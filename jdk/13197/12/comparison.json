{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -685,1 +685,1 @@\n-            if (ReflectUtil.isNonPublicProxyClass(cls)) {\n+            if (ReflectUtil.isNonPublicProxyClass(cls) || ReflectUtil.isMethodHandleProxiesClass(cls)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,9 @@\n-import java.lang.reflect.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.nio.file.Path;\n+import java.security.AccessControlContext;\n@@ -31,0 +39,9 @@\n+import java.security.ProtectionDomain;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n@@ -34,3 +51,5 @@\n-import sun.invoke.WrapperInstance;\n-import java.util.ArrayList;\n-\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.misc.VM;\n+import jdk.internal.module.Modules;\n@@ -39,0 +58,3 @@\n+import jdk.internal.util.ClassFileDumper;\n+import sun.invoke.WrapperInstance;\n+import sun.invoke.empty.Empty;\n@@ -40,0 +62,2 @@\n+\n+import static java.lang.constant.ConstantDescs.*;\n@@ -41,0 +65,3 @@\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -64,1 +91,2 @@\n-     * The interface must be public and not {@linkplain Class#isSealed() sealed}.\n+     * The interface must be public, not {@linkplain Class#isHidden() hidden},\n+     * and not {@linkplain Class#isSealed() sealed}.\n@@ -157,0 +185,16 @@\n+    \/*\n+     * Discussion:\n+     * Since project leyden aims to improve startup speed, asInterfaceInstance\n+     * will share one implementation class for each interface than one implementation\n+     * class for each method handle. This is good for use cases where multiple distinct\n+     * method handles are converted into one interface stored in a collection, where each\n+     * instance is invoked rarely (or only once), such as property getters on a bean.\n+     *\n+     * Using super-customized implementation classes for each method handle would\n+     * allow constant-folding of calls through the returned instance, but it comes with\n+     * a huge class definition overhead for each instance and is not feasible for rare\n+     * invocation use cases like above.\n+     *\n+     * The shared-class implementation is also closer in behavior to the original\n+     * proxy-backed implementation. We might add another API for super-customized instances.\n+     *\/\n@@ -165,0 +209,5 @@\n+        if (intfc.isHidden())\n+            throw newIllegalArgumentException(\"a hidden interface\", intfc.getName());\n+        if (!VM.isModuleSystemInited())\n+            throw newInternalError(\"asInterfaceInstance is not supported until module system is initialized\");\n+        Objects.requireNonNull(target);\n@@ -174,36 +223,66 @@\n-        ClassLoader proxyLoader = intfc.getClassLoader();\n-        if (proxyLoader == null) {\n-            ClassLoader cl = Thread.currentThread().getContextClassLoader(); \/\/ avoid use of BCP\n-            proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();\n-        }\n-        final Method[] methods = getSingleNameMethods(intfc);\n-        if (methods == null)\n-            throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n-        final MethodHandle[] vaTargets = new MethodHandle[methods.length];\n-        for (int i = 0; i < methods.length; i++) {\n-            Method sm = methods[i];\n-            MethodType smMT = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());\n-            MethodHandle checkTarget = mh.asType(smMT);  \/\/ make throw WMT\n-            checkTarget = checkTarget.asType(checkTarget.type().changeReturnType(Object.class));\n-            vaTargets[i] = checkTarget.asSpreader(Object[].class, smMT.parameterCount());\n-        }\n-        final InvocationHandler ih = new InvocationHandler() {\n-                private Object getArg(String name) {\n-                    if ((Object)name == \"getWrapperInstanceTarget\")  return target;\n-                    if ((Object)name == \"getWrapperInstanceType\")    return intfc;\n-                    throw new AssertionError();\n-                }\n-                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                    for (int i = 0; i < methods.length; i++) {\n-                        if (method.equals(methods[i]))\n-                            return vaTargets[i].invokeExact(args);\n-                    }\n-                    if (method.getDeclaringClass() == WrapperInstance.class)\n-                        return getArg(method.getName());\n-                    if (isObjectMethod(method))\n-                        return callObjectMethod(proxy, method, args);\n-                    if (isDefaultMethod(method)) {\n-                        \/\/ no additional access check is performed\n-                        return JLRA.invokeDefault(proxy, method, args, null);\n-                    }\n-                    throw newInternalError(\"bad proxy method: \"+method);\n+\n+        \/*\n+         * For each interface I define a new hidden class and pass the\n+         *\n+         * The bytecode is generated only once.  One hidden class is defined\n+         * for each invocation of MethodHandleProxies::asInterfaceInstance(I, MH).\n+         * Therefore, one or more hidden classes may be defined for I.\n+         *\n+         * All the hidden classes defined for I are defined in a dynamic module M\n+         * which has access to the types referenced by the members of I including\n+         * the parameter types, return type and exception types.\n+         *\/\n+        ProxyClassInfo pci = PROXY_CLASS_INFOS.get(intfc); \/\/ throws IllegalArgumentException\n+\n+        Object proxy;\n+\/\/        if (System.getSecurityManager() != null) {\n+\/\/            proxy = AccessController.doPrivileged((PrivilegedAction<?>) () -> {\n+\/\/                try {\n+\/\/                    return pci.constructor.invokeExact(pci.originalLookup, target, mh);\n+\/\/                } catch (Throwable e) {\n+\/\/                    throw uncaughtException(e);\n+\/\/                }\n+\/\/            });\n+\/\/        } else {\n+            try {\n+                proxy = pci.constructor.invokeExact(pci.originalLookup, target, mh);\n+            } catch (Throwable e) {\n+                throw uncaughtException(e);\n+            }\n+\/\/        }\n+\n+        assert proxy.getClass().getModule().isNamed() : proxy.getClass() + \" \" + proxy.getClass().getModule();\n+        return intfc.cast(proxy);\n+    }\n+\n+    private record LocalMethodInfo(MethodTypeDesc desc, List<ClassDesc> thrown, String fieldName) {}\n+\n+    private record ProxyClassInfo(MethodHandle constructor, Lookup originalLookup) {}\n+\n+    private static final ClassFileDumper DUMPER = ClassFileDumper.getInstance(\n+            \"jdk.invoke.MethodHandleProxies.dumpClassFiles\", Path.of(\"DUMP_MH_PROXY_CLASSFILES\"));\n+\n+    \/*\n+     * A map from a given interface to the ProxyClassDefiner.\n+     * This creates a dynamic module for each interface.\n+     *\/\n+    private static final ClassValue<ProxyClassInfo> PROXY_CLASS_INFOS = new ClassValue<>() {\n+        @Override\n+        protected ProxyClassInfo computeValue(Class<?> intfc) {\n+\n+            final SamInfo stats = getStats(intfc);\n+            if (stats == null)\n+                throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n+\n+            List<LocalMethodInfo> infos = new ArrayList<>(stats.methods.size());\n+            for (int i = 0; i < stats.methods.size(); i++) {\n+                String fieldName = \"m\" + i;\n+                Method m = stats.methods.get(i);\n+                MethodType mt = methodType(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m));\n+                MethodTypeDesc mtDesc = desc(mt);\n+                var thrown = JLRA.getExecutableSharedExceptionTypes(m);\n+                if (thrown.length == 0) {\n+                    infos.add(new LocalMethodInfo(mtDesc, DEFAULT_RETHROWS, fieldName));\n+                } else {\n+                    infos.add(new LocalMethodInfo(mtDesc, Stream.concat(DEFAULT_RETHROWS.stream(),\n+                            Arrays.stream(thrown).map(MethodHandleProxies::desc)).distinct().toList(), fieldName));\n@@ -211,1 +290,1 @@\n-            };\n+            }\n@@ -213,11 +292,94 @@\n-        final Object proxy;\n-        if (System.getSecurityManager() != null) {\n-            \/\/ sun.invoke.WrapperInstance is a restricted interface not accessible\n-            \/\/ by any non-null class loader.\n-            final ClassLoader loader = proxyLoader;\n-            proxy = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Object run() {\n-                    return Proxy.newProxyInstance(\n-                            loader,\n-                            new Class<?>[]{ intfc, WrapperInstance.class },\n-                            ih);\n+            Set<Class<?>> referencedTypes = stats.referencedTypes;\n+            Module targetModule = newDynamicModule(intfc.getClassLoader(), referencedTypes);\n+\n+            \/\/ generate a class file in the package of the dynamic module\n+            String pn = targetModule.getName();\n+            String n = intfc.getName() + \"$MHProxy\";\n+            int i = n.lastIndexOf('.');\n+            String cn = i > 0 ? pn + \".\" + n.substring(i+1) : pn + \".\" + n;\n+            ClassDesc proxyDesc = ClassDesc.of(cn);\n+            byte[] template = createTemplate(proxyDesc, desc(intfc), stats.singleName, infos);\n+            var definer = new Lookup(intfc).makeHiddenClassDefiner(cn, template, Set.of(), DUMPER);\n+            Lookup lookup;\n+\n+            @SuppressWarnings(\"removal\")\n+            var sm = System.getSecurityManager();\n+            if (sm != null) {\n+                @SuppressWarnings(\"removal\")\n+                var l = AccessController.doPrivileged((PrivilegedAction<Lookup>) () -> definer.defineClassAsLookup(true));\n+                lookup = l;\n+            } else {\n+                lookup = definer.defineClassAsLookup(true);\n+            }\n+\n+            MethodHandle constructor;\n+            try {\n+                constructor = lookup.findConstructor(lookup.lookupClass(), MT_void_Lookup_MethodHandle_MethodHandle)\n+                        .asType(MT_Object_Lookup_MethodHandle_MethodHandle);\n+            } catch (Throwable ex) {\n+                throw uncaughtException(ex);\n+            }\n+            return new ProxyClassInfo(constructor, lookup);\n+        }\n+    };\n+\n+    private static final List<ClassDesc> DEFAULT_RETHROWS = List.of(desc(RuntimeException.class), desc(Error.class));\n+    private static final ClassDesc CD_UndeclaredThrowableException = desc(UndeclaredThrowableException.class);\n+    private static final ClassDesc CD_WrapperInstance = desc(WrapperInstance.class);\n+    private static final ClassDesc CD_Empty = desc(Empty.class);\n+    private static final MethodTypeDesc MTD_MethodHandle_Empty = MethodTypeDesc.of(CD_MethodHandle, CD_Empty);\n+    private static final MethodTypeDesc MTD_Class_Empty = MethodTypeDesc.of(CD_Class, CD_Empty);\n+    private static final MethodTypeDesc MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable);\n+    private static final MethodType MT_void_Lookup_MethodHandle_MethodHandle = methodType(void.class, Lookup.class, MethodHandle.class, MethodHandle.class);\n+    private static final MethodType MT_Object_Lookup_MethodHandle_MethodHandle = MT_void_Lookup_MethodHandle_MethodHandle.changeReturnType(Object.class);\n+    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle = desc(MT_void_Lookup_MethodHandle_MethodHandle);\n+    private static final MethodTypeDesc MTD_void_Lookup_Class = MethodTypeDesc.of(CD_void, CD_MethodHandles_Lookup, CD_Class);\n+    private static final MethodTypeDesc MTD_MethodHandle_MethodType = MethodTypeDesc.of(CD_MethodHandle, CD_MethodType);\n+    private static final String ORIGINAL_TARGET_NAME = \"originalTarget\";\n+\n+    \/**\n+     * Creates an implementation class file for a given interface. One implementation class is\n+     * defined for each method handle, with the same bytes but different class data:\n+     * [interfaceInfo, wrapperInstanceTarget, methodtype1, methodtype2, ...]\n+     *\n+     * @param ifaceDesc the given interface\n+     * @param methodName the name of the single abstract method\n+     * @param methods the information for implementation methods\n+     * @return the bytes of the implementation classes\n+     *\/\n+    private static byte[] createTemplate(ClassDesc proxyDesc, ClassDesc ifaceDesc, String methodName, List<LocalMethodInfo> methods) {\n+        return Classfile.build(proxyDesc, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(ifaceDesc, CD_WrapperInstance);\n+\n+            \/\/ individual handle fields\n+            clb.withField(ORIGINAL_TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            for (var mi : methods) {\n+                clb.withField(mi.fieldName, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            }\n+\n+            \/\/ <init>(Lookup, MethodHandle originalHandle, MethodHandle implHandle)\n+            clb.withMethodBody(INIT_NAME, MTD_void_Lookup_MethodHandle_MethodHandle, 0, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+\n+                \/\/ WrapperInstance.ensureOriginalLookup\n+                cob.aload(1);\n+                cob.constantInstruction(proxyDesc);\n+                cob.invokestatic(CD_WrapperInstance, \"ensureOriginalLookup\", MTD_void_Lookup_Class, true);\n+\n+                \/\/ keep original target\n+                \/\/ this.originalTarget = originalHandle;\n+                cob.aload(0);\n+                cob.aload(2);\n+                cob.putfield(proxyDesc, ORIGINAL_TARGET_NAME, CD_MethodHandle);\n+\n+                \/\/ convert individual handles\n+                for (var mi : methods) {\n+                    \/\/ this.handleField = implHandle.asType(xxType);\n+                    cob.aload(0);\n+                    cob.aload(3);\n+                    cob.constantInstruction(mi.desc);\n+                    cob.invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType);\n+                    cob.putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n@@ -225,0 +387,3 @@\n+\n+                \/\/ complete\n+                cob.return_();\n@@ -226,6 +391,41 @@\n-        } else {\n-            proxy = Proxy.newProxyInstance(proxyLoader,\n-                                           new Class<?>[]{ intfc, WrapperInstance.class },\n-                                           ih);\n-        }\n-        return intfc.cast(proxy);\n+\n+            \/\/ implementation methods\n+            for (LocalMethodInfo mi : methods) {\n+                \/\/ we don't need to generate thrown exception attribute\n+                clb.withMethodBody(methodName, mi.desc, ACC_PUBLIC, cob -> cob\n+                        .trying(bcb -> {\n+                                    \/\/ return this.handleField.invokeExact(arguments...);\n+                                    bcb.aload(0);\n+                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                                    for (int j = 0; j < mi.desc.parameterCount(); j++) {\n+                                        bcb.loadInstruction(TypeKind.from(mi.desc.parameterType(j)), bcb.parameterSlot(j));\n+                                    }\n+                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc);\n+                                    bcb.returnInstruction(TypeKind.from(mi.desc.returnType()));\n+                                }, ctb -> ctb\n+                                        \/\/ catch (Error | RuntimeException | Declared ex) { throw ex; }\n+                                        .catchingMulti(mi.thrown, CodeBuilder::athrow)\n+                                        \/\/ catch (Throwable ex) { throw new UndeclaredThrowableException(ex); }\n+                                        .catchingAll(cb -> cb\n+                                                .new_(CD_UndeclaredThrowableException)\n+                                                .dup_x1()\n+                                                .swap()\n+                                                .invokespecial(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable)\n+                                                .athrow()\n+                                        )\n+                        ));\n+            }\n+\n+            \/\/ WrapperInstance hooks\n+            \/\/ getWrapperInstanceTarget\n+            clb.withMethodBody(\"getWrapperInstanceTarget\", MTD_MethodHandle_Empty, ACC_PUBLIC, cob -> cob\n+                    \/\/ return this.originalTarget;\n+                    .aload(0)\n+                    .getfield(proxyDesc, ORIGINAL_TARGET_NAME, CD_MethodHandle)\n+                    .areturn());\n+            \/\/ getWrapperInstanceType\n+            clb.withMethodBody(\"getWrapperInstanceType\", MTD_Class_Empty, ACC_PUBLIC, cob -> cob\n+                    \/\/ return ifaceDesc.class;\n+                    .constantInstruction(ifaceDesc)\n+                    .areturn());\n+        });\n@@ -248,6 +448,4 @@\n-        try {\n-            if (x != null)\n-                return (WrapperInstance) x;\n-        } catch (ClassCastException ex) {\n-        }\n-        throw newIllegalArgumentException(\"not a wrapper instance\");\n+        if (x instanceof WrapperInstance wrapperInstance)\n+            return wrapperInstance;\n+\n+        throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n@@ -266,1 +464,1 @@\n-        return asWrapperInstance(x).getWrapperInstanceTarget();\n+        return asWrapperInstance(x).getWrapperInstanceTarget(null);\n@@ -278,1 +476,48 @@\n-        return asWrapperInstance(x).getWrapperInstanceType();\n+        return asWrapperInstance(x).getWrapperInstanceType(null);\n+    }\n+\n+    private static ClassDesc desc(Class<?> cl) {\n+        return cl.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert class \"\n+                + cl.getName() + \" to a constant\"));\n+    }\n+\n+    private static MethodTypeDesc desc(MethodType mt) {\n+        return mt.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert method type \"\n+                + mt + \" to a constant\"));\n+    }\n+\n+    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+    private static final AtomicInteger counter = new AtomicInteger();\n+\n+    private static String nextModuleName() {\n+        return \"jdk.MHProxy\" + counter.incrementAndGet();\n+    }\n+\n+    \/**\n+     * Create a dynamic module defined to the given class loader and has\n+     * access to the given types.\n+     * <p>\n+     * The dynamic module contains only one single package named the same as\n+     * the name of the dynamic module.  It's not exported or open.\n+     *\/\n+    private static Module newDynamicModule(ClassLoader ld, Set<Class<?>> types) {\n+        Objects.requireNonNull(types);\n+\n+        \/\/ create a dynamic module and setup module access\n+        String mn = nextModuleName();\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                .packages(Set.of(mn))\n+                .build();\n+\n+        Module dynModule = Modules.defineModule(ld, descriptor, null);\n+        Module javaBase = Object.class.getModule();\n+\n+        Modules.addReads(dynModule, javaBase);\n+        Modules.addOpens(dynModule, mn, javaBase);\n+\n+        ensureAccess(dynModule, WrapperInstance.class);\n+        ensureAccess(dynModule, Empty.class);\n+        for (Class<?> c : types) {\n+            ensureAccess(dynModule, c);\n+        }\n+        return dynModule;\n@@ -284,1 +529,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -286,1 +531,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -288,2 +533,2 @@\n-                               && m.getParameterCount() == 1\n-                               && m.getParameterTypes()[0] == Object.class;\n+                    && m.getParameterCount() == 1\n+                    && JLRA.getExecutableSharedParameterTypes(m)[0] == Object.class;\n@@ -294,8 +539,8 @@\n-    private static Object callObjectMethod(Object self, Method m, Object[] args) {\n-        assert(isObjectMethod(m)) : m;\n-        return switch (m.getName()) {\n-            case \"toString\" -> java.util.Objects.toIdentityString(self);\n-            case \"hashCode\" -> System.identityHashCode(self);\n-            case \"equals\"   -> (self == args[0]);\n-            default -> null;\n-        };\n+    \/**\n+     * Stores the result of iteration over methods in a given single-abstract-method interface.\n+     *\n+     * @param singleName the single abstract method's name in the given interface\n+     * @param methods the abstract methods to implement in the given interface\n+     * @param referencedTypes a set of types that are referenced by the instance methods of the given interface\n+     *\/\n+    private record SamInfo(String singleName, List<Method> methods, Set<Class<?>> referencedTypes) {\n@@ -304,1 +549,8 @@\n-    private static Method[] getSingleNameMethods(Class<?> intfc) {\n+    \/*\n+     * Returns null if given interface is not SAM\n+     *\/\n+    private static SamInfo getStats(Class<?> intfc) {\n+        if (!intfc.isInterface()) {\n+            throw new IllegalArgumentException(intfc + \" not an inteface\");\n+        }\n+\n@@ -306,0 +558,2 @@\n+        var types = new HashSet<Class<?>>();\n+        types.add(intfc);\n@@ -308,2 +562,12 @@\n-            if (isObjectMethod(m))  continue;\n-            if (!Modifier.isAbstract(m.getModifiers()))  continue;\n+            if (Modifier.isStatic(m.getModifiers()))\n+                continue;\n+\n+            if (isObjectMethod(m))\n+                continue; \/\/ covered by java.base reads\n+\n+            addElementType(types, m.getReturnType());\n+            addElementTypes(types, JLRA.getExecutableSharedParameterTypes(m));\n+            addElementTypes(types, JLRA.getExecutableSharedExceptionTypes(m));\n+\n+            if (!Modifier.isAbstract(m.getModifiers()))\n+                continue;\n@@ -317,2 +581,20 @@\n-        if (uniqueName == null)  return null;\n-        return methods.toArray(new Method[methods.size()]);\n+\n+        if (uniqueName == null)\n+            return null;\n+\n+        return new SamInfo(uniqueName, methods, types);\n+    }\n+\n+    \/*\n+     * Ensure the given module can access the given class.\n+     *\/\n+    private static void ensureAccess(Module target, Class<?> c) {\n+        Module m = c.getModule();\n+        \/\/ add read edge and qualified export for the target module to access\n+        if (!target.canRead(m)) {\n+            Modules.addReads(target, m);\n+        }\n+        String pn = c.getPackageName();\n+        if (!m.isExported(pn, target)) {\n+            Modules.addExports(m, pn, target);\n+        }\n@@ -321,2 +603,4 @@\n-    private static boolean isDefaultMethod(Method m) {\n-        return !Modifier.isAbstract(m.getModifiers());\n+    private static void addElementTypes(Set<Class<?>> types, Class<?>... classes) {\n+        for (var cls : classes) {\n+            addElementType(types, cls);\n+        }\n@@ -325,1 +609,10 @@\n-    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+    private static void addElementType(Set<Class<?>> types, Class<?> cls) {\n+        Class<?> e = cls;\n+        while (e.isArray()) {\n+            e = e.getComponentType();\n+        }\n+\n+        if (!e.isPrimitive()) {\n+            types.add(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":381,"deletions":88,"binary":false,"changes":469,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,4 @@\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex) {\n+        return ex.getSharedExceptionTypes();\n+    }\n+\n@@ -130,5 +134,0 @@\n-\n-    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n-            throws Throwable {\n-        return Proxy.invokeDefault(proxy, method, args, caller);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,3 @@\n+    \/** Gets the shared array of exception types of an Executable. *\/\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex);\n+\n@@ -105,7 +108,0 @@\n-\n-    \/** Invokes the given default method if the method's declaring interface is\n-     *  accessible to the given caller.  Otherwise, IllegalAccessException will\n-     *  be thrown.  If the caller is null, no access check is performed.\n-     *\/\n-    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n-        throws Throwable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -52,2 +54,10 @@\n-                public InputStream apply(ClassDesc classDesc) {\n-                    return ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                @SuppressWarnings(\"removal\")\n+                public InputStream apply(final ClassDesc classDesc) {\n+                    var sm = System.getSecurityManager();\n+                    if (sm == null) {\n+                        return ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                    } else {\n+                        PrivilegedAction<InputStream> pa =\n+                                () -> ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                        return AccessController.doPrivileged(pa);\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,48 +1,62 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.invoke;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Private API used inside of java.lang.invoke.MethodHandles.\n- * Interface implemented by every object which is produced by\n- * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance MethodHandleProxies.asInterfaceInstance}.\n- * The methods of this interface allow a caller to recover the parameters\n- * to {@code asInstance}.\n- * This allows applications to repeatedly convert between method handles\n- * and SAM objects, without the risk of creating unbounded delegation chains.\n- *\/\n-public interface WrapperInstance {\n-    \/** Produce or recover a target method handle which is behaviorally\n-     *  equivalent to the SAM method of this object.\n-     *\/\n-    public MethodHandle getWrapperInstanceTarget();\n-    \/** Recover the SAM type for which this object was created.\n-     *\/\n-    public Class<?> getWrapperInstanceType();\n-}\n-\n+\/*\r\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package sun.invoke;\r\n+\r\n+import sun.invoke.empty.Empty;\r\n+\r\n+import java.lang.invoke.MethodHandle;\r\n+import java.lang.invoke.MethodHandles;\r\n+\r\n+\/**\r\n+ * Private API used inside of java.lang.invoke.MethodHandles.\r\n+ * Interface implemented by every object which is produced by\r\n+ * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance\r\n+ * MethodHandleProxies.asInterfaceInstance}.\r\n+ * The methods of this interface allow a caller to recover the parameters\r\n+ * to {@code asInstance}.\r\n+ * This allows applications to repeatedly convert between method handles\r\n+ * and SAM objects, without the risk of creating unbounded delegation chains.\r\n+ * The methods have an empty parameter to avoid accidental clashes with\r\n+ * the implemented SAM methods.\r\n+ *\/\r\n+public interface WrapperInstance {\r\n+    \/**\r\n+     * Called by proxies implementation to ensure the constructor is called by proper callers.\r\n+     *\/\r\n+    static void ensureOriginalLookup(MethodHandles.Lookup lookup, Class<?> lookupClass) throws IllegalAccessException {\r\n+        if (lookup.lookupClass() != lookupClass || (lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL) == 0) {\r\n+            throw new IllegalAccessException(\"Illegal caller to \" + lookupClass + \": \" + lookup);\r\n+        }\r\n+    }\r\n+\r\n+    \/** Produce or recover a target method handle which is behaviorally\r\n+     *  equivalent to the SAM method of this object.\r\n+     *\/\r\n+    MethodHandle getWrapperInstanceTarget(Empty empty);\r\n+    \/** Recover the SAM type for which this object was created.\r\n+     *\/\r\n+    Class<?> getWrapperInstanceType(Empty empty);\r\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/WrapperInstance.java","additions":62,"deletions":48,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import sun.invoke.WrapperInstance;\n@@ -270,0 +271,9 @@\n+    \/**\n+     * Test if the given class is a method handle proxy class.\n+     * Such proxy classes may access certain java.base internal\n+     * packages exported to its dynamic module.\n+     *\/\n+    public static boolean isMethodHandleProxiesClass(Class<?> cls) {\n+        return WrapperInstance.class.isAssignableFrom(cls);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6983726\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ * @summary Basic sanity tests for MethodHandleProxies\n+ * @build BasicTest Untrusted\n+ * @run junit BasicTest\n+ *\/\n+\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.ToLongFunction;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+public class BasicTest {\n+\n+    @Test\n+    public void testUsual() throws Throwable {\n+        AtomicInteger ai = new AtomicInteger(5);\n+        var mh = MethodHandles.lookup().findVirtual(AtomicInteger.class, \"getAndIncrement\", methodType(int.class));\n+        IntSupplier is = asInterfaceInstance(IntSupplier.class, mh.bindTo(ai));\n+        assertEquals(5, is.getAsInt());\n+        assertEquals(6, is.getAsInt());\n+        assertEquals(7, is.getAsInt());\n+    }\n+\n+    @Test\n+    public void testThrowables() throws Throwable {\n+        \/\/ don't wrap\n+        assertThrows(Error.class, throwing(Error.class, new Error())::close);\n+        assertThrows(RuntimeException.class, throwing(RuntimeException.class, new RuntimeException())::close);\n+        assertThrows(IOException.class, throwing(IOException.class, new IOException())::close);\n+        \/\/ wrap\n+        assertThrows(UndeclaredThrowableException.class, throwing(IllegalAccessException.class,\n+                new IllegalAccessException())::close);\n+    }\n+\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        Comparator<Integer> lambda = Integer::compareTo;\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertFalse(isWrapperInstance(lambda));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(lambda));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(lambda));\n+    }\n+\n+    private <T extends Throwable> Closeable throwing(Class<T> clz, T value) {\n+        return asInterfaceInstance(Closeable.class, MethodHandles.throwException(void.class, clz).bindTo(value));\n+    }\n+\n+    private static long mul(int i) {\n+        return (long) i * i;\n+    }\n+\n+    @Test\n+    public void testConversion() throws Throwable {\n+        var mh = MethodHandles.lookup().findStatic(BasicTest.class, \"mul\", methodType(long.class, int.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Function<Integer, Long> func = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh);\n+        assertEquals(32423432L * 32423432L, func.apply(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        ToLongFunction<Integer> func1 = (ToLongFunction<Integer>) asInterfaceInstance(ToLongFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func1.applyAsLong(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        IntFunction<Long> func2 = (IntFunction<Long>) asInterfaceInstance(IntFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func2.apply(32423432));\n+    }\n+\n+    @Test\n+    public void testSameModule() throws Throwable {\n+        var mh = MethodHandles.lookup().findStatic(BasicTest.class, \"mul\", methodType(long.class, int.class));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Function<Integer, Long> func1 = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh);\n+        assertEquals(32423432L * 32423432L, func1.apply(32423432));\n+        Class<?> c1 = func1.getClass();\n+        Module m1 = c1.getModule();\n+\n+        String pn = c1.getPackageName();\n+        assertFalse(m1.isExported(pn));\n+        assertTrue(m1.isExported(pn, MethodHandleProxies.class.getModule()));\n+    }\n+\n+    @Test\n+    public void testMultiAbstract() throws Throwable {\n+        var baseAndChild = loadBaseAndChild();\n+        var baseClass = baseAndChild.get(0);\n+        var childClass = baseAndChild.get(1);\n+        checkMethods(childClass.getMethods());\n+        checkMethods(childClass.getDeclaredMethods());\n+\n+        var lookup = MethodHandles.lookup();\n+        var baseValueMh = lookup.findVirtual(baseClass, \"value\", genericMethodType(0))\n+                .asType(genericMethodType(1));\n+        var childIntegerValueMh = lookup.findVirtual(childClass, \"value\", methodType(Integer.class))\n+                .asType(methodType(Integer.class, Object.class));\n+        var childIntValueMh = lookup.findVirtual(childClass, \"value\", methodType(int.class))\n+                .asType(methodType(int.class, Object.class));\n+\n+        Object child = asInterfaceInstance(childClass, MethodHandles.constant(Integer.class, 7));\n+\n+        assertEquals(7, (Object) baseValueMh.invokeExact(child));\n+        assertEquals(7, (Integer) childIntegerValueMh.invokeExact(child));\n+        assertEquals(7, (int) childIntValueMh.invokeExact(child));\n+    }\n+\n+    @Test\n+    public void testRejects() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(Inaccessible.class, mh));\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(loadHidden(), mh));\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(MultiAbstractMethods.class, mh));\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(NoAbstractMethods.class, mh));\n+        assertThrows(WrongMethodTypeException.class, () -> asInterfaceInstance(IntSupplier.class, mh));\n+    }\n+\n+    @Test\n+    public void testNoInstantiation() throws IllegalAccessException {\n+        Untrusted untrusted = asInterfaceInstance(Untrusted.class, MethodHandles.zero(void.class));\n+        var instanceClass = untrusted.getClass();\n+        var leakLookup = Untrusted.leakLookup();\n+        assertEquals(Lookup.ORIGINAL, leakLookup.lookupModes() & Lookup.ORIGINAL, \"Leaked lookup original flag\");\n+        assertThrows(IllegalAccessException.class, () -> MethodHandles.privateLookupIn(instanceClass, Untrusted.leakLookup()));\n+    }\n+\n+    void checkMethods(Method[] methods) {\n+        assertTrue(methods.length > 1, () -> \"Should have more than 1 declared methods, found only \" + Arrays.toString(methods));\n+        for (Method method : methods) {\n+            assertTrue(method.accessFlags().contains(AccessFlag.ABSTRACT), () -> method + \" is not abstract\");\n+        }\n+    }\n+\n+    private Class<?> loadHidden() throws IllegalAccessException {\n+        ClassDesc baseCd = ClassDesc.of(\"BasicTest$HiddenItf\");\n+        var objMtd = MethodTypeDesc.of(CD_Object);\n+        var baseBytes = Classfile.build(baseCd, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", objMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var lookup = MethodHandles.lookup();\n+        return lookup.defineHiddenClass(baseBytes, true).lookupClass();\n+    }\n+\n+    \/\/ Base: Object value();\n+    \/\/ Child: Integer value(); int value();\n+    private List<Class<?>> loadBaseAndChild() throws IllegalAccessException {\n+        ClassDesc baseCd = ClassDesc.of(\"BasicTest$Base\");\n+        ClassDesc childCd = ClassDesc.of(\"BasicTest$Child\");\n+        var objMtd = MethodTypeDesc.of(CD_Object);\n+        var integerMtd = MethodTypeDesc.of(CD_Integer);\n+        var intMtd = MethodTypeDesc.of(CD_int);\n+        var chi = ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER.orElse(\n+                ClassHierarchyResolver.of(List.of(baseCd, childCd), Map.ofEntries(Map.entry(baseCd, CD_Object),\n+                        Map.entry(childCd, CD_Object))));\n+\n+        var baseBytes = Classfile.build(baseCd, List.of(Option.classHierarchyResolver(chi)), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", objMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var lookup = MethodHandles.lookup();\n+        var base = lookup.ensureInitialized(lookup.defineClass(baseBytes));\n+\n+        var childBytes = Classfile.build(childCd, List.of(Option.classHierarchyResolver(chi)), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(baseCd);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", integerMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+            clb.withMethod(\"value\", intMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var child = lookup.ensureInitialized(lookup.defineClass(childBytes));\n+        return List.of(base, child);\n+    }\n+\n+    public interface MultiAbstractMethods {\n+        String a();\n+        String b();\n+    }\n+\n+    public interface NoAbstractMethods {\n+        String toString();\n+    }\n+}\n+\n+interface Inaccessible {\n+    Object value();\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @run testng\/othervm -ea -esa test.java.lang.invoke.MethodHandlesProxiesTest\n+ * @run testng test.java.lang.invoke.MethodHandlesProxiesTest\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/MethodHandlesProxiesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n+public interface Untrusted {\n+    \/**\n+     * Leaks a lookup that has full privilege access in Untrusted.class.\n+     *\/\n+    static Lookup leakLookup() {\n+        return MethodHandles.lookup();\n+    }\n+\n+    void exec();\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Untrusted.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 6983726\n+ * @build Untrusted WithSecurityManagerTest\n+ * @run main\/othervm\/policy=jtreg.security.policy WithSecurityManagerTest\n+ * @summary Checks MethodHandleProxies behavior with security manager present\n+ *\/\n+\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+\n+public class WithSecurityManagerTest {\n+    public static void main(String... args) {\n+        var originalMh = MethodHandles.zero(void.class);\n+        Object o = MethodHandleProxies.asInterfaceInstance(Untrusted.class, originalMh);\n+        System.out.println(o);\n+        var untrustedTarget = MethodHandleProxies.wrapperInstanceTarget(o);\n+        assert originalMh == untrustedTarget : \"Got \" + untrustedTarget;\n+\n+        var runnableTarget = MethodHandleProxies.wrapperInstanceTarget(MethodHandleProxies.asInterfaceInstance(Runnable.class, originalMh));\n+        assert originalMh == runnableTarget : \"Got \" + runnableTarget;\n+   }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WithSecurityManagerTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/jtreg.security.policy","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/invoke\/7196190\/jtreg.security.policy","status":"copied"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n-\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-\/**\n- * @test\n- * @summary test MethodHandleProxies that adds qualified export of sun.invoke\n- * from java.base to a dynamic module\n- * @run testng ProxyForMethodHandle\n- *\/\n-public class ProxyForMethodHandle {\n-    \/**\n-     * MethodHandleProxies will add qualified export of sun.invoke from java.base\n-     * to a dynamic module\n-     *\/\n-    @Test\n-    public static void testRunnableMethodHandle() throws Exception {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodType mt = MethodType.methodType(void.class);\n-        MethodHandle mh = lookup.findStatic(ProxyForMethodHandle.class, \"runForRunnable\", mt);\n-        Runnable proxy = MethodHandleProxies.asInterfaceInstance(Runnable.class, mh);\n-        proxy.run();\n-\n-        Class<?> proxyClass = proxy.getClass();\n-        Module target = proxyClass.getModule();\n-        assertDynamicModule(target, proxyClass.getClassLoader(), proxyClass);\n-    }\n-\n-    static void runForRunnable() {\n-        System.out.println(\"runForRunnable\");\n-    }\n-\n-    public static void assertDynamicModule(Module m, ClassLoader ld, Class<?> proxyClass) {\n-        if (!m.isNamed() || !m.getName().startsWith(\"jdk.proxy\")) {\n-            throw new RuntimeException(m.getName() + \" not dynamic module\");\n-        }\n-\n-        if (ld != m.getClassLoader() || proxyClass.getClassLoader() != ld) {\n-            throw new RuntimeException(\"unexpected class loader\");\n-        }\n-\n-        try {\n-            Constructor<?> cons = proxyClass.getConstructor(InvocationHandler.class);\n-            cons.newInstance(handler);\n-            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n-        } catch (IllegalAccessException e) {\n-            \/\/ expected\n-        } catch (NoSuchMethodException|InstantiationException|InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    private final static InvocationHandler handler =\n-            (proxy, m, params) -> { throw new RuntimeException(m.toString()); };\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyForMethodHandle.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @modules java.base\/sun.invoke\n@@ -40,3 +39,0 @@\n-        \/\/ unnamed module gets access to sun.invoke package (e.g. via --add-exports)\n-        new ProxyModuleMapping(sun.invoke.WrapperInstance.class).test();\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,124 +1,124 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.invoke;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * Benchmark evaluates the performance of MethodHandleProxies.*\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n-@Fork(3)\n-public class MethodHandleProxiesAsIFInstance {\n-\n-    \/**\n-     * Implementation notes:\n-     *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n-     *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n-     *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n-     *\/\n-\n-    public int i;\n-\n-    private MethodHandle target;\n-    private Doable precreated;\n-\n-    @Setup\n-    public void setup() throws Throwable {\n-        target = MethodHandles.lookup().findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MethodType.methodType(int.class, int.class));\n-        precreated = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-    }\n-\n-    @Benchmark\n-    public Doable testCreate() {\n-        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-        return doable;              \/\/ make sure allocation happens\n-    }\n-\n-    @Benchmark\n-    public Doable testCreateCall() {\n-        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-        i = doable.doWork(i);       \/\/ make sure computation happens\n-        return null;                \/\/ let allocation be eliminated\n-    }\n-\n-    @Benchmark\n-    public Doable testCall() {\n-        i = precreated.doWork(i);   \/\/ make sure computation happens\n-        return precreated;\n-    }\n-\n-    @Benchmark\n-    public Doable baselineCompute() {\n-        Doable doable = new Doable() {\n-            @Override\n-            public int doWork(int i) {\n-                return MethodHandleProxiesAsIFInstance.doWork(i);\n-            }\n-        };\n-\n-        i = doable.doWork(i);       \/\/ make sure computation happens\n-        return null;                \/\/ let allocation be eliminated\n-    }\n-\n-    @Benchmark\n-    public Doable baselineAllocCompute() {\n-        Doable doable = new Doable() {\n-            @Override\n-            public int doWork(int i) {\n-                return MethodHandleProxiesAsIFInstance.doWork(i);\n-            }\n-        };\n-\n-        i = doable.doWork(i);       \/\/ make sure computation happens\n-        return doable;              \/\/ make sure allocation happens\n-    }\n-\n-    public static int doWork(int i) {\n-        return i + 1;\n-    }\n-\n-    public interface Doable {\n-        int doWork(int i);\n-    }\n-\n-}\n+\/*\r\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+package org.openjdk.bench.java.lang.invoke;\r\n+\r\n+import org.openjdk.jmh.annotations.Benchmark;\r\n+import org.openjdk.jmh.annotations.BenchmarkMode;\r\n+import org.openjdk.jmh.annotations.Fork;\r\n+import org.openjdk.jmh.annotations.Measurement;\r\n+import org.openjdk.jmh.annotations.Mode;\r\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\r\n+import org.openjdk.jmh.annotations.Scope;\r\n+import org.openjdk.jmh.annotations.Setup;\r\n+import org.openjdk.jmh.annotations.State;\r\n+import org.openjdk.jmh.annotations.Warmup;\r\n+\r\n+import java.lang.invoke.MethodHandle;\r\n+import java.lang.invoke.MethodHandleProxies;\r\n+import java.lang.invoke.MethodHandles;\r\n+import java.lang.invoke.MethodType;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+\/**\r\n+ * Benchmark evaluates the performance of MethodHandleProxies.*\r\n+ *\/\r\n+@BenchmarkMode(Mode.AverageTime)\r\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\r\n+@State(Scope.Thread)\r\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\r\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\r\n+@Fork(3)\r\n+public class MethodHandleProxiesAsIFInstance {\r\n+\r\n+\t\/**\r\n+\t * Implementation notes:\r\n+\t *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\r\n+\t *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\r\n+\t *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\r\n+\t *\/\r\n+\r\n+\tpublic int i;\r\n+\r\n+\tprivate MethodHandle target;\r\n+\tprivate Doable precreated;\r\n+\r\n+\t@Setup\r\n+\tpublic void setup() throws Throwable {\r\n+\t\ttarget = MethodHandles.lookup().findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MethodType.methodType(int.class, int.class));\r\n+\t\tprecreated = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable testCreate() {\r\n+\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n+\t\treturn doable;              \/\/ make sure allocation happens\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable testCreateCall() {\r\n+\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n+\t\treturn null;                \/\/ let allocation be eliminated\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable testCall() {\r\n+\t\ti = precreated.doWork(i);   \/\/ make sure computation happens\r\n+\t\treturn precreated;\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable baselineCompute() {\r\n+\t\tDoable doable = new Doable() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic int doWork(int i) {\r\n+\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\r\n+\t\t\t}\r\n+\t\t};\r\n+\r\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n+\t\treturn null;                \/\/ let allocation be eliminated\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable baselineAllocCompute() {\r\n+\t\tDoable doable = new Doable() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic int doWork(int i) {\r\n+\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\r\n+\t\t\t}\r\n+\t\t};\r\n+\r\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n+\t\treturn doable;              \/\/ make sure allocation happens\r\n+\t}\r\n+\r\n+\tpublic static int doWork(int i) {\r\n+\t\treturn i + 1;\r\n+\t}\r\n+\r\n+\tpublic interface Doable {\r\n+\t\tint doWork(int i);\r\n+\t}\r\n+\r\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstance.java","additions":124,"deletions":124,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * Benchmark evaluates the call performance of MethodHandleProxies.asInterfaceInstance\n+ * return value, compared to\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(1)\n+public class MethodHandleProxiesAsIFInstanceCall {\n+    \/**\n+     * Avoids elimination of computation, set up to random value\n+     *\/\n+    public int i;\n+\n+    private static final Lookup LOOKUP = lookup();\n+    private static final MethodType MT_Doable = methodType(Doable.class);\n+    private static final MethodType MT_int_int = methodType(int.class, int.class);\n+\n+    \/\/ intentionally constant-folded\n+    private static final MethodHandle constantTarget;\n+    private static final Doable constantDoable;\n+    private static final Doable constantHandle;\n+    private static final Doable constantInterfaceInstance;\n+    private static final Doable constantLambda;\n+\n+    \/\/ part of state object, non-constant\n+    private MethodHandle target;\n+    private Doable doable;\n+    private Doable handle;\n+    private Doable interfaceInstance;\n+    private Doable lambda;\n+\n+    static {\n+        try {\n+            constantTarget = LOOKUP.findStatic(MethodHandleProxiesAsIFInstanceCall.class, \"doWork\", MT_int_int);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+        constantDoable = new Doable() {\n+            @Override\n+            public int doWork(int i) {\n+                return MethodHandleProxiesAsIFInstanceCall.doWork(i);\n+            }\n+        };\n+        constantHandle = new Doable() {\n+            @Override\n+            public int doWork(int i) {\n+                try {\n+                    return (int) constantTarget.invokeExact((int) i);\n+                } catch (Error | RuntimeException e) {\n+                    throw e;\n+                } catch (Throwable e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+        constantInterfaceInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, constantTarget);\n+        constantLambda = MethodHandleProxiesAsIFInstanceCall::doWork;\n+    }\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        target = constantTarget;\n+        doable = constantDoable;\n+        handle = constantHandle;\n+        interfaceInstance = constantInterfaceInstance;\n+        lambda = constantLambda;\n+        i = ThreadLocalRandom.current().nextInt();\n+    }\n+\n+    @Benchmark\n+    public void direct() {\n+        i = doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void callDoable() {\n+        i = doable.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void callHandle() {\n+        i = handle.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void callInterfaceInstance() {\n+        i = interfaceInstance.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void callLambda() {\n+        i = lambda.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void constantDoable() {\n+        i = constantDoable.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void constantHandle() {\n+        i = constantHandle.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void constantInterfaceInstance() {\n+        i = constantInterfaceInstance.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void constantLambda() {\n+        i = constantLambda.doWork(i);\n+    }\n+\n+    public static int doWork(int i) {\n+        return i + 1;\n+    }\n+\n+    public interface Doable {\n+        int doWork(int i);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCall.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * Benchmark evaluates the performance of MethodHandleProxies.asInterfaceInstance creation performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(1)\n+public class MethodHandleProxiesAsIFInstanceCreate {\n+    \/**\n+     * Avoids elimination of computation, set up to random value\n+     *\/\n+    public int i;\n+\n+    private static final Lookup LOOKUP = lookup();\n+    private static final MethodType MT_Doable = methodType(Doable.class);\n+    private static final MethodType MT_int_int = methodType(int.class, int.class);\n+    private MethodHandle target;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        target = LOOKUP.findStatic(MethodHandleProxiesAsIFInstanceCreate.class, \"doWork\", MT_int_int);\n+        i = ThreadLocalRandom.current().nextInt();\n+    }\n+\n+    @Benchmark\n+    public Doable createLambda() throws Throwable {\n+        return (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n+    }\n+\n+    @Benchmark\n+    public Doable createInterfaceInstance() {\n+        return MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+    }\n+\n+    @Benchmark\n+    public Doable createCallLambda() throws Throwable {\n+        Doable doable = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n+        i = doable.doWork(i);\n+        return doable;\n+    }\n+\n+    @Benchmark\n+    public Doable createCallInterfaceInstance() {\n+        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+        i = doable.doWork(i);\n+        return doable;\n+    }\n+\n+    public static int doWork(int i) {\n+        return i + 1;\n+    }\n+\n+    public interface Doable {\n+        int doWork(int i);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCreate.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}