{"files":[{"patch":"@@ -1020,0 +1020,5 @@\n+  if ((!is_hidden || is_nestmate) && !Reflection::is_same_class_package(lookup_k, ik)) {\n+    \/\/ non-hidden class or nestmate class must be in the same package as the Lookup class\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Lookup class and defined class are in different packages\");\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1663,0 +1663,5 @@\n+\n+            @Override\n+            public boolean isMethodHandleProxiesClass(Class<?> cls) {\n+                return MethodHandleProxies.isWrapperClass(cls);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.ref.SoftReference;\n@@ -35,1 +36,0 @@\n-import java.nio.file.Path;\n@@ -52,1 +52,0 @@\n-import jdk.internal.misc.VM;\n@@ -58,1 +57,0 @@\n-import sun.invoke.empty.Empty;\n@@ -209,2 +207,0 @@\n-        if (!VM.isModuleSystemInited())\n-            throw newInternalError(\"asInterfaceInstance is not supported until module system is initialized\");\n@@ -230,1 +226,1 @@\n-        ProxyClassInfo pci = PROXY_CLASS_INFOS.get(intfc); \/\/ throws IllegalArgumentException\n+        ProxyClassInfo info = getProxyClassInfo(intfc); \/\/ throws IllegalArgumentException\n@@ -234,1 +230,1 @@\n-            proxy = pci.constructor.invokeExact(pci.originalLookup, target, mh);\n+            proxy = info.constructor.invokeExact(info.originalLookup, target, mh);\n@@ -245,1 +241,2 @@\n-    private record ProxyClassInfo(MethodHandle constructor, Lookup originalLookup) {}\n+    private record ProxyClassInfo(MethodHandle constructor, Lookup originalLookup,\n+                                  MethodHandle targetGetter) {}\n@@ -248,1 +245,1 @@\n-            \"jdk.invoke.MethodHandleProxies.dumpClassFiles\", Path.of(\"DUMP_MH_PROXY_CLASSFILES\"));\n+            \"jdk.invoke.MethodHandleProxies.dumpClassFiles\", \"DUMP_MH_PROXY_CLASSFILES\");\n@@ -254,1 +251,1 @@\n-    private static final ClassValue<ProxyClassInfo> PROXY_CLASS_INFOS = new ClassValue<>() {\n+    private static final ClassValue<SoftReference<ProxyClassInfo>> PROXY_CLASS_INFOS = new ClassValue<>() {\n@@ -256,1 +253,1 @@\n-        protected ProxyClassInfo computeValue(Class<?> intfc) {\n+        protected SoftReference<ProxyClassInfo> computeValue(Class<?> intfc) {\n@@ -282,1 +279,1 @@\n-            String n = intfc.getName() + \"$MHProxy\";\n+            String n = intfc.getName();\n@@ -301,0 +298,1 @@\n+            MethodHandle targetGetter;\n@@ -304,0 +302,2 @@\n+                targetGetter = lookup.findGetter(lookup.lookupClass(), ORIGINAL_TARGET_NAME, MethodHandle.class)\n+                        .asType(MT_MethodHandle_Object);\n@@ -307,1 +307,1 @@\n-            return new ProxyClassInfo(constructor, lookup);\n+            return new SoftReference<>(new ProxyClassInfo(constructor, lookup, targetGetter));\n@@ -311,0 +311,11 @@\n+    private static ProxyClassInfo getProxyClassInfo(Class<?> intfc) throws IllegalArgumentException {\n+        while (true) {\n+            var maybeInfo = PROXY_CLASS_INFOS.get(intfc); \/\/ throws IllegalArgumentException\n+            var info = maybeInfo.get();\n+            if (info != null) {\n+                return info;\n+            }\n+            PROXY_CLASS_INFOS.remove(intfc); \/\/ force recomputation\n+        }\n+    }\n+\n@@ -314,3 +325,0 @@\n-    private static final ClassDesc CD_Empty = desc(Empty.class);\n-    private static final MethodTypeDesc MTD_MethodHandle_Empty = MethodTypeDesc.of(CD_MethodHandle, CD_Empty);\n-    private static final MethodTypeDesc MTD_Class_Empty = MethodTypeDesc.of(CD_Class, CD_Empty);\n@@ -320,0 +328,1 @@\n+    private static final MethodType MT_MethodHandle_Object = methodType(MethodHandle.class, Object.class);\n@@ -324,0 +333,1 @@\n+    private static final String ORIGINAL_TYPE_NAME = \"originalType\";\n@@ -327,2 +337,1 @@\n-     * defined for each method handle, with the same bytes but different class data:\n-     * [interfaceInfo, wrapperInstanceTarget, methodtype1, methodtype2, ...]\n+     * defined for each interface.\n@@ -339,1 +348,1 @@\n-            clb.withInterfaceSymbols(ifaceDesc, CD_WrapperInstance);\n+            clb.withInterfaceSymbols(ifaceDesc);\n@@ -342,0 +351,1 @@\n+            clb.withField(ORIGINAL_TYPE_NAME, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -347,0 +357,7 @@\n+            \/\/ <clinit>\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.constantInstruction(ifaceDesc);\n+                cob.putstatic(proxyDesc, ORIGINAL_TYPE_NAME, CD_Class);\n+                cob.return_();\n+            });\n+\n@@ -355,1 +372,1 @@\n-                cob.invokestatic(CD_WrapperInstance, \"ensureOriginalLookup\", MTD_void_Lookup_Class, true);\n+                cob.invokestatic(CD_WrapperInstance, \"ensureOriginalLookup\", MTD_void_Lookup_Class);\n@@ -403,13 +420,0 @@\n-\n-            \/\/ WrapperInstance hooks\n-            \/\/ getWrapperInstanceTarget\n-            clb.withMethodBody(\"getWrapperInstanceTarget\", MTD_MethodHandle_Empty, ACC_PUBLIC, cob -> cob\n-                    \/\/ return this.originalTarget;\n-                    .aload(0)\n-                    .getfield(proxyDesc, ORIGINAL_TARGET_NAME, CD_MethodHandle)\n-                    .areturn());\n-            \/\/ getWrapperInstanceType\n-            clb.withMethodBody(\"getWrapperInstanceType\", MTD_Class_Empty, ACC_PUBLIC, cob -> cob\n-                    \/\/ return ifaceDesc.class;\n-                    .constantInstruction(ifaceDesc)\n-                    .areturn());\n@@ -429,1 +433,1 @@\n-        return x instanceof WrapperInstance;\n+        return isWrapperClass(x.getClass());\n@@ -432,5 +436,6 @@\n-    private static WrapperInstance asWrapperInstance(Object x) {\n-        if (x instanceof WrapperInstance wrapperInstance)\n-            return wrapperInstance;\n-\n-        throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n+    static boolean isWrapperClass(Class<?> cls) {\n+        try {\n+            return WRAPPER_TYPES.get(cls) != null;\n+        } catch (IllegalArgumentException ex) {\n+            return false;\n+        }\n@@ -439,0 +444,30 @@\n+    private static final ClassValue<Class<?>> WRAPPER_TYPES = new ClassValue<>() {\n+        @Override\n+        protected Class<?> computeValue(Class<?> type) {\n+            MethodHandle originalTypeField;\n+            try {\n+                originalTypeField = new Lookup(type).findStaticGetter(type, ORIGINAL_TYPE_NAME, Class.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                return null;\n+            }\n+\n+            Class<?> originalType;\n+            try {\n+                originalType = (Class<?>) originalTypeField.invokeExact();\n+            } catch (Throwable e) {\n+                throw uncaughtException(e);\n+            }\n+\n+            if (originalType == null)\n+                return null;\n+\n+            try {\n+                getProxyClassInfo(originalType); \/\/ throws IAE\n+            } catch (IllegalArgumentException ex) {\n+                return null;\n+            }\n+\n+            return originalType;\n+        }\n+    };\n+\n@@ -449,1 +484,10 @@\n-        return asWrapperInstance(x).getWrapperInstanceTarget(null);\n+        if (!isWrapperInstance(x))\n+            throw new IllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        var getter = getProxyClassInfo(WRAPPER_TYPES.get(x.getClass())).targetGetter;\n+\n+        try {\n+            return (MethodHandle) getter.invokeExact(x);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n@@ -461,1 +505,4 @@\n-        return asWrapperInstance(x).getWrapperInstanceType(null);\n+        if (!isWrapperInstance(x))\n+            throw new IllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        return WRAPPER_TYPES.get(x.getClass());\n@@ -504,1 +551,0 @@\n-        ensureAccess(dynModule, Empty.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":88,"deletions":42,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -176,0 +176,6 @@\n+\n+    \/**\n+     * Checks whether a given class is a MethodHandle proxy instance. It can bypass certain\n+     * security manager package access checks.\n+     *\/\n+    boolean isMethodHandleProxiesClass(Class<?> cls);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import sun.invoke.empty.Empty;\n-\n-import java.lang.invoke.MethodHandle;\n@@ -35,9 +32,1 @@\n- * Interface implemented by every object which is produced by\n- * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance\n- * MethodHandleProxies.asInterfaceInstance}.\n- * The methods of this interface allow a caller to recover the parameters\n- * to {@code asInstance}.\n- * This allows applications to repeatedly convert between method handles\n- * and SAM objects, without the risk of creating unbounded delegation chains.\n- * The methods have an empty parameter to avoid accidental clashes with\n- * the implemented SAM methods.\n+ * Includes utility methods for implementation of MethodHandle proxies.\n@@ -45,1 +34,1 @@\n-public interface WrapperInstance {\n+public final class WrapperInstance {\n@@ -49,1 +38,1 @@\n-    static void ensureOriginalLookup(MethodHandles.Lookup lookup, Class<?> lookupClass) throws IllegalAccessException {\n+    public static void ensureOriginalLookup(MethodHandles.Lookup lookup, Class<?> lookupClass) throws IllegalAccessException {\n@@ -55,7 +44,1 @@\n-    \/** Produce or recover a target method handle which is behaviorally\n-     *  equivalent to the SAM method of this object.\n-     *\/\n-    MethodHandle getWrapperInstanceTarget(Empty empty);\n-    \/** Recover the SAM type for which this object was created.\n-     *\/\n-    Class<?> getWrapperInstanceType(Empty empty);\n+    private WrapperInstance() {}\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/WrapperInstance.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.invoke.MethodHandleProxies;\n@@ -33,0 +34,3 @@\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -271,0 +275,2 @@\n+    public static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n@@ -277,1 +283,1 @@\n-        return WrapperInstance.class.isAssignableFrom(cls);\n+        return JLIA.isMethodHandleProxiesClass(cls);\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-        assertTrue(Object.class.getModule().isExported(\"sun.invoke.empty\", m1));\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\/*\n+ * @test\n+ * @summary test MethodHandleProxies that adds qualified export of sun.invoke\n+ * from java.base to a dynamic module\n+ * @run junit ProxyForMethodHandleTest\n+ *\/\n+public class ProxyForMethodHandleTest {\n+    \/**\n+     * MethodHandleProxies will add qualified export of sun.invoke from java.base\n+     * to a dynamic module\n+     *\/\n+    @Test\n+    public void testRunnableMethodHandle() throws Exception {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodType mt = MethodType.methodType(void.class);\n+        MethodHandle mh = lookup.findStatic(ProxyForMethodHandleTest.class, \"runForRunnable\", mt);\n+        Runnable proxy = MethodHandleProxies.asInterfaceInstance(Runnable.class, mh);\n+        proxy.run();\n+\n+        Class<?> proxyClass = proxy.getClass();\n+        Module target = proxyClass.getModule();\n+        assertDynamicModule(target, proxyClass.getClassLoader(), proxyClass);\n+    }\n+\n+    static void runForRunnable() {\n+        System.out.println(\"runForRunnable\");\n+    }\n+\n+    public static void assertDynamicModule(Module m, ClassLoader ld, Class<?> proxyClass) {\n+        if (!m.isNamed() || !m.getName().startsWith(\"jdk.MHProxy\")) {\n+            throw new RuntimeException(m.getName() + \" not dynamic module\");\n+        }\n+\n+        if (ld != m.getClassLoader() || proxyClass.getClassLoader() != ld) {\n+            throw new RuntimeException(\"unexpected class loader\");\n+        }\n+\n+        try {\n+            Constructor<?> cons = proxyClass.getDeclaredConstructor(MethodHandles.Lookup.class,\n+                    MethodHandle.class, MethodHandle.class);\n+            cons.newInstance(MethodHandles.lookup(), MethodHandles.zero(int.class), MethodHandles.zero(int.class));\n+            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        } catch (NoSuchMethodException|InstantiationException|InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/ProxyForMethodHandleTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}