{"files":[{"patch":"@@ -259,1 +259,3 @@\n-            byte[] template = AccessController.doPrivileged(new PrivilegedAction<byte[]>() {\n+            var sm = System.getSecurityManager();\n+            @SuppressWarnings(\"removal\")\n+            byte[] template = sm != null ? AccessController.doPrivileged(new PrivilegedAction<byte[]>() {\n@@ -264,1 +266,1 @@\n-            });\n+            }) : createTemplate(desc(intfc), methods.get(0).getName(), infos);\n@@ -266,1 +268,0 @@\n-                \/\/= createTemplate(desc(intfc), methods.get(0).getName(), infos);\n@@ -274,0 +275,3 @@\n+            \/\/ WrapperInstance is in non-exported package\n+            @SuppressWarnings(\"removal\")\n+            var sm = System.getSecurityManager();\n@@ -275,1 +279,1 @@\n-            WrapperInstance anno = AccessController.doPrivileged(new PrivilegedAction<>() {\n+            WrapperInstance anno = sm != null ? AccessController.doPrivileged(new PrivilegedAction<>() {\n@@ -280,1 +284,2 @@\n-            });\n+            }) : type.getDeclaredAnnotation(WrapperInstance.class);\n+\n@@ -376,1 +381,1 @@\n-            throw newIllegalArgumentException(\"not a wrapper instance: \" + x);;\n+            throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,26 +1,26 @@\n-\/*\r\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-public interface Untrusted {\r\n-    void exec();\r\n-}\r\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public interface Untrusted {\n+    void exec();\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Untrusted.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-\n@@ -59,5 +58,1 @@\n-     * Implementation notes:\n-     *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n-     *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n-     *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n-     *   - lambda* compares lambda performance with asInterfaceInstance performance\n+     * Avoids elimination of computation\n@@ -65,1 +60,0 @@\n-\n@@ -72,1 +66,1 @@\n-    \/\/ constant-fold\n+    \/\/ intentionally constant-folded\n@@ -74,3 +68,4 @@\n-    private static final Doable constantPrecreatedDoable;\n-    private static final Doable constantPrecreatedInstance;\n-    private static final Doable constantPrecreatedLambda;\n+    private static final Doable constantDoable;\n+    private static final Doable constantHandle;\n+    private static final Doable constantInterfaceInstance;\n+    private static final Doable constantLambda;\n@@ -78,1 +73,1 @@\n-    \/\/ part of state object\n+    \/\/ part of state object, non-constant\n@@ -80,3 +75,4 @@\n-    private Doable precreatedDoable;\n-    private Doable precreatedInstance;\n-    private Doable precreatedLambda;\n+    private Doable doable;\n+    private Doable handle;\n+    private Doable interfaceInstance;\n+    private Doable lambda;\n@@ -90,1 +86,1 @@\n-        constantPrecreatedDoable = new Doable() {\n+        constantDoable = new Doable() {\n@@ -96,2 +92,14 @@\n-        constantPrecreatedInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, constantTarget);\n-        constantPrecreatedLambda = MethodHandleProxiesAsIFInstanceCall::doWork;\n+        constantHandle = new Doable() {\n+            @Override\n+            public int doWork(int i) {\n+                try {\n+                    return (int) constantTarget.invokeExact((int) i);\n+                } catch (Error | RuntimeException e) {\n+                    throw e;\n+                } catch (Throwable e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+        constantInterfaceInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, constantTarget);\n+        constantLambda = MethodHandleProxiesAsIFInstanceCall::doWork;\n@@ -103,1 +111,1 @@\n-        precreatedDoable = new Doable() {\n+        doable = new Doable() {\n@@ -109,3 +117,14 @@\n-        precreatedInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-        precreatedLambda = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n-        ;\n+        handle = new Doable() {\n+            @Override\n+            public int doWork(int i) {\n+                try {\n+                    return (int) target.invokeExact((int) i);\n+                } catch (Error | RuntimeException e) {\n+                    throw e;\n+                } catch (Throwable e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+        interfaceInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+        lambda = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n@@ -115,1 +134,1 @@\n-    public Doable directCall() {\n+    public void direct() {\n@@ -117,1 +136,0 @@\n-        return null;\n@@ -121,3 +139,12 @@\n-    public Doable doableCall() {\n-        i = precreatedDoable.doWork(i);\n-        return precreatedDoable;\n+    public void callDoable() {\n+        i = doable.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void callHandle() {\n+        i = handle.doWork(i);\n+    }\n+\n+    @Benchmark\n+    public void callInterfaceInstance() {\n+        i = interfaceInstance.doWork(i);\n@@ -127,3 +154,2 @@\n-    public Doable interfaceInstanceCall() {\n-        i = precreatedInstance.doWork(i);   \/\/ make sure computation happens\n-        return precreatedInstance;\n+    public void callLambda() {\n+        i = lambda.doWork(i);\n@@ -133,3 +159,2 @@\n-    public Doable lambdaCall() {\n-        i = precreatedLambda.doWork(i); \/\/ make sure computation happens\n-        return precreatedLambda;\n+    public void constantDoable() {\n+        i = constantDoable.doWork(i);\n@@ -139,3 +164,2 @@\n-    public Doable constantDoableCall() {\n-        i = constantPrecreatedDoable.doWork(i);\n-        return constantPrecreatedDoable;\n+    public void constantHandle() {\n+        i = constantHandle.doWork(i);\n@@ -145,3 +169,2 @@\n-    public Doable constantInterfaceInstanceCall() {\n-        i = constantPrecreatedInstance.doWork(i);   \/\/ make sure computation happens\n-        return constantPrecreatedInstance;\n+    public void constantInterfaceInstance() {\n+        i = constantInterfaceInstance.doWork(i);\n@@ -151,3 +174,2 @@\n-    public Doable constantLambdaCall() {\n-        i = constantPrecreatedLambda.doWork(i); \/\/ make sure computation happens\n-        return constantPrecreatedLambda;\n+    public void constantLambda() {\n+        i = constantLambda.doWork(i);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCall.java","additions":65,"deletions":43,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-\n@@ -58,5 +57,1 @@\n-     * Implementation notes:\n-     *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n-     *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n-     *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n-     *   - lambda* compares lambda performance with asInterfaceInstance performance\n+     * Avoids elimination of computation\n@@ -64,1 +59,0 @@\n-\n@@ -78,1 +72,1 @@\n-    public Doable lambdaCreate() throws Throwable {\n+    public Doable createLambda() throws Throwable {\n@@ -83,1 +77,1 @@\n-    public Doable interfaceInstanceCreate() {\n+    public Doable createInterfaceInstance() {\n@@ -88,1 +82,1 @@\n-    public Doable lambdaCreateCall() throws Throwable {\n+    public Doable createCallLambda() throws Throwable {\n@@ -95,1 +89,1 @@\n-    public Doable interfaceInstanceCreateCall() {\n+    public Doable createCallInterfaceInstance() {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCreate.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"}]}