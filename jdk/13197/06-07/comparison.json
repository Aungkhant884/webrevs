{"files":[{"patch":"@@ -196,4 +196,5 @@\n-        var mhs = new MethodHandle[info.types.length + 1];\n-        mhs[0] = target;\n-        for (int i = 1; i < mhs.length; i++) {\n-            mhs[i] = mh.asType(info.types[i - 1]); \/\/ throws WrongMethodTypeException\n+        List<Object> classData = new ArrayList<>(info.types.length + 2);\n+        classData.add(info);\n+        classData.add(target);\n+        for (var methodType : info.types) {\n+            classData.add(mh.asType(methodType)); \/\/ throws WrongMethodTypeException\n@@ -206,1 +207,1 @@\n-                    .defineClassAsLookup(true, List.of(mhs));\n+                    .defineClassAsLookup(true, classData);\n@@ -268,13 +269,0 @@\n-            var interfaces = type.getInterfaces();\n-            if (interfaces.length != 1)\n-                return WrapperInfo.INVALID;\n-\n-            var implementedType = interfaces[0];\n-            InterfaceInfo itfInfo;\n-            try {\n-                itfInfo = INTERFACE_INFOS.get(implementedType);\n-            } catch (IllegalArgumentException ex) {\n-                \/\/ bad interface in WrapperInstance anno, may be attacks\n-                return WrapperInfo.INVALID;\n-            }\n-\n@@ -282,3 +270,5 @@\n-                    && l.size() == itfInfo.types.length + 1\n-                    && l.get(0) instanceof MethodHandle mh) {\n-                return new WrapperInfo(implementedType, mh);\n+                    && l.size() > 2\n+                    && l.get(0) instanceof InterfaceInfo info\n+                    && l.size() == info.types.length + 2\n+                    && l.get(1) instanceof MethodHandle mh) {\n+                return new WrapperInfo(info.lookup.lookupClass(), mh);\n@@ -298,1 +288,1 @@\n-     * [wrapperInstanceTarget, methodtype1, methodtype2, ...]\n+     * [interfaceInfo, wrapperInstanceTarget, methodtype1, methodtype2, ...]\n@@ -318,1 +308,1 @@\n-            int classDataIndex = 1; \/\/ 0 is reserved for wrapper instance target\n+            int classDataIndex = 2; \/\/ 0 is interfaceInfo, 1 is reserved for wrapper instance target\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run junit\/othervm -ea -esa -Djdk.invoke.MethodHandleProxies.dumpInterfaceInstances BasicTest\n+ * @run junit\/othervm -Djdk.invoke.MethodHandleProxies.dumpInterfaceInstances BasicTest\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run testng\/othervm -ea -esa -Djdk.invoke.MethodHandleProxies.dumpInterfaceInstances\n+ * @run testng\/othervm -Djdk.invoke.MethodHandleProxies.dumpInterfaceInstances\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/MethodHandlesProxiesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run main\/othervm\/policy=jtreg.security.policy -ea -esa\n+ * @run main\/othervm\/policy=jtreg.security.policy\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WithSecurityManagerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.concurrent.ThreadLocalRandom;\n@@ -55,1 +56,1 @@\n-@Fork(3)\n+@Fork(1)\n@@ -58,1 +59,1 @@\n-     * Avoids elimination of computation\n+     * Avoids elimination of computation, set up to random value\n@@ -110,21 +111,6 @@\n-        target = LOOKUP.findStatic(MethodHandleProxiesAsIFInstanceCall.class, \"doWork\", MT_int_int);\n-        doable = new Doable() {\n-            @Override\n-            public int doWork(int i) {\n-                return MethodHandleProxiesAsIFInstanceCall.doWork(i);\n-            }\n-        };\n-        handle = new Doable() {\n-            @Override\n-            public int doWork(int i) {\n-                try {\n-                    return (int) target.invokeExact((int) i);\n-                } catch (Error | RuntimeException e) {\n-                    throw e;\n-                } catch (Throwable e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        };\n-        interfaceInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-        lambda = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n+        target = constantTarget;\n+        doable = constantDoable;\n+        handle = constantHandle;\n+        interfaceInstance = constantInterfaceInstance;\n+        lambda = constantLambda;\n+        i = ThreadLocalRandom.current().nextInt();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCall.java","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.concurrent.ThreadLocalRandom;\n@@ -54,1 +55,1 @@\n-@Fork(3)\n+@Fork(1)\n@@ -57,1 +58,1 @@\n-     * Avoids elimination of computation\n+     * Avoids elimination of computation, set up to random value\n@@ -69,0 +70,1 @@\n+        i = ThreadLocalRandom.current().nextInt();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCreate.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}