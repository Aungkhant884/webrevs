{"files":[{"patch":"@@ -1019,2 +1019,5 @@\n-  assert(Reflection::is_same_class_package(lookup_k, ik),\n-         \"lookup class and defined class are in different packages\");\n+\n+  if ((!is_hidden || is_nestmate) && !Reflection::is_same_class_package(lookup_k, ik)) {\n+    \/\/ non-hidden class or nestmate class must be in the same package as the Lookup class\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Lookup class and defined class are in different packages\");\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,8 @@\n-import java.lang.reflect.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.UndeclaredThrowableException;\n@@ -31,0 +38,10 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n@@ -34,3 +51,5 @@\n-import sun.invoke.WrapperInstance;\n-import java.util.ArrayList;\n-\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.module.Modules;\n@@ -39,0 +58,1 @@\n+import jdk.internal.util.ClassFileDumper;\n@@ -40,0 +60,2 @@\n+\n+import static java.lang.constant.ConstantDescs.*;\n@@ -41,0 +63,3 @@\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -64,1 +89,2 @@\n-     * The interface must be public and not {@linkplain Class#isSealed() sealed}.\n+     * The interface must be public, not {@linkplain Class#isHidden() hidden},\n+     * and not {@linkplain Class#isSealed() sealed}.\n@@ -136,23 +162,1 @@\n-    \/\/ Other notes to implementors:\n-    \/\/ <p>\n-    \/\/ No stable mapping is promised between the single-method interface and\n-    \/\/ the implementation class C.  Over time, several implementation\n-    \/\/ classes might be used for the same type.\n-    \/\/ <p>\n-    \/\/ If the implementation is able\n-    \/\/ to prove that a wrapper of the required type\n-    \/\/ has already been created for a given\n-    \/\/ method handle, or for another method handle with the\n-    \/\/ same behavior, the implementation may return that wrapper in place of\n-    \/\/ a new wrapper.\n-    \/\/ <p>\n-    \/\/ This method is designed to apply to common use cases\n-    \/\/ where a single method handle must interoperate with\n-    \/\/ an interface that implements a function-like\n-    \/\/ API.  Additional variations, such as single-abstract-method classes with\n-    \/\/ private constructors, or interfaces with multiple but related\n-    \/\/ entry points, must be covered by hand-written or automatically\n-    \/\/ generated adapter classes.\n-    \/\/\n-    @SuppressWarnings({\"removal\",\n-                       \"doclint:reference\"}) \/\/ cross-module links\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -165,0 +169,3 @@\n+        if (intfc.isHidden())\n+            throw newIllegalArgumentException(\"a hidden interface\", intfc.getName());\n+        Objects.requireNonNull(target);\n@@ -166,1 +173,3 @@\n-        if (System.getSecurityManager() != null) {\n+        @SuppressWarnings(\"removal\")\n+        var sm = System.getSecurityManager();\n+        if (sm != null) {\n@@ -174,4 +183,27 @@\n-        ClassLoader proxyLoader = intfc.getClassLoader();\n-        if (proxyLoader == null) {\n-            ClassLoader cl = Thread.currentThread().getContextClassLoader(); \/\/ avoid use of BCP\n-            proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();\n+\n+        \/\/ Define one hidden class for each interface.  Create an instance of\n+        \/\/ the hidden class for a given target method handle which will be\n+        \/\/ accessed via getfield.  Multiple instances may be created for a\n+        \/\/ hidden class.  This approach allows the generated hidden classes\n+        \/\/ more shareable.\n+        \/\/\n+        \/\/ The implementation class is weakly referenced; a new class is\n+        \/\/ defined if the last one has been garbage collected.\n+        \/\/\n+        \/\/ An alternative approach is to define one hidden class with the\n+        \/\/ target method handle as class data and the target method handle\n+        \/\/ is loaded via ldc\/condy.  If more than one target method handles\n+        \/\/ are used, the extra classes will pollute the same type profiles.\n+        \/\/ In addition, hidden classes without class data is more friendly\n+        \/\/ for pre-generation (shifting the dynamic class generation from\n+        \/\/ runtime to an earlier phrase).\n+        Class<?> proxyClass = getProxyClass(intfc);  \/\/ throws IllegalArgumentException\n+        Lookup lookup = new Lookup(proxyClass);\n+        Object proxy;\n+        try {\n+            MethodHandle constructor = lookup.findConstructor(proxyClass,\n+                                                              MT_void_Lookup_MethodHandle_MethodHandle)\n+                                             .asType(MT_Object_Lookup_MethodHandle_MethodHandle);\n+            proxy = constructor.invokeExact(lookup, target, mh);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n@@ -179,10 +211,14 @@\n-        final Method[] methods = getSingleNameMethods(intfc);\n-        if (methods == null)\n-            throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n-        final MethodHandle[] vaTargets = new MethodHandle[methods.length];\n-        for (int i = 0; i < methods.length; i++) {\n-            Method sm = methods[i];\n-            MethodType smMT = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());\n-            MethodHandle checkTarget = mh.asType(smMT);  \/\/ make throw WMT\n-            checkTarget = checkTarget.asType(checkTarget.type().changeReturnType(Object.class));\n-            vaTargets[i] = checkTarget.asSpreader(Object[].class, smMT.parameterCount());\n+        assert proxy.getClass().getModule().isNamed() : proxy.getClass() + \" \" + proxy.getClass().getModule();\n+        return intfc.cast(proxy);\n+    }\n+\n+    private record MethodInfo(MethodTypeDesc desc, List<ClassDesc> thrown, String fieldName) {}\n+\n+    private static final ClassFileDumper DUMPER = ClassFileDumper.getInstance(\n+            \"jdk.invoke.MethodHandleProxies.dumpClassFiles\", \"DUMP_MH_PROXY_CLASSFILES\");\n+\n+    private static final Set<Class<?>> WRAPPER_TYPES = Collections.newSetFromMap(new WeakHashMap<>());\n+    private static final ClassValue<WeakReferenceHolder<Class<?>>> PROXIES = new ClassValue<>() {\n+        @Override\n+        protected WeakReferenceHolder<Class<?>> computeValue(Class<?> intfc) {\n+            return new WeakReferenceHolder<>(newProxyClass(intfc));\n@@ -190,36 +226,68 @@\n-        final InvocationHandler ih = new InvocationHandler() {\n-                private Object getArg(String name) {\n-                    if ((Object)name == \"getWrapperInstanceTarget\")  return target;\n-                    if ((Object)name == \"getWrapperInstanceType\")    return intfc;\n-                    throw new AssertionError();\n-                }\n-                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                    for (int i = 0; i < methods.length; i++) {\n-                        if (method.equals(methods[i]))\n-                            return vaTargets[i].invokeExact(args);\n-                    }\n-                    if (method.getDeclaringClass() == WrapperInstance.class)\n-                        return getArg(method.getName());\n-                    if (isObjectMethod(method))\n-                        return callObjectMethod(proxy, method, args);\n-                    if (isDefaultMethod(method)) {\n-                        \/\/ no additional access check is performed\n-                        return JLRA.invokeDefault(proxy, method, args, null);\n-                    }\n-                    throw newInternalError(\"bad proxy method: \"+method);\n-                }\n-            };\n-\n-        final Object proxy;\n-        if (System.getSecurityManager() != null) {\n-            \/\/ sun.invoke.WrapperInstance is a restricted interface not accessible\n-            \/\/ by any non-null class loader.\n-            final ClassLoader loader = proxyLoader;\n-            proxy = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Object run() {\n-                    return Proxy.newProxyInstance(\n-                            loader,\n-                            new Class<?>[]{ intfc, WrapperInstance.class },\n-                            ih);\n-                }\n-            });\n+    };\n+\n+    private static Class<?> newProxyClass(Class<?> intfc) {\n+        List<MethodInfo> methods = new ArrayList<>();\n+        Set<Class<?>> referencedTypes = new HashSet<>();\n+        referencedTypes.add(intfc);\n+        String uniqueName = null;\n+        int count = 0;\n+        for (Method m : intfc.getMethods()) {\n+            if (!Modifier.isAbstract(m.getModifiers()))\n+                continue;\n+\n+            if (isObjectMethod(m))\n+                continue;\n+\n+            \/\/ ensure it's SAM interface\n+            String methodName = m.getName();\n+            if (uniqueName == null) {\n+                uniqueName = methodName;\n+            } else if (!uniqueName.equals(methodName)) {\n+                \/\/ too many abstract methods\n+                throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n+            }\n+\n+            \/\/ the field name holding the method handle for this method\n+            String fieldName = \"m\" + count++;\n+            var mt = methodType(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m), true);\n+            var thrown = JLRA.getExecutableSharedExceptionTypes(m);\n+            var exceptionTypeDescs =\n+                    thrown.length == 0 ? DEFAULT_RETHROWS\n+                                       : Stream.concat(DEFAULT_RETHROWS.stream(),\n+                                                       Arrays.stream(thrown).map(MethodHandleProxies::desc))\n+                                               .distinct().toList();\n+            methods.add(new MethodInfo(desc(mt), exceptionTypeDescs, fieldName));\n+\n+            \/\/ find the types referenced by this method\n+            addElementType(referencedTypes, m.getReturnType());\n+            addElementTypes(referencedTypes, JLRA.getExecutableSharedParameterTypes(m));\n+            addElementTypes(referencedTypes, JLRA.getExecutableSharedExceptionTypes(m));\n+        }\n+\n+        if (uniqueName == null)\n+            throw newIllegalArgumentException(\"no method in \", intfc.getName());\n+\n+        \/\/ create a dynamic module for each proxy class, which needs access\n+        \/\/ to the types referenced by the members of the interface including\n+        \/\/ the parameter types, return type and exception types\n+        var loader = intfc.getClassLoader();\n+        Module targetModule = newDynamicModule(loader, referencedTypes);\n+\n+        \/\/ generate a class file in the package of the dynamic module\n+        String packageName = targetModule.getName();\n+        String intfcName = intfc.getName();\n+        int i = intfcName.lastIndexOf('.');\n+        \/\/ jdk.MHProxy#.Interface\n+        String className = packageName + \".\" + (i > 0 ? intfcName.substring(i + 1) : intfcName);\n+        byte[] template = createTemplate(loader, ClassDesc.of(className), desc(intfc), uniqueName, methods);\n+        \/\/ define the dynamic module to the class loader of the interface\n+        var definer = new Lookup(intfc).makeHiddenClassDefiner(className, template, Set.of(), DUMPER);\n+\n+        @SuppressWarnings(\"removal\")\n+        var sm = System.getSecurityManager();\n+        Lookup lookup;\n+        if (sm != null) {\n+            @SuppressWarnings(\"removal\")\n+            var l = AccessController.doPrivileged((PrivilegedAction<Lookup>) () ->\n+                    definer.defineClassAsLookup(true));\n+            lookup = l;\n@@ -227,3 +295,1 @@\n-            proxy = Proxy.newProxyInstance(proxyLoader,\n-                                           new Class<?>[]{ intfc, WrapperInstance.class },\n-                                           ih);\n+            lookup = definer.defineClassAsLookup(true);\n@@ -231,1 +297,178 @@\n-        return intfc.cast(proxy);\n+        \/\/ cache the wrapper type\n+        var ret = lookup.lookupClass();\n+        WRAPPER_TYPES.add(ret);\n+        return ret;\n+    }\n+\n+    private static final class WeakReferenceHolder<T> {\n+        private volatile WeakReference<T> ref;\n+\n+        WeakReferenceHolder(T value) {\n+            set(value);\n+        }\n+\n+        void set(T value) {\n+            ref = new WeakReference<>(value);\n+        }\n+\n+        T get() {\n+            return ref.get();\n+        }\n+    }\n+\n+    private static Class<?> getProxyClass(Class<?> intfc) {\n+        WeakReferenceHolder<Class<?>> r = PROXIES.get(intfc);\n+        Class<?> cl = r.get();\n+        if (cl != null)\n+            return cl;\n+\n+        \/\/ avoid spinning multiple classes in a race\n+        synchronized (r) {\n+            cl = r.get();\n+            if (cl != null)\n+                return cl;\n+\n+            \/\/ If the referent is cleared, create a new value and update cached weak reference.\n+            cl = newProxyClass(intfc);\n+            r.set(cl);\n+            return cl;\n+        }\n+    }\n+\n+    private static final List<ClassDesc> DEFAULT_RETHROWS = List.of(desc(RuntimeException.class), desc(Error.class));\n+    private static final ClassDesc CD_UndeclaredThrowableException = desc(UndeclaredThrowableException.class);\n+    private static final ClassDesc CD_IllegalAccessException = desc(IllegalAccessException.class);\n+    private static final MethodTypeDesc MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable);\n+    private static final MethodType MT_void_Lookup_MethodHandle_MethodHandle =\n+            methodType(void.class, Lookup.class, MethodHandle.class, MethodHandle.class);\n+    private static final MethodType MT_Object_Lookup_MethodHandle_MethodHandle =\n+            MT_void_Lookup_MethodHandle_MethodHandle.changeReturnType(Object.class);\n+    private static final MethodType MT_MethodHandle_Object = methodType(MethodHandle.class, Object.class);\n+    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle =\n+            desc(MT_void_Lookup_MethodHandle_MethodHandle);\n+    private static final MethodTypeDesc MTD_void_Lookup = MethodTypeDesc.of(CD_void, CD_MethodHandles_Lookup);\n+    private static final MethodTypeDesc MTD_MethodHandle_MethodType = MethodTypeDesc.of(CD_MethodHandle, CD_MethodType);\n+    private static final MethodTypeDesc MTD_Class = MethodTypeDesc.of(CD_Class);\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n+    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+    private static final String TARGET_NAME = \"target\";\n+    private static final String TYPE_NAME = \"interfaceType\";\n+    private static final String ENSURE_ORIGINAL_LOOKUP = \"ensureOriginalLookup\";\n+\n+    \/**\n+     * Creates an implementation class file for a given interface. One implementation class is\n+     * defined for each interface.\n+     *\n+     * @param ifaceDesc the given interface\n+     * @param methodName the name of the single abstract method\n+     * @param methods the information for implementation methods\n+     * @return the bytes of the implementation classes\n+     *\/\n+    private static byte[] createTemplate(ClassLoader loader, ClassDesc proxyDesc, ClassDesc ifaceDesc,\n+                                         String methodName, List<MethodInfo> methods) {\n+        return Classfile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader)))\n+                        .build(proxyDesc, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(ifaceDesc);\n+\n+            \/\/ static and instance fields\n+            clb.withField(TYPE_NAME, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+            clb.withField(TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            for (var mi : methods) {\n+                clb.withField(mi.fieldName, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            }\n+\n+            \/\/ <clinit>\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.constantInstruction(ifaceDesc);\n+                cob.putstatic(proxyDesc, TYPE_NAME, CD_Class);\n+                cob.return_();\n+            });\n+\n+            \/\/ <init>(Lookup, MethodHandle target, MethodHandle callerBoundTarget)\n+            clb.withMethodBody(INIT_NAME, MTD_void_Lookup_MethodHandle_MethodHandle, 0, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+\n+                \/\/ call ensureOriginalLookup to verify the given Lookup has access\n+                cob.aload(1);\n+                cob.invokestatic(proxyDesc, \"ensureOriginalLookup\", MTD_void_Lookup);\n+\n+                \/\/ this.target = target;\n+                cob.aload(0);\n+                cob.aload(2);\n+                cob.putfield(proxyDesc, TARGET_NAME, CD_MethodHandle);\n+\n+                \/\/ method handles adjusted to the method type of each method\n+                for (var mi : methods) {\n+                    \/\/ this.m<i> = callerBoundTarget.asType(xxType);\n+                    cob.aload(0);\n+                    cob.aload(3);\n+                    cob.constantInstruction(mi.desc);\n+                    cob.invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType);\n+                    cob.putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                }\n+\n+                \/\/ complete\n+                cob.return_();\n+            });\n+\n+            \/\/ private static void ensureOriginalLookup(Lookup) checks if the given Lookup\n+            \/\/ has ORIGINAL access to this class, i.e. the lookup class is this class;\n+            \/\/ otherwise, IllegalAccessException is thrown\n+            clb.withMethodBody(ENSURE_ORIGINAL_LOOKUP, MTD_void_Lookup, ACC_PRIVATE | ACC_STATIC, cob -> {\n+                var failLabel = cob.newLabel();\n+                \/\/ check lookupClass\n+                cob.aload(0);\n+                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class);\n+                cob.constantInstruction(proxyDesc);\n+                cob.if_acmpne(failLabel);\n+                \/\/ check original access\n+                cob.aload(0);\n+                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int);\n+                cob.constantInstruction(Lookup.ORIGINAL);\n+                cob.iand();\n+                cob.ifeq(failLabel);\n+                \/\/ success\n+                cob.return_();\n+                \/\/ throw exception\n+                cob.labelBinding(failLabel);\n+                cob.new_(CD_IllegalAccessException);\n+                cob.dup();\n+                cob.aload(0); \/\/ lookup\n+                cob.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                cob.invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String);\n+                cob.athrow();\n+            });\n+\n+            \/\/ implementation methods\n+            for (MethodInfo mi : methods) {\n+                \/\/ no need to generate thrown exception attribute\n+                clb.withMethodBody(methodName, mi.desc, ACC_PUBLIC, cob -> cob\n+                        .trying(bcb -> {\n+                                    \/\/ return this.handleField.invokeExact(arguments...);\n+                                    bcb.aload(0);\n+                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                                    for (int j = 0; j < mi.desc.parameterCount(); j++) {\n+                                        bcb.loadInstruction(TypeKind.from(mi.desc.parameterType(j)),\n+                                                bcb.parameterSlot(j));\n+                                    }\n+                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc);\n+                                    bcb.returnInstruction(TypeKind.from(mi.desc.returnType()));\n+                                }, ctb -> ctb\n+                                        \/\/ catch (Error | RuntimeException | Declared ex) { throw ex; }\n+                                        .catchingMulti(mi.thrown, CodeBuilder::athrow)\n+                                        \/\/ catch (Throwable ex) { throw new UndeclaredThrowableException(ex); }\n+                                        .catchingAll(cb -> cb\n+                                                .new_(CD_UndeclaredThrowableException)\n+                                                .dup_x1()\n+                                                .swap()\n+                                                .invokespecial(CD_UndeclaredThrowableException,\n+                                                        INIT_NAME, MTD_void_Throwable)\n+                                                .athrow()\n+                                        )\n+                        ));\n+            }\n+        });\n@@ -244,10 +487,1 @@\n-        return x instanceof WrapperInstance;\n-    }\n-\n-    private static WrapperInstance asWrapperInstance(Object x) {\n-        try {\n-            if (x != null)\n-                return (WrapperInstance) x;\n-        } catch (ClassCastException ex) {\n-        }\n-        throw newIllegalArgumentException(\"not a wrapper instance\");\n+        return x != null && WRAPPER_TYPES.contains(x.getClass());\n@@ -266,1 +500,11 @@\n-        return asWrapperInstance(x).getWrapperInstanceTarget();\n+        if (!isWrapperInstance(x))\n+            throw new IllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        try {\n+            Class<?> type = x.getClass();\n+            MethodHandle getter = new Lookup(type).findGetter(type, TARGET_NAME, MethodHandle.class)\n+                                                  .asType(MT_MethodHandle_Object);\n+            return (MethodHandle) getter.invokeExact(x);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n@@ -278,1 +522,55 @@\n-        return asWrapperInstance(x).getWrapperInstanceType();\n+        if (!isWrapperInstance(x))\n+            throw new IllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        try {\n+            Class<?> type = x.getClass();\n+            MethodHandle originalTypeField = new Lookup(type).findStaticGetter(type, TYPE_NAME, Class.class);\n+            return (Class<?>) originalTypeField.invokeExact();\n+        } catch (Throwable e) {\n+            throw uncaughtException(e);\n+        }\n+    }\n+\n+    private static ClassDesc desc(Class<?> cl) {\n+        return cl.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert class \"\n+                + cl.getName() + \" to a constant\"));\n+    }\n+\n+    private static MethodTypeDesc desc(MethodType mt) {\n+        return mt.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert method type \"\n+                + mt + \" to a constant\"));\n+    }\n+\n+    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+    private static final AtomicInteger counter = new AtomicInteger();\n+\n+    private static String nextModuleName() {\n+        return \"jdk.MHProxy\" + counter.incrementAndGet();\n+    }\n+\n+    \/**\n+     * Create a dynamic module defined to the given class loader and has\n+     * access to the given types.\n+     * <p>\n+     * The dynamic module contains only one single package named the same as\n+     * the name of the dynamic module.  It's not exported or open.\n+     *\/\n+    private static Module newDynamicModule(ClassLoader ld, Set<Class<?>> types) {\n+        Objects.requireNonNull(types);\n+\n+        \/\/ create a dynamic module and setup module access\n+        String mn = nextModuleName();\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                .packages(Set.of(mn))\n+                .build();\n+\n+        Module dynModule = Modules.defineModule(ld, descriptor, null);\n+        Module javaBase = Object.class.getModule();\n+\n+        Modules.addReads(dynModule, javaBase);\n+        Modules.addOpens(dynModule, mn, javaBase);\n+\n+        for (Class<?> c : types) {\n+            ensureAccess(dynModule, c);\n+        }\n+        return dynModule;\n@@ -284,1 +582,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -286,1 +584,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -288,2 +586,2 @@\n-                               && m.getParameterCount() == 1\n-                               && m.getParameterTypes()[0] == Object.class;\n+                    && m.getParameterCount() == 1\n+                    && JLRA.getExecutableSharedParameterTypes(m)[0] == Object.class;\n@@ -294,8 +592,13 @@\n-    private static Object callObjectMethod(Object self, Method m, Object[] args) {\n-        assert(isObjectMethod(m)) : m;\n-        return switch (m.getName()) {\n-            case \"toString\" -> java.util.Objects.toIdentityString(self);\n-            case \"hashCode\" -> System.identityHashCode(self);\n-            case \"equals\"   -> (self == args[0]);\n-            default -> null;\n-        };\n+    \/*\n+     * Ensure the given module can access the given class.\n+     *\/\n+    private static void ensureAccess(Module target, Class<?> c) {\n+        Module m = c.getModule();\n+        \/\/ add read edge and qualified export for the target module to access\n+        if (!target.canRead(m)) {\n+            Modules.addReads(target, m);\n+        }\n+        String pn = c.getPackageName();\n+        if (!m.isExported(pn, target)) {\n+            Modules.addExports(m, pn, target);\n+        }\n@@ -304,12 +607,3 @@\n-    private static Method[] getSingleNameMethods(Class<?> intfc) {\n-        ArrayList<Method> methods = new ArrayList<>();\n-        String uniqueName = null;\n-        for (Method m : intfc.getMethods()) {\n-            if (isObjectMethod(m))  continue;\n-            if (!Modifier.isAbstract(m.getModifiers()))  continue;\n-            String mname = m.getName();\n-            if (uniqueName == null)\n-                uniqueName = mname;\n-            else if (!uniqueName.equals(mname))\n-                return null;  \/\/ too many abstract methods\n-            methods.add(m);\n+    private static void addElementTypes(Set<Class<?>> types, Class<?>... classes) {\n+        for (var cls : classes) {\n+            addElementType(types, cls);\n@@ -317,2 +611,0 @@\n-        if (uniqueName == null)  return null;\n-        return methods.toArray(new Method[methods.size()]);\n@@ -321,3 +613,5 @@\n-    private static boolean isDefaultMethod(Method m) {\n-        return !Modifier.isAbstract(m.getModifiers());\n-    }\n+    private static void addElementType(Set<Class<?>> types, Class<?> cls) {\n+        Class<?> e = cls;\n+        while (e.isArray()) {\n+            e = e.getComponentType();\n+        }\n@@ -325,1 +619,4 @@\n-    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+        if (!e.isPrimitive()) {\n+            types.add(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":423,"deletions":126,"binary":false,"changes":549,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,4 @@\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex) {\n+        return ex.getSharedExceptionTypes();\n+    }\n+\n@@ -130,5 +134,0 @@\n-\n-    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n-            throws Throwable {\n-        return Proxy.invokeDefault(proxy, method, args, caller);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,3 @@\n+    \/** Gets the shared array of exception types of an Executable. *\/\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex);\n+\n@@ -105,7 +108,0 @@\n-\n-    \/** Invokes the given default method if the method's declaring interface is\n-     *  accessible to the given caller.  Otherwise, IllegalAccessException will\n-     *  be thrown.  If the caller is null, no access check is performed.\n-     *\/\n-    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n-        throws Throwable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.invoke;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Private API used inside of java.lang.invoke.MethodHandles.\n- * Interface implemented by every object which is produced by\n- * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance MethodHandleProxies.asInterfaceInstance}.\n- * The methods of this interface allow a caller to recover the parameters\n- * to {@code asInstance}.\n- * This allows applications to repeatedly convert between method handles\n- * and SAM objects, without the risk of creating unbounded delegation chains.\n- *\/\n-public interface WrapperInstance {\n-    \/** Produce or recover a target method handle which is behaviorally\n-     *  equivalent to the SAM method of this object.\n-     *\/\n-    public MethodHandle getWrapperInstanceTarget();\n-    \/** Recover the SAM type for which this object was created.\n-     *\/\n-    public Class<?> getWrapperInstanceType();\n-}\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/WrapperInstance.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.ToLongFunction;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 6983726 8206955 8269351\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ * @summary Basic sanity tests for MethodHandleProxies\n+ * @build BasicTest Client\n+ * @run junit BasicTest\n+ *\/\n+public class BasicTest {\n+\n+    @Test\n+    public void testUsual() throws Throwable {\n+        AtomicInteger ai = new AtomicInteger(5);\n+        var mh = MethodHandles.lookup().findVirtual(AtomicInteger.class, \"getAndIncrement\", methodType(int.class));\n+        IntSupplier is = asInterfaceInstance(IntSupplier.class, mh.bindTo(ai));\n+        assertEquals(5, is.getAsInt());\n+        assertEquals(6, is.getAsInt());\n+        assertEquals(7, is.getAsInt());\n+    }\n+\n+    \/**\n+     * Established null behaviors of MHP API.\n+     *\/\n+    @Test\n+    public void testNulls() {\n+        assertThrows(NullPointerException.class, () ->\n+                        asInterfaceInstance(null, MethodHandles.zero(void.class)),\n+                \"asInterfaceInstance - intfc\");\n+        assertThrows(NullPointerException.class, () ->\n+                        asInterfaceInstance(Runnable.class, null),\n+                \"asInterfaceInstance - target\");\n+\n+        assertFalse(isWrapperInstance(null), \"isWrapperInstance\");\n+\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(null),\n+                \"wrapperInstanceTarget\");\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(null),\n+                \"wrapperInstanceType\");\n+    }\n+\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+    }\n+\n+    \/**\n+     * Tests undeclared exceptions and declared exceptions in proxies.\n+     *\/\n+    @Test\n+    public void testThrowables() {\n+        \/\/ don't wrap\n+        assertThrows(Error.class, throwing(Error.class, new Error())::close,\n+                \"Errors should be propagated\");\n+        assertThrows(RuntimeException.class, throwing(RuntimeException.class, new RuntimeException())::close,\n+                \"RuntimeException should be propagated\");\n+        assertThrows(IOException.class, throwing(IOException.class, new IOException())::close,\n+                \"Declared IOException should be propagated\");\n+        \/\/ wrap\n+        assertThrows(UndeclaredThrowableException.class, throwing(IllegalAccessException.class,\n+                        new IllegalAccessException())::close,\n+                \"Undeclared IllegalAccessException should be wrapped\");\n+    }\n+\n+    \/**\n+     * Tests that invalid interfaces are rejected.\n+     *\/\n+    @Test\n+    public void testRejects() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(PackagePrivate.class, mh),\n+                \"non-public interface\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(loadHidden(), mh),\n+                \"hidden interface\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(MultiAbstractMethods.class, mh),\n+                \"multiple abstract method names\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(NoAbstractMethods.class, mh),\n+                \"no abstract method\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(Sealed.class, mh),\n+                \"sealed interface\");\n+    }\n+\n+    \/**\n+     * Tests that non-sealed interfaces can be implemented.\n+     *\/\n+    @Test\n+    public void testNonSealed() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"Non-Sealed\");\n+        NonSealed proxy = asInterfaceInstance(NonSealed.class, target);\n+        assertEquals(proxy.m(), \"Non-Sealed\");\n+    }\n+\n+    \/**\n+     * Tests that Proxy correctly proxies potential bridge abstract methods.\n+     *\/\n+    @Test\n+    public void testMultiSameName() throws Throwable {\n+        var baseAndChild = loadBaseAndChild();\n+        var baseClass = baseAndChild.get(0);\n+        var childClass = baseAndChild.get(1);\n+        checkMethods(childClass.getMethods());\n+        checkMethods(childClass.getDeclaredMethods());\n+\n+        var lookup = MethodHandles.lookup();\n+        var baseValueMh = lookup.findVirtual(baseClass, \"value\", genericMethodType(0))\n+                .asType(genericMethodType(1));\n+        var childIntegerValueMh = lookup.findVirtual(childClass, \"value\", methodType(Integer.class))\n+                .asType(methodType(Integer.class, Object.class));\n+        var childIntValueMh = lookup.findVirtual(childClass, \"value\", methodType(int.class))\n+                .asType(methodType(int.class, Object.class));\n+\n+        Object child = asInterfaceInstance(childClass, MethodHandles.constant(Integer.class, 7));\n+\n+        assertEquals(7, (Object) baseValueMh.invokeExact(child));\n+        assertEquals(7, (Integer) childIntegerValueMh.invokeExact(child));\n+        assertEquals(7, (int) childIntValueMh.invokeExact(child));\n+    }\n+\n+    \/**\n+     * Tests that default methods can be used.\n+     *\/\n+    @Test\n+    public void testDefaultMethods() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"F\");\n+        C proxy = asInterfaceInstance(C.class, target);\n+\n+        assertEquals(proxy.f(), \"F\");\n+        assertEquals(proxy.a(), \"A\");\n+        assertEquals(proxy.b(), \"B\");\n+        assertEquals(proxy.c(), \"C\");\n+        assertEquals(proxy.concat(), \"ABC\");\n+    }\n+\n+    \/**\n+     * Tests that correct implementation of default methods are called,\n+     * and correct abstract methods are implemented.\n+     *\/\n+    @Test\n+    public void testOverrides() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"concat\");\n+        D proxy = asInterfaceInstance(D.class, target);\n+\n+        assertEquals(proxy.a(), \"OA\");\n+        assertEquals(proxy.b(), \"OB\");\n+        assertEquals(proxy.c(), \"OC\");\n+        assertEquals(proxy.f(), \"OF\");\n+        assertEquals(proxy.concat(), \"concat\");\n+    }\n+\n+    \/**\n+     * Tests primitive type conversions in proxies.\n+     *\/\n+    @Test\n+    public void testPrimitiveConversion() throws Throwable {\n+        var mh = MethodHandles.lookup().findStatic(BasicTest.class, \"mul\",\n+                methodType(long.class, int.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Function<Integer, Long> func = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh);\n+        assertEquals(32423432L * 32423432L, func.apply(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        ToLongFunction<Integer> func1 = (ToLongFunction<Integer>) asInterfaceInstance(ToLongFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func1.applyAsLong(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        IntFunction<Long> func2 = (IntFunction<Long>) asInterfaceInstance(IntFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func2.apply(32423432));\n+    }\n+\n+    \/**\n+     * Tests common type conversions in proxies.\n+     *\/\n+    @Test\n+    public void testBasicConversion() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        asInterfaceInstance(Client.class, mh).exec(); \/\/ return value dropped, runs fine\n+\n+        var nullMh = MethodHandles.zero(String.class);\n+        var badIterable = asInterfaceInstance(Iterable.class, nullMh);\n+        assertNull(badIterable.iterator()); \/\/ null is convertible\n+    }\n+\n+    \/**\n+     * Tests incompatible type conversions in proxy construction.\n+     *\/\n+    @Test\n+    public void testWrongConversion() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        assertThrows(WrongMethodTypeException.class, () -> asInterfaceInstance(IntSupplier.class, mh),\n+                \"cannot convert String return to int under any circumstance\");\n+\n+        var proxy = asInterfaceInstance(Iterable.class, mh);\n+        assertThrows(ClassCastException.class, proxy::iterator);\n+    }\n+\n+    private static <T extends Throwable> Closeable throwing(Class<T> clz, T value) {\n+        return asInterfaceInstance(Closeable.class, MethodHandles.throwException(void.class, clz).bindTo(value));\n+    }\n+\n+    private static long mul(int i) {\n+        return (long) i * i;\n+    }\n+\n+    void checkMethods(Method[] methods) {\n+        assertTrue(methods.length > 1, () -> \"Should have more than 1 declared methods, found only \" + Arrays.toString(methods));\n+        for (Method method : methods) {\n+            assertTrue(method.accessFlags().contains(AccessFlag.ABSTRACT), () -> method + \" is not abstract\");\n+        }\n+    }\n+\n+    private Class<?> loadHidden() {\n+        try (var is = BasicTest.class.getResourceAsStream(\"Client.class\")) {\n+            var bytes = Objects.requireNonNull(is).readAllBytes();\n+            var lookup = MethodHandles.lookup();\n+            return lookup.defineHiddenClass(bytes, true).lookupClass();\n+        } catch (Throwable ex) {\n+            return fail(\"Hidden interface loading failure\", ex);\n+        }\n+    }\n+\n+    \/\/ Base: Object value();\n+    \/\/ Child: Integer value(); int value();\n+    private List<Class<?>> loadBaseAndChild() throws IllegalAccessException {\n+        ClassDesc baseCd = ClassDesc.of(\"BasicTest$Base\");\n+        ClassDesc childCd = ClassDesc.of(\"BasicTest$Child\");\n+        var objMtd = MethodTypeDesc.of(CD_Object);\n+        var integerMtd = MethodTypeDesc.of(CD_Integer);\n+        var intMtd = MethodTypeDesc.of(CD_int);\n+        var classfile = Classfile.of(Classfile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.defaultResolver().orElse(\n+                ClassHierarchyResolver.of(List.of(baseCd, childCd), Map.ofEntries(Map.entry(baseCd, CD_Object),\n+                        Map.entry(childCd, CD_Object))))));\n+\n+        var baseBytes = classfile.build(baseCd, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", objMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var lookup = MethodHandles.lookup();\n+        var base = lookup.ensureInitialized(lookup.defineClass(baseBytes));\n+\n+        var childBytes = classfile.build(childCd, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(baseCd);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", integerMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+            clb.withMethod(\"value\", intMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var child = lookup.ensureInitialized(lookup.defineClass(childBytes));\n+        return List.of(base, child);\n+    }\n+\n+    public interface MultiAbstractMethods {\n+        String a();\n+        String b();\n+    }\n+\n+    public interface NoAbstractMethods {\n+        String toString();\n+    }\n+\n+    interface PackagePrivate {\n+        Object value();\n+    }\n+\n+    public interface A {\n+        default String a() {\n+            return \"A\";\n+        }\n+    }\n+\n+    public interface B {\n+        default String b() {\n+            return \"B\";\n+        }\n+    }\n+\n+    public interface C extends A, B {\n+        String f();\n+\n+        default String c() {\n+            return \"C\";\n+        }\n+\n+        default String concat() {\n+            return a() + b() + c();\n+        }\n+    }\n+\n+    public interface D extends C {\n+        String concat();\n+\n+        default String f() {\n+            return \"OF\";\n+        }\n+\n+        default String a() {\n+            return \"OA\";\n+        }\n+\n+        default String b() {\n+            return \"OB\";\n+        }\n+\n+        default String c() {\n+            return \"OC\";\n+        }\n+    }\n+\n+    public sealed interface Sealed permits NonSealed {\n+        String m();\n+    }\n+\n+    public non-sealed interface NonSealed extends Sealed {\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n+\/**\n+ * A general-purposed public client interface for testing.\n+ *\/\n+public interface Client {\n+    \/**\n+     * Returns a lookup from Client.class.\n+     *\/\n+    static Lookup lookup() {\n+        return MethodHandles.lookup();\n+    }\n+\n+    void exec();\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Client.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8206955 8269351\n- * @run testng\/othervm -ea -esa test.java.lang.invoke.MethodHandlesProxiesTest\n- *\/\n-\n-package test.java.lang.invoke;\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class MethodHandlesProxiesTest {\n-\n-    public interface A {\n-        default String a() {\n-            return \"A\";\n-        }\n-    }\n-\n-    public interface B {\n-        default String b() {\n-            return \"B\";\n-        }\n-    }\n-\n-    public interface C extends A, B {\n-        String f();\n-\n-        default String c() {\n-            return \"C\";\n-        }\n-\n-        default String concat() {\n-            return a() + b() + c();\n-        }\n-    }\n-\n-    public interface Override extends C {\n-        String f();\n-\n-        default String a() {\n-            return \"OA\";\n-        }\n-\n-        default String b() {\n-            return \"OB\";\n-        }\n-\n-        default String c() {\n-            return \"OC\";\n-        }\n-    }\n-\n-    @Test\n-    public static void testDefaultMethods() throws Throwable {\n-        MethodHandle target = MethodHandles.constant(String.class, \"F\");\n-        C proxy = MethodHandleProxies.asInterfaceInstance(C.class, target);\n-\n-        assertEquals(proxy.f(), \"F\");\n-        assertEquals(proxy.a(), \"A\");\n-        assertEquals(proxy.b(), \"B\");\n-        assertEquals(proxy.c(), \"C\");\n-        assertEquals(proxy.concat(), \"ABC\");\n-    }\n-\n-    @Test\n-    public static void testOverriddenDefaultMethods() throws Throwable {\n-        MethodHandle target = MethodHandles.constant(String.class, \"F\");\n-        Override proxy = MethodHandleProxies.asInterfaceInstance(Override.class, target);\n-\n-        assertEquals(proxy.a(), \"OA\");\n-        assertEquals(proxy.b(), \"OB\");\n-        assertEquals(proxy.c(), \"OC\");\n-    }\n-\n-    public sealed interface Intf permits NonSealedInterface {\n-        String m();\n-    }\n-\n-    public non-sealed interface NonSealedInterface extends Intf {\n-    }\n-\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n-    public void testSealedInterface() {\n-        MethodHandle target = MethodHandles.constant(String.class, \"Sealed\");\n-        MethodHandleProxies.asInterfaceInstance(Intf.class, target);\n-    }\n-\n-    @Test\n-    public void testNonSealedInterface() {\n-        MethodHandle target = MethodHandles.constant(String.class, \"Non-Sealed\");\n-        NonSealedInterface proxy = MethodHandleProxies.asInterfaceInstance(NonSealedInterface.class, target);\n-        assertEquals(proxy.m(), \"Non-Sealed\");\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/MethodHandlesProxiesTest.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+\n+import static jdk.test.lib.Asserts.assertSame;\n+\n+\/*\n+ * @test\n+ * @bug 6983726\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Asserts Client\n+ * @run main\/othervm\/policy=jtreg.security.policy WithSecurityManagerTest\n+ * @summary Checks MethodHandleProxies behavior with security manager present\n+ *\/\n+public class WithSecurityManagerTest {\n+    public interface NestedInterface {\n+        void task();\n+    }\n+\n+    public static void main(String... args) {\n+        var originalMh = MethodHandles.zero(void.class);\n+\n+        \/\/ Test system and user interfaces\n+        for (Class<?> cl : List.of(Runnable.class, Client.class, NestedInterface.class)) {\n+            try {\n+                Object o = MethodHandleProxies.asInterfaceInstance(cl, originalMh);\n+                testWrapperInstanceTarget(o, originalMh);\n+                testWrapperInstanceType(o, cl);\n+            } catch (Throwable ex) {\n+                throw new AssertionError(\"Test failed for \" + cl, ex);\n+            }\n+        }\n+    }\n+\n+    private static void testWrapperInstanceTarget(Object wrapper, MethodHandle originalMh) {\n+        var recoveredTarget = MethodHandleProxies.wrapperInstanceTarget(wrapper);\n+        assertSame(originalMh, recoveredTarget, \"wrapperInstanceTarget recovery\");\n+    }\n+\n+    private static void testWrapperInstanceType(Object wrapper, Class<?> type) {\n+        var recoveredType = MethodHandleProxies.wrapperInstanceType(wrapper);\n+        assertSame(type, recoveredType, \"wrapperInstanceType recovery\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WithSecurityManagerTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.test.lib.util.ForceGC;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.WeakReference;\n+import java.util.Comparator;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 6983726\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ * @summary Tests on implementation hidden classes spinned by MethodHandleProxies\n+ * @build WrapperHiddenClassTest Client jdk.test.lib.util.ForceGC\n+ * @run junit WrapperHiddenClassTest\n+ *\/\n+public class WrapperHiddenClassTest {\n+\n+    \/**\n+     * Tests an adversary \"implementation\" class will not be\n+     * \"recovered\" by the wrapperInstance* APIs\n+     *\/\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        Comparator<Integer> hostile = createHostileInstance();\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertFalse(isWrapperInstance(hostile));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(hostile));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(hostile));\n+    }\n+\n+    private static final String TYPE = \"interfaceType\";\n+    private static final String TARGET = \"target\";\n+    private static final ClassDesc CD_HostileWrapper = ClassDesc.of(\"HostileWrapper\");\n+    private static final ClassDesc CD_Comparator = ClassDesc.of(\"java.util.Comparator\");\n+    private static final MethodTypeDesc MTD_int_Object_Object = MethodTypeDesc.of(CD_int, CD_Object, CD_Object);\n+    private static final MethodTypeDesc MTD_int_Integer = MethodTypeDesc.of(CD_int, CD_Integer);\n+\n+    \/\/ Update this template when the MHP template is updated\n+    @SuppressWarnings(\"unchecked\")\n+    private Comparator<Integer> createHostileInstance() throws Throwable {\n+        var cf = Classfile.of();\n+        var bytes = cf.build(CD_HostileWrapper, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(CD_Comparator);\n+\n+            \/\/ static and instance fields\n+            clb.withField(TYPE, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+            clb.withField(TARGET, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+\n+            \/\/ <clinit>\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.constantInstruction(CD_Comparator);\n+                cob.putstatic(CD_HostileWrapper, TYPE, CD_Class);\n+                cob.return_();\n+            });\n+\n+            \/\/ <init>\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+\n+            \/\/ implementation\n+            clb.withMethodBody(\"compare\", MTD_int_Object_Object, ACC_PUBLIC, cob -> {\n+                cob.aload(1);\n+                cob.checkcast(CD_Integer);\n+                cob.aload(2);\n+                cob.checkcast(CD_Integer);\n+                cob.invokestatic(CD_Integer, \"compareTo\", MTD_int_Integer);\n+                cob.ireturn();\n+            });\n+        });\n+        var l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        return (Comparator<Integer>) l.findConstructor(l.lookupClass(), MethodType.methodType(void.class)).invoke();\n+    }\n+\n+    \/**\n+     * Ensures a user interface cannot access a Proxy implementing it.\n+     *\/\n+    @Test\n+    public void testNoAccess() {\n+        var instance = asInterfaceInstance(Client.class, MethodHandles.zero(void.class));\n+        var instanceClass = instance.getClass();\n+        var interfaceLookup = Client.lookup();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, interfaceLookup.lookupModes() & MethodHandles.Lookup.ORIGINAL,\n+                \"Missing original flag on interface's lookup\");\n+        assertThrows(IllegalAccessException.class, () -> MethodHandles.privateLookupIn(instanceClass,\n+                interfaceLookup));\n+    }\n+\n+    \/**\n+     * Tests the Proxy module properties for Proxies implementing system and\n+     * user interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Client.class, Runnable.class})\n+    public void testModule(Class<?> ifaceClass) {\n+        var mh = MethodHandles.zero(void.class);\n+\n+        var inst = asInterfaceInstance(ifaceClass, mh);\n+        Module ifaceModule = ifaceClass.getModule();\n+        Class<?> implClass = inst.getClass();\n+        Module implModule = implClass.getModule();\n+\n+        String implPackage = implClass.getPackageName();\n+        assertFalse(implModule.isExported(implPackage),\n+                \"implementation should not be exported\");\n+        assertTrue(ifaceModule.isExported(ifaceClass.getPackageName(), implModule),\n+                \"interface package should be exported to implementation\");\n+        assertTrue(implModule.isOpen(implPackage, MethodHandleProxies.class.getModule()),\n+                \"implementation class is not reflectively open to MHP class\");\n+        assertTrue(implModule.isNamed(), \"dynamic module must be named\");\n+        assertTrue(implModule.getName().startsWith(\"jdk.MHProxy\"),\n+                () -> \"incorrect dynamic module name: \" + implModule.getName());\n+\n+        assertSame(ifaceClass.getClassLoader(), implClass.getClassLoader(),\n+                \"wrapper class should use the interface's loader \");\n+        assertSame(implClass.getClassLoader(), implModule.getClassLoader(),\n+                \"module class loader should be wrapper class's loader\");\n+    }\n+\n+    \/**\n+     * Tests the access control of Proxies implementing system and user\n+     * interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Client.class, Runnable.class})\n+    public void testNoInstantiation(Class<?> ifaceClass) throws ReflectiveOperationException {\n+        var mh = MethodHandles.zero(void.class);\n+        var instanceClass = asInterfaceInstance(ifaceClass, mh).getClass();\n+        var ctor = instanceClass.getDeclaredConstructor(MethodHandles.Lookup.class, MethodHandle.class, MethodHandle.class);\n+\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(Client.lookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.lookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.publicLookup(), mh, mh));\n+    }\n+\n+    \/**\n+     * Tests the caching and weak reference of implementation classes for\n+     * system and user interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Runnable.class, Client.class})\n+    public void testWeakImplClass(Class<?> ifaceClass) {\n+        var mh = MethodHandles.zero(void.class);\n+\n+        var wrapper1 = asInterfaceInstance(ifaceClass, mh);\n+        var implClass = wrapper1.getClass();\n+\n+        System.gc(); \/\/ helps debug if incorrect items are weakly referenced\n+        var wrapper2 = asInterfaceInstance(ifaceClass, mh);\n+        assertSame(implClass, wrapper2.getClass(),\n+                \"MHP should reuse old implementation class when available\");\n+\n+        var implClassRef = new WeakReference<>(implClass);\n+        \/\/ clear strong references\n+        implClass = null;\n+        wrapper1 = null;\n+        wrapper2 = null;\n+\n+        if (!ForceGC.wait(() -> implClassRef.refersTo(null))) {\n+            fail(\"MHP impl class cannot be cleared by GC\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/jtreg.security.policy","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/invoke\/7196190\/jtreg.security.policy","status":"copied"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n-\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-\/**\n- * @test\n- * @summary test MethodHandleProxies that adds qualified export of sun.invoke\n- * from java.base to a dynamic module\n- * @run testng ProxyForMethodHandle\n- *\/\n-public class ProxyForMethodHandle {\n-    \/**\n-     * MethodHandleProxies will add qualified export of sun.invoke from java.base\n-     * to a dynamic module\n-     *\/\n-    @Test\n-    public static void testRunnableMethodHandle() throws Exception {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodType mt = MethodType.methodType(void.class);\n-        MethodHandle mh = lookup.findStatic(ProxyForMethodHandle.class, \"runForRunnable\", mt);\n-        Runnable proxy = MethodHandleProxies.asInterfaceInstance(Runnable.class, mh);\n-        proxy.run();\n-\n-        Class<?> proxyClass = proxy.getClass();\n-        Module target = proxyClass.getModule();\n-        assertDynamicModule(target, proxyClass.getClassLoader(), proxyClass);\n-    }\n-\n-    static void runForRunnable() {\n-        System.out.println(\"runForRunnable\");\n-    }\n-\n-    public static void assertDynamicModule(Module m, ClassLoader ld, Class<?> proxyClass) {\n-        if (!m.isNamed() || !m.getName().startsWith(\"jdk.proxy\")) {\n-            throw new RuntimeException(m.getName() + \" not dynamic module\");\n-        }\n-\n-        if (ld != m.getClassLoader() || proxyClass.getClassLoader() != ld) {\n-            throw new RuntimeException(\"unexpected class loader\");\n-        }\n-\n-        try {\n-            Constructor<?> cons = proxyClass.getConstructor(InvocationHandler.class);\n-            cons.newInstance(handler);\n-            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n-        } catch (IllegalAccessException e) {\n-            \/\/ expected\n-        } catch (NoSuchMethodException|InstantiationException|InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    private final static InvocationHandler handler =\n-            (proxy, m, params) -> { throw new RuntimeException(m.toString()); };\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyForMethodHandle.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @modules java.base\/sun.invoke\n+ * @modules java.base\/jdk.internal.misc\n@@ -40,2 +40,2 @@\n-        \/\/ unnamed module gets access to sun.invoke package (e.g. via --add-exports)\n-        new ProxyModuleMapping(sun.invoke.WrapperInstance.class).test();\n+        \/\/ unnamed module gets access to jdk.internal.misc package (e.g. via --add-exports)\n+        new ProxyModuleMapping(jdk.internal.misc.VM.BufferPool.class).test();\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}