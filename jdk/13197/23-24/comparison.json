{"files":[{"patch":"@@ -199,1 +199,2 @@\n-        Lookup lookup = getProxyClassLookup(intfc);  \/\/ throws IllegalArgumentException\n+        Class<?> proxyClass = getProxyClass(intfc);  \/\/ throws IllegalArgumentException\n+        Lookup lookup = new Lookup(proxyClass);\n@@ -202,1 +203,1 @@\n-            MethodHandle constructor = lookup.findConstructor(lookup.lookupClass(),\n+            MethodHandle constructor = lookup.findConstructor(proxyClass,\n@@ -222,1 +223,1 @@\n-            return new WeakReferenceHolder<>(newProxy(intfc));\n+            return new WeakReferenceHolder<>(newProxyClass(intfc));\n@@ -226,1 +227,1 @@\n-    private static Class<?> newProxy(Class<?> intfc) {\n+    private static Class<?> newProxyClass(Class<?> intfc) {\n@@ -317,1 +318,1 @@\n-    private static Lookup getProxyClassLookup(Class<?> intfc) {\n+    private static Class<?> getProxyClass(Class<?> intfc) {\n@@ -320,3 +321,11 @@\n-        if (cl == null) {\n-             \/\/ If the referent is cleared, create a new value and update cached weak reference.\n-            cl = newProxy(intfc);\n+        if (cl != null)\n+            return cl;\n+\n+        \/\/ avoid spinning multiple classes in a race\n+        synchronized (r) {\n+            cl = r.get();\n+            if (cl != null)\n+                return cl;\n+\n+            \/\/ If the referent is cleared, create a new value and update cached weak reference.\n+            cl = newProxyClass(intfc);\n@@ -324,0 +333,1 @@\n+            return cl;\n@@ -325,1 +335,0 @@\n-        return new Lookup(cl);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.ToLongFunction;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 6983726 8206955 8269351\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ * @summary Basic sanity tests for MethodHandleProxies\n+ * @build BasicTest Client\n+ * @run junit BasicTest\n+ *\/\n+public class BasicTest {\n+\n+    @Test\n+    public void testUsual() throws Throwable {\n+        AtomicInteger ai = new AtomicInteger(5);\n+        var mh = MethodHandles.lookup().findVirtual(AtomicInteger.class, \"getAndIncrement\", methodType(int.class));\n+        IntSupplier is = asInterfaceInstance(IntSupplier.class, mh.bindTo(ai));\n+        assertEquals(5, is.getAsInt());\n+        assertEquals(6, is.getAsInt());\n+        assertEquals(7, is.getAsInt());\n+    }\n+\n+    \/**\n+     * Established null behaviors of MHP API.\n+     *\/\n+    @Test\n+    public void testNulls() {\n+        assertThrows(NullPointerException.class, () ->\n+                        asInterfaceInstance(null, MethodHandles.zero(void.class)),\n+                \"asInterfaceInstance - intfc\");\n+        assertThrows(NullPointerException.class, () ->\n+                        asInterfaceInstance(Runnable.class, null),\n+                \"asInterfaceInstance - target\");\n+\n+        assertFalse(isWrapperInstance(null), \"isWrapperInstance\");\n+\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(null),\n+                \"wrapperInstanceTarget\");\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(null),\n+                \"wrapperInstanceType\");\n+    }\n+\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+    }\n+\n+    \/**\n+     * Tests undeclared exceptions and declared exceptions in proxies.\n+     *\/\n+    @Test\n+    public void testThrowables() {\n+        \/\/ don't wrap\n+        assertThrows(Error.class, throwing(Error.class, new Error())::close,\n+                \"Errors should be propagated\");\n+        assertThrows(RuntimeException.class, throwing(RuntimeException.class, new RuntimeException())::close,\n+                \"RuntimeException should be propagated\");\n+        assertThrows(IOException.class, throwing(IOException.class, new IOException())::close,\n+                \"Declared IOException should be propagated\");\n+        \/\/ wrap\n+        assertThrows(UndeclaredThrowableException.class, throwing(IllegalAccessException.class,\n+                        new IllegalAccessException())::close,\n+                \"Undeclared IllegalAccessException should be wrapped\");\n+    }\n+\n+    \/**\n+     * Tests that invalid interfaces are rejected.\n+     *\/\n+    @Test\n+    public void testRejects() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(PackagePrivate.class, mh),\n+                \"non-public interface\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(loadHidden(), mh),\n+                \"hidden interface\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(MultiAbstractMethods.class, mh),\n+                \"multiple abstract method names\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(NoAbstractMethods.class, mh),\n+                \"no abstract method\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(Sealed.class, mh),\n+                \"sealed interface\");\n+    }\n+\n+    \/**\n+     * Tests that non-sealed interfaces can be implemented.\n+     *\/\n+    @Test\n+    public void testNonSealed() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"Non-Sealed\");\n+        NonSealed proxy = asInterfaceInstance(NonSealed.class, target);\n+        assertEquals(proxy.m(), \"Non-Sealed\");\n+    }\n+\n+    \/**\n+     * Tests that Proxy correctly proxies potential bridge abstract methods.\n+     *\/\n+    @Test\n+    public void testMultiSameName() throws Throwable {\n+        var baseAndChild = loadBaseAndChild();\n+        var baseClass = baseAndChild.get(0);\n+        var childClass = baseAndChild.get(1);\n+        checkMethods(childClass.getMethods());\n+        checkMethods(childClass.getDeclaredMethods());\n+\n+        var lookup = MethodHandles.lookup();\n+        var baseValueMh = lookup.findVirtual(baseClass, \"value\", genericMethodType(0))\n+                .asType(genericMethodType(1));\n+        var childIntegerValueMh = lookup.findVirtual(childClass, \"value\", methodType(Integer.class))\n+                .asType(methodType(Integer.class, Object.class));\n+        var childIntValueMh = lookup.findVirtual(childClass, \"value\", methodType(int.class))\n+                .asType(methodType(int.class, Object.class));\n+\n+        Object child = asInterfaceInstance(childClass, MethodHandles.constant(Integer.class, 7));\n+\n+        assertEquals(7, (Object) baseValueMh.invokeExact(child));\n+        assertEquals(7, (Integer) childIntegerValueMh.invokeExact(child));\n+        assertEquals(7, (int) childIntValueMh.invokeExact(child));\n+    }\n+\n+    \/**\n+     * Tests that default methods can be used.\n+     *\/\n+    @Test\n+    public void testDefaultMethods() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"F\");\n+        C proxy = asInterfaceInstance(C.class, target);\n+\n+        assertEquals(proxy.f(), \"F\");\n+        assertEquals(proxy.a(), \"A\");\n+        assertEquals(proxy.b(), \"B\");\n+        assertEquals(proxy.c(), \"C\");\n+        assertEquals(proxy.concat(), \"ABC\");\n+    }\n+\n+    \/**\n+     * Tests that correct implementation of default methods are called,\n+     * and correct abstract methods are implemented.\n+     *\/\n+    @Test\n+    public void testOverrides() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"concat\");\n+        D proxy = asInterfaceInstance(D.class, target);\n+\n+        assertEquals(proxy.a(), \"OA\");\n+        assertEquals(proxy.b(), \"OB\");\n+        assertEquals(proxy.c(), \"OC\");\n+        assertEquals(proxy.f(), \"OF\");\n+        assertEquals(proxy.concat(), \"concat\");\n+    }\n+\n+    \/**\n+     * Tests primitive type conversions in proxies.\n+     *\/\n+    @Test\n+    public void testPrimitiveConversion() throws Throwable {\n+        var mh = MethodHandles.lookup().findStatic(BasicTest.class, \"mul\",\n+                methodType(long.class, int.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Function<Integer, Long> func = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh);\n+        assertEquals(32423432L * 32423432L, func.apply(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        ToLongFunction<Integer> func1 = (ToLongFunction<Integer>) asInterfaceInstance(ToLongFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func1.applyAsLong(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        IntFunction<Long> func2 = (IntFunction<Long>) asInterfaceInstance(IntFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func2.apply(32423432));\n+    }\n+\n+    \/**\n+     * Tests common type conversions in proxies.\n+     *\/\n+    @Test\n+    public void testBasicConversion() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        asInterfaceInstance(Client.class, mh).exec(); \/\/ return value dropped, runs fine\n+\n+        var nullMh = MethodHandles.zero(String.class);\n+        var badIterable = asInterfaceInstance(Iterable.class, nullMh);\n+        assertNull(badIterable.iterator()); \/\/ null is convertible\n+    }\n+\n+    \/**\n+     * Tests incompatible type conversions in proxy construction.\n+     *\/\n+    @Test\n+    public void testWrongConversion() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        assertThrows(WrongMethodTypeException.class, () -> asInterfaceInstance(IntSupplier.class, mh),\n+                \"cannot convert String return to int under any circumstance\");\n+\n+        var proxy = asInterfaceInstance(Iterable.class, mh);\n+        assertThrows(ClassCastException.class, proxy::iterator);\n+    }\n+\n+    private static <T extends Throwable> Closeable throwing(Class<T> clz, T value) {\n+        return asInterfaceInstance(Closeable.class, MethodHandles.throwException(void.class, clz).bindTo(value));\n+    }\n+\n+    private static long mul(int i) {\n+        return (long) i * i;\n+    }\n+\n+    void checkMethods(Method[] methods) {\n+        assertTrue(methods.length > 1, () -> \"Should have more than 1 declared methods, found only \" + Arrays.toString(methods));\n+        for (Method method : methods) {\n+            assertTrue(method.accessFlags().contains(AccessFlag.ABSTRACT), () -> method + \" is not abstract\");\n+        }\n+    }\n+\n+    private Class<?> loadHidden() {\n+        try (var is = BasicTest.class.getResourceAsStream(\"Client.class\")) {\n+            var bytes = Objects.requireNonNull(is).readAllBytes();\n+            var lookup = MethodHandles.lookup();\n+            return lookup.defineHiddenClass(bytes, true).lookupClass();\n+        } catch (Throwable ex) {\n+            return fail(\"Hidden interface loading failure\", ex);\n+        }\n+    }\n+\n+    \/\/ Base: Object value();\n+    \/\/ Child: Integer value(); int value();\n+    private List<Class<?>> loadBaseAndChild() throws IllegalAccessException {\n+        ClassDesc baseCd = ClassDesc.of(\"BasicTest$Base\");\n+        ClassDesc childCd = ClassDesc.of(\"BasicTest$Child\");\n+        var objMtd = MethodTypeDesc.of(CD_Object);\n+        var integerMtd = MethodTypeDesc.of(CD_Integer);\n+        var intMtd = MethodTypeDesc.of(CD_int);\n+        var classfile = Classfile.of(Classfile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.defaultResolver().orElse(\n+                ClassHierarchyResolver.of(List.of(baseCd, childCd), Map.ofEntries(Map.entry(baseCd, CD_Object),\n+                        Map.entry(childCd, CD_Object))))));\n+\n+        var baseBytes = classfile.build(baseCd, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", objMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var lookup = MethodHandles.lookup();\n+        var base = lookup.ensureInitialized(lookup.defineClass(baseBytes));\n+\n+        var childBytes = classfile.build(childCd, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(baseCd);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", integerMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+            clb.withMethod(\"value\", intMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var child = lookup.ensureInitialized(lookup.defineClass(childBytes));\n+        return List.of(base, child);\n+    }\n+\n+    public interface MultiAbstractMethods {\n+        String a();\n+        String b();\n+    }\n+\n+    public interface NoAbstractMethods {\n+        String toString();\n+    }\n+\n+    interface PackagePrivate {\n+        Object value();\n+    }\n+\n+    public interface A {\n+        default String a() {\n+            return \"A\";\n+        }\n+    }\n+\n+    public interface B {\n+        default String b() {\n+            return \"B\";\n+        }\n+    }\n+\n+    public interface C extends A, B {\n+        String f();\n+\n+        default String c() {\n+            return \"C\";\n+        }\n+\n+        default String concat() {\n+            return a() + b() + c();\n+        }\n+    }\n+\n+    public interface D extends C {\n+        String concat();\n+\n+        default String f() {\n+            return \"OF\";\n+        }\n+\n+        default String a() {\n+            return \"OA\";\n+        }\n+\n+        default String b() {\n+            return \"OB\";\n+        }\n+\n+        default String c() {\n+            return \"OC\";\n+        }\n+    }\n+\n+    public sealed interface Sealed permits NonSealed {\n+        String m();\n+    }\n+\n+    public non-sealed interface NonSealed extends Sealed {\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-     * Leaks a lookup that has full privilege access in Client.class.\n+     * Returns a lookup from Client.class.\n@@ -34,1 +34,1 @@\n-    static Lookup leakLookup() {\n+    static Lookup lookup() {\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Client.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-\n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.WrongMethodTypeException;\n-import java.lang.reflect.UndeclaredThrowableException;\n-import java.util.Comparator;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Function;\n-import java.util.function.IntFunction;\n-import java.util.function.IntSupplier;\n-import java.util.function.ToLongFunction;\n-\n-import static java.lang.invoke.MethodHandleProxies.*;\n-import static java.lang.invoke.MethodType.methodType;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\/*\n- * @test\n- * @bug 6983726\n- * @summary Basic sanity tests for MethodHandleProxies\n- * @build ProxiesBasicTest Client\n- * @run junit ProxiesBasicTest\n- *\/\n-public class ProxiesBasicTest {\n-\n-    @Test\n-    public void testUsual() throws Throwable {\n-        AtomicInteger ai = new AtomicInteger(5);\n-        var mh = MethodHandles.lookup().findVirtual(AtomicInteger.class, \"getAndIncrement\", methodType(int.class));\n-        IntSupplier is = asInterfaceInstance(IntSupplier.class, mh.bindTo(ai));\n-        assertEquals(5, is.getAsInt());\n-        assertEquals(6, is.getAsInt());\n-        assertEquals(7, is.getAsInt());\n-    }\n-\n-    \/**\n-     * Established null behaviors of MHP API.\n-     *\/\n-    @Test\n-    public void testNulls() {\n-        assertThrows(NullPointerException.class, () ->\n-                        asInterfaceInstance(null, MethodHandles.zero(void.class)),\n-                \"asInterfaceInstance - intfc\");\n-        assertThrows(NullPointerException.class, () ->\n-                        asInterfaceInstance(Runnable.class, null),\n-                \"asInterfaceInstance - target\");\n-\n-        assertFalse(isWrapperInstance(null), \"isWrapperInstance\");\n-\n-        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(null),\n-                \"wrapperInstanceTarget\");\n-        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(null),\n-                \"wrapperInstanceType\");\n-    }\n-\n-    @Test\n-    public void testWrapperInstance() throws Throwable {\n-        var mh = MethodHandles.publicLookup()\n-                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n-        @SuppressWarnings(\"unchecked\")\n-        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n-\n-        assertTrue(isWrapperInstance(proxy));\n-        assertSame(mh, wrapperInstanceTarget(proxy));\n-        assertSame(Comparator.class, wrapperInstanceType(proxy));\n-    }\n-\n-    \/**\n-     * Tests undeclared exceptions and declared exceptions in proxies.\n-     *\/\n-    @Test\n-    public void testThrowables() {\n-        \/\/ don't wrap\n-        assertThrows(Error.class, throwing(Error.class, new Error())::close,\n-                \"Errors should be propagated\");\n-        assertThrows(RuntimeException.class, throwing(RuntimeException.class, new RuntimeException())::close,\n-                \"RuntimeException should be propagated\");\n-        assertThrows(IOException.class, throwing(IOException.class, new IOException())::close,\n-                \"Declared IOException should be propagated\");\n-        \/\/ wrap\n-        assertThrows(UndeclaredThrowableException.class, throwing(IllegalAccessException.class,\n-                        new IllegalAccessException())::close,\n-                \"Undeclared IllegalAccessException should be wrapped\");\n-    }\n-\n-    \/**\n-     * Tests primitive type conversions in proxies.\n-     *\/\n-    @Test\n-    public void testPrimitiveConversion() throws Throwable {\n-        var mh = MethodHandles.lookup().findStatic(ProxiesBasicTest.class, \"mul\",\n-                methodType(long.class, int.class));\n-        @SuppressWarnings(\"unchecked\")\n-        Function<Integer, Long> func = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh);\n-        assertEquals(32423432L * 32423432L, func.apply(32423432));\n-        @SuppressWarnings(\"unchecked\")\n-        ToLongFunction<Integer> func1 = (ToLongFunction<Integer>) asInterfaceInstance(ToLongFunction.class, mh);\n-        assertEquals(32423432L * 32423432L, func1.applyAsLong(32423432));\n-        @SuppressWarnings(\"unchecked\")\n-        IntFunction<Long> func2 = (IntFunction<Long>) asInterfaceInstance(IntFunction.class, mh);\n-        assertEquals(32423432L * 32423432L, func2.apply(32423432));\n-    }\n-\n-    \/**\n-     * Tests common type conversions in proxies.\n-     *\/\n-    @Test\n-    public void testBasicConversion() {\n-        var mh = MethodHandles.constant(String.class, \"42\");\n-        asInterfaceInstance(Client.class, mh).exec(); \/\/ return value dropped, runs fine\n-\n-        var nullMh = MethodHandles.zero(String.class);\n-        var badIterable = asInterfaceInstance(Iterable.class, nullMh);\n-        assertNull(badIterable.iterator()); \/\/ null is convertible\n-    }\n-\n-    \/**\n-     * Tests incompatible type conversions in proxy construction.\n-     *\/\n-    @Test\n-    public void testWrongConversion() {\n-        var mh = MethodHandles.constant(String.class, \"42\");\n-        assertThrows(WrongMethodTypeException.class, () -> asInterfaceInstance(IntSupplier.class, mh),\n-                \"cannot convert String return to int under any circumstance\");\n-\n-        var proxy = asInterfaceInstance(Iterable.class, mh);\n-        assertThrows(ClassCastException.class, proxy::iterator);\n-    }\n-\n-    private static <T extends Throwable> Closeable throwing(Class<T> clz, T value) {\n-        return asInterfaceInstance(Closeable.class, MethodHandles.throwException(void.class, clz).bindTo(value));\n-    }\n-\n-    private static long mul(int i) {\n-        return (long) i * i;\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/ProxiesBasicTest.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.internal.classfile.Classfile;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.ValueSource;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n-import java.util.Comparator;\n-\n-import static java.lang.constant.ConstantDescs.*;\n-import static java.lang.invoke.MethodHandleProxies.*;\n-import static java.lang.invoke.MethodType.methodType;\n-import static jdk.internal.classfile.Classfile.*;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\/*\n- * @test\n- * @bug 6983726\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- * @summary Tests on implementation classes spinned by MethodHandleProxies\n- * @build ProxiesImplementationTest Client\n- * @run junit ProxiesImplementationTest\n- *\/\n-public class ProxiesImplementationTest {\n-\n-    \/**\n-     * Tests an adversary \"implementation\" class will not be\n-     * \"recovered\" by the wrapperInstance* APIs\n-     *\/\n-    @Test\n-    public void testWrapperInstance() throws Throwable {\n-        Comparator<Integer> hostile = createHostileInstance();\n-        var mh = MethodHandles.publicLookup()\n-                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n-        @SuppressWarnings(\"unchecked\")\n-        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n-\n-        assertTrue(isWrapperInstance(proxy));\n-        assertFalse(isWrapperInstance(hostile));\n-        assertSame(mh, wrapperInstanceTarget(proxy));\n-        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(hostile));\n-        assertSame(Comparator.class, wrapperInstanceType(proxy));\n-        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(hostile));\n-    }\n-\n-    private static final String TYPE = \"interfaceType\";\n-    private static final String TARGET = \"target\";\n-    private static final ClassDesc CD_HostileWrapper = ClassDesc.of(\"HostileWrapper\");\n-    private static final ClassDesc CD_Comparator = ClassDesc.of(\"java.util.Comparator\");\n-    private static final MethodTypeDesc MTD_int_Object_Object = MethodTypeDesc.of(CD_int, CD_Object, CD_Object);\n-    private static final MethodTypeDesc MTD_int_Integer = MethodTypeDesc.of(CD_int, CD_Integer);\n-\n-    \/\/ Update this template when the MHP template is updated\n-    @SuppressWarnings(\"unchecked\")\n-    private Comparator<Integer> createHostileInstance() throws Throwable {\n-        var cf = Classfile.of();\n-        var bytes = cf.build(CD_HostileWrapper, clb -> {\n-            clb.withSuperclass(CD_Object);\n-            clb.withFlags(ACC_FINAL | ACC_SYNTHETIC);\n-            clb.withInterfaceSymbols(CD_Comparator);\n-\n-            \/\/ static and instance fields\n-            clb.withField(TYPE, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-            clb.withField(TARGET, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n-\n-            \/\/ <clinit>\n-            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n-                cob.constantInstruction(CD_Comparator);\n-                cob.putstatic(CD_HostileWrapper, TYPE, CD_Class);\n-                cob.return_();\n-            });\n-\n-            \/\/ <init>\n-            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n-                cob.aload(0);\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-                cob.return_();\n-            });\n-\n-            \/\/ implementation\n-            clb.withMethodBody(\"compare\", MTD_int_Object_Object, ACC_PUBLIC, cob -> {\n-                cob.aload(1);\n-                cob.checkcast(CD_Integer);\n-                cob.aload(2);\n-                cob.checkcast(CD_Integer);\n-                cob.invokestatic(CD_Integer, \"compareTo\", MTD_int_Integer);\n-                cob.ireturn();\n-            });\n-        });\n-        var l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n-        return (Comparator<Integer>) l.findConstructor(l.lookupClass(), MethodType.methodType(void.class)).invoke();\n-    }\n-\n-    \/**\n-     * Ensures a user interface cannot access a Proxy implementing it.\n-     *\/\n-    @Test\n-    public void testNoAccess() {\n-        Client untrusted = asInterfaceInstance(Client.class, MethodHandles.zero(void.class));\n-        var instanceClass = untrusted.getClass();\n-        var leakLookup = Client.leakLookup();\n-        assertEquals(MethodHandles.Lookup.ORIGINAL, leakLookup.lookupModes() & MethodHandles.Lookup.ORIGINAL,\n-                \"Leaked lookup original flag\");\n-        assertThrows(IllegalAccessException.class, () -> MethodHandles.privateLookupIn(instanceClass,\n-                Client.leakLookup()));\n-    }\n-\n-    \/**\n-     * Tests the Proxy module properties for Proxies implementing system and\n-     * user interfaces.\n-     *\/\n-    @ParameterizedTest\n-    @ValueSource(classes = {Client.class, Runnable.class})\n-    public void testModule(Class<?> ifaceClass) {\n-        var mh = MethodHandles.zero(void.class);\n-\n-        var inst = asInterfaceInstance(ifaceClass, mh);\n-        Module ifaceModule = ifaceClass.getModule();\n-        Class<?> implClass = inst.getClass();\n-        Module implModule = implClass.getModule();\n-\n-        String implPackage = implClass.getPackageName();\n-        assertFalse(implModule.isExported(implPackage),\n-                \"implementation should not be exported\");\n-        assertTrue(ifaceModule.isExported(ifaceClass.getPackageName(), implModule),\n-                \"interface package should be exported to implementation\");\n-        assertTrue(implModule.isOpen(implPackage, MethodHandleProxies.class.getModule()),\n-                \"implementation class is not reflectively open to MHP class\");\n-        assertTrue(implModule.isNamed(), \"dynamic module must be named\");\n-        assertTrue(implModule.getName().startsWith(\"jdk.MHProxy\"),\n-                () -> \"incorrect dynamic module name: \" + implModule.getName());\n-\n-        assertSame(implClass.getClassLoader(), implModule.getClassLoader(),\n-                \"module class loader should be proxy class's loader\");\n-    }\n-\n-    \/**\n-     * Tests the access control of Proxies implementing system and user\n-     * interfaces.\n-     *\/\n-    @ParameterizedTest\n-    @ValueSource(classes = {Client.class, Runnable.class})\n-    public void testNoInstantiation(Class<?> ifaceClass) throws ReflectiveOperationException {\n-        var mh = MethodHandles.zero(void.class);\n-        var instanceClass = asInterfaceInstance(ifaceClass, mh).getClass();\n-        var ctor = instanceClass.getDeclaredConstructor(MethodHandles.Lookup.class, MethodHandle.class, MethodHandle.class);\n-\n-        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(Client.leakLookup(), mh, mh));\n-        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.lookup(), mh, mh));\n-        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.publicLookup(), mh, mh));\n-    }\n-\n-    \/**\n-     * Tests the caching and weak reference of implementation classes.\n-     *\/\n-    @ParameterizedTest\n-    @ValueSource(classes = {Runnable.class, Client.class})\n-    public void testWeakImplClass(Class<?> ifaceClass) {\n-        var mh = MethodHandles.zero(void.class);\n-        WeakReference<Class<?>> cl;\n-\n-        var c1 = asInterfaceInstance(ifaceClass, mh);\n-        cl = new WeakReference<>(c1.getClass());\n-\n-        System.gc();\n-        var c2 = asInterfaceInstance(ifaceClass, mh);\n-        assertTrue(cl.refersTo(c2.getClass()), \"MHP should reuse implementation class when available\");\n-        Reference.reachabilityFence(c1);\n-\n-        \/\/ allow GC in interpreter\n-        c1 = null;\n-        c2 = null;\n-\n-        System.gc();\n-        assertTrue(cl.refersTo(null), \"MHP impl class should be cleared by gc\"); \/\/ broken\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/ProxiesImplementationTest.java","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -1,259 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.internal.classfile.ClassHierarchyResolver;\n-import jdk.internal.classfile.Classfile;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.AccessFlag;\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.lang.constant.ConstantDescs.*;\n-import static java.lang.invoke.MethodHandleProxies.asInterfaceInstance;\n-import static java.lang.invoke.MethodType.genericMethodType;\n-import static java.lang.invoke.MethodType.methodType;\n-import static jdk.internal.classfile.Classfile.*;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\/*\n- * @test\n- * @bug 6983726 8206955 8269351\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- * @summary Tests MethodHandleProxies against various types of interfaces\n- * @build ProxiesInterfaceTest Client\n- * @run junit ProxiesInterfaceTest\n- *\/\n-public class ProxiesInterfaceTest {\n-\n-    \/**\n-     * Tests that invalid interfaces are rejected.\n-     *\/\n-    @Test\n-    public void testRejects() {\n-        var mh = MethodHandles.constant(String.class, \"42\");\n-        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(PackagePrivate.class, mh),\n-                \"non-public interface\");\n-        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(loadHidden(), mh),\n-                \"hidden interface\");\n-        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(MultiAbstractMethods.class, mh),\n-                \"multiple abstract method names\");\n-        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(NoAbstractMethods.class, mh),\n-                \"no abstract method\");\n-        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(Sealed.class, mh),\n-                \"sealed interface\");\n-    }\n-\n-    \/**\n-     * Tests that non-sealed interfaces can be implemented.\n-     *\/\n-    @Test\n-    public void testNonSealed() {\n-        MethodHandle target = MethodHandles.constant(String.class, \"Non-Sealed\");\n-        NonSealed proxy = asInterfaceInstance(NonSealed.class, target);\n-        assertEquals(proxy.m(), \"Non-Sealed\");\n-    }\n-\n-    \/**\n-     * Tests that Proxy correctly proxies potential bridge abstract methods.\n-     *\/\n-    @Test\n-    public void testMultiSameName() throws Throwable {\n-        var baseAndChild = loadBaseAndChild();\n-        var baseClass = baseAndChild.get(0);\n-        var childClass = baseAndChild.get(1);\n-        checkMethods(childClass.getMethods());\n-        checkMethods(childClass.getDeclaredMethods());\n-\n-        var lookup = MethodHandles.lookup();\n-        var baseValueMh = lookup.findVirtual(baseClass, \"value\", genericMethodType(0))\n-                .asType(genericMethodType(1));\n-        var childIntegerValueMh = lookup.findVirtual(childClass, \"value\", methodType(Integer.class))\n-                .asType(methodType(Integer.class, Object.class));\n-        var childIntValueMh = lookup.findVirtual(childClass, \"value\", methodType(int.class))\n-                .asType(methodType(int.class, Object.class));\n-\n-        Object child = asInterfaceInstance(childClass, MethodHandles.constant(Integer.class, 7));\n-\n-        assertEquals(7, (Object) baseValueMh.invokeExact(child));\n-        assertEquals(7, (Integer) childIntegerValueMh.invokeExact(child));\n-        assertEquals(7, (int) childIntValueMh.invokeExact(child));\n-    }\n-\n-    \/**\n-     * Tests that default methods can be used.\n-     *\/\n-    @Test\n-    public void testDefaultMethods() {\n-        MethodHandle target = MethodHandles.constant(String.class, \"F\");\n-        C proxy = asInterfaceInstance(C.class, target);\n-\n-        assertEquals(proxy.f(), \"F\");\n-        assertEquals(proxy.a(), \"A\");\n-        assertEquals(proxy.b(), \"B\");\n-        assertEquals(proxy.c(), \"C\");\n-        assertEquals(proxy.concat(), \"ABC\");\n-    }\n-\n-    \/**\n-     * Tests that correct implementation of default methods are called,\n-     * and correct abstract methods are implemented.\n-     *\/\n-    @Test\n-    public void testOverrides() {\n-        MethodHandle target = MethodHandles.constant(String.class, \"concat\");\n-        D proxy = asInterfaceInstance(D.class, target);\n-\n-        assertEquals(proxy.a(), \"OA\");\n-        assertEquals(proxy.b(), \"OB\");\n-        assertEquals(proxy.c(), \"OC\");\n-        assertEquals(proxy.f(), \"OF\");\n-        assertEquals(proxy.concat(), \"concat\");\n-    }\n-\n-    \/\/<editor-fold desc=\"Infrastructure\">\n-    void checkMethods(Method[] methods) {\n-        assertTrue(methods.length > 1, () -> \"Should have more than 1 declared methods, found only \" + Arrays.toString(methods));\n-        for (Method method : methods) {\n-            assertTrue(method.accessFlags().contains(AccessFlag.ABSTRACT), () -> method + \" is not abstract\");\n-        }\n-    }\n-\n-    private Class<?> loadHidden() {\n-        try (var is = ProxiesInterfaceTest.class.getResourceAsStream(\"Client.class\")) {\n-            var bytes = Objects.requireNonNull(is).readAllBytes();\n-            var lookup = MethodHandles.lookup();\n-            return lookup.defineHiddenClass(bytes, true).lookupClass();\n-        } catch (Throwable ex) {\n-            return fail(\"Hidden interface loading failure\", ex);\n-        }\n-    }\n-\n-    \/\/ Base: Object value();\n-    \/\/ Child: Integer value(); int value();\n-    private List<Class<?>> loadBaseAndChild() throws IllegalAccessException {\n-        ClassDesc baseCd = ClassDesc.of(\"ProxiesInterfaceTest$Base\");\n-        ClassDesc childCd = ClassDesc.of(\"ProxiesInterfaceTest$Child\");\n-        var objMtd = MethodTypeDesc.of(CD_Object);\n-        var integerMtd = MethodTypeDesc.of(CD_Integer);\n-        var intMtd = MethodTypeDesc.of(CD_int);\n-        var classfile = Classfile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.defaultResolver().orElse(\n-                ClassHierarchyResolver.of(List.of(baseCd, childCd), Map.ofEntries(Map.entry(baseCd, CD_Object),\n-                        Map.entry(childCd, CD_Object))))));\n-\n-        var baseBytes = classfile.build(baseCd, clb -> {\n-            clb.withSuperclass(CD_Object);\n-            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n-            clb.withMethod(\"value\", objMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n-        });\n-\n-        var lookup = MethodHandles.lookup();\n-        var base = lookup.ensureInitialized(lookup.defineClass(baseBytes));\n-\n-        var childBytes = classfile.build(childCd, clb -> {\n-            clb.withSuperclass(CD_Object);\n-            clb.withInterfaceSymbols(baseCd);\n-            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n-            clb.withMethod(\"value\", integerMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n-            clb.withMethod(\"value\", intMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n-        });\n-\n-        var child = lookup.ensureInitialized(lookup.defineClass(childBytes));\n-        return List.of(base, child);\n-    }\n-\n-    public interface MultiAbstractMethods {\n-        String a();\n-        String b();\n-    }\n-\n-    public interface NoAbstractMethods {\n-        String toString();\n-    }\n-\n-    interface PackagePrivate {\n-        Object value();\n-    }\n-\n-    public interface A {\n-        default String a() {\n-            return \"A\";\n-        }\n-    }\n-\n-    public interface B {\n-        default String b() {\n-            return \"B\";\n-        }\n-    }\n-\n-    public interface C extends A, B {\n-        String f();\n-\n-        default String c() {\n-            return \"C\";\n-        }\n-\n-        default String concat() {\n-            return a() + b() + c();\n-        }\n-    }\n-\n-    public interface D extends C {\n-        String concat();\n-\n-        default String f() {\n-            return \"OF\";\n-        }\n-\n-        default String a() {\n-            return \"OA\";\n-        }\n-\n-        default String b() {\n-            return \"OB\";\n-        }\n-\n-        default String c() {\n-            return \"OC\";\n-        }\n-    }\n-\n-    public sealed interface Sealed permits NonSealed {\n-        String m();\n-    }\n-\n-    public non-sealed interface NonSealed extends Sealed {\n-    }\n-    \/\/<\/editor-fold>\n-}\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/ProxiesInterfaceTest.java","additions":0,"deletions":259,"binary":false,"changes":259,"status":"deleted"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.test.lib.util.ForceGC;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.WeakReference;\n+import java.util.Comparator;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 6983726\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ * @summary Tests on implementation hidden classes spinned by MethodHandleProxies\n+ * @build WrapperHiddenClassTest Client jdk.test.lib.util.ForceGC\n+ * @run junit WrapperHiddenClassTest\n+ *\/\n+public class WrapperHiddenClassTest {\n+\n+    \/**\n+     * Tests an adversary \"implementation\" class will not be\n+     * \"recovered\" by the wrapperInstance* APIs\n+     *\/\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        Comparator<Integer> hostile = createHostileInstance();\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertFalse(isWrapperInstance(hostile));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(hostile));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(hostile));\n+    }\n+\n+    private static final String TYPE = \"interfaceType\";\n+    private static final String TARGET = \"target\";\n+    private static final ClassDesc CD_HostileWrapper = ClassDesc.of(\"HostileWrapper\");\n+    private static final ClassDesc CD_Comparator = ClassDesc.of(\"java.util.Comparator\");\n+    private static final MethodTypeDesc MTD_int_Object_Object = MethodTypeDesc.of(CD_int, CD_Object, CD_Object);\n+    private static final MethodTypeDesc MTD_int_Integer = MethodTypeDesc.of(CD_int, CD_Integer);\n+\n+    \/\/ Update this template when the MHP template is updated\n+    @SuppressWarnings(\"unchecked\")\n+    private Comparator<Integer> createHostileInstance() throws Throwable {\n+        var cf = Classfile.of();\n+        var bytes = cf.build(CD_HostileWrapper, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(CD_Comparator);\n+\n+            \/\/ static and instance fields\n+            clb.withField(TYPE, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+            clb.withField(TARGET, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+\n+            \/\/ <clinit>\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.constantInstruction(CD_Comparator);\n+                cob.putstatic(CD_HostileWrapper, TYPE, CD_Class);\n+                cob.return_();\n+            });\n+\n+            \/\/ <init>\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+\n+            \/\/ implementation\n+            clb.withMethodBody(\"compare\", MTD_int_Object_Object, ACC_PUBLIC, cob -> {\n+                cob.aload(1);\n+                cob.checkcast(CD_Integer);\n+                cob.aload(2);\n+                cob.checkcast(CD_Integer);\n+                cob.invokestatic(CD_Integer, \"compareTo\", MTD_int_Integer);\n+                cob.ireturn();\n+            });\n+        });\n+        var l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        return (Comparator<Integer>) l.findConstructor(l.lookupClass(), MethodType.methodType(void.class)).invoke();\n+    }\n+\n+    \/**\n+     * Ensures a user interface cannot access a Proxy implementing it.\n+     *\/\n+    @Test\n+    public void testNoAccess() {\n+        var instance = asInterfaceInstance(Client.class, MethodHandles.zero(void.class));\n+        var instanceClass = instance.getClass();\n+        var interfaceLookup = Client.lookup();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, interfaceLookup.lookupModes() & MethodHandles.Lookup.ORIGINAL,\n+                \"Missing original flag on interface's lookup\");\n+        assertThrows(IllegalAccessException.class, () -> MethodHandles.privateLookupIn(instanceClass,\n+                interfaceLookup));\n+    }\n+\n+    \/**\n+     * Tests the Proxy module properties for Proxies implementing system and\n+     * user interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Client.class, Runnable.class})\n+    public void testModule(Class<?> ifaceClass) {\n+        var mh = MethodHandles.zero(void.class);\n+\n+        var inst = asInterfaceInstance(ifaceClass, mh);\n+        Module ifaceModule = ifaceClass.getModule();\n+        Class<?> implClass = inst.getClass();\n+        Module implModule = implClass.getModule();\n+\n+        String implPackage = implClass.getPackageName();\n+        assertFalse(implModule.isExported(implPackage),\n+                \"implementation should not be exported\");\n+        assertTrue(ifaceModule.isExported(ifaceClass.getPackageName(), implModule),\n+                \"interface package should be exported to implementation\");\n+        assertTrue(implModule.isOpen(implPackage, MethodHandleProxies.class.getModule()),\n+                \"implementation class is not reflectively open to MHP class\");\n+        assertTrue(implModule.isNamed(), \"dynamic module must be named\");\n+        assertTrue(implModule.getName().startsWith(\"jdk.MHProxy\"),\n+                () -> \"incorrect dynamic module name: \" + implModule.getName());\n+\n+        assertSame(implClass.getClassLoader(), implModule.getClassLoader(),\n+                \"module class loader should be proxy class's loader\");\n+    }\n+\n+    \/**\n+     * Tests the access control of Proxies implementing system and user\n+     * interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Client.class, Runnable.class})\n+    public void testNoInstantiation(Class<?> ifaceClass) throws ReflectiveOperationException {\n+        var mh = MethodHandles.zero(void.class);\n+        var instanceClass = asInterfaceInstance(ifaceClass, mh).getClass();\n+        var ctor = instanceClass.getDeclaredConstructor(MethodHandles.Lookup.class, MethodHandle.class, MethodHandle.class);\n+\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(Client.lookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.lookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.publicLookup(), mh, mh));\n+    }\n+\n+    \/**\n+     * Tests the caching and weak reference of implementation classes for\n+     * system and user interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Runnable.class, Client.class})\n+    public void testWeakImplClass(Class<?> ifaceClass) {\n+        var mh = MethodHandles.zero(void.class);\n+\n+        var wrapper1 = asInterfaceInstance(ifaceClass, mh);\n+        var implClass = wrapper1.getClass();\n+\n+        System.gc(); \/\/ helps debug if incorrect items are weakly referenced\n+        var wrapper2 = asInterfaceInstance(ifaceClass, mh);\n+        assertSame(implClass, wrapper2.getClass(),\n+                \"MHP should reuse old implementation class when available\");\n+\n+        var implClassRef = new WeakReference<>(implClass);\n+        \/\/ clear strong references\n+        implClass = null;\n+        wrapper1 = null;\n+        wrapper2 = null;\n+\n+        if (!ForceGC.wait(() -> implClassRef.refersTo(null))) {\n+            fail(\"MHP impl class cannot be cleared by GC\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.invoke;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.LambdaMetafactory;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.invoke.MethodHandles.lookup;\n-import static java.lang.invoke.MethodType.methodType;\n-\n-\/**\n- * Benchmark evaluates the call performance of MethodHandleProxies.asInterfaceInstance\n- * return value, compared to\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n-@Fork(1)\n-public class MethodHandleProxiesAsIFInstanceCall {\n-    \/**\n-     * Avoids elimination of computation, set up to random value\n-     *\/\n-    public int i;\n-\n-    private static final Lookup LOOKUP = lookup();\n-    private static final MethodType MT_Doable = methodType(Doable.class);\n-    private static final MethodType MT_int_int = methodType(int.class, int.class);\n-\n-    \/\/ intentionally constant-folded\n-    private static final MethodHandle constantTarget;\n-    private static final Doable constantDoable;\n-    private static final Doable constantHandle;\n-    private static final Doable constantInterfaceInstance;\n-    private static final Doable constantLambda;\n-\n-    \/\/ part of state object, non-constant\n-    private MethodHandle target;\n-    private Doable doable;\n-    private Doable handle;\n-    private Doable interfaceInstance;\n-    private Doable lambda;\n-\n-    static {\n-        try {\n-            constantTarget = LOOKUP.findStatic(MethodHandleProxiesAsIFInstanceCall.class, \"doWork\", MT_int_int);\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-        constantDoable = new Doable() {\n-            @Override\n-            public int doWork(int i) {\n-                return MethodHandleProxiesAsIFInstanceCall.doWork(i);\n-            }\n-        };\n-        constantHandle = new Doable() {\n-            @Override\n-            public int doWork(int i) {\n-                try {\n-                    return (int) constantTarget.invokeExact((int) i);\n-                } catch (Error | RuntimeException e) {\n-                    throw e;\n-                } catch (Throwable e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        };\n-        constantInterfaceInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, constantTarget);\n-        constantLambda = MethodHandleProxiesAsIFInstanceCall::doWork;\n-    }\n-\n-    @Setup\n-    public void setup() throws Throwable {\n-        target = constantTarget;\n-        doable = constantDoable;\n-        handle = constantHandle;\n-        interfaceInstance = constantInterfaceInstance;\n-        lambda = constantLambda;\n-        i = ThreadLocalRandom.current().nextInt();\n-    }\n-\n-    @Benchmark\n-    public void direct() {\n-        i = doWork(i);\n-    }\n-\n-    @Benchmark\n-    public void callDoable() {\n-        i = doable.doWork(i);\n-    }\n-\n-    @Benchmark\n-    public void callHandle() {\n-        i = handle.doWork(i);\n-    }\n-\n-    @Benchmark\n-    public void callInterfaceInstance() {\n-        i = interfaceInstance.doWork(i);\n-    }\n-\n-    @Benchmark\n-    public void callLambda() {\n-        i = lambda.doWork(i);\n-    }\n-\n-    @Benchmark\n-    public void constantDoable() {\n-        i = constantDoable.doWork(i);\n-    }\n-\n-    @Benchmark\n-    public void constantHandle() {\n-        i = constantHandle.doWork(i);\n-    }\n-\n-    @Benchmark\n-    public void constantInterfaceInstance() {\n-        i = constantInterfaceInstance.doWork(i);\n-    }\n-\n-    @Benchmark\n-    public void constantLambda() {\n-        i = constantLambda.doWork(i);\n-    }\n-\n-    public static int doWork(int i) {\n-        return i + 1;\n-    }\n-\n-    public interface Doable {\n-        int doWork(int i);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCall.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.invoke;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.LambdaMetafactory;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.invoke.MethodHandles.lookup;\n-import static java.lang.invoke.MethodType.methodType;\n-\n-\/**\n- * Benchmark evaluates the performance of MethodHandleProxies.asInterfaceInstance creation performance\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n-@Fork(1)\n-public class MethodHandleProxiesAsIFInstanceCreate {\n-    \/**\n-     * Avoids elimination of computation, set up to random value\n-     *\/\n-    public int i;\n-\n-    private static final Lookup LOOKUP = lookup();\n-    private static final MethodType MT_Doable = methodType(Doable.class);\n-    private static final MethodType MT_int_int = methodType(int.class, int.class);\n-    private MethodHandle target;\n-\n-    @Setup\n-    public void setup() throws Throwable {\n-        target = LOOKUP.findStatic(MethodHandleProxiesAsIFInstanceCreate.class, \"doWork\", MT_int_int);\n-        i = ThreadLocalRandom.current().nextInt();\n-    }\n-\n-    @Benchmark\n-    public Doable createLambda() throws Throwable {\n-        return (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n-    }\n-\n-    @Benchmark\n-    public Doable createInterfaceInstance() {\n-        return MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-    }\n-\n-    @Benchmark\n-    public Doable createCallLambda() throws Throwable {\n-        Doable doable = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n-        i = doable.doWork(i);\n-        return doable;\n-    }\n-\n-    @Benchmark\n-    public Doable createCallInterfaceInstance() {\n-        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-        i = doable.doWork(i);\n-        return doable;\n-    }\n-\n-    public static int doWork(int i) {\n-        return i + 1;\n-    }\n-\n-    public interface Doable {\n-        int doWork(int i);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCreate.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"}]}