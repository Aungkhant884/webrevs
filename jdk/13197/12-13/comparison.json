{"files":[{"patch":"@@ -36,1 +36,0 @@\n-import java.security.AccessControlContext;\n@@ -39,1 +38,0 @@\n-import java.security.ProtectionDomain;\n@@ -225,1 +223,2 @@\n-         * For each interface I define a new hidden class and pass the\n+         * For each interface I define a new hidden class and pass the original and\n+         * caller-sensitive method handles to its constructor.\n@@ -227,5 +226,1 @@\n-         * The bytecode is generated only once.  One hidden class is defined\n-         * for each invocation of MethodHandleProxies::asInterfaceInstance(I, MH).\n-         * Therefore, one or more hidden classes may be defined for I.\n-         *\n-         * All the hidden classes defined for I are defined in a dynamic module M\n+         * The hidden classes defined for I is defined in a dynamic module M\n@@ -238,15 +233,5 @@\n-\/\/        if (System.getSecurityManager() != null) {\n-\/\/            proxy = AccessController.doPrivileged((PrivilegedAction<?>) () -> {\n-\/\/                try {\n-\/\/                    return pci.constructor.invokeExact(pci.originalLookup, target, mh);\n-\/\/                } catch (Throwable e) {\n-\/\/                    throw uncaughtException(e);\n-\/\/                }\n-\/\/            });\n-\/\/        } else {\n-            try {\n-                proxy = pci.constructor.invokeExact(pci.originalLookup, target, mh);\n-            } catch (Throwable e) {\n-                throw uncaughtException(e);\n-            }\n-\/\/        }\n+        try {\n+            proxy = pci.constructor.invokeExact(pci.originalLookup, target, mh);\n+        } catch (Throwable e) {\n+            throw uncaughtException(e); \/\/ propagates WrongMethodTypeException\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,61 +1,61 @@\n-\/*\r\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package sun.invoke;\r\n-\r\n-import sun.invoke.empty.Empty;\r\n-\r\n-import java.lang.invoke.MethodHandle;\r\n-import java.lang.invoke.MethodHandles;\r\n-\r\n-\/**\r\n- * Private API used inside of java.lang.invoke.MethodHandles.\r\n- * Interface implemented by every object which is produced by\r\n- * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance\r\n- * MethodHandleProxies.asInterfaceInstance}.\r\n- * The methods of this interface allow a caller to recover the parameters\r\n- * to {@code asInstance}.\r\n- * This allows applications to repeatedly convert between method handles\r\n- * and SAM objects, without the risk of creating unbounded delegation chains.\r\n- * The methods have an empty parameter to avoid accidental clashes with\r\n- * the implemented SAM methods.\r\n- *\/\r\n-public interface WrapperInstance {\r\n-    \/**\r\n-     * Called by proxies implementation to ensure the constructor is called by proper callers.\r\n-     *\/\r\n-    static void ensureOriginalLookup(MethodHandles.Lookup lookup, Class<?> lookupClass) throws IllegalAccessException {\r\n-        if (lookup.lookupClass() != lookupClass || (lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL) == 0) {\r\n-            throw new IllegalAccessException(\"Illegal caller to \" + lookupClass + \": \" + lookup);\r\n-        }\r\n-    }\r\n-\r\n-    \/** Produce or recover a target method handle which is behaviorally\r\n-     *  equivalent to the SAM method of this object.\r\n-     *\/\r\n-    MethodHandle getWrapperInstanceTarget(Empty empty);\r\n-    \/** Recover the SAM type for which this object was created.\r\n-     *\/\r\n-    Class<?> getWrapperInstanceType(Empty empty);\r\n+\/*\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.invoke;\n+\n+import sun.invoke.empty.Empty;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n+\/**\n+ * Private API used inside of java.lang.invoke.MethodHandles.\n+ * Interface implemented by every object which is produced by\n+ * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance\n+ * MethodHandleProxies.asInterfaceInstance}.\n+ * The methods of this interface allow a caller to recover the parameters\n+ * to {@code asInstance}.\n+ * This allows applications to repeatedly convert between method handles\n+ * and SAM objects, without the risk of creating unbounded delegation chains.\n+ * The methods have an empty parameter to avoid accidental clashes with\n+ * the implemented SAM methods.\n+ *\/\n+public interface WrapperInstance {\n+    \/**\n+     * Called by proxies implementation to ensure the constructor is called by proper callers.\n+     *\/\n+    static void ensureOriginalLookup(MethodHandles.Lookup lookup, Class<?> lookupClass) throws IllegalAccessException {\n+        if (lookup.lookupClass() != lookupClass || (lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL) == 0) {\n+            throw new IllegalAccessException(\"Illegal caller to \" + lookupClass + \": \" + lookup);\n+        }\n+    }\n+\n+    \/** Produce or recover a target method handle which is behaviorally\n+     *  equivalent to the SAM method of this object.\n+     *\/\n+    MethodHandle getWrapperInstanceTarget(Empty empty);\n+    \/** Recover the SAM type for which this object was created.\n+     *\/\n+    Class<?> getWrapperInstanceType(Empty empty);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/WrapperInstance.java","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1,123 +1,123 @@\n-\/*\r\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-package org.openjdk.bench.java.lang.invoke;\r\n-\r\n-import org.openjdk.jmh.annotations.Benchmark;\r\n-import org.openjdk.jmh.annotations.BenchmarkMode;\r\n-import org.openjdk.jmh.annotations.Fork;\r\n-import org.openjdk.jmh.annotations.Measurement;\r\n-import org.openjdk.jmh.annotations.Mode;\r\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\r\n-import org.openjdk.jmh.annotations.Scope;\r\n-import org.openjdk.jmh.annotations.Setup;\r\n-import org.openjdk.jmh.annotations.State;\r\n-import org.openjdk.jmh.annotations.Warmup;\r\n-\r\n-import java.lang.invoke.MethodHandle;\r\n-import java.lang.invoke.MethodHandleProxies;\r\n-import java.lang.invoke.MethodHandles;\r\n-import java.lang.invoke.MethodType;\r\n-import java.util.concurrent.TimeUnit;\r\n-\r\n-\/**\r\n- * Benchmark evaluates the performance of MethodHandleProxies.*\r\n- *\/\r\n-@BenchmarkMode(Mode.AverageTime)\r\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\r\n-@State(Scope.Thread)\r\n-@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\r\n-@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\r\n-@Fork(3)\r\n-public class MethodHandleProxiesAsIFInstance {\r\n-\r\n-\t\/**\r\n-\t * Implementation notes:\r\n-\t *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\r\n-\t *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\r\n-\t *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\r\n-\t *\/\r\n-\r\n-\tpublic int i;\r\n-\r\n-\tprivate MethodHandle target;\r\n-\tprivate Doable precreated;\r\n-\r\n-\t@Setup\r\n-\tpublic void setup() throws Throwable {\r\n-\t\ttarget = MethodHandles.lookup().findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MethodType.methodType(int.class, int.class));\r\n-\t\tprecreated = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n-\t}\r\n-\r\n-\t@Benchmark\r\n-\tpublic Doable testCreate() {\r\n-\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n-\t\treturn doable;              \/\/ make sure allocation happens\r\n-\t}\r\n-\r\n-\t@Benchmark\r\n-\tpublic Doable testCreateCall() {\r\n-\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n-\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n-\t\treturn null;                \/\/ let allocation be eliminated\r\n-\t}\r\n-\r\n-\t@Benchmark\r\n-\tpublic Doable testCall() {\r\n-\t\ti = precreated.doWork(i);   \/\/ make sure computation happens\r\n-\t\treturn precreated;\r\n-\t}\r\n-\r\n-\t@Benchmark\r\n-\tpublic Doable baselineCompute() {\r\n-\t\tDoable doable = new Doable() {\r\n-\t\t\t@Override\r\n-\t\t\tpublic int doWork(int i) {\r\n-\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\r\n-\t\t\t}\r\n-\t\t};\r\n-\r\n-\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n-\t\treturn null;                \/\/ let allocation be eliminated\r\n-\t}\r\n-\r\n-\t@Benchmark\r\n-\tpublic Doable baselineAllocCompute() {\r\n-\t\tDoable doable = new Doable() {\r\n-\t\t\t@Override\r\n-\t\t\tpublic int doWork(int i) {\r\n-\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\r\n-\t\t\t}\r\n-\t\t};\r\n-\r\n-\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n-\t\treturn doable;              \/\/ make sure allocation happens\r\n-\t}\r\n-\r\n-\tpublic static int doWork(int i) {\r\n-\t\treturn i + 1;\r\n-\t}\r\n-\r\n-\tpublic interface Doable {\r\n-\t\tint doWork(int i);\r\n-\t}\r\n-\r\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark evaluates the performance of MethodHandleProxies.*\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class MethodHandleProxiesAsIFInstance {\n+\n+\t\/**\n+\t * Implementation notes:\n+\t *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n+\t *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n+\t *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n+\t *\/\n+\n+\tpublic int i;\n+\n+\tprivate MethodHandle target;\n+\tprivate Doable precreated;\n+\n+\t@Setup\n+\tpublic void setup() throws Throwable {\n+\t\ttarget = MethodHandles.lookup().findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MethodType.methodType(int.class, int.class));\n+\t\tprecreated = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+\t}\n+\n+\t@Benchmark\n+\tpublic Doable testCreate() {\n+\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+\t\treturn doable;              \/\/ make sure allocation happens\n+\t}\n+\n+\t@Benchmark\n+\tpublic Doable testCreateCall() {\n+\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\n+\t\treturn null;                \/\/ let allocation be eliminated\n+\t}\n+\n+\t@Benchmark\n+\tpublic Doable testCall() {\n+\t\ti = precreated.doWork(i);   \/\/ make sure computation happens\n+\t\treturn precreated;\n+\t}\n+\n+\t@Benchmark\n+\tpublic Doable baselineCompute() {\n+\t\tDoable doable = new Doable() {\n+\t\t\t@Override\n+\t\t\tpublic int doWork(int i) {\n+\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\n+\t\t\t}\n+\t\t};\n+\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\n+\t\treturn null;                \/\/ let allocation be eliminated\n+\t}\n+\n+\t@Benchmark\n+\tpublic Doable baselineAllocCompute() {\n+\t\tDoable doable = new Doable() {\n+\t\t\t@Override\n+\t\t\tpublic int doWork(int i) {\n+\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\n+\t\t\t}\n+\t\t};\n+\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\n+\t\treturn doable;              \/\/ make sure allocation happens\n+\t}\n+\n+\tpublic static int doWork(int i) {\n+\t\treturn i + 1;\n+\t}\n+\n+\tpublic interface Doable {\n+\t\tint doWork(int i);\n+\t}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstance.java","additions":123,"deletions":123,"binary":false,"changes":246,"status":"modified"}]}