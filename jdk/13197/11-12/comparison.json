{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -685,1 +685,1 @@\n-            if (ReflectUtil.isNonPublicProxyClass(cls)) {\n+            if (ReflectUtil.isNonPublicProxyClass(cls) || ReflectUtil.isMethodHandleProxiesClass(cls)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.constant.DynamicConstantDesc;\n@@ -37,0 +36,4 @@\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.ProtectionDomain;\n@@ -56,0 +59,2 @@\n+import sun.invoke.WrapperInstance;\n+import sun.invoke.empty.Empty;\n@@ -180,0 +185,16 @@\n+    \/*\n+     * Discussion:\n+     * Since project leyden aims to improve startup speed, asInterfaceInstance\n+     * will share one implementation class for each interface than one implementation\n+     * class for each method handle. This is good for use cases where multiple distinct\n+     * method handles are converted into one interface stored in a collection, where each\n+     * instance is invoked rarely (or only once), such as property getters on a bean.\n+     *\n+     * Using super-customized implementation classes for each method handle would\n+     * allow constant-folding of calls through the returned instance, but it comes with\n+     * a huge class definition overhead for each instance and is not feasible for rare\n+     * invocation use cases like above.\n+     *\n+     * The shared-class implementation is also closer in behavior to the original\n+     * proxy-backed implementation. We might add another API for super-customized instances.\n+     *\/\n@@ -204,2 +225,1 @@\n-         * For each interface I and each MH, define a new hidden class with\n-         * the target MH in the class data.\n+         * For each interface I define a new hidden class and pass the\n@@ -215,7 +235,1 @@\n-        ProxyClassDefiner pcd = PROXY_CLASS_DEFINERS.get(intfc); \/\/ throws IllegalArgumentException\n-        List<Object> classData = new ArrayList<>(pcd.types.length + 2);\n-        classData.add(intfc);\n-        classData.add(target);\n-        for (var methodType : pcd.types) {\n-            classData.add(mh.asType(methodType)); \/\/ throws WrongMethodTypeException\n-        }\n+        ProxyClassInfo pci = PROXY_CLASS_INFOS.get(intfc); \/\/ throws IllegalArgumentException\n@@ -224,9 +238,15 @@\n-        try {\n-            var lookup = pcd.definer().defineClassAsLookup(true, classData);\n-            proxy = lookup.findConstructor(lookup.lookupClass(), MT_void_Lookup)\n-                          .invoke(lookup);\n-\n-            assert proxy.getClass().getModule().isNamed() : proxy.getClass() + \" \" + proxy.getClass().getModule();\n-        } catch (Throwable e) {\n-            throw uncaughtException(e);\n-        }\n+\/\/        if (System.getSecurityManager() != null) {\n+\/\/            proxy = AccessController.doPrivileged((PrivilegedAction<?>) () -> {\n+\/\/                try {\n+\/\/                    return pci.constructor.invokeExact(pci.originalLookup, target, mh);\n+\/\/                } catch (Throwable e) {\n+\/\/                    throw uncaughtException(e);\n+\/\/                }\n+\/\/            });\n+\/\/        } else {\n+            try {\n+                proxy = pci.constructor.invokeExact(pci.originalLookup, target, mh);\n+            } catch (Throwable e) {\n+                throw uncaughtException(e);\n+            }\n+\/\/        }\n@@ -234,0 +254,1 @@\n+        assert proxy.getClass().getModule().isNamed() : proxy.getClass() + \" \" + proxy.getClass().getModule();\n@@ -237,3 +258,1 @@\n-    private record LocalMethodInfo(MethodTypeDesc desc, List<ClassDesc> thrown) {}\n-\n-    private record ProxyClassDefiner(Lookup.ClassDefiner definer, MethodType[] types, Class<?> intf, byte[] template) {}\n+    private record LocalMethodInfo(MethodTypeDesc desc, List<ClassDesc> thrown, String fieldName) {}\n@@ -241,3 +260,1 @@\n-    private record WrapperInfo(Class<?> type, MethodHandle target) {\n-        private static final WrapperInfo INVALID = new WrapperInfo(null, null);\n-    }\n+    private record ProxyClassInfo(MethodHandle constructor, Lookup originalLookup) {}\n@@ -252,1 +269,1 @@\n-    private static final ClassValue<ProxyClassDefiner> PROXY_CLASS_DEFINERS = new ClassValue<>() {\n+    private static final ClassValue<ProxyClassInfo> PROXY_CLASS_INFOS = new ClassValue<>() {\n@@ -254,1 +271,1 @@\n-        protected ProxyClassDefiner computeValue(Class<?> intfc) {\n+        protected ProxyClassInfo computeValue(Class<?> intfc) {\n@@ -261,1 +278,0 @@\n-            MethodType[] types = new MethodType[stats.methods.size()];\n@@ -263,0 +279,1 @@\n+                String fieldName = \"m\" + i;\n@@ -266,1 +283,0 @@\n-                types[i] = mt;\n@@ -269,1 +285,1 @@\n-                    infos.add(new LocalMethodInfo(mtDesc, DEFAULT_RETHROWS));\n+                    infos.add(new LocalMethodInfo(mtDesc, DEFAULT_RETHROWS, fieldName));\n@@ -271,5 +287,2 @@\n-                    infos.add(new LocalMethodInfo(mtDesc,\n-                                                  Stream.concat(DEFAULT_RETHROWS.stream(),\n-                                                                Arrays.stream(thrown)\n-                                                                      .map(MethodHandleProxies::desc))\n-                                                                      .distinct().toList()));\n+                    infos.add(new LocalMethodInfo(mtDesc, Stream.concat(DEFAULT_RETHROWS.stream(),\n+                            Arrays.stream(thrown).map(MethodHandleProxies::desc)).distinct().toList(), fieldName));\n@@ -290,3 +303,11 @@\n-            return new ProxyClassDefiner(definer, types, intfc, template);\n-        }\n-    };\n+            Lookup lookup;\n+\n+            @SuppressWarnings(\"removal\")\n+            var sm = System.getSecurityManager();\n+            if (sm != null) {\n+                @SuppressWarnings(\"removal\")\n+                var l = AccessController.doPrivileged((PrivilegedAction<Lookup>) () -> definer.defineClassAsLookup(true));\n+                lookup = l;\n+            } else {\n+                lookup = definer.defineClassAsLookup(true);\n+            }\n@@ -294,8 +315,6 @@\n-    private static final ClassValue<WrapperInfo> WRAPPER_INFOS = new ClassValue<>() {\n-        @Override\n-        protected WrapperInfo computeValue(Class<?> type) {\n-            if ((MethodHandles.classData(type) instanceof List<?> l)\n-                    && l.size() > 2\n-                    && l.get(0) instanceof Class<?> intfc\n-                    && l.get(1) instanceof MethodHandle mh) {\n-                return new WrapperInfo(intfc, mh);\n+            MethodHandle constructor;\n+            try {\n+                constructor = lookup.findConstructor(lookup.lookupClass(), MT_void_Lookup_MethodHandle_MethodHandle)\n+                        .asType(MT_Object_Lookup_MethodHandle_MethodHandle);\n+            } catch (Throwable ex) {\n+                throw uncaughtException(ex);\n@@ -303,1 +322,1 @@\n-            return WrapperInfo.INVALID;\n+            return new ProxyClassInfo(constructor, lookup);\n@@ -309,1 +328,4 @@\n-    private static final ClassDesc CD_IllegalAccessException = desc(IllegalAccessException.class);\n+    private static final ClassDesc CD_WrapperInstance = desc(WrapperInstance.class);\n+    private static final ClassDesc CD_Empty = desc(Empty.class);\n+    private static final MethodTypeDesc MTD_MethodHandle_Empty = MethodTypeDesc.of(CD_MethodHandle, CD_Empty);\n+    private static final MethodTypeDesc MTD_Class_Empty = MethodTypeDesc.of(CD_Class, CD_Empty);\n@@ -311,6 +333,6 @@\n-    private static final MethodType MT_void_Lookup = methodType(void.class, Lookup.class);\n-    private static final MethodTypeDesc MTD_void_Lookup = desc(MT_void_Lookup);\n-    private static final MethodTypeDesc MTD_Class = MethodTypeDesc.of(CD_Class);\n-    private static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n-    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n-    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodType MT_void_Lookup_MethodHandle_MethodHandle = methodType(void.class, Lookup.class, MethodHandle.class, MethodHandle.class);\n+    private static final MethodType MT_Object_Lookup_MethodHandle_MethodHandle = MT_void_Lookup_MethodHandle_MethodHandle.changeReturnType(Object.class);\n+    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle = desc(MT_void_Lookup_MethodHandle_MethodHandle);\n+    private static final MethodTypeDesc MTD_void_Lookup_Class = MethodTypeDesc.of(CD_void, CD_MethodHandles_Lookup, CD_Class);\n+    private static final MethodTypeDesc MTD_MethodHandle_MethodType = MethodTypeDesc.of(CD_MethodHandle, CD_MethodType);\n+    private static final String ORIGINAL_TARGET_NAME = \"originalTarget\";\n@@ -332,3 +354,10 @@\n-            clb.withInterfaceSymbols(ifaceDesc);\n-            \/\/ <init>(Lookup)\n-            clb.withMethodBody(INIT_NAME, MTD_void_Lookup, 0, cob -> {\n+            clb.withInterfaceSymbols(ifaceDesc, CD_WrapperInstance);\n+\n+            \/\/ individual handle fields\n+            clb.withField(ORIGINAL_TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            for (var mi : methods) {\n+                clb.withField(mi.fieldName, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            }\n+\n+            \/\/ <init>(Lookup, MethodHandle originalHandle, MethodHandle implHandle)\n+            clb.withMethodBody(INIT_NAME, MTD_void_Lookup_MethodHandle_MethodHandle, 0, cob -> {\n@@ -338,2 +367,1 @@\n-                var failLabel = cob.newLabel();\n-                \/\/ check lookupClass\n+                \/\/ WrapperInstance.ensureOriginalLookup\n@@ -341,1 +369,0 @@\n-                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class);\n@@ -343,8 +370,19 @@\n-                cob.if_acmpne(failLabel);\n-                \/\/ check original access\n-                cob.aload(1);\n-                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int);\n-                cob.constantInstruction(Lookup.ORIGINAL);\n-                cob.iand();\n-                cob.ifeq(failLabel);\n-                \/\/ success\n+                cob.invokestatic(CD_WrapperInstance, \"ensureOriginalLookup\", MTD_void_Lookup_Class, true);\n+\n+                \/\/ keep original target\n+                \/\/ this.originalTarget = originalHandle;\n+                cob.aload(0);\n+                cob.aload(2);\n+                cob.putfield(proxyDesc, ORIGINAL_TARGET_NAME, CD_MethodHandle);\n+\n+                \/\/ convert individual handles\n+                for (var mi : methods) {\n+                    \/\/ this.handleField = implHandle.asType(xxType);\n+                    cob.aload(0);\n+                    cob.aload(3);\n+                    cob.constantInstruction(mi.desc);\n+                    cob.invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType);\n+                    cob.putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                }\n+\n+                \/\/ complete\n@@ -352,8 +390,0 @@\n-                \/\/ throw exception\n-                cob.labelBinding(failLabel);\n-                cob.new_(CD_IllegalAccessException);\n-                cob.dup();\n-                cob.aload(1); \/\/ lookup\n-                cob.invokevirtual(CD_Object, \"toString\", MTD_String);\n-                cob.invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String);\n-                cob.athrow();\n@@ -362,2 +392,1 @@\n-            \/\/ actual implementations\n-            int classDataIndex = 2; \/\/ 0 is the interface, 1 is reserved for wrapper instance target\n+            \/\/ implementation methods\n@@ -365,1 +394,0 @@\n-                var condy = DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, CD_MethodHandle, classDataIndex++);\n@@ -369,1 +397,3 @@\n-                                    bcb.constantInstruction(condy);\n+                                    \/\/ return this.handleField.invokeExact(arguments...);\n+                                    bcb.aload(0);\n+                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n@@ -375,2 +405,2 @@\n-                                },\n-                                ctb -> ctb\n+                                }, ctb -> ctb\n+                                        \/\/ catch (Error | RuntimeException | Declared ex) { throw ex; }\n@@ -378,0 +408,1 @@\n+                                        \/\/ catch (Throwable ex) { throw new UndeclaredThrowableException(ex); }\n@@ -387,0 +418,13 @@\n+\n+            \/\/ WrapperInstance hooks\n+            \/\/ getWrapperInstanceTarget\n+            clb.withMethodBody(\"getWrapperInstanceTarget\", MTD_MethodHandle_Empty, ACC_PUBLIC, cob -> cob\n+                    \/\/ return this.originalTarget;\n+                    .aload(0)\n+                    .getfield(proxyDesc, ORIGINAL_TARGET_NAME, CD_MethodHandle)\n+                    .areturn());\n+            \/\/ getWrapperInstanceType\n+            clb.withMethodBody(\"getWrapperInstanceType\", MTD_Class_Empty, ACC_PUBLIC, cob -> cob\n+                    \/\/ return ifaceDesc.class;\n+                    .constantInstruction(ifaceDesc)\n+                    .areturn());\n@@ -400,1 +444,1 @@\n-        return WRAPPER_INFOS.get(x.getClass()) != WrapperInfo.INVALID;\n+        return x instanceof WrapperInstance;\n@@ -403,4 +447,3 @@\n-    private static WrapperInfo ensureWrapperInstance(Object x) {\n-        var ret = WRAPPER_INFOS.get(x.getClass());\n-        if (ret == WrapperInfo.INVALID)\n-            throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n+    private static WrapperInstance asWrapperInstance(Object x) {\n+        if (x instanceof WrapperInstance wrapperInstance)\n+            return wrapperInstance;\n@@ -408,1 +451,1 @@\n-        return ret;\n+        throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n@@ -421,1 +464,1 @@\n-        return ensureWrapperInstance(x).target;\n+        return asWrapperInstance(x).getWrapperInstanceTarget(null);\n@@ -433,1 +476,1 @@\n-        return ensureWrapperInstance(x).type;\n+        return asWrapperInstance(x).getWrapperInstanceType(null);\n@@ -475,0 +518,2 @@\n+        ensureAccess(dynModule, WrapperInstance.class);\n+        ensureAccess(dynModule, Empty.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":135,"deletions":90,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\r\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package sun.invoke;\r\n+\r\n+import sun.invoke.empty.Empty;\r\n+\r\n+import java.lang.invoke.MethodHandle;\r\n+import java.lang.invoke.MethodHandles;\r\n+\r\n+\/**\r\n+ * Private API used inside of java.lang.invoke.MethodHandles.\r\n+ * Interface implemented by every object which is produced by\r\n+ * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance\r\n+ * MethodHandleProxies.asInterfaceInstance}.\r\n+ * The methods of this interface allow a caller to recover the parameters\r\n+ * to {@code asInstance}.\r\n+ * This allows applications to repeatedly convert between method handles\r\n+ * and SAM objects, without the risk of creating unbounded delegation chains.\r\n+ * The methods have an empty parameter to avoid accidental clashes with\r\n+ * the implemented SAM methods.\r\n+ *\/\r\n+public interface WrapperInstance {\r\n+    \/**\r\n+     * Called by proxies implementation to ensure the constructor is called by proper callers.\r\n+     *\/\r\n+    static void ensureOriginalLookup(MethodHandles.Lookup lookup, Class<?> lookupClass) throws IllegalAccessException {\r\n+        if (lookup.lookupClass() != lookupClass || (lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL) == 0) {\r\n+            throw new IllegalAccessException(\"Illegal caller to \" + lookupClass + \": \" + lookup);\r\n+        }\r\n+    }\r\n+\r\n+    \/** Produce or recover a target method handle which is behaviorally\r\n+     *  equivalent to the SAM method of this object.\r\n+     *\/\r\n+    MethodHandle getWrapperInstanceTarget(Empty empty);\r\n+    \/** Recover the SAM type for which this object was created.\r\n+     *\/\r\n+    Class<?> getWrapperInstanceType(Empty empty);\r\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/WrapperInstance.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import sun.invoke.WrapperInstance;\n@@ -270,0 +271,9 @@\n+    \/**\n+     * Test if the given class is a method handle proxy class.\n+     * Such proxy classes may access certain java.base internal\n+     * packages exported to its dynamic module.\n+     *\/\n+    public static boolean isMethodHandleProxiesClass(Class<?> cls) {\n+        return WrapperInstance.class.isAssignableFrom(cls);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -115,3 +115,1 @@\n-    private static long mul2(int i) {\n-        return (long) i * i *2;\n-    }\n+\n@@ -135,1 +133,0 @@\n-        var mh2 = MethodHandles.lookup().findStatic(BasicTest.class, \"mul2\", methodType(long.class, int.class));\n@@ -137,0 +134,1 @@\n+        @SuppressWarnings(\"unchecked\")\n@@ -142,8 +140,0 @@\n-        Function<Integer, Long> func2 = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh2);\n-        assertEquals(32423432L * 32423432L * 2, func2.apply(32423432));\n-        Class<?> c2 = func2.getClass();\n-        Module m2 = c2.getModule();\n-        assertTrue(c1 != c2);\n-        assertEquals(c1.getPackageName(), c2.getPackageName());\n-        assertTrue(m1 == m2);\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\r\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+package org.openjdk.bench.java.lang.invoke;\r\n+\r\n+import org.openjdk.jmh.annotations.Benchmark;\r\n+import org.openjdk.jmh.annotations.BenchmarkMode;\r\n+import org.openjdk.jmh.annotations.Fork;\r\n+import org.openjdk.jmh.annotations.Measurement;\r\n+import org.openjdk.jmh.annotations.Mode;\r\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\r\n+import org.openjdk.jmh.annotations.Scope;\r\n+import org.openjdk.jmh.annotations.Setup;\r\n+import org.openjdk.jmh.annotations.State;\r\n+import org.openjdk.jmh.annotations.Warmup;\r\n+\r\n+import java.lang.invoke.MethodHandle;\r\n+import java.lang.invoke.MethodHandleProxies;\r\n+import java.lang.invoke.MethodHandles;\r\n+import java.lang.invoke.MethodType;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+\/**\r\n+ * Benchmark evaluates the performance of MethodHandleProxies.*\r\n+ *\/\r\n+@BenchmarkMode(Mode.AverageTime)\r\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\r\n+@State(Scope.Thread)\r\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\r\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\r\n+@Fork(3)\r\n+public class MethodHandleProxiesAsIFInstance {\r\n+\r\n+\t\/**\r\n+\t * Implementation notes:\r\n+\t *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\r\n+\t *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\r\n+\t *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\r\n+\t *\/\r\n+\r\n+\tpublic int i;\r\n+\r\n+\tprivate MethodHandle target;\r\n+\tprivate Doable precreated;\r\n+\r\n+\t@Setup\r\n+\tpublic void setup() throws Throwable {\r\n+\t\ttarget = MethodHandles.lookup().findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MethodType.methodType(int.class, int.class));\r\n+\t\tprecreated = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable testCreate() {\r\n+\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n+\t\treturn doable;              \/\/ make sure allocation happens\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable testCreateCall() {\r\n+\t\tDoable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\r\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n+\t\treturn null;                \/\/ let allocation be eliminated\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable testCall() {\r\n+\t\ti = precreated.doWork(i);   \/\/ make sure computation happens\r\n+\t\treturn precreated;\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable baselineCompute() {\r\n+\t\tDoable doable = new Doable() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic int doWork(int i) {\r\n+\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\r\n+\t\t\t}\r\n+\t\t};\r\n+\r\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n+\t\treturn null;                \/\/ let allocation be eliminated\r\n+\t}\r\n+\r\n+\t@Benchmark\r\n+\tpublic Doable baselineAllocCompute() {\r\n+\t\tDoable doable = new Doable() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic int doWork(int i) {\r\n+\t\t\t\treturn MethodHandleProxiesAsIFInstance.doWork(i);\r\n+\t\t\t}\r\n+\t\t};\r\n+\r\n+\t\ti = doable.doWork(i);       \/\/ make sure computation happens\r\n+\t\treturn doable;              \/\/ make sure allocation happens\r\n+\t}\r\n+\r\n+\tpublic static int doWork(int i) {\r\n+\t\treturn i + 1;\r\n+\t}\r\n+\r\n+\tpublic interface Doable {\r\n+\t\tint doWork(int i);\r\n+\t}\r\n+\r\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstance.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}