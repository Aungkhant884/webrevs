{"files":[{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -48,0 +47,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -85,1 +86,2 @@\n-     * The interface must be public and not {@linkplain Class#isSealed() sealed}.\n+     * The interface must be public, not {@linkplain Class#isHidden() hidden},\n+     * and not {@linkplain Class#isSealed() sealed}.\n@@ -200,1 +202,1 @@\n-        var info = INTERFACE_INFOS.get(intfc); \/\/ throws IllegalArgumentException\n+        InterfaceInfo info = INTERFACE_INFOS.get(intfc); \/\/ throws IllegalArgumentException\n@@ -212,2 +214,1 @@\n-            proxy = lookup.findConstructor(lookup.lookupClass(), methodType(void.class))\n-                    .asType(methodType(Object.class)).invokeExact();\n+            proxy = lookup.findConstructor(lookup.lookupClass(), methodType(void.class)).invoke();\n@@ -225,1 +226,1 @@\n-    private record InterfaceInfo(@Stable MethodType[] types, Lookup lookup, @Stable byte[] template) {}\n+    private record InterfaceInfo(MethodType[] types, Lookup lookup, byte[] template) {}\n@@ -256,1 +257,10 @@\n-            var template = createTemplate(desc(intfc), methods.get(0).getName(), infos);\n+            \/\/ default class hierarchy resolver accesses system resources\n+            @SuppressWarnings(\"removal\")\n+            byte[] template = AccessController.doPrivileged(new PrivilegedAction<byte[]>() {\n+                @Override\n+                public byte[] run() {\n+                    return createTemplate(desc(intfc), methods.get(0).getName(), infos);\n+                }\n+            });\n+\n+                \/\/= createTemplate(desc(intfc), methods.get(0).getName(), infos);\n@@ -264,1 +274,7 @@\n-            var anno = type.getDeclaredAnnotation(WrapperInstance.class);\n+            @SuppressWarnings(\"removal\")\n+            WrapperInstance anno = AccessController.doPrivileged(new PrivilegedAction<>() {\n+                @Override\n+                public WrapperInstance run() {\n+                    return type.getDeclaredAnnotation(WrapperInstance.class);\n+                }\n+            });\n@@ -292,3 +308,11 @@\n-    \/\/ Spin an implementation class for an interface. A new class should be defined for each handle.\n-    \/\/ constructor parameter: Array[target, mh1, mh2, ...]\n-    private static byte[] createTemplate(ClassDesc ifaceDesc, String name, List<LocalMethodInfo> methods) {\n+    \/**\n+     * Creates an implementation class file for a given interface. One implementation class is\n+     * defined for each method handle, with the same bytes but different class data:\n+     * [wrapperInstanceTarget, methodtype1, methodtype2, ...]\n+     *\n+     * @param ifaceDesc the given interface\n+     * @param methodName the name of the single abstract method\n+     * @param methods the information for implementation methods\n+     * @return the bytes of the implementation classes\n+     *\/\n+    private static byte[] createTemplate(ClassDesc ifaceDesc, String methodName, List<LocalMethodInfo> methods) {\n@@ -309,1 +333,1 @@\n-            int i = 1;\n+            int classDataIndex = 1; \/\/ 0 is reserved for wrapper instance target\n@@ -311,1 +335,1 @@\n-                var condy = DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, CD_MethodHandle, i++);\n+                var condy = DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, CD_MethodHandle, classDataIndex++);\n@@ -313,1 +337,1 @@\n-                clb.withMethodBody(name, mi.desc, ACC_PUBLIC, cob -> cob\n+                clb.withMethodBody(methodName, mi.desc, ACC_PUBLIC, cob -> cob\n@@ -316,5 +340,2 @@\n-                                    int slot = 1;\n-                                    for (var t : mi.desc.parameterList()) {\n-                                        var kind = TypeKind.from(t);\n-                                        bcb.loadInstruction(kind, slot);\n-                                        slot += kind.slotSize();\n+                                    for (int j = 0; j < mi.desc.parameterCount(); j++) {\n+                                        bcb.loadInstruction(TypeKind.from(mi.desc.parameterType(j)), bcb.parameterSlot(j));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":40,"deletions":19,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run junit BasicTest\n+ * @run junit\/othervm -ea -esa -Djdk.invoke.MethodHandleProxies.dumpInterfaceInstances BasicTest\n@@ -104,21 +104,0 @@\n-    \/\/ We both check for correctness and that it doesn't throw\n-    @Test\n-    public void testObjectMethods() throws Throwable {\n-        var mh = MethodHandles.publicLookup()\n-                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n-        @SuppressWarnings(\"unchecked\")\n-        Comparator<Integer> p1 = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n-        @SuppressWarnings(\"unchecked\")\n-        Comparator<Integer> p2 = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n-\n-        assertEquals(System.identityHashCode(p1), p1.hashCode());\n-        assertEquals(System.identityHashCode(p2), p2.hashCode());\n-\n-        assertEquals(p1, p1);\n-        assertEquals(p1 == p2, p1.equals(p2));\n-        assertEquals(p2 == p1, p2.equals(p1));\n-\n-        assertEquals(Objects.toIdentityString(p1), p1.toString());\n-        assertEquals(Objects.toIdentityString(p2), p2.toString());\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * @run testng\/othervm -ea -esa test.java.lang.invoke.MethodHandlesProxiesTest\n+ * @run testng\/othervm -ea -esa -Djdk.invoke.MethodHandleProxies.dumpInterfaceInstances\n+ *      test.java.lang.invoke.MethodHandlesProxiesTest\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/MethodHandlesProxiesTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,25 +1,26 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Used as a reference type for a field in NoSuchFieldReference.jasm\n-public class TestClass {}\n+\/*\r\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+public interface Untrusted {\r\n+    void exec();\r\n+}\r\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Untrusted.java","additions":26,"deletions":25,"binary":false,"changes":51,"previous_filename":"test\/hotspot\/jtreg\/runtime\/linkResolver\/TestClass.java","status":"copied"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 6983726\n+ * @build Untrusted WithSecurityManagerTest\n+ * @run main\/othervm\/policy=jtreg.security.policy -ea -esa\n+ *      -Djdk.invoke.MethodHandleProxies.dumpInterfaceInstances WithSecurityManagerTest\n+ * @summary Checks MethodHandleProxies behavior with security manager present\n+ *\/\n+\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+\n+public class WithSecurityManagerTest {\n+    public static void main(String... args) {\n+        var originalMh = MethodHandles.zero(void.class);\n+        var untrustedTarget = MethodHandleProxies.wrapperInstanceTarget(MethodHandleProxies.asInterfaceInstance(Untrusted.class, originalMh));\n+        assert originalMh == untrustedTarget : \"Got \" + untrustedTarget;\n+\n+        var runnableTarget = MethodHandleProxies.wrapperInstanceTarget(MethodHandleProxies.asInterfaceInstance(Runnable.class, originalMh));\n+        assert originalMh == runnableTarget : \"Got \" + runnableTarget;\n+   }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WithSecurityManagerTest.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/jtreg.security.policy","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/invoke\/7196190\/jtreg.security.policy","status":"copied"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.invoke;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.LambdaMetafactory;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.invoke.MethodHandles.lookup;\n-import static java.lang.invoke.MethodType.methodType;\n-\n-\/**\n- * Benchmark evaluates the performance of MethodHandleProxies.*\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n-@Fork(3)\n-public class MethodHandleProxiesAsIFInstance {\n-\n-    \/**\n-     * Implementation notes:\n-     *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n-     *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n-     *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n-     *   - lambda* compares lambda performance with asInterfaceInstance performance\n-     *\/\n-\n-    public int i;\n-\n-    private static final Lookup LOOKUP = lookup();\n-    private static final MethodType MT_Doable = methodType(Doable.class);\n-    private static final MethodType MT_int_int = methodType(int.class, int.class);\n-    private MethodHandle target;\n-    private Doable precreated;\n-    private Doable precreatedLambda;\n-\n-    @Setup\n-    public void setup() throws Throwable {\n-        target = LOOKUP.findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MT_int_int);\n-        precreated = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-        precreatedLambda = MethodHandleProxiesAsIFInstance::doWork;\n-    }\n-\n-    @Benchmark\n-    public Doable lambdaCreate() throws Throwable {\n-        Doable doable = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n-        return doable;              \/\/ make sure allocation happens\n-    }\n-\n-    @Benchmark\n-    public Doable testCreate() {\n-        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-        return doable;              \/\/ make sure allocation happens\n-    }\n-\n-    @Benchmark\n-    public Doable lambdaCreateCall() throws Throwable {\n-        Doable doable = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n-        i = doable.doWork(i);       \/\/ make sure computation happens\n-        return null;                \/\/ let allocation be eliminated\n-    }\n-\n-    @Benchmark\n-    public Doable testCreateCall() {\n-        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n-        i = doable.doWork(i);       \/\/ make sure computation happens\n-        return null;                \/\/ let allocation be eliminated\n-    }\n-\n-    @Benchmark\n-    public Doable lambdaCall() {\n-        i = precreatedLambda.doWork(i); \/\/ make sure computation happens\n-        return precreatedLambda;\n-    }\n-\n-    @Benchmark\n-    public Doable testCall() {\n-        i = precreated.doWork(i);   \/\/ make sure computation happens\n-        return precreated;\n-    }\n-\n-    @Benchmark\n-    public Doable baselineCompute() {\n-        Doable doable = new Doable() {\n-            @Override\n-            public int doWork(int i) {\n-                return MethodHandleProxiesAsIFInstance.doWork(i);\n-            }\n-        };\n-\n-        i = doable.doWork(i);       \/\/ make sure computation happens\n-        return null;                \/\/ let allocation be eliminated\n-    }\n-\n-    @Benchmark\n-    public Doable baselineAllocCompute() {\n-        Doable doable = new Doable() {\n-            @Override\n-            public int doWork(int i) {\n-                return MethodHandleProxiesAsIFInstance.doWork(i);\n-            }\n-        };\n-\n-        i = doable.doWork(i);       \/\/ make sure computation happens\n-        return doable;              \/\/ make sure allocation happens\n-    }\n-\n-    public static int doWork(int i) {\n-        return i + 1;\n-    }\n-\n-    public interface Doable {\n-        int doWork(int i);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstance.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * Benchmark evaluates the call performance of MethodHandleProxies.asInterfaceInstance\n+ * return value, compared to\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class MethodHandleProxiesAsIFInstanceCall {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n+     *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n+     *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n+     *   - lambda* compares lambda performance with asInterfaceInstance performance\n+     *\/\n+\n+    public int i;\n+\n+    private static final Lookup LOOKUP = lookup();\n+    private static final MethodType MT_Doable = methodType(Doable.class);\n+    private static final MethodType MT_int_int = methodType(int.class, int.class);\n+\n+    \/\/ constant-fold\n+    private static final MethodHandle constantTarget;\n+    private static final Doable constantPrecreatedDoable;\n+    private static final Doable constantPrecreatedInstance;\n+    private static final Doable constantPrecreatedLambda;\n+\n+    \/\/ part of state object\n+    private MethodHandle target;\n+    private Doable precreatedDoable;\n+    private Doable precreatedInstance;\n+    private Doable precreatedLambda;\n+\n+    static {\n+        try {\n+            constantTarget = LOOKUP.findStatic(MethodHandleProxiesAsIFInstanceCall.class, \"doWork\", MT_int_int);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+        constantPrecreatedDoable = new Doable() {\n+            @Override\n+            public int doWork(int i) {\n+                return MethodHandleProxiesAsIFInstanceCall.doWork(i);\n+            }\n+        };\n+        constantPrecreatedInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, constantTarget);\n+        constantPrecreatedLambda = MethodHandleProxiesAsIFInstanceCall::doWork;\n+    }\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        target = LOOKUP.findStatic(MethodHandleProxiesAsIFInstanceCall.class, \"doWork\", MT_int_int);\n+        precreatedDoable = new Doable() {\n+            @Override\n+            public int doWork(int i) {\n+                return MethodHandleProxiesAsIFInstanceCall.doWork(i);\n+            }\n+        };\n+        precreatedInstance = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+        precreatedLambda = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n+        ;\n+    }\n+\n+    @Benchmark\n+    public Doable directCall() {\n+        i = doWork(i);\n+        return null;\n+    }\n+\n+    @Benchmark\n+    public Doable doableCall() {\n+        i = precreatedDoable.doWork(i);\n+        return precreatedDoable;\n+    }\n+\n+    @Benchmark\n+    public Doable interfaceInstanceCall() {\n+        i = precreatedInstance.doWork(i);   \/\/ make sure computation happens\n+        return precreatedInstance;\n+    }\n+\n+    @Benchmark\n+    public Doable lambdaCall() {\n+        i = precreatedLambda.doWork(i); \/\/ make sure computation happens\n+        return precreatedLambda;\n+    }\n+\n+    @Benchmark\n+    public Doable constantDoableCall() {\n+        i = constantPrecreatedDoable.doWork(i);\n+        return constantPrecreatedDoable;\n+    }\n+\n+    @Benchmark\n+    public Doable constantInterfaceInstanceCall() {\n+        i = constantPrecreatedInstance.doWork(i);   \/\/ make sure computation happens\n+        return constantPrecreatedInstance;\n+    }\n+\n+    @Benchmark\n+    public Doable constantLambdaCall() {\n+        i = constantPrecreatedLambda.doWork(i); \/\/ make sure computation happens\n+        return constantPrecreatedLambda;\n+    }\n+\n+    public static int doWork(int i) {\n+        return i + 1;\n+    }\n+\n+    public interface Doable {\n+        int doWork(int i);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCall.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * Benchmark evaluates the performance of MethodHandleProxies.asInterfaceInstance creation performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class MethodHandleProxiesAsIFInstanceCreate {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - asInterfaceInstance() can only target static MethodHandle (adapters needed to call instance method?)\n+     *   - baselineCompute will quickly degrade to GC test, if escape analysis is unable to spare the allocation\n+     *   - testCreate* will always be slower if allocation is not eliminated; baselineAllocCompute makes sure allocation is present\n+     *   - lambda* compares lambda performance with asInterfaceInstance performance\n+     *\/\n+\n+    public int i;\n+\n+    private static final Lookup LOOKUP = lookup();\n+    private static final MethodType MT_Doable = methodType(Doable.class);\n+    private static final MethodType MT_int_int = methodType(int.class, int.class);\n+    private MethodHandle target;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        target = LOOKUP.findStatic(MethodHandleProxiesAsIFInstanceCreate.class, \"doWork\", MT_int_int);\n+    }\n+\n+    @Benchmark\n+    public Doable lambdaCreate() throws Throwable {\n+        return (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n+    }\n+\n+    @Benchmark\n+    public Doable interfaceInstanceCreate() {\n+        return MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+    }\n+\n+    @Benchmark\n+    public Doable lambdaCreateCall() throws Throwable {\n+        Doable doable = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n+        i = doable.doWork(i);\n+        return doable;\n+    }\n+\n+    @Benchmark\n+    public Doable interfaceInstanceCreateCall() {\n+        Doable doable = MethodHandleProxies.asInterfaceInstance(Doable.class, target);\n+        i = doable.doWork(i);\n+        return doable;\n+    }\n+\n+    public static int doWork(int i) {\n+        return i + 1;\n+    }\n+\n+    public interface Doable {\n+        int doWork(int i);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstanceCreate.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}