{"files":[{"patch":"@@ -219,1 +219,1 @@\n-    private static final ClassValue<WeakReferenceHolder<Lookup>> PROXY_LOOKUPS = new ClassValue<>() {\n+    private static final ClassValue<WeakReferenceHolder<Class<?>>> PROXIES = new ClassValue<>() {\n@@ -221,2 +221,2 @@\n-        protected WeakReferenceHolder<Lookup> computeValue(Class<?> intfc) {\n-            return new WeakReferenceHolder<>(newProxyLookup(intfc));\n+        protected WeakReferenceHolder<Class<?>> computeValue(Class<?> intfc) {\n+            return new WeakReferenceHolder<>(newProxy(intfc));\n@@ -226,1 +226,1 @@\n-    private static Lookup newProxyLookup(Class<?> intfc) {\n+    private static Class<?> newProxy(Class<?> intfc) {\n@@ -296,2 +296,3 @@\n-        WRAPPER_TYPES.add(lookup.lookupClass());\n-        return lookup;\n+        var ret = lookup.lookupClass();\n+        WRAPPER_TYPES.add(ret);\n+        return ret;\n@@ -317,3 +318,3 @@\n-        WeakReferenceHolder<Lookup> r = PROXY_LOOKUPS.get(intfc);\n-        Lookup lookup = r.get();\n-        if (lookup == null) {\n+        WeakReferenceHolder<Class<?>> r = PROXIES.get(intfc);\n+        Class<?> cl = r.get();\n+        if (cl == null) {\n@@ -321,2 +322,2 @@\n-            lookup = newProxyLookup(intfc);\n-            r.set(lookup);\n+            cl = newProxy(intfc);\n+            r.set(cl);\n@@ -324,1 +325,1 @@\n-        return lookup;\n+        return new Lookup(cl);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.ref.Reference;\n@@ -192,3 +193,2 @@\n-        {\n-            var c1 = asInterfaceInstance(ifaceClass, mh);\n-            cl = new WeakReference<>(c1.getClass());\n+        var c1 = asInterfaceInstance(ifaceClass, mh);\n+        cl = new WeakReference<>(c1.getClass());\n@@ -196,4 +196,8 @@\n-            \/\/System.gc(); \/\/ clears the WeakReference while it's still reachable?\n-            var c2 = asInterfaceInstance(ifaceClass, mh);\n-            assertTrue(cl.refersTo(c2.getClass()), \"MHP should reuse implementation class when available\");\n-        }\n+        System.gc();\n+        var c2 = asInterfaceInstance(ifaceClass, mh);\n+        assertTrue(cl.refersTo(c2.getClass()), \"MHP should reuse implementation class when available\");\n+        Reference.reachabilityFence(c1);\n+\n+        \/\/ allow GC in interpreter\n+        c1 = null;\n+        c2 = null;\n@@ -202,1 +206,1 @@\n-        \/\/assertTrue(cl.refersTo(null), \"MHP impl class should be cleared by gc\"); \/\/ broken\n+        assertTrue(cl.refersTo(null), \"MHP impl class should be cleared by gc\"); \/\/ broken\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/ProxiesImplementationTest.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"}]}