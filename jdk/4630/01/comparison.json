{"files":[{"patch":"@@ -19,0 +19,2 @@\n+\/.project\/\n+\/.settings\/\n","filename":".gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,0 +224,6 @@\n+  # Linux x86_64 needs higher binutils after 8265783\n+  # (this really is a dependency on as version, but we take ld as a check for a general binutils version)\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n+    TOOLCHAIN_MINIMUM_LD_VERSION_gcc=\"2.25\"\n+  fi\n+\n@@ -680,0 +686,1 @@\n+    AC_MSG_NOTICE([comparing linker version to minimum version $TOOLCHAIN_MINIMUM_LD_VERSION])\n@@ -682,1 +689,1 @@\n-          AC_MSG_WARN([You are using a linker older than $TOOLCHAIN_MINIMUM_LD_VERSION. This is not a supported configuration.])\n+          AC_MSG_ERROR([You are using a linker older than $TOOLCHAIN_MINIMUM_LD_VERSION. This is not a supported configuration.])\n","filename":"make\/autoconf\/toolchain.m4","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=17\n+DEFAULT_VERSION_FEATURE=18\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2021-09-14\n-DEFAULT_VERSION_CLASSFILE_MAJOR=61  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2022-03-15\n+DEFAULT_VERSION_CLASSFILE_MAJOR=62  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -40,2 +40,2 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=17\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17 18\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=18\n","filename":"make\/conf\/version-numbers.conf","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,930 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.base\n+header exports java\/io,java\/lang,java\/lang\/annotation,java\/lang\/constant,java\/lang\/invoke,java\/lang\/module,java\/lang\/ref,java\/lang\/reflect,java\/lang\/runtime,java\/math,java\/net,java\/net\/spi,java\/nio,java\/nio\/channels,java\/nio\/channels\/spi,java\/nio\/charset,java\/nio\/charset\/spi,java\/nio\/file,java\/nio\/file\/attribute,java\/nio\/file\/spi,java\/security,java\/security\/cert,java\/security\/interfaces,java\/security\/spec,java\/text,java\/text\/spi,java\/time,java\/time\/chrono,java\/time\/format,java\/time\/temporal,java\/time\/zone,java\/util,java\/util\/concurrent,java\/util\/concurrent\/atomic,java\/util\/concurrent\/locks,java\/util\/function,java\/util\/jar,java\/util\/random,java\/util\/regex,java\/util\/spi,java\/util\/stream,java\/util\/zip,javax\/crypto,javax\/crypto\/interfaces,javax\/crypto\/spec,javax\/net,javax\/net\/ssl,javax\/security\/auth,javax\/security\/auth\/callback,javax\/security\/auth\/login,javax\/security\/auth\/spi,javax\/security\/auth\/x500,javax\/security\/cert uses java\/lang\/System$LoggerFinder,java\/net\/ContentHandlerFactory,java\/net\/spi\/URLStreamHandlerProvider,java\/nio\/channels\/spi\/AsynchronousChannelProvider,java\/nio\/channels\/spi\/SelectorProvider,java\/nio\/charset\/spi\/CharsetProvider,java\/nio\/file\/spi\/FileSystemProvider,java\/nio\/file\/spi\/FileTypeDetector,java\/security\/Provider,java\/text\/spi\/BreakIteratorProvider,java\/text\/spi\/CollatorProvider,java\/text\/spi\/DateFormatProvider,java\/text\/spi\/DateFormatSymbolsProvider,java\/text\/spi\/DecimalFormatSymbolsProvider,java\/text\/spi\/NumberFormatProvider,java\/time\/chrono\/AbstractChronology,java\/time\/chrono\/Chronology,java\/time\/zone\/ZoneRulesProvider,java\/util\/random\/RandomGenerator,java\/util\/spi\/CalendarDataProvider,java\/util\/spi\/CalendarNameProvider,java\/util\/spi\/CurrencyNameProvider,java\/util\/spi\/LocaleNameProvider,java\/util\/spi\/ResourceBundleControlProvider,java\/util\/spi\/ResourceBundleProvider,java\/util\/spi\/TimeZoneNameProvider,java\/util\/spi\/ToolProvider,javax\/security\/auth\/spi\/LoginModule,jdk\/internal\/logger\/DefaultLoggerFinder,sun\/text\/spi\/JavaTimeDateTimePatternProvider,sun\/util\/locale\/provider\/LocaleDataMetaInfo,sun\/util\/resources\/LocaleData$CommonResourceBundleProvider,sun\/util\/resources\/LocaleData$SupplementaryResourceBundleProvider,sun\/util\/spi\/CalendarProvider provides interface\\u0020;java\/nio\/file\/spi\/FileSystemProvider\\u0020;impls\\u0020;jdk\/internal\/jrtfs\/JrtFileSystemProvider,interface\\u0020;java\/util\/random\/RandomGenerator\\u0020;impls\\u0020;java\/security\/SecureRandom\\u005C;u002C;java\/util\/Random\\u005C;u002C;java\/util\/SplittableRandom target linux-amd64 flags 8000\n+\n+class name java\/io\/CharArrayReader\n+method name read descriptor (Ljava\/nio\/CharBuffer;)I thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/Console\n+method name charset descriptor ()Ljava\/nio\/charset\/Charset; flags 1\n+\n+class name java\/io\/FileInputStream\n+method name readAllBytes descriptor ()[B thrownTypes java\/io\/IOException flags 1\n+method name readNBytes descriptor (I)[B thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/InputStreamReader\n+method name read descriptor (Ljava\/nio\/CharBuffer;)I thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/ObjectInputFilter\n+method name allowFilter descriptor (Ljava\/util\/function\/Predicate;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter; flags 9 signature (Ljava\/util\/function\/Predicate<Ljava\/lang\/Class<*>;>;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter;\n+method name rejectFilter descriptor (Ljava\/util\/function\/Predicate;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter; flags 9 signature (Ljava\/util\/function\/Predicate<Ljava\/lang\/Class<*>;>;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter;\n+method name merge descriptor (Ljava\/io\/ObjectInputFilter;Ljava\/io\/ObjectInputFilter;)Ljava\/io\/ObjectInputFilter; flags 9\n+method name rejectUndecidedClass descriptor (Ljava\/io\/ObjectInputFilter;)Ljava\/io\/ObjectInputFilter; flags 9\n+\n+class name java\/io\/ObjectInputFilter$Config\n+method name getSerialFilterFactory descriptor ()Ljava\/util\/function\/BinaryOperator; flags 9 signature ()Ljava\/util\/function\/BinaryOperator<Ljava\/io\/ObjectInputFilter;>;\n+method name setSerialFilterFactory descriptor (Ljava\/util\/function\/BinaryOperator;)V flags 9 signature (Ljava\/util\/function\/BinaryOperator<Ljava\/io\/ObjectInputFilter;>;)V\n+\n+class name java\/io\/PrintStream\n+header extends java\/io\/FilterOutputStream implements java\/lang\/Appendable,java\/io\/Closeable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/io\/WriteAbortedException\n+-field name detail descriptor Ljava\/lang\/Exception;\n+field name detail descriptor Ljava\/lang\/Exception; flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/lang\/AbstractStringBuilder\n+header extends java\/lang\/Object implements java\/lang\/Appendable,java\/lang\/CharSequence flags 420\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/Class\n+-method name isSealed descriptor ()Z\n+-method name getPermittedSubclasses descriptor ()[Ljava\/lang\/Class;\n+method name getPermittedSubclasses descriptor ()[Ljava\/lang\/Class; flags 1 signature ()[Ljava\/lang\/Class<*>; runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isSealed descriptor ()Z flags 1\n+\n+class name java\/lang\/Compiler\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/lang\/Deprecated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;MODULE;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;TYPE;})\n+\n+class name java\/lang\/IllegalCallerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/LayerInstantiationException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/NamedPackage\n+header extends java\/lang\/Object flags 20\n+\n+class name java\/lang\/Process\n+method name inputReader descriptor ()Ljava\/io\/BufferedReader; flags 11\n+method name inputReader descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedReader; flags 11\n+method name errorReader descriptor ()Ljava\/io\/BufferedReader; flags 11\n+method name errorReader descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedReader; flags 11\n+method name outputWriter descriptor ()Ljava\/io\/BufferedWriter; flags 11\n+method name outputWriter descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedWriter; flags 11\n+\n+class name java\/lang\/SecurityManager\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens outerClass java\/lang\/module\/ModuleDescriptor innerClassName Opens flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports outerClass java\/lang\/module\/ModuleDescriptor innerClassName Exports flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name checkMulticast descriptor (Ljava\/net\/InetAddress;B)V\n+method name checkMulticast descriptor (Ljava\/net\/InetAddress;B)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.4\")\n+\n+class name java\/lang\/StrictMath\n+-method name toRadians descriptor (D)D\n+-method name toDegrees descriptor (D)D\n+method name toRadians descriptor (D)D flags 9\n+method name toDegrees descriptor (D)D flags 9\n+\n+class name java\/lang\/SuppressWarnings\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;MODULE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)\n+\n+class name java\/lang\/System\n+-method name setSecurityManager descriptor (Ljava\/lang\/SecurityManager;)V\n+-method name getSecurityManager descriptor ()Ljava\/lang\/SecurityManager;\n+method name setSecurityManager descriptor (Ljava\/lang\/SecurityManager;)V flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name getSecurityManager descriptor ()Ljava\/lang\/SecurityManager; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/Thread\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/ThreadGroup\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/constant\/ClassDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfField sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/constant\/ClassDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+\n+class name java\/lang\/constant\/ConstantDesc\n+header extends java\/lang\/Object sealed true flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/constant\/DirectMethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/MethodHandleDesc nestMembers java\/lang\/constant\/DirectMethodHandleDesc$Kind sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/DynamicConstantDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass java\/lang\/Enum$EnumDesc outerClass java\/lang\/Enum innerClassName EnumDesc flags 19\n+innerclass innerClass java\/lang\/invoke\/VarHandle$VarHandleDesc outerClass java\/lang\/invoke\/VarHandle innerClassName VarHandleDesc flags 19\n+\n+class name java\/lang\/constant\/MethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodTypeDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfMethod sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfMethod<Ljava\/lang\/constant\/ClassDesc;Ljava\/lang\/constant\/MethodTypeDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfMethod outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfMethod flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/CallSite\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/LambdaMetafactory\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/MethodHandles\n+method name tableSwitch descriptor (Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/invoke\/MethodHandle; flags 89\n+\n+class name java\/lang\/invoke\/StringConcatException\n+header extends java\/lang\/Exception flags 21\n+\n+class name java\/lang\/module\/Configuration\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/module\/FindException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/InvalidModuleDescriptorException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ModuleReader\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 601\n+\n+class name java\/lang\/module\/ModuleReference\n+header extends java\/lang\/Object flags 421\n+\n+class name java\/lang\/module\/ResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ResolvedModule\n+header extends java\/lang\/Object flags 31\n+\n+class name java\/lang\/reflect\/AccessibleObject\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name <init> descriptor ()V\n+method name <init> descriptor ()V flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/lang\/reflect\/AnnotatedElement\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/Executable\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member,java\/lang\/reflect\/GenericDeclaration sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/InaccessibleObjectException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/runtime\/SwitchBootstraps\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;)\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name typeSwitch descriptor (Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite; thrownTypes java\/lang\/Throwable flags 89\n+\n+class name java\/net\/DatagramSocket\n+-method name setDatagramSocketImplFactory descriptor (Ljava\/net\/DatagramSocketImplFactory;)V\n+method name setDatagramSocketImplFactory descriptor (Ljava\/net\/DatagramSocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name joinGroup descriptor (Ljava\/net\/SocketAddress;Ljava\/net\/NetworkInterface;)V thrownTypes java\/io\/IOException flags 1\n+method name leaveGroup descriptor (Ljava\/net\/SocketAddress;Ljava\/net\/NetworkInterface;)V thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/net\/ServerSocket\n+-method name setSocketFactory descriptor (Ljava\/net\/SocketImplFactory;)V\n+method name setSocketFactory descriptor (Ljava\/net\/SocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/net\/Socket\n+-method name setSocketImplFactory descriptor (Ljava\/net\/SocketImplFactory;)V\n+method name setSocketImplFactory descriptor (Ljava\/net\/SocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/net\/URLDecoder\n+-method name <init> descriptor ()V\n+\n+class name java\/net\/URLStreamHandler\n+-method name getHostAddress descriptor (Ljava\/net\/URL;)Ljava\/net\/InetAddress;\n+method name getHostAddress descriptor (Ljava\/net\/URL;)Ljava\/net\/InetAddress; flags 4\n+\n+class name java\/net\/spi\/URLStreamHandlerProvider\n+header extends java\/lang\/Object implements java\/net\/URLStreamHandlerFactory flags 421\n+\n+class name java\/nio\/CharBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable,java\/lang\/Appendable,java\/lang\/CharSequence,java\/lang\/Readable flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/CharBuffer;>;Ljava\/lang\/Appendable;Ljava\/lang\/CharSequence;Ljava\/lang\/Readable;\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/nio\/MappedByteBuffer\n+method name slice descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name slice descriptor (II)Ljava\/nio\/MappedByteBuffer; flags 401\n+method name duplicate descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name compact descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name compact descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name duplicate descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name slice descriptor (II)Ljava\/nio\/ByteBuffer; flags 1041\n+method name slice descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name duplicate descriptor ()Ljava\/nio\/Buffer; flags 1041\n+method name slice descriptor (II)Ljava\/nio\/Buffer; flags 1041\n+method name slice descriptor ()Ljava\/nio\/Buffer; flags 1041\n+\n+class name java\/security\/AccessControlContext\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/AccessControlException\n+header extends java\/lang\/SecurityException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/AccessController\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/Certificate\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/DomainCombiner\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/Identity\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/Policy\n+header extends java\/lang\/Object nestMembers java\/security\/Policy$Parameters flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/security\/Policy$Parameters outerClass java\/security\/Policy innerClassName Parameters flags 609\n+\n+class name java\/security\/Policy$Parameters\n+header extends java\/lang\/Object nestHost java\/security\/Policy flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/security\/Policy$Parameters outerClass java\/security\/Policy innerClassName Parameters flags 609\n+\n+class name java\/security\/PolicySpi\n+header extends java\/lang\/Object flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/SecureRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SecureRandom\",isStochastic=Ztrue)\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name java\/security\/SecureRandomParameters\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/security\/SignedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/security\/cert\/CertificateRevokedException\n+header extends java\/security\/cert\/CertificateException flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/security\/cert\/URICertStoreParameters\n+header extends java\/lang\/Object implements java\/security\/cert\/CertStoreParameters flags 31\n+\n+class name java\/security\/interfaces\/RSAKey\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/MGF1ParameterSpec\n+-field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+-field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+\n+class name java\/security\/spec\/PSSParameterSpec\n+-field name TRAILER_FIELD_BC descriptor I\n+field name TRAILER_FIELD_BC descriptor I constantValue 1 flags 19\n+-method name toString descriptor ()Ljava\/lang\/String;\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/security\/spec\/RSAKeyGenParameterSpec\n+-method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAMultiPrimePrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAPublicKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/text\/DateFormatSymbols\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/text\/RuleBasedCollator\n+header extends java\/text\/Collator flags 21\n+innerclass innerClass java\/text\/Normalizer$Form outerClass java\/text\/Normalizer innerClassName Form flags 4019\n+\n+class name java\/time\/Clock\n+header extends java\/lang\/Object implements java\/time\/InstantSource flags 421\n+\n+class name java\/time\/InstantSource\n+header extends java\/lang\/Object flags 601\n+method name system descriptor ()Ljava\/time\/InstantSource; flags 9\n+method name tick descriptor (Ljava\/time\/InstantSource;Ljava\/time\/Duration;)Ljava\/time\/InstantSource; flags 9\n+method name fixed descriptor (Ljava\/time\/Instant;)Ljava\/time\/InstantSource; flags 9\n+method name offset descriptor (Ljava\/time\/InstantSource;Ljava\/time\/Duration;)Ljava\/time\/InstantSource; flags 9\n+method name instant descriptor ()Ljava\/time\/Instant; flags 401\n+method name millis descriptor ()J flags 1\n+method name withZone descriptor (Ljava\/time\/ZoneId;)Ljava\/time\/Clock; flags 1\n+\n+class name java\/time\/chrono\/ChronoLocalDate\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDate;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDateTime\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature <D::Ljava\/time\/chrono\/ChronoLocalDate;>Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDateTime<*>;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/format\/DecimalStyle\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/time\/temporal\/TemporalAdjusters\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Comparator\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/DoubleSummaryStatistics\n+header extends java\/lang\/Object implements java\/util\/function\/DoubleConsumer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/GregorianCalendar\n+header extends java\/util\/Calendar flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/HashSet\n+header extends java\/util\/AbstractSet implements java\/util\/Set,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/Set<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/HexFormat\n+header extends java\/lang\/Object flags 31\n+method name of descriptor ()Ljava\/util\/HexFormat; flags 9\n+method name ofDelimiter descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 9\n+method name withDelimiter descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withPrefix descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withSuffix descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withUpperCase descriptor ()Ljava\/util\/HexFormat; flags 1\n+method name withLowerCase descriptor ()Ljava\/util\/HexFormat; flags 1\n+method name delimiter descriptor ()Ljava\/lang\/String; flags 1\n+method name prefix descriptor ()Ljava\/lang\/String; flags 1\n+method name suffix descriptor ()Ljava\/lang\/String; flags 1\n+method name isUpperCase descriptor ()Z flags 1\n+method name formatHex descriptor ([B)Ljava\/lang\/String; flags 1\n+method name formatHex descriptor ([BII)Ljava\/lang\/String; flags 1\n+method name formatHex descriptor (Ljava\/lang\/Appendable;[B)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;[B)TA;\n+method name formatHex descriptor (Ljava\/lang\/Appendable;[BII)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;[BII)TA;\n+method name parseHex descriptor (Ljava\/lang\/CharSequence;)[B flags 1\n+method name parseHex descriptor (Ljava\/lang\/CharSequence;II)[B flags 1\n+method name parseHex descriptor ([CII)[B flags 1\n+method name toLowHexDigit descriptor (I)C flags 1\n+method name toHighHexDigit descriptor (I)C flags 1\n+method name toHexDigits descriptor (Ljava\/lang\/Appendable;B)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;B)TA;\n+method name toHexDigits descriptor (B)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (C)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (S)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (I)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (J)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (JI)Ljava\/lang\/String; flags 1\n+method name isHexDigit descriptor (I)Z flags 9\n+method name fromHexDigit descriptor (I)I flags 9\n+method name fromHexDigits descriptor (Ljava\/lang\/CharSequence;)I flags 9\n+method name fromHexDigits descriptor (Ljava\/lang\/CharSequence;II)I flags 9\n+method name fromHexDigitsToLong descriptor (Ljava\/lang\/CharSequence;)J flags 9\n+method name fromHexDigitsToLong descriptor (Ljava\/lang\/CharSequence;II)J flags 9\n+method name equals descriptor (Ljava\/lang\/Object;)Z flags 1\n+method name hashCode descriptor ()I flags 1\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/util\/Locale$IsoCountryCode\n+header extends java\/lang\/Enum nestHost java\/util\/Locale sealed true flags 4421 signature Ljava\/lang\/Enum<Ljava\/util\/Locale$IsoCountryCode;>;\n+innerclass innerClass java\/util\/Locale$IsoCountryCode outerClass java\/util\/Locale innerClassName IsoCountryCode flags 4409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Map$Entry\n+method name copyOf descriptor (Ljava\/util\/Map$Entry;)Ljava\/util\/Map$Entry; flags 9 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>(Ljava\/util\/Map$Entry<+TK;+TV;>;)Ljava\/util\/Map$Entry<TK;TV;>;\n+\n+class name java\/util\/Observable\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Observer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Random\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator,java\/io\/Serializable flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"Random\",i=I48,j=I0,k=I0,equidistribution=I0)\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name java\/util\/SplittableRandom\n+header extends jdk\/internal\/util\/random\/RandomSupport$AbstractSplittableGenerator flags 31 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SplittableRandom\",i=I64,j=I0,k=I0,equidistribution=I1)\n+innerclass innerClass jdk\/internal\/util\/random\/RandomSupport$AbstractSplittableGenerator outerClass jdk\/internal\/util\/random\/RandomSupport innerClassName AbstractSplittableGenerator flags 409\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+-method name nextInt descriptor (I)I\n+-method name nextInt descriptor (II)I\n+-method name nextLong descriptor (J)J\n+-method name nextLong descriptor (JJ)J\n+-method name nextDouble descriptor ()D\n+-method name nextDouble descriptor (D)D\n+-method name nextDouble descriptor (DD)D\n+-method name nextBoolean descriptor ()Z\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/SplittableRandom; flags 1\n+method name splits descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 1 signature (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 1 signature (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name split descriptor ()Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 1041\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 1041\n+\n+class name java\/util\/TimeZone\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/Timer\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/ref\/Cleaner$Cleanable outerClass java\/lang\/ref\/Cleaner innerClassName Cleanable flags 609\n+\n+class name java\/util\/TreeSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/concurrent\/ConcurrentMap\n+header extends java\/lang\/Object implements java\/util\/Map flags 601 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Map<TK;TV;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentSkipListSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/CountedCompleter\n+header extends java\/util\/concurrent\/ForkJoinTask flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/util\/concurrent\/ForkJoinTask<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/Executors\n+-method name privilegedThreadFactory descriptor ()Ljava\/util\/concurrent\/ThreadFactory;\n+-method name privilegedCallable descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable;\n+-method name privilegedCallableUsingCurrentClassLoader descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable;\n+method name privilegedThreadFactory descriptor ()Ljava\/util\/concurrent\/ThreadFactory; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name privilegedCallable descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<TT;>;)Ljava\/util\/concurrent\/Callable<TT;>; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name privilegedCallableUsingCurrentClassLoader descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<TT;>;)Ljava\/util\/concurrent\/Callable<TT;>; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/util\/concurrent\/ForkJoinPool\n+header extends java\/util\/concurrent\/AbstractExecutorService nestMembers java\/util\/concurrent\/ForkJoinPool$ManagedBlocker,java\/util\/concurrent\/ForkJoinPool$ForkJoinWorkerThreadFactory flags 21\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ForkJoinWorkerThreadFactory outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ForkJoinWorkerThreadFactory flags 609\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ManagedBlocker outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ManagedBlocker flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name invokeAll descriptor (Ljava\/util\/Collection;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/util\/List; thrownTypes java\/lang\/InterruptedException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/util\/List<Ljava\/util\/concurrent\/Future<TT;>;>;\n+method name invokeAny descriptor (Ljava\/util\/Collection;)Ljava\/lang\/Object; thrownTypes java\/lang\/InterruptedException,java\/util\/concurrent\/ExecutionException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;)TT;\n+method name invokeAny descriptor (Ljava\/util\/Collection;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/lang\/Object; thrownTypes java\/lang\/InterruptedException,java\/util\/concurrent\/ExecutionException,java\/util\/concurrent\/TimeoutException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;JLjava\/util\/concurrent\/TimeUnit;)TT;\n+\n+class name java\/util\/concurrent\/ForkJoinWorkerThread\n+header extends java\/lang\/Thread flags 21\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/util\/concurrent\/LinkedTransferQueue\n+header extends java\/util\/AbstractQueue implements java\/util\/concurrent\/TransferQueue,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractQueue<TE;>;Ljava\/util\/concurrent\/TransferQueue<TE;>;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ManagedBlocker outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ManagedBlocker flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ThreadLocalRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"ThreadLocalRandom\",i=I64,j=I0,k=I0,equidistribution=I1)\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+-method name nextGaussian descriptor ()D\n+method name nextFloat descriptor (F)F flags 1\n+method name nextFloat descriptor (FF)F flags 1\n+\n+class name java\/util\/concurrent\/atomic\/AtomicBoolean\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReference\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReferenceArray\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/locks\/StampedLock\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name tryWriteLock descriptor ()J\n+-method name writeLockInterruptibly descriptor ()J\n+-method name tryReadLock descriptor ()J\n+-method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J\n+-method name readLockInterruptibly descriptor ()J\n+-method name unlock descriptor (J)V\n+method name tryWriteLock descriptor ()J flags 1\n+method name writeLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name tryReadLock descriptor ()J flags 1\n+method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J thrownTypes java\/lang\/InterruptedException flags 1\n+method name readLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name unlock descriptor (J)V flags 1\n+\n+class name java\/util\/function\/BiConsumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiFunction\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiPredicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BinaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/BiFunction flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction<TT;TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Consumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoublePredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Function\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Predicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/UnaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/Function flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/Function<TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/random\/RandomGenerator\n+header extends java\/lang\/Object nestMembers java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator,java\/util\/random\/RandomGenerator$LeapableGenerator,java\/util\/random\/RandomGenerator$JumpableGenerator,java\/util\/random\/RandomGenerator$SplittableGenerator,java\/util\/random\/RandomGenerator$StreamableGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator; flags 9\n+method name getDefault descriptor ()Ljava\/util\/random\/RandomGenerator; flags 9\n+method name isDeprecated descriptor ()Z flags 1\n+method name doubles descriptor ()Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (DD)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (J)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (JDD)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name ints descriptor ()Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (II)Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (J)Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (JII)Ljava\/util\/stream\/IntStream; flags 1\n+method name longs descriptor ()Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (JJ)Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (J)Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (JJJ)Ljava\/util\/stream\/LongStream; flags 1\n+method name nextBoolean descriptor ()Z flags 1\n+method name nextBytes descriptor ([B)V flags 1\n+method name nextFloat descriptor ()F flags 1\n+method name nextFloat descriptor (F)F flags 1\n+method name nextFloat descriptor (FF)F flags 1\n+method name nextDouble descriptor ()D flags 1\n+method name nextDouble descriptor (D)D flags 1\n+method name nextDouble descriptor (DD)D flags 1\n+method name nextInt descriptor ()I flags 1\n+method name nextInt descriptor (I)I flags 1\n+method name nextInt descriptor (II)I flags 1\n+method name nextLong descriptor ()J flags 401\n+method name nextLong descriptor (J)J flags 1\n+method name nextLong descriptor (JJ)J flags 1\n+method name nextGaussian descriptor ()D flags 1\n+method name nextGaussian descriptor (DD)D flags 1\n+method name nextExponential descriptor ()D flags 1\n+\n+class name java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$LeapableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 401\n+method name jumpPowerOfTwo descriptor (I)V flags 401\n+method name jump descriptor (D)V flags 401\n+method name jump descriptor ()V flags 1\n+method name jumps descriptor (D)Ljava\/util\/stream\/Stream; flags 1 signature (D)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator;>;\n+method name jumps descriptor (JD)Ljava\/util\/stream\/Stream; flags 1 signature (JD)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator;>;\n+method name leap descriptor ()V flags 1\n+method name copyAndJump descriptor (D)Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 1\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 1041\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1041\n+\n+class name java\/util\/random\/RandomGenerator$JumpableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$StreamableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 401\n+method name jump descriptor ()V flags 401\n+method name jumpDistance descriptor ()D flags 401\n+method name jumps descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name jumps descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name copyAndJump descriptor ()Ljava\/util\/random\/RandomGenerator; flags 1\n+\n+class name java\/util\/random\/RandomGenerator$LeapableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$JumpableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 401\n+method name leap descriptor ()V flags 401\n+method name leapDistance descriptor ()D flags 401\n+method name leaps descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$JumpableGenerator;>;\n+method name leaps descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$JumpableGenerator;>;\n+method name copyAndLeap descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1041\n+\n+class name java\/util\/random\/RandomGenerator$SplittableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$StreamableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 9\n+method name split descriptor ()Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 401\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 401\n+method name splits descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (J)Ljava\/util\/stream\/Stream; flags 401 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 401 signature (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 401 signature (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+\n+class name java\/util\/random\/RandomGenerator$StreamableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$StreamableGenerator; flags 9\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 401 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+\n+class name java\/util\/random\/RandomGeneratorFactory\n+header extends java\/lang\/Object flags 31 signature <T::Ljava\/util\/random\/RandomGenerator;>Ljava\/lang\/Object;\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGeneratorFactory; flags 9 signature <T::Ljava\/util\/random\/RandomGenerator;>(Ljava\/lang\/String;)Ljava\/util\/random\/RandomGeneratorFactory<TT;>;\n+method name getDefault descriptor ()Ljava\/util\/random\/RandomGeneratorFactory; flags 9 signature ()Ljava\/util\/random\/RandomGeneratorFactory<Ljava\/util\/random\/RandomGenerator;>;\n+method name all descriptor ()Ljava\/util\/stream\/Stream; flags 9 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGeneratorFactory<Ljava\/util\/random\/RandomGenerator;>;>;\n+method name name descriptor ()Ljava\/lang\/String; flags 1\n+method name group descriptor ()Ljava\/lang\/String; flags 1\n+method name stateBits descriptor ()I flags 1\n+method name equidistribution descriptor ()I flags 1\n+method name period descriptor ()Ljava\/math\/BigInteger; flags 1\n+method name isStatistical descriptor ()Z flags 1\n+method name isStochastic descriptor ()Z flags 1\n+method name isHardware descriptor ()Z flags 1\n+method name isArbitrarilyJumpable descriptor ()Z flags 1\n+method name isJumpable descriptor ()Z flags 1\n+method name isLeapable descriptor ()Z flags 1\n+method name isSplittable descriptor ()Z flags 1\n+method name isStreamable descriptor ()Z flags 1\n+method name isDeprecated descriptor ()Z flags 1\n+method name create descriptor ()Ljava\/util\/random\/RandomGenerator; flags 1 signature ()TT;\n+method name create descriptor (J)Ljava\/util\/random\/RandomGenerator; flags 1 signature (J)TT;\n+method name create descriptor ([B)Ljava\/util\/random\/RandomGenerator; flags 1 signature ([B)TT;\n+\n+class name java\/util\/spi\/AbstractResourceBundleProvider\n+header extends java\/lang\/Object implements java\/util\/spi\/ResourceBundleProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/spi\/CurrencyNameProvider\n+header extends java\/util\/spi\/LocaleServiceProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+\n+class name java\/util\/spi\/ResourceBundleProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/util\/spi\/ToolProvider\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/zip\/CRC32C\n+header extends java\/lang\/Object implements java\/util\/zip\/Checksum flags 31\n+\n+class name javax\/crypto\/AEADBadTagException\n+header extends javax\/crypto\/BadPaddingException flags 21\n+\n+class name javax\/crypto\/BadPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/CipherInputStream\n+header extends java\/io\/FilterInputStream flags 21\n+\n+class name javax\/crypto\/CipherOutputStream\n+header extends java\/io\/FilterOutputStream flags 21\n+\n+class name javax\/crypto\/CipherSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/EncryptedPrivateKeyInfo\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanism\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/IllegalBlockSizeException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/KeyAgreement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyAgreementSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/KeyGenerator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyGeneratorSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/Mac\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/MacSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/NoSuchPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/NullCipher\n+header extends javax\/crypto\/Cipher flags 21\n+\n+class name javax\/crypto\/SealedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/crypto\/SecretKey\n+header extends java\/lang\/Object implements java\/security\/Key,javax\/security\/auth\/Destroyable flags 601\n+\n+class name javax\/crypto\/SecretKeyFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/SecretKeyFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/ShortBufferException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/interfaces\/DHKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPrivateKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PrivateKey flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPublicKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PublicKey flags 601\n+\n+class name javax\/crypto\/interfaces\/PBEKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 601\n+\n+class name javax\/crypto\/spec\/DESKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DESedeKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHGenParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPrivateKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPublicKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/GCMParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/IvParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/OAEPParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+innerclass innerClass javax\/crypto\/spec\/PSource$PSpecified outerClass javax\/crypto\/spec\/PSource innerClassName PSpecified flags 19\n+\n+class name javax\/crypto\/spec\/PBEKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/PBEParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC2ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC5ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/SecretKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec,javax\/crypto\/SecretKey flags 21\n+\n+class name javax\/security\/auth\/Subject\n+-method name getSubject descriptor (Ljava\/security\/AccessControlContext;)Ljavax\/security\/auth\/Subject;\n+-method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object;\n+-method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object;\n+method name getSubject descriptor (Ljava\/security\/AccessControlContext;)Ljavax\/security\/auth\/Subject; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction<TT;>;Ljava\/security\/AccessControlContext;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object; thrownTypes java\/security\/PrivilegedActionException flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction<TT;>;Ljava\/security\/AccessControlContext;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name javax\/security\/auth\/SubjectDomainCombiner\n+header extends java\/lang\/Object implements java\/security\/DomainCombiner flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n","filename":"make\/data\/symbols\/java.base-H.sym.txt","additions":930,"deletions":0,"binary":false,"changes":930,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/annotation\/processing\/AbstractProcessor\n+header extends java\/lang\/Object implements javax\/annotation\/processing\/Processor flags 421\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/annotation\/processing\/Generated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;PARAMETER;})\n+\n+class name javax\/lang\/model\/SourceVersion\n+field name RELEASE_17 descriptor Ljavax\/lang\/model\/SourceVersion; flags 4019\n+\n+class name javax\/lang\/model\/element\/Modifier\n+header extends java\/lang\/Enum sealed true flags 4021 signature Ljava\/lang\/Enum<Ljavax\/lang\/model\/element\/Modifier;>;\n+-field name SEALED descriptor Ljavax\/lang\/model\/element\/Modifier;\n+-field name NON_SEALED descriptor Ljavax\/lang\/model\/element\/Modifier;\n+field name SEALED descriptor Ljavax\/lang\/model\/element\/Modifier; flags 4019\n+field name NON_SEALED descriptor Ljavax\/lang\/model\/element\/Modifier; flags 4019\n+\n+class name javax\/lang\/model\/element\/TypeElement\n+-method name getPermittedSubclasses descriptor ()Ljava\/util\/List;\n+method name getPermittedSubclasses descriptor ()Ljava\/util\/List; flags 1 signature ()Ljava\/util\/List<+Ljavax\/lang\/model\/type\/TypeMirror;>;\n+\n+class name javax\/lang\/model\/element\/UnknownAnnotationValueException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownDirectiveException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass javax\/lang\/model\/element\/ModuleElement$Directive outerClass javax\/lang\/model\/element\/ModuleElement innerClassName Directive flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownElementException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypeException\n+header extends javax\/lang\/model\/type\/MirroredTypesException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypesException\n+header extends java\/lang\/RuntimeException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/UnknownTypeException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/AbstractAnnotationValueVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractElementVisitor14\n+header extends javax\/lang\/model\/util\/AbstractElementVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor14\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor6\n+header extends java\/lang\/Object implements javax\/lang\/model\/type\/TypeVisitor flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/lang\/model\/type\/TypeVisitor<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_6;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor7\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor6 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor6<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_7;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor8\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor7 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor7<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_8;)\n+\n+class name javax\/lang\/model\/util\/ElementKindVisitor14\n+header extends javax\/lang\/model\/util\/ElementKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/ElementScanner14\n+header extends javax\/lang\/model\/util\/ElementScanner9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementScanner9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/Elements\n+method name isAutomaticModule descriptor (Ljavax\/lang\/model\/element\/ModuleElement;)Z flags 1\n+\n+class name javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/SimpleAnnotationValueVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/SimpleElementVisitor14\n+header extends javax\/lang\/model\/util\/SimpleElementVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/SimpleTypeVisitor14\n+header extends javax\/lang\/model\/util\/SimpleTypeVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/TypeKindVisitor14\n+header extends javax\/lang\/model\/util\/TypeKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/TypeKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/tools\/SimpleJavaFileObject\n+header extends java\/lang\/Object implements javax\/tools\/JavaFileObject flags 21\n+innerclass innerClass javax\/tools\/JavaFileObject$Kind outerClass javax\/tools\/JavaFileObject innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/tools\/ToolProvider\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.compiler-H.sym.txt","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/awt\/datatransfer\/Clipboard\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/datatransfer\/DataFlavor\n+header extends java\/lang\/Object implements java\/io\/Externalizable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name selectionHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+-field name fragmentHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+-field name allHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+field name selectionHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+field name fragmentHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+field name allHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+\n","filename":"make\/data\/symbols\/java.datatransfer-H.sym.txt","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,902 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/applet\/Applet\n+header extends java\/awt\/Panel nestMembers java\/applet\/Applet$AccessibleApplet flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+innerclass innerClass java\/applet\/Applet$AccessibleApplet outerClass java\/applet\/Applet innerClassName AccessibleApplet flags 4\n+\n+class name java\/applet\/AppletContext\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/applet\/AppletStub\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/applet\/AudioClip\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/awt\/AWTKeyStroke\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/AttributeValue\n+header extends java\/lang\/Object flags 420\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/BorderLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/CheckboxGroup\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Color\n+header extends java\/lang\/Object implements java\/awt\/Paint,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/ContainerOrderFocusTraversalPolicy\n+header extends java\/awt\/FocusTraversalPolicy implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Dimension\n+header extends java\/awt\/geom\/Dimension2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/DisplayMode\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Event\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FlowLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FontMetrics\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Graphics\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/GridBagLayoutInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+\n+class name java\/awt\/GridLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/HeadlessException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Insets\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MenuShortcut\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Point\n+header extends java\/awt\/geom\/Point2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Rectangle\n+header extends java\/awt\/geom\/Rectangle2D implements java\/awt\/Shape,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/SystemColor\n+header extends java\/awt\/Color implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TexturePaint\n+header extends java\/lang\/Object implements java\/awt\/Paint flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/color\/ColorSpace\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/color\/ICC_ColorSpace\n+header extends java\/awt\/color\/ColorSpace flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name java\/awt\/desktop\/AboutEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AboutHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/AppEvent\n+header extends java\/util\/EventObject flags 21\n+\n+class name java\/awt\/desktop\/AppForegroundEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppForegroundListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppHiddenEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppHiddenListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppReopenedEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppReopenedListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/FilesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 21\n+\n+class name java\/awt\/desktop\/OpenFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/OpenURIEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenURIHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PreferencesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/PreferencesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PrintFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/PrintFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/QuitHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitResponse\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitStrategy\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/awt\/desktop\/QuitStrategy;>;\n+\n+class name java\/awt\/desktop\/ScreenSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/ScreenSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemEventListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/SystemSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/UserSessionListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/dnd\/DragGestureEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragGestureRecognizer\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragSource\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDragEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDropEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ActionEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/AdjustmentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ComponentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ContainerEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/HierarchyEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputMethodEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ItemEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/MouseWheelEvent\n+header extends java\/awt\/event\/MouseEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/PaintEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/WindowEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/FontRenderContext\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/awt\/RenderingHints$Key outerClass java\/awt\/RenderingHints innerClassName Key flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/GraphicAttribute\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/ImageGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/NumericShaper$Range\n+header extends java\/lang\/Enum nestHost java\/awt\/font\/NumericShaper sealed true flags 4021 signature Ljava\/lang\/Enum<Ljava\/awt\/font\/NumericShaper$Range;>;\n+innerclass innerClass java\/awt\/font\/NumericShaper$Range outerClass java\/awt\/font\/NumericShaper innerClassName Range flags 4009\n+\n+class name java\/awt\/font\/ShapeGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/TextHitInfo\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/TextMeasurer\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/AffineTransform\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Double outerClass java\/awt\/geom\/Point2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/Area\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/geom\/RectangularShape\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/image\/AbstractMultiResolutionImage\n+header extends java\/awt\/Image implements java\/awt\/image\/MultiResolutionImage flags 421\n+\n+class name java\/awt\/image\/BandCombineOp\n+header extends java\/lang\/Object implements java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BandedSampleModel\n+header extends java\/awt\/image\/ComponentSampleModel flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BaseMultiResolutionImage\n+header extends java\/awt\/image\/AbstractMultiResolutionImage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BufferedImageFilter\n+header extends java\/awt\/image\/ImageFilter implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ByteLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ColorConvertOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/ComponentColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ComponentSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ConvolveOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/DataBufferUShort\n+header extends java\/awt\/image\/DataBuffer flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/DirectColorModel\n+header extends java\/awt\/image\/PackedColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ImageFilter\n+header extends java\/lang\/Object implements java\/awt\/image\/ImageConsumer,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/IndexColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Kernel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/LookupOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiPixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiResolutionImage\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/image\/PackedColorModel\n+header extends java\/awt\/image\/ColorModel flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Raster\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ReplicateScaleFilter\n+header extends java\/awt\/image\/ImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/RescaleOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SampleModel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ShortLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SinglePixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/print\/Paper\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/beans\/AppletInitializer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/beans\/BeanProperty\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;METHOD;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/Beans\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name instantiate descriptor (Ljava\/lang\/ClassLoader;Ljava\/lang\/String;Ljava\/beans\/beancontext\/BeanContext;Ljava\/beans\/AppletInitializer;)Ljava\/lang\/Object;\n+method name instantiate descriptor (Ljava\/lang\/ClassLoader;Ljava\/lang\/String;Ljava\/beans\/beancontext\/BeanContext;Ljava\/beans\/AppletInitializer;)Ljava\/lang\/Object; thrownTypes java\/io\/IOException,java\/lang\/ClassNotFoundException flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/beans\/DefaultPersistenceDelegate\n+header extends java\/beans\/PersistenceDelegate flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Encoder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/EventSetDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Expression\n+header extends java\/beans\/Statement flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/FeatureDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/beans\/IndexedPropertyDescriptor\n+header extends java\/beans\/PropertyDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/JavaBean\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/PropertyDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/SimpleBeanInfo\n+header extends java\/lang\/Object implements java\/beans\/BeanInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibilityProvider\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/accessibility\/AccessibleBundle\n+header extends java\/lang\/Object flags 421 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/accessibility\/AccessibleRelationSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibleStateSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/metadata\/IIOMetadata\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGHuffmanTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGQTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFDirectory\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFField\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFImageReadParam\n+header extends javax\/imageio\/ImageReadParam flags 31\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTag\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTagSet\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/imageio\/spi\/ImageReaderWriterSpi\n+header extends javax\/imageio\/spi\/IIOServiceProvider flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/DateTimeSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/EnumSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/IntegerSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/standard\/MediaPrintableArea\n+header extends java\/lang\/Object implements javax\/print\/attribute\/DocAttribute,javax\/print\/attribute\/PrintRequestAttribute,javax\/print\/attribute\/PrintJobAttribute flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/event\/PrintEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MetaMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MidiMessage\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/Sequence\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/ShortMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/SysexMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/sampled\/ReverbType\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/sound\/sampled\/spi\/FormatConversionProvider\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/sound\/sampled\/AudioFormat$Encoding outerClass javax\/sound\/sampled\/AudioFormat innerClassName Encoding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/BoxLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DebugGraphics\n+header extends java\/awt\/Graphics flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultBoundedRangeModel\n+header extends java\/lang\/Object implements javax\/swing\/BoundedRangeModel,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultListSelectionModel\n+header extends java\/lang\/Object implements javax\/swing\/ListSelectionModel,java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GrayFilter\n+header extends java\/awt\/image\/RGBImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/JApplet\n+header extends java\/applet\/Applet implements javax\/accessibility\/Accessible,javax\/swing\/RootPaneContainer,javax\/swing\/TransferHandler$HasGetTransferHandler nestMembers javax\/swing\/JApplet$AccessibleJApplet flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")@Ljava\/beans\/JavaBean;(defaultProperty=\"JMenuBar\",description=\"Swing's\\u005C;u0020;Applet\\u005C;u0020;subclass.\")@Ljavax\/swing\/SwingContainer;(delegate=\"getContentPane\")\n+innerclass innerClass javax\/swing\/JApplet$AccessibleJApplet outerClass javax\/swing\/JApplet innerClassName AccessibleJApplet flags 4\n+innerclass innerClass javax\/swing\/TransferHandler$HasGetTransferHandler outerClass javax\/swing\/TransferHandler innerClassName HasGetTransferHandler flags 608\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/JList$AccessibleJList$AccessibleJListChild\n+-method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction;\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+\n+class name javax\/swing\/JSlider$AccessibleJSlider\n+header extends javax\/swing\/JComponent$AccessibleJComponent implements javax\/accessibility\/AccessibleValue,javax\/swing\/event\/ChangeListener,javax\/accessibility\/AccessibleAction nestHost javax\/swing\/JSlider flags 21\n+innerclass innerClass javax\/swing\/JSlider$AccessibleJSlider outerClass javax\/swing\/JSlider innerClassName AccessibleJSlider flags 4\n+innerclass innerClass javax\/swing\/JComponent$AccessibleJComponent outerClass javax\/swing\/JComponent innerClassName AccessibleJComponent flags 401\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+method name getAccessibleActionCount descriptor ()I flags 1\n+method name getAccessibleActionDescription descriptor (I)Ljava\/lang\/String; flags 1\n+method name doAccessibleAction descriptor (I)Z flags 1\n+\n+class name javax\/swing\/JTextPane\n+header extends javax\/swing\/JEditorPane flags 21 runtimeAnnotations @Ljava\/beans\/JavaBean;(description=\"A\\u005C;u0020;text\\u005C;u0020;component\\u005C;u0020;that\\u005C;u0020;can\\u005C;u0020;be\\u005C;u0020;marked\\u005C;u0020;up\\u005C;u0020;with\\u005C;u0020;attributes\\u005C;u0020;that\\u005C;u0020;are\\u005C;u0020;graphically\\u005C;u0020;represented.\")@Ljavax\/swing\/SwingContainer;\n+\n+class name javax\/swing\/LookAndFeel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/text\/JTextComponent$KeyBinding outerClass javax\/swing\/text\/JTextComponent innerClassName KeyBinding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/MenuSelectionManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/RepaintManager\n+-method name addDirtyRegion descriptor (Ljava\/applet\/Applet;IIII)V\n+method name addDirtyRegion descriptor (Ljava\/applet\/Applet;IIII)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/swing\/SizeRequirements\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SortingFocusTraversalPolicy\n+header extends javax\/swing\/InternalFrameFocusTraversalPolicy flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SwingContainer\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/swing\/UIClientPropertyKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/swing\/border\/LineBorder\n+header extends javax\/swing\/border\/AbstractBorder flags 21\n+innerclass innerClass java\/awt\/geom\/RoundRectangle2D$Float outerClass java\/awt\/geom\/RoundRectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name javax\/swing\/event\/EventListenerList\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListDataEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListSelectionEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/TreeModelEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileNameExtensionFilter\n+header extends javax\/swing\/filechooser\/FileFilter flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileSystemView\n+method name getSystemIcon descriptor (Ljava\/io\/File;II)Ljavax\/swing\/Icon; flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicArrowButton\n+header extends javax\/swing\/JButton implements javax\/swing\/SwingConstants flags 21\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicButtonUI\n+header extends javax\/swing\/plaf\/ButtonUI flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicDirectoryModel\n+-method name intervalAdded descriptor (Ljavax\/swing\/event\/ListDataEvent;)V\n+-method name intervalRemoved descriptor (Ljavax\/swing\/event\/ListDataEvent;)V\n+-method name lt descriptor (Ljava\/io\/File;Ljava\/io\/File;)Z\n+method name intervalAdded descriptor (Ljavax\/swing\/event\/ListDataEvent;)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name intervalRemoved descriptor (Ljavax\/swing\/event\/ListDataEvent;)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name lt descriptor (Ljava\/io\/File;Ljava\/io\/File;)Z flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name javax\/swing\/plaf\/basic\/BasicMenuItemUI$MouseInputHandler\n+header extends java\/lang\/Object implements javax\/swing\/event\/MouseInputListener nestHost javax\/swing\/plaf\/basic\/BasicMenuItemUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicMenuItemUI$MouseInputHandler outerClass javax\/swing\/plaf\/basic\/BasicMenuItemUI innerClassName MouseInputHandler flags 4\n+\n+class name javax\/swing\/plaf\/basic\/BasicPasswordFieldUI\n+header extends javax\/swing\/plaf\/basic\/BasicTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$HSBChangeListener\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$HSBChangeListener outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName HSBChangeListener flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$PropertyChangeHandler\n+header extends java\/lang\/Object implements java\/beans\/PropertyChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$PropertyChangeHandler outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName PropertyChangeHandler flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$VSBChangeListener\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$VSBChangeListener outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName VSBChangeListener flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$ViewportChangeHandler\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$ViewportChangeHandler outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName ViewportChangeHandler flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarSeparatorUI\n+header extends javax\/swing\/plaf\/basic\/BasicSeparatorUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarUI\n+-method name createFloatingFrame descriptor (Ljavax\/swing\/JToolBar;)Ljavax\/swing\/JFrame;\n+method name createFloatingFrame descriptor (Ljavax\/swing\/JToolBar;)Ljavax\/swing\/JFrame; flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name javax\/swing\/plaf\/metal\/MetalButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalCheckBoxUI\n+header extends javax\/swing\/plaf\/metal\/MetalRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalRadioButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToggleButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicToggleButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolTipUI\n+header extends javax\/swing\/plaf\/basic\/BasicToolTipUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/multi\/MultiLookAndFeel\n+header extends javax\/swing\/LookAndFeel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthIcon\n+header extends java\/lang\/Object implements javax\/swing\/Icon flags 601\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuItemUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuItemUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthSeparatorUI\n+header extends javax\/swing\/plaf\/SeparatorUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/synth\/SynthStyle\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/UIDefaults$LazyInputMap outerClass javax\/swing\/UIDefaults innerClassName LazyInputMap flags 9\n+innerclass innerClass javax\/swing\/UIDefaults$LazyValue outerClass javax\/swing\/UIDefaults innerClassName LazyValue flags 609\n+\n+class name javax\/swing\/table\/AbstractTableModel\n+header extends java\/lang\/Object implements javax\/swing\/table\/TableModel,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/AbstractWriter\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/BoxView\n+header extends javax\/swing\/text\/CompositeView flags 21\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/CompositeView\n+header extends javax\/swing\/text\/View flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/DateFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/DateFormat$Field outerClass java\/text\/DateFormat innerClassName Field flags 9\n+\n+class name javax\/swing\/text\/IconView\n+header extends javax\/swing\/text\/View flags 21\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/LayoutQueue\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/NumberFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/NumberFormat$Field outerClass java\/text\/NumberFormat innerClassName Field flags 9\n+innerclass innerClass javax\/swing\/text\/DocumentFilter$FilterBypass outerClass javax\/swing\/text\/DocumentFilter innerClassName FilterBypass flags 409\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/Segment\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/text\/CharacterIterator,java\/lang\/CharSequence flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabSet\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabStop\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/View\n+header extends java\/lang\/Object implements javax\/swing\/SwingConstants flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$EventType outerClass javax\/swing\/event\/DocumentEvent innerClassName EventType flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/InlineView\n+header extends javax\/swing\/text\/LabelView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ListView\n+header extends javax\/swing\/text\/html\/BlockView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$ListPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName ListPainter flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/MinimalHTMLWriter\n+header extends javax\/swing\/text\/AbstractWriter flags 21\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ParagraphConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ParagraphConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$CharacterConstants outerClass javax\/swing\/text\/StyleConstants innerClassName CharacterConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$FontConstants outerClass javax\/swing\/text\/StyleConstants innerClassName FontConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ColorConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ColorConstants flags 9\n+innerclass innerClass javax\/swing\/text\/AbstractDocument$BranchElement outerClass javax\/swing\/text\/AbstractDocument innerClassName BranchElement flags 1\n+innerclass innerClass javax\/swing\/text\/StyleContext$NamedStyle outerClass javax\/swing\/text\/StyleContext innerClassName NamedStyle flags 1\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/ObjectView\n+header extends javax\/swing\/text\/ComponentView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/Option\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ParagraphView\n+header extends javax\/swing\/text\/ParagraphView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$BoxPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName BoxPainter flags 9\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/ContentModel\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/DocumentParser\n+header extends javax\/swing\/text\/html\/parser\/Parser flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTMLEditorKit$ParserCallback outerClass javax\/swing\/text\/html\/HTMLEditorKit innerClassName ParserCallback flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/Parser\n+header extends java\/lang\/Object implements javax\/swing\/text\/html\/parser\/DTDConstants flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/TagElement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$UnknownTag outerClass javax\/swing\/text\/html\/HTML innerClassName UnknownTag flags 9\n+\n+class name javax\/swing\/tree\/DefaultTreeModel\n+header extends java\/lang\/Object implements java\/io\/Serializable,javax\/swing\/tree\/TreeModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/swing\/tree\/DefaultTreeSelectionModel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable,javax\/swing\/tree\/TreeSelectionModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/tree\/TreePath\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/AbstractUndoableEdit\n+header extends java\/lang\/Object implements javax\/swing\/undo\/UndoableEdit,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/CompoundEdit\n+header extends javax\/swing\/undo\/AbstractUndoableEdit flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/UndoableEditSupport\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.desktop-H.sym.txt","additions":902,"deletions":0,"binary":false,"changes":902,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/instrument\/UnmodifiableModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/java.instrument-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/util\/logging\/ErrorManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/LogManager\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V thrownTypes java\/lang\/SecurityException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/util\/logging\/LoggingMXBean\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/logging\/LoggingPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/MemoryHandler\n+header extends java\/util\/logging\/Handler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SimpleFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SocketHandler\n+header extends java\/util\/logging\/StreamHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/XMLFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.logging-H.sym.txt","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/management\/LockInfo\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/ManagementPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MemoryUsage\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MonitorInfo\n+header extends java\/lang\/management\/LockInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/RuntimeMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Attribute\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/AttributeList\n+header extends java\/util\/ArrayList flags 21 signature Ljava\/util\/ArrayList<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadAttributeValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadBinaryOpValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadStringOperationException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ConstructorParameters\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/management\/ImmutableDescriptor\n+header extends java\/lang\/Object implements javax\/management\/Descriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanAttributeInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanConstructorInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanNotificationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanOperationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanParameterInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerDelegate\n+header extends java\/lang\/Object implements javax\/management\/MBeanServerDelegateMBean,javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanTrustPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Notification\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ObjectInstance\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Query\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StandardEmitterMBean\n+header extends javax\/management\/StandardMBean implements javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StringValueExp\n+header extends java\/lang\/Object implements javax\/management\/ValueExp flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/DefaultLoaderRepository\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/loading\/MLetContent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/InvalidTargetObjectTypeException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/XMLParseException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/ArrayType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,java\/io\/Serializable flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/CompositeData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport\n+header extends javax\/management\/MBeanAttributeInfo implements javax\/management\/openmbean\/OpenMBeanAttributeInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanOperationInfoSupport\n+header extends javax\/management\/MBeanOperationInfo implements javax\/management\/openmbean\/OpenMBeanOperationInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/SimpleType\n+header extends javax\/management\/openmbean\/OpenType flags 31 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/TabularData,java\/util\/Map,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature Ljava\/lang\/Object;Ljavax\/management\/openmbean\/TabularData;Ljava\/util\/Map<Ljava\/lang\/Object;Ljava\/lang\/Object;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/TabularData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RelationNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RelationSupport\n+header extends java\/lang\/Object implements javax\/management\/relation\/RelationSupportMBean,javax\/management\/MBeanRegistration flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/relation\/Role\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RoleUnresolved\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXConnectorServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXServiceURL\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/NotificationResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/TargetedNotification\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management-H.sym.txt","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/management\/remote\/rmi\/RMIConnectorServer\n+header extends javax\/management\/remote\/JMXConnectorServer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/rmi\/RMIIIOPServerImpl\n+header extends javax\/management\/remote\/rmi\/RMIServerImpl flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name javax\/management\/remote\/rmi\/RMIServerImpl\n+header extends java\/lang\/Object implements java\/io\/Closeable,javax\/management\/remote\/rmi\/RMIServer flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management.rmi-H.sym.txt","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/naming\/BinaryRefAddr\n+header extends javax\/naming\/RefAddr flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Binding\n+header extends javax\/naming\/NameClassPair flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompositeName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompoundName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Context\n+-field name APPLET descriptor Ljava\/lang\/String;\n+field name APPLET descriptor Ljava\/lang\/String; constantValue java.naming.applet flags 19 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/naming\/LinkException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NameClassPair\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NamingException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/RefAddr\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Reference\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/AttributeModificationException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/ModificationItem\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/SearchResult\n+header extends javax\/naming\/Binding flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.naming-H.sym.txt","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.rmi\n+header exports java\/rmi,java\/rmi\/dgc,java\/rmi\/registry,java\/rmi\/server,javax\/rmi\/ssl requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;java.logging\\u0020;flags\\u0020;0 uses java\/rmi\/server\/RMIClassLoaderSpi target linux-amd64 flags 8000\n+\n+class name java\/rmi\/RMISecurityManager\n+header extends java\/lang\/SecurityManager flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.8\")\n+\n+class name java\/rmi\/RemoteException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name java\/rmi\/activation\/Activatable\n+\n+-class name java\/rmi\/activation\/ActivateFailedException\n+\n+-class name java\/rmi\/activation\/ActivationDesc\n+\n+-class name java\/rmi\/activation\/ActivationException\n+\n+-class name java\/rmi\/activation\/ActivationGroup\n+\n+-class name java\/rmi\/activation\/ActivationGroupDesc\n+\n+-class name java\/rmi\/activation\/ActivationGroupDesc$CommandEnvironment\n+\n+-class name java\/rmi\/activation\/ActivationGroupID\n+\n+-class name java\/rmi\/activation\/ActivationGroup_Stub\n+\n+-class name java\/rmi\/activation\/ActivationID\n+\n+-class name java\/rmi\/activation\/ActivationInstantiator\n+\n+-class name java\/rmi\/activation\/ActivationMonitor\n+\n+-class name java\/rmi\/activation\/ActivationSystem\n+\n+-class name java\/rmi\/activation\/Activator\n+\n+-class name java\/rmi\/activation\/UnknownGroupException\n+\n+-class name java\/rmi\/activation\/UnknownObjectException\n+\n+class name java\/rmi\/dgc\/VMID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ObjID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/RemoteObject\n+header extends java\/lang\/Object implements java\/rmi\/Remote,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ServerCloneException\n+header extends java\/lang\/CloneNotSupportedException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/UID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.rmi-H.sym.txt","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/script\/ScriptException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.scripting-H.sym.txt","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/security\/auth\/kerberos\/DelegationPermission\n+header extends java\/security\/BasicPermission implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/EncryptionKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosCredMessage\n+header extends java\/lang\/Object implements javax\/security\/auth\/Destroyable flags 31\n+innerclass innerClass java\/util\/Base64$Encoder outerClass java\/util\/Base64 innerClassName Encoder flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosTicket\n+header extends java\/lang\/Object implements javax\/security\/auth\/Destroyable,javax\/security\/auth\/Refreshable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KeyTab\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/ServicePermission\n+header extends java\/security\/Permission implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/ietf\/jgss\/GSSException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/ietf\/jgss\/Oid\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.security.jgss-H.sym.txt","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/security\/sasl\/SaslException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.security.sasl-H.sym.txt","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/smartcardio\/ATR\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/Card\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CardChannel\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CardException\n+header extends java\/lang\/Exception flags 21\n+\n+class name javax\/smartcardio\/CardNotPresentException\n+header extends javax\/smartcardio\/CardException flags 21\n+\n+class name javax\/smartcardio\/CardPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/CardTerminal\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CommandAPDU\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/ResponseAPDU\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/TerminalFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/java.smartcardio-H.sym.txt","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/sql\/BatchUpdateException\n+header extends java\/sql\/SQLException flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name java\/sql\/ConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/JDBCType\n+header extends java\/lang\/Enum implements java\/sql\/SQLType flags 4031 signature Ljava\/lang\/Enum<Ljava\/sql\/JDBCType;>;Ljava\/sql\/SQLType;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/sql\/SQLWarning\n+header extends java\/sql\/SQLException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/sql\/ShardingKey\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/ShardingKeyBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/Statement\n+header extends java\/lang\/Object implements java\/sql\/Wrapper,java\/lang\/AutoCloseable flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/PooledConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/sql\/XAConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/java.sql-H.sym.txt","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/sql\/rowset\/BaseRowSet\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialArray\n+header extends java\/lang\/Object implements java\/sql\/Array,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialBlob\n+header extends java\/lang\/Object implements java\/sql\/Blob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialClob\n+header extends java\/lang\/Object implements java\/sql\/Clob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialDatalink\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialJavaObject\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialRef\n+header extends java\/lang\/Object implements java\/sql\/Ref,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialStruct\n+header extends java\/lang\/Object implements java\/sql\/Struct,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.sql.rowset-H.sym.txt","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/catalog\/Catalog\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/xml\/catalog\/CatalogException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name javax\/xml\/catalog\/CatalogManager\n+header extends java\/lang\/Object flags 31\n+\n+class name javax\/xml\/catalog\/CatalogResolver\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,javax\/xml\/stream\/XMLResolver,javax\/xml\/transform\/URIResolver,org\/w3c\/dom\/ls\/LSResourceResolver flags 601\n+\n+class name javax\/xml\/datatype\/DatatypeFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/datatype\/Duration\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/namespace\/QName\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilder\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilderFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParser\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParserFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/stream\/XMLEventReader\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Ljava\/lang\/Object;>;\n+\n+class name javax\/xml\/stream\/XMLInputFactory\n+-method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory;\n+method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory; thrownTypes javax\/xml\/stream\/FactoryConfigurationError flags 9\n+\n+class name javax\/xml\/stream\/XMLStreamException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/Transformer\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/TransformerException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/validation\/SchemaFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPath\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/xml\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPathNodes\n+header extends java\/lang\/Object implements java\/lang\/Iterable flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/Iterable<Lorg\/w3c\/dom\/Node;>;\n+\n+class name org\/w3c\/dom\/ElementTraversal\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/xml\/sax\/AttributeList\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/DocumentHandler\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/HandlerBase\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/DocumentHandler,org\/xml\/sax\/ErrorHandler flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/Parser\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/ext\/Attributes2Impl\n+header extends org\/xml\/sax\/helpers\/AttributesImpl implements org\/xml\/sax\/ext\/Attributes2 flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/AttributeListImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/AttributeList flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/AttributesImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/Attributes flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/ParserFactory\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/XMLFilterImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/XMLFilter,org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/ContentHandler,org\/xml\/sax\/ErrorHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/XMLReaderFactory\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.xml-H.sym.txt","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/crypto\/NodeSetData\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/Data,java\/lang\/Iterable flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/xml\/crypto\/Data;Ljava\/lang\/Iterable<TT;>;\n+\n+class name javax\/xml\/crypto\/dom\/DOMCryptoContext\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/XMLCryptoContext flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/SignatureMethod\n+field name RSA_PSS descriptor Ljava\/lang\/String; constantValue http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/XMLSignatureFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/keyinfo\/KeyInfoFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/spec\/RSAPSSParameterSpec\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/dsig\/spec\/SignatureMethodParameterSpec flags 31\n+method name <init> descriptor (Ljava\/security\/spec\/PSSParameterSpec;)V flags 1\n+method name getPSSParameterSpec descriptor ()Ljava\/security\/spec\/PSSParameterSpec; flags 1\n+\n","filename":"make\/data\/symbols\/java.xml.crypto-H.sym.txt","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/java\/accessibility\/util\/AccessibilityListenerList\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/java\/accessibility\/util\/EventID\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/java\/accessibility\/util\/GUIInitializedListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/TopLevelWindowListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/Translator\n+header extends javax\/accessibility\/AccessibleContext implements javax\/accessibility\/Accessible,javax\/accessibility\/AccessibleComponent flags 21\n+\n","filename":"make\/data\/symbols\/jdk.accessibility-H.sym.txt","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/tools\/attach\/AgentInitializationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AgentLoadException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachNotSupportedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachOperationFailedException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/VirtualMachine\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/VirtualMachineDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/spi\/AttachProvider\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.attach-H.sym.txt","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/source\/doctree\/AuthorTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/BlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/CommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DeprecatedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocCommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocRootTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocTreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/source\/doctree\/DocTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EndElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EntityTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/TextTree flags 601\n+\n+class name com\/sun\/source\/doctree\/HiddenTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IndexTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InheritDocTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LinkTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ParamTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ReferenceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SeeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialDataTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialFieldTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SinceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/StartElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SummaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/TextTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ThrowsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownBlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownInlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ValueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/VersionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotatedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayAccessTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/AssertTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/AssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BinaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BlockTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/BreakTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CaseLabelTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/CaseTree\n+method name getLabels descriptor ()Ljava\/util\/List; flags 401 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/tree\/CaseLabelTree;>; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/CatchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+-method name getPermitsClause descriptor ()Ljava\/util\/List;\n+method name getPermitsClause descriptor ()Ljava\/util\/List; flags 1 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/tree\/Tree;>;\n+\n+class name com\/sun\/source\/tree\/CompilationUnitTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+method name getModule descriptor ()Lcom\/sun\/source\/tree\/ModuleTree; flags 1\n+\n+class name com\/sun\/source\/tree\/CompoundAssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ConditionalExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ContinueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/DefaultCaseLabelTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/CaseLabelTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/DirectiveTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/DoWhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EmptyStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EnhancedForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExportsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree,com\/sun\/source\/tree\/CaseLabelTree flags 601 classAnnotations @Ljdk\/internal\/javac\/NoPreview;\n+\n+class name com\/sun\/source\/tree\/ForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/GuardedPatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/PatternTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name getPattern descriptor ()Lcom\/sun\/source\/tree\/PatternTree; flags 401\n+method name getExpression descriptor ()Lcom\/sun\/source\/tree\/ExpressionTree; flags 401\n+\n+class name com\/sun\/source\/tree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ImportTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/InstanceOfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IntersectionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/LabeledStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/LineMap\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MemberSelectTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodInvocationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ModifiersTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/NewArrayTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/NewClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/OpensTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/PackageTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParameterizedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParenthesizedPatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/PatternTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name getPattern descriptor ()Lcom\/sun\/source\/tree\/PatternTree; flags 401\n+\n+class name com\/sun\/source\/tree\/ParenthesizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/PatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree,com\/sun\/source\/tree\/CaseLabelTree flags 601\n+\n+class name com\/sun\/source\/tree\/PrimitiveTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/RequiresTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ReturnTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Scope\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/StatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/SwitchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/SynchronizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ThrowTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Tree$Kind\n+field name GUARDED_PATTERN descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+field name PARENTHESIZED_PATTERN descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+field name DEFAULT_CASE_LABEL descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/TreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/TryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeCastTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeParameterTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UnaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/UnionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/VariableTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WildcardTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/util\/DocSourcePositions\n+header extends java\/lang\/Object implements com\/sun\/source\/util\/SourcePositions flags 601\n+\n+class name com\/sun\/source\/util\/DocTreeFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass com\/sun\/source\/doctree\/AttributeTree$ValueKind outerClass com\/sun\/source\/doctree\/AttributeTree innerClassName ValueKind flags 4019\n+\n+class name com\/sun\/source\/util\/DocTreePathScanner\n+header extends com\/sun\/source\/util\/DocTreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/DocTreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTreeScanner\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTrees\n+header extends com\/sun\/source\/util\/Trees flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/source\/util\/JavacTask\n+header extends java\/lang\/Object implements javax\/tools\/JavaCompiler$CompilationTask flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+\n+class name com\/sun\/source\/util\/Plugin\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/SimpleDocTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/SimpleTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/TreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/tree\/TreeVisitor<TR;TP;>;\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/util\/SourcePositions\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TaskListener\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TreePathScanner\n+header extends com\/sun\/source\/util\/TreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/TreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/TreeScanner\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/util\/Trees\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/tools\/javac\/Main\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.compiler-H.sym.txt","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/dynalink\/CallSiteDescriptor\n+header extends jdk\/dynalink\/SecureLookupSupplier flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/DynamicLinker\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/StackWalker$StackFrame outerClass java\/lang\/StackWalker innerClassName StackFrame flags 609\n+innerclass innerClass java\/lang\/StackWalker$Option outerClass java\/lang\/StackWalker innerClassName Option flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/NamedOperation\n+header extends java\/lang\/Object implements jdk\/dynalink\/Operation flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/Namespace\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/NamespaceOperation\n+header extends java\/lang\/Object implements jdk\/dynalink\/Operation flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/NoSuchDynamicMethodException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/dynalink\/Operation\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/RelinkableCallSite\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/SecureLookupSupplier\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/StandardNamespace\n+header extends java\/lang\/Enum implements jdk\/dynalink\/Namespace flags 4031 signature Ljava\/lang\/Enum<Ljdk\/dynalink\/StandardNamespace;>;Ljdk\/dynalink\/Namespace;\n+\n+class name jdk\/dynalink\/StandardOperation\n+header extends java\/lang\/Enum implements jdk\/dynalink\/Operation flags 4031 signature Ljava\/lang\/Enum<Ljdk\/dynalink\/StandardOperation;>;Ljdk\/dynalink\/Operation;\n+\n+class name jdk\/dynalink\/beans\/MissingMemberHandlerFactory\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/GuardedInvocation\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/GuardedInvocationTransformer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/GuardingDynamicLinker\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/linker\/GuardingDynamicLinkerExporter\n+header extends java\/lang\/Object implements java\/util\/function\/Supplier flags 421 signature Ljava\/lang\/Object;Ljava\/util\/function\/Supplier<Ljava\/util\/List<Ljdk\/dynalink\/linker\/GuardingDynamicLinker;>;>;\n+\n+class name jdk\/dynalink\/linker\/GuardingTypeConverterFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/LinkRequest\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/linker\/LinkerServices\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/dynalink\/linker\/ConversionComparator$Comparison outerClass jdk\/dynalink\/linker\/ConversionComparator innerClassName Comparison flags 4019\n+\n+class name jdk\/dynalink\/linker\/MethodHandleTransformer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/MethodTypeConversionStrategy\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/TypeBasedGuardingDynamicLinker\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/GuardingDynamicLinker flags 601\n+\n+class name jdk\/dynalink\/linker\/support\/CompositeGuardingDynamicLinker\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/GuardingDynamicLinker flags 21\n+\n+class name jdk\/dynalink\/linker\/support\/DefaultInternalObjectFilter\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/MethodHandleTransformer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/Guards\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/Lookup\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/SimpleLinkRequest\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/LinkRequest flags 21\n+\n+class name jdk\/dynalink\/linker\/support\/TypeUtilities\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name jdk\/dynalink\/support\/AbstractRelinkableCallSite\n+header extends java\/lang\/invoke\/MutableCallSite implements jdk\/dynalink\/RelinkableCallSite flags 421\n+\n+class name jdk\/dynalink\/support\/ChainedCallSite\n+header extends jdk\/dynalink\/support\/AbstractRelinkableCallSite flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/support\/SimpleRelinkableCallSite\n+header extends jdk\/dynalink\/support\/AbstractRelinkableCallSite flags 21\n+\n","filename":"make\/data\/symbols\/jdk.dynalink-H.sym.txt","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/net\/httpserver\/Filter\n+method name beforeHandler descriptor (Ljava\/lang\/String;Ljava\/util\/function\/Consumer;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/Consumer<Lcom\/sun\/net\/httpserver\/HttpExchange;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+method name afterHandler descriptor (Ljava\/lang\/String;Ljava\/util\/function\/Consumer;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/Consumer<Lcom\/sun\/net\/httpserver\/HttpExchange;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+\n+class name com\/sun\/net\/httpserver\/Headers\n+header extends java\/lang\/Object implements java\/util\/Map flags 21 signature Ljava\/lang\/Object;Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/util\/List<Ljava\/lang\/String;>;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name com\/sun\/net\/httpserver\/HttpContext\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/net\/httpserver\/HttpPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/net\/httpserver\/HttpServer\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsConfigurator\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/net\/httpserver\/HttpsExchange\n+header extends com\/sun\/net\/httpserver\/HttpExchange flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsParameters\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsServer\n+header extends com\/sun\/net\/httpserver\/HttpServer flags 421\n+\n+class name com\/sun\/net\/httpserver\/spi\/HttpServerProvider\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.httpserver-H.sym.txt","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/foreign\/CLinker\n+header extends java\/lang\/Object nestMembers jdk\/incubator\/foreign\/CLinker$TypeKind,jdk\/incubator\/foreign\/CLinker$VaList,jdk\/incubator\/foreign\/CLinker$VaList$Builder sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$TypeKind outerClass jdk\/incubator\/foreign\/CLinker innerClassName TypeKind flags 4019\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+-method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker;\n+-method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toJavaStringRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String;\n+-method name toJavaStringRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljava\/nio\/charset\/Charset;)Ljava\/lang\/String;\n+-method name allocateMemoryRestricted descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress;\n+-method name freeMemoryRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V\n+method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name downcallHandle descriptor (Ljdk\/incubator\/foreign\/Addressable;Ljdk\/incubator\/foreign\/SegmentAllocator;Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name downcallHandle descriptor (Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemoryAddress; flags 401\n+method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljava\/nio\/charset\/Charset;)Ljava\/lang\/String; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name allocateMemory descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name freeMemory descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name systemLookup descriptor ()Ljdk\/incubator\/foreign\/SymbolLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name jdk\/incubator\/foreign\/CLinker$VaList\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable nestHost jdk\/incubator\/foreign\/CLinker sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+-method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name isAlive descriptor ()Z\n+-method name close descriptor ()V\n+-method name copy descriptor (Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name ofAddressRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 signature (Ljava\/util\/function\/Consumer<Ljdk\/incubator\/foreign\/CLinker$VaList$Builder;>;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+\n+class name jdk\/incubator\/foreign\/CLinker$VaList$Builder\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/CLinker sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+\n+class name jdk\/incubator\/foreign\/GroupLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name jdk\/incubator\/foreign\/LibraryLookup\n+\n+-class name jdk\/incubator\/foreign\/LibraryLookup$Symbol\n+\n+-class name jdk\/incubator\/foreign\/MappedMemorySegments\n+\n+class name jdk\/incubator\/foreign\/MemoryAddress\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+-method name asSegmentRestricted descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name asSegmentRestricted descriptor (JLjava\/lang\/Runnable;Ljava\/lang\/Object;)Ljdk\/incubator\/foreign\/MemorySegment;\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name asSegment descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name asSegment descriptor (JLjava\/lang\/Runnable;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isNative descriptor ()Z flags 401\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable nestMembers jdk\/incubator\/foreign\/MemoryLayout$PathElement sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name ofPaddingBits descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout;\n+-method name ofValueBits descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout;\n+-method name ofSequence descriptor (JLjdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name ofSequence descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name ofStruct descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout;\n+-method name ofUnion descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout;\n+method name sliceHandle descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout$PathElement;)Ljava\/lang\/invoke\/MethodHandle; flags 81\n+method name paddingLayout descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 9\n+method name valueLayout descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 9\n+method name sequenceLayout descriptor (JLjdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout; flags 9\n+method name sequenceLayout descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout; flags 9\n+method name structLayout descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout; flags 89\n+method name unionLayout descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout; flags 89\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout$PathElement\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/MemoryLayout sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/foreign\/MemorySegment\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+innerclass innerClass java\/nio\/channels\/FileChannel$MapMode outerClass java\/nio\/channels\/FileChannel innerClassName MapMode flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name READ descriptor I\n+-field name WRITE descriptor I\n+-field name CLOSE descriptor I\n+-field name HANDOFF descriptor I\n+-field name ALL_ACCESS descriptor I\n+-field name SHARE descriptor I\n+-method name ownerThread descriptor ()Ljava\/lang\/Thread;\n+-method name isAlive descriptor ()Z\n+-method name close descriptor ()V\n+-method name allocateNative descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (JJ)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name withAccessModes descriptor (I)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name hasAccessModes descriptor (I)Z\n+-method name accessModes descriptor ()I\n+-method name spliterator descriptor (Ljdk\/incubator\/foreign\/SequenceLayout;)Ljava\/util\/Spliterator;\n+-method name handoff descriptor (Ljava\/lang\/Thread;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name handoff descriptor (Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name share descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name registerCleaner descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name mapFile descriptor (Ljava\/nio\/file\/Path;JJLjava\/nio\/channels\/FileChannel$MapMode;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name ofNativeRestricted descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+method name asReadOnly descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name isReadOnly descriptor ()Z flags 401\n+method name spliterator descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Spliterator; flags 401 signature (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Spliterator<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name elements descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/stream\/Stream; flags 401 signature (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/stream\/Stream<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name isNative descriptor ()Z flags 401\n+method name isLoaded descriptor ()Z flags 401\n+method name load descriptor ()V flags 401\n+method name unload descriptor ()V flags 401\n+method name force descriptor ()V flags 401\n+method name allocateNative descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JJLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name mapFile descriptor (Ljava\/nio\/file\/Path;JJLjava\/nio\/channels\/FileChannel$MapMode;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; thrownTypes java\/io\/IOException flags 9\n+method name globalNativeSegment descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+-class name jdk\/incubator\/foreign\/NativeScope\n+\n+class name jdk\/incubator\/foreign\/ResourceScope\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable nestMembers jdk\/incubator\/foreign\/ResourceScope$Handle sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ResourceScope$Handle outerClass jdk\/incubator\/foreign\/ResourceScope innerClassName Handle flags 609\n+method name isAlive descriptor ()Z flags 401\n+method name ownerThread descriptor ()Ljava\/lang\/Thread; flags 401\n+method name isImplicit descriptor ()Z flags 401\n+method name close descriptor ()V flags 401\n+method name addCloseAction descriptor (Ljava\/lang\/Runnable;)V flags 401\n+method name acquire descriptor ()Ljdk\/incubator\/foreign\/ResourceScope$Handle; flags 401\n+method name release descriptor (Ljdk\/incubator\/foreign\/ResourceScope$Handle;)V flags 401\n+method name newConfinedScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newConfinedScope descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newSharedScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newSharedScope descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newImplicitScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name globalScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+\n+class name jdk\/incubator\/foreign\/ResourceScope$Handle\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/ResourceScope sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ResourceScope$Handle outerClass jdk\/incubator\/foreign\/ResourceScope innerClassName Handle flags 609\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+\n+class name jdk\/incubator\/foreign\/SegmentAllocator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (JJ)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name arenaAllocator descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name arenaAllocator descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name ofSegment descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name ofScope descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+\n+class name jdk\/incubator\/foreign\/SequenceLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/foreign\/SymbolLookup\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional; flags 401 signature (Ljava\/lang\/String;)Ljava\/util\/Optional<Ljdk\/incubator\/foreign\/MemoryAddress;>;\n+method name loaderLookup descriptor ()Ljdk\/incubator\/foreign\/SymbolLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n","filename":"make\/data\/symbols\/jdk.incubator.foreign-H.sym.txt","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/vector\/ByteVector\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI[II)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI[II)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI[IILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([ZILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI[II)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI[IILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([ZI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+\n+class name jdk\/incubator\/vector\/ShortVector\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI[II)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI[II)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI[IILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([CILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI[II)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI[IILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([CI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+\n+class name jdk\/incubator\/vector\/VectorOperators\n+field name UNSIGNED_LT descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_LE descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_GT descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_GE descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+\n","filename":"make\/data\/symbols\/jdk.incubator.vector-H.sym.txt","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/security\/jarsigner\/JarSignerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/jdk.jartool-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/javadoc\/doclet\/Reporter\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+method name print descriptor (Ljavax\/tools\/Diagnostic$Kind;Ljavax\/tools\/FileObject;IIILjava\/lang\/String;)V flags 401\n+method name getStandardWriter descriptor ()Ljava\/io\/PrintWriter; flags 1\n+method name getDiagnosticWriter descriptor ()Ljava\/io\/PrintWriter; flags 1\n+\n+class name jdk\/javadoc\/doclet\/StandardDoclet\n+header extends java\/lang\/Object implements jdk\/javadoc\/doclet\/Doclet flags 21\n+innerclass innerClass jdk\/javadoc\/doclet\/Doclet$Option outerClass jdk\/javadoc\/doclet\/Doclet innerClassName Option flags 609\n+method name getLocale descriptor ()Ljava\/util\/Locale; flags 1\n+method name getReporter descriptor ()Ljdk\/javadoc\/doclet\/Reporter; flags 1\n+\n","filename":"make\/data\/symbols\/jdk.javadoc-H.sym.txt","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/tools\/jconsole\/JConsolePlugin\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.jconsole-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,395 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/jdi\/AbsentInformationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/Accessible\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ArrayReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ArrayType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/BooleanType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/BooleanValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue flags 601\n+\n+class name com\/sun\/jdi\/Bootstrap\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/jdi\/ByteType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ByteValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ByteValue;>;\n+\n+class name com\/sun\/jdi\/CharType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/CharValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/CharValue;>;\n+\n+class name com\/sun\/jdi\/ClassLoaderReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassNotLoadedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/ClassNotPreparedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ClassObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/DoubleType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/DoubleValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/DoubleValue;>;\n+\n+class name com\/sun\/jdi\/Field\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Field;>;\n+\n+class name com\/sun\/jdi\/FloatType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/FloatValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/FloatValue;>;\n+\n+class name com\/sun\/jdi\/IncompatibleThreadStateException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InconsistentDebugInfoException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/IntegerType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/IntegerValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/IntegerValue;>;\n+\n+class name com\/sun\/jdi\/InterfaceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/InternalException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidCodeIndexException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidLineNumberException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidStackFrameException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidTypeException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InvocationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/JDIPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/jdi\/LocalVariable\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LocalVariable;>;\n+\n+class name com\/sun\/jdi\/Locatable\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/Location\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Location;>;\n+\n+class name com\/sun\/jdi\/LongType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/LongValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LongValue;>;\n+\n+class name com\/sun\/jdi\/Method\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,com\/sun\/jdi\/Locatable,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Lcom\/sun\/jdi\/Locatable;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Method;>;\n+\n+class name com\/sun\/jdi\/Mirror\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ModuleReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/MonitorInfo\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/NativeMethodException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectCollectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/PathSearchingVirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/VirtualMachine flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/ReferenceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type,java\/lang\/Comparable,com\/sun\/jdi\/Accessible flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Type;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ReferenceType;>;Lcom\/sun\/jdi\/Accessible;\n+\n+class name com\/sun\/jdi\/ShortType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ShortValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ShortValue;>;\n+\n+class name com\/sun\/jdi\/StackFrame\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/StringReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadGroupReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/Type\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/TypeComponent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Accessible flags 601\n+\n+class name com\/sun\/jdi\/VMCannotBeModifiedException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+\n+class name com\/sun\/jdi\/VMDisconnectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMMismatchException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMOutOfMemoryException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/Value\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachineManager\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/VoidType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/VoidValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/connect\/AttachingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/IllegalConnectorArgumentsException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/LaunchingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/ListeningConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/Transport\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/connect\/TransportTimeoutException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/VMStartException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/ClosedConnectionException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/Connection\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/jdi\/event\/AccessWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/BreakpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassPrepareEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassUnloadEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/Event\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventIterator\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/EventQueue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventSet\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/util\/Set flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/util\/Set<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/ExceptionEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/LocatableEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodEntryEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodExitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ModificationWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnterEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnteredEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitedEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/StepEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDisconnectEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/WatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/request\/AccessWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/BreakpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassPrepareRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassUnloadRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/DuplicateRequestException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/EventRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/EventRequestManager\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/ExceptionRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/InvalidRequestStateException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/MethodEntryRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MethodExitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ModificationWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnterRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnteredRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitedRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/StepRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadStartRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/VMDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/WatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n","filename":"make\/data\/symbols\/jdk.jdi-H.sym.txt","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jfr\/consumer\/RecordingStream\n+method name dump descriptor (Ljava\/nio\/file\/Path;)V thrownTypes java\/io\/IOException flags 1\n+\n","filename":"make\/data\/symbols\/jdk.jfr-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jshell\/DeclarationSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/Diag\n+header extends java\/lang\/Object flags 421\n+\n+class name jdk\/jshell\/EvalException\n+header extends jdk\/jshell\/JShellException flags 21\n+\n+class name jdk\/jshell\/ExpressionSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/ImportSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/JShellException\n+header extends java\/lang\/Exception flags 21\n+\n+class name jdk\/jshell\/MethodSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/PersistentSnippet\n+header extends jdk\/jshell\/Snippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/Snippet$SubKind\n+-field name RECORD_SUBKIND descriptor Ljdk\/jshell\/Snippet$SubKind;\n+field name RECORD_SUBKIND descriptor Ljdk\/jshell\/Snippet$SubKind; flags 4019\n+\n+class name jdk\/jshell\/SnippetEvent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$Status outerClass jdk\/jshell\/Snippet innerClassName Status flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/StatementSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/TypeDeclSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/execution\/FailOverExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiDefaultExecutionControl\n+header extends jdk\/jshell\/execution\/JdiExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/execution\/LoaderDelegate\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/spi\/ExecutionControlProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/ExecutionEnv\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/SPIResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/jshell\/tool\/JavaShellToolBuilder\n+header extends java\/lang\/Object flags 601\n+method name interactiveTerminal descriptor (Z)Ljdk\/jshell\/tool\/JavaShellToolBuilder; flags 1\n+\n","filename":"make\/data\/symbols\/jdk.jshell-H.sym.txt","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name netscape\/javascript\/JSException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/jdk.jsobject-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/management\/GarbageCollectionNotificationInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/GarbageCollectorMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/GarbageCollectorMXBean flags 601\n+\n+class name com\/sun\/management\/GcInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/HotSpotDiagnosticMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+\n+class name com\/sun\/management\/OperatingSystemMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/OperatingSystemMXBean flags 601\n+\n+class name com\/sun\/management\/ThreadMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/ThreadMXBean flags 601\n+\n+class name com\/sun\/management\/UnixOperatingSystemMXBean\n+header extends java\/lang\/Object implements com\/sun\/management\/OperatingSystemMXBean flags 601\n+\n","filename":"make\/data\/symbols\/jdk.management-H.sym.txt","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/management\/jfr\/RemoteRecordingStream\n+method name dump descriptor (Ljava\/nio\/file\/Path;)V thrownTypes java\/io\/IOException flags 1\n+\n","filename":"make\/data\/symbols\/jdk.management.jfr-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/net\/NetworkPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n","filename":"make\/data\/symbols\/jdk.net-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/sctp\/AbstractNotificationHandler\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/NotificationHandler flags 21 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/nio\/sctp\/NotificationHandler<TT;>;\n+\n+class name com\/sun\/nio\/sctp\/Association\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/nio\/sctp\/HandlerResult\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/sctp\/HandlerResult;>;\n+\n+class name com\/sun\/nio\/sctp\/IllegalReceiveException\n+header extends java\/lang\/IllegalStateException flags 21\n+\n+class name com\/sun\/nio\/sctp\/IllegalUnbindException\n+header extends java\/lang\/IllegalStateException flags 21\n+\n+class name com\/sun\/nio\/sctp\/InvalidStreamException\n+header extends java\/lang\/IllegalArgumentException flags 21\n+\n+class name com\/sun\/nio\/sctp\/MessageInfo\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/nio\/sctp\/Notification\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/nio\/sctp\/NotificationHandler\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/nio\/sctp\/SctpChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpMultiChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpServerChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpSocketOption\n+header extends java\/lang\/Object implements java\/net\/SocketOption flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/net\/SocketOption<TT;>;\n+\n+class name com\/sun\/nio\/sctp\/SendFailedNotification\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/Notification flags 421\n+\n+class name com\/sun\/nio\/sctp\/ShutdownNotification\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/Notification flags 421\n+\n","filename":"make\/data\/symbols\/jdk.sctp-H.sym.txt","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/auth\/LdapPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+\n+class name com\/sun\/security\/auth\/NTDomainPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/NTNumericCredential\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/auth\/NTSid\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidDomainPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidGroupPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidPrimaryGroupPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidUserPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTUserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/PrincipalComparator\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/security\/auth\/UnixNumericGroupPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UnixNumericUserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UnixPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+\n+class name com\/sun\/security\/auth\/callback\/TextCallbackHandler\n+header extends java\/lang\/Object implements javax\/security\/auth\/callback\/CallbackHandler flags 21\n+\n+class name com\/sun\/security\/auth\/login\/ConfigFile\n+header extends javax\/security\/auth\/login\/Configuration flags 21\n+\n+class name com\/sun\/security\/auth\/module\/JndiLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/KeyStoreLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/Krb5LoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/LdapLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/NTLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/NTSystem\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/auth\/module\/UnixLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/UnixSystem\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.security.auth-H.sym.txt","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/jgss\/AuthorizationDataEntry\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSContext\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSContext flags 601\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSCredential\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSCredential flags 601\n+\n+class name com\/sun\/security\/jgss\/GSSUtil\n+header extends java\/lang\/Object flags 21\n+-method name <init> descriptor ()V\n+\n+class name com\/sun\/security\/jgss\/InquireSecContextPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n+class name com\/sun\/security\/jgss\/InquireType\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/security\/jgss\/InquireType;>;\n+\n","filename":"make\/data\/symbols\/jdk.security.jgss-H.sym.txt","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/file\/ExtendedCopyOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/CopyOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedCopyOption;>;Ljava\/nio\/file\/CopyOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedOpenOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/OpenOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedOpenOption;>;Ljava\/nio\/file\/OpenOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name com\/sun\/nio\/file\/SensitivityWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/SensitivityWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name sun\/misc\/SignalHandler\n+header extends java\/lang\/Object flags 601 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name sun\/misc\/Unsafe\n+-method name defineAnonymousClass descriptor (Ljava\/lang\/Class;[B[Ljava\/lang\/Object;)Ljava\/lang\/Class;\n+\n+class name sun\/reflect\/ReflectionFactory\n+header extends java\/lang\/Object flags 21 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n","filename":"make\/data\/symbols\/jdk.unsupported-H.sym.txt","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name org\/w3c\/dom\/css\/CSS2Properties\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSCharsetRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSFontFaceRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSImportRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSMediaRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSPageRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSPrimitiveValue\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSValue flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSRule\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSRuleList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleDeclaration\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleSheet\n+header extends java\/lang\/Object implements org\/w3c\/dom\/stylesheets\/StyleSheet flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSUnknownRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSValue\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSValueList\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSValue flags 601\n+\n+class name org\/w3c\/dom\/css\/Counter\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/DOMImplementationCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/DOMImplementation flags 601\n+\n+class name org\/w3c\/dom\/css\/DocumentCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/stylesheets\/DocumentStyle flags 601\n+\n+class name org\/w3c\/dom\/css\/ElementCSSInlineStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/RGBColor\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/Rect\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/ViewCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/views\/AbstractView flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAnchorElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAppletElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAreaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBRElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBaseElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBaseFontElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBodyElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLButtonElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLCollection\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDOMImplementation\n+header extends java\/lang\/Object implements org\/w3c\/dom\/DOMImplementation flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDirectoryElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDivElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDocument\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Document flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Element flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFieldSetElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFontElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFormElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFrameElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFrameSetElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHRElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHeadElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHeadingElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHtmlElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLIFrameElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLImageElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLInputElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLIsIndexElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLIElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLabelElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLegendElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLinkElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMapElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMenuElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMetaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLModElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLObjectElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOptGroupElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOptionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLParagraphElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLParamElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLPreElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLQuoteElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLScriptElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLSelectElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLStyleElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableCaptionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableCellElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableColElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableRowElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableSectionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTextAreaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTitleElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLUListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/DocumentStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/LinkStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/MediaList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/StyleSheet\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/StyleSheetList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathEvaluator\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name org\/w3c\/dom\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathNSResolver\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathNamespace\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Node flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathResult\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/jdk.xml.dom-H.sym.txt","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-generate platforms 7:8:9:A:B:C:D:E:F:G\n+generate platforms 7:8:9:A:B:C:D:E:F:G:H\n@@ -43,0 +43,1 @@\n+platform version H base G files java.base-H.sym.txt:java.compiler-H.sym.txt:java.datatransfer-H.sym.txt:java.desktop-H.sym.txt:java.instrument-H.sym.txt:java.logging-H.sym.txt:java.management-H.sym.txt:java.management.rmi-H.sym.txt:java.naming-H.sym.txt:java.rmi-H.sym.txt:java.scripting-H.sym.txt:java.security.jgss-H.sym.txt:java.security.sasl-H.sym.txt:java.smartcardio-H.sym.txt:java.sql-H.sym.txt:java.sql.rowset-H.sym.txt:java.xml-H.sym.txt:java.xml.crypto-H.sym.txt:jdk.accessibility-H.sym.txt:jdk.attach-H.sym.txt:jdk.compiler-H.sym.txt:jdk.dynalink-H.sym.txt:jdk.httpserver-H.sym.txt:jdk.incubator.foreign-H.sym.txt:jdk.incubator.vector-H.sym.txt:jdk.jartool-H.sym.txt:jdk.javadoc-H.sym.txt:jdk.jconsole-H.sym.txt:jdk.jdi-H.sym.txt:jdk.jfr-H.sym.txt:jdk.jshell-H.sym.txt:jdk.jsobject-H.sym.txt:jdk.management-H.sym.txt:jdk.management.jfr-H.sym.txt:jdk.net-H.sym.txt:jdk.sctp-H.sym.txt:jdk.security.auth-H.sym.txt:jdk.security.jgss-H.sym.txt:jdk.unsupported-H.sym.txt:jdk.xml.dom-H.sym.txt\n","filename":"make\/data\/symbols\/symbols","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+      cdsProtectionDomain.cpp \\\n@@ -121,0 +122,3 @@\n+      dumpTimeSharedClassInfo.cpp \\\n+      lambdaProxyClassDictionary.cpp \\\n+      runTimeSharedClassInfo.cpp \\\n@@ -186,1 +190,0 @@\n-      biasedLocking.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+ * @author Guy Abossolo Foh\n@@ -285,1 +286,1 @@\n-        String dtd_home = System.getProperty(\"dtd_home\") + File.separator;\n+        String dtd_home = System.getProperty(\"dtd_home\");\n@@ -294,1 +295,1 @@\n-            mapping = new PublicMapping(dtd_home, \"public.map\");\n+            mapping = new PublicMapping(dtd_home + File.separator, \"public.map\");\n@@ -299,1 +300,1 @@\n-            System.err.println(\"Could not open DTD file \"+argv[0]);\n+            System.err.println(\"Could not open DTD file \" + argv[0]);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/dtdbuilder\/DTDBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,18 +63,0 @@\n-################################################################################\n-\n-ifeq ($(call isTargetOs, windows), true)\n-\n-  $(eval $(call SetupNativeCompilation, BUILD_LIBTIMEOUT_HANDLER, \\\n-        NAME := timeoutHandler, \\\n-        SRC := $(FH_BASEDIR)\/src\/windows\/native\/libtimeoutHandler, \\\n-        OBJECT_DIR := $(FH_SUPPORT)\/libtimeoutHandler, \\\n-        OUTPUT_DIR := $(FH_SUPPORT), \\\n-        CFLAGS := $(CFLAGS_JDKLIB), \\\n-        LDFLAGS := $(LDFLAGS_JDKLIB), \\\n-        OPTIMIZATION := LOW, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBTIMEOUT_HANDLER)\n-\n-endif\n-\n@@ -102,4 +84,0 @@\n-# Add the dir of the dll to the path on windows\n-ifeq ($(call isTargetOs, windows), true)\n-  export PATH := $(PATH);$(FH_SUPPORT)\n-endif\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2441,4 +2441,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2557,0 +2553,25 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ JDK-8183543: When taking the number of available registers as int\n+  \/\/ register pressure threshold, the jtreg test:\n+  \/\/ test\/hotspot\/jtreg\/compiler\/regalloc\/TestC2IntPressure.java\n+  \/\/ failed due to C2 compilation failure with\n+  \/\/ \"COMPILE SKIPPED: failed spill-split-recycle sanity check\".\n+  \/\/\n+  \/\/ A derived pointer is live at CallNode and then is flagged by RA\n+  \/\/ as a spilled LRG. Spilling heuristics(Spill-USE) explicitly skip\n+  \/\/ derived pointers and lastly fail to spill after reaching maximum\n+  \/\/ number of iterations. Lowering the default pressure threshold to\n+  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ a high register pressure area of the code so that split_DEF can\n+  \/\/ generate DefinitionSpillCopy for the derived pointer.\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  return (INTPRESSURE == -1) ? default_int_pressure_threshold : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ _FLOAT_REG_mask is generated by adlc from the float_reg register class.\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+}\n+\n@@ -3770,4 +3791,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);\n-    }\n-\n@@ -3844,4 +3861,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_exit(oop, tmp, cont);\n-    }\n-\n@@ -8869,5 +8882,0 @@\n-\n-\/\/ storeLConditional is used by PhaseMacroExpand::expand_lock_node\n-\/\/ when attempting to rebias a lock towards the current thread.  We\n-\/\/ must use the acquire form of cmpxchg in order to guarantee acquire\n-\/\/ semantics in this case.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3278,2 +3278,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+extern aarch64_atomic_stub_t aarch64_atomic_cmpxchg_4_release_impl;\n+extern aarch64_atomic_stub_t aarch64_atomic_cmpxchg_8_release_impl;\n+extern aarch64_atomic_stub_t aarch64_atomic_cmpxchg_4_seq_cst_impl;\n+extern aarch64_atomic_stub_t aarch64_atomic_cmpxchg_8_seq_cst_impl;\n","filename":"src\/hotspot\/cpu\/aarch64\/atomic_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -364,2 +364,4 @@\n-  __ lea(rscratch2, ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n-  __ incrementw(Address(rscratch2));\n+  if (PrintC1Statistics) {\n+    __ lea(rscratch2, ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+    __ incrementw(Address(rscratch2));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2580,4 +2580,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -2586,1 +2582,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -334,5 +334,0 @@\n-  \/\/ Need a scratch register for biased locking\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n@@ -347,1 +342,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -64,1 +63,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -85,5 +84,0 @@\n-  if (UseBiasedLocking) {\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &slow_case);\n-  }\n-\n@@ -125,4 +119,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    lea(rscratch2, ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-    addmw(Address(rscratch2, 0), 1, rscratch1);\n-  }\n@@ -139,6 +129,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -150,4 +134,2 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ load object\n+  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -182,7 +164,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t\n+  mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  \/\/ scratch : scratch register, contents destroyed\n@@ -63,1 +62,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                32);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  24);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_globals_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                                thread->get_thread_name(), frame.sp(), nm->verified_entry_point());\n+                                thread->name(), frame.sp(), nm->verified_entry_point());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -757,4 +756,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, done, &slow_case);\n-    }\n-\n@@ -772,11 +767,1 @@\n-    if (PrintBiasedLockingStatistics) {\n-      Label fast;\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, fast, &fail);\n-      bind(fast);\n-      atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),\n-                  rscratch2, rscratch1, tmp);\n-      b(done);\n-      bind(fail);\n-    } else {\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n-    }\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n@@ -819,6 +804,0 @@\n-\n-    if (PrintBiasedLockingStatistics) {\n-      br(Assembler::NE, slow_case);\n-      atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),\n-                  rscratch2, rscratch1, tmp);\n-    }\n@@ -875,4 +854,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(obj_reg, header_reg, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -445,172 +444,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg);\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL)\n-    counters = BiasedLocking::counters();\n-\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());\n-  Address saved_mark_addr(lock_reg, 0);\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::NE, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_prototype_header(tmp_reg, obj_reg);\n-  orr(tmp_reg, tmp_reg, rthread);\n-  eor(tmp_reg, swap_reg, tmp_reg);\n-  andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    Label around;\n-    cbnz(tmp_reg, around);\n-    atomic_incw(Address((address)counters->biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);\n-    b(done);\n-    bind(around);\n-  } else {\n-    cbz(tmp_reg, done);\n-  }\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cbnz(rscratch1, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);\n-  cbnz(rscratch1, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  {\n-    Label here;\n-    mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-    andr(swap_reg, swap_reg, rscratch1);\n-    orr(tmp_reg, swap_reg, rthread);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, this means that\n-    \/\/ another thread succeeded in biasing it toward itself and we\n-    \/\/ need to revoke that bias. The revocation will occur in the\n-    \/\/ interpreter runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->anonymously_biased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    orr(tmp_reg, rthread, tmp_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, then another thread\n-    \/\/ succeeded in biasing it toward itself and we need to revoke that\n-    \/\/ bias. The revocation will occur in the runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->rebiased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here, nope;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &nope);\n-    bind(here);\n-\n-    \/\/ Fall through to the normal CAS-based lock, because no matter what\n-    \/\/ the result of the above CAS, some thread must have succeeded in\n-    \/\/ removing the bias bit from the object's header.\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->revoked_lock_entry_count_addr()), tmp_reg,\n-                  rscratch1, rscratch2);\n-    }\n-    bind(nope);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(temp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::EQ, done);\n-}\n-\n@@ -3838,5 +3665,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src) {\n-  load_klass(dst, src);\n-  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":178,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -108,14 +108,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg is killed.\n-  \/\/ tmp_reg must be supplied and must not be rscratch1 or rscratch2\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n-\n@@ -850,2 +836,0 @@\n-  void load_prototype_header(Register dst, Register src);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1776,4 +1776,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1927,5 +1923,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5686,0 +5686,1 @@\n+   *  c_rarg6   - isMIME\n@@ -5768,6 +5769,7 @@\n-    Register src   = c_rarg0;  \/\/ source array\n-    Register soff  = c_rarg1;  \/\/ source start offset\n-    Register send  = c_rarg2;  \/\/ source end offset\n-    Register dst   = c_rarg3;  \/\/ dest array\n-    Register doff  = c_rarg4;  \/\/ position for writing to dest array\n-    Register isURL = c_rarg5;  \/\/ Base64 or URL character set\n+    Register src    = c_rarg0;  \/\/ source array\n+    Register soff   = c_rarg1;  \/\/ source start offset\n+    Register send   = c_rarg2;  \/\/ source end offset\n+    Register dst    = c_rarg3;  \/\/ dest array\n+    Register doff   = c_rarg4;  \/\/ position for writing to dest array\n+    Register isURL  = c_rarg5;  \/\/ Base64 or URL character set\n+    Register isMIME = c_rarg6;  \/\/ Decoding MIME block - unused in this implementation\n@@ -5957,0 +5959,4 @@\n+      case memory_order_release:\n+        acquire = false;\n+        release = true;\n+        break;\n@@ -6038,0 +6044,14 @@\n+    AtomicStubMark mark_cmpxchg_4_release\n+      (_masm, &aarch64_atomic_cmpxchg_4_release_impl);\n+    gen_cas_entry(MacroAssembler::word, memory_order_release);\n+    AtomicStubMark mark_cmpxchg_8_release\n+      (_masm, &aarch64_atomic_cmpxchg_8_release_impl);\n+    gen_cas_entry(MacroAssembler::xword, memory_order_release);\n+\n+    AtomicStubMark mark_cmpxchg_4_seq_cst\n+      (_masm, &aarch64_atomic_cmpxchg_4_seq_cst_impl);\n+    gen_cas_entry(MacroAssembler::word, memory_order_seq_cst);\n+    AtomicStubMark mark_cmpxchg_8_seq_cst\n+      (_masm, &aarch64_atomic_cmpxchg_8_seq_cst_impl);\n+    gen_cas_entry(MacroAssembler::xword, memory_order_seq_cst);\n+\n@@ -7204,0 +7224,4 @@\n+DEFAULT_ATOMIC_OP(cmpxchg, 4, _release)\n+DEFAULT_ATOMIC_OP(cmpxchg, 8, _release)\n+DEFAULT_ATOMIC_OP(cmpxchg, 4, _seq_cst)\n+DEFAULT_ATOMIC_OP(cmpxchg, 8, _seq_cst)\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3556,5 +3556,1 @@\n-    if (UseBiasedLocking) {\n-      __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n-    } else {\n-      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n-    }\n+    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1004,4 +1004,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1103,0 +1099,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 12 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 30 : FLOATPRESSURE;\n+}\n+\n@@ -5457,1 +5463,0 @@\n-    \/\/ used by biased locking only. Requires a membar.\n@@ -8957,1 +8962,0 @@\n-  predicate(!(UseBiasedLocking && !UseOptoBiasInlining));\n@@ -8969,16 +8973,0 @@\n-instruct cmpFastLock_noBiasInline(flagsRegP pcc, iRegP object, iRegP box, iRegP scratch2,\n-                                  iRegP scratch, iRegP scratch3) %{\n-  match(Set pcc (FastLock object box));\n-  predicate(UseBiasedLocking && !UseOptoBiasInlining);\n-\n-  effect(TEMP scratch, TEMP scratch2, TEMP scratch3);\n-  ins_cost(DEFAULT_COST*5);\n-\n-  format %{ \"FASTLOCK  $object, $box; KILL $scratch, $scratch2, $scratch3\" %}\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $scratch$$Register, $scratch2$$Register, $scratch3$$Register);\n-  %}\n-  ins_pipe(long_memory_op);\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-    __ unlock_object(R2, R1, R0, Rtemp, *stub->entry());\n+    __ unlock_object(R2, R1, R0, *stub->entry());\n@@ -2432,2 +2432,0 @@\n-  Register tmp = op->scratch_opr()->is_illegal() ? noreg :\n-                 op->scratch_opr()->as_pointer_register();\n@@ -2439,1 +2437,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, tmp, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n@@ -2444,1 +2442,1 @@\n-    __ unlock_object(hdr, obj, lock, tmp, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -415,8 +415,0 @@\n-  \/\/ Need a scratch register for biased locking on arm\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if(UseBiasedLocking) {\n-    scratch = new_pointer_register();\n-  } else {\n-    scratch = atomicLockOpr();\n-  }\n-\n@@ -429,1 +421,1 @@\n-  monitor_enter(obj.result(), lock, hdr, scratch,\n+  monitor_enter(obj.result(), lock, hdr, LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -93,5 +92,1 @@\n-  if(UseBiasedLocking && !len->is_valid()) {\n-    ldr(tmp, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    mov(tmp, (intptr_t)markWord::prototype().value());\n-  }\n+  mov(tmp, (intptr_t)markWord::prototype().value());\n@@ -190,3 +185,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj,\n-                                   Register disp_hdr, Register tmp1,\n-                                   Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -197,1 +190,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr, tmp1, tmp2);\n+  assert_different_registers(hdr, obj, disp_hdr, tmp2);\n@@ -214,4 +207,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(obj, hdr\/*scratched*\/, tmp1, false, tmp2, done, slow_case);\n-  }\n-\n@@ -252,7 +241,0 @@\n-\n-#ifndef PRODUCT\n-  if (PrintBiasedLockingStatistics) {\n-    cond_atomic_inc32(al, BiasedLocking::fast_path_entry_count_addr());\n-  }\n-#endif \/\/ !PRODUCT\n-\n@@ -264,5 +246,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj,\n-                                      Register disp_hdr, Register tmp,\n-                                      Label& slow_case) {\n-  \/\/ Note: this method is not using its 'tmp' argument\n-\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -277,5 +255,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n@@ -290,4 +263,2 @@\n-  if(!UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-  }\n+  \/\/ load object\n+  ldr(obj, Address(disp_hdr, obj_offset));\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  int lock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  int lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n@@ -64,1 +64,1 @@\n-  void unlock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  void unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-void C2_MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2, Register scratch3) {\n+void C2_MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2) {\n@@ -100,8 +100,0 @@\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    assert(scratch3 != noreg, \"need extra temporary for -XX:-UseOptoBiasInlining\");\n-    biased_locking_enter(Roop, Rmark, Rscratch, false, scratch3, done, done);\n-    \/\/ Fall through if lock not biased otherwise branch to done\n-  }\n-\n-  \/\/ Invariant: Rmark loaded below does not contain biased lock pattern\n-\n@@ -151,4 +143,0 @@\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_exit(Roop, Rscratch, done);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  void fast_lock(Register obj, Register box, Register scratch, Register scratch2, Register scratch3 = noreg);\n+  void fast_lock(Register obj, Register box, Register scratch, Register scratch2);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                30);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  12);\n","filename":"src\/hotspot\/cpu\/arm\/c2_globals_arm.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -893,5 +892,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(Robj, Rmark\/*scratched*\/, R0, false, Rtemp, done, slow_case);\n-    }\n-\n-\n@@ -915,6 +909,0 @@\n-#ifndef PRODUCT\n-    if (PrintBiasedLockingStatistics) {\n-      cond_atomic_inc32(al, BiasedLocking::fast_path_entry_count_addr());\n-    }\n-#endif \/\/!PRODUCT\n-\n@@ -965,7 +953,0 @@\n-\n-#ifndef PRODUCT\n-    if (PrintBiasedLockingStatistics) {\n-      cond_atomic_inc32(eq, BiasedLocking::fast_path_entry_count_addr());\n-    }\n-#endif \/\/ !PRODUCT\n-\n@@ -1013,4 +994,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(Robj, Rmark, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1291,215 +1290,0 @@\n-\n-\/\/ Building block for CAS cases of biased locking: makes CAS and records statistics.\n-\/\/ The slow_case label is used to transfer control if CAS fails. Otherwise leaves condition codes set.\n-void MacroAssembler::biased_locking_enter_with_cas(Register obj_reg, Register old_mark_reg, Register new_mark_reg,\n-                                                 Register tmp, Label& slow_case, int* counter_addr) {\n-\n-  cas_for_lock_acquire(old_mark_reg, new_mark_reg, obj_reg, tmp, slow_case);\n-#ifdef ASSERT\n-  breakpoint(ne); \/\/ Fallthrough only on success\n-#endif\n-#ifndef PRODUCT\n-  if (counter_addr != NULL) {\n-    cond_atomic_inc32(al, counter_addr);\n-  }\n-#endif \/\/ !PRODUCT\n-}\n-\n-void MacroAssembler::biased_locking_enter(Register obj_reg, Register swap_reg, Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Register tmp2,\n-                                          Label& done, Label& slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  \/\/ obj_reg must be preserved (at least) if the bias locking fails\n-  \/\/ tmp_reg is a temporary register\n-  \/\/ swap_reg was used as a temporary but contained a value\n-  \/\/   that was used afterwards in some call pathes. Callers\n-  \/\/   have been fixed so that swap_reg no longer needs to be\n-  \/\/   saved.\n-  \/\/ Rtemp in no longer scratched\n-\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(obj_reg, swap_reg, tmp_reg, tmp2);\n-  guarantee(swap_reg!=tmp_reg, \"invariant\");\n-  assert(tmp_reg != noreg, \"must supply tmp_reg\");\n-\n-#ifndef PRODUCT\n-  if (PrintBiasedLockingStatistics && (counters == NULL)) {\n-    counters = BiasedLocking::counters();\n-  }\n-#endif\n-\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-\n-  \/\/ On MP platform loads could return 'stale' values in some cases.\n-  \/\/ That is acceptable since either CAS or slow case path is taken in the worst case.\n-\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markWord::biased_lock_pattern);\n-\n-  b(cas_label, ne);\n-\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_klass(tmp_reg, obj_reg);\n-  ldr(tmp_reg, Address(tmp_reg, Klass::prototype_header_offset()));\n-  orr(tmp_reg, tmp_reg, Rthread);\n-  eor(tmp_reg, tmp_reg, swap_reg);\n-\n-  bics(tmp_reg, tmp_reg, ((int) markWord::age_mask_in_place));\n-\n-#ifndef PRODUCT\n-  if (counters != NULL) {\n-    cond_atomic_inc32(eq, counters->biased_lock_entry_count_addr());\n-  }\n-#endif \/\/ !PRODUCT\n-\n-  b(done, eq);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  tst(tmp_reg, markWord::biased_lock_mask_in_place);\n-  b(try_revoke_bias, ne);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  tst(tmp_reg, markWord::epoch_mask_in_place);\n-  b(try_rebias, ne);\n-\n-  \/\/ tmp_reg has the age, epoch and pattern bits cleared\n-  \/\/ The remaining (owner) bits are (Thread ^ current_owner)\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-\n-  \/\/ Note that we know the owner is not ourself. Hence, success can\n-  \/\/ only happen when the owner bits is 0\n-\n-  \/\/ until the assembler can be made smarter, we need to make some assumptions about the values\n-  \/\/ so we can optimize this:\n-  assert((markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place) == 0x1ff, \"biased bitmasks changed\");\n-\n-  mov(swap_reg, AsmOperand(swap_reg, lsl, 23));\n-  mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); \/\/ markWord with thread bits cleared (for CAS)\n-\n-  orr(tmp_reg, swap_reg, Rthread); \/\/ new mark\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,\n-        (counters != NULL) ? counters->anonymously_biased_lock_entry_count_addr() : NULL);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  b(done);\n-\n-  bind(try_rebias);\n-\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-\n-  \/\/ tmp_reg low (not owner) bits are (age: 0 | pattern&epoch: prototype^swap_reg)\n-\n-  eor(tmp_reg, tmp_reg, swap_reg); \/\/ OK except for owner bits (age preserved !)\n-\n-  \/\/ owner bits 'random'. Set them to Rthread.\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsl, 23));\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsr, 23));\n-\n-  orr(tmp_reg, tmp_reg, Rthread); \/\/ new mark\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,\n-        (counters != NULL) ? counters->rebiased_lock_entry_count_addr() : NULL);\n-\n-  \/\/ If the biasing toward our thread failed, then another thread\n-  \/\/ succeeded in biasing it toward itself and we need to revoke that\n-  \/\/ bias. The revocation will occur in the runtime in the slow case.\n-\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-\n-  \/\/ tmp_reg low (not owner) bits are (age: 0 | pattern&epoch: prototype^swap_reg)\n-\n-  eor(tmp_reg, tmp_reg, swap_reg); \/\/ OK except for owner bits (age preserved !)\n-\n-  \/\/ owner bits 'random'. Clear them\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsl, 23));\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsr, 23));\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, cas_label,\n-        (counters != NULL) ? counters->revoked_lock_entry_count_addr() : NULL);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-\n-  bind(cas_label);\n-}\n-\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register tmp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(tmp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-  andr(tmp_reg, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markWord::biased_lock_pattern);\n-  b(done, eq);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":0,"deletions":216,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-class BiasedLockingCounters;\n-\n@@ -362,23 +360,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg must be supplied.\n-  \/\/ tmp_reg must be supplied.\n-  \/\/ Done label is branched to with condition code EQ set if the lock is\n-  \/\/ biased and we acquired it. Slow case label is branched to with\n-  \/\/ condition code NE set if the lock is biased but we failed to acquire\n-  \/\/ it. Otherwise fall through.\n-  \/\/ Notes:\n-  \/\/ - swap_reg and tmp_reg are scratched\n-  \/\/ - Rtemp was (implicitly) scratched and can now be specified as the tmp2\n-  void biased_locking_enter(Register obj_reg, Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Register tmp2,\n-                            Label& done, Label& slow_case,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit(Register obj_reg, Register temp_reg, Label& done);\n-\n-  \/\/ Building block for CAS cases of biased locking: makes CAS and records statistics.\n-  \/\/ Optional slow_case label is used to transfer control if CAS fails. Otherwise leaves condition codes set.\n-  void biased_locking_enter_with_cas(Register obj_reg, Register old_mark_reg, Register new_mark_reg,\n-                                     Register tmp, Label& slow_case, int* counter_addr);\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -865,5 +865,0 @@\n-    if (UseBiasedLocking) {\n-      assert(is_power_of_2(markWord::biased_lock_bit_in_place), \"adjust this code\");\n-      __ tbnz(Rtemp, exact_log2(markWord::biased_lock_bit_in_place), slow_case);\n-    }\n-\n@@ -1154,1 +1149,1 @@\n-  Label slow_lock, slow_lock_biased, lock_done, fast_lock;\n+  Label slow_lock, lock_done, fast_lock;\n@@ -1161,4 +1156,0 @@\n-    if(UseBiasedLocking) {\n-      __ biased_locking_enter(sync_obj, tmp, disp_hdr\/*scratched*\/, false, Rtemp, lock_done, slow_lock_biased);\n-    }\n-\n@@ -1246,6 +1237,0 @@\n-    if(UseBiasedLocking) {\n-      __ biased_locking_exit(sync_obj, Rtemp, unlock_done);\n-      \/\/ disp_hdr may not have been saved on entry with biased locking\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-    }\n-\n@@ -1307,5 +1292,0 @@\n-    if(UseBiasedLocking) {\n-      __ bind(slow_lock_biased);\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3970,5 +3970,1 @@\n-    if (UseBiasedLocking) {\n-      __ ldr(Rtemp, Address(Rklass, Klass::prototype_header_offset()));\n-    } else {\n-      __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());\n-    }\n+    __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,2 +97,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,13 +351,0 @@\n-\n-bool VM_Version::use_biased_locking() {\n-  get_os_cpu_info();\n-  \/\/ The cost of CAS on uniprocessor ARM v6 and later is low compared to the\n-  \/\/ overhead related to slightly longer Biased Locking execution path.\n-  \/\/ Testing shows no improvement when running with Biased Locking enabled\n-  \/\/ on an ARMv6 and higher uniprocessor systems.  The situation is different on\n-  \/\/ ARMv5 and MP systems.\n-  \/\/\n-  \/\/ Therefore the Biased Locking is enabled on ARMv5 and ARM MP only.\n-  \/\/\n-  return (!os::is_MP() && (arm_arch() > 5)) ? false : true;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -494,6 +494,8 @@\n-  const address counter = (address)&Runtime1::_arraycopy_slowcase_cnt;\n-  const Register tmp = R3, tmp2 = R4;\n-  int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);\n-  __ lwz(tmp2, simm16_offs, tmp);\n-  __ addi(tmp2, tmp2, 1);\n-  __ stw(tmp2, simm16_offs, tmp);\n+  if (PrintC1Statistics) {\n+    const address counter = (address)&Runtime1::_arraycopy_slowcase_cnt;\n+    const Register tmp = R3, tmp2 = R4;\n+    int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);\n+    __ lwz(tmp2, simm16_offs, tmp);\n+    __ addi(tmp2, tmp2, 1);\n+    __ stw(tmp2, simm16_offs, tmp);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -118,4 +117,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(CCR0, Roop, Rmark, Rscratch, R0, done, &slow_int);\n-  }\n-\n@@ -167,6 +162,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Load the object out of the BasicObjectLock.\n-    ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n-    verify_oop(Roop, FILE_AND_LINE);\n-    biased_locking_exit(CCR0, Roop, R0, done);\n-  }\n@@ -177,5 +166,4 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ Load object.\n-    ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n-    verify_oop(Roop, FILE_AND_LINE);\n-  }\n+\n+  \/\/ Load object.\n+  ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n+  verify_oop(Roop, FILE_AND_LINE);\n@@ -225,5 +213,1 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    ld(t1, in_bytes(Klass::prototype_header_offset()), klass);\n-  } else {\n-    load_const_optimized(t1, (intx)markWord::prototype().value());\n-  }\n+  load_const_optimized(t1, (intx)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                28);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  26);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_globals_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -946,4 +946,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(CCR0, object, displaced_header, tmp, current_header, done, &slow_case);\n-    }\n-\n@@ -1051,7 +1047,0 @@\n-    if (UseBiasedLocking) {\n-      \/\/ The object address from the monitor is in object.\n-      ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-      biased_locking_exit(CCR0, object, displaced_header, free_slot);\n-    }\n-\n@@ -1073,1 +1062,1 @@\n-    if (!UseBiasedLocking) { ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor); }\n+    ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -2076,212 +2075,0 @@\n-\/\/ Supports temp2_reg = R0.\n-void MacroAssembler::biased_locking_enter(ConditionRegister cr_reg, Register obj_reg,\n-                                          Register mark_reg, Register temp_reg,\n-                                          Register temp2_reg, Label& done, Label* slow_case) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-#ifdef ASSERT\n-  assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);\n-#endif\n-\n-  Label cas_label;\n-\n-  \/\/ Branch to done if fast path fails and no slow_case provided.\n-  Label *slow_case_int = (slow_case != NULL) ? slow_case : &done;\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n-         \"biased locking makes assumptions about bit layout\");\n-\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::total_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-\n-  andi(temp_reg, mark_reg, markWord::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n-  bne(cr_reg, cas_label);\n-\n-  load_klass(temp_reg, obj_reg);\n-\n-  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  orr(temp_reg, R16_thread, temp_reg);\n-  xorr(temp_reg, mark_reg, temp_reg);\n-  andr(temp_reg, temp_reg, temp2_reg);\n-  cmpdi(cr_reg, temp_reg, 0);\n-  if (PrintBiasedLockingStatistics) {\n-    Label l;\n-    bne(cr_reg, l);\n-    load_const(temp2_reg, (address) BiasedLocking::biased_lock_entry_count_addr());\n-    lwzx(mark_reg, temp2_reg);\n-    addi(mark_reg, mark_reg, 1);\n-    stwx(mark_reg, temp2_reg);\n-    \/\/ restore mark_reg\n-    ld(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-    bind(l);\n-  }\n-  beq(cr_reg, done);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andi(temp2_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp2_reg, 0);\n-  bne(cr_reg, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-\n-  int shift_amount = 64 - markWord::epoch_shift;\n-  \/\/ rotate epoch bits to right (little) end and set other bits to 0\n-  \/\/ [ big part | epoch | little part ] -> [ 0..0 | epoch ]\n-  rldicl_(temp2_reg, temp_reg, shift_amount, 64 - markWord::epoch_bits);\n-  \/\/ branch if epoch bits are != 0, i.e. they differ, because the epoch has been incremented\n-  bne(CCR0, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  andi(mark_reg, mark_reg, (markWord::biased_lock_mask_in_place |\n-                                markWord::age_mask_in_place |\n-                                markWord::epoch_mask_in_place));\n-  orr(temp_reg, R16_thread, mark_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ CmpxchgX sets cr_reg to cmpX(temp2_reg, mark_reg).\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-           \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-           \/*where=*\/obj_reg,\n-           MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-           noreg, slow_case_int); \/\/ bail out if failed\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::anonymously_biased_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  load_klass(temp_reg, obj_reg);\n-  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n-  orr(temp2_reg, R16_thread, temp2_reg);\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  orr(temp_reg, temp2_reg, temp_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-                 \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-                 \/*where=*\/obj_reg,\n-                 MacroAssembler::MemBarAcq,\n-                 MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-                 noreg, slow_case_int); \/\/ bail out if failed\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  load_klass(temp_reg, obj_reg);\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n-  orr(temp_reg, temp_reg, temp2_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ CmpxchgX sets cr_reg to cmpX(temp2_reg, mark_reg).\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-                 \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-                 \/*where=*\/obj_reg,\n-                 MacroAssembler::MemBarAcq,\n-                 MacroAssembler::cmpxchgx_hint_acquire_lock());\n-\n-  \/\/ reload markWord in mark_reg before continuing with lightweight locking\n-  ld(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (PrintBiasedLockingStatistics) {\n-    Label l;\n-    bne(cr_reg, l);\n-    load_const(temp2_reg, (address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-    bind(l);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit (ConditionRegister cr_reg, Register mark_addr, Register temp_reg, Label& done) {\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-\n-  ld(temp_reg, 0, mark_addr);\n-  andi(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-\n-  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n-  beq(cr_reg, done);\n-}\n-\n@@ -2698,1 +2485,0 @@\n-  assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -2705,1 +2491,1 @@\n-  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n@@ -2723,4 +2509,4 @@\n-  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);      \/\/ Reload in transaction, conflicts need to be tracked.\n-  andi(R0, mark_word, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpwi(flag, R0, markWord::unlocked_value);                \/\/ bits = 001 unlocked\n-  beq(flag, DONE_LABEL);                                    \/\/ all done if unlocked\n+  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);   \/\/ Reload in transaction, conflicts need to be tracked.\n+  andi(R0, mark_word, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+  cmpwi(flag, R0, markWord::unlocked_value);             \/\/ bits = 01 unlocked\n+  beq(flag, DONE_LABEL);                                 \/\/ all done if unlocked\n@@ -2840,1 +2626,0 @@\n-                                               bool try_bias,\n@@ -2861,4 +2646,0 @@\n-  if (try_bias) {\n-    biased_locking_enter(flag, oop, displaced_header, temp, current_header, cont);\n-  }\n-\n@@ -2967,1 +2748,1 @@\n-                                                 bool try_bias, bool use_rtm) {\n+                                                 bool use_rtm) {\n@@ -2973,4 +2754,0 @@\n-  if (try_bias) {\n-    biased_locking_exit(flag, oop, current_header, cont);\n-  }\n-\n@@ -2979,1 +2756,0 @@\n-    assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -2981,6 +2757,6 @@\n-    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);      \/\/ fetch markword\n-    andi(R0, current_header, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-    cmpwi(flag, R0, markWord::unlocked_value);                     \/\/ bits = 001 unlocked\n-    bne(flag, L_regular_unlock);                                   \/\/ else RegularLock\n-    tend_();                                                       \/\/ otherwise end...\n-    b(cont);                                                       \/\/ ... and we're done\n+    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);   \/\/ fetch markword\n+    andi(R0, current_header, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+    cmpwi(flag, R0, markWord::unlocked_value);                  \/\/ bits = 01 unlocked\n+    bne(flag, L_regular_unlock);                                \/\/ else RegularLock\n+    tend_();                                                    \/\/ otherwise end...\n+    b(cont);                                                    \/\/ ... and we're done\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":12,"deletions":236,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -592,18 +592,0 @@\n-  \/\/ Biased locking support\n-  \/\/ Upon entry,obj_reg must contain the target object, and mark_reg\n-  \/\/ must contain the target object's header.\n-  \/\/ Destroys mark_reg if an attempt is made to bias an anonymously\n-  \/\/ biased lock. In this case a failure will go either to the slow\n-  \/\/ case or fall through with the notEqual condition code set with\n-  \/\/ the expectation that the slow case in the runtime will be called.\n-  \/\/ In the fall-through case where the CAS-based lock is done,\n-  \/\/ mark_reg is not destroyed.\n-  void biased_locking_enter(ConditionRegister cr_reg, Register obj_reg, Register mark_reg, Register temp_reg,\n-                            Register temp2_reg, Label& done, Label* slow_case = NULL);\n-  \/\/ Upon entry, the base register of mark_addr must contain the oop.\n-  \/\/ Destroys temp_reg.\n-  \/\/ If allow_delay_slot_filling is set to true, the next instruction\n-  \/\/ emitted after this one will go in an annulled delay slot if the\n-  \/\/ biased locking exit case failed.\n-  void biased_locking_exit(ConditionRegister cr_reg, Register mark_addr, Register temp_reg, Label& done);\n-\n@@ -658,1 +640,0 @@\n-                                 bool try_bias = UseBiasedLocking,\n@@ -666,1 +647,1 @@\n-                                   bool try_bias = UseBiasedLocking, bool use_rtm = false);\n+                                   bool use_rtm = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2196,4 +2196,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2366,0 +2362,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 26 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 28 : FLOATPRESSURE;\n+}\n+\n@@ -12120,2 +12126,1 @@\n-                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0,\n-                                 UseBiasedLocking && !UseOptoBiasInlining);\n+                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0);\n@@ -12139,1 +12144,0 @@\n-                                 \/*Biased Locking*\/ false,\n@@ -12142,1 +12146,1 @@\n-                                 \/*TM*\/ true, ra_->C->profile_rtm());\n+                                 \/*RTM*\/ true, ra_->C->profile_rtm());\n@@ -12159,1 +12163,0 @@\n-                                   UseBiasedLocking && !UseOptoBiasInlining,\n@@ -12177,1 +12180,1 @@\n-                                   \/*Biased Locking*\/ false, \/*TM*\/ true);\n+                                   \/*RTM*\/ true);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2157,8 +2157,0 @@\n-#   ifdef ASSERT\n-    if (UseBiasedLocking) {\n-      \/\/ Making the box point to itself will make it clear it went unused\n-      \/\/ but also be obviously invalid.\n-      __ std(r_box, 0, r_box);\n-    }\n-#   endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3760,0 +3760,1 @@\n+    Register isMIME = R9_ARG7; \/\/ boolean, if non-zero indicates use of RFC 2045 MIME encoding - not used\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3796,5 +3796,1 @@\n-    if (UseBiasedLocking) {\n-      __ ld(Rscratch, in_bytes(Klass::prototype_header_offset()), RinstanceKlass);\n-    } else {\n-      __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n-    }\n+    __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,5 +381,1 @@\n-    \/\/ If CPU or OS do not support TM:\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n-    \/\/ VM_Version_init() is executed after UseBiasedLocking is used\n-    \/\/ in Thread::allocate().\n+    \/\/ If CPU or OS do not support RTM:\n@@ -402,2 +398,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n@@ -547,21 +541,0 @@\n-bool VM_Version::use_biased_locking() {\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM locking is most useful when there is high lock contention and\n-  \/\/ low data contention. With high lock contention the lock is usually\n-  \/\/ inflated and biased locking is not suitable for that case.\n-  \/\/ RTM locking code requires that biased locking is off.\n-  \/\/ Note: we can't switch off UseBiasedLocking in get_processor_features()\n-  \/\/ because it is used by Thread::allocate() which is called before\n-  \/\/ VM_Version::initialize().\n-  if (UseRTMLocking && UseBiasedLocking) {\n-    if (FLAG_IS_DEFAULT(UseBiasedLocking)) {\n-      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n-    } else {\n-      warning(\"Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.\" );\n-      UseBiasedLocking = false;\n-    }\n-  }\n-#endif\n-  return UseBiasedLocking;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -96,3 +96,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -457,2 +457,4 @@\n-  __ load_const_optimized(Z_R1_scratch, (address)&Runtime1::_arraycopy_slowcase_cnt);\n-  __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+  if (PrintC1Statistics) {\n+    __ load_const_optimized(Z_R1_scratch, (address)&Runtime1::_arraycopy_slowcase_cnt);\n+    __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -100,4 +99,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(obj, hdr, Z_R1_scratch, Z_R0_scratch, done, &slow_case);\n-  }\n-\n@@ -113,7 +108,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Unimplemented();\n-#if 0\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-#endif\n-  }\n@@ -153,6 +141,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Load object.\n-    z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -163,4 +145,2 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ Load object.\n-    z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ Load object.\n+  z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -196,7 +176,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1);\n-    z_lg(t1, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t.\n-    load_const_optimized(t1, (intx)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t.\n+  load_const_optimized(t1, (intx)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                15);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  10); \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1008,4 +1007,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(object, displaced_header, Z_R1, Z_R0, done, &slow_case);\n-  }\n-\n@@ -1119,6 +1114,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ The object address from the monitor is in object.\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    biased_locking_exit(object, displaced_header, done);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -3131,188 +3130,1 @@\n-\/\/ Semantics are dependent on the slow_case label:\n-\/\/   If the slow_case label is not NULL, failure to biased-lock the object\n-\/\/   transfers control to the location of the slow_case label. If the\n-\/\/   object could be biased-locked, control is transferred to the done label.\n-\/\/   The condition code is unpredictable.\n-\/\/\n-\/\/   If the slow_case label is NULL, failure to biased-lock the object results\n-\/\/   in a transfer of control to the done label with a condition code of not_equal.\n-\/\/   If the biased-lock could be successfully obtained, control is transfered to\n-\/\/   the done label with a condition code of equal.\n-\/\/   It is mandatory to react on the condition code At the done label.\n-\/\/\n-void MacroAssembler::biased_locking_enter(Register  obj_reg,\n-                                          Register  mark_reg,\n-                                          Register  temp_reg,\n-                                          Register  temp2_reg,    \/\/ May be Z_RO!\n-                                          Label    &done,\n-                                          Label    *slow_case) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);\n-\n-  Label cas_label; \/\/ Try, if implemented, CAS locking. Fall thru to slow path otherwise.\n-\n-  BLOCK_COMMENT(\"biased_locking_enter {\");\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid.\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits.\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n-         \"biased locking makes assumptions about bit layout\");\n-  z_lr(temp_reg, mark_reg);\n-  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n-  z_chi(temp_reg, markWord::biased_lock_pattern);\n-  z_brne(cas_label);  \/\/ Try cas if object is not biased, i.e. cannot be biased locked.\n-\n-  load_prototype_header(temp_reg, obj_reg);\n-  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n-\n-  z_ogr(temp_reg, Z_thread);\n-  z_xgr(temp_reg, mark_reg);\n-  z_ngr(temp_reg, temp2_reg);\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::biased_lock_entry_count_addr(), mark_reg, temp2_reg);\n-    \/\/ Restore mark_reg.\n-    z_lg(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-  }\n-  branch_optimized(Assembler::bcondEqual, done);  \/\/ Biased lock obtained, return success.\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-  Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());\n-\n-  \/\/----------------------------------------------------------------------------\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  z_tmll(temp_reg, markWord::biased_lock_mask_in_place);\n-  z_brnaz(try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  z_tmll(temp_reg, markWord::epoch_mask_in_place);\n-  z_brnaz(try_rebias);\n-\n-  \/\/----------------------------------------------------------------------------\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |\n-         markWord::epoch_mask_in_place);\n-  z_lgr(temp_reg, Z_thread);\n-  z_llgfr(mark_reg, mark_reg);\n-  z_ogr(temp_reg, mark_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::anonymously_biased_lock_entry_count_addr(),\n-                         temp_reg, temp2_reg);\n-  }\n-  if (slow_case != NULL) {\n-    branch_optimized(Assembler::bcondNotEqual, *slow_case); \/\/ Biased lock not obtained, need to go the long way.\n-  }\n-  branch_optimized(Assembler::bcondAlways, done);           \/\/ Biased lock status given in condition code.\n-\n-  \/\/----------------------------------------------------------------------------\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-\n-  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-  load_prototype_header(temp_reg, obj_reg);\n-  z_llgfr(mark_reg, mark_reg);\n-\n-  z_ogr(temp_reg, Z_thread);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg, temp2_reg);\n-  }\n-  if (slow_case != NULL) {\n-    branch_optimized(Assembler::bcondNotEqual, *slow_case);  \/\/ Biased lock not obtained, need to go the long way.\n-  }\n-  z_bru(done);           \/\/ Biased lock status given in condition code.\n-\n-  \/\/----------------------------------------------------------------------------\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  load_prototype_header(temp_reg, obj_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (PrintBiasedLockingStatistics) {\n-    \/\/ z_cgr(mark_reg, temp2_reg);\n-    increment_counter_eq((address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg, temp2_reg);\n-  }\n-\n-  bind(cas_label);\n-  BLOCK_COMMENT(\"} biased_locking_enter\");\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register mark_addr, Register temp_reg, Label& done) {\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  BLOCK_COMMENT(\"biased_locking_exit {\");\n-\n-  z_lg(temp_reg, 0, mark_addr);\n-  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n-\n-  z_chi(temp_reg, markWord::biased_lock_pattern);\n-  z_bre(done);\n-  BLOCK_COMMENT(\"} biased_locking_exit\");\n-}\n-\n-void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {\n+void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2) {\n@@ -3337,4 +3149,0 @@\n-  if (try_bias) {\n-    biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);\n-  }\n-\n@@ -3405,1 +3213,1 @@\n-void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {\n+void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2) {\n@@ -3415,4 +3223,0 @@\n-  if (try_bias) {\n-    biased_locking_exit(oop, currentHeader, done);\n-  }\n-\n@@ -3836,6 +3640,0 @@\n-void MacroAssembler::load_prototype_header(Register Rheader, Register Rsrc_oop) {\n-  assert_different_registers(Rheader, Rsrc_oop);\n-  load_klass(Rheader, Rsrc_oop);\n-  z_lg(Rheader, Address(Rheader, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":204,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -721,20 +721,3 @@\n-  \/\/ Biased locking support\n-  \/\/ Upon entry,obj_reg must contain the target object, and mark_reg\n-  \/\/ must contain the target object's header.\n-  \/\/ Destroys mark_reg if an attempt is made to bias an anonymously\n-  \/\/ biased lock. In this case a failure will go either to the slow\n-  \/\/ case or fall through with the notEqual condition code set with\n-  \/\/ the expectation that the slow case in the runtime will be called.\n-  \/\/ In the fall-through case where the CAS-based lock is done,\n-  \/\/ mark_reg is not destroyed.\n-  void biased_locking_enter(Register obj_reg, Register mark_reg, Register temp_reg,\n-                            Register temp2_reg, Label& done, Label* slow_case = NULL);\n-  \/\/ Upon entry, the base register of mark_addr must contain the oop.\n-  \/\/ Destroys temp_reg.\n-  \/\/ If allow_delay_slot_filling is set to true, the next instruction\n-  \/\/ emitted after this one will go in an annulled delay slot if the\n-  \/\/ biased locking exit case failed.\n-  void biased_locking_exit(Register mark_addr, Register temp_reg, Label& done);\n-\n-  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias = UseBiasedLocking);\n-  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias = UseBiasedLocking);\n+\n+  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2);\n+  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2);\n@@ -785,1 +768,0 @@\n-  void load_prototype_header(Register Rheader, Register Rsrc_oop);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1557,4 +1557,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1668,0 +1664,11 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n+  return (INTPRESSURE == -1) ? 10 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 15 : FLOATPRESSURE;\n+}\n+\n@@ -9812,2 +9819,1 @@\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                             UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n@@ -9821,1 +9827,1 @@\n-  \/\/ TODO: s390 port size(FIXED_SIZE);  \/\/ emitted code depends on UseBiasedLocking being on\/off.\n+  \/\/ TODO: s390 port size(FIXED_SIZE);\n@@ -9823,2 +9829,1 @@\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                               UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1876,7 +1876,0 @@\n-#ifdef ASSERT\n-    if (UseBiasedLocking)\n-      \/\/ Making the box point to itself will make it clear it went unused\n-      \/\/ but also be obviously invalid.\n-      __ z_stg(r_box, 0, r_box);\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3816,8 +3816,2 @@\n-    if (UseBiasedLocking) {\n-      Register prototype = RobjectFields;\n-      __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));\n-      __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));\n-    } else {\n-      __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n-                     (long)markWord::prototype().value());\n-    }\n+    __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n+                   (long)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -3833,0 +3832,8 @@\n+void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}\n+\n@@ -4552,0 +4559,9 @@\n+void Assembler::vpmaddubsw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {\n+assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n+       vector_len == AVX_256bit? VM_Version::supports_avx2() :\n+       vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x04, (0xC0 | encode));\n+}\n+\n@@ -4860,0 +4876,9 @@\n+void Assembler::evptestmb(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x26, (0xC0 | encode));\n+}\n+\n@@ -9407,0 +9432,7 @@\n+void Assembler::shrxl(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-class BiasedLockingCounters;\n-\n@@ -1702,0 +1700,1 @@\n+  void evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1815,0 +1814,2 @@\n+  void vpmaddubsw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+\n@@ -1882,0 +1883,2 @@\n+  void evptestmb(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n@@ -2143,0 +2146,1 @@\n+  void shrxl(Register dst, Register src1, Register src2);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -546,1 +546,3 @@\n-  __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+  if (PrintC1Statistics) {\n+    __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3515,4 +3515,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -3521,1 +3517,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -291,5 +291,0 @@\n-  \/\/ Need a scratch register for biased locking on x86\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n@@ -304,1 +299,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -41,1 +40,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -64,5 +63,0 @@\n-  if (UseBiasedLocking) {\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, rklass_decode_tmp, false, done, &slow_case);\n-  }\n-\n@@ -81,4 +75,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-  }\n@@ -119,6 +109,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -131,4 +115,3 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ load object\n-    movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ load object\n+  movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+\n@@ -162,8 +145,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t\n+  movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  \/\/ scratch : scratch register, contents destroyed\n@@ -54,1 +53,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -237,1 +236,0 @@\n-  assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -247,1 +245,1 @@\n-  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n@@ -262,2 +260,2 @@\n-  andptr(tmpReg, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpptr(tmpReg, markWord::unlocked_value);            \/\/ bits = 001 unlocked\n+  andptr(tmpReg, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+  cmpptr(tmpReg, markWord::unlocked_value);         \/\/ bits = 01 unlocked\n@@ -450,1 +448,0 @@\n-                                 BiasedLockingCounters* counters,\n@@ -465,4 +462,0 @@\n-  if (counters != NULL) {\n-    atomic_incl(ExternalAddress((address)counters->total_entry_count_addr()), scrReg);\n-  }\n-\n@@ -476,3 +469,0 @@\n-  \/\/ * biased\n-  \/\/    -- by Self\n-  \/\/    -- by other\n@@ -496,10 +486,0 @@\n-  \/\/ it's stack-locked, biased or neutral\n-  \/\/ TODO: optimize away redundant LDs of obj->mark and improve the markword triage\n-  \/\/ order to reduce the number of conditional branches in the most common cases.\n-  \/\/ Beware -- there's a subtle invariant that fetch of the markword\n-  \/\/ at [FETCH], below, will never observe a biased encoding (*101b).\n-  \/\/ If this invariant is not held we risk exclusion (safety) failure.\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_enter(boxReg, objReg, tmpReg, scrReg, cx1Reg, false, DONE_LABEL, NULL, counters);\n-  }\n-\n@@ -515,1 +495,1 @@\n-  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral\n@@ -523,4 +503,0 @@\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)counters->fast_path_entry_count_addr()));\n-  }\n@@ -536,4 +512,0 @@\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)counters->fast_path_entry_count_addr()));\n-  }\n@@ -662,6 +634,0 @@\n-  \/\/ Critically, the biased locking test must have precedence over\n-  \/\/ and appear before the (box->dhw == 0) recursive stack-lock test.\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_exit(objReg, tmpReg, DONE_LABEL);\n-  }\n-\n@@ -670,1 +636,0 @@\n-    assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -673,2 +638,2 @@\n-    andptr(tmpReg, markWord::biased_lock_mask_in_place);              \/\/ look at 3 lock bits\n-    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 001 unlocked\n+    andptr(tmpReg, markWord::lock_mask_in_place);                     \/\/ look at 2 lock bits\n+    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 01 unlocked\n@@ -741,1 +706,1 @@\n-  \/\/ It's not inflated and it's not recursively stack-locked and it's not biased.\n+  \/\/ It's not inflated and it's not recursively stack-locked.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":7,"deletions":42,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-                 BiasedLockingCounters* counters,\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-define_pd_global(intx,  INTPRESSURE,                 13);\n-define_pd_global(intx,  FLOATPRESSURE,               14);\n@@ -61,2 +59,0 @@\n-define_pd_global(intx,  INTPRESSURE,                 6);\n-define_pd_global(intx,  FLOATPRESSURE,               6);\n","filename":"src\/hotspot\/cpu\/x86\/c2_globals_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-                               jth->get_thread_name(), callers_rsp, nm->verified_entry_point());\n+                               jth->name(), callers_rsp, nm->verified_entry_point());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1208,2 +1207,1 @@\n-    const Register tmp_reg = rbx; \/\/ Will be passed to biased_locking_enter to avoid a\n-                                  \/\/ problematic case where tmp_reg = no_reg.\n+    const Register tmp_reg = rbx;\n@@ -1230,4 +1228,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &slow_case);\n-    }\n-\n@@ -1248,4 +1242,0 @@\n-    if (PrintBiasedLockingStatistics) {\n-      cond_inc32(Assembler::zero,\n-                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n-    }\n@@ -1288,5 +1278,0 @@\n-\n-    if (PrintBiasedLockingStatistics) {\n-      cond_inc32(Assembler::zero,\n-                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n-    }\n@@ -1344,4 +1329,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(obj_reg, header_reg, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1283,194 +1282,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          Register tmp_reg2,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert(swap_reg == rax, \"swap_reg must be rax for cmpxchgq\");\n-  assert(tmp_reg != noreg, \"tmp_reg must be supplied\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  NOT_LP64( Address saved_mark_addr(lock_reg, 0); )\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL) {\n-    counters = BiasedLocking::counters();\n-  }\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    movptr(swap_reg, mark_addr);\n-  }\n-  movptr(tmp_reg, swap_reg);\n-  andptr(tmp_reg, markWord::biased_lock_mask_in_place);\n-  cmpptr(tmp_reg, markWord::biased_lock_pattern);\n-  jcc(Assembler::notEqual, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-#ifndef _LP64\n-  \/\/ Note that because there is no current thread register on x86_32 we\n-  \/\/ need to store off the mark word we read out of the object to\n-  \/\/ avoid reloading it and needing to recheck invariants below. This\n-  \/\/ store is unfortunate but it makes the overall code shorter and\n-  \/\/ simpler.\n-  movptr(saved_mark_addr, swap_reg);\n-#endif\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-#ifdef _LP64\n-  orptr(tmp_reg, r15_thread);\n-  xorptr(tmp_reg, swap_reg);\n-  Register header_reg = tmp_reg;\n-#else\n-  xorptr(tmp_reg, swap_reg);\n-  get_thread(swap_reg);\n-  xorptr(swap_reg, tmp_reg);\n-  Register header_reg = swap_reg;\n-#endif\n-  andptr(header_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->biased_lock_entry_count_addr()));\n-  }\n-  jcc(Assembler::equal, done);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  testptr(header_reg, markWord::biased_lock_mask_in_place);\n-  jcc(Assembler::notZero, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  testptr(header_reg, markWord::epoch_mask_in_place);\n-  jccb(Assembler::notZero, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  NOT_LP64( movptr(swap_reg, saved_mark_addr); )\n-  andptr(swap_reg,\n-         markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-#ifdef _LP64\n-  movptr(tmp_reg, swap_reg);\n-  orptr(tmp_reg, r15_thread);\n-#else\n-  get_thread(tmp_reg);\n-  orptr(tmp_reg, swap_reg);\n-#endif\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->anonymously_biased_lock_entry_count_addr()));\n-  }\n-  if (slow_case != NULL) {\n-    jcc(Assembler::notZero, *slow_case);\n-  }\n-  jmp(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-#ifdef _LP64\n-  orptr(tmp_reg, r15_thread);\n-#else\n-  get_thread(swap_reg);\n-  orptr(tmp_reg, swap_reg);\n-  movptr(swap_reg, saved_mark_addr);\n-#endif\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ If the biasing toward our thread failed, then another thread\n-  \/\/ succeeded in biasing it toward itself and we need to revoke that\n-  \/\/ bias. The revocation will occur in the runtime in the slow case.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->rebiased_lock_entry_count_addr()));\n-  }\n-  if (slow_case != NULL) {\n-    jcc(Assembler::notZero, *slow_case);\n-  }\n-  jmp(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  NOT_LP64( movptr(swap_reg, saved_mark_addr); )\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->revoked_lock_entry_count_addr()));\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andptr(temp_reg, markWord::biased_lock_mask_in_place);\n-  cmpptr(temp_reg, markWord::biased_lock_pattern);\n-  jcc(Assembler::equal, done);\n-}\n-\n@@ -4735,5 +4540,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {\n-  load_klass(dst, src, tmp);\n-  movptr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":200,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -359,2 +359,0 @@\n-  void load_prototype_header(Register dst, Register src, Register tmp);\n-\n@@ -676,15 +674,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg must be rax, and is killed.\n-  \/\/ tmp_reg is optional. If it is supplied (i.e., != noreg) it will\n-  \/\/ be killed; if not supplied, push\/pop will be used internally to\n-  \/\/ allocate a temporary (inefficient, avoid if possible).\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            Register tmp_reg2, bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,6 +65,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Check if biased and fall through to runtime if so\n-    __ testptr(result, markWord::biased_lock_bit_in_place);\n-    __ jcc(Assembler::notZero, slowCase);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1826,5 +1826,0 @@\n-    if (UseBiasedLocking) {\n-      \/\/ Note that oop_handle_reg is trashed during this call\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, noreg, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1863,5 +1858,0 @@\n-\n-    if (UseBiasedLocking) {\n-      \/\/ Re-fetch oop_handle_reg as we trashed it above\n-      __ movptr(oop_handle_reg, Address(rsp, wordSize));\n-    }\n@@ -1996,4 +1986,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, rbx, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2073,4 +2073,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, rscratch2, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -2227,5 +2223,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5686,0 +5686,644 @@\n+  \/\/ base64 AVX512vbmi tables\n+  address base64_vbmi_lookup_lo_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x3f8080803e808080, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0x8080808080803d3c, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_lookup_hi_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x0605040302010080, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x8080808080191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1a80, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0x8080808080333231, relocInfo::none);\n+    return start;\n+  }\n+  address base64_vbmi_lookup_lo_url_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64url\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x80803e8080808080, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0x8080808080803d3c, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_lookup_hi_url_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64url\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x0605040302010080, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x3f80808080191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1a80, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0x8080808080333231, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_pack_vec_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"pack_vec_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x090a040506000102, relocInfo::none);\n+    __ emit_data64(0x161011120c0d0e08, relocInfo::none);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_0_1_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_0_1_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x090a040506000102, relocInfo::none);\n+    __ emit_data64(0x161011120c0d0e08, relocInfo::none);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_1_2_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_1_2_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    __ emit_data64(0x5c5d5e58595a5455, relocInfo::none);\n+    __ emit_data64(0x696a646566606162, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_2_3_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_2_3_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    __ emit_data64(0x5c5d5e58595a5455, relocInfo::none);\n+    __ emit_data64(0x696a646566606162, relocInfo::none);\n+    __ emit_data64(0x767071726c6d6e68, relocInfo::none);\n+    __ emit_data64(0x7c7d7e78797a7475, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_decoding_table_addr() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"decoding_table_base64\");\n+    address start = __ pc();\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0x3fffffff3effffff, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0xffffffffffff3d3c, relocInfo::none);\n+    __ emit_data64(0x06050403020100ff, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0xffffffffff191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1aff, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0xffffffffff333231, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+\n+    \/\/ URL table\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffff3effffffffff, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0xffffffffffff3d3c, relocInfo::none);\n+    __ emit_data64(0x06050403020100ff, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x3fffffffff191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1aff, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0xffffffffff333231, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    return start;\n+  }\n+\n+\n+\/\/ Code for generating Base64 decoding.\n+\/\/\n+\/\/ Based on the article (and associated code) from https:\/\/arxiv.org\/abs\/1910.05109.\n+\/\/\n+\/\/ Intrinsic function prototype in Base64.java:\n+\/\/ private void decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, isMIME) {\n+  address generate_base64_decodeBlock() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"implDecode\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    \/\/ Save callee-saved registers before using them\n+    __ push(r12);\n+    __ push(r13);\n+    __ push(r14);\n+    __ push(r15);\n+    __ push(rbx);\n+\n+    \/\/ arguments\n+    const Register source = c_rarg0; \/\/ Source Array\n+    const Register start_offset = c_rarg1; \/\/ start offset\n+    const Register end_offset = c_rarg2; \/\/ end offset\n+    const Register dest = c_rarg3; \/\/ destination array\n+    const Register isMIME = rbx;\n+\n+#ifndef _WIN64\n+    const Register dp = c_rarg4;  \/\/ Position for writing to dest array\n+    const Register isURL = c_rarg5;\/\/ Base64 or URL character set\n+    __ movl(isMIME, Address(rbp, 2 * wordSize));\n+#else\n+    const Address  dp_mem(rbp, 6 * wordSize);  \/\/ length is on stack on Win64\n+    const Address isURL_mem(rbp, 7 * wordSize);\n+    const Register isURL = r10;      \/\/ pick the volatile windows register\n+    const Register dp = r12;\n+    __ movl(dp, dp_mem);\n+    __ movl(isURL, isURL_mem);\n+    __ movl(isMIME, Address(rbp, 8 * wordSize));\n+#endif\n+\n+    const XMMRegister lookup_lo = xmm5;\n+    const XMMRegister lookup_hi = xmm6;\n+    const XMMRegister errorvec = xmm7;\n+    const XMMRegister pack16_op = xmm9;\n+    const XMMRegister pack32_op = xmm8;\n+    const XMMRegister input0 = xmm3;\n+    const XMMRegister input1 = xmm20;\n+    const XMMRegister input2 = xmm21;\n+    const XMMRegister input3 = xmm19;\n+    const XMMRegister join01 = xmm12;\n+    const XMMRegister join12 = xmm11;\n+    const XMMRegister join23 = xmm10;\n+    const XMMRegister translated0 = xmm2;\n+    const XMMRegister translated1 = xmm1;\n+    const XMMRegister translated2 = xmm0;\n+    const XMMRegister translated3 = xmm4;\n+\n+    const XMMRegister merged0 = xmm2;\n+    const XMMRegister merged1 = xmm1;\n+    const XMMRegister merged2 = xmm0;\n+    const XMMRegister merged3 = xmm4;\n+    const XMMRegister merge_ab_bc0 = xmm2;\n+    const XMMRegister merge_ab_bc1 = xmm1;\n+    const XMMRegister merge_ab_bc2 = xmm0;\n+    const XMMRegister merge_ab_bc3 = xmm4;\n+\n+    const XMMRegister pack24bits = xmm4;\n+\n+    const Register length = r14;\n+    const Register output_size = r13;\n+    const Register output_mask = r15;\n+    const KRegister input_mask = k1;\n+\n+    const XMMRegister input_initial_valid_b64 = xmm0;\n+    const XMMRegister tmp = xmm10;\n+    const XMMRegister mask = xmm0;\n+    const XMMRegister invalid_b64 = xmm1;\n+\n+    Label L_process256, L_process64, L_process64Loop, L_exit, L_processdata, L_loadURL;\n+    Label L_continue, L_finalBit, L_padding, L_donePadding, L_bruteForce;\n+    Label L_forceLoop, L_bottomLoop, L_checkMIME, L_exit_no_vzero;\n+\n+    \/\/ calculate length from offsets\n+    __ movl(length, end_offset);\n+    __ subl(length, start_offset);\n+    __ push(dest);          \/\/ Save for return value calc\n+\n+    \/\/ If AVX512 VBMI not supported, just compile non-AVX code\n+    if(VM_Version::supports_avx512_vbmi() &&\n+       VM_Version::supports_avx512bw()) {\n+      __ cmpl(length, 128);     \/\/ 128-bytes is break-even for AVX-512\n+      __ jcc(Assembler::lessEqual, L_bruteForce);\n+\n+      __ cmpl(isMIME, 0);\n+      __ jcc(Assembler::notEqual, L_bruteForce);\n+\n+      \/\/ Load lookup tables based on isURL\n+      __ cmpl(isURL, 0);\n+      __ jcc(Assembler::notZero, L_loadURL);\n+\n+      __ evmovdquq(lookup_lo, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_lo_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(lookup_hi, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_hi_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ BIND(L_continue);\n+\n+      __ movl(r15, 0x01400140);\n+      __ evpbroadcastd(pack16_op, r15, Assembler::AVX_512bit);\n+\n+      __ movl(r15, 0x00011000);\n+      __ evpbroadcastd(pack32_op, r15, Assembler::AVX_512bit);\n+\n+      __ cmpl(length, 0xff);\n+      __ jcc(Assembler::lessEqual, L_process64);\n+\n+      \/\/ load masks required for decoding data\n+      __ BIND(L_processdata);\n+      __ evmovdquq(join01, ExternalAddress(StubRoutines::x86::base64_vbmi_join_0_1_addr()), Assembler::AVX_512bit,r13);\n+      __ evmovdquq(join12, ExternalAddress(StubRoutines::x86::base64_vbmi_join_1_2_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(join23, ExternalAddress(StubRoutines::x86::base64_vbmi_join_2_3_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ align(32);\n+      __ BIND(L_process256);\n+      \/\/ Grab input data\n+      __ evmovdquq(input0, Address(source, start_offset, Address::times_1, 0x00), Assembler::AVX_512bit);\n+      __ evmovdquq(input1, Address(source, start_offset, Address::times_1, 0x40), Assembler::AVX_512bit);\n+      __ evmovdquq(input2, Address(source, start_offset, Address::times_1, 0x80), Assembler::AVX_512bit);\n+      __ evmovdquq(input3, Address(source, start_offset, Address::times_1, 0xc0), Assembler::AVX_512bit);\n+\n+      \/\/ Copy the low part of the lookup table into the destination of the permutation\n+      __ evmovdquq(translated0, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated1, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated2, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated3, lookup_lo, Assembler::AVX_512bit);\n+\n+      \/\/ Translate the base64 input into \"decoded\" bytes\n+      __ evpermt2b(translated0, input0, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated1, input1, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated2, input2, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated3, input3, lookup_hi, Assembler::AVX_512bit);\n+\n+      \/\/ OR all of the translations together to check for errors (high-order bit of byte set)\n+      __ vpternlogd(input0, 0xfe, input1, input2, Assembler::AVX_512bit);\n+\n+      __ vpternlogd(input3, 0xfe, translated0, translated1, Assembler::AVX_512bit);\n+      __ vpternlogd(input0, 0xfe, translated1, translated2, Assembler::AVX_512bit);\n+      __ vpor(errorvec, input3, input0, Assembler::AVX_512bit);\n+\n+      \/\/ Check if there was an error - if so, try 64-byte chunks\n+      __ evpmovb2m(k3, errorvec, Assembler::AVX_512bit);\n+      __ kortestql(k3, k3);\n+      __ jcc(Assembler::notZero, L_process64);\n+\n+      \/\/ The merging and shuffling happens here\n+      \/\/ We multiply each byte pair [00dddddd | 00cccccc | 00bbbbbb | 00aaaaaa]\n+      \/\/ Multiply [00cccccc] by 2^6 added to [00dddddd] to get [0000cccc | ccdddddd]\n+      \/\/ The pack16_op is a vector of 0x01400140, so multiply D by 1 and C by 0x40\n+      __ vpmaddubsw(merge_ab_bc0, translated0, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc1, translated1, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc2, translated2, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc3, translated3, pack16_op, Assembler::AVX_512bit);\n+\n+      \/\/ Now do the same with packed 16-bit values.\n+      \/\/ We start with [0000cccc | ccdddddd | 0000aaaa | aabbbbbb]\n+      \/\/ pack32_op is 0x00011000 (2^12, 1), so this multiplies [0000aaaa | aabbbbbb] by 2^12\n+      \/\/ and adds [0000cccc | ccdddddd] to yield [00000000 | aaaaaabb | bbbbcccc | ccdddddd]\n+      __ vpmaddwd(merged0, merge_ab_bc0, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged1, merge_ab_bc1, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged2, merge_ab_bc2, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged3, merge_ab_bc3, pack32_op, Assembler::AVX_512bit);\n+\n+      \/\/ The join vectors specify which byte from which vector goes into the outputs\n+      \/\/ One of every 4 bytes in the extended vector is zero, so we pack them into their\n+      \/\/ final positions in the register for storing (256 bytes in, 192 bytes out)\n+      __ evpermt2b(merged0, join01, merged1, Assembler::AVX_512bit);\n+      __ evpermt2b(merged1, join12, merged2, Assembler::AVX_512bit);\n+      __ evpermt2b(merged2, join23, merged3, Assembler::AVX_512bit);\n+\n+      \/\/ Store result\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x00), merged0, Assembler::AVX_512bit);\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x40), merged1, Assembler::AVX_512bit);\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x80), merged2, Assembler::AVX_512bit);\n+\n+      __ addptr(source, 0x100);\n+      __ addptr(dest, 0xc0);\n+      __ subl(length, 0x100);\n+      __ cmpl(length, 64 * 4);\n+      __ jcc(Assembler::greaterEqual, L_process256);\n+\n+      \/\/ At this point, we've decoded 64 * 4 * n bytes.\n+      \/\/ The remaining length will be <= 64 * 4 - 1.\n+      \/\/ UNLESS there was an error decoding the first 256-byte chunk.  In this\n+      \/\/ case, the length will be arbitrarily long.\n+      \/\/\n+      \/\/ Note that this will be the path for MIME-encoded strings.\n+\n+      __ BIND(L_process64);\n+\n+      __ evmovdquq(pack24bits, ExternalAddress(StubRoutines::x86::base64_vbmi_pack_vec_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ cmpl(length, 63);\n+      __ jcc(Assembler::lessEqual, L_finalBit);\n+\n+      __ align(32);\n+      __ BIND(L_process64Loop);\n+\n+      \/\/ Handle first 64-byte block\n+\n+      __ evmovdquq(input0, Address(source, start_offset), Assembler::AVX_512bit);\n+      __ evmovdquq(translated0, lookup_lo, Assembler::AVX_512bit);\n+      __ evpermt2b(translated0, input0, lookup_hi, Assembler::AVX_512bit);\n+\n+      __ vpor(errorvec, translated0, input0, Assembler::AVX_512bit);\n+\n+      \/\/ Check for error and bomb out before updating dest\n+      __ evpmovb2m(k3, errorvec, Assembler::AVX_512bit);\n+      __ kortestql(k3, k3);\n+      __ jcc(Assembler::notZero, L_exit);\n+\n+      \/\/ Pack output register, selecting correct byte ordering\n+      __ vpmaddubsw(merge_ab_bc0, translated0, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged0, merge_ab_bc0, pack32_op, Assembler::AVX_512bit);\n+      __ vpermb(merged0, pack24bits, merged0, Assembler::AVX_512bit);\n+\n+      __ evmovdquq(Address(dest, dp), merged0, Assembler::AVX_512bit);\n+\n+      __ subl(length, 64);\n+      __ addptr(source, 64);\n+      __ addptr(dest, 48);\n+\n+      __ cmpl(length, 64);\n+      __ jcc(Assembler::greaterEqual, L_process64Loop);\n+\n+      __ cmpl(length, 0);\n+      __ jcc(Assembler::lessEqual, L_exit);\n+\n+      __ BIND(L_finalBit);\n+      \/\/ Now have 1 to 63 bytes left to decode\n+\n+      \/\/ I was going to let Java take care of the final fragment\n+      \/\/ however it will repeatedly call this routine for every 4 bytes\n+      \/\/ of input data, so handle the rest here.\n+      __ movq(rax, -1);\n+      __ bzhiq(rax, rax, length);    \/\/ Input mask in rax\n+\n+      __ movl(output_size, length);\n+      __ shrl(output_size, 2);   \/\/ Find (len \/ 4) * 3 (output length)\n+      __ lea(output_size, Address(output_size, output_size, Address::times_2, 0));\n+      \/\/ output_size in r13\n+\n+      \/\/ Strip pad characters, if any, and adjust length and mask\n+      __ cmpb(Address(source, length, Address::times_1, -1), '=');\n+      __ jcc(Assembler::equal, L_padding);\n+\n+      __ BIND(L_donePadding);\n+\n+      \/\/ Output size is (64 - output_size), output mask is (all 1s >> output_size).\n+      __ kmovql(input_mask, rax);\n+      __ movq(output_mask, -1);\n+      __ bzhiq(output_mask, output_mask, output_size);\n+\n+      \/\/ Load initial input with all valid base64 characters.  Will be used\n+      \/\/ in merging source bytes to avoid masking when determining if an error occurred.\n+      __ movl(rax, 0x61616161);\n+      __ evpbroadcastd(input_initial_valid_b64, rax, Assembler::AVX_512bit);\n+\n+      \/\/ A register containing all invalid base64 decoded values\n+      __ movl(rax, 0x80808080);\n+      __ evpbroadcastd(invalid_b64, rax, Assembler::AVX_512bit);\n+\n+      \/\/ input_mask is in k1\n+      \/\/ output_size is in r13\n+      \/\/ output_mask is in r15\n+      \/\/ zmm0 - free\n+      \/\/ zmm1 - 0x00011000\n+      \/\/ zmm2 - 0x01400140\n+      \/\/ zmm3 - errorvec\n+      \/\/ zmm4 - pack vector\n+      \/\/ zmm5 - lookup_lo\n+      \/\/ zmm6 - lookup_hi\n+      \/\/ zmm7 - errorvec\n+      \/\/ zmm8 - 0x61616161\n+      \/\/ zmm9 - 0x80808080\n+\n+      \/\/ Load only the bytes from source, merging into our \"fully-valid\" register\n+      __ evmovdqub(input_initial_valid_b64, input_mask, Address(source, start_offset, Address::times_1, 0x0), true, Assembler::AVX_512bit);\n+\n+      \/\/ Decode all bytes within our merged input\n+      __ evmovdquq(tmp, lookup_lo, Assembler::AVX_512bit);\n+      __ evpermt2b(tmp, input_initial_valid_b64, lookup_hi, Assembler::AVX_512bit);\n+      __ vporq(mask, tmp, input_initial_valid_b64, Assembler::AVX_512bit);\n+\n+      \/\/ Check for error.  Compare (decoded | initial) to all invalid.\n+      \/\/ If any bytes have their high-order bit set, then we have an error.\n+      __ evptestmb(k2, mask, invalid_b64, Assembler::AVX_512bit);\n+      __ kortestql(k2, k2);\n+\n+      \/\/ If we have an error, use the brute force loop to decode what we can (4-byte chunks).\n+      __ jcc(Assembler::notZero, L_bruteForce);\n+\n+      \/\/ Shuffle output bytes\n+      __ vpmaddubsw(tmp, tmp, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(tmp, tmp, pack32_op, Assembler::AVX_512bit);\n+\n+      __ vpermb(tmp, pack24bits, tmp, Assembler::AVX_512bit);\n+      __ kmovql(k1, output_mask);\n+      __ evmovdqub(Address(dest, dp), k1, tmp, true, Assembler::AVX_512bit);\n+\n+      __ addptr(dest, output_size);\n+\n+      __ BIND(L_exit);\n+      __ vzeroupper();\n+      __ pop(rax);             \/\/ Get original dest value\n+      __ subptr(dest, rax);      \/\/ Number of bytes converted\n+      __ movptr(rax, dest);\n+      __ pop(rbx);\n+      __ pop(r15);\n+      __ pop(r14);\n+      __ pop(r13);\n+      __ pop(r12);\n+      __ leave();\n+      __ ret(0);\n+\n+      __ BIND(L_loadURL);\n+      __ evmovdquq(lookup_lo, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_lo_url_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(lookup_hi, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_hi_url_addr()), Assembler::AVX_512bit, r13);\n+      __ jmp(L_continue);\n+\n+      __ BIND(L_padding);\n+      __ decrementq(output_size, 1);\n+      __ shrq(rax, 1);\n+\n+      __ cmpb(Address(source, length, Address::times_1, -2), '=');\n+      __ jcc(Assembler::notEqual, L_donePadding);\n+\n+      __ decrementq(output_size, 1);\n+      __ shrq(rax, 1);\n+      __ jmp(L_donePadding);\n+\n+      __ align(32);\n+      __ BIND(L_bruteForce);\n+    }   \/\/ End of if(avx512_vbmi)\n+\n+    \/\/ Use non-AVX code to decode 4-byte chunks into 3 bytes of output\n+\n+    \/\/ Register state (Linux):\n+    \/\/ r12-15 - saved on stack\n+    \/\/ rdi - src\n+    \/\/ rsi - sp\n+    \/\/ rdx - sl\n+    \/\/ rcx - dst\n+    \/\/ r8 - dp\n+    \/\/ r9 - isURL\n+\n+    \/\/ Register state (Windows):\n+    \/\/ r12-15 - saved on stack\n+    \/\/ rcx - src\n+    \/\/ rdx - sp\n+    \/\/ r8 - sl\n+    \/\/ r9 - dst\n+    \/\/ r12 - dp\n+    \/\/ r10 - isURL\n+\n+    \/\/ Registers (common):\n+    \/\/ length (r14) - bytes in src\n+\n+    const Register decode_table = r11;\n+    const Register out_byte_count = rbx;\n+    const Register byte1 = r13;\n+    const Register byte2 = r15;\n+    const Register byte3 = WINDOWS_ONLY(r8) NOT_WINDOWS(rdx);\n+    const Register byte4 = WINDOWS_ONLY(r10) NOT_WINDOWS(r9);\n+\n+    __ shrl(length, 2);    \/\/ Multiple of 4 bytes only - length is # 4-byte chunks\n+    __ cmpl(length, 0);\n+    __ jcc(Assembler::lessEqual, L_exit_no_vzero);\n+\n+    __ shll(isURL, 8);    \/\/ index into decode table based on isURL\n+    __ lea(decode_table, ExternalAddress(StubRoutines::x86::base64_decoding_table_addr()));\n+    __ addptr(decode_table, isURL);\n+\n+    __ jmp(L_bottomLoop);\n+\n+    __ align(32);\n+    __ BIND(L_forceLoop);\n+    __ shll(byte1, 18);\n+    __ shll(byte2, 12);\n+    __ shll(byte3, 6);\n+    __ orl(byte1, byte2);\n+    __ orl(byte1, byte3);\n+    __ orl(byte1, byte4);\n+\n+    __ addptr(source, 4);\n+\n+    __ movb(Address(dest, dp, Address::times_1, 2), byte1);\n+    __ shrl(byte1, 8);\n+    __ movb(Address(dest, dp, Address::times_1, 1), byte1);\n+    __ shrl(byte1, 8);\n+    __ movb(Address(dest, dp, Address::times_1, 0), byte1);\n+\n+    __ addptr(dest, 3);\n+    __ decrementl(length, 1);\n+    __ jcc(Assembler::zero, L_exit_no_vzero);\n+\n+    __ BIND(L_bottomLoop);\n+    __ load_unsigned_byte(byte1, Address(source, start_offset, Address::times_1, 0x00));\n+    __ load_unsigned_byte(byte2, Address(source, start_offset, Address::times_1, 0x01));\n+    __ load_signed_byte(byte1, Address(decode_table, byte1));\n+    __ load_signed_byte(byte2, Address(decode_table, byte2));\n+    __ load_unsigned_byte(byte3, Address(source, start_offset, Address::times_1, 0x02));\n+    __ load_unsigned_byte(byte4, Address(source, start_offset, Address::times_1, 0x03));\n+    __ load_signed_byte(byte3, Address(decode_table, byte3));\n+    __ load_signed_byte(byte4, Address(decode_table, byte4));\n+\n+    __ mov(rax, byte1);\n+    __ orl(rax, byte2);\n+    __ orl(rax, byte3);\n+    __ orl(rax, byte4);\n+    __ jcc(Assembler::positive, L_forceLoop);\n+\n+    __ BIND(L_exit_no_vzero);\n+    __ pop(rax);             \/\/ Get original dest value\n+    __ subptr(dest, rax);      \/\/ Number of bytes converted\n+    __ movptr(rax, dest);\n+    __ pop(rbx);\n+    __ pop(r15);\n+    __ pop(r14);\n+    __ pop(r13);\n+    __ pop(r12);\n+    __ leave();\n+    __ ret(0);\n+\n+    return start;\n+  }\n+\n+\n@@ -6972,0 +7616,13 @@\n+      if(VM_Version::supports_avx512_vbmi() &&\n+         VM_Version::supports_avx512bw()) {\n+        StubRoutines::x86::_lookup_lo_base64 = base64_vbmi_lookup_lo_addr();\n+        StubRoutines::x86::_lookup_hi_base64 = base64_vbmi_lookup_hi_addr();\n+        StubRoutines::x86::_lookup_lo_base64url = base64_vbmi_lookup_lo_url_addr();\n+        StubRoutines::x86::_lookup_hi_base64url = base64_vbmi_lookup_hi_url_addr();\n+        StubRoutines::x86::_pack_vec_base64 = base64_vbmi_pack_vec_addr();\n+        StubRoutines::x86::_join_0_1_base64 = base64_vbmi_join_0_1_addr();\n+        StubRoutines::x86::_join_1_2_base64 = base64_vbmi_join_1_2_addr();\n+        StubRoutines::x86::_join_2_3_base64 = base64_vbmi_join_2_3_addr();\n+      }\n+      StubRoutines::x86::_decoding_table_base64 = base64_decoding_table_addr();\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":657,"deletions":0,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -76,0 +76,9 @@\n+address StubRoutines::x86::_lookup_lo_base64 = NULL;\n+address StubRoutines::x86::_lookup_hi_base64 = NULL;\n+address StubRoutines::x86::_lookup_lo_base64url = NULL;\n+address StubRoutines::x86::_lookup_hi_base64url = NULL;\n+address StubRoutines::x86::_pack_vec_base64 = NULL;\n+address StubRoutines::x86::_join_0_1_base64 = NULL;\n+address StubRoutines::x86::_join_1_2_base64 = NULL;\n+address StubRoutines::x86::_join_2_3_base64 = NULL;\n+address StubRoutines::x86::_decoding_table_base64 = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -194,0 +194,9 @@\n+  static address _lookup_lo_base64;\n+  static address _lookup_hi_base64;\n+  static address _lookup_lo_base64url;\n+  static address _lookup_hi_base64url;\n+  static address _pack_vec_base64;\n+  static address _join_0_1_base64;\n+  static address _join_1_2_base64;\n+  static address _join_2_3_base64;\n+  static address _decoding_table_base64;\n@@ -339,0 +348,9 @@\n+  static address base64_vbmi_lookup_lo_addr() { return _lookup_lo_base64; }\n+  static address base64_vbmi_lookup_hi_addr() { return _lookup_hi_base64; }\n+  static address base64_vbmi_lookup_lo_url_addr() { return _lookup_lo_base64url; }\n+  static address base64_vbmi_lookup_hi_url_addr() { return _lookup_hi_base64url; }\n+  static address base64_vbmi_pack_vec_addr() { return _pack_vec_base64; }\n+  static address base64_vbmi_join_0_1_addr() { return _join_0_1_base64; }\n+  static address base64_vbmi_join_1_2_addr() { return _join_1_2_base64; }\n+  static address base64_vbmi_join_2_3_addr() { return _join_2_3_base64; }\n+  static address base64_decoding_table_addr() { return _decoding_table_base64; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4026,9 +4026,3 @@\n-    if (UseBiasedLocking) {\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-      __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n-    } else {\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),\n-                (intptr_t)markWord::prototype().value()); \/\/ header\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-    }\n+    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n+              (intptr_t)markWord::prototype().value()); \/\/ header\n+    __ pop(rcx);   \/\/ get saved klass back in the register.\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1015,4 +1015,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n-    \/\/ VM_Version_init() is executed after UseBiasedLocking is used\n-    \/\/ in Thread::allocate().\n@@ -1026,2 +1022,0 @@\n-      \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-      \/\/ setting during arguments processing. See use_biased_locking().\n@@ -1065,2 +1059,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n@@ -1739,21 +1731,0 @@\n-bool VM_Version::use_biased_locking() {\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM locking is most useful when there is high lock contention and\n-  \/\/ low data contention.  With high lock contention the lock is usually\n-  \/\/ inflated and biased locking is not suitable for that case.\n-  \/\/ RTM locking code requires that biased locking is off.\n-  \/\/ Note: we can't switch off UseBiasedLocking in get_processor_features()\n-  \/\/ because it is used by Thread::allocate() which is called before\n-  \/\/ VM_Version::initialize().\n-  if (UseRTMLocking && UseBiasedLocking) {\n-    if (FLAG_IS_DEFAULT(UseBiasedLocking)) {\n-      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n-    } else {\n-      warning(\"Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.\" );\n-      UseBiasedLocking = false;\n-    }\n-  }\n-#endif\n-  return UseBiasedLocking;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -750,3 +750,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1901,12 +1901,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  int float_pressure_threshold = default_pressure_threshold;\n-#ifdef _LP64\n-  if (UseAVX > 2) {\n-    \/\/ Increase pressure threshold on machines with AVX3 which have\n-    \/\/ 2x more XMM registers.\n-    float_pressure_threshold = default_pressure_threshold * 2;\n-  }\n-#endif\n-  return float_pressure_threshold;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1443,0 +1443,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 6 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 6 : FLOATPRESSURE;\n+}\n+\n@@ -13670,1 +13680,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -13685,1 +13695,1 @@\n-                 $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, noreg, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+extern RegMask _FLOAT_REG_mask;\n@@ -353,0 +354,1 @@\n+RegMask _FLOAT_REG_mask;\n@@ -428,0 +430,4 @@\n+  \/\/ _FLOAT_REG_LEGACY_mask\/_FLOAT_REG_EVEX_mask is generated by adlc\n+  \/\/ from the float_reg_legacy\/float_reg_evex register class.\n+  _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;\n+\n@@ -1761,0 +1767,14 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.Size() : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ After experiment around with different values, the following default threshold\n+  \/\/ works best for LCM's register pressure scheduling on x64.\n+  uint dec_count  = VM_Version::supports_evex() ? 4 : 2;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - dec_count;\n+  return (FLOATPRESSURE == -1) ? default_float_pressure_threshold : FLOATPRESSURE;\n+}\n+\n@@ -12910,1 +12930,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -12925,1 +12945,1 @@\n-                 $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, $cx1$$Register, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/assembler_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    get_interpreterState()->set_thread(thread->as_Java_thread());\n+    get_interpreterState()->set_thread(JavaThread::cast(thread));\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -888,0 +888,9 @@\n+\/\/ For dynamic lookup of SetThreadDescription API\n+typedef HRESULT (WINAPI *SetThreadDescriptionFnPtr)(HANDLE, PCWSTR);\n+typedef HRESULT (WINAPI *GetThreadDescriptionFnPtr)(HANDLE, PWSTR*);\n+static SetThreadDescriptionFnPtr _SetThreadDescription = NULL;\n+DEBUG_ONLY(static GetThreadDescriptionFnPtr _GetThreadDescription = NULL;)\n+\n+\/\/ forward decl.\n+static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path);\n+\n@@ -890,0 +899,45 @@\n+  \/\/ From Windows 10 and Windows 2016 server, we have a direct API\n+  \/\/ for setting the thread name\/description:\n+  \/\/ https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/processthreadsapi\/nf-processthreadsapi-setthreaddescription\n+\n+  if (_SetThreadDescription != NULL) {\n+    \/\/ SetThreadDescription takes a PCWSTR but we have conversion routines that produce\n+    \/\/ LPWSTR. The only difference is that PCWSTR is a pointer to const WCHAR.\n+    LPWSTR unicode_name;\n+    errno_t err = convert_to_unicode(name, &unicode_name);\n+    if (err == ERROR_SUCCESS) {\n+      HANDLE current = GetCurrentThread();\n+      HRESULT hr = _SetThreadDescription(current, unicode_name);\n+      if (FAILED(hr)) {\n+        log_debug(os, thread)(\"set_native_thread_name: SetThreadDescription failed - falling back to debugger method\");\n+        FREE_C_HEAP_ARRAY(WCHAR, unicode_name);\n+      } else {\n+        log_trace(os, thread)(\"set_native_thread_name: SetThreadDescription succeeded - new name: %s\", name);\n+\n+#ifdef ASSERT\n+        \/\/ For verification purposes in a debug build we read the thread name back and check it.\n+        PWSTR thread_name;\n+        HRESULT hr2 = _GetThreadDescription(current, &thread_name);\n+        if (FAILED(hr2)) {\n+          log_debug(os, thread)(\"set_native_thread_name: GetThreadDescription failed!\");\n+        } else {\n+          int res = CompareStringW(LOCALE_USER_DEFAULT,\n+                                   0, \/\/ no special comparison rules\n+                                   unicode_name,\n+                                   -1, \/\/ null-terminated\n+                                   thread_name,\n+                                   -1  \/\/ null-terminated\n+                                   );\n+          assert(res == CSTR_EQUAL,\n+                 \"Name strings were not the same - set: %ls, but read: %ls\", unicode_name, thread_name);\n+          LocalFree(thread_name);\n+        }\n+#endif\n+        FREE_C_HEAP_ARRAY(WCHAR, unicode_name);\n+        return;\n+      }\n+    } else {\n+      log_debug(os, thread)(\"set_native_thread_name: convert_to_unicode failed - falling back to debugger method\");\n+    }\n+  }\n+\n@@ -898,0 +952,1 @@\n+    log_debug(os, thread)(\"set_native_thread_name: no debugger present so unable to set thread name\");\n@@ -2236,1 +2291,1 @@\n-    thread->as_Java_thread()->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->PC_NAME);\n+    JavaThread::cast(thread)->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->PC_NAME);\n@@ -2530,1 +2585,1 @@\n-    JavaThread* thread = t->as_Java_thread();\n+    JavaThread* thread = JavaThread::cast(t);\n@@ -4196,0 +4251,1 @@\n+\n@@ -4314,0 +4370,18 @@\n+  \/\/ Lookup SetThreadDescription - the docs state we must use runtime-linking of\n+  \/\/ kernelbase.dll, so that is what we do.\n+  HINSTANCE _kernelbase = LoadLibrary(TEXT(\"kernelbase.dll\"));\n+  if (_kernelbase != NULL) {\n+    _SetThreadDescription =\n+      reinterpret_cast<SetThreadDescriptionFnPtr>(\n+                                                  GetProcAddress(_kernelbase,\n+                                                                 \"SetThreadDescription\"));\n+#ifdef ASSERT\n+    _GetThreadDescription =\n+      reinterpret_cast<GetThreadDescriptionFnPtr>(\n+                                                  GetProcAddress(_kernelbase,\n+                                                                 \"GetThreadDescription\"));\n+#endif\n+  }\n+  log_info(os, thread)(\"The SetThreadDescription API is%s available.\", _SetThreadDescription == NULL ? \" not\" : \"\");\n+\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"utilities\/debug.hpp\"\n+\n@@ -67,1 +69,1 @@\n-  if (order == memory_order_relaxed) {\n+  if (order == memory_order_conservative) {\n@@ -69,0 +71,1 @@\n+    FULL_MEM_BARRIER;\n@@ -71,0 +74,1 @@\n+    FULL_MEM_BARRIER;\n@@ -73,0 +77,23 @@\n+    STATIC_ASSERT (\n+       \/\/ The modes that align with C++11 are intended to\n+       \/\/ follow the same semantics.\n+       memory_order_relaxed == __ATOMIC_RELAXED &&\n+       memory_order_acquire == __ATOMIC_ACQUIRE &&\n+       memory_order_release == __ATOMIC_RELEASE &&\n+       memory_order_acq_rel == __ATOMIC_ACQ_REL &&\n+       memory_order_seq_cst == __ATOMIC_SEQ_CST);\n+\n+    \/\/ Some sanity checking on the memory order. It makes no\n+    \/\/ sense to have a release operation for a store that never\n+    \/\/ happens.\n+    int failure_memory_order;\n+    switch (order) {\n+    case memory_order_release:\n+      failure_memory_order = memory_order_relaxed; break;\n+    case memory_order_acq_rel:\n+      failure_memory_order = memory_order_acquire; break;\n+    default:\n+      failure_memory_order = order;\n+    }\n+    assert(failure_memory_order <= order, \"must be\");\n+\n@@ -74,1 +101,0 @@\n-    FULL_MEM_BARRIER;\n@@ -76,2 +102,1 @@\n-                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n-    FULL_MEM_BARRIER;\n+                              order, failure_memory_order);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/atomic_bsd_aarch64.hpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -115,1 +115,49 @@\n-        .globl aarch64_atomic_cmpxchg_1_relaxed_default_impl\n+        .globl aarch64_atomic_cmpxchg_4_release_default_impl\n+        .align 5\n+aarch64_atomic_cmpxchg_4_release_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldxr    w3, [x0]\n+        cmp     w3, w1\n+        b.ne    1f\n+        stlxr   w8, w2, [x0]\n+        cbnz    w8, 0b\n+1:      mov     w0, w3\n+        ret\n+\n+        .globl aarch64_atomic_cmpxchg_8_release_default_impl\n+        .align 5\n+aarch64_atomic_cmpxchg_8_release_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldxr    x3, [x0]\n+        cmp     x3, x1\n+        b.ne    1f\n+        stlxr   w8, x2, [x0]\n+        cbnz    w8, 0b\n+1:      mov     x0, x3\n+        ret\n+\n+        .globl aarch64_atomic_cmpxchg_4_seq_cst_default_impl\n+        .align 5\n+aarch64_atomic_cmpxchg_4_seq_cst_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldaxr   w3, [x0]\n+        cmp     w3, w1\n+        b.ne    1f\n+        stlxr   w8, w2, [x0]\n+        cbnz    w8, 0b\n+1:      mov     w0, w3\n+        ret\n+\n+        .globl aarch64_atomic_cmpxchg_8_seq_cst_default_impl\n+        .align 5\n+aarch64_atomic_cmpxchg_8_seq_cst_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldaxr   x3, [x0]\n+        cmp     x3, x1\n+        b.ne    1f\n+        stlxr   w8, x2, [x0]\n+        cbnz    w8, 0b\n+1:      mov     x0, x3\n+        ret\n+\n+.globl aarch64_atomic_cmpxchg_1_relaxed_default_impl\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.S","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -154,0 +154,5 @@\n+  case memory_order_release:\n+    stub = aarch64_atomic_cmpxchg_4_release_impl; break;\n+  case memory_order_acq_rel:\n+  case memory_order_seq_cst:\n+    stub = aarch64_atomic_cmpxchg_4_seq_cst_impl; break;\n@@ -172,0 +177,5 @@\n+  case memory_order_release:\n+    stub = aarch64_atomic_cmpxchg_8_release_impl; break;\n+  case memory_order_acq_rel:\n+  case memory_order_seq_cst:\n+    stub = aarch64_atomic_cmpxchg_8_seq_cst_impl; break;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-  AD.addInclude(AD._CPP_file, \"runtime\/biasedLocking.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1529,1 +1529,0 @@\n-        fprintf(fp, \"  ((MachFastLockNode*)n%d)->_counters = _counters;\\n\", cnt);\n@@ -3944,1 +3943,0 @@\n-    fprintf(fp_cpp, \"%s node->_counters = _leaf->as_FastLock()->counters();\\n\", indent);\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,37 +48,0 @@\n-\n-\/\/\n-\/\/ Macros for use in defining Register instances.  We'd like to be\n-\/\/ able to simply define const instances of the RegisterImpl* for each\n-\/\/ of the registers needed on a system in a header file.  However many\n-\/\/ compilers don't handle this very well and end up producing a\n-\/\/ private definition in every file which includes the header file.\n-\/\/ Along with the static constructors necessary for initialization it\n-\/\/ can consume a significant amount of space in the result library.\n-\/\/\n-\/\/ The following macros allow us to declare the instance in a .hpp and\n-\/\/ produce an enumeration value which has the same number.  Then in a\n-\/\/ .cpp the the register instance can be defined using the enumeration\n-\/\/ value.  This avoids the use of static constructors and multiple\n-\/\/ definitions per .cpp.  In addition #defines for the register can be\n-\/\/ produced so that the constant registers can be inlined.  These\n-\/\/ macros should not be used inside other macros, because you may get\n-\/\/ multiple evaluations of the macros which can give bad results.\n-\/\/\n-\/\/ Here are some example uses and expansions.  Note that the macro\n-\/\/ invocation is terminated with a ;.\n-\/\/\n-\/\/ CONSTANT_REGISTER_DECLARATION(Register, G0, 0);\n-\/\/\n-\/\/ extern const Register G0 ;\n-\/\/ enum { G0_RegisterEnumValue = 0 } ;\n-\/\/\n-\/\/ REGISTER_DECLARATION(Register, Gmethod, G5);\n-\/\/\n-\/\/ extern const Register Gmethod ;\n-\/\/ enum { Gmethod_RegisterEnumValue = G5_RegisterEnumValue } ;\n-\/\/\n-\/\/ REGISTER_DEFINITION(Register, G0);\n-\/\/\n-\/\/ const Register G0 = ( ( Register ) G0_RegisterEnumValue ) ;\n-\/\/\n-\n@@ -87,2 +50,2 @@\n-#define CONSTANT_REGISTER_DECLARATION(type, name, value) \\\n-extern const type name;                                  \\\n+#define CONSTANT_REGISTER_DECLARATION(type, name, value)        \\\n+const type name = ((type)value);                                \\\n@@ -91,3 +54,2 @@\n-#define REGISTER_DECLARATION(type, name, value) \\\n-extern const type name;                         \\\n-enum { name##_##type##EnumValue = value##_##type##EnumValue }\n+#define REGISTER_DECLARATION(type, name, value)                 \\\n+const type name = ((type)value)\n@@ -95,2 +57,1 @@\n-#define REGISTER_DEFINITION(type, name) \\\n-const type name = ((type)name##_##type##EnumValue)\n+#define REGISTER_DEFINITION(type, name)\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":6,"deletions":45,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -210,1 +210,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -488,16 +488,0 @@\n-\n-void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {\n-  CodeStub* stub = new RangeCheckStub(info, index);\n-  if (index->is_constant()) {\n-    cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index->as_jint(), info);\n-    __ branch(lir_cond_belowEqual, stub); \/\/ forward branch\n-  } else {\n-    cmp_reg_mem(lir_cond_aboveEqual, index, buffer,\n-                java_nio_Buffer::limit_offset(), T_INT, info);\n-    __ branch(lir_cond_aboveEqual, stub); \/\/ forward branch\n-  }\n-  __ move(index, result);\n-}\n-\n-\n-\n@@ -1862,0 +1846,6 @@\n+\/\/ int\/long jdk.internal.util.Preconditions.checkIndex\n+void LIRGenerator::do_PreconditionsCheckIndex(Intrinsic* x, BasicType type) {\n+  assert(x->number_of_arguments() == 3, \"wrong type\");\n+  LIRItem index(x->argument_at(0), this);\n+  LIRItem length(x->argument_at(1), this);\n+  LIRItem oobef(x->argument_at(2), this);\n@@ -1863,11 +1853,0 @@\n-\/\/------------------------java.nio.Buffer.checkIndex------------------------\n-\n-\/\/ int java.nio.Buffer.checkIndex(int)\n-void LIRGenerator::do_NIOCheckIndex(Intrinsic* x) {\n-  \/\/ NOTE: by the time we are in checkIndex() we are guaranteed that\n-  \/\/ the buffer is non-null (because checkIndex is package-private and\n-  \/\/ only called from within other methods in the buffer).\n-  assert(x->number_of_arguments() == 2, \"wrong type\");\n-  LIRItem buf  (x->argument_at(0), this);\n-  LIRItem index(x->argument_at(1), this);\n-  buf.load_item();\n@@ -1875,0 +1854,2 @@\n+  length.load_item();\n+  oobef.load_item();\n@@ -1877,10 +1858,15 @@\n-  if (GenerateRangeChecks) {\n-    CodeEmitInfo* info = state_for(x);\n-    CodeStub* stub = new RangeCheckStub(info, index.result());\n-    if (index.result()->is_constant()) {\n-      cmp_mem_int(lir_cond_belowEqual, buf.result(), java_nio_Buffer::limit_offset(), index.result()->as_jint(), info);\n-      __ branch(lir_cond_belowEqual, stub);\n-    } else {\n-      cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf.result(),\n-                  java_nio_Buffer::limit_offset(), T_INT, info);\n-      __ branch(lir_cond_aboveEqual, stub);\n+  \/\/ x->state() is created from copy_state_for_exception, it does not contains arguments\n+  \/\/ we should prepare them before entering into interpreter mode due to deoptimization.\n+  ValueStack* state = x->state();\n+  for (int i = 0; i < x->number_of_arguments(); i++) {\n+    Value arg = x->argument_at(i);\n+    state->push(arg->type(), arg);\n+  }\n+  CodeEmitInfo* info = state_for(x, state);\n+\n+  LIR_Opr len = length.result();\n+  LIR_Opr zero = NULL;\n+  if (type == T_INT) {\n+    zero = LIR_OprFact::intConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::intConst(length.result()->as_jint());\n@@ -1888,1 +1874,0 @@\n-    __ move(index.result(), result);\n@@ -1890,3 +1875,34 @@\n-    \/\/ Just load the index into the result register\n-    __ move(index.result(), result);\n-  }\n+    assert(type == T_LONG, \"sanity check\");\n+    zero = LIR_OprFact::longConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::longConst(length.result()->as_jlong());\n+    }\n+  }\n+  \/\/ C1 can not handle the case that comparing index with constant value while condition\n+  \/\/ is neither lir_cond_equal nor lir_cond_notEqual, see LIR_Assembler::comp_op.\n+  LIR_Opr zero_reg = new_register(type);\n+  __ move(zero, zero_reg);\n+#if defined(X86) && !defined(_LP64)\n+  \/\/ BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.\n+  LIR_Opr index_copy = new_register(index.type());\n+  \/\/ index >= 0\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_less, index_copy, zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_greaterEqual, index_copy, len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#else\n+  \/\/ index >= 0\n+  __ cmp(lir_cond_less, index.result(), zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ cmp(lir_cond_greaterEqual, index.result(), len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#endif\n+  __ move(index.result(), result);\n@@ -1895,1 +1911,0 @@\n-\n@@ -3118,2 +3133,6 @@\n-  \/\/ java.nio.Buffer.checkIndex\n-  case vmIntrinsics::_checkIndex:     do_NIOCheckIndex(x); break;\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+    do_PreconditionsCheckIndex(x, T_INT);\n+    break;\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n+    do_PreconditionsCheckIndex(x, T_LONG);\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":63,"deletions":44,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  void do_NIOCheckIndex(Intrinsic* x);\n+  void do_PreconditionsCheckIndex(Intrinsic* x, BasicType type);\n@@ -351,2 +351,0 @@\n-  \/\/ For java.nio.Buffer.checkIndex\n-  void nio_range_check            (LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -351,2 +350,5 @@\n-  NOT_PRODUCT(_new_instance_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_instance_slowcase_cnt++;\n+  }\n+#endif\n@@ -366,1 +368,5 @@\n-  NOT_PRODUCT(_new_type_array_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_type_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -384,2 +390,5 @@\n-  NOT_PRODUCT(_new_object_array_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_object_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -403,2 +412,5 @@\n-  NOT_PRODUCT(_new_multi_array_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_multi_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -656,1 +668,5 @@\n-  NOT_PRODUCT(_throw_range_check_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_range_check_exception_count++;\n+  }\n+#endif\n@@ -666,1 +682,5 @@\n-  NOT_PRODUCT(_throw_index_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_index_exception_count++;\n+  }\n+#endif\n@@ -674,1 +694,5 @@\n-  NOT_PRODUCT(_throw_div0_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_div0_exception_count++;\n+  }\n+#endif\n@@ -680,1 +704,5 @@\n-  NOT_PRODUCT(_throw_null_pointer_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_null_pointer_exception_count++;\n+  }\n+#endif\n@@ -686,1 +714,5 @@\n-  NOT_PRODUCT(_throw_class_cast_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_class_cast_exception_count++;\n+  }\n+#endif\n@@ -694,1 +726,5 @@\n-  NOT_PRODUCT(_throw_incompatible_class_change_error_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_incompatible_class_change_error_count++;\n+  }\n+#endif\n@@ -701,1 +737,5 @@\n-  NOT_PRODUCT(_monitorenter_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _monitorenter_slowcase_cnt++;\n+  }\n+#endif\n@@ -711,1 +751,5 @@\n-  NOT_PRODUCT(_monitorexit_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _monitorexit_slowcase_cnt++;\n+  }\n+#endif\n@@ -863,1 +907,5 @@\n-  NOT_PRODUCT(_patch_code_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _patch_code_slowcase_cnt++;\n+  }\n+#endif\n@@ -1258,1 +1306,5 @@\n-  NOT_PRODUCT(_patch_code_slowcase_cnt++);\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _patch_code_slowcase_cnt++;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":70,"deletions":18,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -156,3 +156,0 @@\n-  product(bool, InlineNIOCheckIndex, true, DIAGNOSTIC,                      \\\n-          \"Intrinsify java.nio.Buffer.checkIndex\")                          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-    \/\/ See RunTimeSharedClassInfo::get_for()\n+    \/\/ See RunTimeClassInfo::get_for()\n@@ -322,1 +322,1 @@\n-  \/\/ size of the symbol table and two dictionaries, plus the RunTimeSharedClassInfo's\n+  \/\/ size of the symbol table and two dictionaries, plus the RunTimeClassInfo's\n@@ -635,2 +635,2 @@\n-    \/\/ we can do a quick lookup from InstanceKlass* -> RunTimeSharedClassInfo*\n-    \/\/ without building another hashtable. See RunTimeSharedClassInfo::get_for()\n+    \/\/ we can do a quick lookup from InstanceKlass* -> RunTimeClassInfo*\n+    \/\/ without building another hashtable. See RunTimeClassInfo::get_for()\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/cdsProtectionDomain.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderExt.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+\n+OopHandle CDSProtectionDomain::_shared_protection_domains;\n+OopHandle CDSProtectionDomain::_shared_jar_urls;\n+OopHandle CDSProtectionDomain::_shared_jar_manifests;\n+\n+\/\/ Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with\n+\/\/ the given InstanceKlass.\n+\/\/ Returns the ProtectionDomain for the InstanceKlass.\n+Handle CDSProtectionDomain::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {\n+  Handle pd;\n+\n+  if (ik != NULL) {\n+    int index = ik->shared_classpath_index();\n+    assert(index >= 0, \"Sanity\");\n+    SharedClassPathEntry* ent = FileMapInfo::shared_path(index);\n+    Symbol* class_name = ik->name();\n+\n+    if (ent->is_modules_image()) {\n+      \/\/ For shared app\/platform classes originated from the run-time image:\n+      \/\/   The ProtectionDomains are cached in the corresponding ModuleEntries\n+      \/\/   for fast access by the VM.\n+      \/\/ all packages from module image are already created during VM bootstrap in\n+      \/\/ Modules::define_module().\n+      assert(pkg_entry != NULL, \"archived class in module image cannot be from unnamed package\");\n+      ModuleEntry* mod_entry = pkg_entry->module();\n+      pd = get_shared_protection_domain(class_loader, mod_entry, CHECK_(pd));\n+    } else {\n+      \/\/ For shared app\/platform classes originated from JAR files on the class path:\n+      \/\/   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length\n+      \/\/   as the shared classpath table in the shared archive (see\n+      \/\/   FileMap::_shared_path_table in filemap.hpp for details).\n+      \/\/\n+      \/\/   If a shared InstanceKlass k is loaded from the class path, let\n+      \/\/\n+      \/\/     index = k->shared_classpath_index():\n+      \/\/\n+      \/\/   FileMap::_shared_path_table[index] identifies the JAR file that contains k.\n+      \/\/\n+      \/\/   k's protection domain is:\n+      \/\/\n+      \/\/     ProtectionDomain pd = _shared_protection_domains[index];\n+      \/\/\n+      \/\/   and k's Package is initialized using\n+      \/\/\n+      \/\/     manifest = _shared_jar_manifests[index];\n+      \/\/     url = _shared_jar_urls[index];\n+      \/\/     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+      \/\/\n+      \/\/   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by\n+      \/\/   the corresponding SystemDictionaryShared::get_shared_xxx() function.\n+      Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));\n+      Handle url = get_shared_jar_url(index, CHECK_(pd));\n+      int index_offset = index - ClassLoaderExt::app_class_paths_start_index();\n+      if (index_offset < PackageEntry::max_index_for_defined_in_class_path()) {\n+        if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n+          \/\/ define_shared_package only needs to be called once for each package in a jar specified\n+          \/\/ in the shared class path.\n+          define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+          if (pkg_entry != NULL) {\n+            pkg_entry->set_defined_by_cds_in_class_path(index_offset);\n+          }\n+        }\n+      } else {\n+        define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+      }\n+      pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));\n+    }\n+  }\n+  return pd;\n+}\n+\n+Handle CDSProtectionDomain::get_package_name(Symbol* class_name, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Handle pkgname_string;\n+  TempNewSymbol pkg = ClassLoader::package_from_class_name(class_name);\n+  if (pkg != NULL) { \/\/ Package prefix found\n+    const char* pkgname = pkg->as_klass_external_name();\n+    pkgname_string = java_lang_String::create_from_str(pkgname,\n+                                                       CHECK_(pkgname_string));\n+  }\n+  return pkgname_string;\n+}\n+\n+PackageEntry* CDSProtectionDomain::get_package_entry_from_class(InstanceKlass* ik, Handle class_loader) {\n+  PackageEntry* pkg_entry = ik->package();\n+  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != NULL) {\n+    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n+    assert(!ik->is_shared_unregistered_class(), \"unexpected archived package entry for an unregistered class\");\n+    assert(ik->module()->is_named(), \"unexpected archived package entry for a class in an unnamed module\");\n+    return pkg_entry;\n+  }\n+  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(ik->name());\n+  if (pkg_name != NULL) {\n+    pkg_entry = SystemDictionaryShared::class_loader_data(class_loader)->packages()->lookup_only(pkg_name);\n+  } else {\n+    pkg_entry = NULL;\n+  }\n+  return pkg_entry;\n+}\n+\n+\/\/ Define Package for shared app classes from JAR file and also checks for\n+\/\/ package sealing (all done in Java code)\n+\/\/ See http:\/\/docs.oracle.com\/javase\/tutorial\/deployment\/jar\/sealman.html\n+void CDSProtectionDomain::define_shared_package(Symbol*  class_name,\n+                                                   Handle class_loader,\n+                                                   Handle manifest,\n+                                                   Handle url,\n+                                                   TRAPS) {\n+  assert(SystemDictionary::is_system_class_loader(class_loader()), \"unexpected class loader\");\n+  \/\/ get_package_name() returns a NULL handle if the class is in unnamed package\n+  Handle pkgname_string = get_package_name(class_name, CHECK);\n+  if (pkgname_string.not_null()) {\n+    Klass* app_classLoader_klass = vmClasses::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();\n+    JavaValue result(T_OBJECT);\n+    JavaCallArguments args(3);\n+    args.set_receiver(class_loader);\n+    args.push_oop(pkgname_string);\n+    args.push_oop(manifest);\n+    args.push_oop(url);\n+    JavaCalls::call_virtual(&result, app_classLoader_klass,\n+                            vmSymbols::defineOrCheckPackage_name(),\n+                            vmSymbols::defineOrCheckPackage_signature(),\n+                            &args,\n+                            CHECK);\n+  }\n+}\n+\n+Handle CDSProtectionDomain::create_jar_manifest(const char* manifest_chars, size_t size, TRAPS) {\n+  typeArrayOop buf = oopFactory::new_byteArray((int)size, CHECK_NH);\n+  typeArrayHandle bufhandle(THREAD, buf);\n+  ArrayAccess<>::arraycopy_from_native(reinterpret_cast<const jbyte*>(manifest_chars),\n+                                         buf, typeArrayOopDesc::element_offset<jbyte>(0), size);\n+  Handle bais = JavaCalls::construct_new_instance(vmClasses::ByteArrayInputStream_klass(),\n+                      vmSymbols::byte_array_void_signature(),\n+                      bufhandle, CHECK_NH);\n+  \/\/ manifest = new Manifest(ByteArrayInputStream)\n+  Handle manifest = JavaCalls::construct_new_instance(vmClasses::Jar_Manifest_klass(),\n+                      vmSymbols::input_stream_void_signature(),\n+                      bais, CHECK_NH);\n+  return manifest;\n+}\n+\n+Handle CDSProtectionDomain::get_shared_jar_manifest(int shared_path_index, TRAPS) {\n+  Handle manifest;\n+  if (shared_jar_manifest(shared_path_index) == NULL) {\n+    SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);\n+    size_t size = (size_t)ent->manifest_size();\n+    if (size == 0) {\n+      return Handle();\n+    }\n+\n+    \/\/ ByteArrayInputStream bais = new ByteArrayInputStream(buf);\n+    const char* src = ent->manifest();\n+    assert(src != NULL, \"No Manifest data\");\n+    manifest = create_jar_manifest(src, size, CHECK_NH);\n+    atomic_set_shared_jar_manifest(shared_path_index, manifest());\n+  }\n+  manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));\n+  assert(manifest.not_null(), \"sanity\");\n+  return manifest;\n+}\n+\n+Handle CDSProtectionDomain::get_shared_jar_url(int shared_path_index, TRAPS) {\n+  Handle url_h;\n+  if (shared_jar_url(shared_path_index) == NULL) {\n+    JavaValue result(T_OBJECT);\n+    const char* path = FileMapInfo::shared_path_name(shared_path_index);\n+    Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));\n+    Klass* classLoaders_klass =\n+        vmClasses::jdk_internal_loader_ClassLoaders_klass();\n+    JavaCalls::call_static(&result, classLoaders_klass,\n+                           vmSymbols::toFileURL_name(),\n+                           vmSymbols::toFileURL_signature(),\n+                           path_string, CHECK_(url_h));\n+\n+    atomic_set_shared_jar_url(shared_path_index, result.get_oop());\n+  }\n+\n+  url_h = Handle(THREAD, shared_jar_url(shared_path_index));\n+  assert(url_h.not_null(), \"sanity\");\n+  return url_h;\n+}\n+\n+\/\/ Get the ProtectionDomain associated with the CodeSource from the classloader.\n+Handle CDSProtectionDomain::get_protection_domain_from_classloader(Handle class_loader,\n+                                                                      Handle url, TRAPS) {\n+  \/\/ CodeSource cs = new CodeSource(url, null);\n+  Handle cs = JavaCalls::construct_new_instance(vmClasses::CodeSource_klass(),\n+                  vmSymbols::url_code_signer_array_void_signature(),\n+                  url, Handle(), CHECK_NH);\n+\n+  \/\/ protection_domain = SecureClassLoader.getProtectionDomain(cs);\n+  Klass* secureClassLoader_klass = vmClasses::SecureClassLoader_klass();\n+  JavaValue obj_result(T_OBJECT);\n+  JavaCalls::call_virtual(&obj_result, class_loader, secureClassLoader_klass,\n+                          vmSymbols::getProtectionDomain_name(),\n+                          vmSymbols::getProtectionDomain_signature(),\n+                          cs, CHECK_NH);\n+  return Handle(THREAD, obj_result.get_oop());\n+}\n+\n+\/\/ Returns the ProtectionDomain associated with the JAR file identified by the url.\n+Handle CDSProtectionDomain::get_shared_protection_domain(Handle class_loader,\n+                                                            int shared_path_index,\n+                                                            Handle url,\n+                                                            TRAPS) {\n+  Handle protection_domain;\n+  if (shared_protection_domain(shared_path_index) == NULL) {\n+    Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);\n+    atomic_set_shared_protection_domain(shared_path_index, pd());\n+  }\n+\n+  \/\/ Acquire from the cache because if another thread beats the current one to\n+  \/\/ set the shared protection_domain and the atomic_set fails, the current thread\n+  \/\/ needs to get the updated protection_domain from the cache.\n+  protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));\n+  assert(protection_domain.not_null(), \"sanity\");\n+  return protection_domain;\n+}\n+\n+\/\/ Returns the ProtectionDomain associated with the moduleEntry.\n+Handle CDSProtectionDomain::get_shared_protection_domain(Handle class_loader,\n+                                                         ModuleEntry* mod, TRAPS) {\n+  ClassLoaderData *loader_data = mod->loader_data();\n+  if (mod->shared_protection_domain() == NULL) {\n+    Symbol* location = mod->location();\n+    if (location != NULL) {\n+      Handle location_string = java_lang_String::create_from_symbol(\n+                                     location, CHECK_NH);\n+      Handle url;\n+      JavaValue result(T_OBJECT);\n+      if (location->starts_with(\"jrt:\/\")) {\n+        url = JavaCalls::construct_new_instance(vmClasses::URL_klass(),\n+                                                vmSymbols::string_void_signature(),\n+                                                location_string, CHECK_NH);\n+      } else {\n+        Klass* classLoaders_klass =\n+          vmClasses::jdk_internal_loader_ClassLoaders_klass();\n+        JavaCalls::call_static(&result, classLoaders_klass, vmSymbols::toFileURL_name(),\n+                               vmSymbols::toFileURL_signature(),\n+                               location_string, CHECK_NH);\n+        url = Handle(THREAD, result.get_oop());\n+      }\n+\n+      Handle pd = get_protection_domain_from_classloader(class_loader, url,\n+                                                         CHECK_NH);\n+      mod->set_shared_protection_domain(loader_data, pd);\n+    }\n+  }\n+\n+  Handle protection_domain(THREAD, mod->shared_protection_domain());\n+  assert(protection_domain.not_null(), \"sanity\");\n+  return protection_domain;\n+}\n+\n+void CDSProtectionDomain::atomic_set_array_index(OopHandle array, int index, oop o) {\n+  \/\/ Benign race condition:  array.obj_at(index) may already be filled in.\n+  \/\/ The important thing here is that all threads pick up the same result.\n+  \/\/ It doesn't matter which racing thread wins, as long as only one\n+  \/\/ result is used by all threads, and all future queries.\n+  ((objArrayOop)array.resolve())->atomic_compare_exchange_oop(index, o, NULL);\n+}\n+\n+oop CDSProtectionDomain::shared_protection_domain(int index) {\n+  return ((objArrayOop)_shared_protection_domains.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_protection_domain_array(int size, TRAPS) {\n+  if (_shared_protection_domains.resolve() == NULL) {\n+    oop spd = oopFactory::new_objArray(\n+        vmClasses::ProtectionDomain_klass(), size, CHECK);\n+    _shared_protection_domains = OopHandle(Universe::vm_global(), spd);\n+  }\n+}\n+\n+oop CDSProtectionDomain::shared_jar_url(int index) {\n+  return ((objArrayOop)_shared_jar_urls.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_jar_url_array(int size, TRAPS) {\n+  if (_shared_jar_urls.resolve() == NULL) {\n+    oop sju = oopFactory::new_objArray(\n+        vmClasses::URL_klass(), size, CHECK);\n+    _shared_jar_urls = OopHandle(Universe::vm_global(), sju);\n+  }\n+}\n+\n+oop CDSProtectionDomain::shared_jar_manifest(int index) {\n+  return ((objArrayOop)_shared_jar_manifests.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_jar_manifest_array(int size, TRAPS) {\n+  if (_shared_jar_manifests.resolve() == NULL) {\n+    oop sjm = oopFactory::new_objArray(\n+        vmClasses::Jar_Manifest_klass(), size, CHECK);\n+    _shared_jar_manifests = OopHandle(Universe::vm_global(), sjm);\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n+#define SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+\n+class InstanceKlass;\n+class Symbol;\n+class PackageEntry;\n+class ModuleEntry;\n+\n+\/\/ CDS security\n+class CDSProtectionDomain : AllStatic {\n+  \/\/ See init_security_info for more info.\n+  static OopHandle _shared_protection_domains;\n+  static OopHandle _shared_jar_urls;\n+  static OopHandle _shared_jar_manifests;\n+\n+public:\n+  \/\/ Package handling:\n+  \/\/\n+  \/\/ 1. For named modules in the runtime image\n+  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces\n+  \/\/                  to get packages in named modules for shared classes.\n+  \/\/                  Package for non-shared classes in named module is also\n+  \/\/                  handled using JVM_GetSystemPackage(s).\n+  \/\/\n+  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::definePackage(String, Module)\n+  \/\/                  to define package for shared app classes from named\n+  \/\/                  modules.\n+  \/\/\n+  \/\/    PLATFORM  classes: VM calls ClassLoaders.PlatformClassLoader::definePackage(String, Module)\n+  \/\/                  to define package for shared platform classes from named\n+  \/\/                  modules.\n+  \/\/\n+  \/\/ 2. For unnamed modules\n+  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces to\n+  \/\/                  get packages for shared boot classes in unnamed modules.\n+  \/\/\n+  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::defineOrCheckPackage()\n+  \/\/                  with with the manifest and url from archived data.\n+  \/\/\n+  \/\/    PLATFORM  classes: No package is defined.\n+  \/\/\n+  \/\/ The following two define_shared_package() functions are used to define\n+  \/\/ package for shared APP and PLATFORM classes.\n+  static Handle        get_package_name(Symbol*  class_name, TRAPS);\n+  static PackageEntry* get_package_entry_from_class(InstanceKlass* ik, Handle class_loader);\n+  static void define_shared_package(Symbol*  class_name,\n+                                    Handle class_loader,\n+                                    Handle manifest,\n+                                    Handle url,\n+                                    TRAPS);\n+  static Handle create_jar_manifest(const char* man, size_t size, TRAPS);\n+  static Handle get_shared_jar_manifest(int shared_path_index, TRAPS);\n+  static Handle get_shared_jar_url(int shared_path_index, TRAPS);\n+  static Handle get_protection_domain_from_classloader(Handle class_loader,\n+                                                       Handle url, TRAPS);\n+  static Handle get_shared_protection_domain(Handle class_loader,\n+                                             int shared_path_index,\n+                                             Handle url,\n+                                             TRAPS);\n+  static Handle get_shared_protection_domain(Handle class_loader,\n+                                             ModuleEntry* mod, TRAPS);\n+  static void atomic_set_array_index(OopHandle array, int index, oop o);\n+  static oop shared_protection_domain(int index);\n+  static void allocate_shared_protection_domain_array(int size, TRAPS);\n+  static oop shared_jar_url(int index);\n+  static void allocate_shared_jar_url_array(int size, TRAPS);\n+  static oop shared_jar_manifest(int index);\n+  static void allocate_shared_jar_manifest_array(int size, TRAPS);\n+  static Handle init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS);\n+\n+  static void allocate_shared_data_arrays(int size, TRAPS) {\n+    allocate_shared_protection_domain_array(size, CHECK);\n+    allocate_shared_jar_url_array(size, CHECK);\n+    allocate_shared_jar_manifest_array(size, CHECK);\n+  }\n+  static void atomic_set_shared_protection_domain(int index, oop pd) {\n+    atomic_set_array_index(_shared_protection_domains, index, pd);\n+  }\n+  static void atomic_set_shared_jar_url(int index, oop url) {\n+    atomic_set_array_index(_shared_jar_urls, index, url);\n+  }\n+  static void atomic_set_shared_jar_manifest(int index, oop man) {\n+    atomic_set_array_index(_shared_jar_manifests, index, man);\n+  }\n+};\n+\n+#endif \/\/ SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -88,1 +88,1 @@\n-  if (_file) {\n+  if (_file != NULL) {\n@@ -92,0 +92,2 @@\n+  delete _indy_items;\n+  delete _interfaces;\n@@ -467,1 +469,1 @@\n-  bool added = SystemDictionaryShared::add_unregistered_class(THREAD, k);\n+  bool added = SystemDictionaryShared::add_unregistered_class_for_static_archive(THREAD, k);\n@@ -615,1 +617,0 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);\n@@ -617,1 +618,1 @@\n-    Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle ext_class_name = java_lang_String::externalize_classname(class_name_symbol, CHECK_NULL);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+\n+void DumpTimeClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n+         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {\n+  if (_verifier_constraints == NULL) {\n+    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n+  }\n+  if (_verifier_constraint_flags == NULL) {\n+    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n+  }\n+  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n+  for (int i = 0; i < vc_array->length(); i++) {\n+    DTVerifierConstraint* p = vc_array->adr_at(i);\n+    if (name == p->_name && from_name == p->_from_name) {\n+      return;\n+    }\n+  }\n+  DTVerifierConstraint cons(name, from_name);\n+  vc_array->append(cons);\n+\n+  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n+  char c = 0;\n+  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n+  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n+  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n+  vcflags_array->append(c);\n+\n+  if (log_is_enabled(Trace, cds, verification)) {\n+    ResourceMark rm;\n+    log_trace(cds, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n+                                 k->external_name(), from_name->as_klass_external_name(),\n+                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+  }\n+}\n+\n+static char get_loader_type_by(oop  loader) {\n+  assert(SystemDictionary::is_builtin_class_loader(loader), \"Must be built-in loader\");\n+  if (SystemDictionary::is_boot_class_loader(loader)) {\n+    return (char)ClassLoader::BOOT_LOADER;\n+  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+    return (char)ClassLoader::PLATFORM_LOADER;\n+  } else {\n+    assert(SystemDictionary::is_system_class_loader(loader), \"Class loader mismatch\");\n+    return (char)ClassLoader::APP_LOADER;\n+  }\n+}\n+\n+void DumpTimeClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {\n+  assert(loader1 != loader2, \"sanity\");\n+  LogTarget(Info, class, loader, constraints) log;\n+  if (_loader_constraints == NULL) {\n+    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n+  }\n+  char lt1 = get_loader_type_by(loader1());\n+  char lt2 = get_loader_type_by(loader2());\n+  DTLoaderConstraint lc(name, lt1, lt2);\n+  for (int i = 0; i < _loader_constraints->length(); i++) {\n+    DTLoaderConstraint dt = _loader_constraints->at(i);\n+    if (lc.equals(dt)) {\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n+        log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]\",\n+                  _klass->external_name(), name->as_C_string(),\n+                  ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n+                  ClassLoaderData::class_loader_data(loader2())->loader_name_and_id());\n+      }\n+      return;\n+    }\n+  }\n+  _loader_constraints->append(lc);\n+  if (log.is_enabled()) {\n+    ResourceMark rm;\n+    \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n+    log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]\",\n+              _klass->external_name(), name->as_C_string(),\n+              ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n+              ClassLoaderData::class_loader_data(loader2())->loader_name_and_id(),\n+              _loader_constraints->length());\n+  }\n+}\n+\n+bool DumpTimeClassInfo::is_builtin() {\n+  return SystemDictionaryShared::is_builtin(_klass);\n+}\n+\n+DumpTimeClassInfo* DumpTimeSharedClassTable::find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress) {\n+  bool created = false;\n+  DumpTimeClassInfo* p;\n+  if (!dump_in_progress) {\n+    p = put_if_absent(k, &created);\n+  } else {\n+    p = get(k);\n+  }\n+  if (created) {\n+    assert(!SystemDictionaryShared::no_class_loading_should_happen(),\n+           \"no new classes can be loaded while dumping archive\");\n+    p->_klass = k;\n+  } else {\n+    if (!dump_in_progress) {\n+      assert(p->_klass == k, \"Sanity\");\n+    }\n+  }\n+  return p;\n+}\n+\n+class CountClassByCategory : StackObj {\n+  DumpTimeSharedClassTable* _table;\n+public:\n+  CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!info.is_excluded()) {\n+      if (info.is_builtin()) {\n+        _table->inc_builtin_count();\n+      } else {\n+        _table->inc_unregistered_count();\n+      }\n+    }\n+    return true; \/\/ keep on iterating\n+  }\n+};\n+\n+void DumpTimeSharedClassTable::update_counts() {\n+  _builtin_count = 0;\n+  _unregistered_count = 0;\n+  CountClassByCategory counter(this);\n+  iterate(&counter);\n+}\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n+#define SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/compactHashtable.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class Method;\n+class Symbol;\n+\n+class DumpTimeClassInfo: public CHeapObj<mtClass> {\n+  bool                         _excluded;\n+  bool                         _is_early_klass;\n+  bool                         _has_checked_exclusion;\n+public:\n+  struct DTLoaderConstraint {\n+    Symbol* _name;\n+    char _loader_type1;\n+    char _loader_type2;\n+    DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {\n+      _name->increment_refcount();\n+    }\n+    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n+    bool equals(const DTLoaderConstraint& t) {\n+      return t._name == _name &&\n+             ((t._loader_type1 == _loader_type1 && t._loader_type2 == _loader_type2) ||\n+              (t._loader_type2 == _loader_type1 && t._loader_type1 == _loader_type2));\n+    }\n+  };\n+\n+  struct DTVerifierConstraint {\n+    Symbol* _name;\n+    Symbol* _from_name;\n+    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n+    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n+      _name->increment_refcount();\n+      _from_name->increment_refcount();\n+    }\n+  };\n+\n+  InstanceKlass*               _klass;\n+  InstanceKlass*               _nest_host;\n+  bool                         _failed_verification;\n+  bool                         _is_archived_lambda_proxy;\n+  int                          _id;\n+  int                          _clsfile_size;\n+  int                          _clsfile_crc32;\n+  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n+  GrowableArray<char>*                 _verifier_constraint_flags;\n+  GrowableArray<DTLoaderConstraint>*   _loader_constraints;\n+\n+  DumpTimeClassInfo() {\n+    _klass = NULL;\n+    _nest_host = NULL;\n+    _failed_verification = false;\n+    _is_archived_lambda_proxy = false;\n+    _has_checked_exclusion = false;\n+    _id = -1;\n+    _clsfile_size = -1;\n+    _clsfile_crc32 = -1;\n+    _excluded = false;\n+    _is_early_klass = JvmtiExport::is_early_phase();\n+    _verifier_constraints = NULL;\n+    _verifier_constraint_flags = NULL;\n+    _loader_constraints = NULL;\n+  }\n+\n+  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n+         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n+  void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);\n+\n+  bool is_builtin();\n+\n+  int num_verifier_constraints() {\n+    if (_verifier_constraint_flags != NULL) {\n+      return _verifier_constraint_flags->length();\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  int num_loader_constraints() {\n+    if (_loader_constraints != NULL) {\n+      return _loader_constraints->length();\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_klass);\n+    it->push(&_nest_host);\n+    if (_verifier_constraints != NULL) {\n+      for (int i = 0; i < _verifier_constraints->length(); i++) {\n+        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n+        it->push(&cons->_name);\n+        it->push(&cons->_from_name);\n+      }\n+    }\n+    if (_loader_constraints != NULL) {\n+      for (int i = 0; i < _loader_constraints->length(); i++) {\n+        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n+        it->push(&lc->_name);\n+      }\n+    }\n+  }\n+\n+  bool is_excluded() {\n+    \/\/ _klass may become NULL due to DynamicArchiveBuilder::set_to_null\n+    return _excluded || _failed_verification || _klass == NULL;\n+  }\n+\n+  \/\/ Was this class loaded while JvmtiExport::is_early_phase()==true\n+  bool is_early_klass() {\n+    return _is_early_klass;\n+  }\n+\n+  \/\/ simple accessors\n+  void set_excluded()                               { _excluded = true; }\n+  bool has_checked_exclusion() const                { return _has_checked_exclusion; }\n+  void set_has_checked_exclusion()                  { _has_checked_exclusion = true; }\n+  bool failed_verification() const                  { return _failed_verification; }\n+  void set_failed_verification()                    { _failed_verification = true; }\n+  InstanceKlass* nest_host() const                  { return _nest_host; }\n+  void set_nest_host(InstanceKlass* nest_host)      { _nest_host = nest_host; }\n+};\n+\n+\n+inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n+  if (DumpSharedSpaces) {\n+    \/\/ Deterministic archive contents\n+    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n+    return primitive_hash<uintx>(delta);\n+  } else {\n+    \/\/ Deterministic archive is not possible because classes can be loaded\n+    \/\/ in multiple threads.\n+    return primitive_hash<InstanceKlass*>(k);\n+  }\n+}\n+\n+class DumpTimeSharedClassTable: public ResourceHashtable<\n+  InstanceKlass*,\n+  DumpTimeClassInfo,\n+  &DumpTimeSharedClassTable_hash,\n+  primitive_equals<InstanceKlass*>,\n+  15889, \/\/ prime number\n+  ResourceObj::C_HEAP>\n+{\n+  int _builtin_count;\n+  int _unregistered_count;\n+public:\n+  DumpTimeClassInfo* find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress);\n+  void inc_builtin_count()      { _builtin_count++; }\n+  void inc_unregistered_count() { _unregistered_count++; }\n+  void update_counts();\n+  int count_of(bool is_builtin) const {\n+    if (is_builtin) {\n+      return _builtin_count;\n+    } else {\n+      return _unregistered_count;\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -110,1 +110,0 @@\n-    SystemDictionaryShared::check_excluded_classes();\n@@ -112,0 +111,1 @@\n+    \/\/ Block concurrent class unloading from changing the _dumptime_table\n@@ -113,0 +113,2 @@\n+    SystemDictionaryShared::check_excluded_classes();\n+\n@@ -320,1 +322,1 @@\n-    if (SystemDictionaryShared::empty_dumptime_table()) {\n+    if (SystemDictionaryShared::is_dumptime_table_empty()) {\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -243,0 +244,1 @@\n+  _has_non_jar_in_classpath = ClassLoaderExt::has_non_jar_in_classpath();\n@@ -296,0 +298,1 @@\n+  st->print_cr(\"- has_non_jar_in_classpath:       %d\", _has_non_jar_in_classpath);\n@@ -720,1 +723,1 @@\n-\n+  JavaThread* current = JavaThread::current();\n@@ -722,0 +725,1 @@\n+  bool non_jar_in_cp = header()->has_non_jar_in_classpath();\n@@ -724,3 +728,14 @@\n-    struct stat st;\n-    if (os::stat(path, &st) == 0) {\n-      path_array->append(path);\n+    if (!non_jar_in_cp) {\n+      struct stat st;\n+      if (os::stat(path, &st) == 0) {\n+        path_array->append(path);\n+      }\n+    } else {\n+      const char* canonical_path = ClassLoader::get_canonical_path(path, current);\n+      if (canonical_path != NULL) {\n+        char* error_msg = NULL;\n+        jzfile* zip = ClassLoader::open_zip_file(canonical_path, &error_msg, current);\n+        if (zip != NULL && error_msg == NULL) {\n+          path_array->append(path);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+  bool _has_non_jar_in_classpath;   \/\/ non-jar file entry exists in classpath\n@@ -275,0 +276,1 @@\n+  bool has_non_jar_in_classpath()          const { return _has_non_jar_in_classpath; }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,2 +140,0 @@\n-  assert(!p->mark().has_bias_pattern(),\n-         \"this object should never have been locked\");  \/\/ so identity_hash won't safepoin\n@@ -419,5 +417,1 @@\n-    if (UseBiasedLocking) {\n-      oopDesc::set_mark(mem, k->prototype_header());\n-    } else {\n-      oopDesc::set_mark(mem, markWord::prototype());\n-    }\n+    oopDesc::set_mark(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+\n+void LambdaProxyClassKey::mark_pointers() {\n+  ArchivePtrMarker::mark_pointer(&_caller_ik);\n+  ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n+  ArchivePtrMarker::mark_pointer(&_invoked_name);\n+  ArchivePtrMarker::mark_pointer(&_invoked_type);\n+  ArchivePtrMarker::mark_pointer(&_member_method);\n+  ArchivePtrMarker::mark_pointer(&_method_type);\n+}\n+\n+unsigned int LambdaProxyClassKey::hash() const {\n+  return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n+}\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n+#define SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+class Symbol;\n+\n+class LambdaProxyClassKey {\n+  InstanceKlass* _caller_ik;\n+  Symbol*        _invoked_name;\n+  Symbol*        _invoked_type;\n+  Symbol*        _method_type;\n+  Method*        _member_method;\n+  Symbol*        _instantiated_method_type;\n+\n+public:\n+  LambdaProxyClassKey(InstanceKlass* caller_ik,\n+                      Symbol*        invoked_name,\n+                      Symbol*        invoked_type,\n+                      Symbol*        method_type,\n+                      Method*        member_method,\n+                      Symbol*        instantiated_method_type) :\n+    _caller_ik(caller_ik),\n+    _invoked_name(invoked_name),\n+    _invoked_type(invoked_type),\n+    _method_type(method_type),\n+    _member_method(member_method),\n+    _instantiated_method_type(instantiated_method_type) {}\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_caller_ik);\n+    it->push(&_invoked_name);\n+    it->push(&_invoked_type);\n+    it->push(&_method_type);\n+    it->push(&_member_method);\n+    it->push(&_instantiated_method_type);\n+  }\n+\n+  bool equals(LambdaProxyClassKey const& other) const {\n+    return _caller_ik == other._caller_ik &&\n+           _invoked_name == other._invoked_name &&\n+           _invoked_type == other._invoked_type &&\n+           _method_type == other._method_type &&\n+           _member_method == other._member_method &&\n+           _instantiated_method_type == other._instantiated_method_type;\n+  }\n+\n+  void mark_pointers();\n+  unsigned int hash() const;\n+\n+  static unsigned int dumptime_hash(Symbol* sym)  {\n+    if (sym == NULL) {\n+      \/\/ _invoked_name maybe NULL\n+      return 0;\n+    }\n+    return java_lang_String::hash_code((const jbyte*)sym->bytes(), sym->utf8_length());\n+  }\n+\n+  unsigned int dumptime_hash() const {\n+    return dumptime_hash(_caller_ik->name()) +\n+           dumptime_hash(_invoked_name) +\n+           dumptime_hash(_invoked_type) +\n+           dumptime_hash(_method_type) +\n+           dumptime_hash(_instantiated_method_type);\n+  }\n+\n+  static inline unsigned int DUMPTIME_HASH(LambdaProxyClassKey const& key) {\n+    return (key.dumptime_hash());\n+  }\n+\n+  static inline bool DUMPTIME_EQUALS(\n+      LambdaProxyClassKey const& k1, LambdaProxyClassKey const& k2) {\n+    return (k1.equals(k2));\n+  }\n+\n+  InstanceKlass* caller_ik() const { return _caller_ik; }\n+};\n+\n+class DumpTimeLambdaProxyClassInfo {\n+public:\n+  GrowableArray<InstanceKlass*>* _proxy_klasses;\n+  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}\n+  void add_proxy_klass(InstanceKlass* proxy_klass) {\n+    if (_proxy_klasses == NULL) {\n+      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<InstanceKlass*>(5, mtClassShared);\n+    }\n+    assert(_proxy_klasses != NULL, \"sanity\");\n+    _proxy_klasses->append(proxy_klass);\n+  }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    for (int i=0; i<_proxy_klasses->length(); i++) {\n+      it->push(_proxy_klasses->adr_at(i));\n+    }\n+  }\n+};\n+\n+class RunTimeLambdaProxyClassInfo {\n+  LambdaProxyClassKey _key;\n+  InstanceKlass* _proxy_klass_head;\n+public:\n+  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n+    _key(key), _proxy_klass_head(proxy_klass_head) {}\n+\n+  InstanceKlass* proxy_klass_head() const { return _proxy_klass_head; }\n+\n+  \/\/ Used by LambdaProxyClassDictionary to implement OffsetCompactHashtable::EQUALS\n+  static inline bool EQUALS(\n+       const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {\n+    return (value->_key.equals(*key));\n+  }\n+  void init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    _key = key;\n+    _key.mark_pointers();\n+    _proxy_klass_head = info._proxy_klasses->at(0);\n+    ArchivePtrMarker::mark_pointer(&_proxy_klass_head);\n+  }\n+\n+  unsigned int hash() const {\n+    return _key.hash();\n+  }\n+  LambdaProxyClassKey key() const {\n+    return _key;\n+  }\n+};\n+\n+class DumpTimeLambdaProxyClassDictionary\n+  : public ResourceHashtable<LambdaProxyClassKey,\n+                             DumpTimeLambdaProxyClassInfo,\n+                             LambdaProxyClassKey::DUMPTIME_HASH,\n+                             LambdaProxyClassKey::DUMPTIME_EQUALS,\n+                             137, \/\/ prime number\n+                             ResourceObj::C_HEAP> {\n+public:\n+  int _count;\n+};\n+\n+class LambdaProxyClassDictionary : public OffsetCompactHashtable<\n+  LambdaProxyClassKey*,\n+  const RunTimeLambdaProxyClassInfo*,\n+  RunTimeLambdaProxyClassInfo::EQUALS> {};\n+\n+#endif \/\/ SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsProtectionDomain.hpp\"\n@@ -249,1 +250,1 @@\n-      SystemDictionaryShared::allocate_shared_data_arrays(size, CHECK);\n+      CDSProtectionDomain::allocate_shared_data_arrays(size, CHECK);\n@@ -487,3 +488,2 @@\n-  \/\/ At this point, many classes have been loaded.\n-  \/\/ Gather systemDictionary classes in a global array and do everything to\n-  \/\/ that so we don't have to walk the SystemDictionary again.\n+  \/\/ Block concurrent class unloading from changing the _dumptime_table\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n@@ -492,1 +492,0 @@\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n@@ -705,1 +704,1 @@\n-  SystemDictionaryShared::create_jar_manifest(dummy, strlen(dummy), CHECK);\n+  CDSProtectionDomain::create_jar_manifest(dummy, strlen(dummy), CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/runTimeClassInfo.hpp\"\n+\n+void RunTimeClassInfo::init(DumpTimeClassInfo& info) {\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+  assert(builder->is_in_buffer_space(info._klass), \"must be\");\n+  _klass = info._klass;\n+  if (!SystemDictionaryShared::is_builtin(_klass)) {\n+    CrcInfo* c = crc();\n+    c->_clsfile_size = info._clsfile_size;\n+    c->_clsfile_crc32 = info._clsfile_crc32;\n+  }\n+  _num_verifier_constraints = info.num_verifier_constraints();\n+  _num_loader_constraints   = info.num_loader_constraints();\n+  int i;\n+  if (_num_verifier_constraints > 0) {\n+    RTVerifierConstraint* vf_constraints = verifier_constraints();\n+    char* flags = verifier_constraint_flags();\n+    for (i = 0; i < _num_verifier_constraints; i++) {\n+      vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n+      vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n+    }\n+    for (i = 0; i < _num_verifier_constraints; i++) {\n+      flags[i] = info._verifier_constraint_flags->at(i);\n+    }\n+  }\n+\n+  if (_num_loader_constraints > 0) {\n+    RTLoaderConstraint* ld_constraints = loader_constraints();\n+    for (i = 0; i < _num_loader_constraints; i++) {\n+      ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n+      ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n+      ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n+    }\n+  }\n+\n+  if (_klass->is_hidden()) {\n+    InstanceKlass* n_h = info.nest_host();\n+    set_nest_host(n_h);\n+  }\n+  ArchivePtrMarker::mark_pointer(&_klass);\n+}\n+\n+size_t RunTimeClassInfo::crc_size(InstanceKlass* klass) {\n+  if (!SystemDictionaryShared::is_builtin(klass)) {\n+    return sizeof(CrcInfo);\n+  } else {\n+    return 0;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_SHAREDCLASSINFO_HPP\n+#define SHARED_CDS_SHAREDCLASSINFO_HPP\n+#include \"classfile\/compactHashtable.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class Method;\n+class Symbol;\n+\n+class RunTimeClassInfo {\n+public:\n+  struct CrcInfo {\n+    int _clsfile_size;\n+    int _clsfile_crc32;\n+  };\n+\n+  \/\/ This is different than  DumpTimeClassInfo::DTVerifierConstraint. We use\n+  \/\/ u4 instead of Symbol* to save space on 64-bit CPU.\n+  struct RTVerifierConstraint {\n+    u4 _name;\n+    u4 _from_name;\n+    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n+    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n+  };\n+\n+  struct RTLoaderConstraint {\n+    u4   _name;\n+    char _loader_type1;\n+    char _loader_type2;\n+    Symbol* constraint_name() {\n+      return (Symbol*)(SharedBaseAddress + _name);\n+    }\n+  };\n+\n+  InstanceKlass* _klass;\n+  int _num_verifier_constraints;\n+  int _num_loader_constraints;\n+\n+  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n+  \/\/ optional InstanceKlass*       _nest_host\n+  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n+  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n+  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n+\n+private:\n+  static size_t header_size_size() {\n+    return sizeof(RunTimeClassInfo);\n+  }\n+  static size_t verifier_constraints_size(int num_verifier_constraints) {\n+    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n+  }\n+  static size_t verifier_constraint_flags_size(int num_verifier_constraints) {\n+    return sizeof(char) * num_verifier_constraints;\n+  }\n+  static size_t loader_constraints_size(int num_loader_constraints) {\n+    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n+  }\n+  static size_t nest_host_size(InstanceKlass* klass) {\n+    if (klass->is_hidden()) {\n+      return sizeof(InstanceKlass*);\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  static size_t crc_size(InstanceKlass* klass);\n+public:\n+  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n+    return header_size_size() +\n+           crc_size(klass) +\n+           nest_host_size(klass) +\n+           loader_constraints_size(num_loader_constraints) +\n+           verifier_constraints_size(num_verifier_constraints) +\n+           verifier_constraint_flags_size(num_verifier_constraints);\n+  }\n+\n+private:\n+  size_t crc_offset() const {\n+    return header_size_size();\n+  }\n+\n+  size_t nest_host_offset() const {\n+      return crc_offset() + crc_size(_klass);\n+  }\n+\n+  size_t loader_constraints_offset() const  {\n+    return nest_host_offset() + nest_host_size(_klass);\n+  }\n+  size_t verifier_constraints_offset() const {\n+    return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);\n+  }\n+  size_t verifier_constraint_flags_offset() const {\n+    return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);\n+  }\n+\n+  void check_verifier_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_verifier_constraints, \"sanity\");\n+  }\n+\n+  void check_loader_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_loader_constraints, \"sanity\");\n+  }\n+\n+public:\n+  CrcInfo* crc() const {\n+    assert(crc_size(_klass) > 0, \"must be\");\n+    return (CrcInfo*)(address(this) + crc_offset());\n+  }\n+  RTVerifierConstraint* verifier_constraints() {\n+    assert(_num_verifier_constraints > 0, \"sanity\");\n+    return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());\n+  }\n+  RTVerifierConstraint* verifier_constraint_at(int i) {\n+    check_verifier_constraint_offset(i);\n+    return verifier_constraints() + i;\n+  }\n+\n+  char* verifier_constraint_flags() {\n+    assert(_num_verifier_constraints > 0, \"sanity\");\n+    return (char*)(address(this) + verifier_constraint_flags_offset());\n+  }\n+\n+  InstanceKlass** nest_host_addr() {\n+    assert(_klass->is_hidden(), \"sanity\");\n+    return (InstanceKlass**)(address(this) + nest_host_offset());\n+  }\n+  InstanceKlass* nest_host() {\n+    return *nest_host_addr();\n+  }\n+  void set_nest_host(InstanceKlass* k) {\n+    *nest_host_addr() = k;\n+    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n+  }\n+\n+  RTLoaderConstraint* loader_constraints() {\n+    assert(_num_loader_constraints > 0, \"sanity\");\n+    return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());\n+  }\n+\n+  RTLoaderConstraint* loader_constraint_at(int i) {\n+    check_loader_constraint_offset(i);\n+    return loader_constraints() + i;\n+  }\n+\n+  void init(DumpTimeClassInfo& info);\n+\n+  bool matches(int clsfile_size, int clsfile_crc32) const {\n+    return crc()->_clsfile_size  == clsfile_size &&\n+           crc()->_clsfile_crc32 == clsfile_crc32;\n+  }\n+\n+  char verifier_constraint_flag(int i) {\n+    check_verifier_constraint_offset(i);\n+    return verifier_constraint_flags()[i];\n+  }\n+\n+private:\n+  \/\/ ArchiveBuilder::make_shallow_copy() has reserved a pointer immediately\n+  \/\/ before archived InstanceKlasses. We can use this slot to do a quick\n+  \/\/ lookup of InstanceKlass* -> RunTimeClassInfo* without\n+  \/\/ building a new hashtable.\n+  \/\/\n+  \/\/  info_pointer_addr(klass) --> 0x0100   RunTimeClassInfo*\n+  \/\/  InstanceKlass* klass     --> 0x0108   <C++ vtbl>\n+  \/\/                               0x0110   fields from Klass ...\n+  static RunTimeClassInfo** info_pointer_addr(InstanceKlass* klass) {\n+    return &((RunTimeClassInfo**)klass)[-1];\n+  }\n+\n+public:\n+  static RunTimeClassInfo* get_for(InstanceKlass* klass) {\n+    assert(klass->is_shared(), \"don't call for non-shared class\");\n+    return *info_pointer_addr(klass);\n+  }\n+  static void set_for(InstanceKlass* klass, RunTimeClassInfo* record) {\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n+    *info_pointer_addr(klass) = record;\n+    ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));\n+  }\n+\n+  \/\/ Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS\n+  static inline bool EQUALS(\n+       const RunTimeClassInfo* value, Symbol* key, int len_unused) {\n+    return (value->_klass->name() == key);\n+  }\n+};\n+\n+class RunTimeSharedDictionary : public OffsetCompactHashtable<\n+  Symbol*,\n+  const RunTimeClassInfo*,\n+  RunTimeClassInfo::EQUALS> {};\n+#endif \/\/ SHARED_CDS_SHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -140,0 +140,2 @@\n+#define JAVA_18_VERSION                   62\n+\n@@ -693,2 +695,3 @@\n-            \/\/ Method name and signature are verified above, when iterating NameAndType_info.\n-            \/\/ Need only to be sure signature is non-zero length and the right type.\n+            \/\/ Method name and signature are individually verified above, when iterating\n+            \/\/ NameAndType_info.  Need to check here that signature is non-zero length and\n+            \/\/ the right type.\n@@ -699,1 +702,1 @@\n-          \/\/ 4509014: If a class method name begins with '<', it must be \"<init>\"\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n@@ -701,8 +704,10 @@\n-          if (tag == JVM_CONSTANT_Methodref &&\n-              name_len != 0 &&\n-              name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-              name != vmSymbols::object_initializer_name()) {\n-            classfile_parse_error(\n-              \"Bad method name at constant pool index %u in class file %s\",\n-              name_ref_index, THREAD);\n-            return;\n+          if (tag == JVM_CONSTANT_Methodref && name_len != 0 &&\n+              name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n+            if (name != vmSymbols::object_initializer_name()) {\n+              classfile_parse_error(\n+                \"Bad method name at constant pool index %u in class file %s\",\n+                name_ref_index, THREAD);\n+              return;\n+            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n+              throwIllegalSignature(\"Method\", name, signature, CHECK);\n+            }\n@@ -2082,1 +2087,0 @@\n-      ik->set_prototype_header(markWord::prototype());\n@@ -2295,0 +2299,1 @@\n+    verify_legal_name_with_signature(name, signature, CHECK_NULL);\n@@ -5044,0 +5049,26 @@\n+\/\/ Check that the signature is compatible with the method name.  For example,\n+\/\/ check that <init> has a void signature.\n+void ClassFileParser::verify_legal_name_with_signature(const Symbol* name,\n+                                                       const Symbol* signature,\n+                                                       TRAPS) const {\n+  if (!_need_verify) {\n+    return;\n+  }\n+\n+  \/\/ Class initializers cannot have args for class format version >= 51.\n+  if (name == vmSymbols::class_initializer_name() &&\n+      signature != vmSymbols::void_method_signature() &&\n+      _major_version >= JAVA_7_VERSION) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+    return;\n+  }\n+\n+  int sig_length = signature->utf8_length();\n+  if (name->utf8_length() > 0 &&\n+      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+      sig_length > 0 &&\n+      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+  }\n+}\n+\n@@ -5055,8 +5086,0 @@\n-  \/\/ Class initializers cannot have args for class format version >= 51.\n-  if (name == vmSymbols::class_initializer_name() &&\n-      signature != vmSymbols::void_method_signature() &&\n-      _major_version >= JAVA_7_VERSION) {\n-    throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-    return 0;\n-  }\n-\n@@ -5085,11 +5108,4 @@\n-      if (name->utf8_length() > 0 && name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n-        \/\/ All internal methods must return void\n-        if ((length == 1) && (p[0] == JVM_SIGNATURE_VOID)) {\n-          return args_size;\n-        }\n-      } else {\n-        \/\/ Now we better just have a return value\n-        nextp = skip_over_field_signature(p, true, length, CHECK_0);\n-        if (nextp && ((int)length == (nextp - p))) {\n-          return args_size;\n-        }\n+      \/\/ Now we better just have a return value\n+      nextp = skip_over_field_signature(p, true, length, CHECK_0);\n+      if (nextp && ((int)length == (nextp - p))) {\n+        return args_size;\n@@ -5100,1 +5116,1 @@\n-  throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+  throwIllegalSignature(\"Method\", name, signature, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":48,"deletions":32,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -465,0 +465,3 @@\n+  void verify_legal_name_with_signature(const Symbol* name,\n+                                        const Symbol* signature,\n+                                        TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -739,0 +739,3 @@\n+#if INCLUDE_CDS\n+      ClassLoaderExt::set_has_non_jar_in_classpath();\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n@@ -260,0 +259,1 @@\n+  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+bool ClassLoaderExt::_has_non_jar_in_classpath = false;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static bool _has_non_jar_in_classpath;\n@@ -110,0 +111,4 @@\n+  static bool has_non_jar_in_classpath() {\n+    return _has_non_jar_in_classpath;\n+  }\n+\n@@ -118,1 +123,4 @@\n-#endif\n+  static void set_has_non_jar_in_classpath() {\n+    _has_non_jar_in_classpath = true;\n+  }\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -130,1 +131,2 @@\n-objArrayHandle names, typeArrayHandle enabled, TRAPS) {\n+                                    objArrayHandle names,\n+                                    typeArrayHandle enabled, TRAPS) {\n@@ -138,2 +140,2 @@\n-    Handle s = java_lang_String::create_from_str(p->name(), CHECK);\n-    s = java_lang_String::char_converter(s, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, CHECK);\n+    TempNewSymbol name = SymbolTable::new_symbol(p->name());\n+    Handle s = java_lang_String::externalize_classname(name, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/javaAssertions.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -472,64 +472,3 @@\n-Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {\n-  oop          obj    = java_string();\n-  \/\/ Typical usage is to convert all '\/' to '.' in string.\n-  typeArrayOop value  = java_lang_String::value(obj);\n-  int          length = java_lang_String::length(obj, value);\n-  bool      is_latin1 = java_lang_String::is_latin1(obj);\n-\n-  \/\/ First check if any from_char exist\n-  int index; \/\/ Declared outside, used later\n-  for (index = 0; index < length; index++) {\n-    jchar c = !is_latin1 ? value->char_at(index) :\n-                  ((jchar) value->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      break;\n-    }\n-  }\n-  if (index == length) {\n-    \/\/ No from_char, so do not copy.\n-    return java_string;\n-  }\n-\n-  \/\/ Check if result string will be latin1\n-  bool to_is_latin1 = false;\n-\n-  \/\/ Replacement char must be latin1\n-  if (CompactStrings && UNICODE::is_latin1(to_char)) {\n-    if (is_latin1) {\n-      \/\/ Source string is latin1 as well\n-      to_is_latin1 = true;\n-    } else if (!UNICODE::is_latin1(from_char)) {\n-      \/\/ We are replacing an UTF16 char. Scan string to\n-      \/\/ check if result can be latin1 encoded.\n-      to_is_latin1 = true;\n-      for (index = 0; index < length; index++) {\n-        jchar c = value->char_at(index);\n-        if (c != from_char && !UNICODE::is_latin1(c)) {\n-          to_is_latin1 = false;\n-          break;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Create new UNICODE (or byte) buffer. Must handlize value because GC\n-  \/\/ may happen during String and char array creation.\n-  typeArrayHandle h_value(THREAD, value);\n-  Handle string = basic_create(length, to_is_latin1, CHECK_NH);\n-  typeArrayOop from_buffer = h_value();\n-  typeArrayOop to_buffer = java_lang_String::value(string());\n-\n-  \/\/ Copy contents\n-  for (index = 0; index < length; index++) {\n-    jchar c = (!is_latin1) ? from_buffer->char_at(index) :\n-                    ((jchar) from_buffer->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      c = to_char;\n-    }\n-    if (!to_is_latin1) {\n-      to_buffer->char_at_put(index, c);\n-    } else {\n-      to_buffer->byte_at_put(index, (jbyte) c);\n-    }\n-  }\n-  return string;\n+Handle java_lang_String::externalize_classname(Symbol* java_name, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  return create_from_str(java_name->as_klass_external_name(), THREAD);\n@@ -4650,20 +4589,0 @@\n-\n-\/\/ Support for intrinsification of java.nio.Buffer.checkIndex\n-\n-int java_nio_Buffer::_limit_offset;\n-\n-#define BUFFER_FIELDS_DO(macro) \\\n-  macro(_limit_offset, k, \"limit\", int_signature, false)\n-\n-void java_nio_Buffer::compute_offsets() {\n-  InstanceKlass* k = vmClasses::nio_Buffer_klass();\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n-  BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {\n-  BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":84,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  f(java_nio_Buffer) \\\n@@ -149,1 +148,0 @@\n-  static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);\n@@ -232,4 +230,2 @@\n-  \/\/ Conversion between '.' and '\/' formats\n-  static Handle externalize_classname(Handle java_string, TRAPS) {\n-    return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);\n-  }\n+  \/\/ Conversion between '.' and '\/' formats, and allocate a String from the result.\n+  static Handle externalize_classname(Symbol* java_name, TRAPS);\n@@ -1587,10 +1583,0 @@\n-class java_nio_Buffer: AllStatic {\n- private:\n-  static int _limit_offset;\n-\n- public:\n-  static int  limit_offset() { CHECK_INIT(_limit_offset); }\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-   Thread *_thread;\n+   JavaThread* _thread;\n@@ -50,1 +50,1 @@\n-   SeenThread(Thread *thread) {\n+   SeenThread(JavaThread* thread) {\n@@ -55,2 +55,2 @@\n-   Thread* thread()                const { return _thread;}\n-   void set_thread(Thread *thread) { _thread = thread; }\n+   JavaThread* thread()          const { return _thread;}\n+   void set_thread(JavaThread* thread) { _thread = thread; }\n@@ -58,3 +58,3 @@\n-   SeenThread* next()              const { return _stnext;}\n-   void set_next(SeenThread *seen) { _stnext = seen; }\n-   void set_prev(SeenThread *seen) { _stprev = seen; }\n+   SeenThread* next()        const { return _stnext;}\n+   void set_next(SeenThread* seen) { _stnext = seen; }\n+   void set_prev(SeenThread* seen) { _stprev = seen; }\n@@ -110,1 +110,1 @@\n-void PlaceholderEntry::add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+void PlaceholderEntry::add_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action) {\n@@ -131,1 +131,1 @@\n-bool PlaceholderEntry::check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+bool PlaceholderEntry::check_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action) {\n@@ -149,1 +149,1 @@\n-bool PlaceholderEntry::remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+bool PlaceholderEntry::remove_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action) {\n@@ -291,1 +291,1 @@\n-                                                 Thread* thread) {\n+                                                 JavaThread* thread) {\n@@ -324,1 +324,1 @@\n-                                       Thread* thread) {\n+                                       JavaThread* thread) {\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                                 Thread* thread);\n+                                 JavaThread* thread);\n@@ -97,1 +97,1 @@\n-                       classloadAction action, Thread* thread);\n+                       classloadAction action, JavaThread* thread);\n@@ -119,1 +119,1 @@\n-  Thread*           _definer;       \/\/ owner of define token\n+  JavaThread*       _definer;       \/\/ owner of define token\n@@ -133,2 +133,2 @@\n-  void add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n-  bool remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n+  void add_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action);\n+  bool remove_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action);\n@@ -149,2 +149,2 @@\n-  Thread*            definer()             const {return _definer; }\n-  void               set_definer(Thread* definer) { _definer = definer; }\n+  JavaThread*        definer()             const {return _definer; }\n+  void               set_definer(JavaThread* definer) { _definer = definer; }\n@@ -161,1 +161,1 @@\n-  SeenThread*        defineThreadQ()        const { return _defineThreadQ; }\n+  SeenThread*        defineThreadQ()       const { return _defineThreadQ; }\n@@ -191,1 +191,1 @@\n-  bool check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n+  bool check_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -158,1 +157,0 @@\n-  if (AlwaysLockClassLoader) return false;\n@@ -1312,1 +1310,0 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);\n@@ -1314,1 +1311,1 @@\n-    Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle string = java_lang_String::externalize_classname(class_name, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -205,5 +205,0 @@\n-protected:\n-  \/\/ Returns the class loader data to be used when looking up\/updating the\n-  \/\/ system dictionary.\n-  static ClassLoaderData *class_loader_data(Handle class_loader);\n-\n@@ -214,0 +209,4 @@\n+  \/\/ Returns the class loader data to be used when looking up\/updating the\n+  \/\/ system dictionary.\n+  static ClassLoaderData *class_loader_data(Handle class_loader);\n+\n@@ -223,1 +222,0 @@\n-public:\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/cdsProtectionDomain.hpp\"\n@@ -63,1 +64,0 @@\n-#include \"prims\/jvmtiExport.hpp\"\n@@ -73,0 +73,11 @@\n+DumpTimeSharedClassTable* SystemDictionaryShared::_dumptime_table = NULL;\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_dumptime_lambda_proxy_class_dictionary = NULL;\n+\/\/ SystemDictionaries in the base layer static archive\n+RunTimeSharedDictionary SystemDictionaryShared::_builtin_dictionary;\n+RunTimeSharedDictionary SystemDictionaryShared::_unregistered_dictionary;\n+\/\/ SystemDictionaries in the top layer dynamic archive\n+RunTimeSharedDictionary SystemDictionaryShared::_dynamic_builtin_dictionary;\n+RunTimeSharedDictionary SystemDictionaryShared::_dynamic_unregistered_dictionary;\n+\n+LambdaProxyClassDictionary SystemDictionaryShared::_lambda_proxy_class_dictionary;\n+LambdaProxyClassDictionary SystemDictionaryShared::_dynamic_lambda_proxy_class_dictionary;\n@@ -74,3 +85,0 @@\n-OopHandle SystemDictionaryShared::_shared_protection_domains;\n-OopHandle SystemDictionaryShared::_shared_jar_urls;\n-OopHandle SystemDictionaryShared::_shared_jar_manifests;\n@@ -80,80 +88,4 @@\n-class DumpTimeSharedClassInfo: public CHeapObj<mtClass> {\n-  bool                         _excluded;\n-  bool                         _is_early_klass;\n-  bool                         _has_checked_exclusion;\n-public:\n-  struct DTLoaderConstraint {\n-    Symbol* _name;\n-    char _loader_type1;\n-    char _loader_type2;\n-    DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {\n-      _name->increment_refcount();\n-    }\n-    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n-    bool equals(const DTLoaderConstraint& t) {\n-      return t._name == _name &&\n-             ((t._loader_type1 == _loader_type1 && t._loader_type2 == _loader_type2) ||\n-              (t._loader_type2 == _loader_type1 && t._loader_type1 == _loader_type2));\n-    }\n-  };\n-\n-  struct DTVerifierConstraint {\n-    Symbol* _name;\n-    Symbol* _from_name;\n-    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n-    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n-      _name->increment_refcount();\n-      _from_name->increment_refcount();\n-    }\n-  };\n-\n-  InstanceKlass*               _klass;\n-  InstanceKlass*               _nest_host;\n-  bool                         _failed_verification;\n-  bool                         _is_archived_lambda_proxy;\n-  int                          _id;\n-  int                          _clsfile_size;\n-  int                          _clsfile_crc32;\n-  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n-  GrowableArray<char>*                 _verifier_constraint_flags;\n-  GrowableArray<DTLoaderConstraint>* _loader_constraints;\n-\n-  DumpTimeSharedClassInfo() {\n-    _klass = NULL;\n-    _nest_host = NULL;\n-    _failed_verification = false;\n-    _is_archived_lambda_proxy = false;\n-    _has_checked_exclusion = false;\n-    _id = -1;\n-    _clsfile_size = -1;\n-    _clsfile_crc32 = -1;\n-    _excluded = false;\n-    _is_early_klass = JvmtiExport::is_early_phase();\n-    _verifier_constraints = NULL;\n-    _verifier_constraint_flags = NULL;\n-    _loader_constraints = NULL;\n-  }\n-\n-  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n-  void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);\n-\n-  bool is_builtin() {\n-    return SystemDictionaryShared::is_builtin(_klass);\n-  }\n-\n-  int num_verifier_constraints() {\n-    if (_verifier_constraint_flags != NULL) {\n-      return _verifier_constraint_flags->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n-\n-  int num_loader_constraints() {\n-    if (_loader_constraints != NULL) {\n-      return _loader_constraints->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n+InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(\n+                 Symbol* class_name, Handle class_loader, TRAPS) {\n+  assert(UseSharedSpaces, \"must be\");\n+  InstanceKlass* ik = find_builtin_class(class_name);\n@@ -161,15 +93,8 @@\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    it->push(&_klass);\n-    it->push(&_nest_host);\n-    if (_verifier_constraints != NULL) {\n-      for (int i = 0; i < _verifier_constraints->length(); i++) {\n-        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n-        it->push(&cons->_name);\n-        it->push(&cons->_from_name);\n-      }\n-    }\n-    if (_loader_constraints != NULL) {\n-      for (int i = 0; i < _loader_constraints->length(); i++) {\n-        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n-        it->push(&lc->_name);\n-      }\n+  if (ik != NULL && !ik->shared_loading_failed()) {\n+    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n+        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n+      SharedClassLoadingMark slm(THREAD, ik);\n+      PackageEntry* pkg_entry = CDSProtectionDomain::get_package_entry_from_class(ik, class_loader);\n+      Handle protection_domain =\n+        CDSProtectionDomain::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);\n+      return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);\n@@ -178,31 +103,1 @@\n-\n-  bool is_excluded() {\n-    \/\/ _klass may become NULL due to DynamicArchiveBuilder::set_to_null\n-    return _excluded || _failed_verification || _klass == NULL;\n-  }\n-\n-  \/\/ Was this class loaded while JvmtiExport::is_early_phase()==true\n-  bool is_early_klass() {\n-    return _is_early_klass;\n-  }\n-\n-  \/\/ simple accessors\n-  void set_excluded()                               { _excluded = true; }\n-  bool has_checked_exclusion() const                { return _has_checked_exclusion; }\n-  void set_has_checked_exclusion()                  { _has_checked_exclusion = true; }\n-  bool failed_verification() const                  { return _failed_verification; }\n-  void set_failed_verification()                    { _failed_verification = true; }\n-  InstanceKlass* nest_host() const                  { return _nest_host; }\n-  void set_nest_host(InstanceKlass* nest_host)      { _nest_host = nest_host; }\n-};\n-\n-inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n-  if (DumpSharedSpaces) {\n-    \/\/ Deterministic archive contents\n-    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n-    return primitive_hash<uintx>(delta);\n-  } else {\n-    \/\/ Deterministic archive is not possible because classes can be loaded\n-    \/\/ in multiple threads.\n-    return primitive_hash<InstanceKlass*>(k);\n-  }\n+  return NULL;\n@@ -211,52 +106,8 @@\n-class DumpTimeSharedClassTable: public ResourceHashtable<\n-  InstanceKlass*,\n-  DumpTimeSharedClassInfo,\n-  &DumpTimeSharedClassTable_hash,\n-  primitive_equals<InstanceKlass*>,\n-  15889, \/\/ prime number\n-  ResourceObj::C_HEAP>\n-{\n-  int _builtin_count;\n-  int _unregistered_count;\n-public:\n-  DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress) {\n-    bool created = false;\n-    DumpTimeSharedClassInfo* p;\n-    if (!dump_in_progress) {\n-      p = put_if_absent(k, &created);\n-    } else {\n-      p = get(k);\n-    }\n-    if (created) {\n-      assert(!SystemDictionaryShared::no_class_loading_should_happen(),\n-             \"no new classes can be loaded while dumping archive\");\n-      p->_klass = k;\n-    } else {\n-      if (!dump_in_progress) {\n-        assert(p->_klass == k, \"Sanity\");\n-      }\n-    }\n-    return p;\n-  }\n-\n-  class CountClassByCategory : StackObj {\n-    DumpTimeSharedClassTable* _table;\n-  public:\n-    CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}\n-    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n-      if (!info.is_excluded()) {\n-        if (info.is_builtin()) {\n-          ++ _table->_builtin_count;\n-        } else {\n-          ++ _table->_unregistered_count;\n-        }\n-      }\n-      return true; \/\/ keep on iterating\n-    }\n-  };\n-\n-  void update_counts() {\n-    _builtin_count = 0;\n-    _unregistered_count = 0;\n-    CountClassByCategory counter(this);\n-    iterate(&counter);\n+\/\/ This function is called for loading only UNREGISTERED classes\n+InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,\n+                                                          Handle class_loader,\n+                                                          Handle protection_domain,\n+                                                          const ClassFileStream* cfs,\n+                                                          TRAPS) {\n+  if (!UseSharedSpaces) {\n+    return NULL;\n@@ -264,7 +115,2 @@\n-\n-  int count_of(bool is_builtin) const {\n-    if (is_builtin) {\n-      return _builtin_count;\n-    } else {\n-      return _unregistered_count;\n-    }\n+  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n+    return NULL;\n@@ -272,65 +118,5 @@\n-};\n-\n-class LambdaProxyClassKey {\n-  InstanceKlass* _caller_ik;\n-  Symbol*        _invoked_name;\n-  Symbol*        _invoked_type;\n-  Symbol*        _method_type;\n-  Method*        _member_method;\n-  Symbol*        _instantiated_method_type;\n-\n-public:\n-  LambdaProxyClassKey(InstanceKlass* caller_ik,\n-                      Symbol*        invoked_name,\n-                      Symbol*        invoked_type,\n-                      Symbol*        method_type,\n-                      Method*        member_method,\n-                      Symbol*        instantiated_method_type) :\n-    _caller_ik(caller_ik),\n-    _invoked_name(invoked_name),\n-    _invoked_type(invoked_type),\n-    _method_type(method_type),\n-    _member_method(member_method),\n-    _instantiated_method_type(instantiated_method_type) {}\n-\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    it->push(&_caller_ik);\n-    it->push(&_invoked_name);\n-    it->push(&_invoked_type);\n-    it->push(&_method_type);\n-    it->push(&_member_method);\n-    it->push(&_instantiated_method_type);\n-  }\n-\n-  void mark_pointers() {\n-    ArchivePtrMarker::mark_pointer(&_caller_ik);\n-    ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n-    ArchivePtrMarker::mark_pointer(&_invoked_name);\n-    ArchivePtrMarker::mark_pointer(&_invoked_type);\n-    ArchivePtrMarker::mark_pointer(&_member_method);\n-    ArchivePtrMarker::mark_pointer(&_method_type);\n-  }\n-\n-  bool equals(LambdaProxyClassKey const& other) const {\n-    return _caller_ik == other._caller_ik &&\n-           _invoked_name == other._invoked_name &&\n-           _invoked_type == other._invoked_type &&\n-           _method_type == other._method_type &&\n-           _member_method == other._member_method &&\n-           _instantiated_method_type == other._instantiated_method_type;\n-  }\n-\n-  unsigned int hash() const {\n-    return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n-  }\n-\n-  static unsigned int dumptime_hash(Symbol* sym)  {\n-    if (sym == NULL) {\n-      \/\/ _invoked_name maybe NULL\n-      return 0;\n-    }\n-    return java_lang_String::hash_code((const jbyte*)sym->bytes(), sym->utf8_length());\n+  if (class_loader.is_null() ||\n+      SystemDictionary::is_system_class_loader(class_loader()) ||\n+      SystemDictionary::is_platform_class_loader(class_loader())) {\n+    \/\/ Do nothing for the BUILTIN loaders.\n+    return NULL;\n@@ -339,6 +125,3 @@\n-  unsigned int dumptime_hash() const {\n-    return dumptime_hash(_caller_ik->name()) +\n-           dumptime_hash(_invoked_name) +\n-           dumptime_hash(_invoked_type) +\n-           dumptime_hash(_method_type) +\n-           dumptime_hash(_instantiated_method_type);\n+  const RunTimeClassInfo* record = find_record(&_unregistered_dictionary, &_dynamic_unregistered_dictionary, class_name);\n+  if (record == NULL) {\n+    return NULL;\n@@ -347,3 +130,2 @@\n-  static inline unsigned int DUMPTIME_HASH(LambdaProxyClassKey const& key) {\n-    return (key.dumptime_hash());\n-  }\n+  int clsfile_size  = cfs->length();\n+  int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs->buffer(), cfs->length());\n@@ -351,3 +133,2 @@\n-  static inline bool DUMPTIME_EQUALS(\n-      LambdaProxyClassKey const& k1, LambdaProxyClassKey const& k2) {\n-    return (k1.equals(k2));\n+  if (!record->matches(clsfile_size, clsfile_crc32)) {\n+    return NULL;\n@@ -356,2 +137,4 @@\n-  InstanceKlass* caller_ik() const { return _caller_ik; }\n-};\n+  return acquire_class_for_current_thread(record->_klass, class_loader,\n+                                          protection_domain, cfs,\n+                                          THREAD);\n+}\n@@ -359,0 +142,7 @@\n+InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(\n+                   InstanceKlass *ik,\n+                   Handle class_loader,\n+                   Handle protection_domain,\n+                   const ClassFileStream *cfs,\n+                   TRAPS) {\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n@@ -360,7 +150,6 @@\n-class DumpTimeLambdaProxyClassInfo {\n-public:\n-  GrowableArray<InstanceKlass*>* _proxy_klasses;\n-  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}\n-  void add_proxy_klass(InstanceKlass* proxy_klass) {\n-    if (_proxy_klasses == NULL) {\n-      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<InstanceKlass*>(5, mtClassShared);\n+  {\n+    MutexLocker mu(THREAD, SharedDictionary_lock);\n+    if (ik->class_loader_data() != NULL) {\n+      \/\/    ik is already loaded (by this loader or by a different loader)\n+      \/\/ or ik is being loaded by a different thread (by this loader or by a different loader)\n+      return NULL;\n@@ -368,3 +157,0 @@\n-    assert(_proxy_klasses != NULL, \"sanity\");\n-    _proxy_klasses->append(proxy_klass);\n-  }\n@@ -372,4 +158,2 @@\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    for (int i=0; i<_proxy_klasses->length(); i++) {\n-      it->push(_proxy_klasses->adr_at(i));\n-    }\n+    \/\/ No other thread has acquired this yet, so give it to *this thread*\n+    ik->set_class_loader_data(loader_data);\n@@ -377,1 +161,0 @@\n-};\n@@ -379,8 +162,3 @@\n-class RunTimeLambdaProxyClassInfo {\n-  LambdaProxyClassKey _key;\n-  InstanceKlass* _proxy_klass_head;\n-public:\n-  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n-    _key(key), _proxy_klass_head(proxy_klass_head) {}\n-\n-  InstanceKlass* proxy_klass_head() const { return _proxy_klass_head; }\n+  \/\/ No longer holding SharedDictionary_lock\n+  \/\/ No need to lock, as <ik> can be held only by a single thread.\n+  loader_data->add_class(ik);\n@@ -388,11 +166,2 @@\n-  \/\/ Used by LambdaProxyClassDictionary to implement OffsetCompactHashtable::EQUALS\n-  static inline bool EQUALS(\n-       const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {\n-    return (value->_key.equals(*key));\n-  }\n-  void init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    _key = key;\n-    _key.mark_pointers();\n-    _proxy_klass_head = info._proxy_klasses->at(0);\n-    ArchivePtrMarker::mark_pointer(&_proxy_klass_head);\n-  }\n+  \/\/ Get the package entry.\n+  PackageEntry* pkg_entry = CDSProtectionDomain::get_package_entry_from_class(ik, class_loader);\n@@ -400,5 +169,6 @@\n-  unsigned int hash() const {\n-    return _key.hash();\n-  }\n-  LambdaProxyClassKey key() const {\n-    return _key;\n+  \/\/ Load and check super\/interfaces, restore unsharable info\n+  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,\n+                                                  cfs, pkg_entry, THREAD);\n+  if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {\n+    \/\/ TODO: clean up <ik> so it can be used again\n+    return NULL;\n@@ -406,6 +176,0 @@\n-};\n-\n-class LambdaProxyClassDictionary : public OffsetCompactHashtable<\n-  LambdaProxyClassKey*,\n-  const RunTimeLambdaProxyClassInfo*,\n-  RunTimeLambdaProxyClassInfo::EQUALS> {};\n@@ -413,3 +177,2 @@\n-LambdaProxyClassDictionary _lambda_proxy_class_dictionary;\n-\n-LambdaProxyClassDictionary _dynamic_lambda_proxy_class_dictionary;\n+  return shared_klass;\n+}\n@@ -417,10 +180,4 @@\n-class DumpTimeLambdaProxyClassDictionary\n-  : public ResourceHashtable<LambdaProxyClassKey,\n-                             DumpTimeLambdaProxyClassInfo,\n-                             LambdaProxyClassKey::DUMPTIME_HASH,\n-                             LambdaProxyClassKey::DUMPTIME_EQUALS,\n-                             137, \/\/ prime number\n-                             ResourceObj::C_HEAP> {\n-public:\n-  int _count;\n-};\n+void SystemDictionaryShared::start_dumping() {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  _dump_in_progress = true;\n+}\n@@ -428,1 +185,4 @@\n-DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary = NULL;\n+DumpTimeClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  return find_or_allocate_info_for_locked(k);\n+}\n@@ -430,2 +190,1 @@\n-static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey key,\n-                                                           InstanceKlass* proxy_klass) {\n+DumpTimeClassInfo* SystemDictionaryShared::find_or_allocate_info_for_locked(InstanceKlass* k) {\n@@ -433,14 +192,2 @@\n-  if (_dumptime_lambda_proxy_class_dictionary == NULL) {\n-    _dumptime_lambda_proxy_class_dictionary =\n-      new (ResourceObj::C_HEAP, mtClass)DumpTimeLambdaProxyClassDictionary();\n-  }\n-  DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n-  if (lambda_info == NULL) {\n-    DumpTimeLambdaProxyClassInfo info;\n-    info.add_proxy_klass(proxy_klass);\n-    _dumptime_lambda_proxy_class_dictionary->put(key, info);\n-    \/\/lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n-    \/\/assert(lambda_info->_proxy_klass == proxy_klass, \"must be\"); \/\/ debug only -- remove\n-    ++_dumptime_lambda_proxy_class_dictionary->_count;\n-  } else {\n-    lambda_info->add_proxy_klass(proxy_klass);\n+  if (_dumptime_table == NULL) {\n+    _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();\n@@ -448,0 +195,1 @@\n+  return _dumptime_table->find_or_allocate_info_for(k, _dump_in_progress);\n@@ -450,61 +198,6 @@\n-class RunTimeSharedClassInfo {\n-public:\n-  struct CrcInfo {\n-    int _clsfile_size;\n-    int _clsfile_crc32;\n-  };\n-\n-  \/\/ This is different than  DumpTimeSharedClassInfo::DTVerifierConstraint. We use\n-  \/\/ u4 instead of Symbol* to save space on 64-bit CPU.\n-  struct RTVerifierConstraint {\n-    u4 _name;\n-    u4 _from_name;\n-    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n-    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n-  };\n-\n-  struct RTLoaderConstraint {\n-    u4   _name;\n-    char _loader_type1;\n-    char _loader_type2;\n-    Symbol* constraint_name() {\n-      return (Symbol*)(SharedBaseAddress + _name);\n-    }\n-  };\n-\n-  InstanceKlass* _klass;\n-  int _num_verifier_constraints;\n-  int _num_loader_constraints;\n-\n-  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n-  \/\/ optional InstanceKlass*       _nest_host\n-  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n-  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n-  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n-\n-private:\n-  static size_t header_size_size() {\n-    return sizeof(RunTimeSharedClassInfo);\n-  }\n-  static size_t crc_size(InstanceKlass* klass) {\n-    if (!SystemDictionaryShared::is_builtin(klass)) {\n-      return sizeof(CrcInfo);\n-    } else {\n-      return 0;\n-    }\n-  }\n-  static size_t verifier_constraints_size(int num_verifier_constraints) {\n-    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n-  }\n-  static size_t verifier_constraint_flags_size(int num_verifier_constraints) {\n-    return sizeof(char) * num_verifier_constraints;\n-  }\n-  static size_t loader_constraints_size(int num_loader_constraints) {\n-    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n-  }\n-  static size_t nest_host_size(InstanceKlass* klass) {\n-    if (klass->is_hidden()) {\n-      return sizeof(InstanceKlass*);\n-    } else {\n-      return 0;\n-    }\n+bool SystemDictionaryShared::check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info) {\n+  if (MetaspaceShared::is_in_shared_metaspace(k)) {\n+    \/\/ We have reached a super type that's already in the base archive. Treat it\n+    \/\/ as \"not excluded\".\n+    assert(DynamicDumpSharedSpaces, \"must be\");\n+    return false;\n@@ -513,8 +206,3 @@\n-public:\n-  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n-    return header_size_size() +\n-           crc_size(klass) +\n-           nest_host_size(klass) +\n-           loader_constraints_size(num_loader_constraints) +\n-           verifier_constraints_size(num_verifier_constraints) +\n-           verifier_constraint_flags_size(num_verifier_constraints);\n+  if (info == NULL) {\n+    info = _dumptime_table->get(k);\n+    assert(info != NULL, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n@@ -523,3 +211,5 @@\n-private:\n-  size_t crc_offset() const {\n-    return header_size_size();\n+  if (!info->has_checked_exclusion()) {\n+    if (check_for_exclusion_impl(k)) {\n+      info->set_excluded();\n+    }\n+    info->set_has_checked_exclusion();\n@@ -528,3 +218,2 @@\n-  size_t nest_host_offset() const {\n-      return crc_offset() + crc_size(_klass);\n-  }\n+  return info->is_excluded();\n+}\n@@ -532,9 +221,6 @@\n-  size_t loader_constraints_offset() const  {\n-    return nest_host_offset() + nest_host_size(_klass);\n-  }\n-  size_t verifier_constraints_offset() const {\n-    return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);\n-  }\n-  size_t verifier_constraint_flags_offset() const {\n-    return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);\n-  }\n+\/\/ Returns true so the caller can do:    return warn_excluded(\".....\");\n+bool SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {\n+  ResourceMark rm;\n+  log_warning(cds)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n+  return true;\n+}\n@@ -542,2 +228,6 @@\n-  void check_verifier_constraint_offset(int i) const {\n-    assert(0 <= i && i < _num_verifier_constraints, \"sanity\");\n+bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {\n+  while (k) {\n+    if (k->name()->equals(\"jdk\/internal\/event\/Event\")) {\n+      return true;\n+    }\n+    k = k->java_super();\n@@ -545,0 +235,2 @@\n+  return false;\n+}\n@@ -546,3 +238,4 @@\n-  void check_loader_constraint_offset(int i) const {\n-    assert(0 <= i && i < _num_loader_constraints, \"sanity\");\n-  }\n+bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {\n+  DumpTimeClassInfo* info = _dumptime_table->get(ik);\n+  return (info != NULL) ? info->_is_archived_lambda_proxy : false;\n+}\n@@ -550,13 +243,4 @@\n-public:\n-  CrcInfo* crc() const {\n-    assert(crc_size(_klass) > 0, \"must be\");\n-    return (CrcInfo*)(address(this) + crc_offset());\n-  }\n-  RTVerifierConstraint* verifier_constraints() {\n-    assert(_num_verifier_constraints > 0, \"sanity\");\n-    return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());\n-  }\n-  RTVerifierConstraint* verifier_constraint_at(int i) {\n-    check_verifier_constraint_offset(i);\n-    return verifier_constraints() + i;\n-  }\n+bool SystemDictionaryShared::is_early_klass(InstanceKlass* ik) {\n+  DumpTimeClassInfo* info = _dumptime_table->get(ik);\n+  return (info != NULL) ? info->is_early_klass() : false;\n+}\n@@ -564,3 +248,6 @@\n-  char* verifier_constraint_flags() {\n-    assert(_num_verifier_constraints > 0, \"sanity\");\n-    return (char*)(address(this) + verifier_constraint_flags_offset());\n+bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {\n+  assert(ik->is_shared(), \"applicable to only a shared class\");\n+  if (ik->is_hidden()) {\n+    return true;\n+  } else {\n+    return false;\n@@ -568,0 +255,1 @@\n+}\n@@ -569,3 +257,3 @@\n-  InstanceKlass** nest_host_addr() {\n-    assert(_klass->is_hidden(), \"sanity\");\n-    return (InstanceKlass**)(address(this) + nest_host_offset());\n+bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {\n+  if (k->is_in_error_state()) {\n+    return warn_excluded(k, \"In error state\");\n@@ -573,2 +261,2 @@\n-  InstanceKlass* nest_host() {\n-    return *nest_host_addr();\n+  if (has_been_redefined(k)) {\n+    return warn_excluded(k, \"Has been redefined\");\n@@ -576,3 +264,4 @@\n-  void set_nest_host(InstanceKlass* k) {\n-    *nest_host_addr() = k;\n-    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n+  if (!k->is_hidden() && k->shared_classpath_index() < 0 && is_builtin(k)) {\n+    \/\/ These are classes loaded from unsupported locations (such as those loaded by JVMTI native\n+    \/\/ agent during dump time).\n+    return warn_excluded(k, \"Unsupported location\");\n@@ -580,4 +269,5 @@\n-\n-  RTLoaderConstraint* loader_constraints() {\n-    assert(_num_loader_constraints > 0, \"sanity\");\n-    return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());\n+  if (k->signers() != NULL) {\n+    \/\/ We cannot include signed classes in the archive because the certificates\n+    \/\/ used during dump time may be different than those used during\n+    \/\/ runtime (due to expiration, etc).\n+    return warn_excluded(k, \"Signed JAR\");\n@@ -585,4 +275,6 @@\n-\n-  RTLoaderConstraint* loader_constraint_at(int i) {\n-    check_loader_constraint_offset(i);\n-    return loader_constraints() + i;\n+  if (is_jfr_event_class(k)) {\n+    \/\/ We cannot include JFR event classes because they need runtime-specific\n+    \/\/ instrumentation in order to work with -XX:FlightRecorderOptions:retransform=false.\n+    \/\/ There are only a small number of these classes, so it's not worthwhile to\n+    \/\/ support them and make CDS more complicated.\n+    return warn_excluded(k, \"JFR event class\");\n@@ -590,0 +282,4 @@\n+  if (k->init_state() < InstanceKlass::linked) {\n+    \/\/ In CDS dumping, we will attempt to link all classes. Those that fail to link will\n+    \/\/ be recorded in DumpTimeClassInfo.\n+    Arguments::assert_is_dumping_archive();\n@@ -591,30 +287,11 @@\n-  void init(DumpTimeSharedClassInfo& info) {\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    assert(builder->is_in_buffer_space(info._klass), \"must be\");\n-    _klass = info._klass;\n-    if (!SystemDictionaryShared::is_builtin(_klass)) {\n-      CrcInfo* c = crc();\n-      c->_clsfile_size = info._clsfile_size;\n-      c->_clsfile_crc32 = info._clsfile_crc32;\n-    }\n-    _num_verifier_constraints = info.num_verifier_constraints();\n-    _num_loader_constraints   = info.num_loader_constraints();\n-    int i;\n-    if (_num_verifier_constraints > 0) {\n-      RTVerifierConstraint* vf_constraints = verifier_constraints();\n-      char* flags = verifier_constraint_flags();\n-      for (i = 0; i < _num_verifier_constraints; i++) {\n-        vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n-        vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n-      }\n-      for (i = 0; i < _num_verifier_constraints; i++) {\n-        flags[i] = info._verifier_constraint_flags->at(i);\n-      }\n-    }\n-\n-    if (_num_loader_constraints > 0) {\n-      RTLoaderConstraint* ld_constraints = loader_constraints();\n-      for (i = 0; i < _num_loader_constraints; i++) {\n-        ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n-        ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n-        ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n+    \/\/ TODO -- rethink how this can be handled.\n+    \/\/ We should try to link ik, however, we can't do it here because\n+    \/\/ 1. We are at VM exit\n+    \/\/ 2. linking a class may cause other classes to be loaded, which means\n+    \/\/    a custom ClassLoader.loadClass() may be called, at a point where the\n+    \/\/    class loader doesn't expect it.\n+    if (has_class_failed_verification(k)) {\n+      return warn_excluded(k, \"Failed verification\");\n+    } else {\n+      if (k->can_be_verified_at_dumptime()) {\n+        return warn_excluded(k, \"Not linked\");\n@@ -623,47 +300,0 @@\n-\n-    if (_klass->is_hidden()) {\n-      InstanceKlass* n_h = info.nest_host();\n-      set_nest_host(n_h);\n-    }\n-    ArchivePtrMarker::mark_pointer(&_klass);\n-  }\n-\n-  bool matches(int clsfile_size, int clsfile_crc32) const {\n-    return crc()->_clsfile_size  == clsfile_size &&\n-           crc()->_clsfile_crc32 == clsfile_crc32;\n-  }\n-\n-  char verifier_constraint_flag(int i) {\n-    check_verifier_constraint_offset(i);\n-    return verifier_constraint_flags()[i];\n-  }\n-\n-private:\n-  \/\/ ArchiveBuilder::make_shallow_copy() has reserved a pointer immediately\n-  \/\/ before archived InstanceKlasses. We can use this slot to do a quick\n-  \/\/ lookup of InstanceKlass* -> RunTimeSharedClassInfo* without\n-  \/\/ building a new hashtable.\n-  \/\/\n-  \/\/  info_pointer_addr(klass) --> 0x0100   RunTimeSharedClassInfo*\n-  \/\/  InstanceKlass* klass     --> 0x0108   <C++ vtbl>\n-  \/\/                               0x0110   fields from Klass ...\n-  static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {\n-    return &((RunTimeSharedClassInfo**)klass)[-1];\n-  }\n-\n-public:\n-  static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {\n-    assert(klass->is_shared(), \"don't call for non-shared class\");\n-    return *info_pointer_addr(klass);\n-  }\n-  static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {\n-    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n-    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n-    *info_pointer_addr(klass) = record;\n-    ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));\n-  }\n-\n-  \/\/ Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS\n-  static inline bool EQUALS(\n-       const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {\n-    return (value->_klass->name() == key);\n@@ -671,64 +301,7 @@\n-};\n-\n-class RunTimeSharedDictionary : public OffsetCompactHashtable<\n-  Symbol*,\n-  const RunTimeSharedClassInfo*,\n-  RunTimeSharedClassInfo::EQUALS> {};\n-\n-static DumpTimeSharedClassTable* _dumptime_table = NULL;\n-\/\/ SystemDictionaries in the base layer static archive\n-static RunTimeSharedDictionary _builtin_dictionary;\n-static RunTimeSharedDictionary _unregistered_dictionary;\n-\/\/ SystemDictionaries in the top layer dynamic archive\n-static RunTimeSharedDictionary _dynamic_builtin_dictionary;\n-static RunTimeSharedDictionary _dynamic_unregistered_dictionary;\n-\n-void SystemDictionaryShared::atomic_set_array_index(OopHandle array, int index, oop o) {\n-  \/\/ Benign race condition:  array.obj_at(index) may already be filled in.\n-  \/\/ The important thing here is that all threads pick up the same result.\n-  \/\/ It doesn't matter which racing thread wins, as long as only one\n-  \/\/ result is used by all threads, and all future queries.\n-  ((objArrayOop)array.resolve())->atomic_compare_exchange_oop(index, o, NULL);\n-}\n-\n-Handle SystemDictionaryShared::create_jar_manifest(const char* manifest_chars, size_t size, TRAPS) {\n-  typeArrayOop buf = oopFactory::new_byteArray((int)size, CHECK_NH);\n-  typeArrayHandle bufhandle(THREAD, buf);\n-  ArrayAccess<>::arraycopy_from_native(reinterpret_cast<const jbyte*>(manifest_chars),\n-                                         buf, typeArrayOopDesc::element_offset<jbyte>(0), size);\n-  Handle bais = JavaCalls::construct_new_instance(vmClasses::ByteArrayInputStream_klass(),\n-                      vmSymbols::byte_array_void_signature(),\n-                      bufhandle, CHECK_NH);\n-  \/\/ manifest = new Manifest(ByteArrayInputStream)\n-  Handle manifest = JavaCalls::construct_new_instance(vmClasses::Jar_Manifest_klass(),\n-                      vmSymbols::input_stream_void_signature(),\n-                      bais, CHECK_NH);\n-  return manifest;\n-}\n-\n-oop SystemDictionaryShared::shared_protection_domain(int index) {\n-  return ((objArrayOop)_shared_protection_domains.resolve())->obj_at(index);\n-}\n-\n-oop SystemDictionaryShared::shared_jar_url(int index) {\n-  return ((objArrayOop)_shared_jar_urls.resolve())->obj_at(index);\n-}\n-\n-oop SystemDictionaryShared::shared_jar_manifest(int index) {\n-  return ((objArrayOop)_shared_jar_manifests.resolve())->obj_at(index);\n-}\n-\n-Handle SystemDictionaryShared::get_shared_jar_manifest(int shared_path_index, TRAPS) {\n-  Handle manifest ;\n-  if (shared_jar_manifest(shared_path_index) == NULL) {\n-    SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);\n-    size_t size = (size_t)ent->manifest_size();\n-    if (size == 0) {\n-      return Handle();\n-    }\n-\n-    \/\/ ByteArrayInputStream bais = new ByteArrayInputStream(buf);\n-    const char* src = ent->manifest();\n-    assert(src != NULL, \"No Manifest data\");\n-    manifest = create_jar_manifest(src, size, CHECK_NH);\n-    atomic_set_shared_jar_manifest(shared_path_index, manifest());\n+  if (DynamicDumpSharedSpaces && k->major_version() < 50 \/*JAVA_6_VERSION*\/) {\n+    \/\/ In order to support old classes during dynamic dump, class rewriting needs to\n+    \/\/ be reverted. This would result in more complex code and testing but not much gain.\n+    ResourceMark rm;\n+    log_warning(cds)(\"Pre JDK 6 class not supported by CDS: %u.%u %s\",\n+                     k->major_version(),  k->minor_version(), k->name()->as_C_string());\n+    return true;\n@@ -736,25 +309,0 @@\n-  manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));\n-  assert(manifest.not_null(), \"sanity\");\n-  return manifest;\n-}\n-\n-Handle SystemDictionaryShared::get_shared_jar_url(int shared_path_index, TRAPS) {\n-  Handle url_h;\n-  if (shared_jar_url(shared_path_index) == NULL) {\n-    JavaValue result(T_OBJECT);\n-    const char* path = FileMapInfo::shared_path_name(shared_path_index);\n-    Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));\n-    Klass* classLoaders_klass =\n-        vmClasses::jdk_internal_loader_ClassLoaders_klass();\n-    JavaCalls::call_static(&result, classLoaders_klass,\n-                           vmSymbols::toFileURL_name(),\n-                           vmSymbols::toFileURL_signature(),\n-                           path_string, CHECK_(url_h));\n-\n-    atomic_set_shared_jar_url(shared_path_index, result.get_oop());\n-  }\n-\n-  url_h = Handle(THREAD, shared_jar_url(shared_path_index));\n-  assert(url_h.not_null(), \"sanity\");\n-  return url_h;\n-}\n@@ -762,8 +310,2 @@\n-Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  Handle pkgname_string;\n-  TempNewSymbol pkg = ClassLoader::package_from_class_name(class_name);\n-  if (pkg != NULL) { \/\/ Package prefix found\n-    const char* pkgname = pkg->as_klass_external_name();\n-    pkgname_string = java_lang_String::create_from_str(pkgname,\n-                                                       CHECK_(pkgname_string));\n+  if (!k->can_be_verified_at_dumptime() && k->is_linked()) {\n+    return warn_excluded(k, \"Old class has been linked\");\n@@ -771,2 +313,0 @@\n-  return pkgname_string;\n-}\n@@ -774,24 +314,4 @@\n-\/\/ Define Package for shared app classes from JAR file and also checks for\n-\/\/ package sealing (all done in Java code)\n-\/\/ See http:\/\/docs.oracle.com\/javase\/tutorial\/deployment\/jar\/sealman.html\n-void SystemDictionaryShared::define_shared_package(Symbol*  class_name,\n-                                                   Handle class_loader,\n-                                                   Handle manifest,\n-                                                   Handle url,\n-                                                   TRAPS) {\n-  assert(SystemDictionary::is_system_class_loader(class_loader()), \"unexpected class loader\");\n-  \/\/ get_package_name() returns a NULL handle if the class is in unnamed package\n-  Handle pkgname_string = get_package_name(class_name, CHECK);\n-  if (pkgname_string.not_null()) {\n-    Klass* app_classLoader_klass = vmClasses::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();\n-    JavaValue result(T_OBJECT);\n-    JavaCallArguments args(3);\n-    args.set_receiver(class_loader);\n-    args.push_oop(pkgname_string);\n-    args.push_oop(manifest);\n-    args.push_oop(url);\n-    JavaCalls::call_virtual(&result, app_classLoader_klass,\n-                            vmSymbols::defineOrCheckPackage_name(),\n-                            vmSymbols::defineOrCheckPackage_signature(),\n-                            &args,\n-                            CHECK);\n+  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n+    ResourceMark rm;\n+    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n+    return true;\n@@ -799,1 +319,0 @@\n-}\n@@ -801,27 +320,5 @@\n-\/\/ Get the ProtectionDomain associated with the CodeSource from the classloader.\n-Handle SystemDictionaryShared::get_protection_domain_from_classloader(Handle class_loader,\n-                                                                      Handle url, TRAPS) {\n-  \/\/ CodeSource cs = new CodeSource(url, null);\n-  Handle cs = JavaCalls::construct_new_instance(vmClasses::CodeSource_klass(),\n-                  vmSymbols::url_code_signer_array_void_signature(),\n-                  url, Handle(), CHECK_NH);\n-\n-  \/\/ protection_domain = SecureClassLoader.getProtectionDomain(cs);\n-  Klass* secureClassLoader_klass = vmClasses::SecureClassLoader_klass();\n-  JavaValue obj_result(T_OBJECT);\n-  JavaCalls::call_virtual(&obj_result, class_loader, secureClassLoader_klass,\n-                          vmSymbols::getProtectionDomain_name(),\n-                          vmSymbols::getProtectionDomain_signature(),\n-                          cs, CHECK_NH);\n-  return Handle(THREAD, obj_result.get_oop());\n-}\n-\n-\/\/ Returns the ProtectionDomain associated with the JAR file identified by the url.\n-Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,\n-                                                            int shared_path_index,\n-                                                            Handle url,\n-                                                            TRAPS) {\n-  Handle protection_domain;\n-  if (shared_protection_domain(shared_path_index) == NULL) {\n-    Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);\n-    atomic_set_shared_protection_domain(shared_path_index, pd());\n+  InstanceKlass* super = k->java_super();\n+  if (super != NULL && check_for_exclusion(super, NULL)) {\n+    ResourceMark rm;\n+    log_warning(cds)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n+    return true;\n@@ -830,35 +327,7 @@\n-  \/\/ Acquire from the cache because if another thread beats the current one to\n-  \/\/ set the shared protection_domain and the atomic_set fails, the current thread\n-  \/\/ needs to get the updated protection_domain from the cache.\n-  protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));\n-  assert(protection_domain.not_null(), \"sanity\");\n-  return protection_domain;\n-}\n-\n-\/\/ Returns the ProtectionDomain associated with the moduleEntry.\n-Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,\n-                                                            ModuleEntry* mod, TRAPS) {\n-  ClassLoaderData *loader_data = mod->loader_data();\n-  if (mod->shared_protection_domain() == NULL) {\n-    Symbol* location = mod->location();\n-    if (location != NULL) {\n-      Handle location_string = java_lang_String::create_from_symbol(\n-                                     location, CHECK_NH);\n-      Handle url;\n-      JavaValue result(T_OBJECT);\n-      if (location->starts_with(\"jrt:\/\")) {\n-        url = JavaCalls::construct_new_instance(vmClasses::URL_klass(),\n-                                                vmSymbols::string_void_signature(),\n-                                                location_string, CHECK_NH);\n-      } else {\n-        Klass* classLoaders_klass =\n-          vmClasses::jdk_internal_loader_ClassLoaders_klass();\n-        JavaCalls::call_static(&result, classLoaders_klass, vmSymbols::toFileURL_name(),\n-                               vmSymbols::toFileURL_signature(),\n-                               location_string, CHECK_NH);\n-        url = Handle(THREAD, result.get_oop());\n-      }\n-\n-      Handle pd = get_protection_domain_from_classloader(class_loader, url,\n-                                                         CHECK_NH);\n-      mod->set_shared_protection_domain(loader_data, pd);\n+  Array<InstanceKlass*>* interfaces = k->local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = interfaces->at(i);\n+    if (check_for_exclusion(intf, NULL)) {\n+      log_warning(cds)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n+      return true;\n@@ -868,69 +337,1 @@\n-  Handle protection_domain(THREAD, mod->shared_protection_domain());\n-  assert(protection_domain.not_null(), \"sanity\");\n-  return protection_domain;\n-}\n-\n-\/\/ Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with\n-\/\/ the given InstanceKlass.\n-\/\/ Returns the ProtectionDomain for the InstanceKlass.\n-Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {\n-  Handle pd;\n-\n-  if (ik != NULL) {\n-    int index = ik->shared_classpath_index();\n-    assert(index >= 0, \"Sanity\");\n-    SharedClassPathEntry* ent = FileMapInfo::shared_path(index);\n-    Symbol* class_name = ik->name();\n-\n-    if (ent->is_modules_image()) {\n-      \/\/ For shared app\/platform classes originated from the run-time image:\n-      \/\/   The ProtectionDomains are cached in the corresponding ModuleEntries\n-      \/\/   for fast access by the VM.\n-      \/\/ all packages from module image are already created during VM bootstrap in\n-      \/\/ Modules::define_module().\n-      assert(pkg_entry != NULL, \"archived class in module image cannot be from unnamed package\");\n-      ModuleEntry* mod_entry = pkg_entry->module();\n-      pd = get_shared_protection_domain(class_loader, mod_entry, CHECK_(pd));\n-    } else {\n-      \/\/ For shared app\/platform classes originated from JAR files on the class path:\n-      \/\/   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length\n-      \/\/   as the shared classpath table in the shared archive (see\n-      \/\/   FileMap::_shared_path_table in filemap.hpp for details).\n-      \/\/\n-      \/\/   If a shared InstanceKlass k is loaded from the class path, let\n-      \/\/\n-      \/\/     index = k->shared_classpath_index():\n-      \/\/\n-      \/\/   FileMap::_shared_path_table[index] identifies the JAR file that contains k.\n-      \/\/\n-      \/\/   k's protection domain is:\n-      \/\/\n-      \/\/     ProtectionDomain pd = _shared_protection_domains[index];\n-      \/\/\n-      \/\/   and k's Package is initialized using\n-      \/\/\n-      \/\/     manifest = _shared_jar_manifests[index];\n-      \/\/     url = _shared_jar_urls[index];\n-      \/\/     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-      \/\/\n-      \/\/   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by\n-      \/\/   the corresponding SystemDictionaryShared::get_shared_xxx() function.\n-      Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));\n-      Handle url = get_shared_jar_url(index, CHECK_(pd));\n-      int index_offset = index - ClassLoaderExt::app_class_paths_start_index();\n-      if (index_offset < PackageEntry::max_index_for_defined_in_class_path()) {\n-        if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n-          \/\/ define_shared_package only needs to be called once for each package in a jar specified\n-          \/\/ in the shared class path.\n-          define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-          if (pkg_entry != NULL) {\n-            pkg_entry->set_defined_by_cds_in_class_path(index_offset);\n-          }\n-        }\n-      } else {\n-        define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-      }\n-      pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));\n-    }\n-  }\n-  return pd;\n+  return false; \/\/ false == k should NOT be excluded\n@@ -1016,148 +417,2 @@\n-        }\n-      }\n-\n-      k = load_shared_class_for_builtin_loader(name, class_loader, THREAD);\n-      if (k != NULL) {\n-        SharedClassLoadingMark slm(THREAD, k);\n-        k = find_or_define_instance_class(name, class_loader, k, CHECK_NULL);\n-      }\n-    }\n-  }\n-  return k;\n-}\n-\n-PackageEntry* SystemDictionaryShared::get_package_entry_from_class(InstanceKlass* ik, Handle class_loader) {\n-  PackageEntry* pkg_entry = ik->package();\n-  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != NULL) {\n-    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n-    assert(!ik->is_shared_unregistered_class(), \"unexpected archived package entry for an unregistered class\");\n-    assert(ik->module()->is_named(), \"unexpected archived package entry for a class in an unnamed module\");\n-    return pkg_entry;\n-  }\n-  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(ik->name());\n-  if (pkg_name != NULL) {\n-    pkg_entry = class_loader_data(class_loader)->packages()->lookup_only(pkg_name);\n-  } else {\n-    pkg_entry = NULL;\n-  }\n-  return pkg_entry;\n-}\n-\n-InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(\n-                 Symbol* class_name, Handle class_loader, TRAPS) {\n-  assert(UseSharedSpaces, \"must be\");\n-  InstanceKlass* ik = find_builtin_class(class_name);\n-\n-  if (ik != NULL && !ik->shared_loading_failed()) {\n-    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n-        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n-      SharedClassLoadingMark slm(THREAD, ik);\n-      PackageEntry* pkg_entry = get_package_entry_from_class(ik, class_loader);\n-      Handle protection_domain =\n-        SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);\n-      return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);\n-    }\n-  }\n-  return NULL;\n-}\n-\n-void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {\n-  if (_shared_protection_domains.resolve() == NULL) {\n-    oop spd = oopFactory::new_objArray(\n-        vmClasses::ProtectionDomain_klass(), size, CHECK);\n-    _shared_protection_domains = OopHandle(Universe::vm_global(), spd);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {\n-  if (_shared_jar_urls.resolve() == NULL) {\n-    oop sju = oopFactory::new_objArray(\n-        vmClasses::URL_klass(), size, CHECK);\n-    _shared_jar_urls = OopHandle(Universe::vm_global(), sju);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {\n-  if (_shared_jar_manifests.resolve() == NULL) {\n-    oop sjm = oopFactory::new_objArray(\n-        vmClasses::Jar_Manifest_klass(), size, CHECK);\n-    _shared_jar_manifests = OopHandle(Universe::vm_global(), sjm);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {\n-  allocate_shared_protection_domain_array(size, CHECK);\n-  allocate_shared_jar_url_array(size, CHECK);\n-  allocate_shared_jar_manifest_array(size, CHECK);\n-}\n-\n-\/\/ This function is called for loading only UNREGISTERED classes\n-InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,\n-                                                          Handle class_loader,\n-                                                          Handle protection_domain,\n-                                                          const ClassFileStream* cfs,\n-                                                          TRAPS) {\n-  if (!UseSharedSpaces) {\n-    return NULL;\n-  }\n-  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n-    return NULL;\n-  }\n-  if (class_loader.is_null() ||\n-      SystemDictionary::is_system_class_loader(class_loader()) ||\n-      SystemDictionary::is_platform_class_loader(class_loader())) {\n-    \/\/ Do nothing for the BUILTIN loaders.\n-    return NULL;\n-  }\n-\n-  const RunTimeSharedClassInfo* record = find_record(&_unregistered_dictionary, &_dynamic_unregistered_dictionary, class_name);\n-  if (record == NULL) {\n-    return NULL;\n-  }\n-\n-  int clsfile_size  = cfs->length();\n-  int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs->buffer(), cfs->length());\n-\n-  if (!record->matches(clsfile_size, clsfile_crc32)) {\n-    return NULL;\n-  }\n-\n-  return acquire_class_for_current_thread(record->_klass, class_loader,\n-                                          protection_domain, cfs,\n-                                          THREAD);\n-}\n-\n-InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(\n-                   InstanceKlass *ik,\n-                   Handle class_loader,\n-                   Handle protection_domain,\n-                   const ClassFileStream *cfs,\n-                   TRAPS) {\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n-\n-  {\n-    MutexLocker mu(THREAD, SharedDictionary_lock);\n-    if (ik->class_loader_data() != NULL) {\n-      \/\/    ik is already loaded (by this loader or by a different loader)\n-      \/\/ or ik is being loaded by a different thread (by this loader or by a different loader)\n-      return NULL;\n-    }\n-\n-    \/\/ No other thread has acquired this yet, so give it to *this thread*\n-    ik->set_class_loader_data(loader_data);\n-  }\n-\n-  \/\/ No longer holding SharedDictionary_lock\n-  \/\/ No need to lock, as <ik> can be held only by a single thread.\n-  loader_data->add_class(ik);\n-\n-  \/\/ Get the package entry.\n-  PackageEntry* pkg_entry = get_package_entry_from_class(ik, class_loader);\n-\n-  \/\/ Load and check super\/interfaces, restore unsharable info\n-  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,\n-                                                  cfs, pkg_entry, THREAD);\n-  if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {\n-    \/\/ TODO: clean up <ik> so it can be used again\n-    return NULL;\n-  }\n+        }\n+      }\n@@ -1165,1 +420,8 @@\n-  return shared_klass;\n+      k = load_shared_class_for_builtin_loader(name, class_loader, THREAD);\n+      if (k != NULL) {\n+        SharedClassLoadingMark slm(THREAD, k);\n+        k = find_or_define_instance_class(name, class_loader, k, CHECK_NULL);\n+      }\n+    }\n+  }\n+  return k;\n@@ -1168,2 +430,2 @@\n-class LoadedUnregisteredClassesTable : public ResourceHashtable<\n-  Symbol*, bool,\n+class UnregisteredClassesTable : public ResourceHashtable<\n+  Symbol*, InstanceKlass*,\n@@ -1172,1 +434,1 @@\n-  6661,                             \/\/ prime number\n+  15889, \/\/ prime number\n@@ -1175,1 +437,1 @@\n-static LoadedUnregisteredClassesTable* _loaded_unregistered_classes = NULL;\n+static UnregisteredClassesTable* _unregistered_classes_table = NULL;\n@@ -1177,6 +439,9 @@\n-bool SystemDictionaryShared::add_unregistered_class(Thread* current, InstanceKlass* k) {\n-  \/\/ We don't allow duplicated unregistered classes of the same name.\n-  assert(DumpSharedSpaces, \"only when dumping\");\n-  Symbol* name = k->name();\n-  if (_loaded_unregistered_classes == NULL) {\n-    _loaded_unregistered_classes = new (ResourceObj::C_HEAP, mtClass)LoadedUnregisteredClassesTable();\n+bool SystemDictionaryShared::add_unregistered_class(Thread* current, InstanceKlass* klass) {\n+  \/\/ We don't allow duplicated unregistered classes with the same name.\n+  \/\/ We only archive the first class with that name that succeeds putting\n+  \/\/ itself into the table.\n+  Arguments::assert_is_dumping_archive();\n+  MutexLocker ml(current, UnregisteredClassesTable_lock);\n+  Symbol* name = klass->name();\n+  if (_unregistered_classes_table == NULL) {\n+    _unregistered_classes_table = new (ResourceObj::C_HEAP, mtClass)UnregisteredClassesTable();\n@@ -1184,2 +449,2 @@\n-  bool created = false;\n-  _loaded_unregistered_classes->put_if_absent(name, true, &created);\n+  bool created;\n+  InstanceKlass** v = _unregistered_classes_table->put_if_absent(name, klass, &created);\n@@ -1187,0 +452,9 @@\n+    name->increment_refcount();\n+  }\n+  return (klass == *v);\n+}\n+\n+\/\/ true == class was successfully added; false == a duplicated class (with the same name) already exists.\n+bool SystemDictionaryShared::add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k) {\n+  assert(DumpSharedSpaces, \"only when dumping\");\n+  if (add_unregistered_class(current, k)) {\n@@ -1189,0 +463,3 @@\n+    return true;\n+  } else {\n+    return false;\n@@ -1190,1 +467,0 @@\n-  return created;\n@@ -1232,18 +508,0 @@\n-void SystemDictionaryShared::start_dumping() {\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-  _dump_in_progress = true;\n-}\n-\n-DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-  return find_or_allocate_info_for_locked(k);\n-}\n-\n-DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for_locked(InstanceKlass* k) {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  if (_dumptime_table == NULL) {\n-    _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();\n-  }\n-  return _dumptime_table->find_or_allocate_info_for(k, _dump_in_progress);\n-}\n-\n@@ -1253,1 +511,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1266,1 +524,1 @@\n-  DumpTimeSharedClassInfo* p = _dumptime_table->get(k);\n+  DumpTimeClassInfo* p = _dumptime_table->get(k);\n@@ -1272,1 +530,1 @@\n-      DumpTimeSharedClassInfo::DTVerifierConstraint constraint = p->_verifier_constraints->at(i);\n+      DumpTimeClassInfo::DTVerifierConstraint constraint = p->_verifier_constraints->at(i);\n@@ -1280,1 +538,1 @@\n-    FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTVerifierConstraint, p->_verifier_constraints);\n+    FREE_C_HEAP_ARRAY(DumpTimeClassInfo::DTVerifierConstraint, p->_verifier_constraints);\n@@ -1287,1 +545,1 @@\n-      DumpTimeSharedClassInfo::DTLoaderConstraint ld =  p->_loader_constraints->at(i);\n+      DumpTimeClassInfo::DTLoaderConstraint ld =  p->_loader_constraints->at(i);\n@@ -1292,1 +550,1 @@\n-    FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTLoaderConstraint, p->_loader_constraints);\n+    FREE_C_HEAP_ARRAY(DumpTimeClassInfo::DTLoaderConstraint, p->_loader_constraints);\n@@ -1298,48 +556,2 @@\n-bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {\n-  while (k) {\n-    if (k->name()->equals(\"jdk\/internal\/event\/Event\")) {\n-      return true;\n-    }\n-    k = k->java_super();\n-  }\n-  return false;\n-}\n-\n-bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(ik);\n-  return (info != NULL) ? info->_is_archived_lambda_proxy : false;\n-}\n-\n-bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {\n-  assert(ik->is_shared(), \"applicable to only a shared class\");\n-  if (ik->is_hidden()) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-bool SystemDictionaryShared::is_early_klass(InstanceKlass* ik) {\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(ik);\n-  return (info != NULL) ? info->is_early_klass() : false;\n-}\n-\n-\/\/ Returns true so the caller can do:    return warn_excluded(\".....\");\n-bool SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {\n-  ResourceMark rm;\n-  log_warning(cds)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n-  return true;\n-}\n-\n-bool SystemDictionaryShared::check_for_exclusion(InstanceKlass* k, DumpTimeSharedClassInfo* info) {\n-  if (MetaspaceShared::is_in_shared_metaspace(k)) {\n-    \/\/ We have reached a super type that's already in the base archive. Treat it\n-    \/\/ as \"not excluded\".\n-    assert(DynamicDumpSharedSpaces, \"must be\");\n-    return false;\n-  }\n-\n-  if (info == NULL) {\n-    info = _dumptime_table->get(k);\n-    assert(info != NULL, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n-  }\n+void SystemDictionaryShared::handle_class_unloading(InstanceKlass* klass) {\n+  remove_dumptime_info(klass);\n@@ -1347,3 +559,8 @@\n-  if (!info->has_checked_exclusion()) {\n-    if (check_for_exclusion_impl(k)) {\n-      info->set_excluded();\n+  if (_unregistered_classes_table != NULL) {\n+    \/\/ Remove the class from _unregistered_classes_table: keep the entry but\n+    \/\/ set it to NULL. This ensure no classes with the same name can be\n+    \/\/ added again.\n+    MutexLocker ml(Thread::current(), UnregisteredClassesTable_lock);\n+    InstanceKlass** v = _unregistered_classes_table->get(klass->name());\n+    if (v != NULL) {\n+      *v = NULL;\n@@ -1351,1 +568,0 @@\n-    info->set_has_checked_exclusion();\n@@ -1353,2 +569,0 @@\n-\n-  return info->is_excluded();\n@@ -1375,83 +589,0 @@\n-bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {\n-  if (k->is_in_error_state()) {\n-    return warn_excluded(k, \"In error state\");\n-  }\n-  if (has_been_redefined(k)) {\n-    return warn_excluded(k, \"Has been redefined\");\n-  }\n-  if (!k->is_hidden() && k->shared_classpath_index() < 0 && is_builtin(k)) {\n-    \/\/ These are classes loaded from unsupported locations (such as those loaded by JVMTI native\n-    \/\/ agent during dump time).\n-    return warn_excluded(k, \"Unsupported location\");\n-  }\n-  if (k->signers() != NULL) {\n-    \/\/ We cannot include signed classes in the archive because the certificates\n-    \/\/ used during dump time may be different than those used during\n-    \/\/ runtime (due to expiration, etc).\n-    return warn_excluded(k, \"Signed JAR\");\n-  }\n-  if (is_jfr_event_class(k)) {\n-    \/\/ We cannot include JFR event classes because they need runtime-specific\n-    \/\/ instrumentation in order to work with -XX:FlightRecorderOptions:retransform=false.\n-    \/\/ There are only a small number of these classes, so it's not worthwhile to\n-    \/\/ support them and make CDS more complicated.\n-    return warn_excluded(k, \"JFR event class\");\n-  }\n-  if (k->init_state() < InstanceKlass::linked) {\n-    \/\/ In CDS dumping, we will attempt to link all classes. Those that fail to link will\n-    \/\/ be recorded in DumpTimeSharedClassInfo.\n-    Arguments::assert_is_dumping_archive();\n-\n-    \/\/ TODO -- rethink how this can be handled.\n-    \/\/ We should try to link ik, however, we can't do it here because\n-    \/\/ 1. We are at VM exit\n-    \/\/ 2. linking a class may cause other classes to be loaded, which means\n-    \/\/    a custom ClassLoader.loadClass() may be called, at a point where the\n-    \/\/    class loader doesn't expect it.\n-    if (has_class_failed_verification(k)) {\n-      return warn_excluded(k, \"Failed verification\");\n-    } else {\n-      if (k->can_be_verified_at_dumptime()) {\n-        return warn_excluded(k, \"Not linked\");\n-      }\n-    }\n-  }\n-  if (DynamicDumpSharedSpaces && k->major_version() < 50 \/*JAVA_6_VERSION*\/) {\n-    \/\/ In order to support old classes during dynamic dump, class rewriting needs to\n-    \/\/ be reverted. This would result in more complex code and testing but not much gain.\n-    ResourceMark rm;\n-    log_warning(cds)(\"Pre JDK 6 class not supported by CDS: %u.%u %s\",\n-                     k->major_version(),  k->minor_version(), k->name()->as_C_string());\n-    return true;\n-  }\n-\n-  if (!k->can_be_verified_at_dumptime() && k->is_linked()) {\n-    return warn_excluded(k, \"Old class has been linked\");\n-  }\n-\n-  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n-    ResourceMark rm;\n-    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n-    return true;\n-  }\n-\n-  InstanceKlass* super = k->java_super();\n-  if (super != NULL && check_for_exclusion(super, NULL)) {\n-    ResourceMark rm;\n-    log_warning(cds)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n-    return true;\n-  }\n-\n-  Array<InstanceKlass*>* interfaces = k->local_interfaces();\n-  int len = interfaces->length();\n-  for (int i = 0; i < len; i++) {\n-    InstanceKlass* intf = interfaces->at(i);\n-    if (check_for_exclusion(intf, NULL)) {\n-      log_warning(cds)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n-      return true;\n-    }\n-  }\n-\n-  return false; \/\/ false == k should NOT be excluded\n-}\n-\n@@ -1462,1 +593,1 @@\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(k);\n+  DumpTimeClassInfo* info = _dumptime_table->get(k);\n@@ -1479,0 +610,42 @@\n+class UnregisteredClassesDuplicationChecker : StackObj {\n+  GrowableArray<InstanceKlass*> _list;\n+  Thread* _thread;\n+public:\n+  UnregisteredClassesDuplicationChecker() : _thread(Thread::current()) {}\n+\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!SystemDictionaryShared::is_builtin(k)) {\n+      _list.append(k);\n+    }\n+    return true;  \/\/ keep on iterating\n+  }\n+\n+  static int compare_by_loader(InstanceKlass** a, InstanceKlass** b) {\n+    ClassLoaderData* loader_a = a[0]->class_loader_data();\n+    ClassLoaderData* loader_b = b[0]->class_loader_data();\n+\n+    if (loader_a != loader_b) {\n+      return intx(loader_a) - intx(loader_b);\n+    } else {\n+      return intx(a[0]) - intx(b[0]);\n+    }\n+  }\n+\n+  void mark_duplicated_classes() {\n+    \/\/ Two loaders may load two identical or similar hierarchies of classes. If we\n+    \/\/ check for duplication in random order, we may end up excluding important base classes\n+    \/\/ in both hierarchies, causing most of the classes to be excluded.\n+    \/\/ We sort the classes by their loaders. This way we're likely to archive\n+    \/\/ all classes in the one of the two hierarchies.\n+    _list.sort(compare_by_loader);\n+    for (int i = 0; i < _list.length(); i++) {\n+      InstanceKlass* k = _list.at(i);\n+      bool i_am_first = SystemDictionaryShared::add_unregistered_class(_thread, k);\n+      if (!i_am_first) {\n+        SystemDictionaryShared::warn_excluded(k, \"Duplicated unregistered class\");\n+        SystemDictionaryShared::set_excluded_locked(k);\n+      }\n+    }\n+  }\n+};\n+\n@@ -1481,1 +654,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1488,0 +661,12 @@\n+  assert(no_class_loading_should_happen(), \"sanity\");\n+  assert_lock_strong(DumpTimeTable_lock);\n+\n+  if (DynamicDumpSharedSpaces) {\n+    \/\/ Do this first -- if a base class is excluded due to duplication,\n+    \/\/ all of its subclasses will also be excluded by ExcludeDumpTimeSharedClasses\n+    ResourceMark rm;\n+    UnregisteredClassesDuplicationChecker dup_checker;\n+    _dumptime_table->iterate(&dup_checker);\n+    dup_checker.mark_duplicated_classes();\n+  }\n+\n@@ -1497,1 +682,1 @@\n-  DumpTimeSharedClassInfo* p = find_or_allocate_info_for_locked(k);\n+  DumpTimeClassInfo* p = find_or_allocate_info_for_locked(k);\n@@ -1501,0 +686,9 @@\n+void SystemDictionaryShared::set_excluded_locked(InstanceKlass* k) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  Arguments::assert_is_dumping_archive();\n+  DumpTimeClassInfo* info = find_or_allocate_info_for_locked(k);\n+  if (info != NULL) {\n+    info->set_excluded();\n+  }\n+}\n+\n@@ -1503,1 +697,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1511,1 +705,1 @@\n-  DumpTimeSharedClassInfo* p = find_or_allocate_info_for(ik);\n+  DumpTimeClassInfo* p = find_or_allocate_info_for(ik);\n@@ -1524,1 +718,1 @@\n-  DumpTimeSharedClassInfo* p = _dumptime_table->get(ik);\n+  DumpTimeClassInfo* p = _dumptime_table->get(ik);\n@@ -1533,1 +727,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1570,1 +764,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1596,14 +790,6 @@\n-void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {\n-  if (_verifier_constraints == NULL) {\n-    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n-  }\n-  if (_verifier_constraint_flags == NULL) {\n-    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n-  }\n-  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n-  for (int i = 0; i < vc_array->length(); i++) {\n-    DTVerifierConstraint* p = vc_array->adr_at(i);\n-    if (name == p->_name && from_name == p->_from_name) {\n-      return;\n-    }\n+void SystemDictionaryShared::add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey& key,\n+                                                           InstanceKlass* proxy_klass) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  if (_dumptime_lambda_proxy_class_dictionary == NULL) {\n+    _dumptime_lambda_proxy_class_dictionary =\n+      new (ResourceObj::C_HEAP, mtClass)DumpTimeLambdaProxyClassDictionary();\n@@ -1611,15 +797,10 @@\n-  DTVerifierConstraint cons(name, from_name);\n-  vc_array->append(cons);\n-\n-  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n-  char c = 0;\n-  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n-  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n-  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n-  vcflags_array->append(c);\n-\n-  if (log_is_enabled(Trace, cds, verification)) {\n-    ResourceMark rm;\n-    log_trace(cds, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n-                                 k->external_name(), from_name->as_klass_external_name(),\n-                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+  DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n+  if (lambda_info == NULL) {\n+    DumpTimeLambdaProxyClassInfo info;\n+    info.add_proxy_klass(proxy_klass);\n+    _dumptime_lambda_proxy_class_dictionary->put(key, info);\n+    \/\/lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n+    \/\/assert(lambda_info->_proxy_klass == proxy_klass, \"must be\"); \/\/ debug only -- remove\n+    ++_dumptime_lambda_proxy_class_dictionary->_count;\n+  } else {\n+    lambda_info->add_proxy_klass(proxy_klass);\n@@ -1649,1 +830,1 @@\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(lambda_ik);\n+  DumpTimeClassInfo* info = _dumptime_table->get(lambda_ik);\n@@ -1653,1 +834,1 @@\n-    \/\/ Set _is_archived_lambda_proxy in DumpTimeSharedClassInfo so that the lambda_ik\n+    \/\/ Set _is_archived_lambda_proxy in DumpTimeClassInfo so that the lambda_ik\n@@ -1714,1 +895,1 @@\n-  RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(lambda_ik);\n+  RunTimeClassInfo* record = RunTimeClassInfo::get_for(lambda_ik);\n@@ -1724,1 +905,1 @@\n-    protection_domain = SystemDictionaryShared::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);\n+    protection_domain = CDSProtectionDomain::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);\n@@ -1764,58 +945,0 @@\n-static char get_loader_type_by(oop  loader) {\n-  assert(SystemDictionary::is_builtin_class_loader(loader), \"Must be built-in loader\");\n-  if (SystemDictionary::is_boot_class_loader(loader)) {\n-    return (char)ClassLoader::BOOT_LOADER;\n-  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-    return (char)ClassLoader::PLATFORM_LOADER;\n-  } else {\n-    assert(SystemDictionary::is_system_class_loader(loader), \"Class loader mismatch\");\n-    return (char)ClassLoader::APP_LOADER;\n-  }\n-}\n-\n-static oop get_class_loader_by(char type) {\n-  if (type == (char)ClassLoader::BOOT_LOADER) {\n-    return (oop)NULL;\n-  } else if (type == (char)ClassLoader::PLATFORM_LOADER) {\n-    return SystemDictionary::java_platform_loader();\n-  } else {\n-    assert (type == (char)ClassLoader::APP_LOADER, \"Sanity\");\n-    return SystemDictionary::java_system_loader();\n-  }\n-}\n-\n-void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {\n-  assert(loader1 != loader2, \"sanity\");\n-  LogTarget(Info, class, loader, constraints) log;\n-  if (_loader_constraints == NULL) {\n-    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n-  }\n-  char lt1 = get_loader_type_by(loader1());\n-  char lt2 = get_loader_type_by(loader2());\n-  DTLoaderConstraint lc(name, lt1, lt2);\n-  for (int i = 0; i < _loader_constraints->length(); i++) {\n-    DTLoaderConstraint dt = _loader_constraints->at(i);\n-    if (lc.equals(dt)) {\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n-        log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]\",\n-                  _klass->external_name(), name->as_C_string(),\n-                  ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n-                  ClassLoaderData::class_loader_data(loader2())->loader_name_and_id());\n-      }\n-      return;\n-    }\n-  }\n-  _loader_constraints->append(lc);\n-  if (log.is_enabled()) {\n-    ResourceMark rm;\n-    \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n-    log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]\",\n-              _klass->external_name(), name->as_C_string(),\n-              ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n-              ClassLoaderData::class_loader_data(loader2())->loader_name_and_id(),\n-              _loader_constraints->length());\n-  }\n-}\n-\n@@ -1825,1 +948,1 @@\n-  RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(klass);\n+  RunTimeClassInfo* record = RunTimeClassInfo::get_for(klass);\n@@ -1830,1 +953,1 @@\n-      RunTimeSharedClassInfo::RTVerifierConstraint* vc = record->verifier_constraint_at(i);\n+      RunTimeClassInfo::RTVerifierConstraint* vc = record->verifier_constraint_at(i);\n@@ -1863,0 +986,11 @@\n+static oop get_class_loader_by(char type) {\n+  if (type == (char)ClassLoader::BOOT_LOADER) {\n+    return (oop)NULL;\n+  } else if (type == (char)ClassLoader::PLATFORM_LOADER) {\n+    return SystemDictionary::java_platform_loader();\n+  } else {\n+    assert (type == (char)ClassLoader::APP_LOADER, \"Sanity\");\n+    return SystemDictionary::java_system_loader();\n+  }\n+}\n+\n@@ -1923,1 +1057,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(klass);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(klass);\n@@ -1939,1 +1073,1 @@\n-    RunTimeSharedClassInfo* info = RunTimeSharedClassInfo::get_for(klass);\n+    RunTimeClassInfo* info = RunTimeClassInfo::get_for(klass);\n@@ -1944,1 +1078,1 @@\n-        RunTimeSharedClassInfo::RTLoaderConstraint* lc = info->loader_constraint_at(i);\n+        RunTimeClassInfo::RTLoaderConstraint* lc = info->loader_constraint_at(i);\n@@ -2035,1 +1169,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -2037,1 +1171,1 @@\n-      size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n@@ -2144,1 +1278,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -2146,3 +1280,3 @@\n-      size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n-      RunTimeSharedClassInfo* record;\n-      record = (RunTimeSharedClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n+      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      RunTimeClassInfo* record;\n+      record = (RunTimeClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n@@ -2165,2 +1299,2 @@\n-      \/\/ Save this for quick runtime lookup of InstanceKlass* -> RunTimeSharedClassInfo*\n-      RunTimeSharedClassInfo::set_for(info._klass, record);\n+      \/\/ Save this for quick runtime lookup of InstanceKlass* -> RunTimeClassInfo*\n+      RunTimeClassInfo::set_for(info._klass, record);\n@@ -2238,1 +1372,1 @@\n-const RunTimeSharedClassInfo*\n+const RunTimeClassInfo*\n@@ -2246,1 +1380,1 @@\n-  const RunTimeSharedClassInfo* record = NULL;\n+  const RunTimeClassInfo* record = NULL;\n@@ -2274,1 +1408,1 @@\n-  const RunTimeSharedClassInfo* record = find_record(&_builtin_dictionary, &_dynamic_builtin_dictionary, name);\n+  const RunTimeClassInfo* record = find_record(&_builtin_dictionary, &_dynamic_builtin_dictionary, name);\n@@ -2286,1 +1420,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -2314,1 +1448,1 @@\n-  void do_value(const RunTimeSharedClassInfo* record) {\n+  void do_value(const RunTimeClassInfo* record) {\n@@ -2395,1 +1529,1 @@\n-bool SystemDictionaryShared::empty_dumptime_table() {\n+bool SystemDictionaryShared::is_dumptime_table_empty() {\n@@ -2427,1 +1561,1 @@\n-  void do_value(const RunTimeSharedClassInfo* info) {\n+  void do_value(const RunTimeClassInfo* info) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":372,"deletions":1238,"binary":false,"changes":1610,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"cds\/runTimeClassInfo.hpp\"\n@@ -109,1 +112,1 @@\n-class DumpTimeSharedClassInfo;\n+class DumpTimeClassInfo;\n@@ -112,1 +115,1 @@\n-class RunTimeSharedClassInfo;\n+class RunTimeClassInfo;\n@@ -114,0 +117,2 @@\n+class DumpTimeLambdaProxyClassDictionary;\n+class LambdaProxyClassKey;\n@@ -142,7 +147,11 @@\n-  \/\/ These _shared_xxxs arrays are used to initialize the java.lang.Package and\n-  \/\/ java.security.ProtectionDomain objects associated with each shared class.\n-  \/\/\n-  \/\/ See SystemDictionaryShared::init_security_info for more info.\n-  static OopHandle _shared_protection_domains;\n-  static OopHandle _shared_jar_urls;\n-  static OopHandle _shared_jar_manifests;\n+\n+  static DumpTimeSharedClassTable* _dumptime_table;\n+  static DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary;\n+  \/\/ SystemDictionaries in the base layer static archive\n+  static RunTimeSharedDictionary _builtin_dictionary;\n+  static RunTimeSharedDictionary _unregistered_dictionary;\n+  static LambdaProxyClassDictionary _lambda_proxy_class_dictionary;\n+  \/\/ SystemDictionaries in the top layer dynamic archive\n+  static RunTimeSharedDictionary _dynamic_builtin_dictionary;\n+  static RunTimeSharedDictionary _dynamic_unregistered_dictionary;\n+  static LambdaProxyClassDictionary _dynamic_lambda_proxy_class_dictionary;\n@@ -154,66 +163,0 @@\n-  static Handle get_package_name(Symbol*  class_name, TRAPS);\n-\n-  static PackageEntry* get_package_entry_from_class(InstanceKlass* ik, Handle class_loader);\n-\n-\n-  \/\/ Package handling:\n-  \/\/\n-  \/\/ 1. For named modules in the runtime image\n-  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces\n-  \/\/                  to get packages in named modules for shared classes.\n-  \/\/                  Package for non-shared classes in named module is also\n-  \/\/                  handled using JVM_GetSystemPackage(s).\n-  \/\/\n-  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::definePackage(String, Module)\n-  \/\/                  to define package for shared app classes from named\n-  \/\/                  modules.\n-  \/\/\n-  \/\/    PLATFORM  classes: VM calls ClassLoaders.PlatformClassLoader::definePackage(String, Module)\n-  \/\/                  to define package for shared platform classes from named\n-  \/\/                  modules.\n-  \/\/\n-  \/\/ 2. For unnamed modules\n-  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces to\n-  \/\/                  get packages for shared boot classes in unnamed modules.\n-  \/\/\n-  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::defineOrCheckPackage()\n-  \/\/                  with with the manifest and url from archived data.\n-  \/\/\n-  \/\/    PLATFORM  classes: No package is defined.\n-  \/\/\n-  \/\/ The following two define_shared_package() functions are used to define\n-  \/\/ package for shared APP and PLATFORM classes.\n-  static void define_shared_package(Symbol*  class_name,\n-                                    Handle class_loader,\n-                                    Handle manifest,\n-                                    Handle url,\n-                                    TRAPS);\n-\n-  static Handle get_shared_jar_manifest(int shared_path_index, TRAPS);\n-  static Handle get_shared_jar_url(int shared_path_index, TRAPS);\n-  static Handle get_protection_domain_from_classloader(Handle class_loader,\n-                                                       Handle url, TRAPS);\n-  static Handle get_shared_protection_domain(Handle class_loader,\n-                                             int shared_path_index,\n-                                             Handle url,\n-                                             TRAPS);\n-  static Handle get_shared_protection_domain(Handle class_loader,\n-                                             ModuleEntry* mod, TRAPS);\n-\n-  static void atomic_set_array_index(OopHandle array, int index, oop o);\n-\n-  static oop shared_protection_domain(int index);\n-  static void atomic_set_shared_protection_domain(int index, oop pd) {\n-    atomic_set_array_index(_shared_protection_domains, index, pd);\n-  }\n-  static void allocate_shared_protection_domain_array(int size, TRAPS);\n-  static oop shared_jar_url(int index);\n-  static void atomic_set_shared_jar_url(int index, oop url) {\n-    atomic_set_array_index(_shared_jar_urls, index, url);\n-  }\n-  static void allocate_shared_jar_url_array(int size, TRAPS);\n-  static oop shared_jar_manifest(int index);\n-  static void atomic_set_shared_jar_manifest(int index, oop man) {\n-    atomic_set_array_index(_shared_jar_manifests, index, man);\n-  }\n-  static void allocate_shared_jar_manifest_array(int size, TRAPS);\n@@ -226,2 +169,2 @@\n-  static DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k);\n-  static DumpTimeSharedClassInfo* find_or_allocate_info_for_locked(InstanceKlass* k);\n+  static DumpTimeClassInfo* find_or_allocate_info_for(InstanceKlass* k);\n+  static DumpTimeClassInfo* find_or_allocate_info_for_locked(InstanceKlass* k);\n@@ -233,1 +176,0 @@\n-  static bool warn_excluded(InstanceKlass* k, const char* reason);\n@@ -235,0 +177,1 @@\n+  static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;\n@@ -248,1 +191,0 @@\n-  static Handle init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS);\n@@ -251,1 +193,1 @@\n-  static const RunTimeSharedClassInfo* find_record(RunTimeSharedDictionary* static_dict,\n+  static const RunTimeClassInfo* find_record(RunTimeSharedDictionary* static_dict,\n@@ -268,1 +210,1 @@\n-  static bool add_unregistered_class(Thread* current, InstanceKlass* k);\n+  static bool add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k);\n@@ -273,1 +215,1 @@\n-  static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;\n+  static void handle_class_unloading(InstanceKlass* k) NOT_CDS_RETURN;\n@@ -310,0 +252,2 @@\n+  static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey& key,\n+                                                             InstanceKlass* proxy_klass) NOT_CDS_RETURN;\n@@ -325,0 +269,1 @@\n+  static bool add_unregistered_class(Thread* current, InstanceKlass* k);\n@@ -326,1 +271,1 @@\n-  static bool check_for_exclusion(InstanceKlass* k, DumpTimeSharedClassInfo* info);\n+  static bool check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info);\n@@ -330,0 +275,2 @@\n+  static void set_excluded_locked(InstanceKlass* k);\n+  static bool warn_excluded(InstanceKlass* k, const char* reason);\n@@ -341,1 +288,1 @@\n-  static bool empty_dumptime_table() NOT_CDS_RETURN_(true);\n+  static bool is_dumptime_table_empty() NOT_CDS_RETURN_(true);\n@@ -343,1 +290,0 @@\n-  static Handle create_jar_manifest(const char* man, size_t size, TRAPS) NOT_CDS_RETURN_(Handle());\n@@ -345,1 +291,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":31,"deletions":86,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n@@ -470,5 +471,0 @@\n-#ifdef COMPILER1\n-  case vmIntrinsics::_checkIndex:\n-    if (!InlineNIOCheckIndex) return true;\n-    break;\n-#endif \/\/ COMPILER1\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -344,4 +344,0 @@\n-  do_class(java_nio_Buffer,               \"java\/nio\/Buffer\")                                                            \\\n-  do_intrinsic(_checkIndex,               java_nio_Buffer,        checkIndex_name, int_int_signature,            F_R)   \\\n-   do_name(     checkIndex_name,                                 \"checkIndex\")                                          \\\n-                                                                                                                        \\\n@@ -460,1 +456,1 @@\n-   do_signature(decodeBlock_signature, \"([BII[BIZ)I\")                                                                   \\\n+   do_signature(decodeBlock_signature, \"([BII[BIZZ)I\")                                                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  template(java_nio_Buffer,                           \"java\/nio\/Buffer\")                          \\\n@@ -485,0 +486,1 @@\n+  template(checkIndex_name,                           \"checkIndex\")                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1080,6 +1080,0 @@\n-\/\/ Just marks the methods in this class as needing deoptimization\n-void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-}\n-\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  static void mark_for_evol_deoptimization(InstanceKlass* dependee);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    return thread->as_Java_thread()->thread_state() == _thread_in_vm;\n+    return JavaThread::cast(thread)->thread_state() == _thread_in_vm;\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,2 +272,1 @@\n-  \/\/ locate the owner and stack slot for the BasicLock so that we can\n-  \/\/ properly revoke the bias of the owner if necessary. They are\n+  \/\/ locate the owner and stack slot for the BasicLock. They are\n@@ -278,5 +277,2 @@\n-  \/\/ sharing between platforms. Note that currently biased locking\n-  \/\/ will never cause Class instances to be biased but this code\n-  \/\/ handles the static synchronized case as well.\n-  \/\/ JVMTI's GetLocalInstance() also uses these offsets to find the receiver\n-  \/\/ for non-static native wrapper frames.\n+  \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n+  \/\/ offsets to find the receiver for non-static native wrapper frames.\n@@ -739,1 +735,1 @@\n-  \/\/ UseBiasedLocking support\n+  \/\/ JVMTI's GetLocalInstance() support\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1011,1 +1011,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1013,1 +1013,1 @@\n-        tty->print_cr(\"Added initial compiler thread %s\", ct->get_thread_name());\n+        tty->print_cr(\"Added initial compiler thread %s\", ct->name());\n@@ -1032,1 +1032,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1034,1 +1034,1 @@\n-        tty->print_cr(\"Added initial compiler thread %s\", ct->get_thread_name());\n+        tty->print_cr(\"Added initial compiler thread %s\", ct->name());\n@@ -1119,1 +1119,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1122,1 +1122,1 @@\n-                      ct->get_thread_name(), (int)(available_memory\/M), (int)(available_cc_np\/M));\n+                      ct->name(), (int)(available_memory\/M), (int)(available_cc_np\/M));\n@@ -1140,1 +1140,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1143,1 +1143,1 @@\n-                      ct->get_thread_name(), (int)(available_memory\/M), (int)(available_cc_p\/M));\n+                      ct->name(), (int)(available_memory\/M), (int)(available_cc_p\/M));\n@@ -1279,1 +1279,1 @@\n-        vframeStream vfst(thread->as_Java_thread());\n+        vframeStream vfst(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -758,0 +758,11 @@\n+void* Disassembler::dll_load(char* buf, int buflen, int offset, char* ebuf, int ebuflen, outputStream* st) {\n+  int sz = buflen - offset;\n+  int written = jio_snprintf(&buf[offset], sz, \"%s%s\", hsdis_library_name, os::dll_file_extension());\n+  if (written < sz) { \/\/ written successfully, not truncated.\n+    if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n+    return os::dll_load(buf, ebuf, ebuflen);\n+  } else if (Verbose) {\n+    st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n+  }\n+  return NULL;\n+}\n@@ -807,8 +818,1 @@\n-    if (jvm_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-      strcpy(&buf[jvm_offset], hsdis_library_name);\n-      strcat(&buf[jvm_offset], os::dll_file_extension());\n-      if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-      _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-    } else {\n-      if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-    }\n+    _library = dll_load(buf, sizeof buf, jvm_offset, ebuf, sizeof ebuf, st);\n@@ -817,8 +821,1 @@\n-      if (lib_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-        strcpy(&buf[lib_offset], hsdis_library_name);\n-        strcat(&buf[lib_offset], os::dll_file_extension());\n-        if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-        _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-      } else {\n-        if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-      }\n+      _library = dll_load(buf, sizeof buf, lib_offset, ebuf, sizeof ebuf, st);\n@@ -832,8 +829,1 @@\n-        if (lib_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-          strcpy(&buf[lib_offset], hsdis_library_name);\n-          strcat(&buf[lib_offset], os::dll_file_extension());\n-          if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-          _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-        } else {\n-          if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-        }\n+        _library = dll_load(buf, sizeof buf, lib_offset, ebuf, sizeof ebuf, st);\n@@ -844,5 +834,1 @@\n-    \/\/ 4. hsdis-<arch>.so  (using LD_LIBRARY_PATH)\n-    strcpy(&buf[0], hsdis_library_name);\n-    strcat(&buf[0], os::dll_file_extension());\n-    if (Verbose) st->print_cr(\"Trying to load: %s via LD_LIBRARY_PATH or equivalent\", buf);\n-    _library = os::dll_load(buf, ebuf, sizeof ebuf);\n+    _library = dll_load(buf, sizeof buf, 0, ebuf, sizeof ebuf, st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+  static void* dll_load(char* buf, int buflen, int offset, char* ebuf, int ebuflen, outputStream* st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -296,2 +296,1 @@\n-  \/\/ Cast away constness:\n-  ((VirtualSpace)_virtual_space).print_on(st);\n+  _virtual_space.print_on(st);\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -53,2 +55,6 @@\n-  \/\/ The remembered set needs the heap regions set up.\n-  HeapRegionRemSet::setup_remset_size();\n+  SpaceAlignment = HeapRegion::GrainBytes;\n+  HeapAlignment = calculate_heap_alignment(SpaceAlignment);\n+\n+  \/\/ We need to initialize card set configuration as soon as heap region size is\n+  \/\/ known as it depends on it and is used really early.\n+  initialize_card_set_configuration();\n@@ -58,1 +64,1 @@\n-    FLAG_SET_ERGO(G1EagerReclaimRemSetThreshold, G1RSetSparseRegionEntries);\n+    FLAG_SET_ERGO(G1EagerReclaimRemSetThreshold, G1RemSetArrayOfCardsEntries);\n@@ -60,3 +66,0 @@\n-\n-  SpaceAlignment = HeapRegion::GrainBytes;\n-  HeapAlignment = calculate_heap_alignment(SpaceAlignment);\n@@ -93,0 +96,2 @@\n+  } else if (strcmp(type, \"young-evac-fail\") == 0) {\n+    G1HeapVerifier::enable_verification_type(G1HeapVerifier::G1VerifyYoungEvacFail);\n@@ -101,1 +106,1 @@\n-                            \"young-normal, concurrent-start, mixed, remark, cleanup and full\", type);\n+                            \"young-normal, young-evac-fail, concurrent-start, mixed, remark, cleanup and full\", type);\n@@ -122,0 +127,34 @@\n+\n+void G1Arguments::initialize_card_set_configuration() {\n+  assert(HeapRegion::LogOfHRGrainBytes != 0, \"not initialized\");\n+  \/\/ Array of Cards card set container globals.\n+  const int LOG_M = 20;\n+  uint region_size_log_mb = (uint)MAX2(HeapRegion::LogOfHRGrainBytes - LOG_M, 0);\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetArrayOfCardsEntries)) {\n+    uint num_cards_in_inline_ptr = G1CardSetConfiguration::num_cards_in_inline_ptr(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift);\n+    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MAX2(num_cards_in_inline_ptr * 2,\n+                                                    G1RemSetArrayOfCardsEntriesBase * (1u << (region_size_log_mb + 1))));\n+  }\n+\n+  \/\/ Round to next 8 byte boundary for array to maximize space usage.\n+  size_t const cur_size = G1CardSetArray::size_in_bytes(G1RemSetArrayOfCardsEntries);\n+  FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries,\n+                G1RemSetArrayOfCardsEntries + (uint)(align_up(cur_size, G1CardSetAllocOptions::BufferAlignment) - cur_size) \/ sizeof(G1CardSetArray::EntryDataType));\n+\n+  \/\/ Howl card set container globals.\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlNumBuckets, G1CardSetHowl::num_buckets(HeapRegion::CardsPerRegion,\n+                                                                     G1RemSetArrayOfCardsEntries,\n+                                                                     G1RemSetHowlMaxNumBuckets));\n+  }\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlMaxNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlMaxNumBuckets, MAX2(G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets));\n+  } else if (G1RemSetHowlMaxNumBuckets < G1RemSetHowlNumBuckets) {\n+    FormatBuffer<> buf(\"Maximum Howl card set container bucket size %u smaller than requested bucket size %u\",\n+                       G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets);\n+    vm_exit_during_initialization(buf);\n+  }\n+}\n+\n@@ -199,0 +238,8 @@\n+\n+  \/\/ Verify that the maximum parallelism isn't too high to eventually overflow\n+  \/\/ the refcount in G1CardSetContainer.\n+  uint max_parallel_refinement_threads = G1ConcRefinementThreads + G1DirtyCardQueueSet::num_par_ids();\n+  uint const divisor = 3;  \/\/ Safe divisor; we increment by 2 for each claim, but there is a small initial value.\n+  if (max_parallel_refinement_threads > UINTPTR_MAX \/ divisor) {\n+    vm_exit_during_initialization(\"Too large parallelism for remembered sets.\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":54,"deletions":7,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  static void initialize_card_set_configuration();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,887 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1FromCardCache.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+G1CardSet::CardSetPtr G1CardSet::FullCardSet = (G1CardSet::CardSetPtr)-1;\n+\n+G1CardSetConfiguration::G1CardSetConfiguration() :\n+  _inline_ptr_bits_per_card(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift) {\n+\n+  \/\/ Array of Cards card set container size calculation\n+  _num_cards_in_array = G1RemSetArrayOfCardsEntries;\n+\n+  \/\/ Full card set container size calculation\n+  _max_cards_in_card_set = (uint)HeapRegion::CardsPerRegion;\n+  assert(is_power_of_2(_max_cards_in_card_set),\n+        \"max_cards_in_card_set must be a power of 2: %u\", _max_cards_in_card_set);\n+  _cards_in_howl_threshold = _max_cards_in_card_set * (double)G1RemSetCoarsenHowlToFullPercent \/ 100;\n+\n+  \/\/ Howl card set container size calculation.\n+  _num_buckets_in_howl = G1RemSetHowlNumBuckets;\n+\n+  \/\/ Howl Bitmap card set container size calculation.\n+  _num_cards_in_howl_bitmap = G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl);\n+  _log2_num_cards_in_howl_bitmap = log2i_exact(_num_cards_in_howl_bitmap);\n+  _cards_in_howl_bitmap_threshold = _num_cards_in_howl_bitmap * (double)G1RemSetCoarsenHowlBitmapToHowlFullPercent \/ 100;\n+  _bitmap_hash_mask = ~(~(0) << _log2_num_cards_in_howl_bitmap);\n+\n+  log_configuration();\n+}\n+\n+G1CardSetConfiguration::G1CardSetConfiguration(uint inline_ptr_bits_per_card,\n+                                               uint num_cards_in_array,\n+                                               double cards_in_bitmap_threshold,\n+                                               uint max_buckets_in_howl,\n+                                               double cards_in_howl_threshold,\n+                                               uint max_cards_in_cardset) :\n+  _inline_ptr_bits_per_card(inline_ptr_bits_per_card),\n+  _num_cards_in_array(num_cards_in_array),\n+  _max_cards_in_card_set(max_cards_in_cardset),\n+  _cards_in_howl_threshold(max_cards_in_cardset * cards_in_howl_threshold) {\n+\n+  assert(is_power_of_2(_max_cards_in_card_set),\n+        \"max_cards_in_card_set must be a power of 2: %u\", _max_cards_in_card_set);\n+\n+  _num_buckets_in_howl = G1CardSetHowl::num_buckets(_max_cards_in_card_set, _num_cards_in_array, max_buckets_in_howl);\n+\n+  _num_cards_in_howl_bitmap = G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl);\n+  _cards_in_howl_bitmap_threshold = _num_cards_in_howl_bitmap * cards_in_bitmap_threshold;\n+  _log2_num_cards_in_howl_bitmap = log2i_exact(_num_cards_in_howl_bitmap);\n+  _bitmap_hash_mask = ~(~(0) << _log2_num_cards_in_howl_bitmap);\n+\n+  log_configuration();\n+}\n+\n+void G1CardSetConfiguration::log_configuration() {\n+  log_debug_p(gc, remset)(\"Card Set container configuration: \"\n+                          \"InlinePtr #elems %u size %zu \"\n+                          \"Array Of Cards #elems %u size %zu \"\n+                          \"Howl #buckets %u coarsen threshold %u \"\n+                          \"Howl Bitmap #elems %u size %zu coarsen threshold %u\",\n+                          num_cards_in_inline_ptr(), sizeof(void*),\n+                          num_cards_in_array(), G1CardSetArray::size_in_bytes(num_cards_in_array()),\n+                          num_buckets_in_howl(), cards_in_howl_threshold(),\n+                          num_cards_in_howl_bitmap(), G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), cards_in_howl_bitmap_threshold());\n+}\n+\n+uint G1CardSetConfiguration::num_cards_in_inline_ptr() const {\n+  return num_cards_in_inline_ptr(_inline_ptr_bits_per_card);\n+}\n+\n+uint G1CardSetConfiguration::num_cards_in_inline_ptr(uint bits_per_card) {\n+  return G1CardSetInlinePtr::max_cards_in_inline_ptr(bits_per_card);\n+}\n+\n+G1CardSetAllocOptions* G1CardSetConfiguration::mem_object_alloc_options() {\n+  G1CardSetAllocOptions* result = NEW_C_HEAP_ARRAY(G1CardSetAllocOptions, num_mem_object_types(), mtGC);\n+\n+  result[0] = { (uint)CardSetHash::get_node_size() };\n+  result[1] = { (uint)G1CardSetArray::size_in_bytes(num_cards_in_array()), 2, 256 };\n+  result[2] = { (uint)G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), 2, 256 };\n+  result[3] = { (uint)G1CardSetHowl::size_in_bytes(num_buckets_in_howl()), 2, 256 };\n+\n+  return result;\n+}\n+\n+const char* G1CardSetConfiguration::mem_object_type_name_str(uint index) {\n+  const char* names[] = { \"Node\", \"Array\", \"Bitmap\", \"Howl\" };\n+  return names[index];\n+}\n+\n+void G1CardSetCoarsenStats::reset() {\n+  STATIC_ASSERT(ARRAY_SIZE(_coarsen_from) == ARRAY_SIZE(_coarsen_collision));\n+  for (uint i = 0; i < ARRAY_SIZE(_coarsen_from); i++) {\n+    _coarsen_from[i] = 0;\n+    _coarsen_collision[i] = 0;\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::subtract_from(G1CardSetCoarsenStats& other) {\n+  STATIC_ASSERT(ARRAY_SIZE(_coarsen_from) == ARRAY_SIZE(_coarsen_collision));\n+  for (uint i = 0; i < ARRAY_SIZE(_coarsen_from); i++) {\n+    _coarsen_from[i] = other._coarsen_from[i] - _coarsen_from[i];\n+    _coarsen_collision[i] = other._coarsen_collision[i] - _coarsen_collision[i];\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::record_coarsening(uint tag, bool collision) {\n+  assert(tag < ARRAY_SIZE(_coarsen_from), \"tag %u out of bounds\", tag);\n+  Atomic::inc(&_coarsen_from[tag], memory_order_relaxed);\n+  if (collision) {\n+    Atomic::inc(&_coarsen_collision[tag], memory_order_relaxed);\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::print_on(outputStream* out) {\n+  out->print_cr(\"Inline->AoC %zu (%zu) \"\n+                \"AoC->Howl %zu (%zu) \"\n+                \"Howl->Full %zu (%zu) \"\n+                \"Inline->AoC %zu (%zu) \"\n+                \"AoC->BitMap %zu (%zu) \"\n+                \"BitMap->Full %zu (%zu) \",\n+                _coarsen_from[0], _coarsen_collision[0],\n+                _coarsen_from[1], _coarsen_collision[1],\n+                \/\/ There is no BitMap at the first level so we can't .\n+                _coarsen_from[3], _coarsen_collision[3],\n+                _coarsen_from[4], _coarsen_collision[4],\n+                _coarsen_from[5], _coarsen_collision[5],\n+                _coarsen_from[6], _coarsen_collision[6]\n+               );\n+}\n+\n+class G1CardSetHashTable : public CHeapObj<mtGCCardSet> {\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  \/\/ Did we insert at least one element in the table?\n+  bool volatile _inserted_elem;\n+\n+  G1CardSetMemoryManager* _mm;\n+  CardSetHash _table;\n+\n+  class G1CardSetHashTableLookUp : public StackObj {\n+    uint _region_idx;\n+  public:\n+    explicit G1CardSetHashTableLookUp(uint region_idx) : _region_idx(region_idx) { }\n+\n+    uintx get_hash() const { return _region_idx; }\n+\n+    bool equals(G1CardSetHashTableValue* value, bool* is_dead) {\n+      *is_dead = false;\n+      return value->_region_idx == _region_idx;\n+    }\n+  };\n+\n+  class G1CardSetHashTableFound : public StackObj {\n+    G1CardSetHashTableValue* _value;\n+  public:\n+    void operator()(G1CardSetHashTableValue* value) {\n+      _value = value;\n+    }\n+\n+    G1CardSetHashTableValue* value() const { return _value; }\n+  };\n+\n+  class G1CardSetHashTableScan : public StackObj {\n+    G1CardSet::G1CardSetPtrIterator* _scan_f;\n+  public:\n+    explicit G1CardSetHashTableScan(G1CardSet::G1CardSetPtrIterator* f) : _scan_f(f) { }\n+\n+    bool operator()(G1CardSetHashTableValue* value) {\n+      _scan_f->do_cardsetptr(value->_region_idx, value->_num_occupied, value->_card_set);\n+      return true;\n+    }\n+  };\n+\n+\n+public:\n+  static const size_t InitialLogTableSize = 2;\n+\n+  G1CardSetHashTable(G1CardSetMemoryManager* mm,\n+                     size_t initial_log_table_size = InitialLogTableSize) :\n+    _inserted_elem(false),\n+    _mm(mm),\n+    _table(mm, initial_log_table_size) {\n+  }\n+\n+  ~G1CardSetHashTable() {\n+    reset();\n+  }\n+\n+  G1CardSetHashTableValue* get_or_add(uint region_idx, bool* should_grow) {\n+    G1CardSetHashTableLookUp lookup(region_idx);\n+    G1CardSetHashTableFound found;\n+\n+    if (_table.get(Thread::current(), lookup, found)) {\n+      return found.value();\n+    }\n+\n+    G1CardSetHashTableValue value(region_idx, G1CardSetInlinePtr());\n+    bool inserted = _table.insert_get(Thread::current(), lookup, value, found, should_grow);\n+\n+    if (!_inserted_elem && inserted) {\n+      \/\/ It does not matter to us who is setting the flag so a regular atomic store\n+      \/\/ is sufficient.\n+      Atomic::store(&_inserted_elem, true);\n+    }\n+\n+    return found.value();\n+  }\n+\n+  CardSetPtr get(uint region_idx) {\n+    G1CardSetHashTableLookUp lookup(region_idx);\n+    G1CardSetHashTableFound found;\n+\n+    if (_table.get(Thread::current(), lookup, found)) {\n+      return found.value()->_card_set;\n+    }\n+    return nullptr;\n+  }\n+\n+  void iterate_safepoint(G1CardSet::G1CardSetPtrIterator* cl2) {\n+    G1CardSetHashTableScan cl(cl2);\n+    _table.do_safepoint_scan(cl);\n+  }\n+\n+  void iterate(G1CardSet::G1CardSetPtrIterator* cl2) {\n+    G1CardSetHashTableScan cl(cl2);\n+    _table.do_scan(Thread::current(), cl);\n+  }\n+\n+  void reset() {\n+    if (Atomic::load(&_inserted_elem)) {\n+       _table.unsafe_reset(InitialLogTableSize);\n+      Atomic::store(&_inserted_elem, false);\n+    }\n+  }\n+\n+  void print(outputStream* os) {\n+    os->print(\"TBL \" PTR_FORMAT \" size %zu mem %zu \", p2i(&_table), _table.get_size_log2(Thread::current()), _table.get_mem_size(Thread::current()));\n+  }\n+\n+  void grow() {\n+    size_t new_limit = _table.get_size_log2(Thread::current()) + 1;\n+    _table.grow(Thread::current(), new_limit);\n+  }\n+\n+  size_t mem_size() {\n+    return sizeof(*this) +\n+      _table.get_mem_size(Thread::current()) - sizeof(_table);\n+  }\n+\n+  size_t log_table_size() { return _table.get_size_log2(Thread::current()); }\n+};\n+\n+void* G1CardSetHashTableConfig::allocate_node(void* context, size_t size, Value const& value) {\n+  G1CardSetMemoryManager* mm = (G1CardSetMemoryManager*)context;\n+  return mm->allocate_node();\n+}\n+\n+void G1CardSetHashTableConfig::free_node(void* context, void* memory, Value const& value) {\n+  G1CardSetMemoryManager* mm = (G1CardSetMemoryManager*)context;\n+  mm->free_node(memory);\n+}\n+\n+G1CardSetCoarsenStats G1CardSet::_coarsen_stats;\n+G1CardSetCoarsenStats G1CardSet::_last_coarsen_stats;\n+\n+G1CardSet::G1CardSet(G1CardSetConfiguration* config, G1CardSetMemoryManager* mm) :\n+  _mm(mm),\n+  _config(config),\n+  _table(new G1CardSetHashTable(mm)),\n+  _num_occupied(0) {\n+}\n+\n+G1CardSet::~G1CardSet() {\n+  delete _table;\n+  _mm->flush();\n+}\n+\n+uint G1CardSet::card_set_type_to_mem_object_type(uintptr_t type) const {\n+  assert(type == G1CardSet::CardSetArrayOfCards ||\n+         type == G1CardSet::CardSetBitMap ||\n+         type == G1CardSet::CardSetHowl, \"should not allocate card set type %zu\", type);\n+\n+  return (uint)type;\n+}\n+\n+uint8_t* G1CardSet::allocate_mem_object(uintptr_t type) {\n+  return _mm->allocate(card_set_type_to_mem_object_type(type));\n+}\n+\n+void G1CardSet::free_mem_object(CardSetPtr card_set) {\n+  assert(card_set != G1CardSet::FreeCardSet, \"should not free Free card set\");\n+  assert(card_set != G1CardSet::FullCardSet, \"should not free Full card set\");\n+\n+  uintptr_t type = card_set_type(card_set);\n+  void* value = strip_card_set_type(card_set);\n+\n+  assert(type == G1CardSet::CardSetArrayOfCards ||\n+         type == G1CardSet::CardSetBitMap ||\n+         type == G1CardSet::CardSetHowl, \"should not free card set type %zu\", type);\n+\n+#ifdef ASSERT\n+  if (type == G1CardSet::CardSetArrayOfCards ||\n+      type == G1CardSet::CardSetBitMap ||\n+      type == G1CardSet::CardSetHowl) {\n+    G1CardSetContainer* card_set = (G1CardSetContainer*)value;\n+    assert((card_set->refcount() == 1), \"must be\");\n+  }\n+#endif\n+\n+  _mm->free(card_set_type_to_mem_object_type(type), value);\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::acquire_card_set(CardSetPtr volatile* card_set_addr) {\n+  \/\/ Update reference counts under RCU critical section to avoid a\n+  \/\/ use-after-cleapup bug where we increment a reference count for\n+  \/\/ an object whose memory has already been cleaned up and reused.\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  while (true) {\n+    \/\/ Get cardsetptr and increment refcount atomically wrt to memory reuse.\n+    CardSetPtr card_set = Atomic::load_acquire(card_set_addr);\n+    uint cs_type = card_set_type(card_set);\n+    if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+      return card_set;\n+    }\n+\n+    G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+\n+    if (card_set_on_heap->try_increment_refcount()) {\n+      assert(card_set_on_heap->refcount() >= 3, \"Smallest value is 3\");\n+      return card_set;\n+    }\n+  }\n+}\n+\n+bool G1CardSet::release_card_set(CardSetPtr card_set) {\n+  uint cs_type = card_set_type(card_set);\n+  if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+    return false;\n+  }\n+\n+  G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+  return card_set_on_heap->decrement_refcount() == 1;\n+}\n+\n+void G1CardSet::release_and_maybe_free_card_set(CardSetPtr card_set) {\n+  if (release_card_set(card_set)) {\n+    free_mem_object(card_set);\n+  }\n+}\n+\n+void G1CardSet::release_and_must_free_card_set(CardSetPtr card_set) {\n+  bool should_free = release_card_set(card_set);\n+  assert(should_free, \"should have been the only one having a reference\");\n+  free_mem_object(card_set);\n+}\n+\n+class G1ReleaseCardsets : public StackObj {\n+  G1CardSet* _card_set;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  void coarsen_to_full(CardSetPtr* card_set_addr) {\n+    while (true) {\n+      CardSetPtr cur_card_set = Atomic::load_acquire(card_set_addr);\n+      uint cs_type = G1CardSet::card_set_type(cur_card_set);\n+      if (cur_card_set == G1CardSet::FullCardSet) {\n+        return;\n+      }\n+\n+      CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, G1CardSet::FullCardSet);\n+\n+      if (old_value == cur_card_set) {\n+        _card_set->release_and_maybe_free_card_set(cur_card_set);\n+        return;\n+      }\n+    }\n+  }\n+\n+public:\n+  explicit G1ReleaseCardsets(G1CardSet* card_set) : _card_set(card_set) { }\n+\n+  void operator ()(CardSetPtr* card_set_addr) {\n+    coarsen_to_full(card_set_addr);\n+  }\n+};\n+\n+G1AddCardResult G1CardSet::add_to_array(CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetArray* array = card_set_ptr<G1CardSetArray>(card_set);\n+  return array->add(card_in_region);\n+}\n+\n+G1AddCardResult G1CardSet::add_to_howl(CardSetPtr parent_card_set,\n+                                                uint card_region,\n+                                                uint card_in_region,\n+                                                bool increment_total) {\n+  G1CardSetHowl* howl = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+\n+  G1AddCardResult add_result;\n+  CardSetPtr to_transfer = nullptr;\n+  CardSetPtr card_set;\n+\n+  uint bucket = _config->howl_bucket_index(card_in_region);\n+  volatile CardSetPtr* bucket_entry = howl->get_card_set_addr(bucket);\n+\n+  while (true) {\n+    if (Atomic::load(&howl->_num_entries) >= _config->cards_in_howl_threshold()) {\n+      return Overflow;\n+    }\n+\n+    card_set = acquire_card_set(bucket_entry);\n+    add_result = add_to_card_set(bucket_entry, card_set, card_region, card_in_region);\n+\n+    if (add_result != Overflow) {\n+      break;\n+    }\n+    \/\/ Card set has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_card_set(bucket_entry, card_set, card_in_region, true \/* within_howl *\/);\n+    _coarsen_stats.record_coarsening(card_set_type(card_set) + G1CardSetCoarsenStats::CoarsenHowlOffset, !coarsened);\n+    if (coarsened) {\n+      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      add_result = Added;\n+      to_transfer = card_set;\n+      break;\n+    }\n+    \/\/ Somebody else beat us to coarsening. Retry.\n+    release_and_maybe_free_card_set(card_set);\n+  }\n+\n+  if (increment_total && add_result == Added) {\n+    Atomic::inc(&howl->_num_entries, memory_order_relaxed);\n+  }\n+\n+  if (to_transfer != nullptr) {\n+    transfer_cards_in_howl(parent_card_set, to_transfer, card_region);\n+  }\n+\n+  release_and_maybe_free_card_set(card_set);\n+  return add_result;\n+}\n+\n+G1AddCardResult G1CardSet::add_to_bitmap(CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetBitMap* bitmap = card_set_ptr<G1CardSetBitMap>(card_set);\n+  uint card_offset = _config->howl_bitmap_offset(card_in_region);\n+  return bitmap->add(card_offset, _config->cards_in_howl_bitmap_threshold(), _config->num_cards_in_howl_bitmap());\n+}\n+\n+G1AddCardResult G1CardSet::add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetInlinePtr value(card_set_addr, card_set);\n+  return value.add(card_in_region, _config->inline_ptr_bits_per_card(), _config->num_cards_in_inline_ptr());\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::create_coarsened_array_of_cards(uint card_in_region, bool within_howl) {\n+  uint8_t* data = nullptr;\n+  CardSetPtr new_card_set;\n+  if (within_howl) {\n+    uint const size_in_bits = _config->num_cards_in_howl_bitmap();\n+    uint card_offset = _config->howl_bitmap_offset(card_in_region);\n+    data = allocate_mem_object(CardSetBitMap);\n+    new (data) G1CardSetBitMap(card_offset, size_in_bits);\n+    new_card_set = make_card_set_ptr(data, CardSetBitMap);\n+  } else {\n+    data = allocate_mem_object(CardSetHowl);\n+    new (data) G1CardSetHowl(card_in_region, _config);\n+    new_card_set = make_card_set_ptr(data, CardSetHowl);\n+  }\n+  return new_card_set;\n+}\n+\n+bool G1CardSet::coarsen_card_set(volatile CardSetPtr* card_set_addr,\n+                                 CardSetPtr cur_card_set,\n+                                 uint card_in_region,\n+                                 bool within_howl) {\n+  CardSetPtr new_card_set = nullptr;\n+\n+  switch (card_set_type(cur_card_set)) {\n+    case CardSetArrayOfCards : {\n+      new_card_set = create_coarsened_array_of_cards(card_in_region, within_howl);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      new_card_set = FullCardSet;\n+      break;\n+    }\n+    case CardSetInlinePtr: {\n+      uint const size = _config->num_cards_in_array();\n+      uint8_t* data = allocate_mem_object(CardSetArrayOfCards);\n+      new (data) G1CardSetArray(card_in_region, size);\n+      new_card_set = make_card_set_ptr(data, CardSetArrayOfCards);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      new_card_set = FullCardSet; \/\/ anything will do at this point.\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, new_card_set); \/\/ Memory order?\n+  if (old_value == cur_card_set) {\n+    \/\/ Success. Indicate that the cards from the current card set must be transferred\n+    \/\/ by this caller.\n+    \/\/ Release the hash table reference to the card. The caller still holds the\n+    \/\/ reference to this card set, so it can never be released (and we do not need to\n+    \/\/ check its result).\n+    bool should_free = release_card_set(cur_card_set);\n+    assert(!should_free, \"must have had more than one reference\");\n+    \/\/ Free containers if cur_card_set is CardSetHowl\n+    if (card_set_type(cur_card_set) == CardSetHowl) {\n+      G1ReleaseCardsets rel(this);\n+      card_set_ptr<G1CardSetHowl>(cur_card_set)->iterate(rel, _config->num_buckets_in_howl());\n+    }\n+    return true;\n+  } else {\n+    \/\/ Somebody else beat us to coarsening that card set. Exit, but clean up first.\n+    if (new_card_set != FullCardSet) {\n+      assert(new_card_set != nullptr, \"must not be\");\n+      release_and_must_free_card_set(new_card_set);\n+    }\n+    return false;\n+  }\n+}\n+\n+class G1TransferCard : public StackObj {\n+  G1CardSet* _card_set;\n+  uint _region_idx;\n+public:\n+  G1TransferCard(G1CardSet* card_set, uint region_idx) : _card_set(card_set), _region_idx(region_idx) { }\n+\n+  void operator ()(uint card_idx) {\n+    _card_set->add_card(_region_idx, card_idx, false);\n+  }\n+};\n+\n+void G1CardSet::transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region) {\n+  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n+  \/\/ the old type has been CardSetBitMap. \"Full\" contains all elements anyway.\n+  if (card_set_type(source_card_set) != CardSetHowl) {\n+    G1TransferCard iter(this, card_region);\n+    iterate_cards_during_transfer(source_card_set, iter);\n+  } else {\n+    assert(card_set_type(source_card_set) == CardSetHowl, \"must be\");\n+    \/\/ Need to correct for that the Full remembered set occupies more cards than the\n+    \/\/ AoCS before.\n+    Atomic::add(&_num_occupied, _config->max_cards_in_region() - table_entry->_num_occupied, memory_order_relaxed);\n+  }\n+}\n+\n+void G1CardSet::transfer_cards_in_howl(CardSetPtr parent_card_set,\n+                                                     CardSetPtr source_card_set,\n+                                                     uint card_region) {\n+  assert(card_set_type(parent_card_set) == CardSetHowl, \"must be\");\n+  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n+  \/\/ the old type has been CardSetBitMap.\n+  if (card_set_type(source_card_set) != CardSetBitMap) {\n+    \/\/ We only need to transfer from anything below CardSetBitMap.\n+    G1TransferCard iter(this, card_region);\n+    iterate_cards_during_transfer(source_card_set, iter);\n+  } else {\n+    uint diff = _config->num_cards_in_howl_bitmap() - card_set_ptr<G1CardSetBitMap>(source_card_set)->num_bits_set();\n+\n+    \/\/ Need to correct for that the Full remembered set occupies more cards than the\n+    \/\/ bitmap before.\n+    \/\/ We add 1 element less because the values will be incremented\n+    \/\/ in G1CardSet::add_card for the current addition or where already incremented in\n+    \/\/ G1CardSet::add_to_howl after coarsening.\n+    diff -= 1;\n+\n+    G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+    Atomic::add(&howling_array->_num_entries, diff, memory_order_relaxed);\n+\n+    bool should_grow_table = false;\n+    G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+    Atomic::add(&table_entry->_num_occupied, diff, memory_order_relaxed);\n+\n+    Atomic::add(&_num_occupied, diff, memory_order_relaxed);\n+  }\n+}\n+\n+G1AddCardResult G1CardSet::add_to_card_set(volatile CardSetPtr* card_set_addr, CardSetPtr card_set,  uint card_region, uint card_in_region, bool increment_total) {\n+  assert(card_set_addr != nullptr, \"Cannot add to empty cardset\");\n+\n+  G1AddCardResult add_result;\n+\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      add_result = add_to_inline_ptr(card_set_addr, card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetArrayOfCards : {\n+      add_result = add_to_array(card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      add_result = add_to_bitmap(card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      assert(CardSetHowl == card_set_type(FullCardSet), \"must be\");\n+      if (card_set == FullCardSet) {\n+        return Found;\n+      }\n+      add_result = add_to_howl(card_set, card_region, card_in_region, increment_total);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  return add_result;\n+}\n+\n+G1CardSetHashTableValue* G1CardSet::get_or_add_card_set(uint card_region, bool* should_grow_table) {\n+  return _table->get_or_add(card_region, should_grow_table);\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::get_card_set(uint card_region) {\n+  return _table->get(card_region);\n+}\n+\n+G1AddCardResult G1CardSet::add_card(uint card_region, uint card_in_region, bool increment_total) {\n+  G1AddCardResult add_result;\n+  CardSetPtr to_transfer = nullptr;\n+  CardSetPtr card_set;\n+\n+  bool should_grow_table = false;\n+  G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+  while (true) {\n+    card_set = acquire_card_set(&table_entry->_card_set);\n+    add_result = add_to_card_set(&table_entry->_card_set, card_set, card_region, card_in_region, increment_total);\n+\n+    if (add_result != Overflow) {\n+      break;\n+    }\n+    \/\/ Card set has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_card_set(&table_entry->_card_set, card_set, card_in_region);\n+    _coarsen_stats.record_coarsening(card_set_type(card_set), !coarsened);\n+    if (coarsened) {\n+      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      add_result = Added;\n+      to_transfer = card_set;\n+      break;\n+    }\n+    \/\/ Somebody else beat us to coarsening. Retry.\n+    release_and_maybe_free_card_set(card_set);\n+  }\n+\n+  if (increment_total && add_result == Added) {\n+    Atomic::inc(&table_entry->_num_occupied, memory_order_relaxed);\n+    Atomic::inc(&_num_occupied, memory_order_relaxed);\n+  }\n+  if (should_grow_table) {\n+    _table->grow();\n+  }\n+  if (to_transfer != nullptr) {\n+    transfer_cards(table_entry, to_transfer, card_region);\n+  }\n+\n+  release_and_maybe_free_card_set(card_set);\n+\n+  return add_result;\n+}\n+\n+bool G1CardSet::contains_card(uint card_region, uint card_in_region) {\n+  assert(card_in_region < _config->max_cards_in_region(),\n+         \"Card %u is beyond max %u\", card_in_region, _config->max_cards_in_region());\n+\n+  \/\/ Protect the card set from reclamation.\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  CardSetPtr card_set = get_card_set(card_region);\n+  if (card_set == nullptr) {\n+    return false;\n+  } else if (card_set == FullCardSet) {\n+    \/\/ contains_card() is not a performance critical method so we do not hide that\n+    \/\/ case in the switch below.\n+    return true;\n+  }\n+\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      return ptr.contains(card_in_region, _config->inline_ptr_bits_per_card());\n+    }\n+    case CardSetArrayOfCards :  return card_set_ptr<G1CardSetArray>(card_set)->contains(card_in_region);\n+    case CardSetBitMap: return card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_in_region, _config->num_cards_in_howl_bitmap());\n+    case CardSetHowl: {\n+      G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(card_set);\n+\n+      return howling_array->contains(card_in_region, _config);\n+    }\n+  }\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+void G1CardSet::print_info(outputStream* st, uint card_region, uint card_in_region) {\n+  CardSetPtr card_set = get_card_set(card_region);\n+  if (card_set == nullptr) {\n+    st->print(\"NULL card set\");\n+    return;\n+  } else if (card_set == FullCardSet) {\n+    st->print(\"FULL card set)\");\n+    return;\n+  }\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      st->print(\"InlinePtr not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetArrayOfCards :  {\n+      st->print(\"AoC not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      st->print(\"BitMap not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      st->print(\"CardSetHowl not containing %u\", card_in_region);\n+      break;\n+    }\n+    default: st->print(\"Unknown card set type %u\", card_set_type(card_set)); ShouldNotReachHere(); break;\n+  }\n+}\n+\n+template <class CardVisitor>\n+void G1CardSet::iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found) {\n+  uint type = card_set_type(card_set);\n+  assert(type == CardSetInlinePtr || type == CardSetArrayOfCards,\n+         \"invalid card set type %d to transfer from\",\n+         card_set_type(card_set));\n+\n+  switch (type) {\n+    case CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      return;\n+    }\n+    case CardSetArrayOfCards : {\n+      card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      return;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void G1CardSet::iterate_containers(G1CardSetPtrIterator* found, bool at_safepoint) {\n+  if (at_safepoint) {\n+    _table->iterate_safepoint(found);\n+  } else {\n+    _table->iterate(found);\n+  }\n+}\n+\n+template <typename Closure>\n+class G1ContainerCards {\n+  Closure& _iter;\n+  uint _region_idx;\n+\n+public:\n+  G1ContainerCards(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+\n+  bool start_iterate(uint tag) { return true; }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(_region_idx, card_idx);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    for (uint i = 0; i < length; i++) {\n+      _iter.do_card(_region_idx, card_idx);\n+    }\n+  }\n+};\n+\n+void G1CardSet::iterate_cards(G1CardSetCardIterator& iter) {\n+  G1CardSetMergeCardIterator<G1CardSetCardIterator, G1ContainerCards> cl(this, iter);\n+  iterate_containers(&cl);\n+}\n+\n+bool G1CardSet::occupancy_less_or_equal_to(size_t limit) const {\n+  return occupied() <= limit;\n+}\n+\n+bool G1CardSet::is_empty() const {\n+  return _num_occupied == 0;\n+}\n+\n+size_t G1CardSet::occupied() const {\n+  return _num_occupied;\n+}\n+\n+size_t G1CardSet::num_containers() {\n+  class GetNumberOfContainers : public G1CardSetPtrIterator {\n+  public:\n+    size_t _count;\n+\n+    GetNumberOfContainers() : G1CardSetPtrIterator(), _count(0) { }\n+\n+    void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) override {\n+      _count++;\n+    }\n+  } cl;\n+\n+  iterate_containers(&cl);\n+  return cl._count;\n+}\n+\n+G1CardSetCoarsenStats G1CardSet::coarsen_stats() {\n+  return _coarsen_stats;\n+}\n+\n+void G1CardSet::print_coarsen_stats(outputStream* out) {\n+  _last_coarsen_stats.subtract_from(_coarsen_stats);\n+  out->print(\"Coarsening (recent): \");\n+  _last_coarsen_stats.print_on(out);\n+  out->print(\"Coarsening (all): \");\n+  _coarsen_stats.print_on(out);\n+}\n+\n+size_t G1CardSet::mem_size() const {\n+  return sizeof(*this) +\n+         _table->mem_size() +\n+         _mm->mem_size();\n+}\n+\n+size_t G1CardSet::wasted_mem_size() const {\n+  return _mm->wasted_mem_size();\n+}\n+\n+size_t G1CardSet::static_mem_size() {\n+  return sizeof(FullCardSet) + sizeof(_coarsen_stats);\n+}\n+\n+void G1CardSet::clear() {\n+  _table->reset();\n+  _num_occupied = 0;\n+  _mm->flush();\n+}\n+\n+void G1CardSet::print(outputStream* os) {\n+  _table->print(os);\n+  _mm->print(os);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":887,"deletions":0,"binary":false,"changes":887,"status":"added"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSET_HPP\n+#define SHARE_GC_G1_G1CARDSET_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/padded.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/concurrentHashTable.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class G1CardSetAllocOptions;\n+class G1CardSetBufferList;\n+class G1CardSetHashTable;\n+class G1CardSetHashTableValue;\n+class G1CardSetMemoryManager;\n+class Mutex;\n+\n+\/\/ The result of an attempt to add a card to that card set.\n+enum G1AddCardResult {\n+  Overflow,  \/\/ The card set is more than full. The entry may have been added. Need\n+             \/\/ Coarsen and retry.\n+  Found,     \/\/ The card is already in the set.\n+  Added      \/\/ The card has been added to the set by this attempt.\n+};\n+\n+class G1CardSetConfiguration {\n+  uint _inline_ptr_bits_per_card;\n+  uint _num_cards_in_array;\n+  uint _num_cards_in_howl_bitmap;\n+  uint _num_buckets_in_howl;\n+  uint _max_cards_in_card_set;\n+  uint _cards_in_howl_threshold;\n+  uint _cards_in_howl_bitmap_threshold;\n+  uint _log2_num_cards_in_howl_bitmap;\n+  size_t _bitmap_hash_mask;\n+\n+  void log_configuration();\n+public:\n+\n+  \/\/ Initialize card set configuration from globals.\n+  G1CardSetConfiguration();\n+  \/\/ Initialize card set configuration from parameters.\n+  G1CardSetConfiguration(uint inline_ptr_bits_per_card,\n+                         uint num_cards_in_array,\n+                         double cards_in_bitmap_threshold,\n+                         uint max_buckets_in_howl,\n+                         double cards_in_howl_threshold,\n+                         uint max_cards_in_cardset);\n+\n+  \/\/ Inline pointer configuration\n+  uint inline_ptr_bits_per_card() const { return _inline_ptr_bits_per_card; }\n+  uint num_cards_in_inline_ptr() const;\n+  static uint num_cards_in_inline_ptr(uint bits_per_card);\n+\n+  \/\/ Array of Cards configuration\n+  bool use_cards_in_array() const { return _num_cards_in_array != 0; } \/\/ Unused for now\n+  \/\/ Number of cards in \"Array of Cards\" set; 0 to disable.\n+  \/\/ Always coarsen to next level if full, so no specific threshold.\n+  uint num_cards_in_array() const { return _num_cards_in_array; }\n+\n+  \/\/ Bitmap within Howl card set container configuration\n+  bool use_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap != 0; } \/\/ Unused for now\n+  uint num_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap; }\n+  \/\/ (Approximate) Number of cards in bitmap to coarsen Howl Bitmap to Howl Full.\n+  uint cards_in_howl_bitmap_threshold() const { return _cards_in_howl_bitmap_threshold; }\n+  uint log2_num_cards_in_howl_bitmap() const {return _log2_num_cards_in_howl_bitmap;}\n+\n+  \/\/ Howl card set container configuration\n+  uint num_buckets_in_howl() const { return _num_buckets_in_howl; }\n+  \/\/ Threshold at which to turn howling arrays into Full.\n+  uint cards_in_howl_threshold() const { return _cards_in_howl_threshold; }\n+  uint howl_bitmap_offset(uint card_idx) const { return card_idx & _bitmap_hash_mask; }\n+  \/\/ Given a card index, return the bucket in the array of card sets.\n+  uint howl_bucket_index(uint card_idx) { return card_idx >> _log2_num_cards_in_howl_bitmap; }\n+\n+  \/\/ Full card configuration\n+  \/\/ Maximum number of cards in a non-full card set for a single region. Card sets\n+  \/\/ with more entries per region are coarsened to Full.\n+  uint max_cards_in_region() const { return _max_cards_in_card_set; }\n+\n+  \/\/ Memory object types configuration\n+  \/\/ Number of distinctly sized memory objects on the card set heap.\n+  \/\/ Currently contains CHT-Nodes, ArrayOfCards, BitMaps, Howl\n+  static constexpr uint num_mem_object_types() { return 4; }\n+  \/\/ Returns the memory allocation options for the memory objects on the card set heap. The returned\n+  \/\/ array must be freed by the caller.\n+  G1CardSetAllocOptions* mem_object_alloc_options();\n+\n+  \/\/ For a given memory object, get a descriptive name.\n+  static const char* mem_object_type_name_str(uint index);\n+};\n+\n+\/\/ Collects coarsening statistics: how many attempts of each kind and how many\n+\/\/ failed due to a competing thread doing the coarsening first.\n+class G1CardSetCoarsenStats {\n+public:\n+  \/\/ Number of entries in the statistics tables: since we index with the source\n+  \/\/ cardset of the coarsening, this is the total number of combinations of\n+  \/\/ card sets - 1.\n+  static constexpr size_t NumCoarsenCategories = 7;\n+  \/\/ Coarsening statistics for the possible CardSetPtr in the Howl card set\n+  \/\/ start from this offset.\n+  static constexpr size_t CoarsenHowlOffset = 4;\n+\n+private:\n+  \/\/ Indices are \"from\" indices.\n+  size_t _coarsen_from[NumCoarsenCategories];\n+  size_t _coarsen_collision[NumCoarsenCategories];\n+\n+public:\n+  G1CardSetCoarsenStats() { reset(); }\n+\n+  void reset();\n+\n+  void subtract_from(G1CardSetCoarsenStats& other);\n+\n+  \/\/ Record a coarsening for the given tag\/category. Collision should be true if\n+  \/\/ this coarsening lost the race to do the coarsening of that category.\n+  void record_coarsening(uint tag, bool collision);\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Sparse set of card indexes comprising a remembered set on the Java heap. Card\n+\/\/ size is assumed to be card table card size.\n+\/\/\n+\/\/ Technically it is implemented using a ConcurrentHashTable that stores a card\n+\/\/ set container for every region containing at least one card.\n+\/\/\n+\/\/ There are in total five different containers, encoded in the ConcurrentHashTable\n+\/\/ node as CardSetPtr. A CardSetPtr may cover the whole region or just a part of\n+\/\/ it.\n+\/\/ See its description below for more information.\n+class G1CardSet : public CHeapObj<mtGCCardSet> {\n+  friend class G1CardSetTest;\n+  friend class G1CardSetMtTestTask;\n+\n+  template <typename Closure, template <typename> class CardorRanges>\n+  friend class G1CardSetMergeCardIterator;\n+\n+  friend class G1TransferCard;\n+\n+  friend class G1ReleaseCardsets;\n+\n+  static G1CardSetCoarsenStats _coarsen_stats; \/\/ Coarsening statistics since VM start.\n+  static G1CardSetCoarsenStats _last_coarsen_stats; \/\/ Coarsening statistics at last GC.\n+public:\n+  \/\/ Two lower bits are used to encode the card storage types\n+  static const uintptr_t CardSetPtrHeaderSize = 2;\n+\n+  \/\/ CardSetPtr represents the card storage type of a given covered area. It encodes\n+  \/\/ a type in the LSBs, in addition to having a few significant values.\n+  \/\/\n+  \/\/ Possible encodings:\n+  \/\/\n+  \/\/ 0...00000 free               (Empty, should never happen)\n+  \/\/ 1...11111 full               All card indexes in the whole area this CardSetPtr covers are part of this container.\n+  \/\/ X...XXX00 inline-ptr-cards   A handful of card indexes covered by this CardSetPtr are encoded within the CardSetPtr.\n+  \/\/ X...XXX01 array of cards     The container is a contiguous array of card indexes.\n+  \/\/ X...XXX10 bitmap             The container uses a bitmap to determine whether a given index is part of this set.\n+  \/\/ X...XXX11 howl               This is a card set container containing an array of CardSetPtr, with each CardSetPtr\n+  \/\/                              limited to a sub-range of the original range. Currently only one level of this\n+  \/\/                              container is supported.\n+  typedef void* CardSetPtr;\n+  \/\/ Coarsening happens in the order below:\n+  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetHowl -> Full\n+  \/\/ Corsening of containers inside the CardSetHowl happens in the order:\n+  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetBitMap -> Full\n+  static const uintptr_t CardSetInlinePtr      = 0x0;\n+  static const uintptr_t CardSetArrayOfCards   = 0x1;\n+  static const uintptr_t CardSetBitMap         = 0x2;\n+  static const uintptr_t CardSetHowl           = 0x3;\n+\n+  \/\/ The special sentinel values\n+  static constexpr CardSetPtr FreeCardSet = nullptr;\n+  \/\/ Unfortunately we can't make (G1CardSet::CardSetPtr)-1 constexpr because\n+  \/\/ reinterpret_casts are forbidden in constexprs. Use a regular static instead.\n+  static CardSetPtr FullCardSet;\n+\n+  static const uintptr_t CardSetPtrTypeMask    = ((uintptr_t)1 << CardSetPtrHeaderSize) - 1;\n+\n+  static CardSetPtr strip_card_set_type(CardSetPtr ptr) { return (CardSetPtr)((uintptr_t)ptr & ~CardSetPtrTypeMask); }\n+\n+  static uint card_set_type(CardSetPtr ptr) { return (uintptr_t)ptr & CardSetPtrTypeMask; }\n+\n+  template <class T>\n+  static T* card_set_ptr(CardSetPtr ptr);\n+\n+private:\n+  G1CardSetMemoryManager* _mm;\n+  G1CardSetConfiguration* _config;\n+\n+  G1CardSetHashTable* _table;\n+\n+  \/\/ Total number of cards in this card set. This is a best-effort value, i.e. there may\n+  \/\/ be (slightly) more cards in the card set than this value in reality.\n+  size_t _num_occupied;\n+\n+  CardSetPtr make_card_set_ptr(void* value, uintptr_t type);\n+\n+  CardSetPtr acquire_card_set(CardSetPtr volatile* card_set_addr);\n+  \/\/ Returns true if the card set should be released\n+  bool release_card_set(CardSetPtr card_set);\n+  \/\/ Release card set and free if needed.\n+  void release_and_maybe_free_card_set(CardSetPtr card_set);\n+  \/\/ Release card set and free (and it must be freeable).\n+  void release_and_must_free_card_set(CardSetPtr card_set);\n+\n+  \/\/ Coarsens the CardSet cur_card_set to the next level; tries to replace the\n+  \/\/ previous CardSet with a new one which includes the given card_in_region.\n+  \/\/ coarsen_card_set does not transfer cards from cur_card_set\n+  \/\/ to the new card_set. Transfer is achieved by transfer_cards.\n+  \/\/ Returns true if this was the thread that coarsened the CardSet (and added the card).\n+  bool coarsen_card_set(CardSetPtr volatile* card_set_addr,\n+                        CardSetPtr cur_card_set,\n+                        uint card_in_region, bool within_howl = false);\n+\n+  CardSetPtr create_coarsened_array_of_cards(uint card_in_region, bool within_howl);\n+\n+  \/\/ Transfer entries from source_card_set to a recently installed coarser storage type\n+  \/\/ We only need to transfer anything finer than CardSetBitMap. \"Full\" contains\n+  \/\/ all elements anyway.\n+  void transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region);\n+  void transfer_cards_in_howl(CardSetPtr parent_card_set, CardSetPtr source_card_set, uint card_region);\n+\n+  G1AddCardResult add_to_card_set(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_region, uint card, bool increment_total = true);\n+\n+  G1AddCardResult add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_array(CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_bitmap(CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_howl(CardSetPtr parent_card_set, uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  G1CardSetHashTableValue* get_or_add_card_set(uint card_region, bool* should_grow_table);\n+  CardSetPtr get_card_set(uint card_region);\n+\n+  \/\/ Iterate over cards of a card set container during transfer of the cards from\n+  \/\/ one container to another. Executes\n+  \/\/\n+  \/\/     void operator ()(uint card_idx)\n+  \/\/\n+  \/\/ on the given class.\n+  template <class CardVisitor>\n+  void iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found);\n+\n+  \/\/ Iterate over the container, calling a method on every card or card range contained\n+  \/\/ in the card container.\n+  \/\/ For every container, first calls\n+  \/\/\n+  \/\/   void start_iterate(uint tag, uint region_idx);\n+  \/\/\n+  \/\/ Then for every card or card range it calls\n+  \/\/\n+  \/\/   void do_card(uint card_idx);\n+  \/\/   void do_card_range(uint card_idx, uint length);\n+  \/\/\n+  \/\/ where card_idx is the card index within that region_idx passed before in\n+  \/\/ start_iterate().\n+  \/\/\n+  template <class CardOrRangeVisitor>\n+  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found);\n+\n+  uint card_set_type_to_mem_object_type(uintptr_t type) const;\n+  uint8_t* allocate_mem_object(uintptr_t type);\n+  void free_mem_object(CardSetPtr card_set);\n+\n+public:\n+  G1CardSetConfiguration* config() const { return _config; }\n+\n+  \/\/ Create a new remembered set for a particular heap region.\n+  G1CardSet(G1CardSetConfiguration* config, G1CardSetMemoryManager* mm);\n+  virtual ~G1CardSet();\n+\n+  \/\/ Adds the given card to this set, returning an appropriate result. If added,\n+  \/\/ updates the total count.\n+  G1AddCardResult add_card(uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  bool contains_card(uint card_region, uint card_in_region);\n+\n+  void print_info(outputStream* st, uint card_region, uint card_in_region);\n+\n+  \/\/ Returns whether this remembered set (and all sub-sets) have an occupancy\n+  \/\/ that is less or equal to the given occupancy.\n+  bool occupancy_less_or_equal_to(size_t limit) const;\n+\n+  \/\/ Returns whether this remembered set (and all sub-sets) does not contain any entry.\n+  bool is_empty() const;\n+\n+  \/\/ Returns the number of cards contained in this remembered set.\n+  size_t occupied() const;\n+\n+  size_t num_containers();\n+\n+  static G1CardSetCoarsenStats coarsen_stats();\n+  static void print_coarsen_stats(outputStream* out);\n+\n+  \/\/ Returns size of the actual remembered set containers in bytes.\n+  size_t mem_size() const;\n+  size_t wasted_mem_size() const;\n+  \/\/ Returns the size of static data in bytes.\n+  static size_t static_mem_size();\n+\n+  \/\/ Clear the entire contents of this remembered set.\n+  void clear();\n+\n+  void print(outputStream* os);\n+\n+  \/\/ Various iterators - should be made inlineable somehow.\n+  class G1CardSetPtrIterator {\n+  public:\n+    virtual void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) = 0;\n+  };\n+\n+  void iterate_containers(G1CardSetPtrIterator* iter, bool safepoint = false);\n+\n+  class G1CardSetCardIterator {\n+  public:\n+    virtual void do_card(uint region_idx, uint card_idx) = 0;\n+  };\n+\n+  void iterate_cards(G1CardSetCardIterator& iter);\n+\n+  \/\/ Iterate all cards for card set merging. Must be a CardOrRangeVisitor as\n+  \/\/ explained above.\n+  template <class CardOrRangeVisitor>\n+  void iterate_for_merge(CardOrRangeVisitor& cl);\n+};\n+\n+class G1CardSetHashTableValue {\n+public:\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  const uint _region_idx;\n+  uint volatile _num_occupied;\n+  CardSetPtr volatile _card_set;\n+\n+  G1CardSetHashTableValue(uint region_idx, CardSetPtr card_set) : _region_idx(region_idx), _num_occupied(0), _card_set(card_set) { }\n+};\n+\n+class G1CardSetHashTableConfig : public StackObj {\n+public:\n+  using Value = G1CardSetHashTableValue;\n+\n+  static uintx get_hash(Value const& value, bool* is_dead) {\n+    *is_dead = false;\n+    return value._region_idx;\n+  }\n+  static void* allocate_node(void* context, size_t size, Value const& value);\n+  static void free_node(void* context, void* memory, Value const& value);\n+};\n+\n+typedef ConcurrentHashTable<G1CardSetHashTableConfig, mtGCCardSet> CardSetHash;\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSET_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+template <class T>\n+inline T* G1CardSet::card_set_ptr(CardSetPtr ptr) {\n+  return (T*)strip_card_set_type(ptr);\n+}\n+\n+inline G1CardSet::CardSetPtr G1CardSet::make_card_set_ptr(void* value, uintptr_t type) {\n+  assert(card_set_type(value) == 0, \"Given ptr \" PTR_FORMAT \" already has type bits set\", p2i(value));\n+  return (CardSetPtr)((uintptr_t)value | type);\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found) {\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedInline)) {\n+        G1CardSetInlinePtr ptr(card_set);\n+        ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      }\n+      return;\n+    }\n+    case CardSetArrayOfCards : {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedArrayOfCards)) {\n+        card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      }\n+      return;\n+    }\n+    case CardSetBitMap: {\n+      \/\/ There is no first-level bitmap spanning the whole area.\n+      ShouldNotReachHere();\n+      return;\n+    }\n+    case CardSetHowl: {\n+      assert(card_set_type(FullCardSet) == CardSetHowl, \"Must be\");\n+      if (card_set == FullCardSet) {\n+        if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedFull)) {\n+          found(0, _config->max_cards_in_region());\n+        }\n+        return;\n+      }\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedHowl)) {\n+        card_set_ptr<G1CardSetHowl>(card_set)->iterate(found, _config);\n+      }\n+      return;\n+    }\n+  }\n+  log_error(gc)(\"Unkown card set type %u\", card_set_type(card_set));\n+  ShouldNotReachHere();\n+}\n+\n+template <typename Closure>\n+class G1ContainerCardsOrRanges {\n+  Closure& _iter;\n+  uint _region_idx;\n+\n+public:\n+  G1ContainerCardsOrRanges(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+\n+  bool start_iterate(uint tag) {\n+    return _iter.start_iterate(tag, _region_idx);\n+  }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(card_idx);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    _iter.do_card_range(card_idx, length);\n+  }\n+};\n+\n+template <typename Closure, template <typename> class CardOrRanges>\n+class G1CardSetMergeCardIterator : public G1CardSet::G1CardSetPtrIterator {\n+  G1CardSet* _card_set;\n+  Closure& _iter;\n+\n+public:\n+\n+  G1CardSetMergeCardIterator(G1CardSet* card_set, Closure& iter) : _card_set(card_set), _iter(iter) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    CardOrRanges<Closure> cl(_iter, region_idx);\n+    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n+  }\n+};\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  G1CardSetMergeCardIterator<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(this, cl);\n+  iterate_containers(&cl2, true \/* at_safepoint *\/);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.inline.hpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n+#define SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+\n+#include \"runtime\/thread.inline.hpp\"\n+\n+class G1CardSetInlinePtr : public StackObj {\n+  friend class G1CardSetContainersTest;\n+\n+  typedef G1CardSet::CardSetPtr CardSetPtr;\n+\n+  CardSetPtr volatile * _value_addr;\n+  CardSetPtr _value;\n+\n+  static const uint SizeFieldLen = 3;\n+  static const uint SizeFieldPos = 2;\n+  static const uint HeaderSize = G1CardSet::CardSetPtrHeaderSize + SizeFieldLen;\n+\n+  static const uint BitsInValue = sizeof(CardSetPtr) * BitsPerByte;\n+\n+  static const uintptr_t SizeFieldMask = (((uint)1 << SizeFieldLen) - 1) << SizeFieldPos;\n+\n+  static uint8_t card_pos_for(uint const idx, uint const bits_per_card) {\n+    return (idx * bits_per_card + HeaderSize);\n+  }\n+\n+  static CardSetPtr merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card);\n+\n+  static uint card_at(CardSetPtr value, uint const idx, uint const bits_per_card) {\n+    uint8_t card_pos = card_pos_for(idx, bits_per_card);\n+    uint result = ((uintptr_t)value >> card_pos) & (((uintptr_t)1 << bits_per_card) - 1);\n+    return result;\n+  }\n+public:\n+  G1CardSetInlinePtr() : _value_addr(nullptr), _value((CardSetPtr)G1CardSet::CardSetInlinePtr) { }\n+\n+  G1CardSetInlinePtr(CardSetPtr value) : _value_addr(nullptr), _value(value) {\n+    assert(((uintptr_t)_value & G1CardSet::CardSetInlinePtr) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  }\n+\n+  G1CardSetInlinePtr(CardSetPtr volatile* value_addr, CardSetPtr value) : _value_addr(value_addr), _value(value) {\n+    assert(((uintptr_t)_value & G1CardSet::CardSetInlinePtr) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  }\n+\n+  G1AddCardResult add(uint const card_idx, uint const bits_per_card, uint const max_cards_in_inline_ptr);\n+\n+  bool contains(uint const card_idx, uint const bits_per_card);\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found, uint const bits_per_card);\n+\n+  operator CardSetPtr () { return _value; }\n+\n+  static uint max_cards_in_inline_ptr(uint bits_per_card) {\n+    return (BitsInValue - HeaderSize) \/ bits_per_card;\n+  }\n+\n+  static uint num_cards_in(CardSetPtr value) {\n+    return ((uintptr_t)value & SizeFieldMask) >> SizeFieldPos;\n+  }\n+};\n+\n+\n+\/\/ Common base class for card set containers where the memory for the entries is\n+\/\/ managed on the (C-)heap. Depending on the current use, one of the two overlapping\n+\/\/ members are used:\n+\/\/\n+\/\/ While such an object is assigned to a card set container, we utilize the\n+\/\/ reference count for memory management.\n+\/\/\n+\/\/ In this case the object is one of three states:\n+\/\/ 1: Live: The object is visible to other threads, thus can\n+\/\/    safely be accessed by other threads (_ref_count >= 3).\n+\/\/ 2: Dead: The object is visible to only a single thread and may be\n+\/\/    safely reclaimed (_ref_count == 1).\n+\/\/ 3: Reclaimed: The object's memory has been reclaimed ((_ref_count & 0x1) == 0).\n+\/\/ To maintain these constraints, live objects should have ((_ref_count & 0x1) == 1),\n+\/\/ which requires that we increment the reference counts by 2 starting at _ref_count = 3.\n+\/\/\n+\/\/ When such an object is on a free list, we reuse the same field for linking\n+\/\/ together those free objects.\n+\/\/\n+\/\/ All but inline pointers are of this kind. For those, card entries are stored\n+\/\/ directly in the CardSetPtr of the ConcurrentHashTable node.\n+class G1CardSetContainer {\n+private:\n+  union {\n+    G1CardSetContainer* _next;\n+    uintptr_t _ref_count;\n+  };\n+\n+public:\n+  G1CardSetContainer() : _ref_count(3) { }\n+\n+  uintptr_t refcount() const { return Atomic::load_acquire(&_ref_count); }\n+\n+  bool try_increment_refcount();\n+\n+  \/\/ Decrement refcount potentially while racing increment, so we need\n+  \/\/ to check the value after attempting to decrement.\n+  uintptr_t decrement_refcount();\n+\n+  G1CardSetContainer* next() {\n+    return _next;\n+  }\n+\n+  G1CardSetContainer** next_addr() {\n+    return &_next;\n+  }\n+\n+  void set_next(G1CardSetContainer* next) {\n+    _next = next;\n+  }\n+};\n+\n+class G1CardSetArray : public G1CardSetContainer {\n+public:\n+  typedef uint16_t EntryDataType;\n+  typedef uint EntryCountType;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+private:\n+  EntryCountType _size;\n+  EntryCountType volatile _num_entries;\n+  EntryDataType _data[2];\n+\n+  static const EntryCountType LockBitMask = (EntryCountType)1 << (sizeof(EntryCountType) * BitsPerByte - 1);\n+  static const EntryCountType EntryMask = LockBitMask - 1;\n+\n+  class G1CardSetArrayLocker : public StackObj {\n+    EntryCountType volatile* _value;\n+    EntryCountType volatile _original_value;\n+    bool _success;\n+  public:\n+    G1CardSetArrayLocker(EntryCountType volatile* value);\n+\n+    EntryCountType num_entries() const { return _original_value; }\n+    void inc_num_entries() { _success = true; }\n+\n+    ~G1CardSetArrayLocker() {\n+      assert(((_original_value + _success) & EntryMask) == (EntryCountType)(_original_value + _success), \"precondition!\" );\n+\n+      Atomic::release_store(_value, (EntryCountType)(_original_value + _success));\n+    }\n+  };\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _data);\n+  }\n+\n+public:\n+  G1CardSetArray(uint const card_in_region, EntryCountType num_elems);\n+\n+  G1AddCardResult add(uint card_idx);\n+\n+  bool contains(uint card_idx);\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found);\n+\n+  size_t num_entries() const { return _num_entries & EntryMask; }\n+  size_t max_entries() const { return _size; }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetArray>(); }\n+\n+  static size_t size_in_bytes(size_t num_cards) {\n+    return header_size_in_bytes() + sizeof(EntryDataType) * num_cards;\n+  }\n+};\n+\n+class G1CardSetBitMap : public G1CardSetContainer {\n+  size_t _num_bits_set;\n+  BitMap::bm_word_t _bits[1];\n+\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _bits);\n+  }\n+\n+public:\n+  G1CardSetBitMap(uint const card_in_region, uint const size_in_bits);\n+\n+  G1AddCardResult add(uint card_idx, size_t threshold, size_t size_in_bits);\n+\n+  bool contains(uint card_idx, size_t size_in_bits) {\n+    BitMapView bm(_bits, size_in_bits);\n+    return bm.at(card_idx);\n+  }\n+\n+  uint num_bits_set() const { return (uint)_num_bits_set; }\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found, size_t const size_in_bits, uint offset);\n+\n+  uint next(uint const idx, size_t const size_in_bits) {\n+    BitMapView bm(_bits, size_in_bits);\n+    return static_cast<uint>(bm.get_next_one_offset(idx));\n+  }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetBitMap>(); }\n+\n+  static size_t size_in_bytes(size_t size_in_bits) { return header_size_in_bytes() + BitMap::calc_size_in_words(size_in_bits) * BytesPerWord; }\n+};\n+\n+class G1CardSetHowl : public G1CardSetContainer {\n+public:\n+  typedef uint EntryCountType;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+  EntryCountType volatile _num_entries;\n+private:\n+  CardSetPtr _buckets[2];\n+  \/\/ Do not add class member variables beyond this point\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _buckets);\n+  }\n+\n+  \/\/ Iterates over the given CardSetPtr with at index in this Howl card set,\n+  \/\/ applying a CardOrRangeVisitor on it.\n+  template <class CardOrRangeVisitor>\n+  void iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+\n+public:\n+  G1CardSetHowl(EntryCountType card_in_region, G1CardSetConfiguration* config);\n+\n+  CardSetPtr* get_card_set_addr(EntryCountType index) {\n+    return &_buckets[index];\n+  }\n+\n+  bool contains(uint card_idx, G1CardSetConfiguration* config);\n+\n+  \/\/ Iterates over all CardSetPtrs in this Howl card set, applying a CardOrRangeVisitor\n+  \/\/ on it.\n+  template <class CardOrRangeVisitor>\n+  void iterate(CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+\n+  \/\/ Iterates over all CardSetPtrs in this Howl card set. Calls\n+  \/\/\n+  \/\/   void operator ()(CardSetPtr* card_set_addr);\n+  \/\/\n+  \/\/ on all of them.\n+  template <class CardSetPtrVisitor>\n+  void iterate(CardSetPtrVisitor& found, uint num_card_sets);\n+\n+  static EntryCountType num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_buckets);\n+\n+  static EntryCountType bitmap_size(size_t size_in_bits, uint num_buckets) {\n+    EntryCountType num_cards = (EntryCountType)size_in_bits \/ num_buckets;\n+    return round_up_power_of_2(num_cards);\n+  }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetHowl>(); }\n+\n+  static size_t size_in_bytes(size_t num_arrays) {\n+    return header_size_in_bytes() + sizeof(CardSetPtr) * num_arrays;\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+\n+inline G1CardSetInlinePtr::CardSetPtr G1CardSetInlinePtr::merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card) {\n+  assert((idx & (SizeFieldMask >> SizeFieldPos)) == idx, \"Index %u too large to fit into size field\", idx);\n+  assert(card_in_region < ((uint)1 << bits_per_card), \"Card %u too large to fit into card value field\", card_in_region);\n+\n+  uint8_t card_pos = card_pos_for(idx, bits_per_card);\n+  assert(card_pos + bits_per_card < BitsInValue, \"Putting card at pos %u with %u bits would extend beyond pointer\", card_pos, bits_per_card);\n+\n+  \/\/ Check that we do not touch any fields we do not own.\n+  uintptr_t mask = ((((uintptr_t)1 << bits_per_card) - 1) << card_pos);\n+  assert(((uintptr_t)orig_value & mask) == 0, \"The bits in the new range should be empty; orig_value \" PTR_FORMAT \" mask \" PTR_FORMAT, p2i(orig_value), mask);\n+\n+  uintptr_t value = ((uintptr_t)(idx + 1) << SizeFieldPos) | ((uintptr_t)card_in_region << card_pos);\n+  uintptr_t res = (((uintptr_t)orig_value & ~SizeFieldMask) | value);\n+  return (CardSetPtr)res;\n+}\n+\n+inline G1AddCardResult G1CardSetInlinePtr::add(uint card_idx, uint bits_per_card, uint max_cards_in_inline_ptr) {\n+  assert(_value_addr != nullptr, \"No value address available, cannot add to set.\");\n+\n+  while (true) {\n+    uint num_elems = num_cards_in(_value);\n+    \/\/ Check if the card is already stored in the pointer.\n+    if (contains(card_idx, bits_per_card)) {\n+      return Found;\n+    }\n+    \/\/ Check if there is actually enough space.\n+    if (num_elems >= max_cards_in_inline_ptr) {\n+      return Overflow;\n+    }\n+    CardSetPtr new_value = merge(_value, card_idx, num_elems, bits_per_card);\n+    CardSetPtr old_value = Atomic::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n+    if (_value == old_value) {\n+      return Added;\n+    }\n+    \/\/ Update values and retry.\n+    _value = old_value;\n+    \/\/ The value of the pointer may have changed to something different than\n+    \/\/ an inline card set. Exit then instead of overwriting.\n+    if (G1CardSet::card_set_type(_value) != G1CardSet::CardSetInlinePtr) {\n+      return Overflow;\n+    }\n+  }\n+}\n+\n+inline bool G1CardSetInlinePtr::contains(uint card_idx, uint bits_per_card) {\n+  uint num_elems = num_cards_in(_value);\n+  uintptr_t const card_mask = (1 << bits_per_card) - 1;\n+\n+  uintptr_t value = ((uintptr_t)_value) >> card_pos_for(0, bits_per_card);\n+  \/\/ Check if the card is already stored in the pointer.\n+  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+    if ((value & card_mask) == card_idx) {\n+      return true;\n+    }\n+    value >>= bits_per_card;\n+  }\n+  return false;\n+}\n+\n+template <class CardVisitor>\n+inline void G1CardSetInlinePtr::iterate(CardVisitor& found, uint bits_per_card) {\n+  uint const num_elems = num_cards_in(_value);\n+  uintptr_t const card_mask = (1 << bits_per_card) - 1;\n+\n+  uintptr_t value = ((uintptr_t)_value) >> card_pos_for(0, bits_per_card);\n+  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+    found(value & card_mask);\n+    value >>= bits_per_card;\n+  }\n+}\n+\n+inline bool G1CardSetContainer::try_increment_refcount() {\n+  uintptr_t old_value = refcount();\n+  while (true) {\n+    if (old_value < 3 || (old_value & 0x1) == 0) {  \/\/ reclaimed,  reference counts are odd numbers starting at 3\n+      return false; \/\/ dead, can't revive.\n+    }\n+\n+    uintptr_t new_value = old_value + 2;\n+    uintptr_t ref_count = Atomic::cmpxchg(&_ref_count, old_value, new_value);\n+    if (ref_count == old_value) {\n+      return true;\n+    }\n+    old_value = ref_count;\n+  }\n+}\n+\n+inline uintptr_t G1CardSetContainer::decrement_refcount() {\n+  uintptr_t old_value = refcount();\n+  assert((old_value & 0x1) != 0 && old_value >= 3, \"precondition\");\n+  return Atomic::sub(&_ref_count, 2u);\n+}\n+\n+inline G1CardSetArray::G1CardSetArray(uint card_in_region, EntryCountType num_elems) :\n+  G1CardSetContainer(),\n+  _size(num_elems),\n+  _num_entries(1) {\n+  assert(_size > 0, \"CardSetArray of size 0 not supported.\");\n+  assert(_size < LockBitMask, \"Only support CardSetArray of size %u or smaller.\", LockBitMask - 1);\n+  _data[0] = card_in_region;\n+}\n+\n+inline G1CardSetArray::G1CardSetArrayLocker::G1CardSetArrayLocker(EntryCountType volatile* value) :\n+  _value(value),\n+  _success(false) {\n+  SpinYield s;\n+  EntryCountType original_value = (*_value) & EntryMask;\n+  while (true) {\n+    EntryCountType old_value = Atomic::cmpxchg(_value,\n+                                               original_value,\n+                                               (EntryCountType)(original_value | LockBitMask));\n+    if (old_value == original_value) {\n+      \/\/ Succeeded locking the array.\n+      _original_value = original_value;\n+      break;\n+    }\n+    \/\/ Failed. Retry (with the lock bit stripped again).\n+    original_value = old_value & EntryMask;\n+    s.wait();\n+  }\n+}\n+\n+inline G1AddCardResult G1CardSetArray::add(uint card_idx) {\n+  assert(card_idx < (1u << (sizeof(_data[0]) * BitsPerByte)),\n+         \"Card index %u does not fit card element.\", card_idx);\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType idx = 0;\n+  for (; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return Found;\n+    }\n+  }\n+\n+  \/\/ Since we did not find the card, lock.\n+  G1CardSetArrayLocker x(&_num_entries);\n+\n+  \/\/ Reload number of entries from the G1CardSetArrayLocker as it might have changed.\n+  \/\/ It already read the actual value with the necessary synchronization.\n+  num_entries = x.num_entries();\n+  \/\/ Look if the elements added while waiting for the lock are the same as our card.\n+  for (; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return Found;\n+    }\n+  }\n+\n+  \/\/ Check if there is space left.\n+  if (num_entries == _size) {\n+    return Overflow;\n+  }\n+\n+  _data[num_entries] = card_idx;\n+\n+  x.inc_num_entries();\n+\n+  return Added;\n+}\n+\n+inline bool G1CardSetArray::contains(uint card_idx) {\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+\n+  for (EntryCountType idx = 0; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class CardVisitor>\n+void G1CardSetArray::iterate(CardVisitor& found) {\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  for (EntryCountType idx = 0; idx < num_entries; idx++) {\n+    found(_data[idx]);\n+  }\n+}\n+\n+inline G1CardSetBitMap::G1CardSetBitMap(uint card_in_region, uint size_in_bits) :\n+  G1CardSetContainer(), _num_bits_set(1) {\n+  assert(size_in_bits % (sizeof(_bits[0]) * BitsPerByte) == 0,\n+         \"Size %u should be aligned to bitmap word size.\", size_in_bits);\n+  BitMapView bm(_bits, size_in_bits);\n+  bm.clear();\n+  bm.set_bit(card_in_region);\n+}\n+\n+inline G1AddCardResult G1CardSetBitMap::add(uint card_idx, size_t threshold, size_t size_in_bits) {\n+  BitMapView bm(_bits, size_in_bits);\n+  if (_num_bits_set >= threshold) {\n+    return bm.at(card_idx) ? Found : Overflow;\n+  }\n+  if (bm.par_set_bit(card_idx)) {\n+    Atomic::inc(&_num_bits_set, memory_order_relaxed);\n+    return Added;\n+  }\n+  return Found;\n+}\n+\n+template <class CardVisitor>\n+inline void G1CardSetBitMap::iterate(CardVisitor& found, size_t size_in_bits, uint offset) {\n+  BitMapView bm(_bits, size_in_bits);\n+  BitMap::idx_t idx = bm.get_next_one_offset(0);\n+  while (idx != size_in_bits) {\n+    found((offset | (uint)idx));\n+    idx = bm.get_next_one_offset(idx + 1);\n+  }\n+}\n+\n+inline G1CardSetHowl::G1CardSetHowl(EntryCountType card_in_region, G1CardSetConfiguration* config) :\n+  G1CardSetContainer(),\n+  _num_entries((config->num_cards_in_array() + 1)) \/* Card Transfer will not increment _num_entries *\/ {\n+  EntryCountType num_buckets = config->num_buckets_in_howl();\n+  EntryCountType bucket = config->howl_bucket_index(card_in_region);\n+  for (uint i = 0; i < num_buckets; ++i) {\n+    _buckets[i] = G1CardSetInlinePtr();\n+    if (i == bucket) {\n+      G1CardSetInlinePtr value(&_buckets[i], _buckets[i]);\n+      value.add(card_in_region, config->inline_ptr_bits_per_card(), config->num_cards_in_inline_ptr());\n+    }\n+  }\n+}\n+\n+inline bool G1CardSetHowl::contains(uint card_idx, G1CardSetConfiguration* config) {\n+  EntryCountType bucket = config->howl_bucket_index(card_idx);\n+  CardSetPtr* array_entry = get_card_set_addr(bucket);\n+  CardSetPtr card_set = Atomic::load_acquire(array_entry);\n+\n+  switch (G1CardSet::card_set_type(card_set)) {\n+    case G1CardSet::CardSetArrayOfCards : {\n+      return G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->contains(card_idx);\n+    }\n+    case G1CardSet::CardSetBitMap: {\n+      uint card_offset = config->howl_bitmap_offset(card_idx);\n+      return G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_offset, config->num_cards_in_howl_bitmap());\n+    }\n+    case G1CardSet::CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      return ptr.contains(card_idx, config->inline_ptr_bits_per_card());\n+    }\n+    case G1CardSet::CardSetHowl: {\/\/ Fullcard set entry\n+      assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSetHowl::iterate(CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  for (uint i = 0; i < config->num_buckets_in_howl(); ++i) {\n+    iterate_cardset(_buckets[i], i, found, config);\n+  }\n+}\n+\n+template <class CardSetPtrVisitor>\n+inline void G1CardSetHowl::iterate(CardSetPtrVisitor& found, uint num_card_sets) {\n+  for (uint i = 0; i < num_card_sets; ++i) {\n+    found(&_buckets[i]);\n+  }\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSetHowl::iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  switch (G1CardSet::card_set_type(card_set)) {\n+    case G1CardSet::CardSetInlinePtr: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlInline)) {\n+        G1CardSetInlinePtr ptr(card_set);\n+        ptr.iterate(found, config->inline_ptr_bits_per_card());\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetArrayOfCards : {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlArrayOfCards)) {\n+        G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetBitMap: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlBitmap)) {\n+        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n+        G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->iterate(found, config->num_cards_in_howl_bitmap(), offset);\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetHowl: { \/\/ actually FullCardSet\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlFull)) {\n+        assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n+        for (uint i = 0; i < config->max_cards_in_region(); i++) {\n+          found((offset | (uint)i));\n+        }\n+      }\n+      return;\n+    }\n+  }\n+}\n+\n+inline G1CardSetHowl::EntryCountType G1CardSetHowl::num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_num_buckets) {\n+  size_t size_bitmap_bytes = BitMap::calc_size_in_words(size_in_bits) * BytesPerWord;\n+  \/\/ Ensure that in the worst case arrays consume half the memory size\n+  \/\/ of storing the entire bitmap\n+  size_t max_size_arrays_bytes = size_bitmap_bytes \/ 2;\n+  size_t size_array_bytes = num_cards_in_array * sizeof(G1CardSetArray::EntryDataType);\n+  size_t num_arrays = max_size_arrays_bytes \/ size_array_bytes;\n+  \/\/ We use shifts and masks for indexing the array. So round down to the next\n+  \/\/ power of two to not use more than expected memory.\n+  num_arrays = round_down_power_of_2(MAX2((size_t)1, MIN2(num_arrays, max_num_buckets)));\n+  return (EntryCountType)num_arrays;\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"heapRegionRemSet.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n+\n+constexpr const char* G1CardSetFreeMemoryTask::_state_names[];\n+\n+const char* G1CardSetFreeMemoryTask::get_state_name(State value) const {\n+  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n+}\n+\n+bool G1CardSetFreeMemoryTask::deadline_exceeded(jlong deadline) {\n+  return os::elapsed_counter() >= deadline;\n+}\n+\n+static size_t keep_size(size_t free, size_t used, double percent) {\n+  size_t to_keep = used * percent;\n+  return MIN2(free, to_keep);\n+}\n+\n+bool G1CardSetFreeMemoryTask::calculate_return_infos(jlong deadline) {\n+  \/\/ Ignore the deadline in this step as it is very short.\n+\n+  G1CardSetMemoryStats used = _total_used;\n+  G1CardSetMemoryStats free = G1CardSetFreePool::free_list_sizes();\n+\n+  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n+  for (uint i = 0; i < used.num_pools(); i++) {\n+    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n+                                         used._num_mem_sizes[i],\n+                                         G1RemSetFreeMemoryKeepExcessRatio);\n+    log_trace(gc, task)(\"Card Set Free Memory: Type %s: Free: %zu (%zu) \"\n+                        \"Used: %zu Keep: %zu\",\n+                        G1CardSetConfiguration::mem_object_type_name_str(i),\n+                        free._num_mem_sizes[i], free._num_buffers[i],\n+                        used._num_mem_sizes[i], return_to_vm_size);\n+\n+    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n+  }\n+\n+  G1CardSetFreePool::update_unlink_processors(_return_info);\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_vm()) {\n+      if (info->return_to_vm(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::return_memory_to_os(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_os()) {\n+      if (info->return_to_os(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::cleanup_return_infos() {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+     G1ReturnMemoryProcessor* info = _return_info->at(i);\n+     delete info;\n+  }\n+  delete _return_info;\n+\n+  _return_info = nullptr;\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::free_excess_card_set_memory() {\n+  jlong start = os::elapsed_counter();\n+  jlong end = start +\n+              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step start %1.3f end %1.3f\",\n+                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n+\n+  State next_state;\n+\n+  do {\n+    switch (_state) {\n+      case State::CalculateUsed: {\n+        if (calculate_return_infos(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToVM;\n+        break;\n+      }\n+      case State::ReturnToVM: {\n+        if (return_memory_to_vm(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToOS;\n+        break;\n+      }\n+      case State::ReturnToOS: {\n+        if (return_memory_to_os(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::Cleanup;\n+        break;\n+      }\n+      case State::Cleanup: {\n+        cleanup_return_infos();\n+        next_state = State::Inactive;\n+        break;\n+      }\n+      default:\n+        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    set_state(next_state);\n+  } while (_state != State::Inactive && !deadline_exceeded(end));\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step took %1.3fms, done %s\",\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      bool_to_str(_state == State::CalculateUsed));\n+\n+  return is_active();\n+}\n+\n+void G1CardSetFreeMemoryTask::set_state(State new_state) {\n+  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n+                      get_state_name(_state),\n+                      get_state_name(new_state));\n+  _state = new_state;\n+}\n+\n+bool G1CardSetFreeMemoryTask::is_active() const {\n+  return _state != State::Inactive;\n+}\n+\n+jlong G1CardSetFreeMemoryTask::reschedule_delay_ms() const {\n+  return G1RemSetFreeMemoryRescheduleDelayMillis;\n+}\n+\n+G1CardSetFreeMemoryTask::G1CardSetFreeMemoryTask(const char* name) :\n+  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n+\n+void G1CardSetFreeMemoryTask::execute() {\n+  SuspendibleThreadSetJoiner sts;\n+\n+  if (free_excess_card_set_memory()) {\n+    schedule(reschedule_delay_ms());\n+  }\n+}\n+\n+void G1CardSetFreeMemoryTask::notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n+                                               G1CardSetMemoryStats* collection_set_candidate_stats) {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  _total_used = *young_gen_stats;\n+  _total_used.add(*collection_set_candidate_stats);\n+\n+  if (!is_active()) {\n+    set_state(State::CalculateUsed);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.cpp","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n+#define SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n+\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class G1CardSetBuffer;\n+\n+\/\/ Task handling deallocation of free card set memory.\n+class G1CardSetFreeMemoryTask : public G1ServiceTask {\n+\n+  enum class State : uint {\n+    Inactive,\n+    CalculateUsed,\n+    ReturnToVM,\n+    ReturnToOS,\n+    Cleanup\n+  };\n+\n+  static constexpr const char* _state_names[] = { \"Invalid\",\n+                                                  \"CalculateUsed\",\n+                                                  \"ReturnToVM\",\n+                                                  \"ReturnToOS\",\n+                                                  \"Cleanup\" };\n+\n+  const char* get_state_name(State value) const;\n+\n+  State _state;\n+\n+  \/\/ Current total card set memory usage.\n+  G1CardSetMemoryStats _total_used;\n+\n+  typedef G1CardSetFreePool::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n+  typedef G1CardSetFreePool::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n+\n+  G1ReturnMemoryProcessorSet* _return_info;\n+\n+  \/\/ Returns whether the given deadline has passed.\n+  bool deadline_exceeded(jlong deadline);\n+\n+  \/\/ Methods for the tasks to be done. They all return true if that step has\n+  \/\/ completed.\n+  bool calculate_return_infos(jlong deadline);\n+  bool return_memory_to_vm(jlong deadline);\n+  bool return_memory_to_os(jlong deadline);\n+  bool cleanup_return_infos();\n+\n+  \/\/ Free excess card set memory, main method. Returns true if there is more work\n+  \/\/ to do.\n+  bool free_excess_card_set_memory();\n+\n+  void set_state(State new_state);\n+  \/\/ Returns whether we are currently processing a recent request.\n+  bool is_active() const;\n+\n+  \/\/ The delay used to reschedule this task if not all work has been completed.\n+  jlong reschedule_delay_ms() const;\n+\n+public:\n+  explicit G1CardSetFreeMemoryTask(const char* name);\n+\n+  void execute() override;\n+\n+  \/\/ Notify the task of new used remembered set memory statistics for the young\n+  \/\/ generation and the collection set candidate sets.\n+  void notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n+                        G1CardSetMemoryStats* collection_set_candidate_stats);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,478 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+G1CardSetBuffer::G1CardSetBuffer(uint elem_size, uint num_instances, G1CardSetBuffer* next) :\n+    _elem_size(elem_size), _num_elems(num_instances), _next(next), _next_allocate(0) {\n+\n+  _buffer = NEW_C_HEAP_ARRAY(char, (size_t)_num_elems * elem_size, mtGCCardSet);\n+}\n+\n+G1CardSetBuffer::~G1CardSetBuffer() {\n+  FREE_C_HEAP_ARRAY(mtGCCardSet, _buffer);\n+}\n+\n+void* G1CardSetBuffer::get_new_buffer_elem() {\n+  if (_next_allocate >= _num_elems) {\n+    return nullptr;\n+  }\n+  uint result = Atomic::fetch_and_add(&_next_allocate, 1u, memory_order_relaxed);\n+  if (result >= _num_elems) {\n+    return nullptr;\n+  }\n+  void* r = _buffer + (uint)result * _elem_size;\n+  return r;\n+}\n+\n+void G1CardSetBufferList::bulk_add(G1CardSetBuffer& first, G1CardSetBuffer& last, size_t num, size_t mem_size) {\n+  _list.prepend(first, last);\n+  Atomic::add(&_num_buffers, num, memory_order_relaxed);\n+  Atomic::add(&_mem_size, mem_size, memory_order_relaxed);\n+}\n+\n+void G1CardSetBufferList::print_on(outputStream* out, const char* prefix) {\n+  out->print_cr(\"%s: buffers %zu size %zu\", prefix, Atomic::load(&_num_buffers), Atomic::load(&_mem_size));\n+}\n+\n+G1CardSetBuffer* G1CardSetBufferList::get() {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+\n+  G1CardSetBuffer* result = _list.pop();\n+  if (result != nullptr) {\n+    Atomic::dec(&_num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_mem_size, result->mem_size(), memory_order_relaxed);\n+  }\n+  return result;\n+}\n+\n+G1CardSetBuffer* G1CardSetBufferList::get_all(size_t& num_buffers, size_t& mem_size) {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+\n+  G1CardSetBuffer* result = _list.pop_all();\n+  num_buffers = Atomic::load(&_num_buffers);\n+  mem_size = Atomic::load(&_mem_size);\n+\n+  if (result != nullptr) {\n+    Atomic::sub(&_num_buffers, num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_mem_size, mem_size, memory_order_relaxed);\n+  }\n+  return result;\n+}\n+\n+void G1CardSetBufferList::free_all() {\n+  size_t num_freed = 0;\n+  size_t mem_size_freed = 0;\n+  G1CardSetBuffer* cur;\n+\n+  while ((cur = _list.pop()) != nullptr) {\n+    mem_size_freed += cur->mem_size();\n+    num_freed++;\n+    delete cur;\n+  }\n+\n+  Atomic::sub(&_num_buffers, num_freed, memory_order_relaxed);\n+  Atomic::sub(&_mem_size, mem_size_freed, memory_order_relaxed);\n+}\n+\n+template <class Elem>\n+G1CardSetAllocator<Elem>::G1CardSetAllocator(const char* name,\n+                                             const G1CardSetAllocOptions& buffer_options,\n+                                             G1CardSetBufferList* free_buffer_list) :\n+  _alloc_options(buffer_options),\n+  _first(nullptr),\n+  _last(nullptr),\n+  _num_buffers(0),\n+  _mem_size(0),\n+  _free_buffer_list(free_buffer_list),\n+  _transfer_lock(false),\n+  _free_nodes_list(),\n+  _pending_nodes_list(),\n+  _num_pending_nodes(0),\n+  _num_free_nodes(0),\n+  _num_allocated_nodes(0),\n+  _num_available_nodes(0)\n+{\n+  assert(elem_size() >= sizeof(G1CardSetContainer), \"Element instance size %u for allocator %s too small\",\n+         elem_size(), name);\n+  assert(_free_buffer_list != nullptr, \"precondition!\");\n+}\n+\n+template <class Elem>\n+bool G1CardSetAllocator<Elem>::try_transfer_pending() {\n+  \/\/ Attempt to claim the lock.\n+  if (Atomic::load_acquire(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n+      Atomic::cmpxchg(&_transfer_lock, false, true)) {\n+    return false;\n+  }\n+  \/\/ Have the lock; perform the transfer.\n+\n+  \/\/ Claim all the pending nodes.\n+  G1CardSetContainer* first = _pending_nodes_list.pop_all();\n+\n+  if (first != nullptr) {\n+    \/\/ Prepare to add the claimed nodes, and update _num_pending_nodes.\n+    G1CardSetContainer* last = first;\n+    Atomic::load_acquire(&_num_pending_nodes);\n+\n+    uint count = 1;\n+    for (G1CardSetContainer* next = first->next(); next != nullptr; next = next->next()) {\n+      last = next;\n+      ++count;\n+    }\n+\n+    Atomic::sub(&_num_pending_nodes, count);\n+\n+    \/\/ Wait for any in-progress pops to avoid ABA for them.\n+    GlobalCounter::write_synchronize();\n+    \/\/ Add synchronized nodes to _free_node_list.\n+    \/\/ Update count first so there can be no underflow in allocate().\n+    Atomic::add(&_num_free_nodes, count);\n+    _free_nodes_list.prepend(*first, *last);\n+  }\n+  Atomic::release_store(&_transfer_lock, false);\n+  return true;\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::free(Elem* elem) {\n+  assert(elem != nullptr, \"precondition\");\n+  assert(elem_size() >= sizeof(G1CardSetContainer), \"size mismatch\");\n+  \/\/ Desired minimum transfer batch size.  There is relatively little\n+  \/\/ importance to the specific number.  It shouldn't be too big, else\n+  \/\/ we're wasting space when the release rate is low.  If the release\n+  \/\/ rate is high, we might accumulate more than this before being\n+  \/\/ able to start a new transfer, but that's okay.  Also note that\n+  \/\/ the allocation rate and the release rate are going to be fairly\n+  \/\/ similar, due to how the buffers are used. - kbarret\n+  uint const trigger_transfer = 10;\n+\n+  uint pending_count = Atomic::add(&_num_pending_nodes, 1u, memory_order_relaxed);\n+\n+  G1CardSetContainer* node =  reinterpret_cast<G1CardSetContainer*>(reinterpret_cast<char*>(elem));\n+\n+  node->set_next(nullptr);\n+  assert(node->next() == nullptr, \"precondition\");\n+\n+  _pending_nodes_list.push(*node);\n+\n+  if (pending_count > trigger_transfer) {\n+    try_transfer_pending();\n+  }\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::drop_all() {\n+  _free_nodes_list.pop_all();\n+  _pending_nodes_list.pop_all();\n+  G1CardSetBuffer* cur = Atomic::load_acquire(&_first);\n+\n+  if (cur != nullptr) {\n+    assert(_last != nullptr, \"If there is at least one element, there must be a last one.\");\n+\n+    G1CardSetBuffer* first = cur;\n+#ifdef ASSERT\n+    \/\/ Check list consistency.\n+    G1CardSetBuffer* last = cur;\n+    uint num_buffers = 0;\n+    size_t mem_size = 0;\n+    while (cur != nullptr) {\n+      mem_size += cur->mem_size();\n+      num_buffers++;\n+\n+      G1CardSetBuffer* next = cur->next();\n+      last = cur;\n+      cur = next;\n+    }\n+#endif\n+    assert(num_buffers == _num_buffers, \"Buffer count inconsistent %u %u\", num_buffers, _num_buffers);\n+    assert(mem_size == _mem_size, \"Memory size inconsistent\");\n+    assert(last == _last, \"Inconsistent last element\");\n+\n+    _free_buffer_list->bulk_add(*first, *_last, _num_buffers, _mem_size);\n+  }\n+\n+  _first = nullptr;\n+  _last = nullptr;\n+  _num_available_nodes = 0;\n+  _num_allocated_nodes = 0;\n+  _num_pending_nodes = 0;\n+  _num_buffers = 0;\n+  _mem_size = 0;\n+  _num_free_nodes = 0;\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::print(outputStream* os) {\n+  os->print(\"MA \" PTR_FORMAT \": %u elems pending (allocated %u available %u) used %.3f highest %u buffers %u size %zu \",\n+                p2i(this), _num_pending_nodes, _num_allocated_nodes, _num_available_nodes, percent_of(_num_allocated_nodes - _num_pending_nodes, _num_available_nodes), _first != nullptr ? _first->num_elems() : 0, _num_buffers, mem_size());\n+}\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats() {\n+  clear();\n+}\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats(void(*fn)(const void*,uint,size_t&,size_t&), const void* context) {\n+  clear();\n+  for (uint i = 0; i < num_pools(); i++) {\n+    fn(context, i, _num_mem_sizes[i], _num_buffers[i]);\n+  }\n+}\n+\n+void G1CardSetMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_buffers[i] = 0;\n+  }\n+}\n+\n+void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1CardSetBuffer* cur = _first;\n+  G1CardSetBuffer* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1CardSetBuffer* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1CardSetBufferList();\n+  }\n+}\n+\n+G1CardSetFreePool::~G1CardSetFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1CardSetBufferList();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+static void collect_mem_sizes(const void* context, uint i, size_t& mem_size, size_t& num_buffers) {\n+  ((G1CardSetFreePool*)context)->get_size(i, mem_size, num_buffers);\n+}\n+\n+void G1CardSetFreePool::get_size(uint i, size_t& mem_size, size_t& num_buffers) const {\n+  mem_size = _free_lists[i].mem_size();\n+  num_buffers = _free_lists[i].num_buffers();\n+}\n+\n+G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n+  return G1CardSetMemoryStats(collect_mem_sizes, this);\n+}\n+\n+size_t G1CardSetFreePool::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+void G1CardSetFreePool::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n+\n+G1CardSetMemoryManager::G1CardSetMemoryManager(G1CardSetConfiguration* config,\n+                                               G1CardSetFreePool* free_list_pool) : _config(config) {\n+\n+  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>,\n+                                 _config->num_mem_object_types(),\n+                                 mtGC);\n+  G1CardSetAllocOptions* alloc_options = _config->mem_object_alloc_options();\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    new (&_allocators[i]) G1CardSetAllocator<G1CardSetContainer>(_config->mem_object_type_name_str(i),\n+                                                                 alloc_options[i],\n+                                                                 free_list_pool->free_list(i));\n+  }\n+  FREE_C_HEAP_ARRAY(size_t, alloc_options);\n+}\n+\n+uint G1CardSetMemoryManager::num_mem_object_types() const {\n+  return _config->num_mem_object_types();\n+}\n+\n+\n+G1CardSetMemoryManager::~G1CardSetMemoryManager() {\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].~G1CardSetAllocator();\n+  }\n+  FREE_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>, _allocators);\n+}\n+\n+void G1CardSetMemoryManager::free(uint type, void* value) {\n+  assert(type < num_mem_object_types(), \"must be\");\n+  _allocators[type].free((G1CardSetContainer*)value);\n+}\n+\n+void G1CardSetMemoryManager::flush() {\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].drop_all();\n+  }\n+}\n+\n+void G1CardSetMemoryManager::print(outputStream* os) {\n+  os->print_cr(\"MM \" PTR_FORMAT \" size %zu\", p2i(this), sizeof(*this));\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].print(os);\n+  }\n+}\n+\n+size_t G1CardSetMemoryManager::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result += _allocators[i].mem_size();\n+  }\n+  return sizeof(*this) -\n+    (sizeof(G1CardSetAllocator<G1CardSetContainer>) * num_mem_object_types()) +\n+    result;\n+}\n+\n+size_t G1CardSetMemoryManager::wasted_mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result += _allocators[i].wasted_mem_size();\n+  }\n+  return result;\n+}\n+\n+G1CardSetMemoryStats G1CardSetMemoryManager::memory_stats() const {\n+  G1CardSetMemoryStats result;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result._num_mem_sizes[i] += _allocators[i].mem_size();\n+    result._num_buffers[i] += _allocators[i].num_buffers();\n+  }\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":478,"deletions":0,"binary":false,"changes":478,"status":"added"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETMEMORY_HPP\n+#define SHARE_GC_G1_G1CARDSETMEMORY_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class G1CardSetConfiguration;\n+class outputStream;\n+\n+\/\/ Collects G1CardSetAllocator options\/heuristics. Called by G1CardSetAllocator\n+\/\/ to determine the next size of the allocated G1CardSetBuffer.\n+class G1CardSetAllocOptions {\n+  uint _elem_size;\n+  uint _initial_num_elems;\n+  \/\/ Defines a limit to the number of elements in the buffer\n+  uint _max_num_elems;\n+\n+  uint exponential_expand(uint prev_num_elems) {\n+    return clamp(prev_num_elems * 2, _initial_num_elems, _max_num_elems);\n+  }\n+\n+public:\n+  static const uint BufferAlignment = 8;\n+  static const uint MinimumBufferSize = 8;\n+  static const uint MaximumBufferSize =  UINT_MAX \/ 2;\n+\n+  G1CardSetAllocOptions(uint elem_size, uint initial_num_elems = MinimumBufferSize, uint max_num_elems = MaximumBufferSize) :\n+    _elem_size(align_up(elem_size, BufferAlignment)),\n+    _initial_num_elems(initial_num_elems),\n+    _max_num_elems(max_num_elems) {\n+  }\n+\n+  uint next_num_elems(uint prev_num_elems) {\n+    return exponential_expand(prev_num_elems);\n+  }\n+\n+  uint elem_size () const {return _elem_size;}\n+};\n+\n+\/\/ A single buffer\/arena containing _num_elems blocks of memory of _elem_size.\n+\/\/ G1CardSetBuffers can be linked together using a singly linked list.\n+class G1CardSetBuffer : public CHeapObj<mtGCCardSet> {\n+  uint _elem_size;\n+  uint _num_elems;\n+\n+  G1CardSetBuffer* volatile _next;\n+\n+  char* _buffer;  \/\/ Actual data.\n+\n+  \/\/ Index into the next free block to allocate into. Full if equal (or larger)\n+  \/\/ to _num_elems (can be larger because we atomically increment this value and\n+  \/\/ check only afterwards if the allocation has been successful).\n+  uint volatile _next_allocate;\n+\n+public:\n+  G1CardSetBuffer(uint elem_size, uint num_elems, G1CardSetBuffer* next);\n+  ~G1CardSetBuffer();\n+\n+  G1CardSetBuffer* volatile* next_addr() { return &_next; }\n+\n+  void* get_new_buffer_elem();\n+\n+  uint num_elems() const { return _num_elems; }\n+\n+  G1CardSetBuffer* next() const { return _next; }\n+\n+  void set_next(G1CardSetBuffer* next) {\n+    assert(next != this, \" loop condition\");\n+    _next = next;\n+  }\n+\n+  void reset(G1CardSetBuffer* next) {\n+    _next_allocate = 0;\n+    assert(next != this, \" loop condition\");\n+    set_next(next);\n+    memset((void*)_buffer, 0, (size_t)_num_elems * _elem_size);\n+  }\n+\n+  uint elem_size() const { return _elem_size; }\n+\n+  size_t mem_size() const { return sizeof(*this) + (size_t)_num_elems * _elem_size; }\n+\n+  bool is_full() const { return _next_allocate >= _num_elems; }\n+};\n+\n+\/\/ Set of (free) G1CardSetBuffers. The assumed usage is that allocation\n+\/\/ to it and removal of elements is strictly separate, but every action may be\n+\/\/ performed by multiple threads at the same time.\n+\/\/ Counts and memory usage are current on a best-effort basis if accessed concurrently.\n+class G1CardSetBufferList {\n+  static G1CardSetBuffer* volatile* next_ptr(G1CardSetBuffer& node) {\n+    return node.next_addr();\n+  }\n+  typedef LockFreeStack<G1CardSetBuffer, &next_ptr> NodeStack;\n+\n+  NodeStack _list;\n+\n+  volatile size_t _num_buffers;\n+  volatile size_t _mem_size;\n+\n+public:\n+  G1CardSetBufferList() : _list(), _num_buffers(0), _mem_size(0) { }\n+  ~G1CardSetBufferList() { free_all(); }\n+\n+  void bulk_add(G1CardSetBuffer& first, G1CardSetBuffer& last, size_t num, size_t mem_size);\n+  void add(G1CardSetBuffer& elem) { _list.prepend(elem); }\n+\n+  G1CardSetBuffer* get();\n+  G1CardSetBuffer* get_all(size_t& num_buffers, size_t& mem_size);\n+\n+  \/\/ Give back all memory to the OS.\n+  void free_all();\n+\n+  void print_on(outputStream* out, const char* prefix = \"\");\n+\n+  size_t num_buffers() const { return Atomic::load(&_num_buffers); }\n+  size_t mem_size() const { return Atomic::load(&_mem_size); }\n+};\n+\n+\/\/ Arena-like allocator for (card set) heap memory objects (Elem elements).\n+\/\/\n+\/\/ Actual allocation from the C heap occurs on G1CardSetBuffer basis, i.e. sets\n+\/\/ of elements. The assumed allocation pattern for these G1CardSetBuffer elements\n+\/\/ is assumed to be strictly two-phased:\n+\/\/\n+\/\/ - in the first phase, G1CardSetBuffers are allocated from the C heap (or a free\n+\/\/ list given at initialization time). This allocation may occur in parallel. This\n+\/\/ typically corresponds to a single mutator phase, but may extend over multiple.\n+\/\/\n+\/\/ - in the second phase, G1CardSetBuffers are given back in bulk to the free list.\n+\/\/ This is typically done during a GC pause.\n+\/\/\n+\/\/ Some third party is responsible for giving back memory from the free list to\n+\/\/ the operating system.\n+\/\/\n+\/\/ Allocation and deallocation in the first phase on G1CardSetContainer basis\n+\/\/ may occur by multiple threads at once.\n+\/\/\n+\/\/ Allocation occurs from an internal free list of G1CardSetContainers first,\n+\/\/ only then trying to bump-allocate from the current G1CardSetBuffer. If there is\n+\/\/ none, this class allocates a new G1CardSetBuffer (allocated from the C heap,\n+\/\/ asking the G1CardSetAllocOptions instance about sizes etc) and uses that one.\n+\/\/\n+\/\/ The G1CardSetContainerOnHeaps free list is a linked list of G1CardSetContainers\n+\/\/ within all G1CardSetBuffer instances allocated so far. It uses a separate\n+\/\/ pending list and global synchronization to avoid the ABA problem when the\n+\/\/ user frees a memory object.\n+\/\/\n+\/\/ The class also manages a few counters for statistics using atomic operations.\n+\/\/ Their values are only consistent within each other with extra global\n+\/\/ synchronization.\n+\/\/\n+\/\/ Since it is expected that every CardSet (and in extension each region) has its\n+\/\/ own set of allocators, there is intentionally no padding between them to save\n+\/\/ memory.\n+template <class Elem>\n+class G1CardSetAllocator {\n+  \/\/ G1CardSetBuffer management.\n+\n+  \/\/ G1CardSetAllocOptions provides parameters for allocation buffer\n+  \/\/ sizing and expansion.\n+  G1CardSetAllocOptions _alloc_options;\n+\n+  G1CardSetBuffer* volatile _first;       \/\/ The (start of the) list of all buffers.\n+  G1CardSetBuffer* _last;                 \/\/ The last element of the list of all buffers.\n+  volatile uint _num_buffers;             \/\/ Number of assigned buffers to this allocator.\n+  volatile size_t _mem_size;              \/\/ Memory used by all buffers.\n+\n+  G1CardSetBufferList* _free_buffer_list; \/\/ The global free buffer list to\n+                                          \/\/ preferentially get new buffers from.\n+\n+  \/\/ G1CardSetContainer node management within the G1CardSetBuffers allocated\n+  \/\/ by this allocator.\n+\n+  static G1CardSetContainer* volatile* next_ptr(G1CardSetContainer& node);\n+  typedef LockFreeStack<G1CardSetContainer, &G1CardSetAllocator::next_ptr> NodeStack;\n+\n+  volatile bool _transfer_lock;\n+  NodeStack _free_nodes_list;\n+  NodeStack _pending_nodes_list;\n+\n+  volatile uint _num_pending_nodes;   \/\/ Number of nodes in the pending list.\n+  volatile uint _num_free_nodes;      \/\/ Number of nodes in the free list.\n+\n+  volatile uint _num_allocated_nodes; \/\/ Number of total nodes allocated and in use.\n+  volatile uint _num_available_nodes; \/\/ Number of nodes available in all buffers (allocated + free + pending + not yet used).\n+\n+  \/\/ Try to transfer nodes from _pending_nodes_list to _free_nodes_list, with a\n+  \/\/ synchronization delay for any in-progress pops from the _free_nodes_list\n+  \/\/ to solve ABA here.\n+  bool try_transfer_pending();\n+\n+  uint num_free_elems() const;\n+\n+  G1CardSetBuffer* create_new_buffer(G1CardSetBuffer* const prev);\n+\n+  uint elem_size() const { return _alloc_options.elem_size(); }\n+\n+public:\n+  G1CardSetAllocator(const char* name,\n+                     const G1CardSetAllocOptions& buffer_options,\n+                     G1CardSetBufferList* free_buffer_list);\n+  ~G1CardSetAllocator() {\n+    drop_all();\n+  }\n+\n+  Elem* allocate();\n+  void free(Elem* elem);\n+\n+  \/\/ Deallocate all buffers to the free buffer list and reset this allocator. Must\n+  \/\/ be called in a globally synchronized area.\n+  void drop_all();\n+\n+  uint num_buffers() const;\n+\n+  size_t mem_size() const {\n+    return sizeof(*this) +\n+      num_buffers() * sizeof(G1CardSetBuffer) + (size_t)_num_available_nodes * elem_size();\n+  }\n+\n+  size_t wasted_mem_size() const {\n+    return ((size_t)_num_available_nodes - (_num_allocated_nodes - _num_pending_nodes)) * elem_size();\n+  }\n+\n+  void print(outputStream* os);\n+};\n+\n+\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1CardSetMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1CardSetMemoryStats();\n+  \/\/ For every element in the set (indicated by i), call fn to provide the\n+  \/\/ memory size and number of buffers for that i'th buffer list.\n+  G1CardSetMemoryStats(void (*fn)(const void* context, uint i, size_t& mem_size, size_t& num_buffers), const void* context);\n+\n+  void add(G1CardSetMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_buffers[i] += other._num_buffers[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n+class G1CardSetFreePool {\n+  \/\/ The global free pool.\n+  static G1CardSetFreePool _freelist_pool;\n+\n+  uint _num_free_lists;\n+  G1CardSetBufferList* _free_lists;\n+\n+public:\n+  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n+  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1CardSetFreePool(uint num_free_lists);\n+  ~G1CardSetFreePool();\n+\n+  G1CardSetBufferList* free_list(uint i) {\n+    assert(i < _num_free_lists, \"must be\");\n+    return &_free_lists[i];\n+  }\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  \/\/ Return sizes for free list i in this free list pool.\n+  void get_size(uint i, size_t& mem_size, size_t& num_buffers) const;\n+\n+  G1CardSetMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1CardSetBufferList.\n+class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1CardSetBufferList* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1CardSetBuffer* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given card set buffer list for the purpose\n+  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n+  \/\/ nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1CardSetBufferList* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+class G1CardSetMemoryManager : public CHeapObj<mtGCCardSet> {\n+  G1CardSetConfiguration* _config;\n+\n+  G1CardSetAllocator<G1CardSetContainer>* _allocators;\n+\n+  uint num_mem_object_types() const;\n+public:\n+  G1CardSetMemoryManager(G1CardSetConfiguration* config,\n+                         G1CardSetFreePool* free_list_pool);\n+\n+  virtual ~G1CardSetMemoryManager();\n+\n+  \/\/ Allocate and free a memory object of given type.\n+  inline uint8_t* allocate(uint type);\n+  void free(uint type, void* value);\n+\n+  \/\/ Allocate and free a hash table node.\n+  inline uint8_t* allocate_node();\n+  inline void free_node(void* value);\n+\n+  void flush();\n+\n+  void print(outputStream* os);\n+\n+  size_t mem_size() const;\n+  size_t wasted_mem_size() const;\n+\n+  G1CardSetMemoryStats memory_stats() const;\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETMEMORY_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"utilities\/globalCounter.inline.hpp\"\n+\n+template <class Elem>\n+G1CardSetContainer* volatile* G1CardSetAllocator<Elem>::next_ptr(G1CardSetContainer& node) {\n+  return node.next_addr();\n+}\n+\n+template <class Elem>\n+G1CardSetBuffer* G1CardSetAllocator<Elem>::create_new_buffer(G1CardSetBuffer* const prev) {\n+\n+  \/\/ Take an existing buffer if available.\n+  G1CardSetBuffer* next = _free_buffer_list->get();\n+  if (next == nullptr) {\n+    uint prev_num_elems = (prev != nullptr) ? prev->num_elems() : 0;\n+    uint num_elems = _alloc_options.next_num_elems(prev_num_elems);\n+    next = new G1CardSetBuffer(elem_size(), num_elems, prev);\n+  } else {\n+    assert(elem_size() == next->elem_size() , \"Mismatch %d != %d Elem %zu\", elem_size(), next->elem_size(), sizeof(Elem));\n+    next->reset(prev);\n+  }\n+\n+  \/\/ Install it as current allocation buffer.\n+  G1CardSetBuffer* old = Atomic::cmpxchg(&_first, prev, next);\n+  if (old != prev) {\n+    \/\/ Somebody else installed the buffer, use that one.\n+    delete next;\n+    return old;\n+  } else {\n+    \/\/ Did we install the first element in the list? If so, this is also the last.\n+    if (prev == nullptr) {\n+      _last = next;\n+    }\n+    \/\/ Successfully installed the buffer into the list.\n+    Atomic::inc(&_num_buffers, memory_order_relaxed);\n+    Atomic::add(&_mem_size, next->mem_size(), memory_order_relaxed);\n+    Atomic::add(&_num_available_nodes, next->num_elems(), memory_order_relaxed);\n+    return next;\n+  }\n+}\n+\n+template <class Elem>\n+Elem* G1CardSetAllocator<Elem>::allocate() {\n+  assert(elem_size() > 0, \"instance size not set.\");\n+\n+  if (num_free_elems() > 0) {\n+    \/\/ Pop under critical section to deal with ABA problem\n+    \/\/ Other solutions to the same problem are more complicated (ref counting, HP)\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+\n+    G1CardSetContainer* node = _free_nodes_list.pop();\n+    if (node != nullptr) {\n+      Elem* elem = reinterpret_cast<Elem*>(reinterpret_cast<char*>(node));\n+      Atomic::sub(&_num_free_nodes, 1u);\n+      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n+      return elem;\n+    }\n+  }\n+\n+  G1CardSetBuffer* cur = Atomic::load_acquire(&_first);\n+  if (cur == nullptr) {\n+    cur = create_new_buffer(cur);\n+  }\n+\n+  while (true) {\n+    Elem* elem = (Elem*)cur->get_new_buffer_elem();\n+    if (elem != nullptr) {\n+      Atomic::inc(&_num_allocated_nodes, memory_order_relaxed);\n+      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n+      return elem;\n+    }\n+    \/\/ The buffer is full. Next round.\n+    assert(cur->is_full(), \"must be\");\n+    cur = create_new_buffer(cur);\n+  }\n+}\n+\n+inline uint8_t* G1CardSetMemoryManager::allocate(uint type) {\n+  assert(type < num_mem_object_types(), \"must be\");\n+  return (uint8_t*)_allocators[type].allocate();\n+}\n+\n+inline uint8_t* G1CardSetMemoryManager::allocate_node() {\n+  return allocate(0);\n+}\n+\n+inline void G1CardSetMemoryManager::free_node(void* value) {\n+  free(0, value);\n+}\n+\n+template <class Elem>\n+inline uint G1CardSetAllocator<Elem>::num_buffers() const {\n+  return Atomic::load(&_num_buffers);\n+}\n+\n+template <class Elem>\n+inline uint G1CardSetAllocator<Elem>::num_free_elems() const {\n+  return Atomic::load(&_num_free_nodes);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -105,1 +105,1 @@\n-  inline size_t mark_region_dirty(size_t start_card_index, size_t num_cards);\n+  inline size_t mark_range_dirty(size_t start_card_index, size_t num_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-inline size_t G1CardTable::mark_region_dirty(size_t start_card_index, size_t num_cards) {\n+inline size_t G1CardTable::mark_range_dirty(size_t start_card_index, size_t num_cards) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -71,1 +72,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -150,1 +151,1 @@\n-  return new HeapRegion(hrs_index, bot(), mr);\n+  return new HeapRegion(hrs_index, bot(), mr, &_card_set_config);\n@@ -1439,0 +1440,1 @@\n+  _free_card_set_memory_task(NULL),\n@@ -1475,0 +1477,1 @@\n+  _card_set_config(),\n@@ -1480,1 +1483,1 @@\n-  _regions_failed_evacuation(NULL),\n+  _regions_failed_evacuation(mtGC),\n@@ -1744,0 +1747,3 @@\n+  _free_card_set_memory_task = new G1CardSetFreeMemoryTask(\"Card Set Free Memory Task\");\n+  _service_thread->register_task(_free_card_set_memory_task);\n+\n@@ -1773,1 +1779,1 @@\n-  _regions_failed_evacuation = NEW_C_HEAP_ARRAY(volatile bool, max_regions(), mtGC);\n+  _regions_failed_evacuation.resize(max_regions());\n@@ -2624,0 +2630,3 @@\n+\n+  _free_card_set_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n+                                               &_collection_set_candidates_card_set_stats);\n@@ -2845,0 +2854,3 @@\n+  if (evacuation_failed()) {\n+    type = (G1HeapVerifier::G1VerifyType)(type | G1HeapVerifier::G1VerifyYoungEvacFail);\n+  }\n@@ -2961,1 +2973,0 @@\n-\n@@ -2970,1 +2981,0 @@\n-\n@@ -2975,1 +2985,0 @@\n-\n@@ -3064,6 +3073,0 @@\n-    \/\/ We must call G1MonitoringSupport::update_sizes() in the same scoping level\n-    \/\/ as an active TraceMemoryManagerStats object (i.e. before the destructor for the\n-    \/\/ TraceMemoryManagerStats is called) so that the G1 memory pools are updated\n-    \/\/ before any GC notifications are raised.\n-    g1mm()->update_sizes();\n-\n@@ -3322,0 +3325,9 @@\n+bool G1CollectedHeap::should_sample_collection_set_candidates() const {\n+  G1CollectionSetCandidates* candidates = G1CollectedHeap::heap()->collection_set()->candidates();\n+  return candidates != NULL && candidates->num_remaining() > 0;\n+}\n+\n+void G1CollectedHeap::set_collection_set_candidates_stats(G1CardSetMemoryStats& stats) {\n+  _collection_set_candidates_card_set_stats = stats;\n+}\n+\n@@ -3329,0 +3341,11 @@\n+    G1CardSetMemoryStats _card_set_stats;\n+\n+    void sample_card_set_size(HeapRegion* hr) {\n+      \/\/ Sample card set sizes for young gen and humongous before GC: this makes\n+      \/\/ the policy to give back memory to the OS keep the most recent amount of\n+      \/\/ memory for these regions.\n+      if (hr->is_young() || hr->is_starts_humongous()) {\n+        _card_set_stats.add(hr->rem_set()->card_set_memory_stats());\n+      }\n+    }\n+\n@@ -3401,0 +3424,2 @@\n+      sample_card_set_size(hr);\n+\n@@ -3431,0 +3456,4 @@\n+\n+    G1CardSetMemoryStats card_set_stats() const {\n+      return _card_set_stats;\n+    }\n@@ -3437,0 +3466,3 @@\n+\n+  G1CardSetMemoryStats _all_card_set_stats;\n+\n@@ -3448,0 +3480,3 @@\n+\n+    MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+    _all_card_set_stats.add(cl.card_set_stats());\n@@ -3465,0 +3500,4 @@\n+\n+  G1CardSetMemoryStats all_card_set_stats() const {\n+    return _all_card_set_stats;\n+  }\n@@ -3473,1 +3512,1 @@\n-  memset((void*)_regions_failed_evacuation, false, sizeof(bool) * max_regions());\n+  _regions_failed_evacuation.clear();\n@@ -3492,0 +3531,2 @@\n+    _young_gen_card_set_stats = g1_prep_task.all_card_set_stats();\n+\n@@ -3766,0 +3807,1 @@\n+  rem_set()->print_coarsen_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":56,"deletions":14,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n@@ -58,0 +60,1 @@\n+#include \"utilities\/bitMap.hpp\"\n@@ -68,0 +71,1 @@\n+class G1CardSetFreeMemoryTask;\n@@ -160,0 +164,1 @@\n+  G1CardSetFreeMemoryTask* _free_card_set_memory_task;\n@@ -175,0 +180,5 @@\n+  \/\/ Young gen memory statistics before GC.\n+  G1CardSetMemoryStats _young_gen_card_set_stats;\n+  \/\/ Collection set candidates memory statistics after GC.\n+  G1CardSetMemoryStats _collection_set_candidates_card_set_stats;\n+\n@@ -269,0 +279,3 @@\n+  bool should_sample_collection_set_candidates() const;\n+  void set_collection_set_candidates_stats(G1CardSetMemoryStats& stats);\n+\n@@ -842,0 +855,2 @@\n+  \/\/ Global card set configuration\n+  G1CardSetConfiguration _card_set_config;\n@@ -871,1 +886,1 @@\n-  volatile bool* _regions_failed_evacuation;\n+  CHeapBitMap _regions_failed_evacuation;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n@@ -198,3 +199,1 @@\n-  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n-\n-  return Atomic::load(&_regions_failed_evacuation[region_idx]);\n+  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n@@ -208,4 +207,1 @@\n-  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n-\n-  volatile bool* region_failed_addr = &_regions_failed_evacuation[region_idx];\n-  bool result = !Atomic::load(region_failed_addr) && !Atomic::cmpxchg(region_failed_addr, false, true, memory_order_relaxed);\n+  bool result = _regions_failed_evacuation.par_set_bit(region_idx, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -42,1 +43,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -1695,1 +1696,1 @@\n-        thread->as_Java_thread()->nmethods_do(&_code_cl);\n+        JavaThread::cast(thread)->nmethods_do(&_code_cl);\n@@ -2950,1 +2951,1 @@\n-  _total_remset_bytes += HeapRegionRemSet::fl_mem_size() + HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += G1CardSetFreePool::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -48,1 +48,0 @@\n-#include \"utilities\/lockFreeQueue.inline.hpp\"\n@@ -50,0 +49,1 @@\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n@@ -134,2 +134,2 @@\n-\/\/ the _completed queue, using the LockFreeQueue::try_pop() underneath.\n-\/\/ It has a restriction that it may return NULL when there are objects\n+\/\/ the _completed queue, using the NonblockingQueue::try_pop() underneath.\n+\/\/ It has a limitation that it may return NULL when there are objects\n@@ -138,1 +138,0 @@\n-  using Status = LockFreeQueuePopStatus;\n@@ -140,0 +139,1 @@\n+  BufferNode* result = NULL;\n@@ -150,13 +150,1 @@\n-    Pair<Status, BufferNode*> pop_result = _completed.try_pop();\n-    switch (pop_result.first) {\n-      case Status::success:\n-        return pop_result.second;\n-      case Status::operation_in_progress:\n-        \/\/ Returning NULL instead retrying, in order to mitigate the\n-        \/\/ chance of spinning for a long time. In the case of getting a\n-        \/\/ buffer to refine, it is also OK to return NULL when there is\n-        \/\/ an interfering concurrent push\/append operation.\n-        return NULL;\n-      case Status::lost_race:\n-        break;  \/\/ Try again.\n-    }\n+    if (_completed.try_pop(&result)) return result;\n@@ -180,2 +168,3 @@\n-  BufferNode* cur = _completed.top();\n-  for ( ; cur != NULL; cur = cur->next()) {\n+  for (BufferNode* cur = _completed.first();\n+       !_completed.is_end(cur);\n+       cur = cur->next()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"utilities\/lockFreeQueue.hpp\"\n+#include \"utilities\/nonblockingQueue.hpp\"\n@@ -167,3 +167,3 @@\n-  \/\/ LockFreeQueue has inner padding of one cache line.\n-  LockFreeQueue<BufferNode, &BufferNode::next_ptr> _completed;\n-  \/\/ Add a trailer padding after LockFreeQueue.\n+  \/\/ NonblockingQueue has inner padding of one cache line.\n+  NonblockingQueue<BufferNode, &BufferNode::next_ptr> _completed;\n+  \/\/ Add a trailer padding after NonblockingQueue.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -189,4 +188,0 @@\n-  \/\/ We should save the marks of the currently locked biased monitors.\n-  \/\/ The marking doesn't preserve the marks of biased objects.\n-  BiasedLocking::preserve_marks();\n-\n@@ -219,2 +214,0 @@\n-  BiasedLocking::restore_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,4 +111,1 @@\n-      \/\/ since it will be restored by preserved marks. There is an exception\n-      \/\/ with BiasedLocking, in this case forwardee() will return NULL\n-      \/\/ even if the mark-word is used. This is no problem since\n-      \/\/ forwardee() will return NULL in the compaction phase as well.\n+      \/\/ since it will be restored by preserved marks.\n@@ -119,3 +116,2 @@\n-      assert(object->mark() == markWord::prototype_for_klass(object->klass()) || \/\/ Correct mark\n-             object->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-             (UseBiasedLocking && object->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n+      assert(object->mark() == markWord::prototype() || \/\/ Correct mark\n+             object->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n@@ -123,1 +119,1 @@\n-             p2i(object), object->mark().value(), markWord::prototype_for_klass(object->klass()).value());\n+             p2i(object), object->mark().value(), markWord::prototype().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -83,3 +83,2 @@\n-    assert(obj->mark() == markWord::prototype_for_klass(obj->klass()) || \/\/ Correct mark\n-           obj->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-           (UseBiasedLocking && obj->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n+    assert(obj->mark() == markWord::prototype() || \/\/ Correct mark\n+           obj->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n@@ -87,1 +86,1 @@\n-           p2i(obj), obj->mark().value(), markWord::prototype_for_klass(obj->klass()).value());\n+           p2i(obj), obj->mark().value(), markWord::prototype().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -54,5 +54,0 @@\n-  \/\/ We must call G1MonitoringSupport::update_sizes() in the same scoping level\n-  \/\/ as an active TraceMemoryManagerStats object (i.e. before the destructor for the\n-  \/\/ TraceMemoryManagerStats is called) so that the G1 memory pools are updated\n-  \/\/ before any GC notifications are raised.\n-  _g1h->g1mm()->update_sizes();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+constexpr const char* G1GCPhaseTimes::GCMergeRSWorkItemsStrings[];\n+\n@@ -74,4 +76,3 @@\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Sparse:\", MergeRSMergedSparse);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Fine:\", MergeRSMergedFine);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Coarse:\", MergeRSMergedCoarse);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Dirty Cards:\", MergeRSDirtyCards);\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n+    _gc_par_phases[MergeRS]->create_thread_work_items(GCMergeRSWorkItemsStrings[i], i);\n+  }\n@@ -80,4 +81,3 @@\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Sparse:\", MergeRSMergedSparse);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Fine:\", MergeRSMergedFine);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Coarse:\", MergeRSMergedCoarse);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Dirty Cards:\", MergeRSDirtyCards);\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n+    _gc_par_phases[OptMergeRS]->create_thread_work_items(GCMergeRSWorkItemsStrings[i], i);\n+  }\n@@ -137,0 +137,2 @@\n+  _gc_par_phases[SampleCollectionSetCandidates] = new WorkerDataArray<double>(\"SampleCandidates\", \"Sample CSet Candidates (ms):\", max_gc_threads);\n+\n@@ -173,0 +175,1 @@\n+  _recorded_sample_collection_set_candidates_time_ms = 0.0;\n@@ -452,0 +455,1 @@\n+                        _recorded_sample_collection_set_candidates_time_ms +\n@@ -475,0 +479,2 @@\n+  debug_time(\"Sample Collection Set Candidates\", _recorded_sample_collection_set_candidates_time_ms);\n+  trace_phase(_gc_par_phases[RedirtyCards]);\n@@ -488,0 +494,3 @@\n+  if (G1CollectedHeap::heap()->should_sample_collection_set_candidates()) {\n+    debug_phase(_gc_par_phases[SampleCollectionSetCandidates], 1);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    SampleCollectionSetCandidates,\n@@ -100,5 +101,11 @@\n-  enum GCMergeRSWorkTimes {\n-    MergeRSMergedSparse,\n-    MergeRSMergedFine,\n-    MergeRSMergedCoarse,\n-    MergeRSDirtyCards\n+  enum GCMergeRSWorkItems : uint {\n+    MergeRSMergedInline = 0,\n+    MergeRSMergedArrayOfCards,\n+    MergeRSMergedHowl,\n+    MergeRSMergedFull,\n+    MergeRSHowlInline,\n+    MergeRSHowlArrayOfCards,\n+    MergeRSHowlBitmap,\n+    MergeRSHowlFull,\n+    MergeRSDirtyCards,\n+    MergeRSContainersSentinel\n@@ -107,0 +114,5 @@\n+  static constexpr const char* GCMergeRSWorkItemsStrings[MergeRSContainersSentinel] =\n+    { \"Merged Inline\", \"Merged ArrayOfCards\", \"Merged Howl\", \"Merged Full\",\n+      \"Merged Howl Inline\", \"Merged Howl ArrayOfCards\", \"Merged Howl BitMap\", \"Merged Howl Full\",\n+      \"Dirty Cards\" };\n+\n@@ -176,0 +188,2 @@\n+  double _recorded_sample_collection_set_candidates_time_ms;\n+\n@@ -332,0 +346,4 @@\n+  void record_sample_collection_set_candidates_time_ms(double time_ms) {\n+    _recorded_sample_collection_set_candidates_time_ms = time_ms;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  return (_enabled_verification_types & type) == type;\n+  return (_enabled_verification_types & type) != 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,3 +48,4 @@\n-    G1VerifyRemark          =  8, \/\/ -XX:VerifyGCType=remark\n-    G1VerifyCleanup         = 16, \/\/ -XX:VerifyGCType=cleanup\n-    G1VerifyFull            = 32, \/\/ -XX:VerifyGCType=full\n+    G1VerifyYoungEvacFail   =  8, \/\/ -XX:VerifyGCType=young-evac-fail\n+    G1VerifyRemark          = 16, \/\/ -XX:VerifyGCType=remark\n+    G1VerifyCleanup         = 32, \/\/ -XX:VerifyGCType=cleanup\n+    G1VerifyFull            = 64, \/\/ -XX:VerifyGCType=full\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+  _g1mm(g1mm),\n@@ -350,0 +351,4 @@\n+\n+G1MonitoringScope::~G1MonitoringScope() {\n+  _g1mm->update_sizes();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+  G1MonitoringSupport* _g1mm;\n@@ -245,0 +246,1 @@\n+  ~G1MonitoringScope();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -53,0 +53,2 @@\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n@@ -48,1 +49,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -384,3 +384,1 @@\n-    if (!_region_scan_chunks[chunk_idx]) {\n-      _region_scan_chunks[chunk_idx] = true;\n-    }\n+    _region_scan_chunks[chunk_idx] = true;\n@@ -1064,1 +1062,1 @@\n-\/\/ Small ring buffer used for prefetching cards for read\/write from the card\n+\/\/ Small ring buffer used for prefetching cards for write from the card\n@@ -1066,1 +1064,1 @@\n-template <class T, bool for_write>\n+template <class T>\n@@ -1099,5 +1097,1 @@\n-    if (for_write) {\n-      Prefetch::write(elem, 0);\n-    } else {\n-      Prefetch::read(elem, 0);\n-    }\n+    Prefetch::write(elem, 0);\n@@ -1114,1 +1108,27 @@\n-  \/\/ Visitor for remembered sets, dropping entries onto the card table.\n+  class G1MergeCardSetStats {\n+    size_t _merged[G1GCPhaseTimes::MergeRSContainersSentinel];\n+\n+  public:\n+    G1MergeCardSetStats() {\n+      for (uint i = 0; i < ARRAY_SIZE(_merged); i++) {\n+        _merged[i] = 0;\n+      }\n+    }\n+\n+    void inc_card_set_merged(uint tag) {\n+      assert(tag < ARRAY_SIZE(_merged), \"tag out of bounds %u\", tag);\n+      _merged[tag]++;\n+    }\n+\n+    void inc_cards_dirty(size_t increment = 1) {\n+      _merged[G1GCPhaseTimes::MergeRSDirtyCards] += increment;\n+    }\n+\n+    size_t merged(uint i) const { return _merged[i]; }\n+  };\n+\n+  \/\/ Visitor for remembered sets. Several methods of it are called by a region's\n+  \/\/ card set iterator to drop card set remembered set entries onto the card.\n+  \/\/ table. This is in addition to being the HeapRegionClosure to iterate over\n+  \/\/ all region's remembered sets.\n+  \/\/\n@@ -1124,5 +1144,1 @@\n-    uint _merged_sparse;\n-    uint _merged_fine;\n-    uint _merged_coarse;\n-\n-    size_t _cards_dirty;\n+    G1MergeCardSetStats _stats;\n@@ -1134,1 +1150,1 @@\n-    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true> {\n+    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue> {\n@@ -1141,1 +1157,1 @@\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true>(G1CardTable::dirty_card_val()),\n+        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue>(G1CardTable::dirty_card_val()),\n@@ -1163,1 +1179,1 @@\n-        _cards_dirty++;\n+        _stats.inc_cards_dirty();\n@@ -1168,4 +1184,0 @@\n-    void start_iterate(uint const region_idx) {\n-      _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n-    }\n-\n@@ -1173,0 +1185,1 @@\n+\n@@ -1176,4 +1189,1 @@\n-      _merged_sparse(0),\n-      _merged_fine(0),\n-      _merged_coarse(0),\n-      _cards_dirty(0),\n+      _stats(),\n@@ -1181,2 +1191,1 @@\n-      _merge_card_set_cache(this) {\n-    }\n+      _merge_card_set_cache(this) { }\n@@ -1191,24 +1200,7 @@\n-    void next_coarse_prt(uint const region_idx) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_coarse++;\n-\n-      start_iterate(region_idx);\n-      _cards_dirty += _ct->mark_region_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n-      _scan_state->set_chunk_region_dirty(_region_base_idx);\n-    }\n-\n-    void next_fine_prt(uint const region_idx, BitMap* bm) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_fine++;\n-\n-      start_iterate(region_idx);\n-      BitMap::idx_t cur = bm->get_next_one_offset(0);\n-      while (cur != bm->size()) {\n-        do_card((uint)cur);\n-        cur = bm->get_next_one_offset(cur + 1);\n+    \/\/ Returns whether the given region actually needs iteration.\n+    bool start_iterate(uint const tag, uint const region_idx) {\n+      assert(tag < G1GCPhaseTimes::MergeRSDirtyCards, \"invalid tag %u\", tag);\n+      if (remember_if_interesting(region_idx)) {\n+        _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n+        _stats.inc_card_set_merged(tag);\n+        return true;\n@@ -1216,0 +1208,1 @@\n+      return false;\n@@ -1218,11 +1211,6 @@\n-    void next_sparse_prt(uint const region_idx, SparsePRTEntry::card_elem_t* cards, uint const num_cards) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_sparse++;\n-\n-      start_iterate(region_idx);\n-      for (uint i = 0; i < num_cards; i++) {\n-        do_card(cards[i]);\n-      }\n+    void do_card_range(uint const start_card_idx, uint const length) {\n+      assert(start_card_idx == 0, \"must be\");\n+      assert(length == HeapRegion::CardsPerRegion, \"must be\");\n+      size_t num_dirtied = _ct->mark_range_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n+      _stats.inc_cards_dirty(num_dirtied);\n+      _scan_state->set_chunk_region_dirty(_region_base_idx);\n@@ -1231,1 +1219,1 @@\n-    \/\/ Helper to put the remembered set cards for these regions onto the card\n+    \/\/ Helper to merge the cards in the card set for the given region onto the card\n@@ -1245,1 +1233,1 @@\n-    void dump_rem_set_for_region(HeapRegion* r) {\n+    void merge_card_set_for_region(HeapRegion* r) {\n@@ -1250,1 +1238,1 @@\n-        rem_set->iterate_prts(*this);\n+        rem_set->iterate_for_merge(*this);\n@@ -1258,1 +1246,1 @@\n-      dump_rem_set_for_region(r);\n+      merge_card_set_for_region(r);\n@@ -1263,5 +1251,1 @@\n-    size_t merged_sparse() const { return _merged_sparse; }\n-    size_t merged_fine() const { return _merged_fine; }\n-    size_t merged_coarse() const { return _merged_coarse; }\n-\n-    size_t cards_dirty() const { return _cards_dirty; }\n+    G1MergeCardSetStats stats() const { return _stats; }\n@@ -1273,1 +1257,2 @@\n-    G1MergeCardSetClosure _cl;\n+    G1RemSetScanState* _scan_state;\n+    G1MergeCardSetStats _merge_stats;\n@@ -1276,1 +1261,1 @@\n-    G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _cl(scan_state) { }\n+    G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _scan_state(scan_state), _merge_stats() { }\n@@ -1290,1 +1275,6 @@\n-      _cl.dump_rem_set_for_region(r);\n+      G1MergeCardSetStats stats;\n+      {\n+        G1MergeCardSetClosure cl(_scan_state);\n+        cl.merge_card_set_for_region(r);\n+        stats = cl.stats();\n+      }\n@@ -1310,5 +1300,1 @@\n-    size_t merged_sparse() const { return _cl.merged_sparse(); }\n-    size_t merged_fine() const { return _cl.merged_fine(); }\n-    size_t merged_coarse() const { return _cl.merged_coarse(); }\n-\n-    size_t cards_dirty() const { return _cl.cards_dirty(); }\n+    size_t merged(uint i) const { return _merge_stats.merged(i); }\n@@ -1319,1 +1305,0 @@\n-    friend class G1MergeLogBufferCardsCache;\n@@ -1327,17 +1312,0 @@\n-    class G1MergeLogBufferCardsCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false> {\n-      G1MergeLogBufferCardsClosure* const _merge_log_buffer_cl;\n-\n-    public:\n-      G1MergeLogBufferCardsCache(G1MergeLogBufferCardsClosure* const merge_log_buffer_cl) :\n-        \/\/ Initially set dummy card value to Clean to avoid any actual work if we\n-        \/\/ try to process it.\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false>(G1CardTable::clean_card_val()),\n-        _merge_log_buffer_cl(merge_log_buffer_cl) { }\n-\n-      ~G1MergeLogBufferCardsCache() {\n-        for (uint i = 0; i < CacheSize; i++) {\n-          _merge_log_buffer_cl->process_card(push(&_dummy_card));\n-        }\n-      }\n-    } _merge_log_buffer_cache;\n-\n@@ -1358,2 +1326,1 @@\n-      _cards_skipped(0),\n-      _merge_log_buffer_cache(this)\n+      _cards_skipped(0)\n@@ -1376,2 +1343,1 @@\n-        CardValue* to_process = _merge_log_buffer_cache.push(card_ptr);\n-        process_card(to_process);\n+        process_card(card_ptr);\n@@ -1445,4 +1411,3 @@\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged(i), i);\n+      }\n@@ -1454,2 +1419,6 @@\n-      G1MergeCardSetClosure cl(_scan_state);\n-      g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n+      G1MergeCardSetStats stats;\n+      {\n+        G1MergeCardSetClosure cl(_scan_state);\n+        g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n+        stats = cl.stats();\n+      }\n@@ -1457,4 +1426,3 @@\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, stats.merged(i), i);\n+      }\n@@ -1489,1 +1457,3 @@\n-  size_t num_visited_cards = _scan_state->num_visited_cards();\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n@@ -1491,1 +1461,1 @@\n-  size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+    size_t num_visited_cards = _scan_state->num_visited_cards();\n@@ -1493,10 +1463,13 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  size_t total_old_region_cards =\n-    (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n-\n-  log_debug(gc,remset)(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n-                       num_visited_cards,\n-                       total_dirty_region_cards,\n-                       percent_of(num_visited_cards, total_dirty_region_cards),\n-                       total_old_region_cards,\n-                       percent_of(num_visited_cards, total_old_region_cards));\n+    size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    size_t total_old_region_cards =\n+      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n+\n+    ls.print_cr(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n+                num_visited_cards,\n+                total_dirty_region_cards,\n+                percent_of(num_visited_cards, total_dirty_region_cards),\n+                total_old_region_cards,\n+                percent_of(num_visited_cards, total_old_region_cards));\n+  }\n@@ -1534,3 +1507,1 @@\n-  if (log_is_enabled(Debug, gc, remset)) {\n-    print_merge_heap_roots_stats();\n-  }\n+  print_merge_heap_roots_stats();\n@@ -1551,0 +1522,9 @@\n+void G1RemSet::print_coarsen_stats() {\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+\n+    G1CardSet::print_coarsen_stats(&ls);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":109,"deletions":129,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -110,0 +110,4 @@\n+  \/\/ Cleans the card table from temporary duplicate detection information.\n+  void cleanup_after_scan_heap_roots();\n+  \/\/ Print coarsening stats.\n+  void print_coarsen_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -34,1 +35,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -51,0 +52,1 @@\n+\n@@ -53,1 +55,1 @@\n-  _num_coarsenings = HeapRegionRemSet::n_coarsenings();\n+  _coarsenings = HeapRegionRemSet::coarsen_stats();\n@@ -71,1 +73,1 @@\n-  _num_coarsenings(0),\n+  _coarsenings(),\n@@ -91,1 +93,1 @@\n-  _num_coarsenings = other->num_coarsenings();\n+  _coarsenings = other->_coarsenings;\n@@ -102,1 +104,1 @@\n-  _num_coarsenings = other->num_coarsenings() - _num_coarsenings;\n+  _coarsenings.subtract_from(other->_coarsenings);\n@@ -115,0 +117,1 @@\n+  size_t _rs_wasted_mem_size;\n@@ -118,0 +121,1 @@\n+  size_t _amount_tracked;\n@@ -139,0 +143,1 @@\n+  size_t amount_tracked() const { return _amount_tracked; }\n@@ -142,2 +147,2 @@\n-  RegionTypeCounter(const char* name) : _name(name), _rs_mem_size(0), _cards_occupied(0),\n-    _amount(0), _code_root_mem_size(0), _code_root_elems(0) { }\n+  RegionTypeCounter(const char* name) : _name(name), _rs_wasted_mem_size(0), _rs_mem_size(0), _cards_occupied(0),\n+    _amount(0), _amount_tracked(0), _code_root_mem_size(0), _code_root_elems(0) { }\n@@ -145,2 +150,3 @@\n-  void add(size_t rs_mem_size, size_t cards_occupied, size_t code_root_mem_size,\n-    size_t code_root_elems) {\n+  void add(size_t rs_wasted_mem_size, size_t rs_mem_size, size_t cards_occupied,\n+           size_t code_root_mem_size, size_t code_root_elems, bool tracked) {\n+    _rs_wasted_mem_size += rs_wasted_mem_size;\n@@ -152,0 +158,1 @@\n+    _amount_tracked += tracked ? 1 : 0;\n@@ -154,0 +161,1 @@\n+  size_t rs_wasted_mem_size() const { return _rs_wasted_mem_size; }\n@@ -161,4 +169,5 @@\n-    out->print_cr(\"    \" SIZE_FORMAT_W(8) \"%s (%5.1f%%) by \" SIZE_FORMAT \" %s regions\",\n-        byte_size_in_proper_unit(rs_mem_size()),\n-        proper_unit_for_byte_size(rs_mem_size()),\n-        rs_mem_size_percent_of(total), amount(), _name);\n+    out->print_cr(\"    \" SIZE_FORMAT_W(8) \" (%5.1f%%) by \" SIZE_FORMAT \" \"\n+                  \"(\" SIZE_FORMAT \") %s regions wasted \" SIZE_FORMAT,\n+                  rs_mem_size(), rs_mem_size_percent_of(total),\n+                  amount_tracked(), amount(),\n+                  _name, rs_wasted_mem_size());\n@@ -168,2 +177,4 @@\n-    out->print_cr(\"     \" SIZE_FORMAT_W(8) \" (%5.1f%%) entries by \" SIZE_FORMAT \" %s regions\",\n-        cards_occupied(), cards_occupied_percent_of(total), amount(), _name);\n+    out->print_cr(\"     \" SIZE_FORMAT_W(8) \" (%5.1f%%) entries by \" SIZE_FORMAT \" \"\n+                  \"(\" SIZE_FORMAT \") %s regions\",\n+                  cards_occupied(), cards_occupied_percent_of(total),\n+                  amount_tracked(), amount(), _name);\n@@ -198,0 +209,1 @@\n+  size_t total_rs_wasted_mem_sz() const     { return _all.rs_wasted_mem_size(); }\n@@ -225,0 +237,1 @@\n+    size_t rs_wasted_mem_sz = hrrs->wasted_mem_size();\n@@ -252,2 +265,4 @@\n-    current->add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);\n-    _all.add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);\n+    current->add(rs_wasted_mem_sz, rs_mem_sz, occupied_cards,\n+                 code_root_mem_sz, code_root_elems, r->rem_set()->is_tracked());\n+    _all.add(rs_wasted_mem_sz, rs_mem_sz, occupied_cards,\n+             code_root_mem_sz, code_root_elems, r->rem_set()->is_tracked());\n@@ -262,6 +277,5 @@\n-    out->print_cr(\"  Total per region rem sets sizes = \" SIZE_FORMAT \"%s.\"\n-                  \" Max = \" SIZE_FORMAT \"%s.\",\n-                  byte_size_in_proper_unit(total_rs_mem_sz()),\n-                  proper_unit_for_byte_size(total_rs_mem_sz()),\n-                  byte_size_in_proper_unit(max_rs_mem_sz()),\n-                  proper_unit_for_byte_size(max_rs_mem_sz()));\n+    out->print_cr(\"  Total per region rem sets sizes = \" SIZE_FORMAT\n+                  \" Max = \" SIZE_FORMAT \" wasted = \" SIZE_FORMAT,\n+                  total_rs_mem_sz(),\n+                  max_rs_mem_sz(),\n+                  total_rs_wasted_mem_sz());\n@@ -272,7 +286,0 @@\n-    out->print_cr(\"   Static structures = \" SIZE_FORMAT \"%s,\"\n-                  \" free_lists = \" SIZE_FORMAT \"%s.\",\n-                  byte_size_in_proper_unit(HeapRegionRemSet::static_mem_size()),\n-                  proper_unit_for_byte_size(HeapRegionRemSet::static_mem_size()),\n-                  byte_size_in_proper_unit(HeapRegionRemSet::fl_mem_size()),\n-                  proper_unit_for_byte_size(HeapRegionRemSet::fl_mem_size()));\n-\n@@ -288,1 +295,1 @@\n-                  \"size = \" SIZE_FORMAT \"%s, occupied = \" SIZE_FORMAT \"%s.\",\n+                  \"size = \" SIZE_FORMAT \" occupied = \" SIZE_FORMAT,\n@@ -290,4 +297,6 @@\n-                  byte_size_in_proper_unit(rem_set->mem_size()),\n-                  proper_unit_for_byte_size(rem_set->mem_size()),\n-                  byte_size_in_proper_unit(rem_set->occupied()),\n-                  proper_unit_for_byte_size(rem_set->occupied()));\n+                  rem_set->mem_size(),\n+                  rem_set->occupied());\n+\n+    HeapRegionRemSet::print_static_mem_size(out);\n+    G1CardSetFreePool::free_list_pool()->print_on(out);\n+\n@@ -322,1 +331,2 @@\n-  out->print_cr(\"  Did \" SIZE_FORMAT \" coarsenings.\", num_coarsenings());\n+  out->print(\"Coarsening: \");\n+  _coarsenings.print_on(out);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n@@ -36,1 +37,1 @@\n-  size_t _num_coarsenings;\n+  G1CardSetCoarsenStats _coarsenings;\n@@ -68,4 +69,0 @@\n-\n-  size_t num_coarsenings() const {\n-    return _num_coarsenings;\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -44,0 +46,3 @@\n+  if (SampleCollectionSetCandidatesTask::should_execute()) {\n+    add_serial_task(new SampleCollectionSetCandidatesTask());\n+  }\n@@ -67,0 +72,26 @@\n+bool G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::should_execute() {\n+  return G1CollectedHeap::heap()->should_sample_collection_set_candidates();\n+}\n+\n+double G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::worker_cost() const {\n+  return should_execute() ? 1.0 : AlmostNoWork;\n+}\n+\n+class G1SampleCollectionSetCandidatesClosure : public HeapRegionClosure {\n+public:\n+  G1CardSetMemoryStats _total;\n+\n+  bool do_heap_region(HeapRegion* r) override {\n+    _total.add(r->rem_set()->card_set_memory_stats());\n+    return false;\n+  }\n+};\n+\n+void G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::do_work(uint worker_id) {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+  G1SampleCollectionSetCandidatesClosure cl;\n+  g1h->collection_set()->candidates()->iterate(&cl);\n+  g1h->set_collection_set_candidates_stats(cl._total);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+\/\/ - Sample Collection Set Candidates (s)\n@@ -46,0 +47,1 @@\n+  class SampleCollectionSetCandidatesTask;\n@@ -71,0 +73,10 @@\n+class G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask : public G1AbstractSubTask {\n+public:\n+  SampleCollectionSetCandidatesTask() : G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates) { }\n+\n+  static bool should_execute();\n+\n+  double worker_cost() const override;\n+  void do_work(uint worker_id) override;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,2 +133,2 @@\n-          \"Each time the rset update queue increases by this amount \"       \\\n-          \"activate the next refinement thread if available. \"              \\\n+          \"Each time the remembered set update queue increases by this \"    \\\n+          \"amount activate the next refinement thread if available. \"       \\\n@@ -141,1 +141,2 @@\n-          \"process RS update buffers during the collection pause.\")         \\\n+          \"processing remembered set update buffers during the collection \" \\\n+          \"pause.\")                                                         \\\n@@ -156,20 +157,34 @@\n-  develop(intx, G1RSetRegionEntriesBase, 256,                               \\\n-          \"Max number of regions in a fine-grain table per MB.\")            \\\n-          range(1, max_jint\/wordSize)                                       \\\n-                                                                            \\\n-  product(intx, G1RSetRegionEntries, 0,                                     \\\n-          \"Max number of regions for which we keep bitmaps.\"                \\\n-          \"Will be set ergonomically by default\")                           \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetRegionEntriesConstraintFunc,AfterErgo)           \\\n-                                                                            \\\n-  develop(intx, G1RSetSparseRegionEntriesBase, 4,                           \\\n-          \"Max number of entries per region in a sparse table \"             \\\n-          \"per MB.\")                                                        \\\n-          range(1, max_jint\/wordSize)                                       \\\n-                                                                            \\\n-  product(intx, G1RSetSparseRegionEntries, 0,                               \\\n-          \"Max number of entries per region in a sparse table.\"             \\\n-          \"Will be set ergonomically by default.\")                          \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetSparseRegionEntriesConstraintFunc,AfterErgo)     \\\n+  develop(uint, G1RemSetArrayOfCardsEntriesBase, 4,                         \\\n+          \"Maximum number of entries per region in the Array of Cards \"     \\\n+          \"card set container per MB of a heap region.\")                    \\\n+          range(1, 65536)                                                   \\\n+                                                                            \\\n+  product(uint, G1RemSetArrayOfCardsEntries, 0,  EXPERIMENTAL,              \\\n+          \"Maximum number of entries per Array of Cards card set \"          \\\n+          \"container. Will be set ergonomically by default.\")               \\\n+          range(0, 65536)                                                   \\\n+          constraint(G1RemSetArrayOfCardsEntriesConstraintFunc,AfterErgo)   \\\n+                                                                            \\\n+  product(uint, G1RemSetHowlMaxNumBuckets, 8, EXPERIMENTAL,                 \\\n+          \"Maximum number of buckets per Howl card set container. The \"     \\\n+          \"default gives at worst bitmaps of size 8k. This showed to be a \" \\\n+          \"good tradeoff between bitmap size (waste) and cacheability of \"  \\\n+          \"the bucket array. Must be a power of two.\")                      \\\n+          range(1, 1024)                                                    \\\n+          constraint(G1RemSetHowlMaxNumBucketsConstraintFunc,AfterErgo)     \\\n+                                                                            \\\n+  product(uint, G1RemSetHowlNumBuckets, 0, EXPERIMENTAL,                    \\\n+          \"Number of buckets per Howl card set container. Must be a power \" \\\n+          \"of two. Will be set ergonomically by default.\")                  \\\n+          range(0, 1024)                                                    \\\n+          constraint(G1RemSetHowlNumBucketsConstraintFunc,AfterErgo)        \\\n+                                                                            \\\n+  product(uint, G1RemSetCoarsenHowlBitmapToHowlFullPercent, 90, EXPERIMENTAL, \\\n+          \"Percentage at which to coarsen a Howl bitmap to Howl full card \" \\\n+          \"set container.\")                                                 \\\n+          range(1, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1RemSetCoarsenHowlToFullPercent, 90, EXPERIMENTAL,         \\\n+          \"Percentage at which to coarsen a Howl card set to Full card \"    \\\n+          \"set container.\")                                                 \\\n+          range(1, 100)                                                     \\\n@@ -193,1 +208,1 @@\n-          \"The number of parallel rem set update threads. \"                 \\\n+          \"The number of parallel remembered set update threads. \"          \\\n@@ -312,0 +327,16 @@\n+  product(uint, G1RemSetFreeMemoryRescheduleDelayMillis, 10, EXPERIMENTAL,  \\\n+          \"Time after which the card set free memory task reschedules \"     \\\n+          \"itself if there is work remaining.\")                             \\\n+          range(1, UINT_MAX)                                                \\\n+                                                                            \\\n+  product(double, G1RemSetFreeMemoryStepDurationMillis, 1, EXPERIMENTAL,    \\\n+          \"The amount of time that the free memory task should spend \"      \\\n+          \"before a pause of G1RemSetFreeMemoryRescheduleDelayMillis \"      \\\n+          \"length.\")                                                        \\\n+          range(1e-3, 1e+6)                                                 \\\n+                                                                            \\\n+  product(double, G1RemSetFreeMemoryKeepExcessRatio, 0.1, EXPERIMENTAL,     \\\n+          \"The percentage of free card set memory that G1 should keep as \"  \\\n+          \"percentage of the currently used memory.\")                       \\\n+          range(0.0, 1.0)                                                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":56,"deletions":25,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -229,1 +229,2 @@\n-                       MemRegion mr) :\n+                       MemRegion mr,\n+                       G1CardSetConfiguration* config) :\n@@ -255,1 +256,1 @@\n-  _rem_set = new HeapRegionRemSet(bot, this);\n+  _rem_set = new HeapRegionRemSet(this, config);\n@@ -613,0 +614,2 @@\n+          LogStream ls(log.error());\n+          to->rem_set()->print_info(&ls, p);\n@@ -617,1 +620,0 @@\n-          LogStream ls(log.error());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+class G1CardSetConfiguration;\n+class G1CardSetMemoryManager;\n@@ -284,1 +286,4 @@\n-  HeapRegion(uint hrm_index, G1BlockOffsetTable* bot, MemRegion mr);\n+  HeapRegion(uint hrm_index,\n+             G1BlockOffsetTable* bot,\n+             MemRegion mr,\n+             G1CardSetConfiguration* config);\n@@ -448,0 +453,1 @@\n+  void set_rem_set(HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include <cstdio>\n+\n@@ -31,1 +33,0 @@\n-#include \"gc\/g1\/sparsePRT.inline.hpp\"\n@@ -47,346 +48,8 @@\n-PerRegionTable* PerRegionTable::alloc(HeapRegion* hr) {\n-  PerRegionTable* fl = _free_list;\n-  while (fl != NULL) {\n-    PerRegionTable* nxt = fl->next();\n-    PerRegionTable* res = Atomic::cmpxchg(&_free_list, fl, nxt);\n-    if (res == fl) {\n-      fl->init(hr, true);\n-      return fl;\n-    } else {\n-      fl = _free_list;\n-    }\n-  }\n-  assert(fl == NULL, \"Loop condition.\");\n-  return new PerRegionTable(hr);\n-}\n-\n-PerRegionTable* volatile PerRegionTable::_free_list = NULL;\n-\n-size_t OtherRegionsTable::_max_fine_entries = 0;\n-size_t OtherRegionsTable::_mod_max_fine_entries_mask = 0;\n-size_t OtherRegionsTable::_fine_eviction_stride = 0;\n-size_t OtherRegionsTable::_fine_eviction_sample_size = 0;\n-\n-OtherRegionsTable::OtherRegionsTable(Mutex* m) :\n-  _g1h(G1CollectedHeap::heap()),\n-  _m(m),\n-  _num_occupied(0),\n-  _coarse_map(mtGC),\n-  _has_coarse_entries(false),\n-  _fine_grain_regions(NULL),\n-  _n_fine_entries(0),\n-  _first_all_fine_prts(NULL),\n-  _last_all_fine_prts(NULL),\n-  _fine_eviction_start(0),\n-  _sparse_table()\n-{\n-  typedef PerRegionTable* PerRegionTablePtr;\n-\n-  if (_max_fine_entries == 0) {\n-    assert(_mod_max_fine_entries_mask == 0, \"Both or none.\");\n-    size_t max_entries_log = (size_t)log2i(G1RSetRegionEntries);\n-    _max_fine_entries = (size_t)1 << max_entries_log;\n-    _mod_max_fine_entries_mask = _max_fine_entries - 1;\n-\n-    assert(_fine_eviction_sample_size == 0\n-           && _fine_eviction_stride == 0, \"All init at same time.\");\n-    _fine_eviction_sample_size = MAX2((size_t)4, max_entries_log);\n-    _fine_eviction_stride = _max_fine_entries \/ _fine_eviction_sample_size;\n-  }\n-\n-  _fine_grain_regions = NEW_C_HEAP_ARRAY(PerRegionTablePtr, _max_fine_entries, mtGC);\n-  for (size_t i = 0; i < _max_fine_entries; i++) {\n-    _fine_grain_regions[i] = NULL;\n-  }\n-}\n-\n-void OtherRegionsTable::link_to_all(PerRegionTable* prt) {\n-  \/\/ We always append to the beginning of the list for convenience;\n-  \/\/ the order of entries in this list does not matter.\n-  if (_first_all_fine_prts != NULL) {\n-    prt->set_next(_first_all_fine_prts);\n-  } else {\n-    \/\/ this is the first element we insert. Adjust the \"last\" pointer\n-    _last_all_fine_prts = prt;\n-    assert(prt->next() == NULL, \"just checking\");\n-  }\n-  _first_all_fine_prts = prt;\n-\n-  assert(_first_all_fine_prts == prt, \"just checking\");\n-  assert((_first_all_fine_prts == NULL && _last_all_fine_prts == NULL) ||\n-         (_first_all_fine_prts != NULL && _last_all_fine_prts != NULL),\n-         \"just checking\");\n-  assert(_last_all_fine_prts == NULL || _last_all_fine_prts->next() == NULL,\n-         \"just checking\");\n-}\n-\n-CardIdx_t OtherRegionsTable::card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr) {\n-  assert(hr->is_in_reserved(within_region),\n-         \"HeapWord \" PTR_FORMAT \" is outside of region %u [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-         p2i(within_region), hr->hrm_index(), p2i(hr->bottom()), p2i(hr->end()));\n-  CardIdx_t result = (CardIdx_t)(pointer_delta((HeapWord*)within_region, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n-  return result;\n-}\n-\n-void OtherRegionsTable::add_reference(OopOrNarrowOopStar from, uint tid) {\n-  \/\/ Note that this may be a continued H region.\n-  HeapRegion* from_hr = _g1h->heap_region_containing(from);\n-  RegionIdx_t from_hrm_ind = (RegionIdx_t) from_hr->hrm_index();\n-\n-  \/\/ If the region is already coarsened, return.\n-  if (is_region_coarsened(from_hrm_ind)) {\n-    assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the Coarse table\", p2i(from));\n-    return;\n-  }\n-\n-  size_t num_added_by_coarsening = 0;\n-  \/\/ Otherwise find a per-region table to add it to.\n-  size_t ind = from_hrm_ind & _mod_max_fine_entries_mask;\n-  PerRegionTable* prt = find_region_table(ind, from_hr);\n-  if (prt == NULL) {\n-    MutexLocker x(_m, Mutex::_no_safepoint_check_flag);\n-\n-    \/\/ Rechecking if the region is coarsened, while holding the lock.\n-    if (is_region_coarsened(from_hrm_ind)) {\n-      assert(contains_reference_locked(from), \"We just found \" PTR_FORMAT \" in the Coarse table\", p2i(from));\n-      return;\n-    }\n-\n-    \/\/ Confirm that it's really not there...\n-    prt = find_region_table(ind, from_hr);\n-    if (prt == NULL) {\n-\n-      CardIdx_t card_index = card_within_region(from, from_hr);\n-\n-      SparsePRT::AddCardResult result = _sparse_table.add_card(from_hrm_ind, card_index);\n-      if (result != SparsePRT::overflow) {\n-        if (result == SparsePRT::added) {\n-          Atomic::inc(&_num_occupied, memory_order_relaxed);\n-        }\n-        assert(contains_reference_locked(from), \"We just added \" PTR_FORMAT \" to the Sparse table\", p2i(from));\n-        return;\n-      }\n-\n-      \/\/ Sparse PRT returned overflow (sparse table is full)\n-\n-      if (_n_fine_entries == _max_fine_entries) {\n-        prt = delete_region_table(num_added_by_coarsening);\n-        \/\/ There is no need to clear the links to the 'all' list here:\n-        \/\/ prt will be reused immediately, i.e. remain in the 'all' list.\n-        prt->init(from_hr, false \/* clear_links_to_all_list *\/);\n-      } else {\n-        prt = PerRegionTable::alloc(from_hr);\n-        link_to_all(prt);\n-      }\n-\n-      PerRegionTable* first_prt = _fine_grain_regions[ind];\n-      prt->set_collision_list_next(first_prt);\n-      \/\/ The assignment into _fine_grain_regions allows the prt to\n-      \/\/ start being used concurrently. In addition to\n-      \/\/ collision_list_next which must be visible (else concurrent\n-      \/\/ parsing of the list, if any, may fail to see other entries),\n-      \/\/ the content of the prt must be visible (else for instance\n-      \/\/ some mark bits may not yet seem cleared or a 'later' update\n-      \/\/ performed by a concurrent thread could be undone when the\n-      \/\/ zeroing becomes visible). This requires store ordering.\n-      Atomic::release_store(&_fine_grain_regions[ind], prt);\n-      _n_fine_entries++;\n-\n-      \/\/ Transfer from sparse to fine-grain. The cards from the sparse table\n-      \/\/ were already added to the total in _num_occupied.\n-      SparsePRTEntry *sprt_entry = _sparse_table.get_entry(from_hrm_ind);\n-      assert(sprt_entry != NULL, \"There should have been an entry\");\n-      for (int i = 0; i < sprt_entry->num_valid_cards(); i++) {\n-        CardIdx_t c = sprt_entry->card(i);\n-        prt->add_card(c);\n-      }\n-      \/\/ Now we can delete the sparse entry.\n-      bool res = _sparse_table.delete_entry(from_hrm_ind);\n-      assert(res, \"It should have been there.\");\n-    }\n-    assert(prt != NULL && prt->hr() == from_hr, \"consequence\");\n-  }\n-  \/\/ Note that we can't assert \"prt->hr() == from_hr\", because of the\n-  \/\/ possibility of concurrent reuse.  But see head comment of\n-  \/\/ OtherRegionsTable for why this is OK.\n-  assert(prt != NULL, \"Inv\");\n-\n-  if (prt->add_reference(from)) {\n-    num_added_by_coarsening++;\n-  }\n-  Atomic::add(&_num_occupied, num_added_by_coarsening, memory_order_relaxed);\n-  assert(contains_reference(from), \"We just added \" PTR_FORMAT \" to the PRT (%d)\", p2i(from), prt->contains_reference(from));\n-}\n-\n-PerRegionTable*\n-OtherRegionsTable::find_region_table(size_t ind, HeapRegion* hr) const {\n-  assert(ind < _max_fine_entries, \"Preconditions.\");\n-  PerRegionTable* prt = _fine_grain_regions[ind];\n-  while (prt != NULL && prt->hr() != hr) {\n-    prt = prt->collision_list_next();\n-  }\n-  \/\/ Loop postcondition is the method postcondition.\n-  return prt;\n-}\n-\n-jint OtherRegionsTable::_n_coarsenings = 0;\n-\n-PerRegionTable* OtherRegionsTable::delete_region_table(size_t& added_by_deleted) {\n-  assert(_m->owned_by_self(), \"Precondition\");\n-  assert(_n_fine_entries == _max_fine_entries, \"Precondition\");\n-  PerRegionTable* max = NULL;\n-  jint max_occ = 0;\n-  PerRegionTable** max_prev = NULL;\n-\n-  size_t i = _fine_eviction_start;\n-  for (size_t k = 0; k < _fine_eviction_sample_size; k++) {\n-    size_t ii = i;\n-    \/\/ Make sure we get a non-NULL sample.\n-    while (_fine_grain_regions[ii] == NULL) {\n-      ii++;\n-      if (ii == _max_fine_entries) ii = 0;\n-      guarantee(ii != i, \"We must find one.\");\n-    }\n-    PerRegionTable** prev = &_fine_grain_regions[ii];\n-    PerRegionTable* cur = *prev;\n-    while (cur != NULL) {\n-      jint cur_occ = cur->occupied();\n-      if (max == NULL || cur_occ > max_occ) {\n-        max = cur;\n-        max_prev = prev;\n-        max_occ = cur_occ;\n-      }\n-      prev = cur->collision_list_next_addr();\n-      cur = cur->collision_list_next();\n-    }\n-    i = i + _fine_eviction_stride;\n-    if (i >= _n_fine_entries) i = i - _n_fine_entries;\n-  }\n-\n-  _fine_eviction_start++;\n-\n-  if (_fine_eviction_start >= _n_fine_entries) {\n-    _fine_eviction_start -= _n_fine_entries;\n-  }\n-\n-  guarantee(max != NULL, \"Since _n_fine_entries > 0\");\n-  guarantee(max_prev != NULL, \"Since max != NULL.\");\n-\n-  \/\/ Ensure the corresponding coarse bit is set.\n-  size_t max_hrm_index = (size_t) max->hr()->hrm_index();\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    _coarse_map.at_put(max_hrm_index, true);\n-  } else {\n-    \/\/ This will lazily initialize an uninitialized bitmap\n-    _coarse_map.reinitialize(G1CollectedHeap::heap()->max_reserved_regions());\n-    assert(!_coarse_map.at(max_hrm_index), \"No coarse entries\");\n-    _coarse_map.at_put(max_hrm_index, true);\n-    \/\/ Release store guarantees that the bitmap has initialized before any\n-    \/\/ concurrent reader will ever see _has_coarse_entries is true\n-    \/\/ (when read with load_acquire)\n-    Atomic::release_store(&_has_coarse_entries, true);\n-  }\n-\n-  added_by_deleted = HeapRegion::CardsPerRegion - max_occ;\n-  \/\/ Unsplice.\n-  *max_prev = max->collision_list_next();\n-  Atomic::inc(&_n_coarsenings);\n-  _n_fine_entries--;\n-  return max;\n-}\n-\n-bool OtherRegionsTable::occupancy_less_or_equal_than(size_t limit) const {\n-  return occupied() <= limit;\n-}\n-\n-bool OtherRegionsTable::is_empty() const {\n-  return occupied() == 0;\n-}\n-\n-size_t OtherRegionsTable::occupied() const {\n-  return _num_occupied;\n-}\n-\n-size_t OtherRegionsTable::mem_size() const {\n-  size_t sum = 0;\n-  \/\/ all PRTs are of the same size so it is sufficient to query only one of them.\n-  if (_first_all_fine_prts != NULL) {\n-    assert(_last_all_fine_prts != NULL &&\n-      _first_all_fine_prts->mem_size() == _last_all_fine_prts->mem_size(), \"check that mem_size() is constant\");\n-    sum += _first_all_fine_prts->mem_size() * _n_fine_entries;\n-  }\n-  sum += (sizeof(PerRegionTable*) * _max_fine_entries);\n-  sum += (_coarse_map.size_in_words() * HeapWordSize);\n-  sum += (_sparse_table.mem_size());\n-  sum += sizeof(OtherRegionsTable) - sizeof(_sparse_table); \/\/ Avoid double counting above.\n-  return sum;\n-}\n-\n-size_t OtherRegionsTable::static_mem_size() {\n-  return G1FromCardCache::static_mem_size();\n-}\n-\n-size_t OtherRegionsTable::fl_mem_size() {\n-  return PerRegionTable::fl_mem_size();\n-}\n-\n-void OtherRegionsTable::clear() {\n-  \/\/ if there are no entries, skip this step\n-  if (_first_all_fine_prts != NULL) {\n-    guarantee(_first_all_fine_prts != NULL && _last_all_fine_prts != NULL, \"just checking\");\n-    PerRegionTable::bulk_free(_first_all_fine_prts, _last_all_fine_prts);\n-    memset(_fine_grain_regions, 0, _max_fine_entries * sizeof(_fine_grain_regions[0]));\n-  } else {\n-    guarantee(_first_all_fine_prts == NULL && _last_all_fine_prts == NULL, \"just checking\");\n-  }\n-\n-  _first_all_fine_prts = _last_all_fine_prts = NULL;\n-  _sparse_table.clear();\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    _coarse_map.clear();\n-  }\n-  _n_fine_entries = 0;\n-  Atomic::store(&_has_coarse_entries, false);\n-\n-  _num_occupied = 0;\n-}\n-\n-bool OtherRegionsTable::contains_reference(OopOrNarrowOopStar from) const {\n-  \/\/ Cast away const in this case.\n-  MutexLocker x((Mutex*)_m, Mutex::_no_safepoint_check_flag);\n-  return contains_reference_locked(from);\n-}\n-\n-bool OtherRegionsTable::contains_reference_locked(OopOrNarrowOopStar from) const {\n-  HeapRegion* hr = _g1h->heap_region_containing(from);\n-  RegionIdx_t hr_ind = (RegionIdx_t) hr->hrm_index();\n-  \/\/ Is this region in the coarse map?\n-  if (is_region_coarsened(hr_ind)) return true;\n-\n-  PerRegionTable* prt = find_region_table(hr_ind & _mod_max_fine_entries_mask,\n-                                          hr);\n-  if (prt != NULL) {\n-    return prt->contains_reference(from);\n-  } else {\n-    CardIdx_t card_index = card_within_region(from, hr);\n-    return _sparse_table.contains_card(hr_ind, card_index);\n-  }\n-}\n-\n-\/\/ A load_acquire on _has_coarse_entries - coupled with the release_store in\n-\/\/ delete_region_table - guarantees we don't access _coarse_map before\n-\/\/ it's been properly initialized.\n-bool OtherRegionsTable::is_region_coarsened(RegionIdx_t from_hrm_ind) const {\n-  return Atomic::load_acquire(&_has_coarse_entries) && _coarse_map.at(from_hrm_ind);\n-}\n-\n-HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetTable* bot,\n-                                   HeapRegion* hr)\n-  : _bot(bot),\n-    _code_roots(),\n-    _m(Mutex::leaf, FormatBuffer<128>(\"HeapRegionRemSet lock #%u\", hr->hrm_index()), true, Mutex::_safepoint_check_never),\n-    _other_regions(&_m),\n-    _hr(hr),\n-    _state(Untracked)\n-{\n-}\n+HeapRegionRemSet::HeapRegionRemSet(HeapRegion* hr,\n+                                   G1CardSetConfiguration* config) :\n+  _m(Mutex::leaf + 1, FormatBuffer<128>(\"HeapRegionRemSet lock #%u\", hr->hrm_index()), true, Monitor::_safepoint_check_never),\n+  _code_roots(),\n+  _card_set_mm(config, G1CardSetFreePool::free_list_pool()),\n+  _card_set(config, &_card_set_mm),\n+  _hr(hr),\n+  _state(Untracked) { }\n@@ -398,14 +61,0 @@\n-void HeapRegionRemSet::setup_remset_size() {\n-  const int LOG_M = 20;\n-  guarantee(HeapRegion::LogOfHRGrainBytes >= LOG_M, \"Code assumes the region size >= 1M, but is \" SIZE_FORMAT \"B\", HeapRegion::GrainBytes);\n-\n-  int region_size_log_mb = HeapRegion::LogOfHRGrainBytes - LOG_M;\n-  if (FLAG_IS_DEFAULT(G1RSetSparseRegionEntries)) {\n-    G1RSetSparseRegionEntries = G1RSetSparseRegionEntriesBase * ((size_t)1 << (region_size_log_mb + 1));\n-  }\n-  if (FLAG_IS_DEFAULT(G1RSetRegionEntries)) {\n-    G1RSetRegionEntries = G1RSetRegionEntriesBase * (region_size_log_mb + 1);\n-  }\n-  guarantee(G1RSetSparseRegionEntries > 0 && G1RSetRegionEntries > 0 , \"Sanity\");\n-}\n-\n@@ -422,1 +71,1 @@\n-  _other_regions.clear();\n+  _card_set.clear();\n@@ -427,0 +76,4 @@\n+void HeapRegionRemSet::print_static_mem_size(outputStream* out) {\n+  out->print_cr(\"  Static structures = \" SIZE_FORMAT, HeapRegionRemSet::static_mem_size());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":15,"deletions":362,"binary":false,"changes":377,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -34,240 +36,1 @@\n-\/\/ Remembered set for a heap region.  Represent a set of \"cards\" that\n-\/\/ contain pointers into the owner heap region.  Cards are defined somewhat\n-\/\/ abstractly, in terms of what the \"BlockOffsetTable\" in use can parse.\n-\n-class G1CollectedHeap;\n-class G1BlockOffsetTable;\n-class G1CardLiveData;\n-class HeapRegion;\n-class PerRegionTable;\n-class SparsePRT;\n-class nmethod;\n-\n-\/\/ The \"_coarse_map\" is a bitmap with one bit for each region, where set\n-\/\/ bits indicate that the corresponding region may contain some pointer\n-\/\/ into the owning region.\n-\n-\/\/ The \"_fine_grain_entries\" array is an open hash table of PerRegionTables\n-\/\/ (PRTs), indicating regions for which we're keeping the RS as a set of\n-\/\/ cards.  The strategy is to cap the size of the fine-grain table,\n-\/\/ deleting an entry and setting the corresponding coarse-grained bit when\n-\/\/ we would overflow this cap.\n-\n-\/\/ We use a mixture of locking and lock-free techniques here.  We allow\n-\/\/ threads to locate PRTs without locking, but threads attempting to alter\n-\/\/ a bucket list obtain a lock.  This means that any failing attempt to\n-\/\/ find a PRT must be retried with the lock.  It might seem dangerous that\n-\/\/ a read can find a PRT that is concurrently deleted.  This is all right,\n-\/\/ because:\n-\/\/\n-\/\/   1) We only actually free PRT's at safe points (though we reuse them at\n-\/\/      other times).\n-\/\/   2) We find PRT's in an attempt to add entries.  If a PRT is deleted,\n-\/\/      it's _coarse_map bit is set, so the that we were attempting to add\n-\/\/      is represented.  If a deleted PRT is re-used, a thread adding a bit,\n-\/\/      thinking the PRT is for a different region, does no harm.\n-\n-class OtherRegionsTable {\n-  G1CollectedHeap* _g1h;\n-  Mutex*           _m;\n-\n-  size_t volatile _num_occupied;\n-\n-  \/\/ These are protected by \"_m\".\n-  CHeapBitMap   _coarse_map;\n-  bool volatile _has_coarse_entries;\n-  static jint   _n_coarsenings;\n-\n-  PerRegionTable** _fine_grain_regions;\n-  size_t           _n_fine_entries;\n-\n-  \/\/ The fine grain remembered sets are linked together using\n-  \/\/ their 'next' fields.\n-  \/\/ This allows fast bulk freeing of all the fine grain remembered\n-  \/\/ set entries, and fast finding of all of them without iterating\n-  \/\/ over the _fine_grain_regions table.\n-  PerRegionTable * _first_all_fine_prts;\n-  PerRegionTable * _last_all_fine_prts;\n-\n-  \/\/ Used to sample a subset of the fine grain PRTs to determine which\n-  \/\/ PRT to evict and coarsen.\n-  size_t        _fine_eviction_start;\n-  static size_t _fine_eviction_stride;\n-  static size_t _fine_eviction_sample_size;\n-\n-  SparsePRT   _sparse_table;\n-\n-  \/\/ These are static after init.\n-  static size_t _max_fine_entries;\n-  static size_t _mod_max_fine_entries_mask;\n-\n-  \/\/ Requires \"prt\" to be the first element of the bucket list appropriate\n-  \/\/ for \"hr\".  If this list contains an entry for \"hr\", return it,\n-  \/\/ otherwise return \"NULL\".\n-  PerRegionTable* find_region_table(size_t ind, HeapRegion* hr) const;\n-\n-  \/\/ Find, delete, and return a candidate PerRegionTable, if any exists,\n-  \/\/ adding the deleted region to the coarse bitmap.  Requires the caller\n-  \/\/ to hold _m, and the fine-grain table to be full.\n-  PerRegionTable* delete_region_table(size_t& added_by_deleted);\n-\n-  \/\/ link\/add the given fine grain remembered set into the \"all\" list\n-  void link_to_all(PerRegionTable * prt);\n-\n-  bool contains_reference_locked(OopOrNarrowOopStar from) const;\n-\n-public:\n-  \/\/ Create a new remembered set. The given mutex is used to ensure consistency.\n-  OtherRegionsTable(Mutex* m);\n-\n-  template <class Closure>\n-  void iterate(Closure& v);\n-\n-  \/\/ Returns the card index of the given within_region pointer relative to the bottom\n-  \/\/ of the given heap region.\n-  static CardIdx_t card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr);\n-  \/\/ Adds the reference from \"from to this remembered set.\n-  void add_reference(OopOrNarrowOopStar from, uint tid);\n-\n-  \/\/ Returns whether the remembered set contains the given reference.\n-  bool contains_reference(OopOrNarrowOopStar from) const;\n-\n-  \/\/ Returns whether this remembered set (and all sub-sets) have an occupancy\n-  \/\/ that is less or equal than the given occupancy.\n-  bool occupancy_less_or_equal_than(size_t limit) const;\n-\n-  \/\/ Returns whether this remembered set (and all sub-sets) does not contain any entry.\n-  bool is_empty() const;\n-\n-  \/\/ Returns the number of cards contained in this remembered set.\n-  size_t occupied() const;\n-\n-  static jint n_coarsenings() { return _n_coarsenings; }\n-\n-  \/\/ Returns size of the actual remembered set containers in bytes.\n-  size_t mem_size() const;\n-  \/\/ Returns the size of static data in bytes.\n-  static size_t static_mem_size();\n-  \/\/ Returns the size of the free list content in bytes.\n-  static size_t fl_mem_size();\n-\n-  \/\/ Clear the entire contents of this remembered set.\n-  void clear();\n-\n-  \/\/ Safe for use by concurrent readers outside _m\n-  bool is_region_coarsened(RegionIdx_t from_hrm_ind) const;\n-};\n-\n-class PerRegionTable: public CHeapObj<mtGC> {\n-  friend class OtherRegionsTable;\n-\n-  HeapRegion*     _hr;\n-  CHeapBitMap     _bm;\n-  jint            _occupied;\n-\n-  \/\/ next pointer for free\/allocated 'all' list\n-  PerRegionTable* _next;\n-\n-  \/\/ next pointer in collision list\n-  PerRegionTable * _collision_list_next;\n-\n-  \/\/ Global free list of PRTs\n-  static PerRegionTable* volatile _free_list;\n-\n-protected:\n-  PerRegionTable(HeapRegion* hr) :\n-    _hr(hr),\n-    _bm(HeapRegion::CardsPerRegion, mtGC),\n-    _occupied(0),\n-    _next(NULL),\n-    _collision_list_next(NULL)\n-  {}\n-\n-public:\n-  \/\/ We need access in order to union things into the base table.\n-  BitMap* bm() { return &_bm; }\n-\n-  HeapRegion* hr() const { return Atomic::load_acquire(&_hr); }\n-\n-  jint occupied() const {\n-    return _occupied;\n-  }\n-\n-  void init(HeapRegion* hr, bool clear_links_to_all_list);\n-\n-  inline bool add_reference(OopOrNarrowOopStar from);\n-\n-  inline bool add_card(CardIdx_t from_card_index);\n-\n-  \/\/ (Destructively) union the bitmap of the current table into the given\n-  \/\/ bitmap (which is assumed to be of the same size.)\n-  void union_bitmap_into(BitMap* bm) {\n-    bm->set_union(_bm);\n-  }\n-\n-  \/\/ Mem size in bytes.\n-  size_t mem_size() const {\n-    return sizeof(PerRegionTable) + _bm.size_in_words() * HeapWordSize;\n-  }\n-\n-  \/\/ Requires \"from\" to be in \"hr()\".\n-  bool contains_reference(OopOrNarrowOopStar from) const {\n-    assert(hr()->is_in_reserved(from), \"Precondition.\");\n-    size_t card_ind = pointer_delta(from, hr()->bottom(),\n-                                    G1CardTable::card_size);\n-    return _bm.at(card_ind);\n-  }\n-\n-  \/\/ Bulk-free the PRTs from prt to last, assumes that they are\n-  \/\/ linked together using their _next field.\n-  static void bulk_free(PerRegionTable* prt, PerRegionTable* last) {\n-    while (true) {\n-      PerRegionTable* fl = _free_list;\n-      last->set_next(fl);\n-      PerRegionTable* res = Atomic::cmpxchg(&_free_list, fl, prt);\n-      if (res == fl) {\n-        return;\n-      }\n-    }\n-    ShouldNotReachHere();\n-  }\n-\n-  static void free(PerRegionTable* prt) {\n-    bulk_free(prt, prt);\n-  }\n-\n-  \/\/ Returns an initialized PerRegionTable instance.\n-  static PerRegionTable* alloc(HeapRegion* hr);\n-\n-  PerRegionTable* next() const { return _next; }\n-  void set_next(PerRegionTable* next) { _next = next; }\n-\n-  \/\/ Accessor and Modification routines for the pointer for the\n-  \/\/ singly linked collision list that links the PRTs within the\n-  \/\/ OtherRegionsTable::_fine_grain_regions hash table.\n-  \/\/\n-\n-  PerRegionTable* collision_list_next() const {\n-    return _collision_list_next;\n-  }\n-\n-  void set_collision_list_next(PerRegionTable* next) {\n-    _collision_list_next = next;\n-  }\n-\n-  PerRegionTable** collision_list_next_addr() {\n-    return &_collision_list_next;\n-  }\n-\n-  static size_t fl_mem_size() {\n-    PerRegionTable* cur = _free_list;\n-    size_t res = 0;\n-    while (cur != NULL) {\n-      res += cur->mem_size();\n-      cur = cur->next();\n-    }\n-    return res;\n-  }\n-\n-  static void test_fl_mem_size();\n-};\n+class outputStream;\n@@ -278,3 +41,1 @@\n-private:\n-  G1BlockOffsetTable* _bot;\n-\n+  Mutex _m;\n@@ -285,1 +46,1 @@\n-  Mutex _m;\n+  G1CardSetMemoryManager _card_set_mm;\n@@ -287,1 +48,2 @@\n-  OtherRegionsTable _other_regions;\n+  \/\/ The set of cards in the Java heap\n+  G1CardSet _card_set;\n@@ -291,0 +53,1 @@\n+  inline void split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const;\n@@ -294,1 +57,1 @@\n-  HeapRegionRemSet(G1BlockOffsetTable* bot, HeapRegion* hr);\n+  HeapRegionRemSet(HeapRegion* hr, G1CardSetConfiguration* config);\n@@ -297,1 +60,3 @@\n-  static void setup_remset_size();\n+  bool cardset_is_empty() const {\n+    return _card_set.is_empty();\n+  }\n@@ -300,1 +65,1 @@\n-    return (strong_code_roots_list_length() == 0) && _other_regions.is_empty();\n+    return (strong_code_roots_list_length() == 0) && cardset_is_empty();\n@@ -304,1 +69,1 @@\n-    return (strong_code_roots_list_length() == 0) && _other_regions.occupancy_less_or_equal_than(occ);\n+    return (strong_code_roots_list_length() == 0) && _card_set.occupancy_less_or_equal_to(occ);\n@@ -307,8 +72,5 @@\n-  \/\/ For each PRT in the card (remembered) set call one of the following methods\n-  \/\/ of the given closure:\n-  \/\/\n-  \/\/ set_full_region_dirty(uint region_idx) - pass the region index for coarse PRTs\n-  \/\/ set_bitmap_dirty(uint region_idx, BitMap* bitmap) - pass the region index and bitmap for fine PRTs\n-  \/\/ set_cards_dirty(uint region_idx, elem_t* cards, uint num_cards) - pass region index and cards for sparse PRTs\n-  template <class Closure>\n-  inline void iterate_prts(Closure& cl);\n+  \/\/ Iterate the card based remembered set for merging them into the card table.\n+  \/\/ The passed closure must be a CardOrRangeVisitor; we use a template parameter\n+  \/\/ to pass it in to facilitate inlining as much as possible.\n+  template <class CardOrRangeVisitor>\n+  inline void iterate_for_merge(CardOrRangeVisitor& cl);\n@@ -317,1 +79,1 @@\n-    return _other_regions.occupied();\n+    return _card_set.occupied();\n@@ -320,1 +82,2 @@\n-  static jint n_coarsenings() { return OtherRegionsTable::n_coarsenings(); }\n+  \/\/ Coarsening statistics since VM start.\n+  static G1CardSetCoarsenStats coarsen_stats() { return G1CardSet::coarsen_stats(); }\n@@ -342,8 +105,3 @@\n-  void set_state_empty() {\n-    guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(), \"Should only set to Untracked during safepoint but is %s.\", get_state_str());\n-    if (_state == Untracked) {\n-      return;\n-    }\n-    clear_fcc();\n-    _state = Untracked;\n-  }\n+  inline void set_state_empty();\n+  inline void set_state_updating();\n+  inline void set_state_complete();\n@@ -351,27 +109,1 @@\n-  void set_state_updating() {\n-    guarantee(SafepointSynchronize::is_at_safepoint() && !is_tracked(), \"Should only set to Updating from Untracked during safepoint but is %s\", get_state_str());\n-    clear_fcc();\n-    _state = Updating;\n-  }\n-\n-  void set_state_complete() {\n-    clear_fcc();\n-    _state = Complete;\n-  }\n-\n-  void add_reference(OopOrNarrowOopStar from, uint tid) {\n-    RemSetState state = _state;\n-    if (state == Untracked) {\n-      return;\n-    }\n-\n-    uint cur_idx = _hr->hrm_index();\n-    uintptr_t from_card = uintptr_t(from) >> CardTable::card_shift;\n-\n-    if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {\n-      assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the FromCardCache\", p2i(from));\n-      return;\n-    }\n-\n-    _other_regions.add_reference(from, tid);\n-  }\n+  inline void add_reference(OopOrNarrowOopStar from, uint tid);\n@@ -384,2 +116,4 @@\n-  \/\/ The actual # of bytes this hr_remset takes up.\n-  \/\/ Note also includes the strong code root set.\n+  G1CardSetMemoryStats card_set_memory_stats() const { return _card_set_mm.memory_stats(); }\n+\n+  \/\/ The actual # of bytes this hr_remset takes up. Also includes the strong code\n+  \/\/ root set.\n@@ -387,5 +121,2 @@\n-    MutexLocker x(&_m, Mutex::_no_safepoint_check_flag);\n-    return _other_regions.mem_size()\n-      \/\/ This correction is necessary because the above includes the second\n-      \/\/ part.\n-      + (sizeof(HeapRegionRemSet) - sizeof(OtherRegionsTable))\n+    return _card_set.mem_size()\n+      + (sizeof(HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n@@ -395,0 +126,4 @@\n+  size_t wasted_mem_size() {\n+    return _card_set.wasted_mem_size();\n+  }\n+\n@@ -398,1 +133,1 @@\n-    return OtherRegionsTable::static_mem_size() + G1CodeRootSet::static_mem_size();\n+    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1CardSetFreePool);\n@@ -401,5 +136,1 @@\n-  \/\/ Returns the memory occupancy of all free_list data structures associated\n-  \/\/ with remembered sets.\n-  static size_t fl_mem_size() {\n-    return OtherRegionsTable::fl_mem_size();\n-  }\n+  static void print_static_mem_size(outputStream* out);\n@@ -407,3 +138,3 @@\n-  bool contains_reference(OopOrNarrowOopStar from) const {\n-    return _other_regions.contains_reference(from);\n-  }\n+  inline bool contains_reference(OopOrNarrowOopStar from);\n+\n+  inline void print_info(outputStream* st, OopOrNarrowOopStar from);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":43,"deletions":312,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -31,1 +33,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -35,3 +36,8 @@\n-template <class Closure>\n-inline void HeapRegionRemSet::iterate_prts(Closure& cl) {\n-  _other_regions.iterate(cl);\n+void HeapRegionRemSet::set_state_empty() {\n+  guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(),\n+            \"Should only set to Untracked during safepoint but is %s.\", get_state_str());\n+  if (_state == Untracked) {\n+    return;\n+  }\n+  clear_fcc();\n+  _state = Untracked;\n@@ -40,6 +46,5 @@\n-inline bool PerRegionTable::add_card(CardIdx_t from_card_index) {\n-  if (_bm.par_set_bit(from_card_index)) {\n-    Atomic::inc(&_occupied, memory_order_relaxed);\n-    return true;\n-  }\n-  return false;\n+void HeapRegionRemSet::set_state_updating() {\n+  guarantee(SafepointSynchronize::is_at_safepoint() && !is_tracked(),\n+            \"Should only set to Updating from Untracked during safepoint but is %s\", get_state_str());\n+  clear_fcc();\n+  _state = Updating;\n@@ -48,13 +53,3 @@\n-inline bool PerRegionTable::add_reference(OopOrNarrowOopStar from) {\n-  \/\/ Must make this robust in case \"from\" is not in \"_hr\", because of\n-  \/\/ concurrency.\n-\n-  HeapRegion* loc_hr = hr();\n-  \/\/ If the test below fails, then this table was reused concurrently\n-  \/\/ with this operation.  This is OK, since the old table was coarsened,\n-  \/\/ and adding a bit to the new table is never incorrect.\n-  if (loc_hr->is_in_reserved(from)) {\n-    CardIdx_t from_card = OtherRegionsTable::card_within_region(from, loc_hr);\n-    return add_card(from_card);\n-  }\n-  return false;\n+void HeapRegionRemSet::set_state_complete() {\n+  clear_fcc();\n+  _state = Complete;\n@@ -63,10 +58,4 @@\n-inline void PerRegionTable::init(HeapRegion* hr, bool clear_links_to_all_list) {\n-  if (clear_links_to_all_list) {\n-    set_next(NULL);\n-  }\n-  _collision_list_next = NULL;\n-  _occupied = 0;\n-  _bm.clear();\n-  \/\/ Make sure that the bitmap clearing above has been finished before publishing\n-  \/\/ this PRT to concurrent threads.\n-  Atomic::release_store(&_hr, hr);\n+\n+template <class CardOrRangeVisitor>\n+inline void HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  _card_set.iterate_for_merge(cl);\n@@ -75,15 +64,10 @@\n-template <class Closure>\n-void OtherRegionsTable::iterate(Closure& cl) {\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    BitMap::idx_t cur = _coarse_map.get_next_one_offset(0);\n-    while (cur != _coarse_map.size()) {\n-      cl.next_coarse_prt((uint)cur);\n-      cur = _coarse_map.get_next_one_offset(cur + 1);\n-    }\n-  }\n-  {\n-    PerRegionTable* cur = _first_all_fine_prts;\n-    while (cur != NULL) {\n-      cl.next_fine_prt(cur->hr()->hrm_index(), cur->bm());\n-      cur = cur->next();\n-    }\n+void HeapRegionRemSet::split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const {\n+  HeapRegion* hr = G1CollectedHeap::heap()->heap_region_containing(from);\n+  card_region = hr->hrm_index();\n+  card_within_region = (uint)(pointer_delta((HeapWord*)from, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n+}\n+\n+void HeapRegionRemSet::add_reference(OopOrNarrowOopStar from, uint tid) {\n+  RemSetState state = _state;\n+  if (state == Untracked) {\n+    return;\n@@ -91,6 +75,9 @@\n-  {\n-    SparsePRTBucketIter iter(&_sparse_table);\n-    SparsePRTEntry* cur;\n-    while (iter.has_next(cur)) {\n-      cl.next_sparse_prt(cur->r_ind(), cur->cards(), cur->num_valid_cards());\n-    }\n+\n+  uint cur_idx = _hr->hrm_index();\n+  uintptr_t from_card = uintptr_t(from) >> CardTable::card_shift;\n+\n+  if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {\n+    \/\/ We can't check whether the card is in the remembered set - the card container\n+    \/\/ may be coarsened just now.\n+    \/\/assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the FromCardCache\", p2i(from));\n+   return;\n@@ -98,0 +85,25 @@\n+\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  _card_set.add_card(card_region, card_within_region);\n+}\n+\n+bool HeapRegionRemSet::contains_reference(OopOrNarrowOopStar from) {\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  return _card_set.contains_card(card_region, card_within_region);\n+}\n+\n+void HeapRegionRemSet::print_info(outputStream* st, OopOrNarrowOopStar from) {\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  _card_set.print_info(st, card_region, card_within_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":67,"deletions":55,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-JVMFlag::Error G1RSetRegionEntriesConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error G1RemSetArrayOfCardsEntriesConstraintFunc(uint value, bool verbose) {\n@@ -34,1 +34,1 @@\n-  \/\/ Default value of G1RSetRegionEntries=0 means will be set ergonomically.\n+  \/\/ Default value of G1RemSetArrayOfCardsEntries=0 means will be set ergonomically.\n@@ -36,1 +36,1 @@\n-  if (FLAG_IS_CMDLINE(G1RSetRegionEntries) && (value < 1)) {\n+  if (FLAG_IS_CMDLINE(G1RemSetArrayOfCardsEntries) && (value < 1)) {\n@@ -38,2 +38,2 @@\n-                        \"G1RSetRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n+                        \"G1RemSetArrayOfCardsEntries (%u) must be \"\n+                        \"greater than or equal to 1.\\n\",\n@@ -47,1 +47,1 @@\n-JVMFlag::Error G1RSetSparseRegionEntriesConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error G1RemSetHowlNumBucketsConstraintFunc(uint value, bool verbose) {\n@@ -50,3 +50,4 @@\n-  \/\/ Default value of G1RSetSparseRegionEntries=0 means will be set ergonomically.\n-  \/\/ Minimum value is 1.\n-  if (FLAG_IS_CMDLINE(G1RSetSparseRegionEntries) && (value < 1)) {\n+  if (!FLAG_IS_CMDLINE(G1RemSetHowlNumBuckets)) {\n+    return JVMFlag::SUCCESS;\n+  }\n+  if (value == 0 || !is_power_of_2(G1RemSetHowlNumBuckets)) {\n@@ -54,2 +55,2 @@\n-                        \"G1RSetSparseRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n+                        \"G1RemSetHowlNumBuckets (%u) must be a power of two \"\n+                        \"and greater than or equal to 1.\\n\",\n@@ -58,1 +59,8 @@\n-  } else {\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1RemSetHowlMaxNumBucketsConstraintFunc(uint value, bool verbose) {\n+  if (!UseG1GC) return JVMFlag::SUCCESS;\n+\n+  if (!FLAG_IS_CMDLINE(G1RemSetHowlMaxNumBuckets)) {\n@@ -61,0 +69,7 @@\n+  if (!is_power_of_2(G1RemSetHowlMaxNumBuckets)) {\n+    JVMFlag::printError(verbose,\n+                        \"G1RemSetMaxHowlNumBuckets (%u) must be a power of two.\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -33,3 +33,6 @@\n-  \/* G1 Flag Constraints *\/                           \\\n-  f(intx,   G1RSetRegionEntriesConstraintFunc)        \\\n-  f(intx,   G1RSetSparseRegionEntriesConstraintFunc)  \\\n+  \/* G1 Remembered Sets Constraints *\/                \\\n+  f(uint,   G1RemSetArrayOfCardsEntriesConstraintFunc)\\\n+  f(uint,   G1RemSetHowlMaxNumBucketsConstraintFunc)  \\\n+  f(uint,   G1RemSetHowlNumBucketsConstraintFunc)     \\\n+                                                      \\\n+  \/* G1 Heap Size Constraints *\/                      \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/g1\/heapRegionBounds.inline.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"gc\/g1\/sparsePRT.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-\n-\/\/ Check that the size of the SparsePRTEntry is evenly divisible by the maximum\n-\/\/ member type to avoid SIGBUS when accessing them.\n-STATIC_ASSERT(sizeof(SparsePRTEntry) % sizeof(int) == 0);\n-\n-void SparsePRTEntry::init(RegionIdx_t region_ind) {\n-  \/\/ Check that the card array element type can represent all cards in the region.\n-  \/\/ Choose a large SparsePRTEntry::card_elem_t (e.g. CardIdx_t) if required.\n-  assert(((size_t)1 << (sizeof(SparsePRTEntry::card_elem_t) * BitsPerByte)) *\n-         G1CardTable::card_size >= HeapRegionBounds::max_size(), \"precondition\");\n-  assert(G1RSetSparseRegionEntries > 0, \"precondition\");\n-  _region_ind = region_ind;\n-  _next_index = RSHashTable::NullEntry;\n-  _next_null = 0;\n-}\n-\n-bool SparsePRTEntry::contains_card(CardIdx_t card_index) const {\n-  for (int i = 0; i < num_valid_cards(); i++) {\n-    if (card(i) == card_index) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-SparsePRT::AddCardResult SparsePRTEntry::add_card(CardIdx_t card_index) {\n-  for (int i = 0; i < num_valid_cards(); i++) {\n-    if (card(i) == card_index) {\n-      return SparsePRT::found;\n-    }\n-  }\n-  if (num_valid_cards() < cards_num() - 1) {\n-    _cards[_next_null] = (card_elem_t)card_index;\n-    _next_null++;\n-    return SparsePRT::added;\n-   }\n-  \/\/ Otherwise, we're full.\n-  return SparsePRT::overflow;\n-}\n-\n-void SparsePRTEntry::copy_cards(card_elem_t* cards) const {\n-  memcpy(cards, _cards, cards_num() * sizeof(card_elem_t));\n-}\n-\n-void SparsePRTEntry::copy_cards(SparsePRTEntry* e) const {\n-  copy_cards(e->_cards);\n-  assert(_next_null >= 0, \"invariant\");\n-  assert(_next_null <= cards_num(), \"invariant\");\n-  e->_next_null = _next_null;\n-}\n-\n-\/\/ ----------------------------------------------------------------------\n-\n-float RSHashTable::TableOccupancyFactor = 0.5f;\n-\n-\/\/ The empty table can't hold any entries and is effectively immutable\n-\/\/ This means it can be used as an initial sentinel value\n-static int empty_buckets[] = { RSHashTable::NullEntry };\n-RSHashTable RSHashTable::empty_table;\n-\n-RSHashTable::RSHashTable() :\n-  _num_entries(0),\n-  _capacity(0),\n-  _capacity_mask(0),\n-  _occupied_entries(0),\n-  _entries(NULL),\n-  _buckets(empty_buckets),\n-  _free_region(0),\n-  _free_list(NullEntry) { }\n-\n-RSHashTable::RSHashTable(size_t capacity) :\n-  _num_entries((capacity * TableOccupancyFactor) + 1),\n-  _capacity(capacity),\n-  _capacity_mask(capacity - 1),\n-  _occupied_entries(0),\n-  _entries((SparsePRTEntry*)NEW_C_HEAP_ARRAY(char, _num_entries * SparsePRTEntry::size(), mtGC)),\n-  _buckets(NEW_C_HEAP_ARRAY(int, capacity, mtGC)),\n-  _free_region(0),\n-  _free_list(NullEntry)\n-{\n-  clear();\n-}\n-\n-RSHashTable::~RSHashTable() {\n-  \/\/ Nothing to free for empty RSHashTable\n-  if (_buckets != empty_buckets) {\n-    assert(_entries != NULL, \"invariant\");\n-    FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);\n-    FREE_C_HEAP_ARRAY(int, _buckets);\n-  }\n-}\n-\n-void RSHashTable::clear() {\n-  assert(_buckets != empty_buckets, \"Shouldn't call this for the empty_table\");\n-  _occupied_entries = 0;\n-  guarantee(_entries != NULL, \"invariant\");\n-  guarantee(_buckets != NULL, \"invariant\");\n-\n-  guarantee(_capacity <= ((size_t)1 << (sizeof(int)*BitsPerByte-1)) - 1,\n-                \"_capacity too large\");\n-\n-  \/\/ This will put -1 == NullEntry in the key field of all entries.\n-  memset((void*)_entries, NullEntry, _num_entries * SparsePRTEntry::size());\n-  memset((void*)_buckets, NullEntry, _capacity * sizeof(int));\n-  _free_list = NullEntry;\n-  _free_region = 0;\n-}\n-\n-SparsePRT::AddCardResult RSHashTable::add_card(RegionIdx_t region_ind, CardIdx_t card_index) {\n-  assert(this != &empty_table, \"can't add a card to the empty table\");\n-  SparsePRTEntry* e = entry_for_region_ind_create(region_ind);\n-  assert(e != NULL && e->r_ind() == region_ind,\n-         \"Postcondition of call above.\");\n-  SparsePRT::AddCardResult res = e->add_card(card_index);\n-  assert(e->num_valid_cards() > 0, \"Postcondition\");\n-  return res;\n-}\n-\n-SparsePRTEntry* RSHashTable::get_entry(RegionIdx_t region_ind) const {\n-  int ind = (int) (region_ind & capacity_mask());\n-  int cur_ind = _buckets[ind];\n-  SparsePRTEntry* cur;\n-  while (cur_ind != NullEntry &&\n-         (cur = entry(cur_ind))->r_ind() != region_ind) {\n-    cur_ind = cur->next_index();\n-  }\n-\n-  if (cur_ind == NullEntry) return NULL;\n-  \/\/ Otherwise...\n-  assert(cur->r_ind() == region_ind, \"Postcondition of loop + test above.\");\n-  assert(cur->num_valid_cards() > 0, \"Inv\");\n-  return cur;\n-}\n-\n-bool RSHashTable::delete_entry(RegionIdx_t region_ind) {\n-  int ind = (int) (region_ind & capacity_mask());\n-  int* prev_loc = &_buckets[ind];\n-  int cur_ind = *prev_loc;\n-  SparsePRTEntry* cur;\n-  while (cur_ind != NullEntry &&\n-         (cur = entry(cur_ind))->r_ind() != region_ind) {\n-    prev_loc = cur->next_index_addr();\n-    cur_ind = *prev_loc;\n-  }\n-\n-  if (cur_ind == NullEntry) return false;\n-  \/\/ Otherwise, splice out \"cur\".\n-  *prev_loc = cur->next_index();\n-  free_entry(cur_ind);\n-  _occupied_entries--;\n-  return true;\n-}\n-\n-SparsePRTEntry*\n-RSHashTable::entry_for_region_ind_create(RegionIdx_t region_ind) {\n-  SparsePRTEntry* res = get_entry(region_ind);\n-  if (res == NULL) {\n-    int new_ind = alloc_entry();\n-    res = entry(new_ind);\n-    res->init(region_ind);\n-    \/\/ Insert at front.\n-    int ind = (int) (region_ind & capacity_mask());\n-    res->set_next_index(_buckets[ind]);\n-    _buckets[ind] = new_ind;\n-    _occupied_entries++;\n-  }\n-  return res;\n-}\n-\n-int RSHashTable::alloc_entry() {\n-  int res;\n-  if (_free_list != NullEntry) {\n-    res = _free_list;\n-    _free_list = entry(res)->next_index();\n-    return res;\n-  } else if ((size_t)_free_region < _num_entries) {\n-    res = _free_region;\n-    _free_region++;\n-    return res;\n-  } else {\n-    return NullEntry;\n-  }\n-}\n-\n-void RSHashTable::free_entry(int fi) {\n-  entry(fi)->set_next_index(_free_list);\n-  _free_list = fi;\n-}\n-\n-void RSHashTable::add_entry(SparsePRTEntry* e) {\n-  assert(e->num_valid_cards() > 0, \"Precondition.\");\n-  SparsePRTEntry* e2 = entry_for_region_ind_create(e->r_ind());\n-  e->copy_cards(e2);\n-  assert(e2->num_valid_cards() > 0, \"Postcondition.\");\n-}\n-\n-bool RSHashTableBucketIter::has_next(SparsePRTEntry*& entry) {\n-  while (_bl_ind == RSHashTable::NullEntry)  {\n-    if (_tbl_ind + 1 >= _rsht->capacity()) {\n-      return false;\n-    }\n-    _tbl_ind++;\n-    _bl_ind = _rsht->_buckets[_tbl_ind];\n-  }\n-  entry = _rsht->entry(_bl_ind);\n-  _bl_ind = entry->next_index();\n-  return true;\n-}\n-\n-bool RSHashTable::contains_card(RegionIdx_t region_index, CardIdx_t card_index) const {\n-  SparsePRTEntry* e = get_entry(region_index);\n-  return (e != NULL && e->contains_card(card_index));\n-}\n-\n-size_t RSHashTable::mem_size() const {\n-  return sizeof(RSHashTable) +\n-    _num_entries * (SparsePRTEntry::size() + sizeof(int));\n-}\n-\n-\/\/ ----------------------------------------------------------------------\n-\n-SparsePRT::SparsePRT() :\n-  _table(&RSHashTable::empty_table) {\n-}\n-\n-\n-SparsePRT::~SparsePRT() {\n-  if (_table != &RSHashTable::empty_table) {\n-    delete _table;\n-  }\n-}\n-\n-\n-size_t SparsePRT::mem_size() const {\n-  \/\/ We ignore \"_cur\" here, because it either = _next, or else it is\n-  \/\/ on the deleted list.\n-  return sizeof(SparsePRT) + _table->mem_size();\n-}\n-\n-SparsePRT::AddCardResult SparsePRT::add_card(RegionIdx_t region_id, CardIdx_t card_index) {\n-  if (_table->should_expand()) {\n-    expand();\n-  }\n-  return _table->add_card(region_id, card_index);\n-}\n-\n-SparsePRTEntry* SparsePRT::get_entry(RegionIdx_t region_id) {\n-  return _table->get_entry(region_id);\n-}\n-\n-bool SparsePRT::delete_entry(RegionIdx_t region_id) {\n-  return _table->delete_entry(region_id);\n-}\n-\n-void SparsePRT::clear() {\n-  \/\/ If the entry table not at initial capacity, just reset to the empty table.\n-  if (_table->capacity() == InitialCapacity) {\n-    _table->clear();\n-  } else if (_table != &RSHashTable::empty_table) {\n-    delete _table;\n-    _table = &RSHashTable::empty_table;\n-  }\n-}\n-\n-void SparsePRT::expand() {\n-  RSHashTable* last = _table;\n-  if (last != &RSHashTable::empty_table) {\n-    _table = new RSHashTable(last->capacity() * 2);\n-    for (size_t i = 0; i < last->num_entries(); i++) {\n-      SparsePRTEntry* e = last->entry((int)i);\n-      if (e->valid_entry()) {\n-        _table->add_entry(e);\n-      }\n-    }\n-    delete last;\n-  } else {\n-    _table = new RSHashTable(InitialCapacity);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.cpp","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_SPARSEPRT_HPP\n-#define SHARE_GC_G1_SPARSEPRT_HPP\n-\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class RSHashTable;\n-class SparsePRTEntry;\n-\n-\/\/ Sparse remembered set for a heap region (the \"owning\" region).  Maps\n-\/\/ indices of other regions to short sequences of cards in the other region\n-\/\/ that might contain pointers into the owner region.\n-\/\/ Concurrent access to a SparsePRT must be serialized by some external mutex.\n-class SparsePRT {\n-  friend class SparsePRTBucketIter;\n-\n-  RSHashTable* _table;\n-\n-  static const size_t InitialCapacity = 8;\n-\n-  void expand();\n-\n-public:\n-  SparsePRT();\n-  ~SparsePRT();\n-\n-  size_t mem_size() const;\n-\n-  enum AddCardResult {\n-    overflow, \/\/ The table is full, could not add the card to the table.\n-    found,    \/\/ The card is already in the PRT.\n-    added     \/\/ The card has been added.\n-  };\n-\n-  \/\/ Attempts to ensure that the given card_index in the given region is in\n-  \/\/ the sparse table.  If successful (because the card was already\n-  \/\/ present, or because it was successfully added) returns \"true\".\n-  \/\/ Otherwise, returns \"false\" to indicate that the addition would\n-  \/\/ overflow the entry for the region.  The caller must transfer these\n-  \/\/ entries to a larger-capacity representation.\n-  AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);\n-\n-  \/\/ Return the pointer to the entry associated with the given region.\n-  SparsePRTEntry* get_entry(RegionIdx_t region_ind);\n-\n-  \/\/ If there is an entry for \"region_ind\", removes it and return \"true\";\n-  \/\/ otherwise returns \"false.\"\n-  bool delete_entry(RegionIdx_t region_ind);\n-\n-  \/\/ Clear the table, and reinitialize to initial capacity.\n-  void clear();\n-\n-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;\n-};\n-\n-class SparsePRTEntry: public CHeapObj<mtGC> {\n-public:\n-  \/\/ The type of a card entry.\n-  typedef uint16_t card_elem_t;\n-\n-private:\n-  \/\/ We need to make sizeof(SparsePRTEntry) an even multiple of maximum member size,\n-  \/\/ in order to force correct alignment that could otherwise cause SIGBUS errors\n-  \/\/ when reading the member variables. This calculates the minimum number of card\n-  \/\/ array elements required to get that alignment.\n-  static const size_t card_array_alignment = sizeof(int) \/ sizeof(card_elem_t);\n-\n-  RegionIdx_t _region_ind;\n-  int         _next_index;\n-  int         _next_null;\n-  \/\/ The actual cards stored in this array.\n-  \/\/ WARNING: Don't put any data members beyond this line. Card array has, in fact, variable length.\n-  \/\/ It should always be the last data member.\n-  card_elem_t _cards[card_array_alignment];\n-\n-  \/\/ Copy the current entry's cards into \"cards\".\n-  inline void copy_cards(card_elem_t* cards) const;\n-public:\n-  \/\/ Returns the size of the entry, used for entry allocation.\n-  static size_t size() { return sizeof(SparsePRTEntry) + sizeof(card_elem_t) * (cards_num() - card_array_alignment); }\n-  \/\/ Returns the size of the card array.\n-  static int cards_num() {\n-    return align_up((int)G1RSetSparseRegionEntries, (int)card_array_alignment);\n-  }\n-\n-  \/\/ Set the region_ind to the given value, and delete all cards.\n-  inline void init(RegionIdx_t region_ind);\n-\n-  RegionIdx_t r_ind() const { return _region_ind; }\n-  bool valid_entry() const { return r_ind() >= 0; }\n-\n-  int next_index() const { return _next_index; }\n-  int* next_index_addr() { return &_next_index; }\n-  void set_next_index(int ni) { _next_index = ni; }\n-\n-  \/\/ Returns \"true\" iff the entry contains the given card index.\n-  inline bool contains_card(CardIdx_t card_index) const;\n-\n-  \/\/ Returns the number of non-NULL card entries.\n-  inline int num_valid_cards() const { return _next_null; }\n-\n-  inline SparsePRT::AddCardResult add_card(CardIdx_t card_index);\n-\n-  \/\/ Copy the current entry's cards into the \"_card\" array of \"e.\"\n-  inline void copy_cards(SparsePRTEntry* e) const;\n-\n-  card_elem_t* cards() { return _cards; }\n-\n-  inline CardIdx_t card(int i) const {\n-    assert(i >= 0, \"must be nonnegative\");\n-    assert(i < cards_num(), \"range checking\");\n-    return (CardIdx_t)_cards[i];\n-  }\n-};\n-\n-class RSHashTable : public CHeapObj<mtGC> {\n-\n-  friend class RSHashTableBucketIter;\n-\n-  \/\/ Inverse maximum hash table occupancy used.\n-  static float TableOccupancyFactor;\n-\n-  size_t _num_entries;\n-\n-  size_t _capacity;\n-  size_t _capacity_mask;\n-  size_t _occupied_entries;\n-\n-  SparsePRTEntry* _entries;\n-  int* _buckets;\n-  int  _free_region;\n-  int  _free_list;\n-\n-  \/\/ Requires that the caller hold a lock preventing parallel modifying\n-  \/\/ operations, and that the the table be less than completely full.  If\n-  \/\/ an entry for \"region_ind\" is already in the table, finds it and\n-  \/\/ returns its address; otherwise allocates, initializes, inserts and\n-  \/\/ returns a new entry for \"region_ind\".\n-  SparsePRTEntry* entry_for_region_ind_create(RegionIdx_t region_ind);\n-\n-  \/\/ Returns the index of the next free entry in \"_entries\".\n-  int alloc_entry();\n-  \/\/ Declares the entry \"fi\" to be free.  (It must have already been\n-  \/\/ deleted from any bucket lists.\n-  void free_entry(int fi);\n-\n-  \/\/ For the empty sentinel created at static initialization time\n-  RSHashTable();\n-\n-public:\n-  RSHashTable(size_t capacity);\n-  ~RSHashTable();\n-\n-  static const int NullEntry = -1;\n-  static RSHashTable empty_table;\n-\n-  bool should_expand() const { return _occupied_entries == _num_entries; }\n-\n-  \/\/ Attempts to ensure that the given card_index in the given region is in\n-  \/\/ the sparse table.  If successful (because the card was already\n-  \/\/ present, or because it was successfully added) returns \"true\".\n-  \/\/ Otherwise, returns \"false\" to indicate that the addition would\n-  \/\/ overflow the entry for the region.  The caller must transfer these\n-  \/\/ entries to a larger-capacity representation.\n-  SparsePRT::AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);\n-\n-  bool delete_entry(RegionIdx_t region_id);\n-\n-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;\n-\n-  void add_entry(SparsePRTEntry* e);\n-\n-  SparsePRTEntry* get_entry(RegionIdx_t region_id) const;\n-\n-  void clear();\n-\n-  size_t capacity() const      { return _capacity; }\n-  size_t capacity_mask() const { return _capacity_mask;  }\n-  size_t mem_size() const;\n-  \/\/ The number of SparsePRTEntry instances available.\n-  size_t num_entries() const { return _num_entries; }\n-\n-  SparsePRTEntry* entry(int i) const {\n-    assert(i >= 0 && (size_t)i < _num_entries, \"precondition\");\n-    return (SparsePRTEntry*)((char*)_entries + SparsePRTEntry::size() * i);\n-  }\n-\n-  void print();\n-};\n-\n-\/\/ This is embedded in HRRS iterator.\n-class RSHashTableBucketIter {\n-  uint _tbl_ind;        \/\/ [0.._rsht->_capacity)\n-  int  _bl_ind;         \/\/ [-1, 0.._rsht->_capacity)\n-\n-  RSHashTable* _rsht;\n-\n-public:\n-  RSHashTableBucketIter(RSHashTable* rsht) :\n-    _tbl_ind(0),\n-    _bl_ind(rsht->_buckets[_tbl_ind]),\n-    _rsht(rsht) { }\n-\n-  bool has_next(SparsePRTEntry*& entry);\n-};\n-\n-class SparsePRTBucketIter: public RSHashTableBucketIter {\n-public:\n-  SparsePRTBucketIter(const SparsePRT* sprt) :\n-    RSHashTableBucketIter(sprt->_table) {}\n-\n-  bool has_next(SparsePRTEntry*& entry) {\n-    return RSHashTableBucketIter::has_next(entry);\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_SPARSEPRT_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.hpp","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n-#define SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n-\n-#include \"gc\/g1\/sparsePRT.hpp\"\n-\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-\n-inline bool SparsePRT::contains_card(RegionIdx_t region_id, CardIdx_t card_index) const {\n-  return _table->contains_card(region_id, card_index);\n-}\n-\n-\n-#endif \/\/ SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.inline.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -65,1 +65,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -498,3 +498,1 @@\n-HeapWord* DefNewGeneration::expand_and_allocate(size_t size,\n-                                                bool   is_tlab,\n-                                                bool   parallel) {\n+HeapWord* DefNewGeneration::expand_and_allocate(size_t size, bool is_tlab) {\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -311,3 +311,2 @@\n-  HeapWord* expand_and_allocate(size_t size,\n-                                bool is_tlab,\n-                                bool parallel = false);\n+\n+  HeapWord* expand_and_allocate(size_t size, bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -86,3 +86,1 @@\n-           obj->mark() == markWord::prototype() || \/\/ not gc marked?\n-           (UseBiasedLocking && obj->mark().has_bias_pattern()),\n-           \/\/ not gc marked?\n+           obj->mark() == markWord::prototype(), \/\/ not gc marked?\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,3 +191,1 @@\n-TenuredGeneration::expand_and_allocate(size_t word_size,\n-                                       bool is_tlab,\n-                                       bool parallel) {\n+TenuredGeneration::expand_and_allocate(size_t word_size, bool is_tlab) {\n@@ -195,24 +193,2 @@\n-  if (parallel) {\n-    MutexLocker x(ParGCRareEvent_lock);\n-    HeapWord* result = NULL;\n-    size_t byte_size = word_size * HeapWordSize;\n-    while (true) {\n-      expand(byte_size, _min_heap_delta_bytes);\n-      if (GCExpandToAllocateDelayMillis > 0) {\n-        os::naked_sleep(GCExpandToAllocateDelayMillis);\n-      }\n-      result = _the_space->par_allocate(word_size);\n-      if ( result != NULL) {\n-        return result;\n-      } else {\n-        \/\/ If there's not enough expansion space available, give up.\n-        if (_virtual_space.uncommitted_size() < byte_size) {\n-          return NULL;\n-        }\n-        \/\/ else try again\n-      }\n-    }\n-  } else {\n-    expand(word_size*HeapWordSize, _min_heap_delta_bytes);\n-    return _the_space->allocate(word_size);\n-  }\n+  expand(word_size*HeapWordSize, _min_heap_delta_bytes);\n+  return _the_space->allocate(word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":4,"deletions":28,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,3 +96,1 @@\n-  HeapWord* expand_and_allocate(size_t size,\n-                                bool is_tlab,\n-                                bool parallel = false);\n+  HeapWord* expand_and_allocate(size_t size, bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-  static CardValue clean_card_val()          { return clean_card; }\n-  static CardValue dirty_card_val()          { return dirty_card; }\n+  static constexpr CardValue clean_card_val()          { return clean_card; }\n+  static constexpr CardValue dirty_card_val()          { return dirty_card; }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    flush_deferred_card_mark_barrier(thread->as_Java_thread());\n+    flush_deferred_card_mark_barrier(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+\n+  \/\/ Printing\n+  const char* type_name() const { return \"ConcurrentGCThread\"; }\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -442,2 +441,1 @@\n-                                          bool is_tlab, bool run_verification, bool clear_soft_refs,\n-                                          bool restore_marks_for_biased_locking) {\n+                                          bool is_tlab, bool run_verification, bool clear_soft_refs) {\n@@ -464,8 +462,0 @@\n-  if (restore_marks_for_biased_locking) {\n-    \/\/ We perform this mark word preservation work lazily\n-    \/\/ because it's only at this point that we know whether we\n-    \/\/ absolutely have to do it; we want to avoid doing it for\n-    \/\/ scavenge-only collections where it's unnecessary\n-    BiasedLocking::preserve_marks();\n-  }\n-\n@@ -501,5 +491,1 @@\n-    if (!rp->enqueuing_is_done()) {\n-      rp->disable_discovery();\n-    } else {\n-      rp->set_enqueuing_is_done(false);\n-    }\n+    rp->disable_discovery();\n@@ -575,2 +561,1 @@\n-                       do_clear_all_soft_refs,\n-                       false);\n+                       do_clear_all_soft_refs);\n@@ -635,2 +620,1 @@\n-                       do_clear_all_soft_refs,\n-                       true);\n+                       do_clear_all_soft_refs);\n@@ -658,2 +642,0 @@\n-    BiasedLocking::restore_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,1 @@\n-                          bool run_verification, bool clear_soft_refs,\n-                          bool restore_marks_for_biased_locking);\n+                          bool run_verification, bool clear_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -336,3 +336,1 @@\n-  virtual HeapWord* expand_and_allocate(size_t word_size,\n-                                        bool is_tlab,\n-                                        bool parallel = false) = 0;\n+  virtual HeapWord* expand_and_allocate(size_t word_size, bool is_tlab) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  _thread->as_Java_thread()->check_for_valid_safepoint_state();\n+  JavaThread::cast(_thread)->check_for_valid_safepoint_state();\n@@ -385,6 +385,2 @@\n-  if (UseBiasedLocking) {\n-    oopDesc::set_mark(mem, _klass->prototype_header());\n-  } else {\n-    \/\/ May be bootstrapping\n-    oopDesc::set_mark(mem, markWord::prototype());\n-  }\n+  \/\/ May be bootstrapping\n+  oopDesc::set_mark(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-  _enqueuing_is_done(false),\n@@ -202,1 +201,0 @@\n-  assert(!enqueuing_is_done(), \"If here enqueuing should not be complete\");\n@@ -528,1 +526,1 @@\n-    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase1, _phase_times, worker_id);\n+    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase1, _phase_times, tracker_id(worker_id));\n@@ -566,1 +564,1 @@\n-    RefProcWorkerTimeTracker t(_phase_times->phase2_worker_time_sec(), worker_id);\n+    RefProcWorkerTimeTracker t(_phase_times->phase2_worker_time_sec(), tracker_id(worker_id));\n@@ -568,1 +566,1 @@\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase2, _phase_times, worker_id);\n+      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase2, _phase_times, tracker_id(worker_id));\n@@ -572,1 +570,1 @@\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::WeakRefSubPhase2, _phase_times, worker_id);\n+      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::WeakRefSubPhase2, _phase_times, tracker_id(worker_id));\n@@ -576,1 +574,1 @@\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase2, _phase_times, worker_id);\n+      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase2, _phase_times, tracker_id(worker_id));\n@@ -597,1 +595,1 @@\n-    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase3, _phase_times, worker_id);\n+    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase3, _phase_times, tracker_id(worker_id));\n@@ -614,1 +612,1 @@\n-    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::PhantomRefSubPhase4, _phase_times, worker_id);\n+    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::PhantomRefSubPhase4, _phase_times, tracker_id(worker_id));\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-  bool        _enqueuing_is_done;       \/\/ true if all weak references enqueued\n@@ -400,1 +399,0 @@\n-  void set_atomic_discovery(bool atomic) { _discovery_is_atomic = atomic; }\n@@ -409,4 +407,0 @@\n-  \/\/ whether all enqueueing of weak references is complete\n-  bool enqueuing_is_done()  { return _enqueuing_is_done; }\n-  void set_enqueuing_is_done(bool v) { _enqueuing_is_done = v; }\n-\n@@ -564,21 +558,0 @@\n-\/\/ A utility class to temporarily change the disposition\n-\/\/ of the \"discovery_is_atomic\" field of the\n-\/\/ given ReferenceProcessor in the scope that contains it.\n-class ReferenceProcessorAtomicMutator: StackObj {\n- private:\n-  ReferenceProcessor* _rp;\n-  bool                _saved_atomic_discovery;\n-\n- public:\n-  ReferenceProcessorAtomicMutator(ReferenceProcessor* rp,\n-                                  bool atomic):\n-    _rp(rp) {\n-    _saved_atomic_discovery = _rp->discovery_is_atomic();\n-    _rp->set_atomic_discovery(atomic);\n-  }\n-\n-  ~ReferenceProcessorAtomicMutator() {\n-    _rp->set_atomic_discovery(_saved_atomic_discovery);\n-  }\n-};\n-\n@@ -598,0 +571,4 @@\n+  \/\/ Used for tracking how much time a worker spends in a (sub)phase.\n+  uint tracker_id(uint worker_id) const {\n+    return _ref_processor.processing_is_mt() ? worker_id : 0;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  _worker_time->set(_worker_id, result);\n+  _worker_time->set_or_add(_worker_id, result);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static const uint MaxThreadWorkItems = 6;\n+  static const uint MaxThreadWorkItems = 9;\n@@ -70,0 +70,1 @@\n+  void set_or_add(uint worker_i, T value);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+template <typename T>\n+void WorkerDataArray<T>::set_or_add(uint worker_i, T value) {\n+  assert(worker_i < _length, \"Worker %d is greater than max: %d\", worker_i, _length);\n+  if (_data[worker_i] == uninitialized()) {\n+    _data[worker_i] = value;\n+  } else {\n+    _data[worker_i] += value;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -222,0 +222,3 @@\n+\n+  \/\/ Printing\n+  const char* type_name() const override { return \"GCTaskThread\"; }\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-      JavaThread* const jt = thread->as_Java_thread();\n+      JavaThread* const jt = JavaThread::cast(thread);\n@@ -125,1 +125,1 @@\n-        StackWatermarkSet::finish_processing(thread->as_Java_thread(), &oops, StackWatermarkKind::gc);\n+        StackWatermarkSet::finish_processing(JavaThread::cast(thread), &oops, StackWatermarkKind::gc);\n@@ -128,1 +128,1 @@\n-        StackWatermarkSet::finish_processing(thread->as_Java_thread(), &oops, StackWatermarkKind::gc);\n+        StackWatermarkSet::finish_processing(JavaThread::cast(thread), &oops, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-  JavaThread* const jt = thread->as_Java_thread();\n+  JavaThread* const jt = JavaThread::cast(thread);\n@@ -937,1 +937,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  char* name() const { return (char*)\"ShenandoahControlThread\";}\n+  const char* name() const { return \"ShenandoahControlThread\";}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -185,1 +184,0 @@\n-    BiasedLocking::preserve_marks();\n@@ -233,1 +231,0 @@\n-    BiasedLocking::restore_marks();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1753,1 +1753,1 @@\n-      ThreadBlockInVM sp(thread->as_Java_thread());\n+      ThreadBlockInVM sp(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  JavaThread* const jt = thread->as_Java_thread();\n+  JavaThread* const jt = JavaThread::cast(thread);\n@@ -205,1 +205,1 @@\n-        ShenandoahStackWatermark* wm = StackWatermarkSet::get<ShenandoahStackWatermark>(thr->as_Java_thread(), StackWatermarkKind::gc);\n+        ShenandoahStackWatermark* wm = StackWatermarkSet::get<ShenandoahStackWatermark>(JavaThread::cast(thr), StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    _sema.wait_with_safepoint_check(thread->as_Java_thread());\n+    _sema.wait_with_safepoint_check(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/gc\/z\/zFuture.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-      ThreadBlockInVM tbivm(_thread->as_Java_thread());\n+      ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -730,3 +729,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n-  }\n@@ -1037,21 +1033,0 @@\n-\n-  if (osr_nm != NULL) {\n-    \/\/ We may need to do on-stack replacement which requires that no\n-    \/\/ monitors in the activation are biased because their\n-    \/\/ BasicObjectLocks will need to migrate during OSR. Force\n-    \/\/ unbiasing of all monitors in the activation now (even though\n-    \/\/ the OSR nmethod might be invalidated) because we don't have a\n-    \/\/ safepoint opportunity later once the migration begins.\n-    if (UseBiasedLocking) {\n-      ResourceMark rm;\n-      GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-      for( BasicObjectLock *kptr = last_frame.monitor_end();\n-           kptr < last_frame.monitor_begin();\n-           kptr = last_frame.next_monitor(kptr) ) {\n-        if( kptr->obj() != NULL ) {\n-          objects_to_revoke->append(Handle(current, kptr->obj()));\n-        }\n-      }\n-      BiasedLocking::revoke(objects_to_revoke, current);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -579,1 +579,0 @@\n-        \/\/ Monitor not filled in frame manager any longer as this caused race condition with biased locking.\n@@ -583,2 +582,0 @@\n-        assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -679,2 +676,0 @@\n-      assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1522,2 +1517,0 @@\n-          assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1556,2 +1549,0 @@\n-            assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1880,1 +1871,0 @@\n-              assert(!UseBiasedLocking, \"Not implemented\");\n@@ -2686,2 +2676,0 @@\n-          assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -2754,2 +2742,0 @@\n-            assert(!UseBiasedLocking, \"Not implemented\");\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-  DEBUG_ONLY(check_new_unstarted_java_thread(t->as_Java_thread());)\n+  DEBUG_ONLY(check_new_unstarted_java_thread(JavaThread::cast(t));)\n@@ -826,1 +826,1 @@\n-  if (check_exclusion_state_on_thread_start(t->as_Java_thread())) {\n+  if (check_exclusion_state_on_thread_start(JavaThread::cast(t))) {\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n@@ -162,0 +163,1 @@\n+  e.set_objectSize(sample->allocated());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,19 +73,0 @@\n-  <Event name=\"BiasedLockRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Revocation\" description=\"Revoked bias of object\" thread=\"true\"\n-    stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"lockClass\" label=\"Lock Class\" description=\"Class of object whose biased lock was revoked\" \/>\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-    <Field type=\"Thread\" name=\"previousOwner\" label=\"Previous Owner\" description=\"Thread owning the bias before revocation\" \/>\n-  <\/Event>\n-\n-  <Event name=\"BiasedLockSelfRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Self Revocation\" description=\"Revoked bias of object biased towards own thread\"\n-    thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"lockClass\" label=\"Lock Class\" description=\"Class of object whose biased lock was revoked\" \/>\n-  <\/Event>\n-\n-  <Event name=\"BiasedLockClassRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Class Revocation\" description=\"Revoked biases for all instances of a class\"\n-    thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"revokedClass\" label=\"Revoked Class\" description=\"Class whose biased locks were revoked\" \/>\n-    <Field type=\"boolean\" name=\"disableBiasing\" label=\"Disable Further Biasing\" description=\"Whether further biasing for instances of this class will be allowed\" \/>\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-  <\/Event>\n-\n@@ -630,0 +611,1 @@\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"objectSize\" label=\"Object Size\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-  JavaThread* jth = context.thread()->as_Java_thread();\n+  JavaThread* jth = JavaThread::cast(context.thread());\n@@ -346,1 +346,2 @@\n-  virtual char* name() const { return (char*)\"JFR Thread Sampler\"; }\n+  virtual const char* name() const { return \"JFR Thread Sampler\"; }\n+  virtual const char* type_name() const { return \"JfrThreadSampler\"; }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-      ThreadInVMfromNative transition(thread->as_Java_thread());\n+      ThreadInVMfromNative transition(JavaThread::cast(thread));\n@@ -481,1 +481,1 @@\n-    JfrJavaEventWriter::notify(thread->as_Java_thread());\n+    JfrJavaEventWriter::notify(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  const oop thread_obj = t->as_Java_thread()->threadObj();\n+  const oop thread_obj = JavaThread::cast(t)->threadObj();\n@@ -126,1 +126,1 @@\n-  return t->is_Java_thread() ? get_java_thread_name(t->as_Java_thread()) : t->name();\n+  return t->is_Java_thread() ? get_java_thread_name(JavaThread::cast(t)) : t->name();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    _writer.write(JfrThreadGroup::thread_group_id(t->as_Java_thread(), _curthread));\n+    _writer.write(JfrThreadGroup::thread_group_id(JavaThread::cast(t), _curthread));\n@@ -279,1 +279,1 @@\n-    JavaThread* const jt = _thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(_thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -431,2 +431,0 @@\n-    assert(IS_NOT_SERIALIZED(value), \"invariant\");\n-    return;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? t->as_Java_thread() : NULL),\n+  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? JavaThread::cast(t) : NULL),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  return (thread->is_Java_thread() && thread->as_Java_thread()->thread_state() != _thread_in_vm) || thread->is_VM_thread();\n+  return (thread->is_Java_thread() && JavaThread::cast(thread)->thread_state() != _thread_in_vm) || thread->is_VM_thread();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  return instance().record_for(thread->as_Java_thread(), skip, frames, tl->stackdepth());\n+  return instance().record_for(JavaThread::cast(thread), skip, frames, tl->stackdepth());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        send_java_thread_start_event(t->as_Java_thread());\n+        send_java_thread_start_event(JavaThread::cast(t));\n@@ -163,1 +163,1 @@\n-      JavaThread* const jt = t->as_Java_thread();\n+      JavaThread* const jt = JavaThread::cast(t);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-       JfrJavaEventWriter::notify(t->as_Java_thread());\n+       JfrJavaEventWriter::notify(JavaThread::cast(t));\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  return thread->as_Java_thread();\n+  return JavaThread::cast(thread);\n@@ -2282,1 +2282,1 @@\n-    attach_args.name = thread->name();\n+    attach_args.name = const_cast<char*>(thread->name());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-  do_bool_flag(UseBiasedLocking)                                           \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-      attach_args.name = thread->name();\n+      attach_args.name = const_cast<char*>(thread->name());\n@@ -317,1 +317,1 @@\n-        JavaThread* THREAD = thread->as_Java_thread(); \/\/ For exception macros.\n+        JavaThread* THREAD = JavaThread::cast(thread); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -651,1 +650,0 @@\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n@@ -653,1 +651,0 @@\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -658,1 +655,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n-  bool is_Named_thread() const override { return true; }\n+  const char* name() const override { return \"AsyncLog Thread\"; }\n+  const char* type_name() const override { return \"AsyncLogWriter\"; }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  LOG_TAG(biasedlocking) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-void VirtualSpace::print_on(outputStream* out) {\n+void VirtualSpace::print_on(outputStream* out) const {\n@@ -1049,1 +1049,1 @@\n-void VirtualSpace::print() {\n+void VirtualSpace::print() const {\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,2 +243,2 @@\n-  void print_on(outputStream* out) PRODUCT_RETURN;\n-  void print();\n+  void print_on(outputStream* out) const PRODUCT_RETURN;\n+  void print() const;\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -589,1 +589,1 @@\n-      JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n+      JavaThread* THREAD = JavaThread::cast(current); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-class PSPromotionManager;\n-\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2155,1 +2155,1 @@\n-    _exception = Exceptions::new_exception(current->as_Java_thread(),\n+    _exception = Exceptions::new_exception(JavaThread::cast(current),\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -511,6 +510,0 @@\n-\n-  \/\/ Set biased locking bit for all instances of this class; it will be\n-  \/\/ cleared if revocation occurs too often for this type\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    set_prototype_header(markWord::biased_locking_prototype());\n-  }\n@@ -686,1 +679,1 @@\n-    SystemDictionaryShared::remove_dumptime_info(this);\n+    SystemDictionaryShared::handle_class_unloading(this);\n@@ -2533,5 +2526,0 @@\n-  \/\/ Initialize current biased locking state.\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    set_prototype_header(markWord::biased_locking_prototype());\n-  }\n-\n@@ -2541,1 +2529,0 @@\n-    set_prototype_header(markWord::prototype());\n@@ -2616,1 +2603,1 @@\n-    SystemDictionaryShared::remove_dumptime_info(ik);\n+    SystemDictionaryShared::handle_class_unloading(ik);\n@@ -3627,1 +3614,1 @@\n-        current->as_Java_thread()->security_get_caller_class(1):\n+        JavaThread::cast(current)->security_get_caller_class(1):\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-                           _prototype_header(markWord::prototype()),\n@@ -715,4 +714,0 @@\n-int Klass::atomic_incr_biased_lock_revocation_count() {\n-  return (int) Atomic::add(&_biased_lock_revocation_count, 1);\n-}\n-\n@@ -747,2 +742,0 @@\n-     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n-     st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -162,6 +162,0 @@\n-  \/\/ Biased locking implementation and statistics\n-  \/\/ (the 64-bit chunk goes first, to avoid some fragmentation)\n-  jlong    _last_biased_lock_bulk_revocation_time;\n-  markWord _prototype_header;   \/\/ Used when biased locking is both enabled and disabled for this type\n-  jint     _biased_lock_revocation_count;\n-\n@@ -648,24 +642,0 @@\n-  \/\/ Biased locking support\n-  \/\/ Note: the prototype header is always set up to be at least the\n-  \/\/ prototype markWord. If biased locking is enabled it may further be\n-  \/\/ biasable and have an epoch.\n-  markWord prototype_header() const      { return _prototype_header; }\n-\n-  \/\/ NOTE: once instances of this klass are floating around in the\n-  \/\/ system, this header must only be updated at a safepoint.\n-  \/\/ NOTE 2: currently we only ever set the prototype header to the\n-  \/\/ biasable prototype for instanceKlasses. There is no technical\n-  \/\/ reason why it could not be done for arrayKlasses aside from\n-  \/\/ wanting to reduce the initial scope of this optimization. There\n-  \/\/ are potential problems in setting the bias pattern for\n-  \/\/ JVM-internal oops.\n-  inline void set_prototype_header(markWord header);\n-  static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }\n-\n-  int  biased_lock_revocation_count() const { return (int) _biased_lock_revocation_count; }\n-  \/\/ Atomically increments biased_lock_revocation_count and returns updated value\n-  int atomic_incr_biased_lock_revocation_count();\n-  void set_biased_lock_revocation_count(int val) { _biased_lock_revocation_count = (jint) val; }\n-  jlong last_biased_lock_bulk_revocation_time() { return _last_biased_lock_bulk_revocation_time; }\n-  void  set_last_biased_lock_bulk_revocation_time(jlong cur_time) { _last_biased_lock_bulk_revocation_time = cur_time; }\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -54,5 +54,0 @@\n-inline void Klass::set_prototype_header(markWord header) {\n-  assert(!header.has_bias_pattern() || is_instance_klass(), \"biased locking currently only supported for Java instances\");\n-  _prototype_header = header;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,1 @@\n-    \/\/ Biased bit is 3rd rightmost bit\n-    if (is_neutral()) {   \/\/ last bits = 001\n+    if (is_neutral()) {   \/\/ last bits = 01\n@@ -91,4 +90,0 @@\n-    } else if (has_bias_pattern()) {  \/\/ last bits = 101\n-      st->print(\"is_biased\");\n-      JavaThread* jt = biased_locker();\n-      st->print(\" biased_locker=\" INTPTR_FORMAT \" epoch=%d\", p2i(jt), bias_epoch());\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,1 @@\n-\/\/             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)\n-\/\/             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)\n+\/\/             hash:25 ------------>| age:4  unused_gap:1  lock:2 (normal object)\n@@ -44,2 +43,1 @@\n-\/\/  unused:25 hash:31 -->| unused_gap:1   age:4    biased_lock:1 lock:2 (normal object)\n-\/\/  JavaThread*:54 epoch:2 unused_gap:1   age:4    biased_lock:1 lock:2 (biased object)\n+\/\/  unused:25 hash:31 -->| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n@@ -52,28 +50,0 @@\n-\/\/  - the biased lock pattern is used to bias a lock toward a given\n-\/\/    thread. When this pattern is set in the low three bits, the lock\n-\/\/    is either biased toward a given thread or \"anonymously\" biased,\n-\/\/    indicating that it is possible for it to be biased. When the\n-\/\/    lock is biased toward a given thread, locking and unlocking can\n-\/\/    be performed by that thread without using atomic operations.\n-\/\/    When a lock's bias is revoked, it reverts back to the normal\n-\/\/    locking scheme described below.\n-\/\/\n-\/\/    Note that we are overloading the meaning of the \"unlocked\" state\n-\/\/    of the header. Because we steal a bit from the age we can\n-\/\/    guarantee that the bias pattern will never be seen for a truly\n-\/\/    unlocked object.\n-\/\/\n-\/\/    Note also that the biased state contains the age bits normally\n-\/\/    contained in the object header. Large increases in scavenge\n-\/\/    times were seen when these bits were absent and an arbitrary age\n-\/\/    assigned to all biased objects, because they tended to consume a\n-\/\/    significant fraction of the eden semispaces and were not\n-\/\/    promoted promptly, causing an increase in the amount of copying\n-\/\/    performed. The runtime system aligns all JavaThread* pointers to\n-\/\/    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))\n-\/\/    to make room for the age bits & the epoch bits (used in support of\n-\/\/    biased locking).\n-\/\/\n-\/\/    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread\n-\/\/    [0           | epoch | age | 1 | 01]       lock is anonymously biased\n-\/\/\n@@ -83,1 +53,1 @@\n-\/\/    [header      | 0 | 01]  unlocked           regular object header\n+\/\/    [header          | 01]  unlocked           regular object header\n@@ -131,2 +101,2 @@\n-  static const int biased_lock_bits               = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - biased_lock_bits;\n+  static const int first_unused_gap_bits          = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n@@ -134,2 +104,1 @@\n-  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);\n-  static const int epoch_bits                     = 2;\n+  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n@@ -137,2 +106,0 @@\n-  \/\/ The biased locking code currently requires that the age bits be\n-  \/\/ contiguous to the lock bits.\n@@ -140,5 +107,2 @@\n-  static const int biased_lock_shift              = lock_bits;\n-  static const int age_shift                      = lock_bits + biased_lock_bits;\n-  static const int unused_gap_shift               = age_shift + age_bits;\n-  static const int hash_shift                     = unused_gap_shift + unused_gap_bits;\n-  static const int epoch_shift                    = hash_shift;\n+  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n+  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n@@ -148,3 +112,0 @@\n-  static const uintptr_t biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits);\n-  static const uintptr_t biased_lock_mask_in_place= biased_lock_mask << lock_shift;\n-  static const uintptr_t biased_lock_bit_in_place = 1 << biased_lock_shift;\n@@ -153,3 +114,0 @@\n-  static const uintptr_t epoch_mask               = right_n_bits(epoch_bits);\n-  static const uintptr_t epoch_mask_in_place      = epoch_mask << epoch_shift;\n-\n@@ -159,3 +117,0 @@\n-  \/\/ Alignment of JavaThread pointers encoded in object header required by biased locking\n-  static const size_t biased_lock_alignment       = 2 << (epoch_shift + epoch_bits);\n-\n@@ -166,1 +121,0 @@\n-  static const uintptr_t biased_lock_pattern      = 5;\n@@ -174,2 +128,0 @@\n-  static const int max_bias_epoch                 = epoch_mask;\n-\n@@ -179,38 +131,0 @@\n-  \/\/ Biased Locking accessors.\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  bool has_bias_pattern() const {\n-    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);\n-  }\n-  JavaThread* biased_locker() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (JavaThread*) mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place));\n-  }\n-  \/\/ Indicates that the mark has the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  bool is_biased_anonymously() const {\n-    return (has_bias_pattern() && (biased_locker() == NULL));\n-  }\n-  \/\/ Indicates epoch in which this bias was acquired. If the epoch\n-  \/\/ changes due to too many bias revocations occurring, the biases\n-  \/\/ from the previous epochs are all considered invalid.\n-  int bias_epoch() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (mask_bits(value(), epoch_mask_in_place) >> epoch_shift);\n-  }\n-  markWord set_bias_epoch(int epoch) {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    assert((epoch & (~epoch_mask)) == 0, \"epoch overflow\");\n-    return markWord(mask_bits(value(), ~epoch_mask_in_place) | (epoch << epoch_shift));\n-  }\n-  markWord incr_bias_epoch() {\n-    return set_bias_epoch((1 + bias_epoch()) & epoch_mask);\n-  }\n-  \/\/ Prototype mark for initialization\n-  static markWord biased_locking_prototype() {\n-    return markWord( biased_lock_pattern );\n-  }\n-\n@@ -222,1 +136,1 @@\n-    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n@@ -227,1 +141,3 @@\n-  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n+  bool is_neutral()  const {\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n+  }\n@@ -242,1 +158,3 @@\n-  inline bool must_be_preserved(const oopDesc* obj) const;\n+  bool must_be_preserved(const oopDesc* obj) const {\n+    return (!is_unlocked() || !has_no_hash());\n+  }\n@@ -246,16 +164,3 @@\n-  \/\/ Note that we special case this situation. We want to avoid\n-  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n-  \/\/ decrease the number of mark words that need to be preserved\n-  \/\/ during GC) during each scavenge. During scavenges in which there\n-  \/\/ is no promotion failure, we actually don't need to call the above\n-  \/\/ routines at all, since we don't mutate and re-initialize the\n-  \/\/ marks of promoted objects using init_mark(). However, during\n-  \/\/ scavenges which result in promotion failure, we do re-initialize\n-  \/\/ the mark words of objects, meaning that we should have called\n-  \/\/ these mark word preservation routines. Currently there's no good\n-  \/\/ place in which to call them in any of the scavengers (although\n-  \/\/ guarded by appropriate locks we could make one), but the\n-  \/\/ observation is that promotion failures are quite rare and\n-  \/\/ reducing the number of mark words preserved during them isn't a\n-  \/\/ high priority.\n-  inline bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const;\n+  bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n+    return (!is_unlocked() || !has_no_hash());\n+  }\n@@ -308,7 +213,0 @@\n-  static markWord encode(JavaThread* thread, uint age, int bias_epoch) {\n-    uintptr_t tmp = (uintptr_t) thread;\n-    assert(UseBiasedLocking && ((tmp & (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), \"misaligned JavaThread pointer\");\n-    assert(age <= max_age, \"age too large\");\n-    assert(bias_epoch <= max_bias_epoch, \"bias epoch too large\");\n-    return markWord(tmp | (bias_epoch << epoch_shift) | (age << age_shift) | biased_lock_pattern);\n-  }\n@@ -344,3 +242,0 @@\n-  \/\/ Helper function for restoration of unmarked mark oops during GC\n-  static inline markWord prototype_for_klass(const Klass* klass);\n-\n@@ -354,1 +249,1 @@\n-  inline void* decode_pointer() { if (UseBiasedLocking && has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }\n+  inline void* decode_pointer() { return (void*)clear_lock_bits().value(); }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":20,"deletions":125,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_OOPS_MARKWORD_INLINE_HPP\n-#define SHARE_OOPS_MARKWORD_INLINE_HPP\n-\n-#include \"oops\/markWord.hpp\"\n-\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n-\n-\/\/ Should this header be preserved during GC?\n-inline bool markWord::must_be_preserved(const oopDesc* obj) const {\n-  if (UseBiasedLocking) {\n-    if (has_bias_pattern()) {\n-      \/\/ Will reset bias at end of collection\n-      \/\/ Mark words of biased and currently locked objects are preserved separately\n-      return false;\n-    }\n-    markWord prototype_header = prototype_for_klass(obj->klass());\n-    if (prototype_header.has_bias_pattern()) {\n-      \/\/ Individual instance which has its bias revoked; must return\n-      \/\/ true for correctness\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure during scavenge?\n-inline bool markWord::must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n-  if (UseBiasedLocking) {\n-    \/\/ We don't explicitly save off the mark words of biased and\n-    \/\/ currently-locked objects during scavenges, so if during a\n-    \/\/ promotion failure we encounter either a biased mark word or a\n-    \/\/ klass which still has a biasable prototype header, we have to\n-    \/\/ preserve the mark word. This results in oversaving, but promotion\n-    \/\/ failures are rare, and this avoids adding more complex logic to\n-    \/\/ the scavengers to call new variants of\n-    \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n-    \/\/ of a scavenge when a promotion failure has first been detected.\n-    if (has_bias_pattern() || prototype_for_klass(obj->klass()).has_bias_pattern()) {\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-inline markWord markWord::prototype_for_klass(const Klass* klass) {\n-  markWord prototype_header = klass->prototype_header();\n-  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n-\n-  return prototype_header;\n-}\n-\n-#endif \/\/ SHARE_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -616,1 +616,1 @@\n-    JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n+    JavaThread* THREAD = JavaThread::cast(current); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,1 +236,0 @@\n-  inline bool has_bias_pattern() const;\n@@ -286,2 +285,0 @@\n-  \/\/ NOTE with the introduction of UseBiasedLocking that identity_hash() might reach a\n-  \/\/ safepoint if called on a biased object. Calling code must be aware of that.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -78,1 +78,1 @@\n-  set_mark(markWord::prototype_for_klass(klass()));\n+  set_mark(markWord::prototype());\n@@ -257,4 +257,0 @@\n-bool oopDesc::has_bias_pattern() const {\n-  return mark().has_bias_pattern();\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -290,7 +290,11 @@\n-  develop_pd(intx, FLOATPRESSURE,                                           \\\n-          \"Number of float LRG's that constitute high register pressure\")   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  develop_pd(intx, INTPRESSURE,                                             \\\n-          \"Number of integer LRG's that constitute high register pressure\") \\\n-          range(0, max_jint)                                                \\\n+  develop(intx, FLOATPRESSURE, -1,                                          \\\n+          \"Number of float LRG's that constitute high register pressure.\"   \\\n+          \"-1: means the threshold is determined by number of available \"   \\\n+          \"float register for allocation\")                                  \\\n+          range(-1, max_jint)                                               \\\n+                                                                            \\\n+  develop(intx, INTPRESSURE, -1,                                            \\\n+          \"Number of integer LRG's that constitute high register pressure.\" \\\n+          \"-1: means the threshold is determined by number of available \"   \\\n+          \"integer register for allocation\")                                \\\n+          range(-1, max_jint)                                               \\\n@@ -451,4 +455,0 @@\n-  product(bool, PrintPreciseBiasedLockingStatistics, false, DIAGNOSTIC,     \\\n-          \"(Deprecated) Print per-lock-site statistics of biased locking \"  \\\n-          \"in JVM\")                                                         \\\n-                                                                            \\\n@@ -510,3 +510,0 @@\n-  product(bool, UseOptoBiasInlining, true,                                  \\\n-          \"(Deprecated) Generate biased locking code in C2 ideal graph\")    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1673,7 +1673,1 @@\n-  if (UseBiasedLocking && Opcode() == Op_Allocate) {\n-    Node* klass_node = in(AllocateNode::KlassNode);\n-    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n-    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n-  } else {\n-    mark_node = phase->MakeConX(markWord::prototype().value());\n-  }\n+  mark_node = phase->MakeConX(markWord::prototype().value());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -213,4 +213,4 @@\n-  , _sched_int_pressure(0, INTPRESSURE)\n-  , _sched_float_pressure(0, FLOATPRESSURE)\n-  , _scratch_int_pressure(0, INTPRESSURE)\n-  , _scratch_float_pressure(0, FLOATPRESSURE)\n+  , _sched_int_pressure(0, Matcher::int_pressure_limit())\n+  , _sched_float_pressure(0, Matcher::float_pressure_limit())\n+  , _scratch_int_pressure(0, Matcher::int_pressure_limit())\n+  , _scratch_float_pressure(0, Matcher::float_pressure_limit())\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3527,4 +3527,0 @@\n-  if (UseBiasedLocking && PrintPreciseBiasedLockingStatistics) {\n-    \/\/ Create the counters for this fast lock.\n-    flock->create_lock_counter(sync_jvms()); \/\/ sync_jvms used to get current bci\n-  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -859,2 +859,2 @@\n-    Pressure int_pressure(last_inst + 1, INTPRESSURE);\n-    Pressure float_pressure(last_inst + 1, FLOATPRESSURE);\n+    Pressure int_pressure(last_inst + 1, Matcher::int_pressure_limit());\n+    Pressure float_pressure(last_inst + 1, Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1079,5 +1079,4 @@\n-    uint float_pressure = Matcher::float_pressure(FLOATPRESSURE);\n-    _regalloc->_sched_int_pressure.init(INTPRESSURE);\n-    _regalloc->_sched_float_pressure.init(float_pressure);\n-    _regalloc->_scratch_int_pressure.init(INTPRESSURE);\n-    _regalloc->_scratch_float_pressure.init(float_pressure);\n+    _regalloc->_sched_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_sched_float_pressure.init(Matcher::float_pressure_limit());\n+    _regalloc->_scratch_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_scratch_float_pressure.init(Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3815,1 +3815,1 @@\n-  Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);\n+  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n@@ -6418,1 +6418,1 @@\n-  assert(callee()->signature()->size() == 6, \"base64_decodeBlock has 6 parameters\");\n+  assert(callee()->signature()->size() == 7, \"base64_decodeBlock has 7 parameters\");\n@@ -6430,0 +6430,1 @@\n+  Node* isMIME = argument(7);\n@@ -6442,1 +6443,1 @@\n-                                 src_start, src_offset, len, dest_start, dest_offset, isURL);\n+                                 src_start, src_offset, len, dest_start, dest_offset, isURL, isMIME);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -161,9 +161,0 @@\n-\/\/\n-\/\/ Create a counter which counts the number of times this lock is acquired\n-\/\/\n-void FastLockNode::create_lock_counter(JVMState* state) {\n-  BiasedLockingNamedCounter* blnc = (BiasedLockingNamedCounter*)\n-           OptoRuntime::new_named_counter(state, NamedCounter::BiasedLockingCounter);\n-  _counters = blnc->counters();\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class BiasedLockingCounters;\n@@ -77,1 +76,0 @@\n-  BiasedLockingCounters*        _counters;\n@@ -85,1 +83,0 @@\n-    _counters = NULL;\n@@ -102,1 +99,0 @@\n-  void create_lock_counter(JVMState* s);\n@@ -104,1 +100,0 @@\n-  BiasedLockingCounters*        counters() const { return _counters; }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class BiasedLockingCounters;\n@@ -798,1 +797,0 @@\n-  BiasedLockingCounters*        _counters;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2167,80 +2167,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/*\n-     *  See the full description in MacroAssembler::biased_locking_enter().\n-     *\n-     *  if( (mark_word & biased_lock_mask) == biased_lock_pattern ) {\n-     *    \/\/ The object is biased.\n-     *    proto_node = klass->prototype_header;\n-     *    o_node = thread | proto_node;\n-     *    x_node = o_node ^ mark_word;\n-     *    if( (x_node & ~age_mask) == 0 ) { \/\/ Biased to the current thread ?\n-     *      \/\/ Done.\n-     *    } else {\n-     *      if( (x_node & biased_lock_mask) != 0 ) {\n-     *        \/\/ The klass's prototype header is no longer biased.\n-     *        cas(&mark_word, mark_word, proto_node)\n-     *        goto cas_lock;\n-     *      } else {\n-     *        \/\/ The klass's prototype header is still biased.\n-     *        if( (x_node & epoch_mask) != 0 ) { \/\/ Expired epoch?\n-     *          old = mark_word;\n-     *          new = o_node;\n-     *        } else {\n-     *          \/\/ Different thread or anonymous biased.\n-     *          old = mark_word & (epoch_mask | age_mask | biased_lock_mask);\n-     *          new = thread | old;\n-     *        }\n-     *        \/\/ Try to rebias.\n-     *        if( cas(&mark_word, old, new) == 0 ) {\n-     *          \/\/ Done.\n-     *        } else {\n-     *          goto slow_path; \/\/ Failed.\n-     *        }\n-     *      }\n-     *    }\n-     *  } else {\n-     *    \/\/ The object is not biased.\n-     *    cas_lock:\n-     *    if( FastLock(obj) == 0 ) {\n-     *      \/\/ Done.\n-     *    } else {\n-     *      slow_path:\n-     *      OptoRuntime::complete_monitor_locking_Java(obj);\n-     *    }\n-     *  }\n-     *\/\n-\n-    region  = new RegionNode(5);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    Node* fast_lock_region  = new RegionNode(3);\n-    Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ First, check mark word for the biased lock pattern.\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-\n-    \/\/ Get fast path - mark word has the biased lock pattern.\n-    ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern, true);\n-    \/\/ fast_lock_region->in(1) is set to slow path.\n-    fast_lock_mem_phi->init_req(1, mem);\n-\n-    \/\/ Now check that the lock is biased to the current thread and has\n-    \/\/ the same epoch and bias as Klass::_prototype_header.\n-\n-    \/\/ Special-case a fresh allocation to avoid building nodes:\n-    Node* klass_node = AllocateNode::Ideal_klass(obj, &_igvn);\n-    if (klass_node == NULL) {\n-      Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n-      klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)->is_ptr()));\n-#ifdef _LP64\n-      if (UseCompressedClassPointers && klass_node->is_DecodeNKlass()) {\n-        assert(klass_node->in(1)->Opcode() == Op_LoadNKlass, \"sanity\");\n-        klass_node->in(1)->init_req(0, ctrl);\n-      } else\n-#endif\n-      klass_node->init_req(0, ctrl);\n-    }\n-    Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X->basic_type());\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -2248,109 +2171,3 @@\n-    Node* thread = transform_later(new ThreadLocalNode());\n-    Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));\n-    Node* x_node = transform_later(new XorXNode(o_node, mark_node));\n-\n-    \/\/ Get slow path - mark word does NOT match the value.\n-    STATIC_ASSERT(markWord::age_mask_in_place <= INT_MAX);\n-    Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,\n-                                      (~(int)markWord::age_mask_in_place), 0);\n-    \/\/ region->in(3) is set to fast path - the object is biased to the current thread.\n-    mem_phi->init_req(3, mem);\n-\n-\n-    \/\/ Mark word does NOT match the value (thread | Klass::_prototype_header).\n-\n-\n-    \/\/ First, check biased pattern.\n-    \/\/ Get fast path - _prototype_header has the same biased lock pattern.\n-    ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,\n-                          markWord::biased_lock_mask_in_place, 0, true);\n-\n-    not_biased_ctrl = fast_lock_region->in(2); \/\/ Slow path\n-    \/\/ fast_lock_region->in(2) - the prototype header is no longer biased\n-    \/\/ and we have to revoke the bias on this object.\n-    \/\/ We are going to try to reset the mark of this object to the prototype\n-    \/\/ value and fall through to the CAS-based locking scheme.\n-    Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n-    Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,\n-                                          proto_node, mark_node);\n-    transform_later(cas);\n-    Node* proj = transform_later(new SCMemProjNode(cas));\n-    fast_lock_mem_phi->init_req(2, proj);\n-\n-\n-    \/\/ Second, check epoch bits.\n-    Node* rebiased_region  = new RegionNode(3);\n-    Node* old_phi = new PhiNode( rebiased_region, TypeX_X);\n-    Node* new_phi = new PhiNode( rebiased_region, TypeX_X);\n-\n-    \/\/ Get slow path - mark word does NOT match epoch bits.\n-    Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,\n-                                      markWord::epoch_mask_in_place, 0);\n-    \/\/ The epoch of the current bias is not valid, attempt to rebias the object\n-    \/\/ toward the current thread.\n-    rebiased_region->init_req(2, epoch_ctrl);\n-    old_phi->init_req(2, mark_node);\n-    new_phi->init_req(2, o_node);\n-\n-    \/\/ rebiased_region->in(1) is set to fast path.\n-    \/\/ The epoch of the current bias is still valid but we know\n-    \/\/ nothing about the owner; it might be set or it might be clear.\n-    Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |\n-                             markWord::age_mask_in_place |\n-                             markWord::epoch_mask_in_place);\n-    Node* old = transform_later(new AndXNode(mark_node, cmask));\n-    cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* new_mark = transform_later(new OrXNode(cast_thread, old));\n-    old_phi->init_req(1, old);\n-    new_phi->init_req(1, new_mark);\n-\n-    transform_later(rebiased_region);\n-    transform_later(old_phi);\n-    transform_later(new_phi);\n-\n-    \/\/ Try to acquire the bias of the object using an atomic operation.\n-    \/\/ If this fails we will go in to the runtime to revoke the object's bias.\n-    cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);\n-    transform_later(cas);\n-    proj = transform_later(new SCMemProjNode(cas));\n-\n-    \/\/ Get slow path - Failed to CAS.\n-    not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);\n-    mem_phi->init_req(4, proj);\n-    \/\/ region->in(4) is set to fast path - the object is rebiased to the current thread.\n-\n-    \/\/ Failed to CAS.\n-    slow_path  = new RegionNode(3);\n-    Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    slow_path->init_req(1, not_biased_ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(1, proj);\n-\n-    \/\/ Call CAS-based locking scheme (FastLock node).\n-\n-    transform_later(fast_lock_region);\n-    transform_later(fast_lock_mem_phi);\n-\n-    \/\/ Get slow path - FastLock failed to lock the object.\n-    ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, fast_lock_mem_phi);\n-    \/\/ region->in(2) is set to fast path - the object is locked to the current thread.\n-\n-    slow_path->init_req(2, ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(2, fast_lock_mem_phi);\n-\n-    transform_later(slow_path);\n-    transform_later(slow_mem);\n-    \/\/ Reset lock's memory edge.\n-    lock->set_req(TypeFunc::Memory, slow_mem);\n-\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ Optimize test; set region slot 2\n-    slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, mem);\n-  }\n+  \/\/ Optimize test; set region slot 2\n+  slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n+  mem_phi->init_req(2, mem);\n@@ -2406,17 +2223,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/\/ Check for biased locking unlock case, which is a no-op.\n-    \/\/ See the full description in MacroAssembler::biased_locking_exit().\n-    region  = new RegionNode(4);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-    mem_phi->init_req(3, mem);\n-\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-    ctrl = opt_bits_test(ctrl, region, 3, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern);\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-  }\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":9,"deletions":206,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2770,3 +2770,1 @@\n-    \/\/ With biased locking we're no longer guaranteed that a monitor\n-    \/\/ enter operation contains a serializing instruction.\n-    if ((xop == Op_FastLock) && !UseBiasedLocking) {\n+    if (xop == Op_FastLock) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,0 +236,4 @@\n+  \/\/ Number of integer live ranges that constitute high register pressure\n+  static uint int_pressure_limit();\n+  \/\/ Number of float live ranges that constitute high register pressure\n+  static uint float_pressure_limit();\n@@ -331,3 +335,0 @@\n-  \/\/ Some uarchs have different sized float register resources\n-  static const int float_pressure(int default_pressure_threshold);\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1837,7 +1837,0 @@\n-  AllocateNode* alloc = is_new_object_mark_load(phase);\n-  if (alloc != NULL && alloc->Opcode() == Op_Allocate && UseBiasedLocking) {\n-    InitializeNode* init = alloc->initialization();\n-    Node* control = init->proj_out(0);\n-    return alloc->make_ideal_mark(phase, address, control, mem);\n-  }\n-\n@@ -2106,1 +2099,1 @@\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n+  if (alloc != NULL) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  int bound_pres = is_float_or_vector ? FLOATPRESSURE : INTPRESSURE;\n+  int bound_pres = is_float_or_vector ? Matcher::float_pressure_limit() : Matcher::int_pressure_limit();\n@@ -803,1 +803,1 @@\n-              (b->_reg_pressure < (uint)INTPRESSURE) ||\n+              (b->_reg_pressure < Matcher::int_pressure_limit()) ||\n@@ -808,1 +808,1 @@\n-              (b->_freg_pressure < (uint)FLOATPRESSURE) ||\n+              (b->_freg_pressure < Matcher::float_pressure_limit()) ||\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1196,1 +1196,1 @@\n-  int argcnt = 6;\n+  int argcnt = 7;\n@@ -1206,0 +1206,1 @@\n+  fields[argp++] = TypeInt::BOOL;       \/\/ isMIME\n@@ -1601,6 +1602,0 @@\n-    } else if (c->tag() == NamedCounter::BiasedLockingCounter) {\n-      BiasedLockingCounters* blc = ((BiasedLockingNamedCounter*)c)->counters();\n-      if (blc->nonzero()) {\n-        tty->print_cr(\"%s\", c->name());\n-        blc->print_on(tty);\n-      }\n@@ -1657,3 +1652,1 @@\n-  if (tag == NamedCounter::BiasedLockingCounter) {\n-    c = new BiasedLockingNamedCounter(st.as_string());\n-  } else if (tag == NamedCounter::RTMLockingCounter) {\n+  if (tag == NamedCounter::RTMLockingCounter) {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -66,1 +65,0 @@\n-    BiasedLockingCounter,\n@@ -103,12 +101,0 @@\n-class BiasedLockingNamedCounter : public NamedCounter {\n- private:\n-  BiasedLockingCounters _counters;\n-\n- public:\n-  BiasedLockingNamedCounter(const char *n) :\n-    NamedCounter(n, BiasedLockingCounter), _counters() {}\n-\n-  BiasedLockingCounters* counters() { return &_counters; }\n-};\n-\n-\n@@ -173,4 +159,0 @@\n-  \/\/ Slow-path Locking and Unlocking\n-  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2697,1 +2697,1 @@\n-          if (FLOATPRESSURE > 8) {\n+          if (Matcher::float_pressure_limit() > 8) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1877,3 +1877,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorLNode\n-#define StoreXConditionalNode StoreLConditionalNode\n+\/\/ For shenandoahSupport\n@@ -1925,3 +1923,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorINode\n-#define StoreXConditionalNode StoreIConditionalNode\n+\/\/ For shenandoahSupport\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-        \"in thread \\\"%s\\\" \", thread->get_thread_name());\n+        \"in thread \\\"%s\\\" \", thread->name());\n@@ -3770,1 +3770,1 @@\n-      *(JNIEnv**)penv = t->as_Java_thread()->jni_environment();\n+      *(JNIEnv**)penv = JavaThread::cast(t)->jni_environment();\n@@ -3907,1 +3907,1 @@\n-  JavaThread* thread = current->as_Java_thread();\n+  JavaThread* thread = JavaThread::cast(current);\n@@ -3969,1 +3969,1 @@\n-      *(JNIEnv**)penv = thread->as_Java_thread()->jni_environment();\n+      *(JNIEnv**)penv = JavaThread::cast(thread)->jni_environment();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    JavaThread* thr = cur->as_Java_thread();                             \\\n+    JavaThread* thr = JavaThread::cast(cur);                             \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-    <xsl:text>JavaThread* current_thread = this_thread->as_Java_thread();<\/xsl:text>\n+    <xsl:text>JavaThread* current_thread = JavaThread::cast(this_thread);<\/xsl:text>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -973,3 +972,0 @@\n-    \/\/ Revoke any biases before querying the mark word\n-    BiasedLocking::revoke_at_safepoint(hobj);\n-\n@@ -1272,1 +1268,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1396,1 +1392,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1531,1 +1527,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1621,1 +1617,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1652,1 +1648,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1662,1 +1658,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1672,1 +1668,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1691,1 +1687,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-    JavaThread *jt = target->as_Java_thread();\n+    JavaThread *jt = JavaThread::cast(target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-    JavaThread* jt = th->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(th);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-       _jthread = thread->as_Java_thread();\n+       _jthread = JavaThread::cast(thread);\n@@ -2311,1 +2311,1 @@\n-    JvmtiThreadState *state = thread->as_Java_thread()->jvmti_thread_state();\n+    JvmtiThreadState *state = JavaThread::cast(thread)->jvmti_thread_state();\n@@ -2335,1 +2335,1 @@\n-    JvmtiThreadState *state = thread->as_Java_thread()->jvmti_thread_state();\n+    JvmtiThreadState *state = JavaThread::cast(thread)->jvmti_thread_state();\n@@ -2871,1 +2871,1 @@\n-    JavaThread* current_thread = thread->as_Java_thread();\n+    JavaThread* current_thread = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -329,1 +329,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -382,1 +382,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4071,1 +4071,1 @@\n-\/\/ Deoptimize all compiled code that depends on this class.\n+\/\/ Deoptimize all compiled code that depends on the classes redefined.\n@@ -4087,12 +4087,0 @@\n-\/\/ First step is to walk the code cache for each class redefined and mark\n-\/\/ dependent methods.  Wait until all classes are processed to deoptimize everything.\n-void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {\n-  assert_locked_or_safepoint(Compile_lock);\n-\n-  \/\/ All dependencies have been recorded from startup or this is a second or\n-  \/\/ subsequent use of RedefineClasses\n-  if (JvmtiExport::all_dependencies_are_recorded()) {\n-    CodeCache::mark_for_evol_deoptimization(ik);\n-  }\n-}\n-\n@@ -4223,3 +4211,0 @@\n-\n-  \/\/ Mark all compiled code that depends on this class\n-  mark_dependent_code(the_class);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -496,1 +496,0 @@\n-  void mark_dependent_code(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1401,4 +1400,0 @@\n-\n-  if (UseBiasedLocking) {\n-    BiasedLocking::preserve_marks();\n-  }\n@@ -1427,4 +1422,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::restore_marks();\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,1 +280,1 @@\n-  oop threadObj = thread->as_Java_thread()->threadObj();\n+  oop threadObj = JavaThread::cast(thread)->threadObj();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-    upcall_helper(thread->as_Java_thread(), rec, buff);\n+    upcall_helper(JavaThread::cast(thread), rec, buff);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/typeArrayOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"oops\/typeArrayOop.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -2020,0 +2020,46 @@\n+WB_ENTRY(jboolean, WB_HandshakeReadMonitors(JNIEnv* env, jobject wb, jobject thread_handle))\n+  class ReadMonitorsClosure : public HandshakeClosure {\n+    jboolean _executed;\n+\n+    void do_thread(Thread* th) {\n+      JavaThread* jt = JavaThread::cast(th);\n+      ResourceMark rm;\n+\n+      GrowableArray<MonitorInfo*>* info = new GrowableArray<MonitorInfo*>();\n+\n+      if (!jt->has_last_Java_frame()) {\n+        return;\n+      }\n+      RegisterMap rmap(jt);\n+      for (javaVFrame* vf = jt->last_java_vframe(&rmap); vf != NULL; vf = vf->java_sender()) {\n+        GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n+        if (monitors != NULL) {\n+          int len = monitors->length();\n+          \/\/ Walk monitors youngest to oldest\n+          for (int i = len - 1; i >= 0; i--) {\n+            MonitorInfo* mon_info = monitors->at(i);\n+            if (mon_info->eliminated()) continue;\n+            oop owner = mon_info->owner();\n+            if (owner != NULL) {\n+              info->append(mon_info);\n+            }\n+          }\n+        }\n+      }\n+      _executed = true;\n+    }\n+\n+   public:\n+    ReadMonitorsClosure() : HandshakeClosure(\"WB_HandshakeReadMonitors\"), _executed(false) {}\n+    jboolean executed() const { return _executed; }\n+  };\n+\n+  ReadMonitorsClosure rmc;\n+  oop thread_oop = JNIHandles::resolve(thread_handle);\n+  if (thread_oop != NULL) {\n+    JavaThread* target = java_lang_Thread::thread(thread_oop);\n+    Handshake::execute(&rmc, target);\n+  }\n+  return rmc.executed();\n+WB_END\n+\n@@ -2025,1 +2071,1 @@\n-      JavaThread* jt = th->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(th);\n@@ -2061,1 +2107,1 @@\n-      JavaThread* jt = th->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(th);\n@@ -2567,0 +2613,1 @@\n+  {CC\"handshakeReadMonitors\", CC\"(Ljava\/lang\/Thread;)Z\", (void*)&WB_HandshakeReadMonitors },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,3 +169,0 @@\n-  \/\/ ARCH specific policy for the BiasedLocking\n-  static bool use_biased_locking()  { return true; }\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -528,2 +528,7 @@\n-  { \"SuspendRetryCount\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"SuspendRetryDelay\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+\n+  \/\/ --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:\n+  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CreateMinidumpOnCrash\",        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n+\n+  \/\/ -------------- Obsolete Flags - sorted by expired_in --------------\n@@ -531,0 +536,2 @@\n+  { \"G1RSetRegionEntries\",          JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"G1RSetSparseRegionEntries\",    JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -540,9 +547,0 @@\n-\n-  \/\/ --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:\n-  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"CreateMinidumpOnCrash\",        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n-\n-  \/\/ -------------- Obsolete Flags - sorted by expired_in --------------\n-  { \"AssertOnSuspendWaitFailure\",   JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"TraceSuspendWaitFailures\",     JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n@@ -550,1 +548,1 @@\n-  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::undefined() },\n+  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::undefined() },\n@@ -1115,1 +1113,8 @@\n-    st->print_cr(\"java_class_path (initial): %s\", strlen(path) == 0 ? \"<not set>\" : path );\n+    size_t len = strlen(path);\n+    st->print(\"java_class_path (initial): \");\n+    \/\/ Avoid using st->print_cr() because path length maybe longer than O_BUFLEN.\n+    if (len == 0) {\n+      st->print_raw_cr(\"<not set>\");\n+    } else {\n+      st->print_raw_cr(path, (int)len);\n+    }\n@@ -3110,4 +3115,0 @@\n-    \/\/ Disable biased locking now as it interferes with the clean up of\n-    \/\/ the archived Klasses and Java string objects (at dump time only).\n-    UseBiasedLocking = false;\n-\n@@ -4027,20 +4028,0 @@\n-  \/\/ Turn off biased locking for locking debug mode flags,\n-  \/\/ which are subtly different from each other but neither works with\n-  \/\/ biased locking\n-  if (UseHeavyMonitors\n-#ifdef COMPILER1\n-      || !UseFastLocking\n-#endif \/\/ COMPILER1\n-#if INCLUDE_JVMCI\n-      || !JVMCIUseFastLocking\n-#endif\n-    ) {\n-    if (!FLAG_IS_DEFAULT(UseBiasedLocking) && UseBiasedLocking) {\n-      \/\/ flag set to true on command line; warn the user that they\n-      \/\/ can't enable biased locking here\n-      warning(\"Biased Locking is not supported with locking debug flags\"\n-              \"; ignoring UseBiasedLocking flag.\" );\n-    }\n-    UseBiasedLocking = false;\n-  }\n-\n@@ -4050,1 +4031,0 @@\n-  FLAG_SET_DEFAULT(UseBiasedLocking, false);\n@@ -4081,7 +4061,0 @@\n-  \/\/ Apply CPU specific policy for the BiasedLocking\n-  if (UseBiasedLocking) {\n-    if (!VM_Version::use_biased_locking() &&\n-        !(FLAG_IS_CMDLINE(UseBiasedLocking))) {\n-      UseBiasedLocking = false;\n-    }\n-  }\n@@ -4089,4 +4062,0 @@\n-  if (!UseBiasedLocking) {\n-    UseOptoBiasInlining = false;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":18,"deletions":49,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  memory_order_seq_cst = 5,\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,995 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"jfr\/jfrEvents.hpp\"\n-#include \"jfr\/support\/jfrThreadId.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/basicLock.hpp\"\n-#include \"runtime\/biasedLocking.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/handshake.hpp\"\n-#include \"runtime\/safepointMechanism.hpp\"\n-#include \"runtime\/task.hpp\"\n-#include \"runtime\/threadSMR.hpp\"\n-#include \"runtime\/vframe.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"runtime\/vmOperations.hpp\"\n-\n-\n-static bool _biased_locking_enabled = false;\n-BiasedLockingCounters BiasedLocking::_counters;\n-\n-static GrowableArray<Handle>*   _preserved_oop_stack  = NULL;\n-static GrowableArray<markWord>* _preserved_mark_stack = NULL;\n-\n-static void enable_biased_locking(InstanceKlass* k) {\n-  k->set_prototype_header(markWord::biased_locking_prototype());\n-}\n-\n-static void enable_biased_locking() {\n-  _biased_locking_enabled = true;\n-  log_info(biasedlocking)(\"Biased locking enabled\");\n-}\n-\n-class VM_EnableBiasedLocking: public VM_Operation {\n- public:\n-  VM_EnableBiasedLocking() {}\n-  VMOp_Type type() const          { return VMOp_EnableBiasedLocking; }\n-\n-  void doit() {\n-    \/\/ Iterate the class loader data dictionaries enabling biased locking for all\n-    \/\/ currently loaded classes.\n-    ClassLoaderDataGraph::dictionary_classes_do(enable_biased_locking);\n-    \/\/ Indicate that future instances should enable it as well\n-    enable_biased_locking();\n-  }\n-\n-  bool allow_nested_vm_operations() const        { return false; }\n-};\n-\n-\n-\/\/ One-shot PeriodicTask subclass for enabling biased locking\n-class EnableBiasedLockingTask : public PeriodicTask {\n- public:\n-  EnableBiasedLockingTask(size_t interval_time) : PeriodicTask(interval_time) {}\n-\n-  virtual void task() {\n-    VM_EnableBiasedLocking op;\n-    VMThread::execute(&op);\n-\n-    \/\/ Reclaim our storage and disenroll ourself\n-    delete this;\n-  }\n-};\n-\n-\n-void BiasedLocking::init() {\n-  \/\/ If biased locking is enabled and BiasedLockingStartupDelay is set,\n-  \/\/ schedule a task to fire after the specified delay which turns on\n-  \/\/ biased locking for all currently loaded classes as well as future\n-  \/\/ ones. This could be a workaround for startup time regressions\n-  \/\/ due to large number of safepoints being taken during VM startup for\n-  \/\/ bias revocation.\n-  if (UseBiasedLocking) {\n-    if (BiasedLockingStartupDelay > 0) {\n-      EnableBiasedLockingTask* task = new EnableBiasedLockingTask(BiasedLockingStartupDelay);\n-      task->enroll();\n-    } else {\n-      enable_biased_locking();\n-    }\n-  }\n-}\n-\n-\n-bool BiasedLocking::enabled() {\n-  assert(UseBiasedLocking, \"precondition\");\n-  \/\/ We check \"BiasedLockingStartupDelay == 0\" here to cover the\n-  \/\/ possibility of calls to BiasedLocking::enabled() before\n-  \/\/ BiasedLocking::init().\n-  return _biased_locking_enabled || BiasedLockingStartupDelay == 0;\n-}\n-\n-\n-\/\/ Returns MonitorInfos for all objects locked on this thread in youngest to oldest order\n-static GrowableArray<MonitorInfo*>* get_or_compute_monitor_info(JavaThread* thread) {\n-  GrowableArray<MonitorInfo*>* info = thread->cached_monitor_info();\n-  if (info != NULL) {\n-    return info;\n-  }\n-\n-  info = new GrowableArray<MonitorInfo*>();\n-\n-  \/\/ It's possible for the thread to not have any Java frames on it,\n-  \/\/ i.e., if it's the main thread and it's already returned from main()\n-  if (thread->has_last_Java_frame()) {\n-    RegisterMap rm(thread);\n-    for (javaVFrame* vf = thread->last_java_vframe(&rm); vf != NULL; vf = vf->java_sender()) {\n-      GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n-      if (monitors != NULL) {\n-        int len = monitors->length();\n-        \/\/ Walk monitors youngest to oldest\n-        for (int i = len - 1; i >= 0; i--) {\n-          MonitorInfo* mon_info = monitors->at(i);\n-          if (mon_info->eliminated()) continue;\n-          oop owner = mon_info->owner();\n-          if (owner != NULL) {\n-            info->append(mon_info);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  thread->set_cached_monitor_info(info);\n-  return info;\n-}\n-\n-\n-\/\/ After the call, *biased_locker will be set to obj->mark()->biased_locker() if biased_locker != NULL,\n-\/\/ AND it is a living thread. Otherwise it will not be updated, (i.e. the caller is responsible for initialization).\n-void BiasedLocking::single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be done at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-\n-  markWord mark = obj->mark();\n-  if (!mark.has_bias_pattern()) {\n-    if (log_is_enabled(Info, biasedlocking)) {\n-      ResourceMark rm;\n-      log_info(biasedlocking)(\"  (Skipping revocation of object \" INTPTR_FORMAT\n-                              \", mark \" INTPTR_FORMAT \", type %s\"\n-                              \", requesting thread \" INTPTR_FORMAT\n-                              \" because it's no longer biased)\",\n-                              p2i((void *)obj), mark.value(),\n-                              obj->klass()->external_name(),\n-                              (intptr_t) requesting_thread);\n-    }\n-    return;\n-  }\n-\n-  uint age = mark.age();\n-  markWord unbiased_prototype = markWord::prototype().set_age(age);\n-\n-  \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-  if (!is_bulk) {\n-    ResourceMark rm;\n-    log_info(biasedlocking)(\"Revoking bias of object \" INTPTR_FORMAT \", mark \"\n-                            INTPTR_FORMAT \", type %s, prototype header \" INTPTR_FORMAT\n-                            \", requesting thread \" INTPTR_FORMAT,\n-                            p2i((void *)obj),\n-                            mark.value(),\n-                            obj->klass()->external_name(),\n-                            obj->klass()->prototype_header().value(),\n-                            (intptr_t) requesting_thread);\n-  } else {\n-    ResourceMark rm;\n-    log_trace(biasedlocking)(\"Revoking bias of object \" INTPTR_FORMAT \" , mark \"\n-                             INTPTR_FORMAT \" , type %s , prototype header \" INTPTR_FORMAT\n-                             \" , requesting thread \" INTPTR_FORMAT,\n-                             p2i((void *)obj),\n-                             mark.value(),\n-                             obj->klass()->external_name(),\n-                             obj->klass()->prototype_header().value(),\n-                             (intptr_t) requesting_thread);\n-  }\n-\n-  JavaThread* biased_thread = mark.biased_locker();\n-  if (biased_thread == NULL) {\n-    \/\/ Object is anonymously biased. We can get here if, for\n-    \/\/ example, we revoke the bias due to an identity hash code\n-    \/\/ being computed for an object.\n-    obj->set_mark(unbiased_prototype);\n-\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of anonymously-biased object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of anonymously-biased object\");\n-    }\n-    return;\n-  }\n-\n-  \/\/ Handle case where the thread toward which the object was biased has exited\n-  bool thread_is_alive = false;\n-  if (requesting_thread == biased_thread) {\n-    thread_is_alive = true;\n-  } else {\n-    ThreadsListHandle tlh;\n-    thread_is_alive = tlh.includes(biased_thread);\n-  }\n-  if (!thread_is_alive) {\n-    obj->set_mark(unbiased_prototype);\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of object biased toward dead thread (\"\n-                              PTR_FORMAT \")\", p2i(biased_thread));\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of object biased toward dead thread (\"\n-                               PTR_FORMAT \")\", p2i(biased_thread));\n-    }\n-    return;\n-  }\n-\n-  \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-  if (!is_bulk) {\n-    log_info(biasedlocking)(\"  Revoked bias of object biased toward live thread (\"\n-                            PTR_FORMAT \")\", p2i(biased_thread));\n-  } else {\n-    log_trace(biasedlocking)(\"  Revoked bias of object biased toward live thread (\"\n-                               PTR_FORMAT \")\", p2i(biased_thread));\n-  }\n-\n-  \/\/ Thread owning bias is alive.\n-  \/\/ Check to see whether it currently owns the lock and, if so,\n-  \/\/ write down the needed displaced headers to the thread's stack.\n-  \/\/ Otherwise, restore the object's header either to the unlocked\n-  \/\/ or unbiased state.\n-  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_thread);\n-  BasicLock* highest_lock = NULL;\n-  for (int i = 0; i < cached_monitor_info->length(); i++) {\n-    MonitorInfo* mon_info = cached_monitor_info->at(i);\n-    if (mon_info->owner() == obj) {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") == obj (\" PTR_FORMAT \")\",\n-                               p2i((void *) mon_info->owner()),\n-                               p2i((void *) obj));\n-      \/\/ Assume recursive case and fix up highest lock below\n-      markWord mark = markWord::encode((BasicLock*) NULL);\n-      highest_lock = mon_info->lock();\n-      highest_lock->set_displaced_header(mark);\n-    } else {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") != obj (\" PTR_FORMAT \")\",\n-                               p2i((void *) mon_info->owner()),\n-                               p2i((void *) obj));\n-    }\n-  }\n-  if (highest_lock != NULL) {\n-    \/\/ Fix up highest lock to contain displaced header and point\n-    \/\/ object at it\n-    highest_lock->set_displaced_header(unbiased_prototype);\n-    \/\/ Reset object header to point to displaced mark.\n-    \/\/ Must release store the lock address for platforms without TSO\n-    \/\/ ordering (e.g. ppc).\n-    obj->release_set_mark(markWord::encode(highest_lock));\n-    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-    }\n-  } else {\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    }\n-    \/\/ Store the unlocked value into the object's header.\n-    obj->set_mark(unbiased_prototype);\n-  }\n-\n-  \/\/ If requested, return information on which thread held the bias\n-  if (biased_locker != NULL) {\n-    *biased_locker = biased_thread;\n-  }\n-}\n-\n-\n-enum HeuristicsResult {\n-  HR_NOT_BIASED    = 1,\n-  HR_SINGLE_REVOKE = 2,\n-  HR_BULK_REBIAS   = 3,\n-  HR_BULK_REVOKE   = 4\n-};\n-\n-\n-static HeuristicsResult update_heuristics(oop o) {\n-  markWord mark = o->mark();\n-  if (!mark.has_bias_pattern()) {\n-    return HR_NOT_BIASED;\n-  }\n-\n-  \/\/ Heuristics to attempt to throttle the number of revocations.\n-  \/\/ Stages:\n-  \/\/ 1. Revoke the biases of all objects in the heap of this type,\n-  \/\/    but allow rebiasing of those objects if unlocked.\n-  \/\/ 2. Revoke the biases of all objects in the heap of this type\n-  \/\/    and don't allow rebiasing of these objects. Disable\n-  \/\/    allocation of objects of that type with the bias bit set.\n-  Klass* k = o->klass();\n-  jlong cur_time = nanos_to_millis(os::javaTimeNanos());\n-  jlong last_bulk_revocation_time = k->last_biased_lock_bulk_revocation_time();\n-  int revocation_count = k->biased_lock_revocation_count();\n-  if ((revocation_count >= BiasedLockingBulkRebiasThreshold) &&\n-      (revocation_count <  BiasedLockingBulkRevokeThreshold) &&\n-      (last_bulk_revocation_time != 0) &&\n-      (cur_time - last_bulk_revocation_time >= BiasedLockingDecayTime)) {\n-    \/\/ This is the first revocation we've seen in a while of an\n-    \/\/ object of this type since the last time we performed a bulk\n-    \/\/ rebiasing operation. The application is allocating objects in\n-    \/\/ bulk which are biased toward a thread and then handing them\n-    \/\/ off to another thread. We can cope with this allocation\n-    \/\/ pattern via the bulk rebiasing mechanism so we reset the\n-    \/\/ klass's revocation count rather than allow it to increase\n-    \/\/ monotonically. If we see the need to perform another bulk\n-    \/\/ rebias operation later, we will, and if subsequently we see\n-    \/\/ many more revocation operations in a short period of time we\n-    \/\/ will completely disable biasing for this type.\n-    k->set_biased_lock_revocation_count(0);\n-    revocation_count = 0;\n-  }\n-\n-  \/\/ Make revocation count saturate just beyond BiasedLockingBulkRevokeThreshold\n-  if (revocation_count <= BiasedLockingBulkRevokeThreshold) {\n-    revocation_count = k->atomic_incr_biased_lock_revocation_count();\n-  }\n-\n-  if (revocation_count == BiasedLockingBulkRevokeThreshold) {\n-    return HR_BULK_REVOKE;\n-  }\n-\n-  if (revocation_count == BiasedLockingBulkRebiasThreshold) {\n-    return HR_BULK_REBIAS;\n-  }\n-\n-  return HR_SINGLE_REVOKE;\n-}\n-\n-\n-void BiasedLocking::bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requesting_thread) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be done at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-\n-  log_info(biasedlocking)(\"* Beginning bulk revocation (kind == %s) because of object \"\n-                          INTPTR_FORMAT \" , mark \" INTPTR_FORMAT \" , type %s\",\n-                          (bulk_rebias ? \"rebias\" : \"revoke\"),\n-                          p2i((void *) o),\n-                          o->mark().value(),\n-                          o->klass()->external_name());\n-\n-  jlong cur_time = nanos_to_millis(os::javaTimeNanos());\n-  o->klass()->set_last_biased_lock_bulk_revocation_time(cur_time);\n-\n-  Klass* k_o = o->klass();\n-  Klass* klass = k_o;\n-\n-  {\n-    JavaThreadIteratorWithHandle jtiwh;\n-\n-    if (bulk_rebias) {\n-      \/\/ Use the epoch in the klass of the object to implicitly revoke\n-      \/\/ all biases of objects of this data type and force them to be\n-      \/\/ reacquired. However, we also need to walk the stacks of all\n-      \/\/ threads and update the headers of lightweight locked objects\n-      \/\/ with biases to have the current epoch.\n-\n-      \/\/ If the prototype header doesn't have the bias pattern, don't\n-      \/\/ try to update the epoch -- assume another VM operation came in\n-      \/\/ and reset the header to the unbiased state, which will\n-      \/\/ implicitly cause all existing biases to be revoked\n-      if (klass->prototype_header().has_bias_pattern()) {\n-        int prev_epoch = klass->prototype_header().bias_epoch();\n-        klass->set_prototype_header(klass->prototype_header().incr_bias_epoch());\n-        int cur_epoch = klass->prototype_header().bias_epoch();\n-\n-        \/\/ Now walk all threads' stacks and adjust epochs of any biased\n-        \/\/ and locked objects of this data type we encounter\n-        for (; JavaThread *thr = jtiwh.next(); ) {\n-          GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);\n-          for (int i = 0; i < cached_monitor_info->length(); i++) {\n-            MonitorInfo* mon_info = cached_monitor_info->at(i);\n-            oop owner = mon_info->owner();\n-            markWord mark = owner->mark();\n-            if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n-              \/\/ We might have encountered this object already in the case of recursive locking\n-              assert(mark.bias_epoch() == prev_epoch || mark.bias_epoch() == cur_epoch, \"error in bias epoch adjustment\");\n-              owner->set_mark(mark.set_bias_epoch(cur_epoch));\n-            }\n-          }\n-        }\n-      }\n-\n-      \/\/ At this point we're done. All we have to do is potentially\n-      \/\/ adjust the header of the given object to revoke its bias.\n-      single_revoke_at_safepoint(o, true, requesting_thread, NULL);\n-    } else {\n-      if (log_is_enabled(Info, biasedlocking)) {\n-        ResourceMark rm;\n-        log_info(biasedlocking)(\"* Disabling biased locking for type %s\", klass->external_name());\n-      }\n-\n-      \/\/ Disable biased locking for this data type. Not only will this\n-      \/\/ cause future instances to not be biased, but existing biased\n-      \/\/ instances will notice that this implicitly caused their biases\n-      \/\/ to be revoked.\n-      klass->set_prototype_header(markWord::prototype());\n-\n-      \/\/ Now walk all threads' stacks and forcibly revoke the biases of\n-      \/\/ any locked and biased objects of this data type we encounter.\n-      for (; JavaThread *thr = jtiwh.next(); ) {\n-        GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);\n-        for (int i = 0; i < cached_monitor_info->length(); i++) {\n-          MonitorInfo* mon_info = cached_monitor_info->at(i);\n-          oop owner = mon_info->owner();\n-          markWord mark = owner->mark();\n-          if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n-            single_revoke_at_safepoint(owner, true, requesting_thread, NULL);\n-          }\n-        }\n-      }\n-\n-      \/\/ Must force the bias of the passed object to be forcibly revoked\n-      \/\/ as well to ensure guarantees to callers\n-      single_revoke_at_safepoint(o, true, requesting_thread, NULL);\n-    }\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n-  log_info(biasedlocking)(\"* Ending bulk revocation\");\n-\n-  assert(!o->mark().has_bias_pattern(), \"bug in bulk bias revocation\");\n-}\n-\n-\n-static void clean_up_cached_monitor_info(JavaThread* thread = NULL) {\n-  if (thread != NULL) {\n-    thread->set_cached_monitor_info(NULL);\n-  } else {\n-    \/\/ Walk the thread list clearing out the cached monitors\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {\n-      thr->set_cached_monitor_info(NULL);\n-    }\n-  }\n-}\n-\n-\n-class VM_BulkRevokeBias : public VM_Operation {\n-private:\n-  Handle* _obj;\n-  JavaThread* _requesting_thread;\n-  bool _bulk_rebias;\n-  uint64_t _safepoint_id;\n-\n-public:\n-  VM_BulkRevokeBias(Handle* obj, JavaThread* requesting_thread,\n-                    bool bulk_rebias)\n-    : _obj(obj)\n-    , _requesting_thread(requesting_thread)\n-    , _bulk_rebias(bulk_rebias)\n-    , _safepoint_id(0) {}\n-\n-  virtual VMOp_Type type() const { return VMOp_BulkRevokeBias; }\n-\n-  virtual void doit() {\n-    BiasedLocking::bulk_revoke_at_safepoint((*_obj)(), _bulk_rebias, _requesting_thread);\n-    _safepoint_id = SafepointSynchronize::safepoint_id();\n-    clean_up_cached_monitor_info();\n-  }\n-\n-  bool is_bulk_rebias() const {\n-    return _bulk_rebias;\n-  }\n-\n-  uint64_t safepoint_id() const {\n-    return _safepoint_id;\n-  }\n-};\n-\n-\n-class RevokeOneBias : public HandshakeClosure {\n-protected:\n-  Handle _obj;\n-  JavaThread* _requesting_thread;\n-  JavaThread* _biased_locker;\n-  BiasedLocking::Condition _status_code;\n-  traceid _biased_locker_id;\n-  bool _executed;\n-\n-public:\n-  RevokeOneBias(Handle obj, JavaThread* requesting_thread, JavaThread* biased_locker)\n-    : HandshakeClosure(\"RevokeOneBias\")\n-    , _obj(obj)\n-    , _requesting_thread(requesting_thread)\n-    , _biased_locker(biased_locker)\n-    , _status_code(BiasedLocking::NOT_BIASED)\n-    , _biased_locker_id(0)\n-    , _executed(false) {}\n-\n-  bool executed() { return _executed; }\n-\n-  void do_thread(Thread* target) {\n-    assert(target == _biased_locker, \"Wrong thread\");\n-    _executed = true;\n-\n-    oop o = _obj();\n-    markWord mark = o->mark();\n-\n-    if (!mark.has_bias_pattern()) {\n-      return;\n-    }\n-\n-    markWord prototype = o->klass()->prototype_header();\n-    if (!prototype.has_bias_pattern()) {\n-      \/\/ This object has a stale bias from before the handshake\n-      \/\/ was requested. If we fail this race, the object's bias\n-      \/\/ has been revoked by another thread so we simply return.\n-      markWord biased_value = mark;\n-      mark = o->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-      assert(!o->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n-      if (biased_value == mark) {\n-        _status_code = BiasedLocking::BIAS_REVOKED;\n-      }\n-      return;\n-    }\n-\n-    if (_biased_locker == mark.biased_locker()) {\n-      if (mark.bias_epoch() == prototype.bias_epoch()) {\n-        \/\/ Epoch is still valid. This means biaser could be currently\n-        \/\/ synchronized on this object. We must walk its stack looking\n-        \/\/ for monitor records associated with this object and change\n-        \/\/ them to be stack locks if any are found.\n-        ResourceMark rm;\n-        BiasedLocking::walk_stack_and_revoke(o, _biased_locker);\n-        _biased_locker->set_cached_monitor_info(NULL);\n-        assert(!o->mark().has_bias_pattern(), \"invariant\");\n-        _biased_locker_id = JFR_THREAD_ID(_biased_locker);\n-        _status_code = BiasedLocking::BIAS_REVOKED;\n-        return;\n-      } else {\n-        markWord biased_value = mark;\n-        mark = o->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-        if (mark == biased_value || !mark.has_bias_pattern()) {\n-          assert(!o->mark().has_bias_pattern(), \"should be revoked\");\n-          _status_code = (biased_value == mark) ? BiasedLocking::BIAS_REVOKED : BiasedLocking::NOT_BIASED;\n-          return;\n-        }\n-      }\n-    }\n-\n-    _status_code = BiasedLocking::NOT_REVOKED;\n-  }\n-\n-  BiasedLocking::Condition status_code() const {\n-    return _status_code;\n-  }\n-\n-  traceid biased_locker() const {\n-    return _biased_locker_id;\n-  }\n-};\n-\n-\n-static void post_self_revocation_event(EventBiasedLockSelfRevocation* event, Klass* k) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_lockClass(k);\n-  event->commit();\n-}\n-\n-static void post_revocation_event(EventBiasedLockRevocation* event, Klass* k, RevokeOneBias* op) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_lockClass(k);\n-  event->set_safepointId(0);\n-  event->set_previousOwner(op->biased_locker());\n-  event->commit();\n-}\n-\n-static void post_class_revocation_event(EventBiasedLockClassRevocation* event, Klass* k, VM_BulkRevokeBias* op) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_revokedClass(k);\n-  event->set_disableBiasing(!op->is_bulk_rebias());\n-  event->set_safepointId(op->safepoint_id());\n-  event->commit();\n-}\n-\n-\n-BiasedLocking::Condition BiasedLocking::single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser) {\n-\n-  EventBiasedLockRevocation event;\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(handshakes_count_addr());\n-  }\n-  log_info(biasedlocking, handshake)(\"JavaThread \" INTPTR_FORMAT \" handshaking JavaThread \"\n-                                     INTPTR_FORMAT \" to revoke object \" INTPTR_FORMAT, p2i(requester),\n-                                     p2i(biaser), p2i(obj()));\n-\n-  RevokeOneBias revoke(obj, requester, biaser);\n-  Handshake::execute(&revoke, biaser);\n-  if (revoke.status_code() == NOT_REVOKED) {\n-    return NOT_REVOKED;\n-  }\n-  if (revoke.executed()) {\n-    log_info(biasedlocking, handshake)(\"Handshake revocation for object \" INTPTR_FORMAT \" succeeded. Bias was %srevoked\",\n-                                       p2i(obj()), (revoke.status_code() == BIAS_REVOKED ? \"\" : \"already \"));\n-    if (event.should_commit() && revoke.status_code() == BIAS_REVOKED) {\n-      post_revocation_event(&event, obj->klass(), &revoke);\n-    }\n-    assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-    return revoke.status_code();\n-  } else {\n-    \/\/ Thread was not alive.\n-    \/\/ Grab Threads_lock before manually trying to revoke bias. This avoids race with a newly\n-    \/\/ created JavaThread (that happens to get the same memory address as biaser) synchronizing\n-    \/\/ on this object.\n-    {\n-      MutexLocker ml(Threads_lock);\n-      markWord mark = obj->mark();\n-      \/\/ Check if somebody else was able to revoke it before biased thread exited.\n-      if (!mark.has_bias_pattern()) {\n-        return NOT_BIASED;\n-      }\n-      ThreadsListHandle tlh;\n-      markWord prototype = obj->klass()->prototype_header();\n-      if (!prototype.has_bias_pattern() || (!tlh.includes(biaser) && biaser == mark.biased_locker() &&\n-                                            prototype.bias_epoch() == mark.bias_epoch())) {\n-        obj->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-        if (event.should_commit()) {\n-          post_revocation_event(&event, obj->klass(), &revoke);\n-        }\n-        assert(!obj->mark().has_bias_pattern(), \"bias should be revoked by now\");\n-        return BIAS_REVOKED;\n-      }\n-    }\n-  }\n-\n-  return NOT_REVOKED;\n-}\n-\n-\n-\/\/ Caller should have instantiated a ResourceMark object before calling this method\n-void BiasedLocking::walk_stack_and_revoke(oop obj, JavaThread* biased_locker) {\n-  Thread* cur = Thread::current();\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"this should always be executed outside safepoints\");\n-  assert(biased_locker->is_handshake_safe_for(cur), \"wrong thread\");\n-\n-  markWord mark = obj->mark();\n-  assert(mark.biased_locker() == biased_locker &&\n-         obj->klass()->prototype_header().bias_epoch() == mark.bias_epoch(), \"invariant\");\n-\n-  log_trace(biasedlocking)(\"JavaThread(\" INTPTR_FORMAT \") revoking object \" INTPTR_FORMAT \", mark \"\n-                           INTPTR_FORMAT \", type %s, prototype header \" INTPTR_FORMAT\n-                           \", biaser \" INTPTR_FORMAT \" %s\",\n-                           p2i(cur),\n-                           p2i(obj),\n-                           mark.value(),\n-                           obj->klass()->external_name(),\n-                           obj->klass()->prototype_header().value(),\n-                           p2i(biased_locker),\n-                           cur != biased_locker ? \"\" : \"(walking own stack)\");\n-\n-  markWord unbiased_prototype = markWord::prototype().set_age(obj->mark().age());\n-\n-  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_locker);\n-  BasicLock* highest_lock = NULL;\n-  for (int i = 0; i < cached_monitor_info->length(); i++) {\n-    MonitorInfo* mon_info = cached_monitor_info->at(i);\n-    if (mon_info->owner() == obj) {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") == obj (\" PTR_FORMAT \")\",\n-                               p2i(mon_info->owner()),\n-                               p2i(obj));\n-      \/\/ Assume recursive case and fix up highest lock below\n-      markWord mark = markWord::encode((BasicLock*) NULL);\n-      highest_lock = mon_info->lock();\n-      highest_lock->set_displaced_header(mark);\n-    } else {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") != obj (\" PTR_FORMAT \")\",\n-                               p2i(mon_info->owner()),\n-                               p2i(obj));\n-    }\n-  }\n-  if (highest_lock != NULL) {\n-    \/\/ Fix up highest lock to contain displaced header and point\n-    \/\/ object at it\n-    highest_lock->set_displaced_header(unbiased_prototype);\n-    \/\/ Reset object header to point to displaced mark.\n-    \/\/ Must release store the lock address for platforms without TSO\n-    \/\/ ordering (e.g. ppc).\n-    obj->release_set_mark(markWord::encode(highest_lock));\n-    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n-    log_info(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-  } else {\n-    log_info(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    \/\/ Store the unlocked value into the object's header.\n-    obj->set_mark(unbiased_prototype);\n-  }\n-\n-  assert(!obj->mark().has_bias_pattern(), \"must not be biased\");\n-}\n-\n-void BiasedLocking::revoke_own_lock(JavaThread* current, Handle obj) {\n-  markWord mark = obj->mark();\n-\n-  if (!mark.has_bias_pattern()) {\n-    return;\n-  }\n-\n-  Klass *k = obj->klass();\n-  assert(mark.biased_locker() == current &&\n-         k->prototype_header().bias_epoch() == mark.bias_epoch(), \"Revoke failed, unhandled biased lock state\");\n-  ResourceMark rm(current);\n-  log_info(biasedlocking)(\"Revoking bias by walking my own stack:\");\n-  EventBiasedLockSelfRevocation event;\n-  BiasedLocking::walk_stack_and_revoke(obj(), current);\n-  current->set_cached_monitor_info(NULL);\n-  assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-  if (event.should_commit()) {\n-    post_self_revocation_event(&event, k);\n-  }\n-}\n-\n-void BiasedLocking::revoke(JavaThread* current, Handle obj) {\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"must not be called while at safepoint\");\n-\n-  while (true) {\n-    \/\/ We can revoke the biases of anonymously-biased objects\n-    \/\/ efficiently enough that we should not cause these revocations to\n-    \/\/ update the heuristics because doing so may cause unwanted bulk\n-    \/\/ revocations (which are expensive) to occur.\n-    markWord mark = obj->mark();\n-\n-    if (!mark.has_bias_pattern()) {\n-      return;\n-    }\n-\n-    if (mark.is_biased_anonymously()) {\n-      \/\/ We are probably trying to revoke the bias of this object due to\n-      \/\/ an identity hash code computation. Try to revoke the bias\n-      \/\/ without a safepoint. This is possible if we can successfully\n-      \/\/ compare-and-exchange an unbiased header into the mark word of\n-      \/\/ the object, meaning that no other thread has raced to acquire\n-      \/\/ the bias of the object.\n-      markWord biased_value       = mark;\n-      markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-      markWord res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n-      if (res_mark == biased_value) {\n-        return;\n-      }\n-      mark = res_mark;  \/\/ Refresh mark with the latest value.\n-    } else {\n-      Klass* k = obj->klass();\n-      markWord prototype_header = k->prototype_header();\n-      if (!prototype_header.has_bias_pattern()) {\n-        \/\/ This object has a stale bias from before the bulk revocation\n-        \/\/ for this data type occurred. It's pointless to update the\n-        \/\/ heuristics at this point so simply update the header with a\n-        \/\/ CAS. If we fail this race, the object's bias has been revoked\n-        \/\/ by another thread so we simply return and let the caller deal\n-        \/\/ with it.\n-        obj->cas_set_mark(prototype_header.set_age(mark.age()), mark);\n-        assert(!obj->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n-        return;\n-      } else if (prototype_header.bias_epoch() != mark.bias_epoch()) {\n-        \/\/ The epoch of this biasing has expired indicating that the\n-        \/\/ object is effectively unbiased. We can revoke the bias of this\n-        \/\/ object efficiently enough with a CAS that we shouldn't update the\n-        \/\/ heuristics. This is normally done in the assembly code but we\n-        \/\/ can reach this point due to various points in the runtime\n-        \/\/ needing to revoke biases.\n-        markWord res_mark;\n-        markWord biased_value       = mark;\n-        markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-        res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n-        if (res_mark == biased_value) {\n-          return;\n-        }\n-        mark = res_mark;  \/\/ Refresh mark with the latest value.\n-      }\n-    }\n-\n-    HeuristicsResult heuristics = update_heuristics(obj());\n-    if (heuristics == HR_NOT_BIASED) {\n-      return;\n-    } else if (heuristics == HR_SINGLE_REVOKE) {\n-      JavaThread *blt = mark.biased_locker();\n-      assert(blt != NULL, \"invariant\");\n-      if (blt == current) {\n-        \/\/ A thread is trying to revoke the bias of an object biased\n-        \/\/ toward it, again likely due to an identity hash code\n-        \/\/ computation. We can again avoid a safepoint\/handshake in this case\n-        \/\/ since we are only going to walk our own stack. There are no\n-        \/\/ races with revocations occurring in other threads because we\n-        \/\/ reach no safepoints in the revocation path.\n-        EventBiasedLockSelfRevocation event;\n-        ResourceMark rm(current);\n-        walk_stack_and_revoke(obj(), blt);\n-        blt->set_cached_monitor_info(NULL);\n-        assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-        if (event.should_commit()) {\n-          post_self_revocation_event(&event, obj->klass());\n-        }\n-        return;\n-      } else {\n-        BiasedLocking::Condition cond = single_revoke_with_handshake(obj, current, blt);\n-        if (cond != NOT_REVOKED) {\n-          return;\n-        }\n-      }\n-    } else {\n-      assert((heuristics == HR_BULK_REVOKE) ||\n-         (heuristics == HR_BULK_REBIAS), \"?\");\n-      EventBiasedLockClassRevocation event;\n-      VM_BulkRevokeBias bulk_revoke(&obj, current, (heuristics == HR_BULK_REBIAS));\n-      VMThread::execute(&bulk_revoke);\n-      if (event.should_commit()) {\n-        post_class_revocation_event(&event, obj->klass(), &bulk_revoke);\n-      }\n-      return;\n-    }\n-  }\n-}\n-\n-\/\/ All objects in objs should be locked by biaser\n-void BiasedLocking::revoke(GrowableArray<Handle>* objs, JavaThread *biaser) {\n-  bool clean_my_cache = false;\n-  for (int i = 0; i < objs->length(); i++) {\n-    oop obj = (objs->at(i))();\n-    markWord mark = obj->mark();\n-    if (mark.has_bias_pattern()) {\n-      walk_stack_and_revoke(obj, biaser);\n-      clean_my_cache = true;\n-    }\n-  }\n-  if (clean_my_cache) {\n-    clean_up_cached_monitor_info(biaser);\n-  }\n-}\n-\n-\n-void BiasedLocking::revoke_at_safepoint(Handle h_obj) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called while at safepoint\");\n-  oop obj = h_obj();\n-  HeuristicsResult heuristics = update_heuristics(obj);\n-  if (heuristics == HR_SINGLE_REVOKE) {\n-    JavaThread* biased_locker = NULL;\n-    single_revoke_at_safepoint(obj, false, NULL, &biased_locker);\n-    if (biased_locker) {\n-      clean_up_cached_monitor_info(biased_locker);\n-    }\n-  } else if ((heuristics == HR_BULK_REBIAS) ||\n-             (heuristics == HR_BULK_REVOKE)) {\n-    bulk_revoke_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), NULL);\n-    clean_up_cached_monitor_info();\n-  }\n-}\n-\n-\n-void BiasedLocking::preserve_marks() {\n-  if (!UseBiasedLocking)\n-    return;\n-\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called while at safepoint\");\n-\n-  assert(_preserved_oop_stack  == NULL, \"double initialization\");\n-  assert(_preserved_mark_stack == NULL, \"double initialization\");\n-\n-  \/\/ In order to reduce the number of mark words preserved during GC\n-  \/\/ due to the presence of biased locking, we reinitialize most mark\n-  \/\/ words to the class's prototype during GC -- even those which have\n-  \/\/ a currently valid bias owner. One important situation where we\n-  \/\/ must not clobber a bias is when a biased object is currently\n-  \/\/ locked. To handle this case we iterate over the currently-locked\n-  \/\/ monitors in a prepass and, if they are biased, preserve their\n-  \/\/ mark words here. This should be a relatively small set of objects\n-  \/\/ especially compared to the number of objects in the heap.\n-  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<markWord>(10, mtGC);\n-  _preserved_oop_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<Handle>(10, mtGC);\n-\n-  Thread* cur = Thread::current();\n-  ResourceMark rm(cur);\n-\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    if (thread->has_last_Java_frame()) {\n-      RegisterMap rm(thread);\n-      for (javaVFrame* vf = thread->last_java_vframe(&rm); vf != NULL; vf = vf->java_sender()) {\n-        GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n-        if (monitors != NULL) {\n-          int len = monitors->length();\n-          \/\/ Walk monitors youngest to oldest\n-          for (int i = len - 1; i >= 0; i--) {\n-            MonitorInfo* mon_info = monitors->at(i);\n-            if (mon_info->owner_is_scalar_replaced()) continue;\n-            oop owner = mon_info->owner();\n-            if (owner != NULL) {\n-              markWord mark = owner->mark();\n-              if (mark.has_bias_pattern()) {\n-                _preserved_oop_stack->push(Handle(cur, owner));\n-                _preserved_mark_stack->push(mark);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-\n-void BiasedLocking::restore_marks() {\n-  if (!UseBiasedLocking)\n-    return;\n-\n-  assert(_preserved_oop_stack  != NULL, \"double free\");\n-  assert(_preserved_mark_stack != NULL, \"double free\");\n-\n-  int len = _preserved_oop_stack->length();\n-  for (int i = 0; i < len; i++) {\n-    Handle owner = _preserved_oop_stack->at(i);\n-    markWord mark = _preserved_mark_stack->at(i);\n-    owner->set_mark(mark);\n-  }\n-\n-  delete _preserved_oop_stack;\n-  _preserved_oop_stack = NULL;\n-  delete _preserved_mark_stack;\n-  _preserved_mark_stack = NULL;\n-}\n-\n-\n-int* BiasedLocking::total_entry_count_addr()                   { return _counters.total_entry_count_addr(); }\n-int* BiasedLocking::biased_lock_entry_count_addr()             { return _counters.biased_lock_entry_count_addr(); }\n-int* BiasedLocking::anonymously_biased_lock_entry_count_addr() { return _counters.anonymously_biased_lock_entry_count_addr(); }\n-int* BiasedLocking::rebiased_lock_entry_count_addr()           { return _counters.rebiased_lock_entry_count_addr(); }\n-int* BiasedLocking::revoked_lock_entry_count_addr()            { return _counters.revoked_lock_entry_count_addr(); }\n-int* BiasedLocking::handshakes_count_addr()                    { return _counters.handshakes_count_addr(); }\n-int* BiasedLocking::fast_path_entry_count_addr()               { return _counters.fast_path_entry_count_addr(); }\n-int* BiasedLocking::slow_path_entry_count_addr()               { return _counters.slow_path_entry_count_addr(); }\n-\n-\n-\/\/ BiasedLockingCounters\n-\n-int BiasedLockingCounters::slow_path_entry_count() const {\n-  if (_slow_path_entry_count != 0) {\n-    return _slow_path_entry_count;\n-  }\n-  int sum = _biased_lock_entry_count   + _anonymously_biased_lock_entry_count +\n-            _rebiased_lock_entry_count + _revoked_lock_entry_count +\n-            _fast_path_entry_count;\n-\n-  return _total_entry_count - sum;\n-}\n-\n-void BiasedLockingCounters::print_on(outputStream* st) const {\n-  tty->print_cr(\"# total entries: %d\", _total_entry_count);\n-  tty->print_cr(\"# biased lock entries: %d\", _biased_lock_entry_count);\n-  tty->print_cr(\"# anonymously biased lock entries: %d\", _anonymously_biased_lock_entry_count);\n-  tty->print_cr(\"# rebiased lock entries: %d\", _rebiased_lock_entry_count);\n-  tty->print_cr(\"# revoked lock entries: %d\", _revoked_lock_entry_count);\n-  tty->print_cr(\"# handshakes entries: %d\", _handshakes_count);\n-  tty->print_cr(\"# fast path lock entries: %d\", _fast_path_entry_count);\n-  tty->print_cr(\"# slow path lock entries: %d\", slow_path_entry_count());\n-}\n-\n-void BiasedLockingCounters::print() const { print_on(tty); }\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":0,"deletions":995,"binary":false,"changes":995,"status":"deleted"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_BIASEDLOCKING_HPP\n-#define SHARE_RUNTIME_BIASEDLOCKING_HPP\n-\n-#include \"runtime\/handles.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-\/\/ This class describes operations to implement Store-Free Biased\n-\/\/ Locking. The high-level properties of the scheme are similar to\n-\/\/ IBM's lock reservation, Dice-Moir-Scherer QR locks, and other biased\n-\/\/ locking mechanisms. The principal difference is in the handling of\n-\/\/ recursive locking which is how this technique achieves a more\n-\/\/ efficient fast path than these other schemes.\n-\/\/\n-\/\/ The basic observation is that in HotSpot's current fast locking\n-\/\/ scheme, recursive locking (in the fast path) causes no update to\n-\/\/ the object header. The recursion is described simply by stack\n-\/\/ records containing a specific value (NULL). Only the last unlock by\n-\/\/ a given thread causes an update to the object header.\n-\/\/\n-\/\/ This observation, coupled with the fact that HotSpot only compiles\n-\/\/ methods for which monitor matching is obeyed (and which therefore\n-\/\/ can not throw IllegalMonitorStateException), implies that we can\n-\/\/ completely eliminate modifications to the object header for\n-\/\/ recursive locking in compiled code, and perform similar recursion\n-\/\/ checks and throwing of IllegalMonitorStateException in the\n-\/\/ interpreter with little or no impact on the performance of the fast\n-\/\/ path.\n-\/\/\n-\/\/ The basic algorithm is as follows (note, see below for more details\n-\/\/ and information). A pattern in the low three bits is reserved in\n-\/\/ the object header to indicate whether biasing of a given object's\n-\/\/ lock is currently being done or is allowed at all.  If the bias\n-\/\/ pattern is present, the contents of the rest of the header are\n-\/\/ either the JavaThread* of the thread to which the lock is biased,\n-\/\/ or NULL, indicating that the lock is \"anonymously biased\". The\n-\/\/ first thread which locks an anonymously biased object biases the\n-\/\/ lock toward that thread. If another thread subsequently attempts to\n-\/\/ lock the same object, the bias is revoked.\n-\/\/\n-\/\/ Because there are no updates to the object header at all during\n-\/\/ recursive locking while the lock is biased, the biased lock entry\n-\/\/ code is simply a test of the object header's value. If this test\n-\/\/ succeeds, the lock has been acquired by the thread. If this test\n-\/\/ fails, a bit test is done to see whether the bias bit is still\n-\/\/ set. If not, we fall back to HotSpot's original CAS-based locking\n-\/\/ scheme. If it is set, we attempt to CAS in a bias toward this\n-\/\/ thread. The latter operation is expected to be the rarest operation\n-\/\/ performed on these locks. We optimistically expect the biased lock\n-\/\/ entry to hit most of the time, and want the CAS-based fallthrough\n-\/\/ to occur quickly in the situations where the bias has been revoked.\n-\/\/\n-\/\/ Revocation of the lock's bias is fairly straightforward. We want to\n-\/\/ restore the object's header and stack-based BasicObjectLocks and\n-\/\/ BasicLocks to the state they would have been in had the object been\n-\/\/ locked by HotSpot's usual fast locking scheme. To do this, we execute\n-\/\/ a handshake with the JavaThread that biased the lock. Inside the\n-\/\/ handshake we walk the biaser stack searching for all of the lock\n-\/\/ records corresponding to this object, in particular the first \/ \"highest\"\n-\/\/ record. We fill in the highest lock record with the object's displaced\n-\/\/ header (which is a well-known value given that we don't maintain an\n-\/\/ identity hash nor age bits for the object while it's in the biased\n-\/\/ state) and all other lock records with 0, the value for recursive locks.\n-\/\/ Alternatively, we can revoke the bias of an object inside a safepoint\n-\/\/ if we are already in one and we detect that we need to perform a\n-\/\/ revocation.\n-\/\/\n-\/\/ This scheme can not handle transfers of biases of single objects\n-\/\/ from thread to thread efficiently, but it can handle bulk transfers\n-\/\/ of such biases, which is a usage pattern showing up in some\n-\/\/ applications and benchmarks. We implement \"bulk rebias\" and \"bulk\n-\/\/ revoke\" operations using a \"bias epoch\" on a per-data-type basis.\n-\/\/ If too many bias revocations are occurring for a particular data\n-\/\/ type, the bias epoch for the data type is incremented at a\n-\/\/ safepoint, effectively meaning that all previous biases are\n-\/\/ invalid. The fast path locking case checks for an invalid epoch in\n-\/\/ the object header and attempts to rebias the object with a CAS if\n-\/\/ found, avoiding safepoints or bulk heap sweeps (the latter which\n-\/\/ was used in a prior version of this algorithm and did not scale\n-\/\/ well). If too many bias revocations persist, biasing is completely\n-\/\/ disabled for the data type by resetting the prototype header to the\n-\/\/ unbiased markWord. The fast-path locking code checks to see whether\n-\/\/ the instance's bias pattern differs from the prototype header's and\n-\/\/ causes the bias to be revoked without reaching a safepoint or,\n-\/\/ again, a bulk heap sweep.\n-\n-\/\/ Biased locking counters\n-class BiasedLockingCounters {\n- private:\n-  int _total_entry_count;\n-  int _biased_lock_entry_count;\n-  int _anonymously_biased_lock_entry_count;\n-  int _rebiased_lock_entry_count;\n-  int _revoked_lock_entry_count;\n-  int _handshakes_count;\n-  int _fast_path_entry_count;\n-  int _slow_path_entry_count;\n-\n- public:\n-  BiasedLockingCounters() :\n-    _total_entry_count(0),\n-    _biased_lock_entry_count(0),\n-    _anonymously_biased_lock_entry_count(0),\n-    _rebiased_lock_entry_count(0),\n-    _revoked_lock_entry_count(0),\n-    _handshakes_count(0),\n-    _fast_path_entry_count(0),\n-    _slow_path_entry_count(0) {}\n-\n-  int slow_path_entry_count() const; \/\/ Compute this field if necessary\n-\n-  int* total_entry_count_addr()                   { return &_total_entry_count; }\n-  int* biased_lock_entry_count_addr()             { return &_biased_lock_entry_count; }\n-  int* anonymously_biased_lock_entry_count_addr() { return &_anonymously_biased_lock_entry_count; }\n-  int* rebiased_lock_entry_count_addr()           { return &_rebiased_lock_entry_count; }\n-  int* revoked_lock_entry_count_addr()            { return &_revoked_lock_entry_count; }\n-  int* handshakes_count_addr()                    { return &_handshakes_count; }\n-  int* fast_path_entry_count_addr()               { return &_fast_path_entry_count; }\n-  int* slow_path_entry_count_addr()               { return &_slow_path_entry_count; }\n-\n-  bool nonzero() { return _total_entry_count > 0; }\n-\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-};\n-\n-\n-class BiasedLocking : AllStatic {\n-friend class VM_BulkRevokeBias;\n-friend class RevokeOneBias;\n-\n-private:\n-  static BiasedLockingCounters _counters;\n-\n-public:\n-  static int* total_entry_count_addr();\n-  static int* biased_lock_entry_count_addr();\n-  static int* anonymously_biased_lock_entry_count_addr();\n-  static int* rebiased_lock_entry_count_addr();\n-  static int* revoked_lock_entry_count_addr();\n-  static int* handshakes_count_addr();\n-  static int* fast_path_entry_count_addr();\n-  static int* slow_path_entry_count_addr();\n-\n-  enum Condition {\n-    NOT_BIASED = 1,\n-    BIAS_REVOKED = 2,\n-    NOT_REVOKED = 3\n-  };\n-\n-private:\n-  static void single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requester, JavaThread** biaser);\n-  static void bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requester);\n-  static Condition single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser);\n-  static void walk_stack_and_revoke(oop obj, JavaThread* biased_locker);\n-\n-public:\n-  \/\/ This initialization routine should only be called once and\n-  \/\/ schedules a PeriodicTask to turn on biased locking a few seconds\n-  \/\/ into the VM run to avoid startup time regressions\n-  static void init();\n-\n-  \/\/ This provides a global switch for leaving biased locking disabled\n-  \/\/ for the first part of a run and enabling it later\n-  static bool enabled();\n-\n-  \/\/ This should be called by JavaThreads to revoke the bias of an object\n-  static void revoke(JavaThread* current, Handle obj);\n-\n-  \/\/ This must only be called by a JavaThread to revoke the bias of an owned object.\n-  static void revoke_own_lock(JavaThread* current, Handle obj);\n-\n-  static void revoke_at_safepoint(Handle obj);\n-\n-  \/\/ These are used by deoptimization to ensure that monitors on the stack\n-  \/\/ can be migrated\n-  static void revoke(GrowableArray<Handle>* objs, JavaThread *biaser);\n-\n-  static void print_counters() { _counters.print(); }\n-  static BiasedLockingCounters* counters() { return &_counters; }\n-\n-  \/\/ These routines are GC-related and should not be called by end\n-  \/\/ users. GCs which do not do preservation of mark words do not need\n-  \/\/ to call these routines.\n-  static void preserve_marks();\n-  static void restore_marks();\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_BIASEDLOCKING_HPP\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.hpp","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -314,3 +313,0 @@\n-  \/\/ Revoke biases of objects with eliminated locks in the given frame.\n-  Deoptimization::revoke_for_object_deoptimization(deoptee_thread, deoptee, &map, thread);\n-\n@@ -386,4 +382,0 @@\n-  \/\/ Revoke biases, done with in java state.\n-  \/\/ No safepoints allowed after this\n-  revoke_from_deopt_handler(current, deoptee, &map);\n-\n@@ -872,1 +864,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n@@ -1445,10 +1437,1 @@\n-        if (UseBiasedLocking && mark.has_bias_pattern()) {\n-          \/\/ New allocated objects may have the mark set to anonymously biased.\n-          \/\/ Also the deoptimized method may called methods with synchronization\n-          \/\/ where the thread-local object is bias locked to the current thread.\n-          assert(mark.is_biased_anonymously() ||\n-                 mark.biased_locker() == deoptee_thread, \"should be locked to current thread\");\n-          \/\/ Reset mark word to unbiased prototype.\n-          markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-          obj->set_mark(unbiased_prototype);\n-        } else if (exec_mode == Unpack_none) {\n+        if (exec_mode == Unpack_none) {\n@@ -1457,2 +1440,1 @@\n-            \/\/ a callee frame. In this case the bias was revoked before in revoke_for_object_deoptimization().\n-            \/\/ Make the lock in the callee a recursive lock and restore the displaced header.\n+            \/\/ a callee frame. Make the lock in the callee a recursive lock and restore the displaced header.\n@@ -1598,92 +1580,0 @@\n-static void collect_monitors(compiledVFrame* cvf, GrowableArray<Handle>* objects_to_revoke,\n-                             bool only_eliminated) {\n-  GrowableArray<MonitorInfo*>* monitors = cvf->monitors();\n-  Thread* thread = Thread::current();\n-  for (int i = 0; i < monitors->length(); i++) {\n-    MonitorInfo* mon_info = monitors->at(i);\n-    if (mon_info->eliminated() == only_eliminated &&\n-        !mon_info->owner_is_scalar_replaced() &&\n-        mon_info->owner() != NULL) {\n-      objects_to_revoke->append(Handle(thread, mon_info->owner()));\n-    }\n-  }\n-}\n-\n-static void get_monitors_from_stack(GrowableArray<Handle>* objects_to_revoke, JavaThread* thread,\n-                                    frame fr, RegisterMap* map, bool only_eliminated) {\n-  \/\/ Unfortunately we don't have a RegisterMap available in most of\n-  \/\/ the places we want to call this routine so we need to walk the\n-  \/\/ stack again to update the register map.\n-  if (map == NULL || !map->update_map()) {\n-    StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/);\n-    bool found = false;\n-    while (!found && !sfs.is_done()) {\n-      frame* cur = sfs.current();\n-      sfs.next();\n-      found = cur->id() == fr.id();\n-    }\n-    assert(found, \"frame to be deoptimized not found on target thread's stack\");\n-    map = sfs.register_map();\n-  }\n-\n-  vframe* vf = vframe::new_vframe(&fr, map, thread);\n-  compiledVFrame* cvf = compiledVFrame::cast(vf);\n-  \/\/ Revoke monitors' biases in all scopes\n-  while (!cvf->is_top()) {\n-    collect_monitors(cvf, objects_to_revoke, only_eliminated);\n-    cvf = compiledVFrame::cast(cvf->sender());\n-  }\n-  collect_monitors(cvf, objects_to_revoke, only_eliminated);\n-}\n-\n-void Deoptimization::revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map) {\n-  if (!UseBiasedLocking) {\n-    return;\n-  }\n-  assert(thread == Thread::current(), \"should be\");\n-  ResourceMark rm(thread);\n-  HandleMark hm(thread);\n-  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-  get_monitors_from_stack(objects_to_revoke, thread, fr, map, false);\n-\n-  int len = objects_to_revoke->length();\n-  for (int i = 0; i < len; i++) {\n-    oop obj = (objects_to_revoke->at(i))();\n-    BiasedLocking::revoke_own_lock(thread, objects_to_revoke->at(i));\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-}\n-\n-\/\/ Revoke the bias of objects with eliminated locking to prepare subsequent relocking.\n-void Deoptimization::revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n-                                                      RegisterMap* map, JavaThread* thread) {\n-  if (!UseBiasedLocking) {\n-    return;\n-  }\n-  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-  assert(KeepStackGCProcessedMark::stack_is_kept_gc_processed(deoptee_thread), \"must be\");\n-  \/\/ Collect monitors but only those with eliminated locking.\n-  get_monitors_from_stack(objects_to_revoke, deoptee_thread, fr, map, true);\n-\n-  int len = objects_to_revoke->length();\n-  for (int i = 0; i < len; i++) {\n-    oop obj = (objects_to_revoke->at(i))();\n-    markWord mark = obj->mark();\n-    if (!mark.has_bias_pattern() ||\n-        mark.is_biased_anonymously() || \/\/ eliminated locking does not bias an object if it wasn't before\n-        !obj->klass()->prototype_header().has_bias_pattern() || \/\/ bulk revoke ignores eliminated monitors\n-        (obj->klass()->prototype_header().bias_epoch() != mark.bias_epoch())) { \/\/ bulk rebias ignores eliminated monitors\n-      \/\/ We reach here regularly if there's just eliminated locking on obj.\n-      \/\/ We must not call BiasedLocking::revoke_own_lock() in this case, as we\n-      \/\/ would hit assertions because it is a prerequisite that there has to be\n-      \/\/ non-eliminated locking on obj by deoptee_thread.\n-      \/\/ Luckily we don't have to revoke here because obj has to be a\n-      \/\/ non-escaping obj and can be relocked without revoking the bias. See\n-      \/\/ Deoptimization::relock_objects().\n-      continue;\n-    }\n-    BiasedLocking::revoke(thread, objects_to_revoke->at(i));\n-    assert(!objects_to_revoke->at(i)->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-}\n-\n@@ -1926,1 +1816,0 @@\n-  \/\/ We need to update the map if we have biased locking.\n@@ -1931,1 +1820,1 @@\n-  RegisterMap reg_map(current, UseBiasedLocking);\n+  RegisterMap reg_map(current, false);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":115,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -155,7 +155,0 @@\n- private:\n-  \/\/ Revoke biased locks at deopt.\n-  static void revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map);\n-\n-  static void revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n-                                               RegisterMap* map, JavaThread* thread);\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -68,56 +68,0 @@\n-JVMFlag::Error BiasedLockingBulkRebiasThresholdFunc(intx value, bool verbose) {\n-  if (value > BiasedLockingBulkRevokeThreshold) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \")\\n\",\n-                        value, BiasedLockingBulkRevokeThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingStartupDelayFunc(intx value, bool verbose) {\n-  if ((value % PeriodicTask::interval_gran) != 0) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingStartupDelay (\" INTX_FORMAT \") must be \"\n-                        \"evenly divisible by PeriodicTask::interval_gran (%d)\\n\",\n-                        value, PeriodicTask::interval_gran);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingBulkRevokeThresholdFunc(intx value, bool verbose) {\n-  if (value < BiasedLockingBulkRebiasThreshold) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \")\\n\",\n-                        value, BiasedLockingBulkRebiasThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else if ((double)value\/(double)BiasedLockingDecayTime > 0.1) {\n-    JVMFlag::printError(verbose,\n-                        \"The ratio of BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \")\"\n-                        \" to BiasedLockingDecayTime (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to 0.1\\n\",\n-                        value, BiasedLockingBulkRebiasThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingDecayTimeFunc(intx value, bool verbose) {\n-  if (BiasedLockingBulkRebiasThreshold\/(double)value > 0.1) {\n-    JVMFlag::printError(verbose,\n-                        \"The ratio of BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \")\"\n-                        \" to BiasedLockingDecayTime (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to 0.1\\n\",\n-                        BiasedLockingBulkRebiasThreshold, value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,4 +39,0 @@\n-  f(intx,   BiasedLockingBulkRebiasThresholdFunc)     \\\n-  f(intx,   BiasedLockingStartupDelayFunc)            \\\n-  f(intx,   BiasedLockingBulkRevokeThresholdFunc)     \\\n-  f(intx,   BiasedLockingDecayTimeFunc)               \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -264,2 +264,1 @@\n-  \/\/ native methods so that biased locking can revoke the receiver's\n-  \/\/ bias if necessary.  This is also used by JVMTI's GetLocalInstance method\n+  \/\/ native methods. Used by JVMTI's GetLocalInstance method\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -680,5 +680,0 @@\n-  product(bool, AlwaysLockClassLoader, false,                               \\\n-          \"(Deprecated) Require the VM to acquire the class loader lock \"   \\\n-          \"before calling loadClass() even for class loaders registering \"  \\\n-          \"as parallel capable\")                                            \\\n-                                                                            \\\n@@ -802,31 +797,0 @@\n-  product(bool, UseBiasedLocking, false,                                    \\\n-          \"(Deprecated) Enable biased locking in JVM\")                      \\\n-                                                                            \\\n-  product(intx, BiasedLockingStartupDelay, 0,                               \\\n-          \"(Deprecated) Number of milliseconds to wait before enabling \"    \\\n-          \"biased locking\")                                                 \\\n-          range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \\\n-          constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \\\n-                                                                            \\\n-  product(bool, PrintBiasedLockingStatistics, false, DIAGNOSTIC,            \\\n-          \"(Deprecated) Print statistics of biased locking in JVM\")         \\\n-                                                                            \\\n-  product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \\\n-          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n-          \"try to rebias all objects in the heap of that type\")             \\\n-          range(0, max_intx)                                                \\\n-          constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \\\n-                                                                            \\\n-  product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \\\n-          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n-          \"permanently revoke biases of all objects in the heap of that \"   \\\n-          \"type\")                                                           \\\n-          range(0, max_intx)                                                \\\n-          constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \\\n-                                                                            \\\n-  product(intx, BiasedLockingDecayTime, 25000,                              \\\n-          \"(Deprecated) Decay time (in milliseconds) to re-enable bulk \"    \\\n-          \"rebiasing of a type after previous bulk rebias\")                 \\\n-          range(500, max_intx)                                              \\\n-          constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-        wait_blocked(self->as_Java_thread(), now);\n+        wait_blocked(JavaThread::cast(self), now);\n@@ -303,1 +303,1 @@\n-    StackWatermarkSet::start_processing(_requester->as_Java_thread(), StackWatermarkKind::gc);\n+    StackWatermarkSet::start_processing(JavaThread::cast(_requester), StackWatermarkKind::gc);\n@@ -620,1 +620,1 @@\n-    JavaThread* current = thr->as_Java_thread();\n+    JavaThread* current = JavaThread::cast(thr);\n@@ -627,2 +627,2 @@\n-  if (_handshakee->is_exiting() ||\n-     _handshakee->threadObj() == NULL) {\n+  assert(_handshakee->threadObj() != NULL, \"cannot suspend with a NULL threadObj\");\n+  if (_handshakee->is_exiting()) {\n@@ -663,1 +663,1 @@\n-    JavaThread* target = thr->as_Java_thread();\n+    JavaThread* target = JavaThread::cast(thr);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  JavaThread *current_thread = thread->as_Java_thread();\n+  JavaThread *current_thread = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-      JavaThread* t2 = t->as_Java_thread();\n+      JavaThread* t2 = JavaThread::cast(t);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -250,1 +249,1 @@\n-  if (PrintLockStatistics || PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintLockStatistics || PrintPreciseRTMLockingStatistics) {\n@@ -336,4 +335,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    BiasedLocking::print_counters();\n-  }\n-\n@@ -378,1 +373,1 @@\n-  if (PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintPreciseRTMLockingStatistics) {\n@@ -382,3 +377,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    BiasedLocking::print_counters();\n-  }\n@@ -564,1 +556,1 @@\n-      thread->as_Java_thread()->set_thread_state(_thread_in_vm);\n+      JavaThread::cast(thread)->set_thread_state(_thread_in_vm);\n@@ -612,1 +604,1 @@\n-      JavaThread* jt = thread->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-           is_frame_handle(thread->as_Java_thread(), handle))) {\n+           is_frame_handle(JavaThread::cast(thread), handle))) {\n@@ -305,1 +305,1 @@\n-          thread->as_Java_thread()->thread_state() == _thread_in_native);\n+          JavaThread::cast(thread)->thread_state() == _thread_in_native);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    thread->as_Java_thread()->check_for_valid_safepoint_state();\n+    JavaThread::cast(thread)->check_for_valid_safepoint_state();\n@@ -88,1 +88,1 @@\n-      { ThreadBlockInVM tbivmdc(self->as_Java_thread(), &in_flight_mutex);\n+      { ThreadBlockInVM tbivmdc(JavaThread::cast(self), &in_flight_mutex);\n@@ -443,1 +443,1 @@\n-      new_owner->as_Java_thread()->inc_no_safepoint_count();\n+      JavaThread::cast(new_owner)->inc_no_safepoint_count();\n@@ -480,1 +480,1 @@\n-      old_owner->as_Java_thread()->dec_no_safepoint_count();\n+      JavaThread::cast(old_owner)->dec_no_safepoint_count();\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+Mutex*   UnregisteredClassesTable_lock= NULL;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+extern Mutex*   UnregisteredClassesTable_lock;   \/\/ UnregisteredClassesTableTable\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,2 +73,4 @@\n-\/\/ Name support for threads.  non-JavaThread subclasses with multiple\n-\/\/ uniquely named instances should derive from this.\n+\/\/ A base class for non-JavaThread subclasses with multiple\n+\/\/ uniquely named instances. NamedThreads also provide a common\n+\/\/ location to store GC information needed by GC threads\n+\/\/ and the VMThread.\n@@ -92,1 +94,2 @@\n-  virtual char* name() const { return _name == NULL ? (char*)\"Unknown Thread\" : _name; }\n+  virtual const char* name() const { return _name == NULL ? \"Unknown Thread\" : _name; }\n+  virtual const char* type_name() const { return \"NamedThread\"; }\n@@ -120,0 +123,4 @@\n+\n+  \/\/ Printing\n+  virtual const char* type_name() const { return \"WorkerThread\"; }\n+\n@@ -135,0 +142,1 @@\n+\n@@ -151,1 +159,2 @@\n-  char* name() const { return (char*)\"VM Periodic Task Thread\"; }\n+  const char* name() const { return \"VM Periodic Task Thread\"; }\n+  const char* type_name() const { return \"WatcherThread\"; }\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -488,1 +488,1 @@\n-    event.set_previousOwner((uintptr_t)_previous_owner_tid);\n+    event.set_previousOwner(_previous_owner_tid);\n@@ -548,1 +548,1 @@\n-    _contentions = -max_jint;\n+    _contentions = INT_MIN; \/\/ minimum negative int\n@@ -575,1 +575,1 @@\n-    if (Atomic::cmpxchg(&_contentions, (jint)0, -max_jint) != 0) {\n+    if (Atomic::cmpxchg(&_contentions, 0, INT_MIN) != 0) {\n@@ -1434,1 +1434,1 @@\n-                                    jlong notifier_tid,\n+                                    uint64_t notifier_tid,\n@@ -2246,1 +2246,1 @@\n-  st->print_cr(\"  _previous_owner_tid = \" JLONG_FORMAT, _previous_owner_tid);\n+  st->print_cr(\"  _previous_owner_tid = \" UINT64_FORMAT, _previous_owner_tid);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  jlong         _notifier_tid;\n+  uint64_t      _notifier_tid;\n@@ -151,1 +151,1 @@\n-  volatile jlong _previous_owner_tid;  \/\/ thread id of the previous owner of the monitor\n+  volatile uint64_t _previous_owner_tid;  \/\/ thread id of the previous owner of the monitor\n@@ -157,1 +157,1 @@\n-                        sizeof(volatile jlong));\n+                        sizeof(volatile uint64_t));\n@@ -171,1 +171,1 @@\n-  jint  _contentions;               \/\/ Number of active contentions in enter(). It is used by is_busy()\n+  int _contentions;                 \/\/ Number of active contentions in enter(). It is used by is_busy()\n@@ -177,1 +177,1 @@\n-  volatile jint  _waiters;          \/\/ number of waiting threads\n+  volatile int  _waiters;           \/\/ number of waiting threads\n@@ -241,3 +241,4 @@\n-    intptr_t ret_code = _waiters | intptr_t(_cxq) | intptr_t(_EntryList);\n-    if (contentions() > 0) {\n-      ret_code |= contentions();\n+    intptr_t ret_code = intptr_t(_waiters) | intptr_t(_cxq) | intptr_t(_EntryList);\n+    int cnts = contentions(); \/\/ read once\n+    if (cnts > 0) {\n+      ret_code |= intptr_t(cnts);\n@@ -284,1 +285,1 @@\n-  jint      waiters() const;\n+  int       waiters() const;\n@@ -286,2 +287,2 @@\n-  jint      contentions() const;\n-  void      add_to_contentions(jint value);\n+  int       contentions() const;\n+  void      add_to_contentions(int value);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-inline jint ObjectMonitor::waiters() const {\n+inline int ObjectMonitor::waiters() const {\n@@ -82,1 +82,1 @@\n-inline jint ObjectMonitor::contentions() const {\n+inline int ObjectMonitor::contentions() const {\n@@ -87,1 +87,1 @@\n-inline void ObjectMonitor::add_to_contentions(jint value) {\n+inline void ObjectMonitor::add_to_contentions(int value) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-        VM_PrintThreads op;\n+        VM_PrintThreads op(tty, PrintConcurrentLocks, false \/* no extended info *\/, true \/* print JNI handle info *\/);\n@@ -404,2 +404,0 @@\n-        VM_PrintJNI jni_op;\n-        VMThread::execute(&jni_op);\n@@ -1472,1 +1470,1 @@\n-  address limit = thread->as_Java_thread()->stack_end() +\n+  address limit = JavaThread::cast(thread)->stack_end() +\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -513,1 +513,1 @@\n-      StackWatermarkSet::start_processing(thread->as_Java_thread(), StackWatermarkKind::gc);\n+      StackWatermarkSet::start_processing(JavaThread::cast(thread), StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    _thread->as_Java_thread()->inc_no_safepoint_count();\n+    JavaThread::cast(_thread)->inc_no_safepoint_count();\n@@ -42,1 +42,1 @@\n-    _thread->as_Java_thread()->dec_no_safepoint_count();\n+    JavaThread::cast(_thread)->dec_no_safepoint_count();\n@@ -50,1 +50,1 @@\n-    _nsv->_thread->as_Java_thread()->dec_no_safepoint_count();\n+    JavaThread::cast(_nsv->_thread)->dec_no_safepoint_count();\n@@ -56,1 +56,1 @@\n-    _nsv->_thread->as_Java_thread()->inc_no_safepoint_count();\n+    JavaThread::cast(_nsv->_thread)->inc_no_safepoint_count();\n","filename":"src\/hotspot\/share\/runtime\/safepointVerifiers.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -144,1 +143,0 @@\n-int SharedRuntime::_throw_null_ctr = 0;\n@@ -159,1 +157,0 @@\n-int SharedRuntime::_multi1_ctr=0;\n@@ -995,1 +992,1 @@\n-      oop obj = thread->as_Java_thread()->threadObj();\n+      oop obj = JavaThread::cast(thread)->threadObj();\n@@ -2121,3 +2118,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n-  }\n@@ -2161,2 +2155,0 @@\n-  if (_throw_null_ctr) tty->print_cr(\"%5d implicit null throw\", _throw_null_ctr);\n-\n@@ -2168,1 +2160,0 @@\n-  if (_multi1_ctr) tty->print_cr(\"%5d multianewarray 1 dim\", _multi1_ctr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -537,1 +537,0 @@\n-  static int _throw_null_ctr;                    \/\/ throwing a null-pointer exception\n@@ -558,1 +557,1 @@\n-  static int _multi1_ctr, _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n+  static int _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-      thread->as_Java_thread()->nmethods_do(_cl);\n+      JavaThread::cast(thread)->nmethods_do(_cl);\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -130,1 +129,1 @@\n-      ObjectSynchronizer::chk_for_block_req(current->as_Java_thread(), \"unlinking\",\n+      ObjectSynchronizer::chk_for_block_req(JavaThread::cast(current), \"unlinking\",\n@@ -303,1 +302,1 @@\n-  \/\/ biased locking and any other IMS exception states take the slow-path\n+  \/\/ other IMS exception states take the slow-path\n@@ -352,2 +351,1 @@\n-    \/\/ Biased Locking in the object's header, the second check is for\n-    \/\/ stack-locking in the object's header, the third check is for\n+    \/\/ stack-locking in the object's header, the second check is for\n@@ -367,1 +365,0 @@\n-  \/\/ -- perform bias revocation, or\n@@ -434,4 +431,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-  }\n-\n@@ -439,2 +432,0 @@\n-  assert(!mark.has_bias_pattern(), \"should not see bias pattern here\");\n-\n@@ -475,3 +466,0 @@\n-  \/\/ We cannot check for Biased Locking if we are racing an inflation.\n-  assert(mark == markWord::INFLATING() ||\n-         !mark.has_bias_pattern(), \"should not see bias pattern here\");\n@@ -538,5 +526,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -552,5 +535,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -578,4 +556,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -598,6 +572,0 @@\n-  if (UseBiasedLocking) {\n-    Handle h_obj(current, obj);\n-    BiasedLocking::revoke(current, h_obj);\n-    obj = h_obj();\n-  }\n-  assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -641,4 +609,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -667,4 +631,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -680,4 +640,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -699,4 +655,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -849,19 +801,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ NOTE: many places throughout the JVM do not expect a safepoint\n-    \/\/ to be taken here. However, we only ever bias Java instances and all\n-    \/\/ of the call sites of identity_hash that might revoke biases have\n-    \/\/ been checked to make sure they can handle a safepoint. The\n-    \/\/ added check of the bias pattern is to avoid useless calls to\n-    \/\/ thread-local storage.\n-    if (obj->mark().has_bias_pattern()) {\n-      \/\/ Handle for oop obj in case of STW safepoint\n-      Handle hobj(current, obj);\n-      if (SafepointSynchronize::is_at_safepoint()) {\n-        BiasedLocking::revoke_at_safepoint(hobj);\n-      } else {\n-        BiasedLocking::revoke(current->as_Java_thread(), hobj);\n-      }\n-      obj = hobj();\n-      assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-    }\n-  }\n@@ -875,3 +808,0 @@\n-    \/\/ object should remain ineligible for biased locking\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n-\n@@ -988,5 +918,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, h_obj);\n-    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -1016,9 +941,0 @@\n-  if (UseBiasedLocking) {\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      BiasedLocking::revoke_at_safepoint(h_obj);\n-    } else {\n-      BiasedLocking::revoke(JavaThread::current(), h_obj);\n-    }\n-    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -1205,1 +1121,0 @@\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n@@ -1212,1 +1127,0 @@\n-    \/\/ *  BIASED       - Illegal.  We should never see this\n@@ -1420,1 +1334,1 @@\n-      chk_for_block_req(current->as_Java_thread(), \"deflation\", \"deflated_count\",\n+      chk_for_block_req(JavaThread::cast(current), \"deflation\", \"deflated_count\",\n@@ -1510,1 +1424,1 @@\n-        chk_for_block_req(current->as_Java_thread(), \"deletion\", \"deleted_count\",\n+        chk_for_block_req(JavaThread::cast(current), \"deletion\", \"deleted_count\",\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":91,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -166,1 +165,1 @@\n-      const char* name = (javathread)->get_thread_name();                  \\\n+      const char* name = (javathread)->name();                             \\\n@@ -187,1 +186,0 @@\n-\/\/ Support for forcing alignment of thread objects for biased locking\n@@ -189,19 +187,1 @@\n-  if (UseBiasedLocking) {\n-    const size_t alignment = markWord::biased_lock_alignment;\n-    size_t aligned_size = size + (alignment - sizeof(intptr_t));\n-    void* real_malloc_addr = throw_excpt? AllocateHeap(aligned_size, flags, CURRENT_PC)\n-                                          : AllocateHeap(aligned_size, flags, CURRENT_PC,\n-                                                         AllocFailStrategy::RETURN_NULL);\n-    void* aligned_addr     = align_up(real_malloc_addr, alignment);\n-    assert(((uintptr_t) aligned_addr + (uintptr_t) size) <=\n-           ((uintptr_t) real_malloc_addr + (uintptr_t) aligned_size),\n-           \"JavaThread alignment code overflowed allocated storage\");\n-    if (aligned_addr != real_malloc_addr) {\n-      log_info(biasedlocking)(\"Aligned thread \" INTPTR_FORMAT \" to \" INTPTR_FORMAT,\n-                              p2i(real_malloc_addr),\n-                              p2i(aligned_addr));\n-    }\n-    ((Thread*) aligned_addr)->_real_malloc_address = real_malloc_addr;\n-    return aligned_addr;\n-  } else {\n-    return throw_excpt? AllocateHeap(size, flags, CURRENT_PC)\n+  return throw_excpt ? AllocateHeap(size, flags, CURRENT_PC)\n@@ -209,1 +189,0 @@\n-  }\n@@ -213,5 +192,1 @@\n-  if (UseBiasedLocking) {\n-    FreeHeap(((Thread*) p)->_real_malloc_address);\n-  } else {\n-    FreeHeap(p);\n-  }\n+  FreeHeap(p);\n@@ -291,8 +266,0 @@\n-#ifdef ASSERT\n-  if (UseBiasedLocking) {\n-    assert(is_aligned(this, markWord::biased_lock_alignment), \"forced alignment of thread object failed\");\n-    assert(this == _real_malloc_address ||\n-           this == align_up(_real_malloc_address, markWord::biased_lock_alignment),\n-           \"bug in forced alignment of thread objects\");\n-  }\n-#endif \/\/ ASSERT\n@@ -352,1 +319,1 @@\n-    as_Java_thread()->stack_overflow_state()->initialize(stack_base(), stack_end());\n+    JavaThread::cast(this)->stack_overflow_state()->initialize(stack_base(), stack_end());\n@@ -464,2 +431,2 @@\n-         thread->as_Java_thread()->is_handshake_safe_for(Thread::current()) ||\n-         !thread->as_Java_thread()->on_thread_list() ||\n+         JavaThread::cast(thread)->is_handshake_safe_for(Thread::current()) ||\n+         !JavaThread::cast(thread)->on_thread_list() ||\n@@ -467,1 +434,1 @@\n-         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(thread->as_Java_thread()),\n+         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(JavaThread::cast(thread)),\n@@ -539,1 +506,1 @@\n-    java_lang_Thread::set_thread_status(thread->as_Java_thread()->threadObj(),\n+    java_lang_Thread::set_thread_status(JavaThread::cast(thread)->threadObj(),\n@@ -645,9 +612,1 @@\n-  if (is_VM_thread())                 { st->print(\"VMThread\"); }\n-  else if (is_GC_task_thread())       { st->print(\"GCTaskThread\"); }\n-  else if (is_Watcher_thread())       { st->print(\"WatcherThread\"); }\n-  else if (is_ConcurrentGC_thread())  { st->print(\"ConcurrentGCThread\"); }\n-  else                                { st->print(\"Thread\"); }\n-\n-  if (is_Named_thread()) {\n-    st->print(\" \\\"%s\\\"\", name());\n-  }\n+  st->print(\"%s \\\"%s\\\"\", type_name(), name());\n@@ -706,1 +665,1 @@\n-  return os::create_main_thread(this->as_Java_thread());\n+  return os::create_main_thread(JavaThread::cast(this));\n@@ -1082,1 +1041,0 @@\n-  _cached_monitor_info(nullptr),\n@@ -1302,1 +1260,1 @@\n-      this->set_native_thread_name(this->get_thread_name());\n+      this->set_native_thread_name(this->name());\n@@ -1381,1 +1339,1 @@\n-                    get_thread_name());\n+                    name());\n@@ -1486,1 +1444,1 @@\n-    thread_name = os::strdup(get_thread_name());\n+    thread_name = os::strdup(name());\n@@ -1554,1 +1512,1 @@\n-    return thread->as_Java_thread();\n+    return JavaThread::cast(thread);\n@@ -1558,1 +1516,1 @@\n-    JavaThread *ret = op == NULL ? NULL : op->calling_thread()->as_Java_thread();\n+    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n@@ -1716,1 +1674,1 @@\n-    JavaThread* target = thr->as_Java_thread();\n+    JavaThread* target = JavaThread::cast(thr);\n@@ -2094,1 +2052,1 @@\n-  st->print_raw(get_thread_name());\n+  st->print_raw(name());\n@@ -2132,1 +2090,1 @@\n-  st->print(\"JavaThread \\\"%s\\\"\", get_thread_name_string(buf, buflen));\n+  st->print(\"%s \\\"%s\\\"\", type_name(), get_thread_name_string(buf, buflen));\n@@ -2180,1 +2138,1 @@\n-const char* JavaThread::get_thread_name() const {\n+const char* JavaThread::name() const  {\n@@ -2206,1 +2164,1 @@\n-      name_str = Thread::name();\n+      name_str = \"<un-named>\";\n@@ -3057,2 +3015,0 @@\n-  BiasedLocking::init();\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":20,"deletions":64,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -167,3 +167,0 @@\n-  \/\/ Support for forcing alignment of thread objects for biased locking\n-  void*       _real_malloc_address;\n-\n@@ -358,3 +355,5 @@\n-  \/\/ Casts\n-  inline JavaThread* as_Java_thread();\n-  inline const JavaThread* as_Java_thread() const;\n+  \/\/ All threads are given names. For singleton subclasses we can\n+  \/\/ just hard-wire the known name of the instance. JavaThreads and\n+  \/\/ NamedThreads support multiple named instances, and dynamic\n+  \/\/ changing of the name of an instance.\n+  virtual const char* name() const { return \"Unknown thread\"; }\n@@ -362,1 +361,3 @@\n-  virtual char* name() const { return (char*)\"Unknown thread\"; }\n+  \/\/ A thread's type name is also made available for debugging\n+  \/\/ and logging.\n+  virtual const char* type_name() const { return \"Thread\"; }\n@@ -578,0 +579,1 @@\n+  \/\/ Basic, non-virtual, printing support that is simple and always safe.\n@@ -1357,0 +1359,3 @@\n+  \/\/ factor out low-level mechanics for use in both normal and error cases\n+  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+\n@@ -1376,1 +1381,3 @@\n-  char* name() const { return (char*)get_thread_name(); }\n+  const char* name() const;\n+  const char* type_name() const { return \"JavaThread\"; }\n+\n@@ -1384,5 +1391,1 @@\n-  const char* get_thread_name() const;\n- protected:\n-  \/\/ factor out low-level mechanics for use in both normal and error cases\n-  virtual const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n- public:\n+\n@@ -1423,1 +1426,14 @@\n-  static inline JavaThread* current();\n+  static JavaThread* current() {\n+    return JavaThread::cast(Thread::current());\n+  }\n+\n+  \/\/ Casts\n+  static JavaThread* cast(Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to JavaThread\");\n+    return static_cast<JavaThread*>(t);\n+  }\n+\n+  static const JavaThread* cast(const Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to const JavaThread\");\n+    return static_cast<const JavaThread*>(t);\n+  }\n@@ -1554,3 +1570,0 @@\n-  \/\/ Biased locking support\n- private:\n-  GrowableArray<MonitorInfo*>* _cached_monitor_info;\n@@ -1558,3 +1571,0 @@\n-  GrowableArray<MonitorInfo*>* cached_monitor_info() { return _cached_monitor_info; }\n-  void set_cached_monitor_info(GrowableArray<MonitorInfo*>* info) { _cached_monitor_info = info; }\n-\n@@ -1589,15 +1599,0 @@\n-\/\/ Inline implementation of JavaThread::current\n-inline JavaThread* JavaThread::current() {\n-  return Thread::current()->as_Java_thread();\n-}\n-\n-inline JavaThread* Thread::as_Java_thread() {\n-  assert(is_Java_thread(), \"incorrect cast to JavaThread\");\n-  return static_cast<JavaThread*>(this);\n-}\n-\n-inline const JavaThread* Thread::as_Java_thread() const {\n-  assert(is_Java_thread(), \"incorrect cast to const JavaThread\");\n-  return static_cast<const JavaThread*>(this);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":30,"deletions":35,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-          st->print(\"\\t- eliminated <owner is scalar replaced> (a %s)\", k->external_name());\n+          st->print_cr(\"\\t- eliminated <owner is scalar replaced> (a %s)\", k->external_name());\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-          assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern()), \"object must be null or locked, and unbiased\");\n+          assert(monitor->owner() == NULL || !monitor->owner()->is_unlocked(), \"object must be null or locked\");\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,3 +235,2 @@\n-    \/\/ This monitor is really only needed for UseBiasedLocking, but\n-    \/\/ return it in all cases for now as it might be useful for stack\n-    \/\/ traces and tools as well\n+    \/\/ This monitor is not really needed but return it for now as it might be\n+    \/\/ useful for stack traces and tools\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  template(PrintJNI)                              \\\n@@ -71,2 +70,0 @@\n-  template(EnableBiasedLocking)                   \\\n-  template(BulkRevokeBias)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-  calling_thread()->as_Java_thread()->make_zombies();\n+  JavaThread::cast(calling_thread())->make_zombies();\n@@ -171,0 +171,3 @@\n+  if (_print_jni_handle_info) {\n+    JNIHandles::print_on(_out);\n+  }\n@@ -180,4 +183,0 @@\n-void VM_PrintJNI::doit() {\n-  JNIHandles::print_on(_out);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+  bool _print_jni_handle_info;\n@@ -148,1 +149,1 @@\n-    : _out(tty), _print_concurrent_locks(PrintConcurrentLocks), _print_extended_info(false)\n+    : _out(tty), _print_concurrent_locks(PrintConcurrentLocks), _print_extended_info(false), _print_jni_handle_info(false)\n@@ -150,2 +151,3 @@\n-  VM_PrintThreads(outputStream* out, bool print_concurrent_locks, bool print_extended_info)\n-    : _out(out), _print_concurrent_locks(print_concurrent_locks), _print_extended_info(print_extended_info)\n+  VM_PrintThreads(outputStream* out, bool print_concurrent_locks, bool print_extended_info, bool print_jni_handle_info)\n+    : _out(out), _print_concurrent_locks(print_concurrent_locks), _print_extended_info(print_extended_info),\n+      _print_jni_handle_info(print_jni_handle_info)\n@@ -161,10 +163,0 @@\n-class VM_PrintJNI: public VM_Operation {\n- private:\n-  outputStream* _out;\n- public:\n-  VM_PrintJNI()                         { _out = tty; }\n-  VM_PrintJNI(outputStream* out)        { _out = out; }\n-  VMOp_Type type() const                { return VMOp_PrintJNI; }\n-  void doit();\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -884,2 +883,2 @@\n-  nonstatic_field(ObjectMonitor,               _contentions,                                  jint)                                  \\\n-  volatile_nonstatic_field(ObjectMonitor,      _waiters,                                      jint)                                  \\\n+  nonstatic_field(ObjectMonitor,               _contentions,                                  int)                                   \\\n+  volatile_nonstatic_field(ObjectMonitor,      _waiters,                                      int)                                   \\\n@@ -2633,1 +2632,0 @@\n-  declare_constant(markWord::biased_lock_bits)                            \\\n@@ -2638,1 +2636,0 @@\n-  declare_constant(markWord::biased_lock_shift)                           \\\n@@ -2644,3 +2641,0 @@\n-  declare_constant(markWord::biased_lock_mask)                            \\\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n-  declare_constant(markWord::biased_lock_bit_in_place)                    \\\n@@ -2649,2 +2643,0 @@\n-  declare_constant(markWord::epoch_mask)                                  \\\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -2653,1 +2645,0 @@\n-  declare_constant(markWord::biased_lock_alignment)                       \\\n@@ -2659,1 +2650,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-    thread->as_Java_thread()->verify_states_for_handshake();\n+    JavaThread::cast(thread)->verify_states_for_handshake();\n@@ -525,1 +525,1 @@\n-    t->as_Java_thread()->check_for_valid_safepoint_state();\n+    JavaThread::cast(t)->check_for_valid_safepoint_state();\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+  \/\/ Printing\n+  const char* type_name() const { return \"VMThread\"; }\n+\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-  \/\/ thread stacks\n-  VM_PrintThreads op1(out, print_concurrent_locks, print_extended_info);\n+  \/\/ thread stacks and JNI global handles\n+  VM_PrintThreads op1(out, print_concurrent_locks, print_extended_info, true \/* print JNI handle info *\/);\n@@ -190,4 +190,0 @@\n-  \/\/ JNI global handles\n-  VM_PrintJNI op2(out);\n-  VMThread::execute(&op2);\n-\n@@ -195,2 +191,2 @@\n-  VM_FindDeadlocks op3(out);\n-  VMThread::execute(&op3);\n+  VM_FindDeadlocks op2(out);\n+  VMThread::execute(&op2);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -537,2 +537,2 @@\n-  \/\/ thread stacks\n-  VM_PrintThreads op1(output(), _locks.value(), _extended.value());\n+  \/\/ thread stacks and JNI global handles\n+  VM_PrintThreads op1(output(), _locks.value(), _extended.value(), true \/* print JNI handle info *\/);\n@@ -541,4 +541,0 @@\n-  \/\/ JNI global handles\n-  VM_PrintJNI op2(output());\n-  VMThread::execute(&op2);\n-\n@@ -546,2 +542,2 @@\n-  VM_FindDeadlocks op3(output());\n-  VMThread::execute(&op3);\n+  VM_FindDeadlocks op2(output());\n+  VMThread::execute(&op2);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-          currentThread = owner->as_Java_thread();\n+          currentThread = JavaThread::cast(owner);\n@@ -444,2 +444,0 @@\n-            cycle->set_deadlock(true);\n-\n@@ -487,2 +485,0 @@\n-        cycle->set_deadlock(true);\n-\n@@ -958,1 +954,0 @@\n-  _is_deadlock = false;\n@@ -983,1 +978,1 @@\n-    st->print_cr(\"\\\"%s\\\":\", currentThread->get_thread_name());\n+    st->print_cr(\"\\\"%s\\\":\", currentThread->name());\n@@ -994,2 +989,2 @@\n-          currentThread = owner->as_Java_thread();\n-          st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->get_thread_name());\n+          currentThread = JavaThread::cast(owner);\n+          st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->name());\n@@ -1034,1 +1029,1 @@\n-    st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->get_thread_name());\n+    st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->name());\n@@ -1046,1 +1041,1 @@\n-    st->print_cr(\"\\\"%s\\\":\", currentThread->get_thread_name());\n+    st->print_cr(\"\\\"%s\\\":\", currentThread->name());\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -387,1 +387,0 @@\n-  bool _is_deadlock;\n@@ -397,3 +396,1 @@\n-  void           reset()                    { _is_deadlock = false; _threads->clear(); }\n-  void           set_deadlock(bool value)   { _is_deadlock = value; }\n-  bool           is_deadlock()              { return _is_deadlock; }\n+  void           reset()                    { _threads->clear(); }\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -192,0 +192,4 @@\n+\n+    size_t get_mem_size() {\n+      return sizeof(*this) + _size * sizeof(Bucket);\n+    }\n@@ -387,0 +391,2 @@\n+  size_t get_mem_size(Thread* thread);\n+\n@@ -388,1 +394,1 @@\n-  size_t get_node_size() const { return sizeof(Node); }\n+  static size_t get_node_size() { return sizeof(Node); }\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-\/\/ 2^5  = 32 buckets\n-#define SIZE_SMALL_LOG2 5\n+\/\/ 2^2  = 4 buckets\n+#define SIZE_SMALL_LOG2 2\n@@ -820,4 +820,1 @@\n-\n-  if (_new_table->_log2_size == _log2_size_limit) {\n-    _size_limit_reached = true;\n-  }\n+  _size_limit_reached = _new_table->_log2_size == _log2_size_limit;\n@@ -957,0 +954,1 @@\n+    Prefetch::read(current_node->next(), 0);\n@@ -1035,0 +1033,8 @@\n+template <typename CONFIG, MEMFLAGS F>\n+inline size_t ConcurrentHashTable<CONFIG, F>::\n+  get_mem_size(Thread* thread)\n+{\n+  ScopedCS cs(thread, this);\n+  return sizeof(*this) + _table->get_mem_size();\n+}\n+\n@@ -1138,2 +1144,0 @@\n-  assert(Thread::current()->is_VM_thread(),\n-         \"should be in vm thread\");\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -245,0 +245,5 @@\n+  \/\/ The following method is not MT-safe and must be done under lock.\n+  KVHashtableEntry** bucket_addr(int i) {\n+    return (KVHashtableEntry**)BasicHashtable<F>::bucket_addr(i);\n+  }\n+\n@@ -252,0 +257,4 @@\n+  void free_entry(KVHashtableEntry* entry) {\n+    BasicHashtable<F>::free_entry(entry);\n+  }\n+\n@@ -254,0 +263,11 @@\n+  ~KVHashtable() {\n+    KVHashtableEntry* probe = NULL;\n+    for (int index = 0; index < table_size(); index++) {\n+      for (KVHashtableEntry** p = bucket_addr(index); *p != NULL; ) {\n+        probe = *p;\n+        *p = probe->next();\n+        free_entry(probe);\n+      }\n+    }\n+    assert(BasicHashtable<F>::number_of_entries() == 0, \"should have removed all entries\");\n+  }\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n-#define SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n-\n-#include \"memory\/padded.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/pair.hpp\"\n-\n-\/\/ Return status of a LockFreeQueue::try_pop() call.\n-\/\/ See description for try_pop() below.\n-enum class LockFreeQueuePopStatus {\n-  success,\n-  lost_race,\n-  operation_in_progress\n-};\n-\n-\/\/ The LockFreeQueue template provides a lock-free FIFO. Its structure\n-\/\/ and usage is similar to LockFreeStack. It provides a try_pop() function\n-\/\/ for the client to implement pop() according to its need (e.g., whether\n-\/\/ or not to retry or prevent ABA problem). It has inner padding of one\n-\/\/ cache line between its two internal pointer fields.\n-\/\/\n-\/\/ \\tparam T is the class of the elements in the queue.\n-\/\/\n-\/\/ \\tparam next_ptr is a function pointer.  Applying this function to\n-\/\/ an object of type T must return a pointer to the list entry member\n-\/\/ of the object associated with the LockFreeQueue type.\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-class LockFreeQueue {\n-  T* volatile _head;\n-  \/\/ Padding of one cache line to avoid false sharing.\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(T*));\n-  T* volatile _tail;\n-\n-  NONCOPYABLE(LockFreeQueue);\n-\n-  \/\/ Return the entry following node in the list used by the\n-  \/\/ specialized LockFreeQueue class.\n-  static inline T* next(const T& node);\n-\n-  \/\/ Set the entry following node to new_next in the list used by the\n-  \/\/ specialized LockFreeQueue class. Not thread-safe, as it cannot\n-  \/\/ concurrently run with push or try_pop operations that modify this\n-  \/\/ node.\n-  static inline void set_next(T& node, T* new_next);\n-\n-public:\n-  inline LockFreeQueue();\n-  DEBUG_ONLY(~LockFreeQueue();)\n-\n-  \/\/ Return the first object in the queue.\n-  \/\/ Thread-safe, but the result may change immediately.\n-  inline T* top() const;\n-\n-  \/\/ Return true if the queue is empty.\n-  inline bool empty() const { return top() == NULL; }\n-\n-  \/\/ Return the number of objects in the queue.\n-  \/\/ Not thread-safe. There must be no concurrent modification\n-  \/\/ while the length is being determined.\n-  inline size_t length() const;\n-\n-  \/\/ Thread-safe add the object to the end of the queue.\n-  inline void push(T& node) { append(node, node); }\n-\n-  \/\/ Thread-safe add the objects from first to last to the end of the queue.\n-  inline void append(T& first, T& last);\n-\n-  \/\/ Thread-safe attempt to remove and return the first object in the queue.\n-  \/\/ Returns a <LockFreeQueuePopStatus, T*> pair for the caller to determine\n-  \/\/ further operation. 3 possible cases depending on pair.first:\n-  \/\/ - success:\n-  \/\/   The operation succeeded. If pair.second is NULL, the queue is empty;\n-  \/\/   otherwise caller can assume ownership of the object pointed by\n-  \/\/   pair.second. Note that this case is still subject to ABA behavior;\n-  \/\/   callers must ensure usage is safe.\n-  \/\/ - lost_race:\n-  \/\/   An atomic operation failed. pair.second is NULL.\n-  \/\/   The caller can typically retry in this case.\n-  \/\/ - operation_in_progress:\n-  \/\/   An in-progress concurrent operation interfered with taking what had been\n-  \/\/   the only remaining element in the queue. pair.second is NULL.\n-  \/\/   A concurrent try_pop may have already claimed it, but not completely\n-  \/\/   updated the queue. Alternatively, a concurrent push\/append may have not\n-  \/\/   yet linked the new entry(s) to the former sole entry. Retrying the try_pop\n-  \/\/   will continue to fail in this way until that other thread has updated the\n-  \/\/   queue's internal structure.\n-  inline Pair<LockFreeQueuePopStatus, T*> try_pop();\n-\n-  \/\/ Take all the objects from the queue, leaving the queue empty.\n-  \/\/ Not thread-safe. It should only be used when there is no concurrent\n-  \/\/ push\/append\/try_pop operation.\n-  \/\/ Returns a pair of <head, tail> pointers to the current queue.\n-  inline Pair<T*, T*> take_all();\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.hpp","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n-#define SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n-\n-#include \"utilities\/lockFreeQueue.hpp\"\n-\n-#include \"runtime\/atomic.hpp\"\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-T* LockFreeQueue<T, next_ptr>::next(const T& node) {\n-  return Atomic::load(next_ptr(const_cast<T&>(node)));\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-void LockFreeQueue<T, next_ptr>::set_next(T& node, T* new_next) {\n-    Atomic::store(next_ptr(node), new_next);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-LockFreeQueue<T, next_ptr>::LockFreeQueue() : _head(NULL), _tail(NULL) {}\n-\n-#ifdef ASSERT\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-LockFreeQueue<T, next_ptr>::~LockFreeQueue() {\n-  assert(_head == NULL, \"precondition\");\n-  assert(_tail == NULL, \"precondition\");\n-}\n-#endif\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-T* LockFreeQueue<T, next_ptr>::top() const {\n-  return Atomic::load(&_head);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-size_t LockFreeQueue<T, next_ptr>::length() const {\n-  size_t result = 0;\n-  for (const T* current = top(); current != NULL; current = next(*current)) {\n-    ++result;\n-  }\n-  return result;\n-}\n-\n-\/\/ An append operation atomically exchanges the new tail with the queue tail.\n-\/\/ It then sets the \"next\" value of the old tail to the head of the list being\n-\/\/ appended; it is an invariant that the old tail's \"next\" value is NULL.\n-\/\/ But if the old tail is NULL then the queue was empty.  In this case the\n-\/\/ head of the list being appended is instead stored in the queue head; it is\n-\/\/ an invariant that the queue head is NULL in this case.\n-\/\/\n-\/\/ This means there is a period between the exchange and the old tail update\n-\/\/ where the queue sequence is split into two parts, the list from the queue\n-\/\/ head to the old tail, and the list being appended.  If there are concurrent\n-\/\/ push\/append operations, each may introduce another such segment.  But they\n-\/\/ all eventually get resolved by their respective updates of their old tail's\n-\/\/ \"next\" value.  This also means that try_pop operation must handle an object\n-\/\/ with a NULL \"next\" value specially.\n-\/\/\n-\/\/ A push operation is just a degenerate append, where the object being pushed\n-\/\/ is both the head and the tail of the list being appended.\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-void LockFreeQueue<T, next_ptr>::append(T& first, T& last) {\n-  assert(next(last) == NULL, \"precondition\");\n-  T* old_tail = Atomic::xchg(&_tail, &last);\n-  if (old_tail == NULL) {       \/\/ Was empty.\n-    Atomic::store(&_head, &first);\n-  } else {\n-    assert(next(*old_tail) == NULL, \"invariant\");\n-    set_next(*old_tail, &first);\n-  }\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-Pair<LockFreeQueuePopStatus, T*> LockFreeQueue<T, next_ptr>::try_pop() {\n-  typedef Pair<LockFreeQueuePopStatus, T*> StatusPair;\n-  \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n-  \/\/ as the memory_order_consume API is not ready for use yet.\n-  T* result = Atomic::load_acquire(&_head);\n-  if (result == NULL) {\n-    \/\/ Queue is empty.\n-    return StatusPair(LockFreeQueuePopStatus::success, NULL);\n-  }\n-\n-  \/\/ This relaxed load is always followed by a cmpxchg(), thus it\n-  \/\/ is OK as the reader-side of the release-acquire ordering.\n-  T* next_node = Atomic::load(next_ptr(*result));\n-  if (next_node != NULL) {\n-    \/\/ The \"usual\" lock-free pop from the head of a singly linked list.\n-    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n-      \/\/ Former head successfully taken; it is not the last.\n-      assert(Atomic::load(&_tail) != result, \"invariant\");\n-      assert(next(*result) != NULL, \"invariant\");\n-      set_next(*result, NULL);\n-      return StatusPair(LockFreeQueuePopStatus::success, result);\n-    }\n-    \/\/ Lost the race; the caller should try again.\n-    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n-  }\n-\n-  \/\/ next is NULL.  This case is handled differently from the \"usual\"\n-  \/\/ lock-free pop from the head of a singly linked list.\n-\n-  \/\/ If _tail == result then result is the only element in the list. We can\n-  \/\/ remove it from the list by first setting _tail to NULL and then setting\n-  \/\/ _head to NULL, the order being important.  We set _tail with cmpxchg in\n-  \/\/ case of a concurrent push\/append\/try_pop also changing _tail.  If we win\n-  \/\/ then we've claimed result.\n-  if (Atomic::cmpxchg(&_tail, result, (T*)NULL) == result) {\n-    assert(next(*result) == NULL, \"invariant\");\n-    \/\/ Now that we've claimed result, also set _head to NULL.  But we must\n-    \/\/ be careful of a concurrent push\/append after we NULLed _tail, since\n-    \/\/ it may have already performed its list-was-empty update of _head,\n-    \/\/ which we must not overwrite.\n-    Atomic::cmpxchg(&_head, result, (T*)NULL);\n-    return StatusPair(LockFreeQueuePopStatus::success, result);\n-  }\n-\n-  \/\/ If _head != result then we lost the race to take result;\n-  \/\/ the caller should try again.\n-  if (result != Atomic::load_acquire(&_head)) {\n-    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n-  }\n-\n-  \/\/ An in-progress concurrent operation interfered with taking the head\n-  \/\/ element when it was the only element.  A concurrent try_pop may have won\n-  \/\/ the race to clear the tail but not yet cleared the head. Alternatively,\n-  \/\/ a concurrent push\/append may have changed the tail but not yet linked\n-  \/\/ result->next(). This case slightly differs from the \"lost_race\" case,\n-  \/\/ because the caller could wait for a long time for the other concurrent\n-  \/\/ operation to finish.\n-  return StatusPair(LockFreeQueuePopStatus::operation_in_progress, NULL);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-Pair<T*, T*> LockFreeQueue<T, next_ptr>::take_all() {\n-  Pair<T*, T*> result(Atomic::load(&_head), Atomic::load(&_tail));\n-  Atomic::store(&_head, (T*)NULL);\n-  Atomic::store(&_tail, (T*)NULL);\n-  return result;\n-}\n-\n-#endif \/\/ SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.inline.hpp","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n+#define SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n+\n+#include \"memory\/padded.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/pair.hpp\"\n+\n+\/\/ The NonblockingQueue template provides a non-blocking FIFO.\n+\/\/ It has inner padding of one cache line between its two internal pointers.\n+\/\/\n+\/\/ The queue is internally represented by a linked list of elements, with\n+\/\/ the link to the next element provided by a member of each element.\n+\/\/ Access to this member is provided by the next_ptr function.\n+\/\/\n+\/\/ The queue has a special pseudo-element that marks the end of the list.\n+\/\/ Each queue has its own unique special element.  A pointer to this element\n+\/\/ can be recognized using the is_end() function.  Such a pointer must never\n+\/\/ be dereferenced.  This end marker is the value of the next member of the\n+\/\/ last element in the queue, and possibly other elements while modifying\n+\/\/ the queue.\n+\/\/\n+\/\/ A queue may temporarily appear to be empty even though elements have been\n+\/\/ added and not removed.  For example, after running the following program,\n+\/\/ the value of r may be NULL.\n+\/\/\n+\/\/ thread1: q.push(a); r = q.pop();\n+\/\/ thread2: q.push(b);\n+\/\/\n+\/\/ This can occur if the push of b started before the push of a, but didn't\n+\/\/ complete until after the pop.\n+\/\/\n+\/\/ \\tparam T is the class of the elements in the queue.\n+\/\/\n+\/\/ \\tparam next_ptr is a function pointer.  Applying this function to\n+\/\/ an object of type T must return a pointer to the list entry member\n+\/\/ of the object associated with the NonblockingQueue type.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+class NonblockingQueue {\n+  T* volatile _head;\n+  \/\/ Padding of one cache line to avoid false sharing.\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(T*));\n+  T* volatile _tail;\n+\n+  NONCOPYABLE(NonblockingQueue);\n+\n+  \/\/ Return the entry following node in the list used by the\n+  \/\/ specialized NonblockingQueue class.\n+  static inline T* next(const T& node);\n+\n+  \/\/ Set the entry following node to new_next in the list used by the\n+  \/\/ specialized NonblockingQueue class. Not thread-safe, as it cannot\n+  \/\/ concurrently run with push or try_pop operations that modify this\n+  \/\/ node.\n+  static inline void set_next(T& node, T* new_next);\n+\n+  \/\/ A unique pseudo-object pointer associated with this specific queue.\n+  \/\/ The resulting pointer must not be dereferenced.\n+  inline T* end_marker() const;\n+\n+public:\n+  inline NonblockingQueue();\n+  inline ~NonblockingQueue() NOT_DEBUG(= default);\n+\n+  \/\/ Return true if the queue is empty.\n+  \/\/ Not thread-safe.  There must be no concurrent modification while the\n+  \/\/ queue is being tested.\n+  inline bool empty() const;\n+\n+  \/\/ Return the number of objects in the queue.\n+  \/\/ Not thread-safe. There must be no concurrent modification while the\n+  \/\/ length is being determined.\n+  inline size_t length() const;\n+\n+  \/\/ Thread-safe add the object to the end of the queue.\n+  inline void push(T& node) { append(node, node); }\n+\n+  \/\/ Thread-safe add the objects from first to last to the end of the queue.\n+  inline void append(T& first, T& last);\n+\n+  \/\/ Thread-safe attempt to remove and return the first object in the queue.\n+  \/\/ Returns true if successful.  If successful then *node_ptr is the former\n+  \/\/ first object, or NULL if the queue was empty.  If unsuccessful, because\n+  \/\/ of contention with a concurrent modification, then returns false with\n+  \/\/ the value of *node_ptr unspecified.  Subject to ABA behavior; callers\n+  \/\/ must ensure usage is safe.\n+  inline bool try_pop(T** node_ptr);\n+\n+  \/\/ Thread-safe remove and return the first object in the queue, or NULL if\n+  \/\/ the queue was empty.  This just iterates on try_pop() until it\n+  \/\/ succeeds, returning the (possibly NULL) element obtained from that.\n+  \/\/ Subject to ABA behavior; callers must ensure usage is safe.\n+  inline T* pop();\n+\n+  \/\/ Take all the objects from the queue, leaving the queue empty.\n+  \/\/ Not thread-safe.  There must be no concurrent operations.\n+  \/\/ Returns a pair of <head, tail> pointers to the current queue.\n+  inline Pair<T*, T*> take_all();\n+\n+  \/\/ Iteration support is provided by first() and is_end().  The queue must\n+  \/\/ not be modified while iterating over its elements.\n+\n+  \/\/ Return the first object in the queue, or an end marker (a pointer p for\n+  \/\/ which is_end(p) is true) if the queue is empty.\n+  inline T* first() const;\n+\n+  \/\/ Test whether entry is an end marker for this queue.\n+  inline bool is_end(const T* entry) const;\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n+#define SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n+\n+#include \"utilities\/nonblockingQueue.hpp\"\n+\n+#include \"runtime\/atomic.hpp\"\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::next(const T& node) {\n+  return Atomic::load(next_ptr(const_cast<T&>(node)));\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+void NonblockingQueue<T, next_ptr>::set_next(T& node, T* new_next) {\n+  Atomic::store(next_ptr(node), new_next);\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+NonblockingQueue<T, next_ptr>::NonblockingQueue() : _head(NULL), _tail(NULL) {}\n+\n+#ifdef ASSERT\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+NonblockingQueue<T, next_ptr>::~NonblockingQueue() {\n+  assert(_head == NULL, \"precondition\");\n+  assert(_tail == NULL, \"precondition\");\n+}\n+#endif\n+\n+\/\/ The end_marker must be uniquely associated with the specific queue, in\n+\/\/ case queue elements can make their way through multiple queues.  A\n+\/\/ pointer to the queue itself (after casting) satisfies that requirement.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::end_marker() const {\n+  return const_cast<T*>(reinterpret_cast<const T*>(this));\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::first() const {\n+  T* head = Atomic::load(&_head);\n+  return head == NULL ? end_marker() : head;\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::is_end(const T* entry) const {\n+  return entry == end_marker();\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::empty() const {\n+  return Atomic::load(&_head) == NULL;\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+size_t NonblockingQueue<T, next_ptr>::length() const {\n+  size_t result = 0;\n+  for (T* cur = first(); !is_end(cur); cur = next(*cur)) {\n+    ++result;\n+  }\n+  return result;\n+}\n+\n+\/\/ An append operation atomically exchanges the new tail with the queue tail.\n+\/\/ It then sets the \"next\" value of the old tail to the head of the list being\n+\/\/ appended. If the old tail is NULL then the queue was empty, then the head\n+\/\/ of the list being appended is instead stored in the queue head.\n+\/\/\n+\/\/ This means there is a period between the exchange and the old tail update\n+\/\/ where the queue sequence is split into two parts, the list from the queue\n+\/\/ head to the old tail, and the list being appended.  If there are concurrent\n+\/\/ push\/append operations, each may introduce another such segment.  But they\n+\/\/ all eventually get resolved by their respective updates of their old tail's\n+\/\/ \"next\" value.  This also means that try_pop operation must handle an object\n+\/\/ with a NULL \"next\" value specially.\n+\/\/\n+\/\/ A push operation is just a degenerate append, where the object being pushed\n+\/\/ is both the head and the tail of the list being appended.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+void NonblockingQueue<T, next_ptr>::append(T& first, T& last) {\n+  assert(next(last) == NULL, \"precondition\");\n+  set_next(last, end_marker());\n+  T* old_tail = Atomic::xchg(&_tail, &last);\n+  bool is_old_tail_null = (old_tail == NULL);\n+  if (is_old_tail_null ||\n+      \/\/ Try to install first as old_tail's next.\n+      !is_end(Atomic::cmpxchg(next_ptr(*old_tail), end_marker(), &first))) {\n+    \/\/ Install first as the new head if either\n+    \/\/ (1) the list was empty, or\n+    \/\/ (2) a concurrent try_pop claimed old_tail, so it is no longer in the list.\n+    \/\/ Note that multiple concurrent push\/append operations cannot modify\n+    \/\/ _head simultaneously, because the Atomic::xchg() above orders these\n+    \/\/ push\/append operations so they perform Atomic::cmpxchg() on different\n+    \/\/ old_tail. Thus, the cmpxchg can only fail because of a concurrent try_pop.\n+    DEBUG_ONLY(T* old_head = Atomic::load(&_head);)\n+    \/\/ If old_tail is NULL, old_head could be NULL, or an unseen object\n+    \/\/ that is being popped.  Otherwise, old_head must be either NULL\n+    \/\/ or the same as old_tail.\n+    assert(is_old_tail_null ||\n+           old_head == NULL || old_head == old_tail, \"invariant\");\n+    Atomic::store(&_head, &first);\n+  }\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::try_pop(T** node_ptr) {\n+  \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n+  \/\/ as the memory_order_consume API is not ready for use yet.\n+  T* result = Atomic::load_acquire(&_head);\n+  if (result == NULL) {\n+    *node_ptr = NULL;\n+    return true;                \/\/ Queue is empty.\n+  }\n+\n+  T* next_node = Atomic::load_acquire(next_ptr(*result));\n+  if (next_node == NULL) {\n+    \/\/ A concurrent try_pop already claimed what was the last entry.  That\n+    \/\/ operation may not have cleared queue head yet, but we should still\n+    \/\/ treat the queue as empty until a push\/append operation changes head\n+    \/\/ to an entry with a non-NULL next value.\n+    *node_ptr = NULL;\n+    return true;\n+\n+  } else if (!is_end(next_node)) {\n+    \/\/ The next_node is not at the end of the queue's list.  Use the \"usual\"\n+    \/\/ lock-free pop from the head of a singly linked list to try to take it.\n+    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n+      \/\/ Former head successfully taken.\n+      set_next(*result, NULL);\n+      *node_ptr = result;\n+      return true;\n+    } else {\n+      \/\/ Lost race to take result from the head of the list.\n+      return false;\n+    }\n+\n+  } else if (is_end(Atomic::cmpxchg(next_ptr(*result), end_marker(), (T*)NULL))) {\n+    \/\/ Result was the last entry and we've claimed it by setting its next\n+    \/\/ value to NULL.  However, this leaves the queue in disarray.  Fix up\n+    \/\/ the queue, possibly in conjunction with other concurrent operations.\n+    \/\/ Any further try_pops will consider the queue empty until a\n+    \/\/ push\/append completes by installing a new head.\n+\n+    \/\/ Attempt to change the queue tail from result to NULL.  Failure of the\n+    \/\/ cmpxchg indicates that a concurrent push\/append updated the tail first.\n+    \/\/ That operation will eventually recognize the old tail (our result) is\n+    \/\/ no longer in the list and update head from the list being appended.\n+    Atomic::cmpxchg(&_tail, result, (T*)NULL);\n+\n+    \/\/ Attempt to change the queue head from result to NULL.  Failure of the\n+    \/\/ cmpxchg indicates a concurrent push\/append updated the head first.\n+    Atomic::cmpxchg(&_head, result, (T*)NULL);\n+\n+    \/\/ The queue has been restored to order, and we can return the result.\n+    *node_ptr = result;\n+    return true;\n+\n+  } else {\n+    \/\/ Result was the last entry in the list, but either a concurrent pop\n+    \/\/ claimed it first or a concurrent push\/append extended the list from\n+    \/\/ it.  Either way, we lost the race.\n+    return false;\n+  }\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::pop() {\n+  T* result = NULL;\n+  \/\/ Typically try_pop() will succeed without retrying many times, thus we\n+  \/\/ omit SpinPause in the loop body.  SpinPause or yield may be worthwhile\n+  \/\/ in rare, highly contended cases, and client code could implement such\n+  \/\/ with try_pop().\n+  while (!try_pop(&result)) {}\n+  return result;\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+Pair<T*, T*> NonblockingQueue<T, next_ptr>::take_all() {\n+  T* tail = Atomic::load(&_tail);\n+  if (tail != NULL) set_next(*tail, NULL); \/\/ Clear end marker.\n+  Pair<T*, T*> result(Atomic::load(&_head), tail);\n+  Atomic::store(&_head, (T*)NULL);\n+  Atomic::store(&_tail, (T*)NULL);\n+  return result;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -156,1 +156,1 @@\n-    if (thread->as_Java_thread()->thread_state() == _thread_in_native) {\n+    if (JavaThread::cast(thread)->thread_state() == _thread_in_native) {\n@@ -267,1 +267,1 @@\n-          RegisterMap map(t->as_Java_thread(), false); \/\/ No update\n+          RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n@@ -753,1 +753,1 @@\n-       print_stack_trace(st, _thread->as_Java_thread(), buf, sizeof(buf));\n+       print_stack_trace(st, JavaThread::cast(_thread), buf, sizeof(buf));\n@@ -762,1 +762,1 @@\n-         JavaThread* jt = thread->as_Java_thread();\n+         JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-            this.keysize = keysize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2113,0 +2113,7 @@\n+     * <p> If the {@code directory} argument is not {@code null} and its\n+     * abstract pathname is valid and denotes an existing, writable directory,\n+     * then the file will be created in that directory. Otherwise the file will\n+     * not be created and an {@code IOException} will be thrown.  Under no\n+     * circumstances will a directory be created at the location specified by\n+     * the {@code directory} argument.\n+     *\n@@ -2130,1 +2137,2 @@\n-     * @throws  IOException  If a file could not be created\n+     * @throws  IOException\n+     *          If a file could not be created\n@@ -2152,0 +2160,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/File.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -563,1 +563,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -631,4 +630,4 @@\n-            String factoryClassName = StaticProperty.jdkSerialFilterFactory();\n-            if (factoryClassName == null) {\n-                \/\/ Fallback to security property\n-                factoryClassName = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+            @SuppressWarnings(\"removal\")\n+            String factoryClassName = StaticProperty.jdkSerialFilterFactory() != null\n+                    ? StaticProperty.jdkSerialFilterFactory()\n+                    : AccessController.doPrivileged((PrivilegedAction<String>) () ->\n@@ -636,1 +635,0 @@\n-            }\n@@ -638,4 +636,4 @@\n-            String filterString = StaticProperty.jdkSerialFilter();\n-            if (filterString == null) {\n-                \/\/ Fallback to security property\n-                filterString = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+            @SuppressWarnings(\"removal\")\n+            String filterString = StaticProperty.jdkSerialFilter() != null\n+                    ? StaticProperty.jdkSerialFilter()\n+                    : AccessController.doPrivileged((PrivilegedAction<String>) () ->\n@@ -643,1 +641,0 @@\n-            }\n@@ -746,0 +743,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -839,0 +837,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -227,2 +226,0 @@\n-        InputStream stream = null;\n-\n@@ -231,9 +228,7 @@\n-            if (System.getSecurityManager() != null) {\n-                stream = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                    public InputStream run() {\n-                        return StringPrep.class.getResourceAsStream(IDN_PROFILE);\n-                    }\n-                });\n-            } else {\n-                stream = StringPrep.class.getResourceAsStream(IDN_PROFILE);\n-            }\n+            @SuppressWarnings(\"removal\")\n+            InputStream stream = System.getSecurityManager() != null\n+                    ? AccessController.doPrivileged(new PrivilegedAction<>() {\n+                            public InputStream run() {\n+                                return StringPrep.class.getResourceAsStream(IDN_PROFILE);\n+                            }})\n+                    : StringPrep.class.getResourceAsStream(IDN_PROFILE);\n","filename":"src\/java.base\/share\/classes\/java\/net\/IDN.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -40,0 +39,1 @@\n+import java.util.Objects;\n@@ -740,1 +740,0 @@\n-    @IntrinsicCandidate\n@@ -742,3 +741,1 @@\n-        if ((i < 0) || (i >= limit))\n-            throw new IndexOutOfBoundsException();\n-        return i;\n+        return Objects.checkIndex(i, limit);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1669,10 +1669,5 @@\n-        StringBuffer sb = new StringBuffer();\n-        sb.append(getClass().getName());\n-        sb.append(\"[pos=\");\n-        sb.append(position());\n-        sb.append(\" lim=\");\n-        sb.append(limit());\n-        sb.append(\" cap=\");\n-        sb.append(capacity());\n-        sb.append(\"]\");\n-        return sb.toString();\n+        return getClass().getName()\n+                 + \"[pos=\" + position()\n+                 + \" lim=\" + limit()\n+                 + \" cap=\" + capacity()\n+                 + \"]\";\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -450,6 +450,2 @@\n-        case INITIAL:\n-            p.print(\"<initialized>\");\n-            break;\n-        case IN_PROGRESS:\n-            p.print(\"<in progress>\");\n-            break;\n+            case INITIAL     -> p.print(\"<initialized>\");\n+            case IN_PROGRESS -> p.print(\"<in progress>\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -950,12 +950,6 @@\n-        String initState = \"\";\n-        switch (state) {\n-        case UNINITIALIZED:\n-            initState = \"<not initialized>\";\n-            break;\n-        case VERIFY:\n-            initState = \"<initialized for verifying>\";\n-            break;\n-        case SIGN:\n-            initState = \"<initialized for signing>\";\n-            break;\n-        }\n+        String initState = switch (state) {\n+            case UNINITIALIZED -> \"<not initialized>\";\n+            case VERIFY        -> \"<initialized for verifying>\";\n+            case SIGN          -> \"<initialized for signing>\";\n+            default -> \"\";\n+        };\n@@ -1320,20 +1314,7 @@\n-            case I_PUB:\n-                spi.engineInitVerify((PublicKey)key);\n-                break;\n-            case I_PUB_PARAM:\n-                spi.engineInitVerify((PublicKey)key, params);\n-                break;\n-            case I_PRIV:\n-                spi.engineInitSign((PrivateKey)key);\n-                break;\n-            case I_PRIV_SR:\n-                spi.engineInitSign((PrivateKey)key, random);\n-                break;\n-            case I_PRIV_PARAM_SR:\n-                spi.engineInitSign((PrivateKey)key, params, random);\n-                break;\n-            case S_PARAM:\n-                spi.engineSetParameter(params);\n-                break;\n-            default:\n-                throw new AssertionError(\"Internal error: \" + type);\n+                case I_PUB           -> spi.engineInitVerify((PublicKey) key);\n+                case I_PUB_PARAM     -> spi.engineInitVerify((PublicKey) key, params);\n+                case I_PRIV          -> spi.engineInitSign((PrivateKey) key);\n+                case I_PRIV_SR       -> spi.engineInitSign((PrivateKey) key, random);\n+                case I_PRIV_PARAM_SR -> spi.engineInitSign((PrivateKey) key, params, random);\n+                case S_PARAM         -> spi.engineSetParameter(params);\n+                default -> throw new AssertionError(\"Internal error: \" + type);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":13,"deletions":32,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -892,23 +892,10 @@\n-            switch (type) {\n-            case NAME_RFC822:\n-                result = new RFC822Name(nameAsString);\n-                break;\n-            case NAME_DNS:\n-                result = new DNSName(nameAsString);\n-                break;\n-            case NAME_DIRECTORY:\n-                result = new X500Name(nameAsString);\n-                break;\n-            case NAME_URI:\n-                result = new URIName(nameAsString);\n-                break;\n-            case NAME_IP:\n-                result = new IPAddressName(nameAsString);\n-                break;\n-            case NAME_OID:\n-                result = new OIDName(nameAsString);\n-                break;\n-            default:\n-                throw new IOException(\"unable to parse String names of type \"\n-                                      + type);\n-            }\n+            result = switch (type) {\n+                case NAME_RFC822    -> new RFC822Name(nameAsString);\n+                case NAME_DNS       -> new DNSName(nameAsString);\n+                case NAME_DIRECTORY -> new X500Name(nameAsString);\n+                case NAME_URI       -> new URIName(nameAsString);\n+                case NAME_IP        -> new IPAddressName(nameAsString);\n+                case NAME_OID       -> new OIDName(nameAsString);\n+                default -> throw new IOException(\"unable to parse String names of type \"\n+                                                 + type);\n+            };\n@@ -926,32 +913,13 @@\n-            switch (type) {\n-            case NAME_ANY:\n-                result = new OtherName(val);\n-                break;\n-            case NAME_RFC822:\n-                result = new RFC822Name(val);\n-                break;\n-            case NAME_DNS:\n-                result = new DNSName(val);\n-                break;\n-            case NAME_X400:\n-                result = new X400Address(val);\n-                break;\n-            case NAME_DIRECTORY:\n-                result = new X500Name(val);\n-                break;\n-            case NAME_EDI:\n-                result = new EDIPartyName(val);\n-                break;\n-            case NAME_URI:\n-                result = new URIName(val);\n-                break;\n-            case NAME_IP:\n-                result = new IPAddressName(val);\n-                break;\n-            case NAME_OID:\n-                result = new OIDName(val);\n-                break;\n-            default:\n-                throw new IOException(\"unable to parse byte array names of \"\n-                    + \"type \" + type);\n-            }\n+            result = switch (type) {\n+                case NAME_ANY       -> new OtherName(val);\n+                case NAME_RFC822    -> new RFC822Name(val);\n+                case NAME_DNS       -> new DNSName(val);\n+                case NAME_X400      -> new X400Address(val);\n+                case NAME_DIRECTORY -> new X500Name(val);\n+                case NAME_EDI       -> new EDIPartyName(val);\n+                case NAME_URI       -> new URIName(val);\n+                case NAME_IP        -> new IPAddressName(val);\n+                case NAME_OID       -> new OIDName(val);\n+                default -> throw new IOException(\"unable to parse byte array names of \"\n+                                                 + \"type \" + type);\n+            };\n@@ -1931,14 +1899,8 @@\n-            switch (extId) {\n-                case PrivateKeyUsage:\n-                    return impl.getPrivateKeyUsageExtension();\n-                case SubjectAlternativeName:\n-                    return impl.getSubjectAlternativeNameExtension();\n-                case NameConstraints:\n-                    return impl.getNameConstraintsExtension();\n-                case CertificatePolicies:\n-                    return impl.getCertificatePoliciesExtension();\n-                case extendedKeyUsage:\n-                    return impl.getExtendedKeyUsageExtension();\n-                default:\n-                    return null;\n-            }\n+            return switch (extId) {\n+                case PrivateKeyUsage        -> impl.getPrivateKeyUsageExtension();\n+                case SubjectAlternativeName -> impl.getSubjectAlternativeNameExtension();\n+                case NameConstraints        -> impl.getNameConstraintsExtension();\n+                case CertificatePolicies    -> impl.getCertificatePoliciesExtension();\n+                case extendedKeyUsage       -> impl.getExtendedKeyUsageExtension();\n+                default -> null;\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CertSelector.java","additions":31,"deletions":69,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -723,7 +723,7 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusSeconds((amountToAdd \/ (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);\n-                case MILLIS: return plusMillis(amountToAdd);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-            }\n-            return plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));\n+            return switch (chronoUnit) {\n+                case NANOS -> plusNanos(amountToAdd);\n+                case MICROS -> plusSeconds((amountToAdd \/ (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);\n+                case MILLIS -> plusMillis(amountToAdd);\n+                case SECONDS -> plusSeconds(amountToAdd);\n+                default -> plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));\n+            };\n@@ -1263,0 +1263,2 @@\n+     * @apiNote\n+     * This method behaves exactly the same way as {@link #toDays()}.\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -607,8 +607,7 @@\n-                switch (chronoField) {\n-                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n-                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n-                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() == Month.FEBRUARY && isLeapYear() == false ? 4 : 5);\n-                    case YEAR_OF_ERA:\n-                        return (getYear() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n-                }\n-                return field.range();\n+                return switch (chronoField) {\n+                    case DAY_OF_MONTH -> ValueRange.of(1, lengthOfMonth());\n+                    case DAY_OF_YEAR -> ValueRange.of(1, lengthOfYear());\n+                    case ALIGNED_WEEK_OF_MONTH -> ValueRange.of(1, getMonth() == Month.FEBRUARY && !isLeapYear() ? 4 : 5);\n+                    case YEAR_OF_ERA -> (getYear() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n+                    default -> field.range();\n+                };\n@@ -869,11 +868,5 @@\n-        switch (month) {\n-            case 2:\n-                return (isLeapYear() ? 29 : 28);\n-            case 4:\n-            case 6:\n-            case 9:\n-            case 11:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (month) {\n+            case 2 -> (isLeapYear() ? 29 : 28);\n+            case 4, 6, 9, 11 -> 30;\n+            default -> 31;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1180,10 +1180,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n-                case MILLIS: return plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-                case MINUTES: return plusMinutes(amountToAdd);\n-                case HOURS: return plusHours(amountToAdd);\n-                case HALF_DAYS: return plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12);  \/\/ no overflow (256 is multiple of 2)\n-            }\n-            return with(date.plus(amountToAdd, unit), time);\n+            return switch (chronoUnit) {\n+                case NANOS     -> plusNanos(amountToAdd);\n+                case MICROS    -> plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n+                case MILLIS    -> plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n+                case SECONDS   -> plusSeconds(amountToAdd);\n+                case MINUTES   -> plusMinutes(amountToAdd);\n+                case HOURS     -> plusHours(amountToAdd);\n+                case HALF_DAYS -> plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12); \/\/ no overflow (256 is multiple of 2)\n+                default -> with(date.plus(amountToAdd, unit), time);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -426,11 +426,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return (leapYear ? 29 : 28);\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> (leapYear ? 29 : 28);\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -449,11 +443,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return 28;\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> 28;\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -472,11 +460,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return 29;\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> 29;\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -497,27 +479,15 @@\n-        switch (this) {\n-            case JANUARY:\n-                return 1;\n-            case FEBRUARY:\n-                return 32;\n-            case MARCH:\n-                return 60 + leap;\n-            case APRIL:\n-                return 91 + leap;\n-            case MAY:\n-                return 121 + leap;\n-            case JUNE:\n-                return 152 + leap;\n-            case JULY:\n-                return 182 + leap;\n-            case AUGUST:\n-                return 213 + leap;\n-            case SEPTEMBER:\n-                return 244 + leap;\n-            case OCTOBER:\n-                return 274 + leap;\n-            case NOVEMBER:\n-                return 305 + leap;\n-            case DECEMBER:\n-            default:\n-                return 335 + leap;\n-        }\n+        return switch (this) {\n+            case JANUARY   -> 1;\n+            case FEBRUARY  -> 32;\n+            case MARCH     -> 60 + leap;\n+            case APRIL     -> 91 + leap;\n+            case MAY       -> 121 + leap;\n+            case JUNE      -> 152 + leap;\n+            case JULY      -> 182 + leap;\n+            case AUGUST    -> 213 + leap;\n+            case SEPTEMBER -> 244 + leap;\n+            case OCTOBER   -> 274 + leap;\n+            case NOVEMBER  -> 305 + leap;\n+            \/\/ otherwise (DECEMBER)\n+            default -> 335 + leap;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Month.java","additions":30,"deletions":60,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -600,7 +600,6 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS:\n-                    throw new UnsupportedTemporalTypeException(\"Invalid field 'InstantSeconds' for get() method, use getLong() instead\");\n-                case OFFSET_SECONDS:\n-                    return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.get(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> throw new UnsupportedTemporalTypeException(\"Invalid field \" +\n+                                         \"'InstantSeconds' for get() method, use getLong() instead\");\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> dateTime.get(field);\n+            };\n@@ -637,5 +636,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> dateTime.getLong(field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -273,18 +273,17 @@\n-        switch (type) {\n-            case DURATION_TYPE: return Duration.readExternal(in);\n-            case INSTANT_TYPE: return Instant.readExternal(in);\n-            case LOCAL_DATE_TYPE: return LocalDate.readExternal(in);\n-            case LOCAL_DATE_TIME_TYPE: return LocalDateTime.readExternal(in);\n-            case LOCAL_TIME_TYPE: return LocalTime.readExternal(in);\n-            case ZONE_DATE_TIME_TYPE: return ZonedDateTime.readExternal(in);\n-            case ZONE_OFFSET_TYPE: return ZoneOffset.readExternal(in);\n-            case ZONE_REGION_TYPE: return ZoneRegion.readExternal(in);\n-            case OFFSET_TIME_TYPE: return OffsetTime.readExternal(in);\n-            case OFFSET_DATE_TIME_TYPE: return OffsetDateTime.readExternal(in);\n-            case YEAR_TYPE: return Year.readExternal(in);\n-            case YEAR_MONTH_TYPE: return YearMonth.readExternal(in);\n-            case MONTH_DAY_TYPE: return MonthDay.readExternal(in);\n-            case PERIOD_TYPE: return Period.readExternal(in);\n-            default:\n-                throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case DURATION_TYPE         -> Duration.readExternal(in);\n+            case INSTANT_TYPE          -> Instant.readExternal(in);\n+            case LOCAL_DATE_TYPE       -> LocalDate.readExternal(in);\n+            case LOCAL_DATE_TIME_TYPE  -> LocalDateTime.readExternal(in);\n+            case LOCAL_TIME_TYPE       -> LocalTime.readExternal(in);\n+            case ZONE_DATE_TIME_TYPE   -> ZonedDateTime.readExternal(in);\n+            case ZONE_OFFSET_TYPE      -> ZoneOffset.readExternal(in);\n+            case ZONE_REGION_TYPE      -> ZoneRegion.readExternal(in);\n+            case OFFSET_TIME_TYPE      -> OffsetTime.readExternal(in);\n+            case OFFSET_DATE_TIME_TYPE -> OffsetDateTime.readExternal(in);\n+            case YEAR_TYPE             -> Year.readExternal(in);\n+            case YEAR_MONTH_TYPE       -> YearMonth.readExternal(in);\n+            case MONTH_DAY_TYPE        -> MonthDay.readExternal(in);\n+            case PERIOD_TYPE           -> Period.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Ser.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -817,7 +817,6 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS:\n-                    throw new UnsupportedTemporalTypeException(\"Invalid field 'InstantSeconds' for get() method, use getLong() instead\");\n-                case OFFSET_SECONDS:\n-                    return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.get(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> throw new UnsupportedTemporalTypeException(\"Invalid field \" +\n+                                         \"'InstantSeconds' for get() method, use getLong() instead\");\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> dateTime.get(field);\n+            };\n@@ -854,5 +853,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> dateTime.getLong(field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -302,10 +302,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n-                case MILLIS: return plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000000);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-                case MINUTES: return plusMinutes(amountToAdd);\n-                case HOURS: return plusHours(amountToAdd);\n-                case HALF_DAYS: return plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12);  \/\/ no overflow (256 is multiple of 2)\n-            }\n-            return with(date.plus(amountToAdd, unit), time);\n+            return switch (chronoUnit) {\n+                case NANOS     -> plusNanos(amountToAdd);\n+                case MICROS    -> plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n+                case MILLIS    -> plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000000);\n+                case SECONDS   -> plusSeconds(amountToAdd);\n+                case MINUTES   -> plusMinutes(amountToAdd);\n+                case HOURS     -> plusHours(amountToAdd);\n+                case HALF_DAYS -> plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12); \/\/ no overflow (256 is multiple of 2)\n+                default -> with(date.plus(amountToAdd, unit), time);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoLocalDateTimeImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -213,5 +213,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return toLocalDateTime().getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> toLocalDateTime().getLong(field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoZonedDateTime.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -294,2 +293,4 @@\n-        CONF_PATH = Path.of(AccessController.doPrivileged((PrivilegedAction<String>)\n-                () -> System.getProperty(\"java.home\")), \"conf\", \"chronology\");\n+        @SuppressWarnings(\"removal\")\n+        String javaHome = AccessController.doPrivileged((PrivilegedAction<String>)\n+                        () -> System.getProperty(\"java.home\"));\n+        CONF_PATH = Path.of(javaHome, \"conf\", \"chronology\");\n@@ -539,15 +540,8 @@\n-            switch (f) {\n-                case DAY_OF_MONTH:\n-                    return ValueRange.of(1, 1, getMinimumMonthLength(), getMaximumMonthLength());\n-                case DAY_OF_YEAR:\n-                    return ValueRange.of(1, getMaximumDayOfYear());\n-                case ALIGNED_WEEK_OF_MONTH:\n-                    return ValueRange.of(1, 5);\n-                case YEAR:\n-                case YEAR_OF_ERA:\n-                    return ValueRange.of(getMinimumYear(), getMaximumYear());\n-                case ERA:\n-                    return ValueRange.of(1, 1);\n-                default:\n-                    return field.range();\n-            }\n+            return switch (f) {\n+                case DAY_OF_MONTH -> ValueRange.of(1, 1, getMinimumMonthLength(), getMaximumMonthLength());\n+                case DAY_OF_YEAR -> ValueRange.of(1, getMaximumDayOfYear());\n+                case ALIGNED_WEEK_OF_MONTH -> ValueRange.of(1, 5);\n+                case YEAR, YEAR_OF_ERA -> ValueRange.of(getMinimumYear(), getMaximumYear());\n+                case ERA -> ValueRange.of(1, 1);\n+                default -> field.range();\n+            };\n@@ -850,1 +844,1 @@\n-        try (InputStream is = AccessController.doPrivileged(getResourceAction, null, perm1, perm2)) {\n+        try (@SuppressWarnings(\"removal\") InputStream is = AccessController.doPrivileged(getResourceAction, null, perm1, perm2)) {\n@@ -1045,0 +1039,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahChronology.java","additions":14,"deletions":19,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -354,4 +354,4 @@\n-                switch (f) {\n-                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n-                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n-                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, 5);  \/\/ TODO\n+                return switch (f) {\n+                    case DAY_OF_MONTH -> ValueRange.of(1, lengthOfMonth());\n+                    case DAY_OF_YEAR -> ValueRange.of(1, lengthOfYear());\n+                    case ALIGNED_WEEK_OF_MONTH -> ValueRange.of(1, 5); \/\/ TODO\n@@ -360,2 +360,2 @@\n-                }\n-                return getChronology().range(f);\n+                    default -> getChronology().range(f);\n+                };\n@@ -371,16 +371,16 @@\n-            switch ((ChronoField) field) {\n-                case DAY_OF_WEEK: return getDayOfWeek();\n-                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((dayOfMonth - 1) % 7) + 1;\n-                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n-                case DAY_OF_MONTH: return this.dayOfMonth;\n-                case DAY_OF_YEAR: return this.getDayOfYear();\n-                case EPOCH_DAY: return toEpochDay();\n-                case ALIGNED_WEEK_OF_MONTH: return ((dayOfMonth - 1) \/ 7) + 1;\n-                case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) \/ 7) + 1;\n-                case MONTH_OF_YEAR: return monthOfYear;\n-                case PROLEPTIC_MONTH: return getProlepticMonth();\n-                case YEAR_OF_ERA: return prolepticYear;\n-                case YEAR: return prolepticYear;\n-                case ERA: return getEraValue();\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch ((ChronoField) field) {\n+                case DAY_OF_WEEK                  ->  getDayOfWeek();\n+                case ALIGNED_DAY_OF_WEEK_IN_MONTH ->  ((dayOfMonth - 1) % 7) + 1;\n+                case ALIGNED_DAY_OF_WEEK_IN_YEAR  ->  ((getDayOfYear() - 1) % 7) + 1;\n+                case DAY_OF_MONTH                 ->  this.dayOfMonth;\n+                case DAY_OF_YEAR                  ->  this.getDayOfYear();\n+                case EPOCH_DAY                    ->  toEpochDay();\n+                case ALIGNED_WEEK_OF_MONTH        ->  ((dayOfMonth - 1) \/ 7) + 1;\n+                case ALIGNED_WEEK_OF_YEAR         ->  ((getDayOfYear() - 1) \/ 7) + 1;\n+                case MONTH_OF_YEAR                ->  monthOfYear;\n+                case PROLEPTIC_MONTH              ->  getProlepticMonth();\n+                case YEAR_OF_ERA                  ->  prolepticYear;\n+                case YEAR                         ->  prolepticYear;\n+                case ERA                          ->  getEraValue();\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -401,16 +401,16 @@\n-            switch (chronoField) {\n-                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek());\n-                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n-                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n-                case DAY_OF_MONTH: return resolvePreviousValid(prolepticYear, monthOfYear, nvalue);\n-                case DAY_OF_YEAR: return plusDays(Math.min(nvalue, lengthOfYear()) - getDayOfYear());\n-                case EPOCH_DAY: return new HijrahDate(chrono, newValue);\n-                case ALIGNED_WEEK_OF_MONTH: return plusDays((newValue - getLong(ALIGNED_WEEK_OF_MONTH)) * 7);\n-                case ALIGNED_WEEK_OF_YEAR: return plusDays((newValue - getLong(ALIGNED_WEEK_OF_YEAR)) * 7);\n-                case MONTH_OF_YEAR: return resolvePreviousValid(prolepticYear, nvalue, dayOfMonth);\n-                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n-                case YEAR_OF_ERA: return resolvePreviousValid(prolepticYear >= 1 ? nvalue : 1 - nvalue, monthOfYear, dayOfMonth);\n-                case YEAR: return resolvePreviousValid(nvalue, monthOfYear, dayOfMonth);\n-                case ERA: return resolvePreviousValid(1 - prolepticYear, monthOfYear, dayOfMonth);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case DAY_OF_WEEK                  ->  plusDays(newValue - getDayOfWeek());\n+                case ALIGNED_DAY_OF_WEEK_IN_MONTH ->  plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n+                case ALIGNED_DAY_OF_WEEK_IN_YEAR  ->  plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n+                case DAY_OF_MONTH                 ->  resolvePreviousValid(prolepticYear, monthOfYear, nvalue);\n+                case DAY_OF_YEAR                  ->  plusDays(Math.min(nvalue, lengthOfYear()) - getDayOfYear());\n+                case EPOCH_DAY                    ->  new HijrahDate(chrono, newValue);\n+                case ALIGNED_WEEK_OF_MONTH        ->  plusDays((newValue - getLong(ALIGNED_WEEK_OF_MONTH)) * 7);\n+                case ALIGNED_WEEK_OF_YEAR         ->  plusDays((newValue - getLong(ALIGNED_WEEK_OF_YEAR)) * 7);\n+                case MONTH_OF_YEAR                ->  resolvePreviousValid(prolepticYear, nvalue, dayOfMonth);\n+                case PROLEPTIC_MONTH              ->  plusMonths(newValue - getProlepticMonth());\n+                case YEAR_OF_ERA                  ->  resolvePreviousValid(prolepticYear >= 1 ? nvalue : 1 - nvalue, monthOfYear, dayOfMonth);\n+                case YEAR                         ->  resolvePreviousValid(nvalue, monthOfYear, dayOfMonth);\n+                case ERA                          ->  resolvePreviousValid(1 - prolepticYear, monthOfYear, dayOfMonth);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahDate.java","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -131,8 +131,5 @@\n-        switch (isoEra) {\n-            case 0:\n-                return BCE;\n-            case 1:\n-                return CE;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + isoEra);\n-        }\n+        return switch (isoEra) {\n+            case 0  -> BCE;\n+            case 1  -> CE;\n+            default -> throw new DateTimeException(\"Invalid era: \" + isoEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/IsoEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -315,2 +315,2 @@\n-        switch (field) {\n-            case PROLEPTIC_MONTH: {\n+        return switch (field) {\n+            case PROLEPTIC_MONTH -> {\n@@ -318,1 +318,1 @@\n-                return ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE * 12L, range.getMaximum() - YEARS_DIFFERENCE * 12L);\n+                yield ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE * 12L, range.getMaximum() - YEARS_DIFFERENCE * 12L);\n@@ -320,1 +320,1 @@\n-            case YEAR_OF_ERA: {\n+            case YEAR_OF_ERA -> {\n@@ -322,1 +322,1 @@\n-                return ValueRange.of(1, range.getMaximum() - YEARS_DIFFERENCE, -range.getMinimum() + 1 + YEARS_DIFFERENCE);\n+                yield ValueRange.of(1, range.getMaximum() - YEARS_DIFFERENCE, -range.getMinimum() + 1 + YEARS_DIFFERENCE);\n@@ -324,1 +324,1 @@\n-            case YEAR: {\n+            case YEAR -> {\n@@ -326,1 +326,1 @@\n-                return ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE, range.getMaximum() - YEARS_DIFFERENCE);\n+                yield ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE, range.getMaximum() - YEARS_DIFFERENCE);\n@@ -328,2 +328,2 @@\n-        }\n-        return field.range();\n+            default -> field.range();\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoChronology.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -318,2 +318,2 @@\n-            switch (chronoField) {\n-                case PROLEPTIC_MONTH:\n+            return switch (chronoField) {\n+                case PROLEPTIC_MONTH -> {\n@@ -321,4 +321,3 @@\n-                    return plusMonths(newValue - getProlepticMonth());\n-                case YEAR_OF_ERA:\n-                case YEAR:\n-                case ERA: {\n+                    yield plusMonths(newValue - getProlepticMonth());\n+                }\n+                case YEAR_OF_ERA -> {\n@@ -326,8 +325,1 @@\n-                    switch (chronoField) {\n-                        case YEAR_OF_ERA:\n-                            return with(isoDate.withYear(getProlepticYear() >= 1 ? nvalue + YEARS_DIFFERENCE : (1 - nvalue)  + YEARS_DIFFERENCE));\n-                        case YEAR:\n-                            return with(isoDate.withYear(nvalue + YEARS_DIFFERENCE));\n-                        case ERA:\n-                            return with(isoDate.withYear((1 - getProlepticYear()) + YEARS_DIFFERENCE));\n-                    }\n+                    yield with(isoDate.withYear(getProlepticYear() >= 1 ? nvalue + YEARS_DIFFERENCE : (1 - nvalue) + YEARS_DIFFERENCE));\n@@ -335,2 +327,8 @@\n-            }\n-            return with(isoDate.with(field, newValue));\n+                case YEAR -> {\n+                    int nvalue = getChronology().range(chronoField).checkValidIntValue(newValue, chronoField);\n+                    yield with(isoDate.withYear(nvalue + YEARS_DIFFERENCE));\n+                }\n+                case ERA -> with(isoDate.withYear((1 - getProlepticYear()) + YEARS_DIFFERENCE));\n+\n+                default -> with(isoDate.with(field, newValue));\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoDate.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -138,8 +138,5 @@\n-        switch (minguoEra) {\n-            case 0:\n-                return BEFORE_ROC;\n-            case 1:\n-                return ROC;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + minguoEra);\n-        }\n+        return switch (minguoEra) {\n+            case 0  -> BEFORE_ROC;\n+            case 1  -> ROC;\n+            default -> throw new DateTimeException(\"Invalid era: \" + minguoEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -248,12 +248,12 @@\n-        switch (type) {\n-            case CHRONO_TYPE: return (Serializable)AbstractChronology.readExternal(in);\n-            case CHRONO_LOCAL_DATE_TIME_TYPE: return (Serializable)ChronoLocalDateTimeImpl.readExternal(in);\n-            case CHRONO_ZONE_DATE_TIME_TYPE: return (Serializable)ChronoZonedDateTimeImpl.readExternal(in);\n-            case JAPANESE_DATE_TYPE:  return JapaneseDate.readExternal(in);\n-            case JAPANESE_ERA_TYPE: return JapaneseEra.readExternal(in);\n-            case HIJRAH_DATE_TYPE: return HijrahDate.readExternal(in);\n-            case MINGUO_DATE_TYPE: return MinguoDate.readExternal(in);\n-            case THAIBUDDHIST_DATE_TYPE: return ThaiBuddhistDate.readExternal(in);\n-            case CHRONO_PERIOD_TYPE: return ChronoPeriodImpl.readExternal(in);\n-            default: throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case CHRONO_TYPE                 -> (Serializable) AbstractChronology.readExternal(in);\n+            case CHRONO_LOCAL_DATE_TIME_TYPE -> (Serializable) ChronoLocalDateTimeImpl.readExternal(in);\n+            case CHRONO_ZONE_DATE_TIME_TYPE  -> (Serializable) ChronoZonedDateTimeImpl.readExternal(in);\n+            case JAPANESE_DATE_TYPE          -> JapaneseDate.readExternal(in);\n+            case JAPANESE_ERA_TYPE           -> JapaneseEra.readExternal(in);\n+            case HIJRAH_DATE_TYPE            -> HijrahDate.readExternal(in);\n+            case MINGUO_DATE_TYPE            -> MinguoDate.readExternal(in);\n+            case THAIBUDDHIST_DATE_TYPE      -> ThaiBuddhistDate.readExternal(in);\n+            case CHRONO_PERIOD_TYPE          -> ChronoPeriodImpl.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/Ser.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -351,2 +351,2 @@\n-        switch (field) {\n-            case PROLEPTIC_MONTH: {\n+        return switch (field) {\n+            case PROLEPTIC_MONTH -> {\n@@ -354,1 +354,1 @@\n-                return ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE * 12L, range.getMaximum() + YEARS_DIFFERENCE * 12L);\n+                yield ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE * 12L, range.getMaximum() + YEARS_DIFFERENCE * 12L);\n@@ -356,1 +356,1 @@\n-            case YEAR_OF_ERA: {\n+            case YEAR_OF_ERA -> {\n@@ -358,1 +358,1 @@\n-                return ValueRange.of(1, -(range.getMinimum() + YEARS_DIFFERENCE) + 1, range.getMaximum() + YEARS_DIFFERENCE);\n+                yield ValueRange.of(1, -(range.getMinimum() + YEARS_DIFFERENCE) + 1, range.getMaximum() + YEARS_DIFFERENCE);\n@@ -360,1 +360,1 @@\n-            case YEAR: {\n+            case YEAR -> {\n@@ -362,1 +362,1 @@\n-                return ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE, range.getMaximum() + YEARS_DIFFERENCE);\n+                yield ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE, range.getMaximum() + YEARS_DIFFERENCE);\n@@ -364,2 +364,2 @@\n-        }\n-        return field.range();\n+            default -> field.range();\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ThaiBuddhistChronology.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -138,8 +138,5 @@\n-        switch (thaiBuddhistEra) {\n-            case 0:\n-                return BEFORE_BE;\n-            case 1:\n-                return BE;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + thaiBuddhistEra);\n-        }\n+        return switch (thaiBuddhistEra) {\n+            case 0  -> BEFORE_BE;\n+            case 1  -> BE;\n+            default -> throw new DateTimeException(\"Invalid era: \" + thaiBuddhistEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ThaiBuddhistEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2549,4 +2549,4 @@\n-                case 0: context.setCaseSensitive(true); break;\n-                case 1: context.setCaseSensitive(false); break;\n-                case 2: context.setStrict(true); break;\n-                case 3: context.setStrict(false); break;\n+                case 0 -> context.setCaseSensitive(true);\n+                case 1 -> context.setCaseSensitive(false);\n+                case 2 -> context.setStrict(true);\n+                case 3 -> context.setStrict(false);\n@@ -2790,9 +2790,4 @@\n-                    case NORMAL:\n-                    case EXCEEDS_PAD:\n-                    case ALWAYS:\n-                        buf.append(decimalStyle.getNegativeSign());\n-                        break;\n-                    case NOT_NEGATIVE:\n-                        throw new DateTimeException(\"Field \" + field +\n-                            \" cannot be printed as the value \" + value +\n-                            \" cannot be negative according to the SignStyle\");\n+                    case NORMAL, EXCEEDS_PAD, ALWAYS -> buf.append(decimalStyle.getNegativeSign());\n+                    case NOT_NEGATIVE -> throw new DateTimeException(\"Field \" + field +\n+                                             \" cannot be printed as the value \" + value +\n+                                             \" cannot be negative according to the SignStyle\");\n@@ -4131,7 +4126,5 @@\n-            switch (type) {\n-            case STD:\n-                return names[textStyle.zoneNameStyleIndex() + 1];\n-            case DST:\n-                return names[textStyle.zoneNameStyleIndex() + 3];\n-            }\n-            return names[textStyle.zoneNameStyleIndex() + 5];\n+            return switch (type) {\n+                case STD -> names[textStyle.zoneNameStyleIndex() + 1];\n+                case DST -> names[textStyle.zoneNameStyleIndex() + 3];\n+                default  -> names[textStyle.zoneNameStyleIndex() + 5];\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -126,11 +126,5 @@\n-        switch (ordinal()) {\n-            case 0: \/\/ NORMAL\n-                \/\/ valid if negative or (positive and lenient)\n-                return !positive || !strict;\n-            case 1: \/\/ ALWAYS\n-            case 4: \/\/ EXCEEDS_PAD\n-                return true;\n-            default:\n-                \/\/ valid if lenient and not fixed width\n-                return !strict && !fixedWidth;\n-        }\n+        return switch (ordinal()) {\n+            case 0 -> !positive || !strict; \/\/ NORMAL - valid if negative or (positive and lenient)\n+            case 1, 4 -> true; \/\/ ALWAYS, EXCEEDS_PAD\n+            default -> !strict && !fixedWidth; \/\/ valid if lenient and not fixed width\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/SignStyle.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -706,10 +706,7 @@\n-            switch (this) {\n-                case WEEK_BASED_YEARS:\n-                    return (R) temporal.with(WEEK_BASED_YEAR,\n-                            Math.addExact(temporal.get(WEEK_BASED_YEAR), amount));\n-                case QUARTER_YEARS:\n-                    return (R) temporal.plus(amount \/ 4, YEARS)\n-                            .plus((amount % 4) * 3, MONTHS);\n-                default:\n-                    throw new IllegalStateException(\"Unreachable\");\n-            }\n+            return switch (this) {\n+                case WEEK_BASED_YEARS -> (R) temporal.with(WEEK_BASED_YEAR,\n+                                          Math.addExact(temporal.get(WEEK_BASED_YEAR), amount));\n+                case QUARTER_YEARS -> (R) temporal.plus(amount \/ 4, YEARS)\n+                                       .plus((amount % 4) * 3, MONTHS);\n+                default -> throw new IllegalStateException(\"Unreachable\");\n+            };\n@@ -723,9 +720,6 @@\n-            switch(this) {\n-                case WEEK_BASED_YEARS:\n-                    return Math.subtractExact(temporal2Exclusive.getLong(WEEK_BASED_YEAR),\n-                            temporal1Inclusive.getLong(WEEK_BASED_YEAR));\n-                case QUARTER_YEARS:\n-                    return temporal1Inclusive.until(temporal2Exclusive, MONTHS) \/ 3;\n-                default:\n-                    throw new IllegalStateException(\"Unreachable\");\n-            }\n+            return switch (this) {\n+                case WEEK_BASED_YEARS -> Math.subtractExact(temporal2Exclusive.getLong(WEEK_BASED_YEAR),\n+                                          temporal1Inclusive.getLong(WEEK_BASED_YEAR));\n+                case QUARTER_YEARS -> temporal1Inclusive.until(temporal2Exclusive, MONTHS) \/ 3;\n+                default -> throw new IllegalStateException(\"Unreachable\");\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/IsoFields.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -194,10 +194,6 @@\n-        switch (type) {\n-            case ZRULES:\n-                return ZoneRules.readExternal(in);\n-            case ZOT:\n-                return ZoneOffsetTransition.readExternal(in);\n-            case ZOTRULE:\n-                return ZoneOffsetTransitionRule.readExternal(in);\n-            default:\n-                throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case ZRULES -> ZoneRules.readExternal(in);\n+            case ZOT -> ZoneOffsetTransition.readExternal(in);\n+            case ZOTRULE -> ZoneOffsetTransitionRule.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/zone\/Ser.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -150,13 +149,20 @@\n-        final List<ZoneRulesProvider> loaded = new ArrayList<>();\n-        AccessController.doPrivileged(new PrivilegedAction<>() {\n-            public Object run() {\n-                String prop = System.getProperty(\"java.time.zone.DefaultZoneRulesProvider\");\n-                if (prop != null) {\n-                    try {\n-                        Class<?> c = Class.forName(prop, true, ClassLoader.getSystemClassLoader());\n-                        @SuppressWarnings(\"deprecation\")\n-                        ZoneRulesProvider provider = ZoneRulesProvider.class.cast(c.newInstance());\n-                        registerProvider(provider);\n-                        loaded.add(provider);\n-                    } catch (Exception x) {\n-                        throw new Error(x);\n+        @SuppressWarnings(\"removal\")\n+        final List<ZoneRulesProvider> loaded =\n+                AccessController.doPrivileged(new PrivilegedAction<List<ZoneRulesProvider>>() {\n+                    public List<ZoneRulesProvider> run() {\n+                        List<ZoneRulesProvider> result = new ArrayList<>();\n+                        String prop = System.getProperty(\"java.time.zone.DefaultZoneRulesProvider\");\n+                        if (prop != null) {\n+                            try {\n+                                Class<?> c = Class.forName(prop, true, ClassLoader.getSystemClassLoader());\n+                                @SuppressWarnings(\"deprecation\")\n+                                ZoneRulesProvider provider = ZoneRulesProvider.class.cast(c.newInstance());\n+                                registerProvider(provider);\n+                                result.add(provider);\n+                            } catch (Exception x) {\n+                                throw new Error(x);\n+                            }\n+                        } else {\n+                            registerProvider(new TzdbZoneRulesProvider());\n+                        }\n+                        return result;\n@@ -164,6 +170,1 @@\n-                } else {\n-                    registerProvider(new TzdbZoneRulesProvider());\n-                }\n-                return null;\n-            }\n-        });\n+                });\n","filename":"src\/java.base\/share\/classes\/java\/time\/zone\/ZoneRulesProvider.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -756,4 +756,0 @@\n-         * If the intrinsic function does not process all of the bytes in\n-         * src, it must process a multiple of four of them, making the\n-         * returned destination length a multiple of three.\n-         *\n@@ -765,1 +761,4 @@\n-         * containing pad characters.\n+         * containing pad characters.  However, MIME decoding ignores\n+         * illegal characters, so any intrinsic overriding decodeBlock\n+         * can choose how to handle illegal characters based on the isMIME\n+         * parameter.\n@@ -782,0 +781,2 @@\n+         * @param  isMIME\n+         *         boolean, when true decode according to RFC2045 (ignore illegal chars)\n@@ -785,1 +786,1 @@\n-        private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {\n+        private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME) {\n@@ -813,1 +814,1 @@\n-                    int dl = decodeBlock(src, sp, sl, dst, dp, isURL);\n+                    int dl = decodeBlock(src, sp, sl, dst, dp, isURL, isMIME);\n@@ -818,1 +819,1 @@\n-                    int chars_decoded = (dl \/ 3) * 4;\n+                    int chars_decoded = ((dl + 2) \/ 3) * 4;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -213,0 +212,5 @@\n+        initStatic();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void initStatic() {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Currency.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"})\n+@SuppressWarnings(\"serial\")\n@@ -385,2 +385,2 @@\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            BASE = l.findVarHandle(Striped64.class,\n+            MethodHandles.Lookup l1 = MethodHandles.lookup();\n+            BASE = l1.findVarHandle(Striped64.class,\n@@ -388,1 +388,1 @@\n-            CELLSBUSY = l.findVarHandle(Striped64.class,\n+            CELLSBUSY = l1.findVarHandle(Striped64.class,\n@@ -390,1 +390,2 @@\n-            l = java.security.AccessController.doPrivileged(\n+            @SuppressWarnings(\"removal\")\n+            MethodHandles.Lookup l2 = java.security.AccessController.doPrivileged(\n@@ -399,1 +400,1 @@\n-            THREAD_PROBE = l.findVarHandle(Thread.class,\n+            THREAD_PROBE = l2.findVarHandle(Thread.class,\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+        String cwd = new File(\"\").getAbsolutePath(); \/\/ current dir used for printing message.\n@@ -302,2 +303,2 @@\n-            String stdOutFile = drainOutput(proc.getInputStream(), proc.pid(), \"stdout\", cmds);\n-            String stdErrFile = drainOutput(proc.getErrorStream(), proc.pid(), \"stderr\", cmds);\n+            String stdOutFileName = drainOutput(proc.getInputStream(), proc.pid(), \"stdout\", cmds);\n+            String stdErrFileName = drainOutput(proc.getErrorStream(), proc.pid(), \"stderr\", cmds);\n@@ -314,2 +315,2 @@\n-                                            stdOutFile + \" or stderr file \" +\n-                                            stdErrFile + \" for more detail\");\n+                                            cwd + File.separator + stdOutFileName + \" or stderr file \" +\n+                                            cwd + File.separator + stdErrFileName + \" for more detail\");\n@@ -321,1 +322,2 @@\n-                                           \" is not created, please check process \" +\n+                                           \" is not created, please check current working directory \" +\n+                                           cwd  + \" for process \" +\n@@ -334,1 +336,1 @@\n-        System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + archiveFileName);\n+        System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + cwd + File.separator + archiveFileName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V17) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V18) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+    int V18 = 0 << 16 | 62;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -47,3 +46,2 @@\n-    private static String tempFileTemplate;\n-\n-    static {\n+    @SuppressWarnings(\"removal\")\n+    private static String tempFileTemplate =\n@@ -51,18 +49,6 @@\n-            new java.security.PrivilegedAction<Void>() {\n-                public Void run() {\n-                tempFileTemplate =\n-                    System.getProperty(\"content.types.temp.file.template\",\n-                                       \"\/tmp\/%s\");\n-\n-                mailcapLocations = new String[] {\n-                    System.getProperty(\"user.mailcap\"),\n-                    StaticProperty.userHome() + \"\/.mailcap\",\n-                    \"\/etc\/mailcap\",\n-                    \"\/usr\/etc\/mailcap\",\n-                    \"\/usr\/local\/etc\/mailcap\",\n-                };\n-                return null;\n-            }\n-        });\n-    }\n-\n+                new java.security.PrivilegedAction<String>() {\n+                    public String run() {\n+                        return System.getProperty(\"content.types.temp.file.template\",\n+                                \"\/tmp\/%s\");\n+                    }\n+                });\n@@ -80,0 +66,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -223,1 +210,14 @@\n-    protected static String[] mailcapLocations;\n+    @SuppressWarnings(\"removal\")\n+    protected static String[] mailcapLocations =\n+        java.security.AccessController.doPrivileged(\n+                new java.security.PrivilegedAction<String[]>() {\n+                    public String[] run() {\n+                        return new String[]{\n+                                System.getProperty(\"user.mailcap\"),\n+                                StaticProperty.userHome() + \"\/.mailcap\",\n+                                \"\/etc\/mailcap\",\n+                                \"\/usr\/etc\/mailcap\",\n+                                \"\/usr\/local\/etc\/mailcap\",\n+                        };\n+                    }\n+                });\n@@ -391,0 +391,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MimeTable.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -73,3 +72,2 @@\n-    static final boolean serializeAuth;\n-    static {\n-        serializeAuth = java.security.AccessController.doPrivileged(\n+    @SuppressWarnings(\"removal\")\n+    static final boolean serializeAuth = java.security.AccessController.doPrivileged(\n@@ -78,1 +76,0 @@\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationInfo.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -506,0 +506,3 @@\n+        if (!arrayType.isArray()) {\n+            return parseUnknownArray(length, buf);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.TreeSet;\n@@ -51,1 +52,1 @@\n-    static List<String> getAlgorithms(String propertyName) {\n+    static Set<String> getAlgorithms(String propertyName) {\n@@ -76,1 +77,1 @@\n-            return Collections.emptyList();\n+            return Collections.emptySet();\n@@ -78,1 +79,3 @@\n-        return new ArrayList<>(Arrays.asList(algorithmsInProperty));\n+        Set<String> algorithmsInPropertySet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n+        algorithmsInPropertySet.addAll(Arrays.asList(algorithmsInProperty));\n+        return algorithmsInPropertySet;\n@@ -81,1 +84,1 @@\n-    static boolean checkAlgorithm(List<String> algorithms, String algorithm,\n+    static boolean checkAlgorithm(Set<String> algorithms, String algorithm,\n@@ -87,10 +90,3 @@\n-        Set<String> elements = null;\n-        for (String item : algorithms) {\n-            if (item == null || item.isEmpty()) {\n-                continue;\n-            }\n-\n-            \/\/ check the full name\n-            if (item.equalsIgnoreCase(algorithm)) {\n-                return false;\n-            }\n+        if (algorithms.contains(algorithm)) {\n+            return false;\n+        }\n@@ -98,4 +94,2 @@\n-            \/\/ decompose the algorithm into sub-elements\n-            if (elements == null) {\n-                elements = decomposer.decompose(algorithm);\n-            }\n+        \/\/ decompose the algorithm into sub-elements\n+        Set<String> elements = decomposer.decompose(algorithm);\n@@ -103,5 +97,4 @@\n-            \/\/ check the items of the algorithm\n-            for (String element : elements) {\n-                if (item.equalsIgnoreCase(element)) {\n-                    return false;\n-                }\n+        \/\/ check the element of the elements\n+        for (String element : elements) {\n+            if (algorithms.contains(element)) {\n+                return false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AbstractAlgorithmConstraints.java","additions":16,"deletions":23,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+    private static final Pattern INCLUDE_PATTERN = Pattern.compile(\"include \" +\n+            PROPERTY_DISABLED_EC_CURVES, Pattern.CASE_INSENSITIVE);\n+\n@@ -98,1 +101,1 @@\n-    private final List<String> disabledAlgorithms;\n+    private final Set<String> disabledAlgorithms;\n@@ -133,1 +136,0 @@\n-        int ecindex = -1, i = 0;\n@@ -135,6 +137,6 @@\n-            if (s.regionMatches(true, 0,\"include \", 0, 8)) {\n-                if (s.regionMatches(true, 8, PROPERTY_DISABLED_EC_CURVES, 0,\n-                        PROPERTY_DISABLED_EC_CURVES.length())) {\n-                    ecindex = i;\n-                    break;\n-                }\n+            Matcher matcher = INCLUDE_PATTERN.matcher(s);\n+            if (matcher.matches()) {\n+                disabledAlgorithms.remove(matcher.group());\n+                disabledAlgorithms.addAll(\n+                        getAlgorithms(PROPERTY_DISABLED_EC_CURVES));\n+                break;\n@@ -142,6 +144,0 @@\n-            i++;\n-        }\n-        if (ecindex > -1) {\n-            disabledAlgorithms.remove(ecindex);\n-            disabledAlgorithms.addAll(ecindex,\n-                    getAlgorithms(PROPERTY_DISABLED_EC_CURVES));\n@@ -335,2 +331,2 @@\n-        public Constraints(String propertyName, List<String> constraintArray) {\n-            for (String constraintEntry : constraintArray) {\n+        public Constraints(String propertyName, Set<String> constraintSet) {\n+            for (String constraintEntry : constraintSet) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private final List<String> legacyAlgorithms;\n+    private final Set<String> legacyAlgorithms;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/LegacyAlgorithmConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -252,0 +251,5 @@\n+        loadTZDB();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadTZDB() {\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/ZoneInfoFile.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JAVA\" \"1\" \"2021\" \"JDK 17\\-ea\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2021\" \"JDK 18\\-ea\" \"JDK Commands\"\n@@ -184,1 +184,1 @@\n-(\\f[CB]17\\f[R]) and a limited number of previous releases, detailed in the\n+(\\f[CB]18\\f[R]) and a limited number of previous releases, detailed in the\n@@ -3999,10 +3999,0 @@\n-.TP\n-.B \\f[CB]\\-XX:+UseBiasedLocking\\f[R]\n-Enables the use of biased locking.\n-Some applications with significant amounts of uncontended\n-synchronization may attain significant speedups with this flag enabled,\n-but applications with certain patterns of locking may see slowdowns.\n-.RS\n-.PP\n-By default, this option is disabled.\n-.RE\n@@ -4023,8 +4013,0 @@\n-.SH REMOVED JAVA OPTIONS\n-.PP\n-These \\f[CB]java\\f[R] options have been removed in JDK 17 and using them\n-results in an error of:\n-.RS\n-.PP\n-\\f[CB]Unrecognized\\ VM\\ option\\f[R] \\f[I]option\\-name\\f[R]\n-.RE\n@@ -4032,52 +4014,5 @@\n-.B \\f[CB]\\-XX:+UseMembar\\f[R]\n-Enabled issuing membars on thread\\-state transitions.\n-This option was disabled by default on all platforms except ARM servers,\n-where it was enabled.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:MaxPermSize=\\f[R]\\f[I]size\\f[R]\n-Sets the maximum permanent generation space size (in bytes).\n-This option was deprecated in JDK 8 and superseded by the\n-\\f[CB]\\-XX:MaxMetaspaceSize\\f[R] option.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:PermSize=\\f[R]\\f[I]size\\f[R]\n-Sets the space (in bytes) allocated to the permanent generation that\n-triggers a garbage collection if it\\[aq]s exceeded.\n-This option was deprecated in JDK 8 and superseded by the\n-\\f[CB]\\-XX:MetaspaceSize\\f[R] option.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:+TraceClassLoading\\f[R]\n-Enables tracing of classes as they are loaded.\n-By default, this option is disabled and classes aren\\[aq]t traced.\n-.RS\n-.PP\n-The replacement Unified Logging syntax is\n-\\f[CB]\\-Xlog:class+load=\\f[R]\\f[I]level\\f[R].\n-See \\f[B]Enable Logging with the JVM Unified Logging Framework\\f[R]\n-.PP\n-Use \\f[I]level\\f[R]=\\f[CB]info\\f[R] for regular information, or\n-\\f[I]level\\f[R]=\\f[CB]debug\\f[R] for additional information.\n-In Unified Logging syntax, \\f[CB]\\-verbose:class\\f[R] equals\n-\\f[CB]\\-Xlog:class+load=info,class+unload=info\\f[R].\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:+TraceClassLoadingPreorder\\f[R]\n-Enables tracing of all loaded classes in the order in which they\\[aq]re\n-referenced.\n-By default, this option is disabled and classes aren\\[aq]t traced.\n-.RS\n-.PP\n-The replacement Unified Logging syntax is\n-\\f[CB]\\-Xlog:class+preorder=debug\\f[R].\n-See \\f[B]Enable Logging with the JVM Unified Logging Framework\\f[R].\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:+TraceClassResolution\\f[R]\n-Enables tracing of constant pool resolutions.\n-By default, this option is disabled and constant pool resolutions\n-aren\\[aq]t traced.\n+.B \\f[CB]\\-XX:+UseBiasedLocking\\f[R]\n+Enables the use of biased locking.\n+Some applications with significant amounts of uncontended\n+synchronization may attain significant speedups with this flag enabled,\n+but applications with certain patterns of locking may see slowdowns.\n@@ -4086,3 +4021,1 @@\n-The replacement Unified Logging syntax is\n-\\f[CB]\\-Xlog:class+resolve=debug\\f[R].\n-See \\f[B]Enable Logging with the JVM Unified Logging Framework\\f[R].\n+By default, this option is disabled.\n@@ -4090,6 +4023,1 @@\n-.TP\n-.B \\f[CB]\\-XX:+TraceLoaderConstraints\\f[R]\n-Enables tracing of the loader constraints recording.\n-By default, this option is disabled and loader constraints recording\n-isn\\[aq]t traced.\n-.RS\n+.SH REMOVED JAVA OPTIONS\n@@ -4097,4 +4025,1 @@\n-The replacement Unified Logging syntax is\n-\\f[CB]\\-Xlog:class+loader+constraints=info\\f[R].\n-See \\f[B]Enable Logging with the JVM Unified Logging Framework\\f[R].\n-.RE\n+No documented \\f[CB]java\\f[R] options have been removed in JDK 18.\n@@ -4105,1 +4030,4 @@\n-\\f[B]Java Platform, Standard Edition Tools Reference, Release 16\\f[R]\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 17\\f[R]\n+[https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/specs\/man\/java.html]\n+.IP \\[bu] 2\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 16\\f[R]\n@@ -4108,1 +4036,1 @@\n-\\f[B]Java Platform, Standard Edition Tools Reference, Release 15\\f[R]\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 15\\f[R]\n@@ -4111,1 +4039,1 @@\n-\\f[B]Java Platform, Standard Edition Tools Reference, Release 14\\f[R]\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 14\\f[R]\n@@ -4114,1 +4042,1 @@\n-\\f[B]Java Platform, Standard Edition Tools Reference, Release 13\\f[R]\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 13\\f[R]\n@@ -4937,8 +4865,0 @@\n-\\f[CB]TraceBiasedLocking\\f[R]\n-T}@T{\n-\\f[CB]\\-Xlog:biasedlocking=\\f[R]\\f[I]level\\f[R]\n-T}@T{\n-Use \\f[I]level\\f[R]=\\f[CB]info\\f[R] for regular information, or\n-\\f[I]level\\f[R]=\\f[CB]trace\\f[R] for additional information.\n-T}\n-T{\n","filename":"src\/java.base\/share\/man\/java.1","additions":17,"deletions":97,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,1 @@\n-    fos_fd =\n-        (*env)->GetFieldID(env, fosClass, \"fd\", \"Ljava\/io\/FileDescriptor;\");\n+    fos_fd = (*env)->GetFieldID(env, fosClass, \"fd\", \"Ljava\/io\/FileDescriptor;\");\n@@ -70,2 +69,1 @@\n-    jobject this, jbyteArray bytes, jint off, jint len, jboolean append)\n-{\n+    jobject this, jbyteArray bytes, jint off, jint len, jboolean append) {\n","filename":"src\/java.base\/share\/native\/libjava\/FileOutputStream.c","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"src\/java.base\/windows\/native\/libjava\/FileOutputStream_md.c","status":"renamed"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-\n-#include \"io_util.h\"\n-#include \"io_util_md.h\"\n-#include \"java_io_FileOutputStream.h\"\n-\n-#include <fcntl.h>\n-\n-\/*******************************************************************\/\n-\/*  BEGIN JNI ********* BEGIN JNI *********** BEGIN JNI ************\/\n-\/*******************************************************************\/\n-\n-jfieldID fos_fd; \/* id for jobject 'fd' in java.io.FileOutputStream *\/\n-\n-\/**************************************************************\n- * static methods to store field ID's in initializers\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_io_FileOutputStream_initIDs(JNIEnv *env, jclass fdClass) {\n-    fos_fd = (*env)->GetFieldID(env, fdClass, \"fd\", \"Ljava\/io\/FileDescriptor;\");\n-}\n-\n-\/**************************************************************\n- * Output stream\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_io_FileOutputStream_open0(JNIEnv *env, jobject this,\n-                                    jstring path, jboolean append) {\n-    fileOpen(env, this, path, fos_fd,\n-             O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC));\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_java_io_FileOutputStream_write(JNIEnv *env, jobject this, jint byte, jboolean append) {\n-    writeSingle(env, this, byte, append, fos_fd);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_java_io_FileOutputStream_writeBytes(JNIEnv *env,\n-    jobject this, jbyteArray bytes, jint off, jint len, jboolean append) {\n-    writeBytes(env, this, bytes, off, len, append, fos_fd);\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/FileOutputStream_md.c","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,9 @@\n-    RELEASE_17;\n+    RELEASE_17,\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 18.\n+     *\n+     * @since 18\n+     *\/\n+    RELEASE_18;\n@@ -249,1 +257,1 @@\n-        return RELEASE_17;\n+        return RELEASE_18;\n@@ -264,1 +272,1 @@\n-            valueOf(\"RELEASE_\" + Math.min(17, intVersion)):\n+            valueOf(\"RELEASE_\" + Math.min(18, intVersion)):\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -63,0 +64,1 @@\n+    private AtomicReference<Throwable> printErrorRef = new AtomicReference<>();\n@@ -326,0 +328,1 @@\n+            printErrorRef.set(null);\n@@ -384,0 +387,9 @@\n+\n+            Throwable printError = printErrorRef.getAndSet(null);\n+            if (printError != null) {\n+                if (printError instanceof PrinterException) {\n+                    throw (PrinterException) printError;\n+                }\n+                throw (PrinterException)\n+                    new PrinterException().initCause(printError);\n+            }\n@@ -789,5 +801,13 @@\n-        Runnable r = new Runnable() { public void run() { synchronized(ret) {\n-            try {\n-                int pageResult = printable.print(graphics, pageFormat, pageIndex);\n-                if (pageResult != Printable.NO_SUCH_PAGE) {\n-                    ret[0] = getPageFormatArea(pageFormat);\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                synchronized (ret) {\n+                    try {\n+                        int pageResult = printable.print(\n+                            graphics, pageFormat, pageIndex);\n+                        if (pageResult != Printable.NO_SUCH_PAGE) {\n+                            ret[0] = getPageFormatArea(pageFormat);\n+                        }\n+                    } catch (Throwable t) {\n+                        printErrorRef.compareAndSet(null, t);\n+                    }\n@@ -795,2 +815,2 @@\n-            } catch (Exception e) {} \/\/ Original code bailed on any exception\n-        }}};\n+            }\n+        };\n@@ -799,1 +819,5 @@\n-            try { EventQueue.invokeAndWait(r); } catch (Exception e) { e.printStackTrace(); }\n+            try {\n+                EventQueue.invokeAndWait(r);\n+            } catch (Throwable t) {\n+                printErrorRef.compareAndSet(null, t);\n+            }\n@@ -804,1 +828,3 @@\n-        synchronized(ret) { return ret[0]; }\n+        synchronized (ret) {\n+            return ret[0];\n+        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterJob.java","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-     * Changes this application's icon to the provided image.\n+     * Requests the system to change this application's icon to the provided {@code image}.\n@@ -343,0 +343,4 @@\n+     * @apiNote The returned icon image may not be equal\n+     * to an image set by {@link java.awt.Taskbar#setIconImage},\n+     * but should be visually similar.\n+     *\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Taskbar.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -477,0 +477,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -601,0 +602,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -888,0 +890,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -923,0 +926,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1015,0 +1019,5 @@\n+        loadNativeLib();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadNativeLib() {\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"})  \/\/ serialVersionUID not constant\n+@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -122,10 +122,2 @@\n-        String form = null;\n-        boolean compat = false;\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            form = AccessController.doPrivileged(act);\n-            compat = \"1.0\".equals(form);  \/\/ form may be null\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        serialForm = form;\n+        serialForm = getForm();\n+        boolean compat = \"1.0\".equals(serialForm);  \/\/ serialForm may be null\n@@ -140,0 +132,13 @@\n+\n+    @SuppressWarnings(\"removal\")\n+    private static String getForm() {\n+        String form = null;\n+        try {\n+            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n+            return  AccessController.doPrivileged(act);\n+        } catch (Exception e) {\n+            \/\/ OK: No compat with 1.0\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/DescriptorSupport.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -167,12 +166,1 @@\n-            \/\/ Create cleaner to expire idle connections\n-            PrivilegedAction<Void> pa = new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    Thread t = InnocuousThread.newSystemThread(\n-                            \"LDAP PoolCleaner\",\n-                            new PoolCleaner(idleTimeout, pools));\n-                    assert t.getContextClassLoader() == null;\n-                    t.setDaemon(true);\n-                    t.start();\n-                    return null;\n-                }};\n-            AccessController.doPrivileged(pa);\n+            startCleanerThread();\n@@ -186,0 +174,16 @@\n+    @SuppressWarnings(\"removal\")\n+    private static void startCleanerThread() {\n+        \/\/ Create cleaner to expire idle connections\n+        PrivilegedAction<Void> pa = new PrivilegedAction<Void>() {\n+            public Void run() {\n+                Thread t = InnocuousThread.newSystemThread(\n+                        \"LDAP PoolCleaner\",\n+                        new PoolCleaner(idleTimeout, pools));\n+                assert t.getContextClassLoader() == null;\n+                t.setDaemon(true);\n+                t.start();\n+                return null;\n+            }};\n+        AccessController.doPrivileged(pa);\n+    }\n+\n@@ -399,0 +403,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -404,0 +409,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -409,0 +415,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapPoolManager.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-final class HttpClientFacade extends HttpClient implements Trackable {\n+public final class HttpClientFacade extends HttpClient implements Trackable {\n@@ -113,0 +113,4 @@\n+    public Executor theExecutor() {\n+        return impl.theExecutor();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientFacade.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private final boolean server;\n+    private int maskingKey;\n@@ -65,0 +67,4 @@\n+        this(output, false);\n+    }\n+\n+    MessageDecoder(MessageStreamConsumer output, boolean server) {\n@@ -66,0 +72,1 @@\n+        this.server = server;\n@@ -146,1 +153,1 @@\n-        if (value) {\n+        if (value && !server) {\n@@ -149,0 +156,3 @@\n+        if (!value && server) {\n+            throw new FailWebSocketException(\"Masked frame expected\");\n+        }\n@@ -178,1 +188,3 @@\n-        throw new InternalError();\n+        if (!server)\n+            throw new InternalError();\n+        maskingKey = value;\n@@ -207,1 +219,5 @@\n-                output.onBinary(data.slice(), last);\n+                ByteBuffer slice = data.slice();\n+                if (server) {\n+                    unMask(slice);\n+                }\n+                output.onBinary(slice, last);\n@@ -211,0 +227,3 @@\n+                if (server) {\n+                    unMask(data);\n+                }\n@@ -228,0 +247,11 @@\n+    private void unMask(ByteBuffer src) {\n+        int pos = src.position();\n+        int size = src.remaining();\n+        ByteBuffer temp = ByteBuffer.allocate(size);\n+        Frame.Masker.transferMasking(src, temp, maskingKey);\n+        temp.flip();\n+        src.position(pos);\n+        src.put(temp);\n+        src.position(pos).limit(pos+size);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageDecoder.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -84,0 +84,9 @@\n+    private final boolean server;\n+\n+    MessageEncoder() {\n+        this(false);\n+    }\n+\n+    MessageEncoder(boolean isServer) {\n+        this.server = isServer;\n+    }\n@@ -372,2 +381,9 @@\n-        int mask = maskingKeySource.nextInt();\n-        headerWriter.fin(fin)\n+        \/\/ for server setting mask to 0 disables masking (xor)\n+        int mask = this.server ? 0 : maskingKeySource.nextInt();\n+        if (mask == 0) {\n+            headerWriter.fin(fin)\n+                    .opcode(opcode)\n+                    .payloadLen(payloadLen)\n+                    .write(headerBuffer);\n+        } else {\n+            headerWriter.fin(fin)\n@@ -378,0 +394,1 @@\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageEncoder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.net.http.HttpClientFacade;\n@@ -40,0 +41,1 @@\n+import java.net.http.HttpClient;\n@@ -47,0 +49,1 @@\n+import java.util.concurrent.Executor;\n@@ -118,0 +121,1 @@\n+    private final Executor clientExecutor;\n@@ -122,0 +126,1 @@\n+                                       b.getClient(),\n@@ -143,0 +148,1 @@\n+                                     HttpClient client,\n@@ -146,1 +152,1 @@\n-        WebSocketImpl ws = new WebSocketImpl(uri, subprotocol, listener, transport);\n+        WebSocketImpl ws = new WebSocketImpl(uri, client, subprotocol, listener, transport);\n@@ -154,0 +160,1 @@\n+                          HttpClient client,\n@@ -158,0 +165,1 @@\n+        this.clientExecutor = ((HttpClientFacade)client).theExecutor();\n@@ -359,1 +367,1 @@\n-            receiveScheduler.runOrSchedule();\n+            receiveScheduler.runOrSchedule(clientExecutor);\n@@ -401,1 +409,1 @@\n-     *       x --(1)--> IDLE --(2)--> y (otherwise we're loosing events, or\n+     *       x --(1)--> IDLE --(2)--> y (otherwise we're losing events, or\n@@ -705,1 +713,1 @@\n-        receiveScheduler.runOrSchedule();\n+        receiveScheduler.runOrSchedule(clientExecutor);\n@@ -837,1 +845,1 @@\n-                receiveScheduler.runOrSchedule();\n+                receiveScheduler.runOrSchedule(clientExecutor);\n@@ -853,1 +861,1 @@\n-            receiveScheduler.runOrSchedule();\n+            receiveScheduler.runOrSchedule(clientExecutor);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/WebSocketImpl.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -83,0 +82,5 @@\n+        loadPrefsLib();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadPrefsLib() {\n","filename":"src\/java.prefs\/macosx\/classes\/java\/util\/prefs\/MacOSXPreferencesFile.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -53,0 +52,5 @@\n+        loadPrefsLib();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadPrefsLib() {\n@@ -63,0 +67,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -114,0 +119,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -181,0 +187,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -448,0 +455,5 @@\n+        addShutdownHook();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void addShutdownHook() {\n@@ -516,0 +528,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -585,0 +598,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -632,0 +646,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -665,0 +680,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -703,0 +719,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -737,0 +754,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -786,0 +804,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.prefs\/unix\/classes\/java\/util\/prefs\/FileSystemPreferences.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -51,0 +50,5 @@\n+        loadPrefsLib();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadPrefsLib() {\n","filename":"src\/java.prefs\/windows\/classes\/java\/util\/prefs\/WindowsPreferences.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -95,0 +94,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -100,0 +100,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -105,0 +106,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -125,2 +127,5 @@\n-    private static final AccessControlContext SOCKET_ACC;\n-    static {\n+    @SuppressWarnings(\"removal\")\n+    private static final AccessControlContext SOCKET_ACC = createSocketAcc();\n+\n+    @SuppressWarnings(\"removal\")\n+    private static AccessControlContext createSocketAcc() {\n@@ -130,1 +135,1 @@\n-        SOCKET_ACC = new AccessControlContext(pd);\n+        return new AccessControlContext(pd);\n@@ -254,0 +259,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -493,0 +499,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -518,0 +525,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCClient.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-@SuppressWarnings({\"removal\",\"deprecation\"})\n+@SuppressWarnings(\"deprecation\")\n@@ -71,0 +71,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -76,0 +77,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -81,0 +83,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -86,0 +89,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -123,0 +127,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -318,0 +323,5 @@\n+        exportSingleton();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void exportSingleton() {\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-@SuppressWarnings({\"removal\",\"deprecation\"})\n+@SuppressWarnings(\"deprecation\")\n@@ -90,0 +90,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -95,0 +96,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -101,0 +103,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -111,0 +114,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -125,2 +129,5 @@\n-    private static final AccessControlContext NOPERMS_ACC;\n-    static {\n+    @SuppressWarnings(\"removal\")\n+    private static final AccessControlContext NOPERMS_ACC = createNopermsAcc();\n+\n+    @SuppressWarnings(\"removal\")\n+    private static AccessControlContext createNopermsAcc() {\n@@ -129,1 +136,1 @@\n-        NOPERMS_ACC = new AccessControlContext(pd);\n+        return new AccessControlContext(pd);\n@@ -151,0 +158,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -301,1 +309,2 @@\n-    protected void checkAcceptPermission(AccessControlContext acc) {\n+    protected void checkAcceptPermission(@SuppressWarnings(\"removal\") AccessControlContext acc) {\n+        @SuppressWarnings(\"removal\")\n@@ -341,0 +350,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -353,0 +363,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -649,0 +660,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -651,0 +663,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -654,0 +667,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -672,0 +686,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -697,0 +712,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -51,1 +50,8 @@\n-    private static final long CURRENT_PID;\n+    private static final long CURRENT_PID = pid();\n+\n+    @SuppressWarnings(\"removal\")\n+    private static long pid() {\n+        PrivilegedAction<ProcessHandle> pa = () -> ProcessHandle.current();\n+        return AccessController.doPrivileged(pa).pid();\n+    }\n+\n@@ -54,3 +60,0 @@\n-        PrivilegedAction<ProcessHandle> pa = ProcessHandle::current;\n-        CURRENT_PID = AccessController.doPrivileged(pa).pid();\n-\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -115,1 +115,6 @@\n-    JDK17(\"17\");\n+    JDK17(\"17\"),\n+\n+    \/**\n+      * 18, tbd\n+      *\/\n+    JDK18(\"18\");\n@@ -167,0 +172,1 @@\n+        case JDK18  -> Target.JDK1_18;\n@@ -309,0 +315,1 @@\n+        case JDK18  -> RELEASE_18;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-        V61(61, 0);   \/\/ JDK 17\n+        V61(61, 0),   \/\/ JDK 17\n+        V62(62, 0);   \/\/ JDK 18\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,1 +88,4 @@\n-    JDK1_17(\"17\", 61, 0);\n+    JDK1_17(\"17\", 61, 0),\n+\n+    \/** JDK 18. *\/\n+    JDK1_18(\"18\", 62, 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.TreeScanner;\n@@ -196,0 +199,3 @@\n+        if (new TypeAnnotationFinder().scan(paramTypes, null) != null)\n+            throw new ParseException(\"dc.ref.annotations.not.allowed\");\n+\n@@ -198,1 +204,13 @@\n-}\n+\n+    static class TypeAnnotationFinder extends TreeScanner<Tree, Void> {\n+        @Override\n+        public Tree visitAnnotatedType(AnnotatedTypeTree t, Void ignore) {\n+            return t;\n+        }\n+\n+        @Override\n+        public Tree reduce(Tree t1, Tree t2) {\n+            return t1 != null ? t1 : t2;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ReferenceParser.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-@SupportedSourceVersion(SourceVersion.RELEASE_17)\n+@SupportedSourceVersion(SourceVersion.RELEASE_18)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3269,0 +3269,3 @@\n+compiler.err.dc.ref.annotations.not.allowed=\\\n+    annotations not allowed\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    biasedLockBits      = db.lookupLongConstant(\"markWord::biased_lock_bits\").longValue();\n@@ -56,1 +55,0 @@\n-    biasedLockShift     = db.lookupLongConstant(\"markWord::biased_lock_shift\").longValue();\n@@ -61,3 +59,0 @@\n-    biasedLockMask      = db.lookupLongConstant(\"markWord::biased_lock_mask\").longValue();\n-    biasedLockMaskInPlace  = db.lookupLongConstant(\"markWord::biased_lock_mask_in_place\").longValue();\n-    biasedLockBitInPlace  = db.lookupLongConstant(\"markWord::biased_lock_bit_in_place\").longValue();\n@@ -68,1 +63,0 @@\n-    biasedLockAlignment  = db.lookupLongConstant(\"markWord::biased_lock_alignment\").longValue();\n@@ -73,1 +67,0 @@\n-    biasedLockPattern = db.lookupLongConstant(\"markWord::biased_lock_pattern\").longValue();\n@@ -86,1 +79,0 @@\n-  private static long biasedLockBits;\n@@ -91,1 +83,0 @@\n-  private static long biasedLockShift;\n@@ -97,3 +88,0 @@\n-  private static long biasedLockMask;\n-  private static long biasedLockMaskInPlace;\n-  private static long biasedLockBitInPlace;\n@@ -104,1 +92,0 @@\n-  private static long biasedLockAlignment;\n@@ -110,1 +97,0 @@\n-  private static long biasedLockPattern;\n@@ -136,22 +122,0 @@\n-  \/\/ Biased locking accessors\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchoronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  public boolean hasBiasPattern() {\n-    return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == biasedLockPattern);\n-  }\n-\n-  public JavaThread biasedLocker() {\n-    Threads threads = VM.getVM().getThreads();\n-    Address addr = valueAsAddress().andWithMask(~(biasedLockMaskInPlace & ageMaskInPlace));\n-    return threads.createJavaThreadWrapper(addr);\n-  }\n-\n-  \/\/ Indicates that the mark gas the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  public boolean isBiasedAnonymously() {\n-    return hasBiasPattern() && (biasedLocker() == null);\n-  }\n-\n@@ -163,1 +127,1 @@\n-    return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == unlockedValue);\n+    return (Bits.maskBitsLong(value(), lockMaskInPlace) == unlockedValue);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,3 +55,3 @@\n-    contentionsField  = type.getJIntField(\"_contentions\");\n-    waitersField = type.getJIntField(\"_waiters\");\n-    recursionsField = type.getCIntegerField(\"_recursions\");\n+    contentionsField  = new CIntField(type.getCIntegerField(\"_contentions\"), 0);\n+    waitersField      = new CIntField(type.getCIntegerField(\"_waiters\"), 0);\n+    recursionsField   = type.getCIntegerField(\"_recursions\");\n@@ -86,1 +86,1 @@\n-  public int    waiters() { return waitersField.getValue(addr); }\n+  public int    waiters() { return (int)waitersField.getValue(this); }\n@@ -103,1 +103,1 @@\n-      return contentionsField.getValue(addr);\n+      return (int)contentionsField.getValue(this);\n@@ -114,2 +114,2 @@\n-  private static JIntField     contentionsField;\n-  private static JIntField     waitersField;\n+  private static CIntField     contentionsField;\n+  private static CIntField     waitersField;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,24 +78,30 @@\n-        HashMap<String,List<String>> map;\n-\n-       \/**\n-        * Creates an empty instance of {@code Headers}.\n-        *\/\n-        public Headers () {map = new HashMap<String,List<String>>(32);}\n-\n-        \/**\n-         * Normalize the key by converting to following form.\n-         * First {@code char} upper case, rest lower case.\n-         * key is presumed to be {@code ASCII}.\n-         *\/\n-        private String normalize (String key) {\n-            if (key == null) {\n-                return null;\n-            }\n-            int len = key.length();\n-            if (len == 0) {\n-                return key;\n-            }\n-            char[] b = key.toCharArray();\n-            if (b[0] >= 'a' && b[0] <= 'z') {\n-                b[0] = (char)(b[0] - ('a' - 'A'));\n-            } else if (b[0] == '\\r' || b[0] == '\\n')\n+    HashMap<String,List<String>> map;\n+\n+    \/**\n+     * Creates an empty instance of {@code Headers}.\n+     *\/\n+    public Headers() {map = new HashMap<>(32);}\n+\n+    \/**\n+     * Normalize the key by converting to following form.\n+     * First {@code char} upper case, rest lower case.\n+     * key is presumed to be {@code ASCII}.\n+     *\/\n+    private String normalize(String key) {\n+        if (key == null) {\n+            return null;\n+        }\n+        int len = key.length();\n+        if (len == 0) {\n+            return key;\n+        }\n+        char[] b = key.toCharArray();\n+        if (b[0] >= 'a' && b[0] <= 'z') {\n+            b[0] = (char)(b[0] - ('a' - 'A'));\n+        } else if (b[0] == '\\r' || b[0] == '\\n')\n+            throw new IllegalArgumentException(\"illegal character in key\");\n+\n+        for (int i=1; i<len; i++) {\n+            if (b[i] >= 'A' && b[i] <= 'Z') {\n+                b[i] = (char) (b[i] + ('a' - 'A'));\n+            } else if (b[i] == '\\r' || b[i] == '\\n')\n@@ -103,8 +109,0 @@\n-\n-            for (int i=1; i<len; i++) {\n-                if (b[i] >= 'A' && b[i] <= 'Z') {\n-                    b[i] = (char) (b[i] + ('a' - 'A'));\n-                } else if (b[i] == '\\r' || b[i] == '\\n')\n-                    throw new IllegalArgumentException(\"illegal character in key\");\n-            }\n-            return new String(b);\n@@ -112,0 +110,2 @@\n+        return new String(b);\n+    }\n@@ -113,1 +113,1 @@\n-        public int size() {return map.size();}\n+    public int size() {return map.size();}\n@@ -115,1 +115,1 @@\n-        public boolean isEmpty() {return map.isEmpty();}\n+    public boolean isEmpty() {return map.isEmpty();}\n@@ -117,8 +117,3 @@\n-        public boolean containsKey(Object key) {\n-            if (key == null) {\n-                return false;\n-            }\n-            if (!(key instanceof String)) {\n-                return false;\n-            }\n-            return map.containsKey (normalize((String)key));\n+    public boolean containsKey(Object key) {\n+        if (key == null) {\n+            return false;\n@@ -126,3 +121,2 @@\n-\n-        public boolean containsValue(Object value) {\n-            return map.containsValue(value);\n+        if (!(key instanceof String)) {\n+            return false;\n@@ -130,0 +124,2 @@\n+        return map.containsKey(normalize((String)key));\n+    }\n@@ -131,3 +127,3 @@\n-        public List<String> get(Object key) {\n-            return map.get(normalize((String)key));\n-        }\n+    public boolean containsValue(Object value) {\n+        return map.containsValue(value);\n+    }\n@@ -135,14 +131,3 @@\n-        \/**\n-         * Returns the first value from the {@link List} of {@code String}\n-         * values for the given key (if at least one exists).\n-         *\n-         * @param key the key to search for\n-         * @return the first {@code String} value associated with the key\n-         *\/\n-        public String getFirst (String key) {\n-            List<String> l = map.get(normalize(key));\n-            if (l == null) {\n-                return null;\n-            }\n-            return l.get(0);\n-        }\n+    public List<String> get(Object key) {\n+        return map.get(normalize((String)key));\n+    }\n@@ -150,4 +135,11 @@\n-        public List<String> put(String key, List<String> value) {\n-            for (String v : value)\n-                checkValue(v);\n-            return map.put (normalize(key), value);\n+    \/**\n+     * Returns the first value from the {@link List} of {@code String}\n+     * values for the given key (if at least one exists).\n+     *\n+     * @param key the key to search for\n+     * @return the first {@code String} value associated with the key\n+     *\/\n+    public String getFirst(String key) {\n+        List<String> l = map.get(normalize(key));\n+        if (l == null) {\n+            return null;\n@@ -155,0 +147,2 @@\n+        return l.get(0);\n+    }\n@@ -156,16 +150,20 @@\n-        \/**\n-         * Adds the given value to the list of headers for the given key. If\n-         * the mapping does not already exist, then it is created.\n-         *\n-         * @param key the header name\n-         * @param value the value to add to the header\n-         *\/\n-        public void add (String key, String value) {\n-            checkValue(value);\n-            String k = normalize(key);\n-            List<String> l = map.get(k);\n-            if (l == null) {\n-                l = new LinkedList<String>();\n-                map.put(k,l);\n-            }\n-            l.add (value);\n+    public List<String> put(String key, List<String> value) {\n+        for (String v : value)\n+            checkValue(v);\n+        return map.put(normalize(key), value);\n+    }\n+\n+    \/**\n+     * Adds the given value to the list of headers for the given key. If\n+     * the mapping does not already exist, then it is created.\n+     *\n+     * @param key the header name\n+     * @param value the value to add to the header\n+     *\/\n+    public void add(String key, String value) {\n+        checkValue(value);\n+        String k = normalize(key);\n+        List<String> l = map.get(k);\n+        if (l == null) {\n+            l = new LinkedList<>();\n+            map.put(k,l);\n@@ -173,0 +171,2 @@\n+        l.add(value);\n+    }\n@@ -174,20 +174,13 @@\n-        private static void checkValue(String value) {\n-            int len = value.length();\n-            for (int i=0; i<len; i++) {\n-                char c = value.charAt(i);\n-                if (c == '\\r') {\n-                    \/\/ is allowed if it is followed by \\n and a whitespace char\n-                    if (i >= len - 2) {\n-                        throw new IllegalArgumentException(\"Illegal CR found in header\");\n-                    }\n-                    char c1 = value.charAt(i+1);\n-                    char c2 = value.charAt(i+2);\n-                    if (c1 != '\\n') {\n-                        throw new IllegalArgumentException(\"Illegal char found after CR in header\");\n-                    }\n-                    if (c2 != ' ' && c2 != '\\t') {\n-                        throw new IllegalArgumentException(\"No whitespace found after CRLF in header\");\n-                    }\n-                    i+=2;\n-                } else if (c == '\\n') {\n-                    throw new IllegalArgumentException(\"Illegal LF found in header\");\n+    private static void checkValue(String value) {\n+        int len = value.length();\n+        for (int i=0; i<len; i++) {\n+            char c = value.charAt(i);\n+            if (c == '\\r') {\n+                \/\/ is allowed if it is followed by \\n and a whitespace char\n+                if (i >= len - 2) {\n+                    throw new IllegalArgumentException(\"Illegal CR found in header\");\n+                }\n+                char c1 = value.charAt(i+1);\n+                char c2 = value.charAt(i+2);\n+                if (c1 != '\\n') {\n+                    throw new IllegalArgumentException(\"Illegal char found after CR in header\");\n@@ -195,0 +188,6 @@\n+                if (c2 != ' ' && c2 != '\\t') {\n+                    throw new IllegalArgumentException(\"No whitespace found after CRLF in header\");\n+                }\n+                i+=2;\n+            } else if (c == '\\n') {\n+                throw new IllegalArgumentException(\"Illegal LF found in header\");\n@@ -197,0 +196,1 @@\n+    }\n@@ -198,13 +198,12 @@\n-        \/**\n-         * Sets the given value as the sole header value for the given\n-         * key. If the mapping does not already exist, then it is created.\n-         *\n-         * @param key the header name\n-         * @param value the header value to set\n-         *\/\n-        public void set (String key, String value) {\n-            LinkedList<String> l = new LinkedList<String>();\n-            l.add (value);\n-            put (key, l);\n-        }\n-\n+    \/**\n+     * Sets the given value as the sole header value for the given\n+     * key. If the mapping does not already exist, then it is created.\n+     *\n+     * @param key the header name\n+     * @param value the header value to set\n+     *\/\n+    public void set(String key, String value) {\n+        LinkedList<String> l = new LinkedList<>();\n+        l.add(value);\n+        put(key, l);\n+    }\n@@ -212,3 +211,3 @@\n-        public List<String> remove(Object key) {\n-            return map.remove(normalize((String)key));\n-        }\n+    public List<String> remove(Object key) {\n+        return map.remove(normalize((String)key));\n+    }\n@@ -216,3 +215,3 @@\n-        public void putAll(Map<? extends String,? extends List<String>> t)  {\n-            map.putAll (t);\n-        }\n+    public void putAll(Map<? extends String,? extends List<String>> t)  {\n+        map.putAll(t);\n+    }\n@@ -220,1 +219,1 @@\n-        public void clear() {map.clear();}\n+    public void clear() {map.clear();}\n@@ -222,1 +221,1 @@\n-        public Set<String> keySet() {return map.keySet();}\n+    public Set<String> keySet() {return map.keySet();}\n@@ -224,1 +223,1 @@\n-        public Collection<List<String>> values() {return map.values();}\n+    public Collection<List<String>> values() {return map.values();}\n@@ -226,3 +225,3 @@\n-        public Set<Map.Entry<String, List<String>>> entrySet() {\n-            return map.entrySet();\n-        }\n+    public Set<Map.Entry<String, List<String>>> entrySet() {\n+        return map.entrySet();\n+    }\n@@ -230,1 +229,1 @@\n-        public boolean equals(Object o) {return map.equals(o);}\n+    public boolean equals(Object o) {return map.equals(o);}\n@@ -232,2 +231,2 @@\n-        public int hashCode() {return map.hashCode();}\n-    }\n+    public int hashCode() {return map.hashCode();}\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":130,"deletions":131,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -926,5 +926,1 @@\n-        if (isArray()) {\n-            return config.arrayPrototypeMarkWord();\n-        } else {\n-            return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);\n-        }\n+        return config.prototypeMarkWord();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-    final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markWord\");\n@@ -155,1 +154,1 @@\n-    long arrayPrototypeMarkWord() {\n+    long prototypeMarkWord() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1233,0 +1233,4 @@\n+    \/* Setting this flag is needed by findThread(). It's ok to set it before\n+       the callbacks are cleared.*\/\n+    gdata->jvmtiCallBacksCleared = JNI_TRUE;\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -257,2 +257,17 @@\n-         * Search runningThreads list. The TLS lookup may have failed because the\n-         * thread has terminated, but the ThreadNode may still be present.\n+         * Normally we can assume that a thread with no TLS will never be in the runningThreads\n+         * list. This is because we always set the TLS when adding to runningThreads.\n+         * However, when a thread exits, its TLS is automatically cleared. Normally this\n+         * is not a problem because the debug agent will first get a THREAD_END event,\n+         * and that will cause the thread to be removed from runningThreads, thus we\n+         * avoid this situation of having a thread in runningThreads, but with no TLS.\n+         *\n+         * However... there is one exception to this. While handling VM_DEATH, the first thing\n+         * the debug agent does is clear all the callbacks. This means we will no longer\n+         * get THREAD_END events as threads exit. This means we might find threads on\n+         * runningThreads with no TLS during VM_DEATH. Essentially the THREAD_END that\n+         * would normally have resulted in removing the thread from runningThreads is\n+         * missed, so the thread remains on runningThreads.\n+         *\n+         * The end result of all this is that if the TLS lookup failed, we still need to check\n+         * if the thread is on runningThreads, but only if JVMTI callbacks have been cleared.\n+         * Otherwise the thread should not be on the runningThreads.\n@@ -260,3 +275,12 @@\n-        if ( node == NULL ) {\n-            if ( list == NULL || list == &runningThreads ) {\n-                node = nonTlsSearch(getEnv(), &runningThreads, thread);\n+        if ( !gdata->jvmtiCallBacksCleared ) {\n+            \/* The thread better not be on runningThreads if the TLS lookup failed. *\/\n+            JDI_ASSERT(!nonTlsSearch(getEnv(), &runningThreads, thread));\n+        } else {\n+            \/*\n+             * Search the runningThreads list. The TLS lookup may have failed because the\n+             * thread has terminated, but we never got the THREAD_END event.\n+             *\/\n+            if ( node == NULL ) {\n+                if ( list == NULL || list == &runningThreads ) {\n+                    node = nonTlsSearch(getEnv(), &runningThreads, thread);\n+                }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -136,2 +136,5 @@\n-     \/* Indication that the agent has been loaded *\/\n-     jboolean isLoaded;\n+    \/* Indication that the agent has been loaded *\/\n+    jboolean isLoaded;\n+\n+    \/* Indication that VM_DEATH has been recieved and the JVMTI callbacks have been cleared. *\/\n+    volatile jboolean jvmtiCallBacksCleared;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jfr.internal.PrivateAccess;\n@@ -33,0 +34,1 @@\n+import jdk.jfr.internal.WriteableUserPath;\n@@ -47,1 +49,0 @@\n-            SafePath safePath = null;\n@@ -49,0 +50,2 @@\n+            WriteableUserPath path = PrivateAccess.getInstance().getPlatformRecording(recording).getDestination();\n+            SafePath safePath = path == null ? null : new SafePath(path.getRealPathText());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,18 +99,0 @@\n-    <event name=\"jdk.BiasedLockRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockSelfRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockClassRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -99,18 +99,0 @@\n-    <event name=\"jdk.BiasedLockRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockSelfRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockClassRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,2 +66,7 @@\n-static void next_line(FILE *f) {\n-    while (fgetc(f) != '\\n');\n+static int next_line(FILE *f) {\n+    int c;\n+    do {\n+        c = fgetc(f);\n+    } while (c != '\\n' && c != EOF);\n+\n+    return c;\n@@ -96,1 +101,4 @@\n-    next_line(fh);\n+    if (next_line(fh) == EOF) {\n+        fclose(fh);\n+        return -2;\n+    }\n@@ -109,1 +117,4 @@\n-            next_line(fh);\n+            if (next_line(fh) == EOF) {\n+                fclose(fh);\n+                return -2;\n+            }\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -191,0 +190,1 @@\n+                    @SuppressWarnings(\"removal\")\n@@ -361,0 +361,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -1092,0 +1093,5 @@\n+        loadSctpLibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadSctpLibrary() {\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -45,0 +44,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -107,0 +107,1 @@\n+         @SuppressWarnings(\"removal\")\n@@ -116,1 +117,1 @@\n-                                                         SecurityManager sm)\n+                                                         @SuppressWarnings(\"removal\") SecurityManager sm)\n@@ -339,0 +340,5 @@\n+        loadSctpLibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadSctpLibrary() {\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-JAVA_RELEASE = 7\n+JAVA_RELEASE = 15\n@@ -56,1 +56,0 @@\n-CC := \"cl.exe\"\n@@ -61,8 +60,0 @@\n-native: require_env\n-ifeq (\"${OS_NAME}\", \"Cygwin\")\n-\t\"${CC}\" src\/windows\/native\/jdk\/test\/failurehandler\/jtreg\/*.c        \\\n-\t-I\"$(shell cygpath -w \"${JAVA_HOME}\/include\")\"                        \\\n-\t-I\"$(shell cygpath -w \"${JAVA_HOME}\/include\/win32\")\"                  \\\n-\t\/link \/DLL \/OUT:timeoutHandler.dll\n-endif\n-\n@@ -115,1 +106,1 @@\n-build: classes native\n+build: classes\n@@ -117,1 +108,1 @@\n-.PHONY: all build classes native test require_env clean\n+.PHONY: all build classes test require_env clean\n@@ -119,1 +110,0 @@\n-\n","filename":"test\/failure_handler\/Makefile","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-The library requires jtreg 4b13+ and JDK 7+.\n+The library requires jtreg 4b13+ and JDK 15+.\n@@ -105,1 +105,0 @@\n-\n","filename":"test\/failure_handler\/README","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.failurehandler;\n+\n+import java.nio.file.Path;\n+\n+public interface CoreInfoGatherer {\n+    void gatherCoreInfo(HtmlSection section, Path core);\n+}\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/CoreInfoGatherer.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,4 @@\n+    public CoreInfoGatherer getCoreInfoGatherer() {\n+        return create();\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/GathererFactory.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -30,0 +31,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -35,0 +38,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -36,1 +40,1 @@\n-public class ToolKit implements EnvironmentInfoGatherer, ProcessInfoGatherer {\n+public class ToolKit implements EnvironmentInfoGatherer, ProcessInfoGatherer, CoreInfoGatherer {\n@@ -39,0 +43,1 @@\n+    private final PrintWriter log;\n@@ -42,0 +47,1 @@\n+        this.log = log;\n@@ -54,0 +60,21 @@\n+    @Override\n+    public void gatherCoreInfo(HtmlSection section, Path core) {\n+        if (core.getFileName().toString().endsWith(\".gz\")) {\n+            Path unpackedCore = Path.of(core.toString().replace(\".gz\", \"\"));\n+            try (GZIPInputStream gzis = new GZIPInputStream(Files.newInputStream(core))) {\n+                Files.copy(gzis, unpackedCore);\n+                for (ActionSet set : actions) {\n+                    set.gatherCoreInfo(section, unpackedCore);\n+                }\n+                Files.delete(unpackedCore);\n+            } catch (IOException ioe) {\n+                log.printf(\"Unexpected exception whilc opening %s\", core.getFileName().toString());\n+                ioe.printStackTrace(log);\n+            }\n+        } else {\n+            for (ActionSet set : actions) {\n+                set.gatherCoreInfo(section, core);\n+            }\n+        }\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/ToolKit.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import com.sun.tools.attach.VirtualMachine;\n-import com.sun.tools.attach.VirtualMachineDescriptor;\n@@ -137,1 +135,1 @@\n-    private File findApp(String app) {\n+    public File findApp(String app) {\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionHelper.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.test.failurehandler.CoreInfoGatherer;\n@@ -31,0 +32,1 @@\n+import java.io.IOException;\n@@ -32,0 +34,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -35,0 +39,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -36,1 +41,1 @@\n-public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer {\n+public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer, CoreInfoGatherer {\n@@ -39,0 +44,2 @@\n+    private static final String CORES_PROPERTY = \"cores\";\n+\n@@ -49,0 +56,1 @@\n+    private final List<PatternAction> coreActions;\n@@ -58,0 +66,1 @@\n+        coreActions = getPatternActions(log, p, CORES_PROPERTY);\n@@ -126,0 +135,7 @@\n+\n+    @Override\n+    public void gatherCoreInfo(HtmlSection section, Path core) {\n+        for (PatternAction action : coreActions) {\n+            helper.runPatternAction(action, section, core.toString());\n+        }\n+    }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionSet.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,3 @@\n+        for (int i = 0, n = args.length; i < n; ++i) {\n+            args[i] = args[i].replace(\"%java\", helper.findApp(\"java\").getAbsolutePath());\n+        }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/PatternAction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -38,2 +39,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -48,0 +47,2 @@\n+    public static final String CORES_OUTPUT = \"cores.html\";\n+\n@@ -67,1 +68,1 @@\n-        PrintWriter log;\n+        PrintWriter log1;\n@@ -70,1 +71,1 @@\n-            log = new PrintWriter(new FileWriter(\n+            log1 = new PrintWriter(new FileWriter(\n@@ -74,2 +75,2 @@\n-            log = new PrintWriter(System.out);\n-            log.printf(\"ERROR: %s cannot open log file %s\", name,\n+            log1 = new PrintWriter(System.out);\n+            log1.printf(\"ERROR: %s cannot open log file %s\", name,\n@@ -77,1 +78,1 @@\n-            e.printStackTrace(log);\n+            e.printStackTrace(log1);\n@@ -79,0 +80,1 @@\n+        final PrintWriter log = log1;\n@@ -86,0 +88,5 @@\n+            Files.walk(workDir)\n+                    .filter(Files::isRegularFile)\n+                    .filter(f -> (f.getFileName().toString().contains(\"core\") || f.getFileName().toString().contains(\"mdmp\")))\n+                    .forEach(core -> gatherCoreInfo(workDir, name,\n+                            core, log, gathererFactory.getCoreInfoGatherer()));\n@@ -99,0 +106,16 @@\n+    private void gatherCoreInfo(Path workDir, String name, Path core, PrintWriter log,\n+                               CoreInfoGatherer gatherer) {\n+        File output = workDir.resolve(CORES_OUTPUT).toFile();\n+        try (HtmlPage html = new HtmlPage(new PrintWriter(\n+                new FileWriter(output, true), true))) {\n+            try (ElapsedTimePrinter timePrinter\n+                         = new ElapsedTimePrinter(new Stopwatch(), name, log)) {\n+                gatherer.gatherCoreInfo(html.getRootSection(), core);\n+            }\n+        } catch (Throwable e) {\n+            log.printf(\"ERROR: exception in observer on getting environment \"\n+                    + \"information %s:\", name);\n+            e.printStackTrace(log);\n+        }\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherDiagnosticInfoObserver.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.reflect.Field;\n@@ -105,27 +104,0 @@\n-    @Override\n-    protected long getProcessId(Process process) {\n-        long result = super.getProcessId(process);\n-        if (result == 0L) {\n-            \/* jtreg didn't find pid, most probably we are on JDK < 9\n-               there is no Process::getPid *\/\n-            if (HAS_NATIVE_LIBRARY && \"windows\".equals(OS.current().family)) {\n-                try {\n-                    Field field = process.getClass().getDeclaredField(\"handle\");\n-                    boolean old = field.canAccess(process);\n-                    try {\n-                        field.setAccessible(true);\n-                        long handle = field.getLong(process);\n-                        result = getWin32Pid(handle);\n-                    } finally {\n-                        field.setAccessible(old);\n-                    }\n-                } catch (ReflectiveOperationException e) {\n-                    e.printStackTrace(log);\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private native long getWin32Pid(long handle);\n-\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherProcessInfoTimeoutHandler.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  jstack\n+  jstack jhsdb.jstack\n@@ -54,0 +54,1 @@\n+jcmd.vm.info.args=%p VM.info\n@@ -63,0 +64,9 @@\n+jhsdb.app=jhsdb\n+jhsdb.jstack.args=jstack --mixed --pid %p\n+jhsdb.jstack.params.repeat=6\n+\n+cores=jhsdb.jstack\n+jhsdb.jstack.app=jhsdb\n+# Assume that java standard laucher has been used\n+jhsdb.jstack.args=jstack --mixed --core %p --exe %java\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/common.properties","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -58,0 +59,7 @@\n+\n+cores=native.gdb\n+native.gdb.app=gdb\n+# Assume that java standard laucher has been used\n+native.gdb.args=%java\\0-c\\0%p\\0-batch\\0-ex\\0thread apply all backtrace\n+native.gdb.args.delimiter=\\0\n+\n@@ -131,1 +139,0 @@\n-\n","filename":"test\/failure_handler\/src\/share\/conf\/linux.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+cores=native.lldb\n+native.lldb.app=lldb\n+native.lldb.delimiter=\\0\n+# Assume that java standard laucher has been used\n+native.lldb.args=--core\\0%p\\0%java\\0-o\\0thread backtrace all\\0-o\\0quit\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/mac.properties","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <windows.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-JNIEXPORT jlong JNICALL Java_jdk_test_failurehandler_jtreg_GatherProcessInfoTimeoutHandler_getWin32Pid\n-        (JNIEnv* env, jobject o, jlong handle) {\n-    return GetProcessId((HANDLE) handle);\n-}\n-#ifdef __cplusplus\n-}\n-#endif\n","filename":"test\/failure_handler\/src\/windows\/native\/libtimeoutHandler\/GatherProcessInfoTimeoutHandler.c","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -63,5 +63,8 @@\n-  HeapRegion hr0(0, &bot, mr0);\n-  HeapRegion hr1(1, &bot, mr1);\n-  HeapRegion hr2(2, &bot, mr2);\n-  HeapRegion hr3(3, &bot, mr3);\n-  HeapRegion hr4(4, &bot, mr4);\n+  G1CardSetConfiguration config;\n+\n+  HeapRegion hr0(0, &bot, mr0, &config);\n+  HeapRegion hr1(1, &bot, mr1, &config);\n+  HeapRegion hr2(2, &bot, mr2, &config);\n+  HeapRegion hr3(3, &bot, mr3, &config);\n+  HeapRegion hr4(4, &bot, mr4, &config);\n+\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/workgroup.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+class G1CardSetTest : public ::testing::Test {\n+\n+  class G1CountCardsClosure : public G1CardSet::G1CardSetCardIterator {\n+  public:\n+    size_t _num_cards;\n+\n+    G1CountCardsClosure() : _num_cards(0) { }\n+    void do_card(uint region_idx, uint card_idx) override {\n+      _num_cards++;\n+    }\n+  };\n+\n+  static WorkGang* _workers;\n+  static uint _max_workers;\n+\n+  static WorkGang* workers() {\n+    if (_workers == NULL) {\n+      _max_workers = os::processor_count();\n+      _workers = new WorkGang(\"G1CardSetTest Work Gang\", _max_workers, false, false);\n+      _workers->initialize_workers();\n+      _workers->update_active_workers(_max_workers);\n+    }\n+    return _workers;\n+  }\n+\n+  \/\/ Check whether iteration agrees with the expected number of entries. If the\n+  \/\/ add has been single-threaded, we can also check whether the occupied()\n+  \/\/ (which is an estimate in that case) agrees.\n+  static void check_iteration(G1CardSet* card_set,\n+                              const size_t expected,\n+                              const bool add_was_single_threaded = true);\n+\n+public:\n+  G1CardSetTest() { }\n+  ~G1CardSetTest() { }\n+\n+  static uint next_random(uint& seed, uint i) {\n+    \/\/ Park–Miller random number generator\n+    seed = (seed * 279470273u) % 0xfffffffb;\n+    return (seed % i);\n+  }\n+\n+  static void cardset_basic_test();\n+  static void cardset_mt_test();\n+\n+  static void add_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards, G1AddCardResult* results);\n+  static void contains_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards);\n+\n+  static void translate_cards(uint cards_per_region, uint region_idx, uint* cards, uint num_cards);\n+\n+  static void iterate_cards(G1CardSet* card_set, G1CardSet::G1CardSetCardIterator* cl);\n+};\n+\n+WorkGang* G1CardSetTest::_workers = NULL;\n+uint G1CardSetTest::_max_workers = 0;\n+\n+void G1CardSetTest::add_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards, G1AddCardResult* results) {\n+  for (uint i = 0; i < num_cards; i++) {\n+\n+    uint region_idx = cards[i] \/ cards_per_region;\n+    uint card_idx = cards[i] % cards_per_region;\n+\n+    G1AddCardResult res = card_set->add_card(region_idx, card_idx);\n+    if (results != NULL) {\n+      ASSERT_TRUE(res == results[i]);\n+    }\n+  }\n+}\n+\n+class G1CheckCardClosure : public G1CardSet::G1CardSetCardIterator {\n+  G1CardSet* _card_set;\n+\n+  uint _cards_per_region;\n+  uint* _cards_to_expect;\n+  uint _num_cards;\n+\n+  bool _wrong_region_idx;\n+\n+public:\n+  G1CheckCardClosure(G1CardSet* card_set, uint cards_per_region, uint* cards_to_expect, uint num_cards) :\n+    _card_set(card_set),\n+    _cards_per_region(cards_per_region),\n+    _cards_to_expect(cards_to_expect),\n+    _num_cards(num_cards),\n+    _wrong_region_idx(false) {\n+  }\n+\n+  void do_card(uint region_idx, uint card_idx) override {\n+    uint card = _cards_per_region * region_idx + card_idx;\n+    for (uint i = 0; i < _num_cards; i++) {\n+      if (_cards_to_expect[i] == card) {\n+        _cards_to_expect[i] = (uint)-1;\n+      }\n+    }\n+  }\n+\n+  bool all_found() const {\n+    bool all_good = true;\n+    for (uint i = 0; i < _num_cards; i++) {\n+      if (_cards_to_expect[i] != (uint)-1) {\n+        log_error(gc)(\"Could not find card %u in region %u\",\n+                      _cards_to_expect[i] % _cards_per_region,\n+                      _cards_to_expect[i] \/ _cards_per_region);\n+        all_good = false;\n+      }\n+    }\n+    return all_good;\n+  }\n+};\n+\n+void G1CardSetTest::contains_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards) {\n+  for (uint i = 0; i < num_cards; i++) {\n+    uint region_idx = cards[i] \/ cards_per_region;\n+    uint card_idx = cards[i] % cards_per_region;\n+\n+    ASSERT_TRUE(card_set->contains_card(region_idx, card_idx));\n+  }\n+\n+  G1CheckCardClosure cl(card_set, cards_per_region, cards, num_cards);\n+  card_set->iterate_cards(cl);\n+\n+  ASSERT_TRUE(cl.all_found());\n+}\n+\n+\/\/ Offsets the card indexes in the cards array by the region_idx.\n+void G1CardSetTest::translate_cards(uint cards_per_region, uint region_idx, uint* cards, uint num_cards) {\n+  for (uint i = 0; i < num_cards; i++) {\n+    cards[i] = cards_per_region * region_idx + cards[i];\n+  }\n+}\n+\n+class G1CountCardsOccupied : public G1CardSet::G1CardSetPtrIterator {\n+  size_t _num_occupied;\n+\n+public:\n+  G1CountCardsOccupied() : _num_occupied(0) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    _num_occupied += num_occupied;\n+  }\n+\n+  size_t num_occupied() const { return _num_occupied; }\n+};\n+\n+void G1CardSetTest::check_iteration(G1CardSet* card_set, const size_t expected, const bool single_threaded) {\n+\n+  class CheckIterator : public G1CardSet::G1CardSetCardIterator {\n+  public:\n+    G1CardSet* _card_set;\n+    size_t _num_found;\n+\n+    CheckIterator(G1CardSet* card_set) : _card_set(card_set), _num_found(0) { }\n+\n+    void do_card(uint region_idx, uint card_idx) override {\n+      ASSERT_TRUE(_card_set->contains_card(region_idx, card_idx));\n+      _num_found++;\n+    }\n+  } cl(card_set);\n+\n+  card_set->iterate_cards(cl);\n+\n+  ASSERT_TRUE(expected == cl._num_found);\n+  \/\/ We can assert this only if we are single-threaded.\n+  if (single_threaded) {\n+    ASSERT_EQ(card_set->occupied(), cl._num_found);\n+  }\n+}\n+\n+void G1CardSetTest::cardset_basic_test() {\n+\n+  const uint CardsPerRegion = 2048;\n+  const double FullCardSetThreshold = 0.8;\n+  const double BitmapCoarsenThreshold = 0.9;\n+\n+  G1CardSetConfiguration config(log2i_exact(CardsPerRegion), 28, BitmapCoarsenThreshold, 8, FullCardSetThreshold, CardsPerRegion);\n+  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1CardSetMemoryManager mm(&config, &free_pool);\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 1, 2, 3 };\n+    G1AddCardResult results1[] = { Added, Added, Added };\n+    translate_cards(CardsPerRegion, 99, cards1, ARRAY_SIZE(cards1));\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), results1);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+\n+    check_iteration(&card_set, 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 0, 2047, 17, 17 };\n+    G1AddCardResult results1[] = { Added, Added, Added, Found };\n+    translate_cards(CardsPerRegion, 100, cards1, ARRAY_SIZE(cards1));\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), results1);\n+    \/\/ -1 because of the duplicate at the end.\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1) - 1);\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1) - 1);\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1) - 1);\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 0, 2047, 17, 18 \/* for region 100 *\/,\n+                      1,  128, 35, 17 \/* for region 990 *\/\n+                    };\n+    translate_cards(CardsPerRegion, 100, &cards1[0], 4);\n+    translate_cards(CardsPerRegion, 990, &cards1[4], 4);\n+\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[100];\n+    for (uint i = 0; i < ARRAY_SIZE(cards1); i++) {\n+      cards1[i] = i + 3;\n+      translate_cards(CardsPerRegion, i, &cards1[i], 1);\n+    }\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+\n+    ASSERT_TRUE(card_set.num_containers() == ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    \/\/ Generate non-prime numbers from 1 to 1000\n+    uint count = 0;\n+    for (uint i = 2; i < 33; i++) {\n+      if (!card_set.contains_card(100, i)) {\n+        for (uint j = i * i; j < 1000; j += i) {\n+          G1AddCardResult res = card_set.add_card(100, j);\n+          count += (res == Added);\n+        }\n+      }\n+    }\n+\n+    G1CountCardsOccupied cl;\n+    card_set.iterate_containers(&cl);\n+\n+    ASSERT_TRUE(count == card_set.occupied());\n+    ASSERT_TRUE(card_set.occupied() == cl.num_occupied());\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+  { \/\/ Test coarsening to full\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint count = 0;\n+    uint i = 10;\n+    uint bitmap_threshold = config.cards_in_howl_bitmap_threshold();\n+    for (; i <  bitmap_threshold + 10; i++) {\n+      G1AddCardResult res = card_set.add_card(99, i);\n+      ASSERT_TRUE(res == Added);\n+      count++;\n+      ASSERT_TRUE(count == card_set.occupied());\n+    }\n+\n+    G1AddCardResult res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 1);\n+    \/\/ Adding above card should have coarsened Bitmap -> Full.\n+    ASSERT_TRUE(res == Added);\n+    ASSERT_TRUE(config.num_cards_in_howl_bitmap() == card_set.occupied());\n+\n+    res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 2);\n+    ASSERT_TRUE(res == Found);\n+\n+    uint threshold = config.cards_in_howl_threshold();\n+    uint adjusted_threshold = config.cards_in_howl_bitmap_threshold() * config.num_buckets_in_howl();\n+    i = config.num_cards_in_howl_bitmap();\n+    count = i;\n+    for (; i <  threshold; i++) {\n+      G1AddCardResult res = card_set.add_card(99, i);\n+      ASSERT_TRUE(res == Added);\n+      count++;\n+      ASSERT_TRUE(count == card_set.occupied());\n+    }\n+\n+    res = card_set.add_card(99, CardsPerRegion - 1);\n+    \/\/ Adding above card should have coarsened Howl -> Full.\n+    ASSERT_TRUE(res == Added);\n+    ASSERT_TRUE(CardsPerRegion == card_set.occupied());\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    res = card_set.add_card(99, CardsPerRegion - 2);\n+    ASSERT_TRUE(res == Found);\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == config.max_cards_in_region());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+}\n+\n+class G1CardSetMtTestTask : public AbstractGangTask {\n+  G1CardSet* _card_set;\n+\n+  size_t _added;\n+  size_t _found;\n+\n+public:\n+  G1CardSetMtTestTask(G1CardSet* card_set) :\n+    AbstractGangTask(\"\"),\n+    _card_set(card_set),\n+    _added(0),\n+    _found(0) { }\n+\n+  void work(uint worker_id) {\n+    uint seed = worker_id;\n+    size_t added = 0;\n+    size_t found = 0;\n+\n+    for (uint i = 0; i < 100000; i++) {\n+      uint region = G1CardSetTest::next_random(seed, 1000);\n+      uint card = G1CardSetTest::next_random(seed, 10000);\n+\n+      G1AddCardResult res = _card_set->add_card(region, card);\n+\n+      ASSERT_TRUE(res == Added || res == Found);\n+      if (res == Added) {\n+        added++;\n+      } else if (res == Found) {\n+        found++;\n+      }\n+    }\n+    Atomic::add(&_added, added);\n+    Atomic::add(&_found, found);\n+  }\n+\n+  size_t added() const { return _added; }\n+  size_t found() const { return _found; }\n+};\n+\n+void G1CardSetTest::cardset_mt_test() {\n+  const uint CardsPerRegion = 16384;\n+  const double FullCardSetThreshold = 1.0;\n+  const uint BitmapCoarsenThreshold = 1.0;\n+\n+  G1CardSetConfiguration config(log2i_exact(CardsPerRegion), 120, BitmapCoarsenThreshold, 8, FullCardSetThreshold, CardsPerRegion);\n+  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1CardSetMemoryManager mm(&config, &free_pool);\n+\n+  G1CardSet card_set(&config, &mm);\n+\n+  const uint num_workers = workers()->active_workers();\n+\n+  G1CardSetMtTestTask cl(&card_set);\n+\n+  {\n+    GCTraceTime(Error, gc) x(\"Cardset test\");\n+    _workers->run_task(&cl, num_workers);\n+  }\n+\n+  size_t num_found = 0;\n+  \/\/ Now check the contents of the card set.\n+  for (uint i = 0; i < num_workers; i++) {\n+    uint seed = i;\n+\n+    for (uint j = 0; j < 100000; j++) {\n+      uint region = G1CardSetTest::next_random(seed, 1000);\n+      uint card = G1CardSetTest::next_random(seed, 10000);\n+\n+      bool contains = card_set.contains_card(region, card);\n+      ASSERT_TRUE(contains);\n+\n+      num_found += contains;\n+    }\n+  }\n+\n+  ASSERT_TRUE(num_found == cl.added() + cl.found());\n+\n+  G1CountCardsClosure count_cards;\n+  card_set.iterate_cards(count_cards);\n+\n+  check_iteration(&card_set, count_cards._num_cards, false \/* add_was_single_threaded *\/);\n+\n+  \/\/ During coarsening we try to unblock concurrent threads as soon as possible,\n+  \/\/ so we do not add the cards from the smaller CardSetContainer to the larger\n+  \/\/ one immediately, allowing addition by concurrent threads after allocating\n+  \/\/ the space immediately. So the amount of \"successfully added\" results may be\n+  \/\/ (and in case of many threads typically is) higher than the number of unique\n+  \/\/ cards.\n+  ASSERT_TRUE(count_cards._num_cards <= cl.added());\n+}\n+\n+TEST_VM(G1CardSetTest, basic_cardset_test) {\n+  G1CardSetTest::cardset_basic_test();\n+}\n+\n+TEST_VM(G1CardSetTest, mt_cardset_test) {\n+  G1CardSetTest::cardset_mt_test();\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/heapRegionBounds.inline.hpp\"\n+#include \"gc\/shared\/cardTable.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1CardSetContainersTest : public ::testing::Test {\n+public:\n+  G1CardSetContainersTest() { }\n+  ~G1CardSetContainersTest() { }\n+\n+  static uint cards_per_inlineptr_set(uint bits_per_card) {\n+    return G1CardSetInlinePtr::max_cards_in_inline_ptr(bits_per_card);\n+  }\n+\n+  static void cardset_inlineptr_test(uint bits_per_card);\n+  static void cardset_array_test(uint cards_per_array);\n+  static void cardset_bitmap_test(uint threshold, uint size_in_bits);\n+};\n+\n+class G1FindCardsInRange : public StackObj {\n+  uint _num_cards;\n+  uint _range_min;\n+  bool* _cards_found;\n+public:\n+  G1FindCardsInRange(uint range_min, uint range_max) :\n+    _num_cards(range_max - range_min + 1),\n+    _range_min(range_min),\n+    _cards_found(NEW_C_HEAP_ARRAY(bool, _num_cards, mtGC)) {\n+    for (uint i = 0; i < _num_cards; i++) {\n+      _cards_found[i] = false;\n+    }\n+  }\n+\n+  void verify_all_found() {\n+    verify_part_found(_num_cards);\n+  }\n+\n+  void verify_part_found(uint num) {\n+    for (uint i = 0; i < num; i++) {\n+      ASSERT_TRUE(_cards_found[i]);\n+    }\n+  }\n+\n+  ~G1FindCardsInRange() {\n+    FREE_C_HEAP_ARRAY(mtGC, _cards_found);\n+  }\n+  void operator()(uint card) {\n+    ASSERT_TRUE((card - _range_min) < _num_cards);\n+    ASSERT_FALSE(_cards_found[card - _range_min]); \/\/ Must not have been found yet.\n+    _cards_found[card - _range_min] = true;\n+  }\n+};\n+\n+void G1CardSetContainersTest::cardset_inlineptr_test(uint bits_per_card) {\n+  const uint CardsPerSet = cards_per_inlineptr_set(bits_per_card);\n+\n+  G1AddCardResult res;\n+\n+  G1CardSet::CardSetPtr value = G1CardSetInlinePtr();\n+\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    {\n+      G1CardSetInlinePtr cards(&value, value);\n+      res = cards.add(i + 1, bits_per_card, CardsPerSet);\n+      ASSERT_TRUE(res == Added);\n+    }\n+    {\n+      G1CardSetInlinePtr cards(&value, value);\n+      ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+    }\n+  }\n+\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(&value, value);\n+    res = cards.add(i + 1, bits_per_card, CardsPerSet);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    G1CardSetInlinePtr cards(&value, value);\n+    res = cards.add(CardsPerSet + 1, bits_per_card, CardsPerSet);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+  }\n+\n+  \/\/ Boundary cards should not be in the set.\n+  {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(!cards.contains(0, bits_per_card));\n+    ASSERT_TRUE(!cards.contains(CardsPerSet + 1, bits_per_card));\n+  }\n+\n+  \/\/ Verify iteration finds all cards too and only those.\n+  {\n+    G1FindCardsInRange found(1, CardsPerSet);\n+    G1CardSetInlinePtr cards(value);\n+    cards.iterate(found, bits_per_card);\n+    found.verify_all_found();\n+  }\n+}\n+\n+void G1CardSetContainersTest::cardset_array_test(uint cards_per_array) {\n+  uint8_t* cardset_data = NEW_C_HEAP_ARRAY(uint8_t, G1CardSetArray::size_in_bytes(cards_per_array), mtGC);\n+  G1CardSetArray* cards = new (cardset_data) G1CardSetArray(1, cards_per_array);\n+\n+  ASSERT_TRUE(cards->contains(1)); \/\/ Added during initialization\n+  ASSERT_TRUE(cards->num_entries() == 1); \/\/ Check it's the only one.\n+\n+  G1AddCardResult res;\n+\n+  \/\/ Add some elements\n+  for (uint i = 1; i < cards_per_array; i++) {\n+    res = cards->add(i + 1);\n+    ASSERT_TRUE(res == Added);\n+  }\n+\n+  \/\/ Check they are in the container.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    res = cards->add(i + 1);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    res = cards->add(cards_per_array + 1);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1));\n+  }\n+\n+  ASSERT_TRUE(!cards->contains(0));\n+  ASSERT_TRUE(!cards->contains(cards_per_array + 1));\n+\n+  \/\/ Verify iteration finds all cards too.\n+  {\n+    G1FindCardsInRange found(1, cards_per_array);\n+    cards->iterate(found);\n+    found.verify_all_found();\n+  }\n+\n+  FREE_C_HEAP_ARRAY(mtGC, cardset_data);\n+}\n+\n+void G1CardSetContainersTest::cardset_bitmap_test(uint threshold, uint size_in_bits) {\n+  uint8_t* cardset_data = NEW_C_HEAP_ARRAY(uint8_t, G1CardSetBitMap::size_in_bytes(size_in_bits), mtGC);\n+  G1CardSetBitMap* cards = new (cardset_data) G1CardSetBitMap(1, size_in_bits);\n+\n+  ASSERT_TRUE(cards->contains(1, size_in_bits)); \/\/ Added during initialization\n+  ASSERT_TRUE(cards->num_bits_set() == 1); \/\/ Should be the only one.\n+\n+  G1AddCardResult res;\n+\n+  for (uint i = 1; i < threshold; i++) {\n+    res = cards->add(i + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Added);\n+  }\n+\n+  for (uint i = 0; i < threshold; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1, size_in_bits));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < threshold; i++) {\n+    res = cards->add(i + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    res = cards->add(threshold + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < threshold; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1, size_in_bits));\n+  }\n+\n+  ASSERT_TRUE(!cards->contains(0, size_in_bits));\n+\n+  \/\/ Verify iteration finds all cards too.\n+  {\n+    G1FindCardsInRange found(1, threshold + 1);\n+    cards->iterate(found, size_in_bits, 0);\n+    found.verify_part_found(threshold);\n+  }\n+\n+  FREE_C_HEAP_ARRAY(mtGC, cardset_data);\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_inptr_test) {\n+  uint const min = (uint)log2i(HeapRegionBounds::min_size());\n+  uint const max = (uint)log2i(HeapRegionBounds::max_size());\n+\n+  for (uint i = min; i <= max; i++) {\n+    G1CardSetContainersTest::cardset_inlineptr_test(i - CardTable::card_shift);\n+  }\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_array_test) {\n+  uint array_sizes[] = { 5, 9, 63, 77, 127 };\n+\n+  for (uint i = 0; i < ARRAY_SIZE(array_sizes); i++) {\n+    size_t const max_cards_in_set = ARRAY_SIZE(array_sizes);\n+    G1CardSetContainersTest::cardset_array_test(max_cards_in_set);\n+  }\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_bitmap_test) {\n+  uint bit_sizes[] = { 64, 2048 };\n+  uint threshold_sizes[] = { 17, 330 };\n+\n+  for (uint i = 0; i < ARRAY_SIZE(bit_sizes); i++) {\n+    G1CardSetContainersTest::cardset_bitmap_test(threshold_sizes[i], bit_sizes[i]);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSetContainers.cpp","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -44,1 +44,0 @@\n-  ASSERT_TRUE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n@@ -48,0 +47,1 @@\n+  ASSERT_TRUE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyYoungEvacFail));\n@@ -54,1 +54,0 @@\n-  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n@@ -58,0 +57,1 @@\n+  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyYoungEvacFail));\n@@ -82,3 +82,0 @@\n-\n-  \/\/ Enabling all is not the same as G1VerifyAll\n-  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1HeapVerifier.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,7 +29,0 @@\n-class ScopedDisabledBiasedLocking {\n-  bool _orig;\n-public:\n-  ScopedDisabledBiasedLocking() : _orig(UseBiasedLocking) { UseBiasedLocking = false; }\n-  ~ScopedDisabledBiasedLocking() { UseBiasedLocking = _orig; }\n-};\n-\n@@ -59,4 +52,0 @@\n-  \/\/ Need to disable biased locking to easily\n-  \/\/ create oops that \"must_be_preseved\"\n-  ScopedDisabledBiasedLocking dbl;\n-\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -54,6 +53,0 @@\n-static void assert_not_test_pattern(Handle object, const char* pattern) {\n-  stringStream st;\n-  object->print_on(&st);\n-  ASSERT_FALSE(test_pattern(&st, pattern)) << pattern << \" found in \" << st.as_string();\n-}\n-\n@@ -96,21 +89,1 @@\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    \/\/ Can't test this with biased locking disabled.\n-    \/\/ Biased locking is initially enabled for this java.lang.Byte object.\n-    assert_test_pattern(h_obj, \"is_biased\");\n-\n-    \/\/ Lock using biased locking.\n-    BasicObjectLock lock;\n-    lock.set_obj(obj);\n-    markWord prototype_header = obj->klass()->prototype_header();\n-    markWord mark = obj->mark();\n-    markWord biased_mark = markWord::encode((JavaThread*) THREAD, mark.age(), prototype_header.bias_epoch());\n-    obj->set_mark(biased_mark);\n-    \/\/ Look for the biased_locker in markWord, not prototype_header.\n-#ifdef _LP64\n-    assert_not_test_pattern(h_obj, \"mark(is_biased biased_locker=0x0000000000000000\");\n-#else\n-    assert_not_test_pattern(h_obj, \"mark(is_biased biased_locker=0x00000000\");\n-#endif\n-  }\n-\n-  \/\/ Same thread tries to lock it again.\n+  \/\/ Thread tries to lock it.\n@@ -121,2 +94,0 @@\n-\n-  \/\/ This is no longer biased, because ObjectLocker revokes the bias.\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,302 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/lockFreeQueue.inline.hpp\"\n-#include \"utilities\/pair.hpp\"\n-#include \"threadHelper.inline.hpp\"\n-#include \"unittest.hpp\"\n-#include <new>\n-\n-class LockFreeQueueTestElement {\n-  typedef LockFreeQueueTestElement Element;\n-\n-  Element* volatile _entry;\n-  Element* volatile _entry1;\n-  size_t _id;\n-\n-  static Element* volatile* entry_ptr(Element& e) { return &e._entry; }\n-  static Element* volatile* entry1_ptr(Element& e) { return &e._entry1; }\n-\n-public:\n-  class TestQueue: public LockFreeQueue<Element, &entry_ptr> {\n-  public:\n-    Element* pop() {\n-      using Status = LockFreeQueuePopStatus;\n-      while (true) {\n-        Pair<Status, Element*> pop_result = try_pop();\n-        if (pop_result.first == Status::success) {\n-          return pop_result.second;\n-        }\n-        \/\/ Retry until success.\n-      }\n-    }\n-  };\n-  class TestQueue1: public LockFreeQueue<Element, &entry1_ptr> {\n-  public:\n-    Element* pop() {\n-      using Status = LockFreeQueuePopStatus;\n-      while (true) {\n-        Pair<Status, Element*> pop_result = try_pop();\n-        if (pop_result.first == Status::success) {\n-          return pop_result.second;\n-        }\n-        \/\/ Retry until success.\n-      }\n-    }\n-  };\n-\n-  LockFreeQueueTestElement(size_t id = 0) : _entry(), _entry1(), _id(id) {}\n-  size_t id() const { return _id; }\n-  void set_id(size_t value) { _id = value; }\n-  Element* next() { return _entry; }\n-  Element* next1() { return _entry1; }\n-};\n-\n-typedef LockFreeQueueTestElement Element;\n-typedef Element::TestQueue TestQueue;\n-typedef Element::TestQueue1 TestQueue1;\n-\n-static void initialize(Element* elements, size_t size, TestQueue* queue) {\n-  for (size_t i = 0; i < size; ++i) {\n-    elements[i].set_id(i);\n-  }\n-  ASSERT_TRUE(queue->empty());\n-  ASSERT_EQ(0u, queue->length());\n-  ASSERT_TRUE(queue->pop() == NULL);\n-  ASSERT_TRUE(queue->top() == NULL);\n-\n-  for (size_t id = 0; id < size; ++id) {\n-    ASSERT_EQ(id, queue->length());\n-    Element* e = &elements[id];\n-    ASSERT_EQ(id, e->id());\n-    queue->push(*e);\n-    ASSERT_FALSE(queue->empty());\n-    \/\/ top() is always the oldest element.\n-    ASSERT_EQ(&elements[0], queue->top());\n-  }\n-}\n-\n-class LockFreeQueueTestBasics : public ::testing::Test {\n-public:\n-  LockFreeQueueTestBasics();\n-\n-  static const size_t nelements = 10;\n-  Element elements[nelements];\n-  TestQueue queue;\n-};\n-\n-const size_t LockFreeQueueTestBasics::nelements;\n-\n-LockFreeQueueTestBasics::LockFreeQueueTestBasics() : queue() {\n-  initialize(elements, nelements, &queue);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, pop) {\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_FALSE(queue.empty());\n-    ASSERT_EQ(nelements - i, queue.length());\n-    Element* e = queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-  }\n-  ASSERT_TRUE(queue.empty());\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, append) {\n-  TestQueue other_queue;\n-  ASSERT_TRUE(other_queue.empty());\n-  ASSERT_EQ(0u, other_queue.length());\n-  ASSERT_TRUE(other_queue.top() == NULL);\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n-\n-  Pair<Element*, Element*> pair = queue.take_all();\n-  other_queue.append(*pair.first, *pair.second);\n-  ASSERT_EQ(nelements, other_queue.length());\n-  ASSERT_TRUE(queue.empty());\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-  ASSERT_TRUE(queue.top() == NULL);\n-\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_EQ(nelements - i, other_queue.length());\n-    Element* e = other_queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-  }\n-  ASSERT_EQ(0u, other_queue.length());\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, two_queues) {\n-  TestQueue1 queue1;\n-  ASSERT_TRUE(queue1.pop() == NULL);\n-\n-  for (size_t id = 0; id < nelements; ++id) {\n-    queue1.push(elements[id]);\n-  }\n-  ASSERT_EQ(nelements, queue1.length());\n-  Element* e0 = queue.top();\n-  Element* e1 = queue1.top();\n-  while (true) {\n-    ASSERT_EQ(e0, e1);\n-    if (e0 == NULL) break;\n-    e0 = e0->next();\n-    e1 = e1->next1();\n-  }\n-\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_EQ(nelements - i, queue.length());\n-    ASSERT_EQ(nelements - i, queue1.length());\n-\n-    Element* e = queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-\n-    Element* e1 = queue1.pop();\n-    ASSERT_TRUE(e1 != NULL);\n-    ASSERT_EQ(&elements[i], e1);\n-    ASSERT_EQ(i, e1->id());\n-\n-    ASSERT_EQ(e, e1);\n-  }\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_EQ(0u, queue1.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-  ASSERT_TRUE(queue1.pop() == NULL);\n-}\n-\n-class LockFreeQueueTestThread : public JavaTestThread {\n-  uint _id;\n-  TestQueue* _from;\n-  TestQueue* _to;\n-  volatile size_t* _processed;\n-  size_t _process_limit;\n-  size_t _local_processed;\n-  volatile bool _ready;\n-\n-public:\n-  LockFreeQueueTestThread(Semaphore* post,\n-                          uint id,\n-                          TestQueue* from,\n-                          TestQueue* to,\n-                          volatile size_t* processed,\n-                          size_t process_limit) :\n-    JavaTestThread(post),\n-    _id(id),\n-    _from(from),\n-    _to(to),\n-    _processed(processed),\n-    _process_limit(process_limit),\n-    _local_processed(0),\n-    _ready(false)\n-  {}\n-\n-  virtual void main_run() {\n-    Atomic::release_store_fence(&_ready, true);\n-    while (true) {\n-      Element* e = _from->pop();\n-      if (e != NULL) {\n-        _to->push(*e);\n-        Atomic::inc(_processed);\n-        ++_local_processed;\n-      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n-        tty->print_cr(\"thread %u processed \" SIZE_FORMAT, _id, _local_processed);\n-        return;\n-      }\n-    }\n-  }\n-\n-  bool ready() const { return Atomic::load_acquire(&_ready); }\n-};\n-\n-TEST_VM(LockFreeQueueTest, stress) {\n-  Semaphore post;\n-  TestQueue initial_queue;\n-  TestQueue start_queue;\n-  TestQueue middle_queue;\n-  TestQueue final_queue;\n-  volatile size_t stage1_processed = 0;\n-  volatile size_t stage2_processed = 0;\n-\n-  const size_t nelements = 10000;\n-  Element* elements = NEW_C_HEAP_ARRAY(Element, nelements, mtOther);\n-  for (size_t id = 0; id < nelements; ++id) {\n-    ::new (&elements[id]) Element(id);\n-    initial_queue.push(elements[id]);\n-  }\n-  ASSERT_EQ(nelements, initial_queue.length());\n-\n-  \/\/ - stage1 threads pop from start_queue and push to middle_queue.\n-  \/\/ - stage2 threads pop from middle_queue and push to final_queue.\n-  \/\/ - all threads in a stage count the number of elements processed in\n-  \/\/   their corresponding stageN_processed counter.\n-\n-  const uint stage1_threads = 2;\n-  const uint stage2_threads = 2;\n-  const uint nthreads = stage1_threads + stage2_threads;\n-  LockFreeQueueTestThread* threads[nthreads] = {};\n-\n-  for (uint i = 0; i < ARRAY_SIZE(threads); ++i) {\n-    TestQueue* from = &start_queue;\n-    TestQueue* to = &middle_queue;\n-    volatile size_t* processed = &stage1_processed;\n-    if (i >= stage1_threads) {\n-      from = &middle_queue;\n-      to = &final_queue;\n-      processed = &stage2_processed;\n-    }\n-    threads[i] =\n-      new LockFreeQueueTestThread(&post, i, from, to, processed, nelements);\n-    threads[i]->doit();\n-    while (!threads[i]->ready()) {} \/\/ Wait until ready to start test.\n-  }\n-\n-  \/\/ Transfer elements to start_queue to start test.\n-  Pair<Element*, Element*> pair = initial_queue.take_all();\n-  start_queue.append(*pair.first, *pair.second);\n-\n-  \/\/ Wait for all threads to complete.\n-  for (uint i = 0; i < nthreads; ++i) {\n-    post.wait();\n-  }\n-\n-  \/\/ Verify expected state.\n-  ASSERT_EQ(nelements, stage1_processed);\n-  ASSERT_EQ(nelements, stage2_processed);\n-  ASSERT_EQ(0u, initial_queue.length());\n-  ASSERT_EQ(0u, start_queue.length());\n-  ASSERT_EQ(0u, middle_queue.length());\n-  ASSERT_EQ(nelements, final_queue.length());\n-  while (final_queue.pop() != NULL) {}\n-\n-  FREE_C_HEAP_ARRAY(Element, elements);\n-}\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeQueue.cpp","additions":0,"deletions":302,"binary":false,"changes":302,"status":"deleted"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n+#include \"utilities\/pair.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+#include <new>\n+\n+class NonblockingQueueTestElement {\n+  typedef NonblockingQueueTestElement Element;\n+\n+  Element* volatile _entry;\n+  Element* volatile _entry1;\n+  size_t _id;\n+\n+  static Element* volatile* entry_ptr(Element& e) { return &e._entry; }\n+  static Element* volatile* entry1_ptr(Element& e) { return &e._entry1; }\n+\n+public:\n+  using TestQueue = NonblockingQueue<Element, &entry_ptr>;\n+  using TestQueue1 = NonblockingQueue<Element, &entry1_ptr>;\n+\n+  NonblockingQueueTestElement(size_t id = 0) : _entry(), _entry1(), _id(id) {}\n+  size_t id() const { return _id; }\n+  void set_id(size_t value) { _id = value; }\n+  Element* next() { return _entry; }\n+  Element* next1() { return _entry1; }\n+};\n+\n+typedef NonblockingQueueTestElement Element;\n+typedef Element::TestQueue TestQueue;\n+typedef Element::TestQueue1 TestQueue1;\n+\n+static void initialize(Element* elements, size_t size, TestQueue* queue) {\n+  for (size_t i = 0; i < size; ++i) {\n+    elements[i].set_id(i);\n+  }\n+  ASSERT_TRUE(queue->empty());\n+  ASSERT_EQ(0u, queue->length());\n+  ASSERT_TRUE(queue->is_end(queue->first()));\n+  ASSERT_TRUE(queue->pop() == NULL);\n+\n+  for (size_t id = 0; id < size; ++id) {\n+    ASSERT_EQ(id, queue->length());\n+    Element* e = &elements[id];\n+    ASSERT_EQ(id, e->id());\n+    queue->push(*e);\n+    ASSERT_FALSE(queue->empty());\n+    \/\/ first() is always the oldest element.\n+    ASSERT_EQ(&elements[0], queue->first());\n+  }\n+}\n+\n+class NonblockingQueueTestBasics : public ::testing::Test {\n+public:\n+  NonblockingQueueTestBasics();\n+\n+  static const size_t nelements = 10;\n+  Element elements[nelements];\n+  TestQueue queue;\n+};\n+\n+const size_t NonblockingQueueTestBasics::nelements;\n+\n+NonblockingQueueTestBasics::NonblockingQueueTestBasics() : queue() {\n+  initialize(elements, nelements, &queue);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, pop) {\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_FALSE(queue.empty());\n+    ASSERT_EQ(nelements - i, queue.length());\n+    Element* e = queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+  }\n+  ASSERT_TRUE(queue.empty());\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, append) {\n+  TestQueue other_queue;\n+  ASSERT_TRUE(other_queue.empty());\n+  ASSERT_EQ(0u, other_queue.length());\n+  ASSERT_TRUE(other_queue.is_end(other_queue.first()));\n+  ASSERT_TRUE(other_queue.pop() == NULL);\n+\n+  Pair<Element*, Element*> pair = queue.take_all();\n+  other_queue.append(*pair.first, *pair.second);\n+  ASSERT_EQ(nelements, other_queue.length());\n+  ASSERT_TRUE(queue.empty());\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_TRUE(queue.is_end(queue.first()));\n+  ASSERT_TRUE(queue.pop() == NULL);\n+\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_EQ(nelements - i, other_queue.length());\n+    Element* e = other_queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+  }\n+  ASSERT_EQ(0u, other_queue.length());\n+  ASSERT_TRUE(other_queue.pop() == NULL);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, two_queues) {\n+  TestQueue1 queue1;\n+  ASSERT_TRUE(queue1.pop() == NULL);\n+\n+  for (size_t id = 0; id < nelements; ++id) {\n+    queue1.push(elements[id]);\n+  }\n+  ASSERT_EQ(nelements, queue1.length());\n+  Element* e0 = queue.first();\n+  Element* e1 = queue1.first();\n+  ASSERT_TRUE(e0 != NULL);\n+  ASSERT_TRUE(e1 != NULL);\n+  ASSERT_FALSE(queue.is_end(e0));\n+  ASSERT_FALSE(queue1.is_end(e1));\n+  while (!queue.is_end(e0) && !queue1.is_end(e1)) {\n+    ASSERT_EQ(e0, e1);\n+    e0 = e0->next();\n+    e1 = e1->next1();\n+  }\n+  ASSERT_TRUE(queue.is_end(e0));\n+  ASSERT_TRUE(queue1.is_end(e1));\n+\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_EQ(nelements - i, queue.length());\n+    ASSERT_EQ(nelements - i, queue1.length());\n+\n+    Element* e = queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+\n+    Element* e1 = queue1.pop();\n+    ASSERT_TRUE(e1 != NULL);\n+    ASSERT_EQ(&elements[i], e1);\n+    ASSERT_EQ(i, e1->id());\n+\n+    ASSERT_EQ(e, e1);\n+  }\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_EQ(0u, queue1.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue1.pop() == NULL);\n+}\n+\n+class NonblockingQueueTestThread : public JavaTestThread {\n+  uint _id;\n+  TestQueue* _from;\n+  TestQueue* _to;\n+  volatile size_t* _processed;\n+  size_t _process_limit;\n+  size_t _local_processed;\n+  volatile bool _ready;\n+\n+public:\n+  NonblockingQueueTestThread(Semaphore* post,\n+                             uint id,\n+                             TestQueue* from,\n+                             TestQueue* to,\n+                             volatile size_t* processed,\n+                             size_t process_limit) :\n+    JavaTestThread(post),\n+    _id(id),\n+    _from(from),\n+    _to(to),\n+    _processed(processed),\n+    _process_limit(process_limit),\n+    _local_processed(0),\n+    _ready(false)\n+  {}\n+\n+  virtual void main_run() {\n+    Atomic::release_store_fence(&_ready, true);\n+    while (true) {\n+      Element* e = _from->pop();\n+      if (e != NULL) {\n+        _to->push(*e);\n+        Atomic::inc(_processed);\n+        ++_local_processed;\n+      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n+        tty->print_cr(\"thread %u processed \" SIZE_FORMAT, _id, _local_processed);\n+        return;\n+      }\n+    }\n+  }\n+\n+  bool ready() const { return Atomic::load_acquire(&_ready); }\n+};\n+\n+TEST_VM(NonblockingQueueTest, stress) {\n+  Semaphore post;\n+  TestQueue initial_queue;\n+  TestQueue start_queue;\n+  TestQueue middle_queue;\n+  TestQueue final_queue;\n+  volatile size_t stage1_processed = 0;\n+  volatile size_t stage2_processed = 0;\n+\n+  const size_t nelements = 10000;\n+  Element* elements = NEW_C_HEAP_ARRAY(Element, nelements, mtOther);\n+  for (size_t id = 0; id < nelements; ++id) {\n+    ::new (&elements[id]) Element(id);\n+    initial_queue.push(elements[id]);\n+  }\n+  ASSERT_EQ(nelements, initial_queue.length());\n+\n+  \/\/ - stage1 threads pop from start_queue and push to middle_queue.\n+  \/\/ - stage2 threads pop from middle_queue and push to final_queue.\n+  \/\/ - all threads in a stage count the number of elements processed in\n+  \/\/   their corresponding stageN_processed counter.\n+\n+  const uint stage1_threads = 2;\n+  const uint stage2_threads = 2;\n+  const uint nthreads = stage1_threads + stage2_threads;\n+  NonblockingQueueTestThread* threads[nthreads] = {};\n+\n+  for (uint i = 0; i < ARRAY_SIZE(threads); ++i) {\n+    TestQueue* from = &start_queue;\n+    TestQueue* to = &middle_queue;\n+    volatile size_t* processed = &stage1_processed;\n+    if (i >= stage1_threads) {\n+      from = &middle_queue;\n+      to = &final_queue;\n+      processed = &stage2_processed;\n+    }\n+    threads[i] =\n+      new NonblockingQueueTestThread(&post, i, from, to, processed, nelements);\n+    threads[i]->doit();\n+    while (!threads[i]->ready()) {} \/\/ Wait until ready to start test.\n+  }\n+\n+  \/\/ Transfer elements to start_queue to start test.\n+  Pair<Element*, Element*> pair = initial_queue.take_all();\n+  start_queue.append(*pair.first, *pair.second);\n+\n+  \/\/ Wait for all threads to complete.\n+  for (uint i = 0; i < nthreads; ++i) {\n+    post.wait();\n+  }\n+\n+  \/\/ Verify expected state.\n+  ASSERT_EQ(nelements, stage1_processed);\n+  ASSERT_EQ(nelements, stage2_processed);\n+  ASSERT_EQ(0u, initial_queue.length());\n+  ASSERT_EQ(0u, start_queue.length());\n+  ASSERT_EQ(0u, middle_queue.length());\n+  ASSERT_EQ(nelements, final_queue.length());\n+  while (final_queue.pop() != NULL) {}\n+\n+  FREE_C_HEAP_ARRAY(Element, elements);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_nonblockingQueue.cpp","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -43,4 +43,0 @@\n-\n-serviceability\/dcmd\/framework\/HelpTest.java                   8268433 windows-x64\n-serviceability\/dcmd\/framework\/InvalidCommandTest.java         8268433 windows-x64\n-serviceability\/dcmd\/framework\/VMVersionTest.java              8268433 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+vmTestbase\/nsk\/jdi\/HiddenClass\/events\/events001.java                 8257705 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccess.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccessStressGCM.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @author Yi Yang\n+ * @bug 8265518\n+ * @summary C1 intrinsic support for jdk.internal.util.Preconditions.checkIndex\n+ * @requires vm.compiler1.enabled\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.util\n+ * @run main\/othervm -XX:TieredStopAtLevel=1 -Xbatch\n+ *                   -XX:CompileCommand=dontinline,*TestCheckIndexC1Intrinsic.check*\n+ *                   -XX:CompileCommand=compileonly,*TestCheckIndexC1Intrinsic.check*\n+ *                   compiler.c1.TestCheckIndexC1Intrinsic\n+ *\/\n+\n+package compiler.c1;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.util.Preconditions;\n+\n+public class TestCheckIndexC1Intrinsic {\n+    static int limit = 100;\n+\n+    private static class MyException extends RuntimeException {\n+        public MyException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    static void check0() {\n+        long res = Preconditions.checkIndex(0, 1, null);\n+        Asserts.assertEquals((int)res, 0);\n+        try {\n+            Preconditions.checkIndex(1, 1, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Integer.MIN_VALUE, -1, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Integer.MIN_VALUE, Integer.MIN_VALUE, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Long.MAX_VALUE, Long.MAX_VALUE, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        res = Preconditions.checkIndex(Long.MAX_VALUE - 1, Long.MAX_VALUE, null);\n+        Asserts.assertEquals(res, Long.MAX_VALUE - 1);\n+\n+        try {\n+            \/\/ read fields\n+            Preconditions.checkIndex(limit + 1, limit, (s, integers) -> new MyException(\"Reason:\" + s + \"::\" + integers));\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch(MyException e){\n+            \/\/ got it!\n+        }\n+    }\n+\n+    static void check1(int i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999, (s, integers) -> new RuntimeException(\"ex\"));\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(\"ex\".equals(e.getMessage()));\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check2(long i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999L, (s, integers) -> new RuntimeException(\"ex\"));\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(\"ex\".equals(e.getMessage()));\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check3(int i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999, null);\n+        } catch (IndexOutOfBoundsException e) {\n+            Asserts.assertTrue(i == 9999);\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check4(long i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999L, null);\n+        } catch (IndexOutOfBoundsException e) {\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check5(int i) {\n+        Preconditions.checkIndex(i, 99999, (s, integers) -> new RuntimeException(\"ex\"));\n+    }\n+\n+    static void check6(long i) {\n+        Preconditions.checkIndex(i, 99999L, (s, integers) -> new RuntimeException(\"ex\"));\n+    }\n+\n+    static void check7(int i) {\n+        Preconditions.checkIndex(i, 99999, null);\n+    }\n+\n+    static void check8(long i) {\n+        Preconditions.checkIndex(i, 99999L, null);\n+    }\n+\n+    static void check9(int i) {\n+        Preconditions.checkIndex(i, i + 1, null);\n+    }\n+\n+    static void check10(long i) {\n+        Preconditions.checkIndex(i, i + 1L, null);\n+    }\n+\n+    public static void main(String... args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            check0();\n+\n+            check1(i);\n+            check2((long) i);\n+            check3(i);\n+            check4((long) i);\n+\n+            check5(i);\n+            check6((long) i);\n+            check7(i);\n+            check8((long) i);\n+\n+            check9(i);\n+            check10((long)i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestCheckIndexC1Intrinsic.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8062950\n- * @requires vm.flavor == \"server\"\n- * @library \/test\/lib\n- * @run driver compiler.c2.Test8062950\n- *\/\n-\n-package compiler.c2;\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class Test8062950 {\n-    private static final String CLASSNAME = \"DoesNotExist\";\n-    public static void main(String[] args) throws Exception {\n-        ProcessTools.executeTestJvm(\"-Xcomp\",\n-                                    \"-XX:-TieredCompilation\",\n-                                    \"-XX:-UseOptoBiasInlining\",\n-                                    CLASSNAME)\n-                    .shouldHaveExitValue(1)\n-                    .shouldContain(\"Error: Could not find or load main class \" + CLASSNAME)\n-                    .shouldNotContain(\"A fatal error has been detected\")\n-                    .shouldNotContain(\"Internal Error\")\n-                    .shouldNotContain(\"HotSpot Virtual Machine Error\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test8062950.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+ * @requires vm.compiler2.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestJumpTable.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReplaceEquivPhis.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -30,0 +31,8 @@\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8260585\n+ * @summary AArch64: Wrong code generated for shifting right and accumulating four unsigned short integers.\n+ * @requires vm.compiler2.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestShiftRightAndAccumulate.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8217990\n- * @summary With -XX:+UseOptoBiasInlining loading the markword is replaced by 0L if EliminateLocks is disabled. assert(dmw->is_neutral()) failed: invariant fails.\n- * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n- *\n- * @library \/test\/lib \/test\/hotspot\/jtreg\n- *\n- * @build sun.hotspot.WhiteBox\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n- *                   -XX:CompileCommand=compileonly,*.TestUseOptoBiasInliningWithoutEliminateLocks::dontinline_testMethod\n- *                   -XX:CompileCommand=dontinline,*::dontinline_*\n- *                   -XX:-EliminateLocks\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                   -Xbatch\n- *                   -XX:-TieredCompilation\n- *                   compiler.c2.TestUseOptoBiasInliningWithoutEliminateLocks\n- *\/\n-\n-package compiler.c2;\n-\n-import sun.hotspot.WhiteBox;\n-\n-public class TestUseOptoBiasInliningWithoutEliminateLocks {\n-\n-    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n-    public static void main(String[] args) {\n-        new TestUseOptoBiasInliningWithoutEliminateLocks().run();\n-    }\n-\n-    public boolean warmupDone;\n-\n-    public void run() {\n-        for(int i = 0; i < 30000; i++) {\n-            dontinline_testMethod();\n-        }\n-        warmupDone = true;\n-        dontinline_testMethod();\n-    }\n-\n-    public void dontinline_testMethod() {\n-        PointXY l1 = new PointXY(4.0f, 2.0f);\n-        synchronized (l1) {\n-            dontinline_deopt();\n-        }\n-    }\n-\n-    public void dontinline_deopt() {\n-        if (warmupDone) {\n-            WB.deoptimizeFrames(false);\n-        }\n-    }\n-\n-    static class PointXY {\n-\n-        public float fritz;\n-        public float felix;\n-\n-        public PointXY(float fritz_param, float felix_param) {\n-            this.fritz = fritz_param;\n-\/\/            this.felix = felix_param;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUseOptoBiasInliningWithoutEliminateLocks.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -61,1 +61,1 @@\n-                if (!out.getOutput().contains(\"-XX:+TieredCompilation not supported in this VM\")) {\n+                if (Platform.isTieredSupported()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n- * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,*ClearArrayTest.test -XX:+UnlockDiagnosticVMOptions -XX:-IdealizeClearArrayNode compiler.codegen.ClearArrayTest\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,*ClearArrayTest.test\n+ *                   -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:-IdealizeClearArrayNode\n+ *                   compiler.codegen.ClearArrayTest\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/ClearArrayTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,8 @@\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8001183\n+ * @summary incorrect results of char vectors right shift operation\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestCharVect2.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-                                    \/\/ to prevent biased locking handshakes from changing the timing of this test\n-                                    \"-XX:-UseBiasedLocking\",\n@@ -60,2 +58,0 @@\n-                                    \/\/ to prevent biased locking handshakes from changing the timing of this test\n-                                    \"-XX:-UseBiasedLocking\",\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8183543\n+ * @summary C2 compilation often fails on aarch64 with \"failed spill-split-recycle sanity check\"\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:-Inline\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:+PreserveFramePointer\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   compiler.regalloc.TestC2IntPressure\n+ *\/\n+\n+package compiler.regalloc;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class TestC2IntPressure {\n+\n+  static volatile int vol_f;\n+\n+  static void not_inlined() {\n+    \/\/ Do nothing\n+  }\n+\n+  static int test(TestC2IntPressure arg) {\n+    TestC2IntPressure a = arg;\n+    int res = 0;\n+    not_inlined();\n+    res = a.vol_f;\n+    return res;\n+  }\n+\n+  public static void main(String args[]) {\n+    TestC2IntPressure arg = new TestC2IntPressure();\n+    for (int i = 0; i < 10000; i++) {\n+      test(arg);\n+    }\n+    try {\n+      var method = TestC2IntPressure.class.getDeclaredMethod(\"test\", TestC2IntPressure.class);\n+      if (!WhiteBox.getWhiteBox().isMethodCompiled(method)) {\n+        throw new Error(\"test method didn't get compiled\");\n+      }\n+    } catch (NoSuchMethodException e) {\n+      throw new Error(\"TESTBUG : \" + e, e);\n+    }\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/regalloc\/TestC2IntPressure.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,0 @@\n-    protected static final String RTM_BIASED_LOCKING_WARNING\n-            = \"Biased locking is not supported with RTM locking; \"\n-            + \"ignoring UseBiasedLocking flag\";\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/RTMGenericCommandLineOptionTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of UseRTMLocking and UseBiasedLocking\n- *          options combination on CPU, OS, and VM with rtm support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMLockingOptionWithBiasedLocking\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMLockingOptionWithBiasedLocking {\n-\n-    public void runTestCases() throws Throwable {\n-        String warningMessage\n-                = RTMGenericCommandLineOptionTest.RTM_BIASED_LOCKING_WARNING;\n-        String shouldPassMessage = \"JVM startup should pass with both \"\n-                + \"-XX:+UseRTMLocking and \"\n-                + \"-XX:-UseBiasedLocking flags set without any warnings\";\n-        \/\/ verify that we will not get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[] { warningMessage }, shouldPassMessage,\n-                shouldPassMessage, ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:-UseBiasedLocking\");\n-\n-        \/\/ verify that we will get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { warningMessage }, null,\n-                \"JVM startup should pass when both -XX:+UseRTMLocking and \"\n-                        + \"-XX:+UseBiasedLocking flags set\",\n-                \"Flags -XX:+UseRTMLocking\"\n-                        + \" and -XX:+UseBiasedLocking conflicts. \"\n-                        + \"Warning should be shown.\", ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-        \/\/ verify that UseBiasedLocking is false when we use rtm locking\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseBiasedLocking\",\n-                \"false\",\n-                \"Value of option 'UseBiasedLocking' should be false if\"\n-                        + \"-XX:+UseRTMLocking flag set.\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-        \/\/ verify that we can't turn on biased locking when\n-        \/\/ using rtm locking\n-        CommandLineOptionTest\n-                .verifyOptionValueForSameVM(\n-                        \"UseBiasedLocking\",\n-                        \"false\",\n-                        \"Value of option 'UseBiasedLocking' should be false if\"\n-                                + \"both -XX:+UseRTMLocking and \"\n-                                + \"-XX:+UseBiasedLocking flags set.\",\n-                        CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                        \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockingOptionWithBiasedLocking().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionWithBiasedLocking.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8032011\n- * @summary biased locking's revoke_bias locks monitor in compiled frame with eliminated lock\n- *\n- * @run main\/othervm -XX:-UseOnStackReplacement\n- *      -XX:CompileCommand=dontinline,compiler.uncommontrap.TestLockEliminatedAtDeopt$A::m2\n- *      -XX:-BackgroundCompilation -XX:BiasedLockingStartupDelay=0\n- *      compiler.uncommontrap.TestLockEliminatedAtDeopt\n- *\/\n-\n-package compiler.uncommontrap;\n-\n-public class TestLockEliminatedAtDeopt {\n-\n-    static class A {\n-        void m() {\n-        }\n-\n-        \/\/ This lock is not eliminated but biased to main thread on\n-        \/\/ first call\n-        synchronized void m2(boolean trap) {\n-            if (trap) {\n-                new B();\n-            }\n-        }\n-    }\n-\n-    static class B extends A {\n-        void m() {\n-        }\n-    }\n-\n-    static void m1(boolean trap) {\n-        A a = new A();\n-        \/\/ This lock is eliminated by c2\n-        synchronized(a) {\n-            a.m2(trap);\n-            a.m();\n-        }\n-    }\n-\n-     public static void main(String[] args) {\n-        for (int i = 0; i < 20000; i++) {\n-            m1(false);\n-        }\n-        \/\/ Trigger uncommon trap in A.m2() (class unloaded) and\n-        \/\/ deoptimization of m1() (CHA invalidated). Uncommon trap\n-        \/\/ code locks monitor in m1's frame where's it's eliminated.\n-        m1(true);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestLockEliminatedAtDeopt.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n- * @run main\/othervm -XX:NewSize=10m -XX:+FullGCALot -XX:FullGCALotInterval=120 -XX:+UseBiasedLocking gc.TestFullGCALot\n","filename":"test\/hotspot\/jtreg\/gc\/TestFullGCALot.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * @run main\/othervm -XX:+UseLargePages gc.TestSystemGC\n-  *\/\n+ *\/\n@@ -56,0 +55,7 @@\n+\n+\/*\n+ * @test TestSystemGCLargePages\n+ * @summary Runs System.gc() with different flags.\n+ * @run main\/othervm -XX:+UseLargePages gc.TestSystemGC\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestSystemGC.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.arguments;\n+\n+\/*\n+ * @test TestG1RemSetFlags\n+ * @requires vm.gc.G1\n+ * @summary Verify that the remembered set flags are updated as expected\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.management\/sun.management\n+ * @library \/test\/lib\n+ * @library \/\n+ * @run driver gc.arguments.TestG1RemSetFlags\n+ *\/\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1RemSetFlags {\n+\n+  private static void checkG1RemSetFlags(String[] flags, int exitValue) throws Exception {\n+    ArrayList<String> flagList = new ArrayList<String>();\n+    flagList.addAll(Arrays.asList(flags));\n+    flagList.add(\"-XX:+UseG1GC\");\n+    flagList.add(\"-XX:+PrintFlagsFinal\");\n+    flagList.add(\"-version\");\n+\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n+    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    output.shouldHaveExitValue(exitValue);\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=8\", \"-XX:G1RemSetHowlMaxNumBuckets=8\"  },  0);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=8\", \"-XX:G1RemSetHowlMaxNumBuckets=16\"  },  0);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=16\", \"-XX:G1RemSetHowlMaxNumBuckets=8\"  },  1);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=7\"  },  1);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlMaxNumBuckets=7\"  },  1);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1RemSetFlags.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -104,3 +104,8 @@\n-        new LogMessageWithLevel(\"Merged Sparse\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Fine\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Coarse\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Inline\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged ArrayOfCards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Full\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Inline\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl ArrayOfCards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl BitMap\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Full\", Level.DEBUG),\n@@ -138,0 +143,1 @@\n+        new LogMessageWithLevel(\"Sample Collection Set Candidates\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc,gc+humongous=debug -XX:+UseG1GC -XX:MaxTenuringThreshold=0 -XX:G1RSetSparseRegionEntries=32 -XX:G1HeapRegionSize=1m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.TestNoEagerReclaimOfHumongousRegions\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc,gc+humongous=debug -XX:+UseG1GC -XX:MaxTenuringThreshold=0 -XX:+UnlockExperimentalVMOptions -XX:G1RemSetArrayOfCardsEntries=32 -XX:G1HeapRegionSize=1m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.TestNoEagerReclaimOfHumongousRegions\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestNoEagerReclaimOfHumongousRegions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Platform;\n@@ -55,0 +56,3 @@\n+        if (Platform.isDebugBuild()) {\n+            testYoungEvacFail();\n+        }\n@@ -118,0 +122,20 @@\n+    private static void testYoungEvacFail() throws Exception {\n+        OutputAnalyzer output;\n+        output = testWithVerificationType(new String[] {\"young-evac-fail\"},\n+                                          new String[] {\"-XX:+G1EvacuationFailureALot\",\n+                                                        \"-XX:G1EvacuationFailureALotCount=100\",\n+                                                        \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                                        \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                        \"-XX:-G1UsePreventiveGC\"});\n+        output.shouldHaveExitValue(0);\n+\n+        verifyCollection(\"Pause Young (Normal)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Concurrent Start)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Mixed)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Prepare Mixed)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Remark\", false, false, false, output.getStdout());\n+        verifyCollection(\"Pause Cleanup\", false, false, false, output.getStdout());\n+        verifyCollection(\"Pause Full\", false, false, false, output.getStdout());\n+    }\n+\n+\n@@ -124,1 +148,1 @@\n-        output.shouldMatch(\"VerifyGCType: '.*' is unknown. Available types are: young-normal, concurrent-start, mixed, remark, cleanup and full\");\n+        output.shouldMatch(\"VerifyGCType: '.*' is unknown. Available types are: young-normal, young-evac-fail, concurrent-start, mixed, remark, cleanup and full\");\n@@ -134,1 +158,1 @@\n-    private static OutputAnalyzer testWithVerificationType(String[] types) throws Exception {\n+    private static OutputAnalyzer testWithVerificationType(String[] types, String... extraOpts) throws Exception {\n@@ -154,0 +178,2 @@\n+        Collections.addAll(basicOpts, extraOpts);\n+\n@@ -158,0 +184,1 @@\n+\n@@ -231,0 +258,3 @@\n+\n+        \/\/ This class triggers GCs; we need to make sure that in all of the young gcs\n+        \/\/ at least some objects survive so that evacuation failure can happen.\n@@ -244,0 +274,2 @@\n+\n+            used = alloc1M();\n@@ -245,0 +277,1 @@\n+            partialFree(used);\n@@ -252,0 +285,1 @@\n+            used = alloc1M();\n@@ -253,0 +287,3 @@\n+            partialFree(used);\n+\n+            used = alloc1M();\n@@ -254,0 +291,1 @@\n+            partialFree(used);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    private static final int CARDSIZE = 512; \/\/ Card size in bytes.\n+\n@@ -232,2 +234,2 @@\n-        \/\/ threshold for sparce -> fine\n-        final int FINE = WB.getIntxVMFlag(\"G1RSetSparseRegionEntries\").intValue();\n+        \/\/ Threshold for Array of Cards -> Howl\n+        final int ARRAY_TO_HOWL_THRESHOLD = WB.getUintVMFlag(\"G1RemSetArrayOfCardsEntries\").intValue();\n@@ -235,2 +237,4 @@\n-        \/\/ threshold for fine -> coarse\n-        final int COARSE = WB.getIntxVMFlag(\"G1RSetRegionEntries\").intValue();\n+        \/\/ Threshold for Howl -> Full\n+        int coarsenHowlToFullPercent = WB.getUintVMFlag(\"G1RemSetCoarsenHowlToFullPercent\").intValue();\n+        int cardsPerRegion = WB.getSizeTVMFlag(\"G1HeapRegionSize\").intValue() \/ CARDSIZE;\n+        final int HOWL_TO_FULL_THRESHOLD = (cardsPerRegion * coarsenHowlToFullPercent) \/ 100;\n@@ -244,2 +248,7 @@\n-        int[] regToRegRefCounts = {0, FINE \/ 2, 0, FINE, (FINE + COARSE) \/ 2, 0,\n-            COARSE, COARSE + 10, FINE + 1, FINE \/ 2, 0};\n+        int[] regToRegRefCounts = {\n+            0, ARRAY_TO_HOWL_THRESHOLD \/ 2,\n+            0, ARRAY_TO_HOWL_THRESHOLD,\n+            (ARRAY_TO_HOWL_THRESHOLD + HOWL_TO_FULL_THRESHOLD) \/ 2, 0,\n+            HOWL_TO_FULL_THRESHOLD, HOWL_TO_FULL_THRESHOLD + 10,\n+            ARRAY_TO_HOWL_THRESHOLD + 1, ARRAY_TO_HOWL_THRESHOLD \/ 2,\n+            0};\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        command.add(\"--gtest_catch_exceptions=0\" + resultFile);\n+        command.add(\"--gtest_catch_exceptions=0\");\n","filename":"test\/hotspot\/jtreg\/gtest\/GTestWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+PrintCommandLineFlags -XX:-ShowMessageBoxOnError -XX:BiasedLockingStartupDelay=4000 -XX:ParallelGCThreads=4 -XX:MaxRAM=1G -XX:ErrorFile=\"file\" PrintAsFlag\n+ * @run main\/othervm -XX:+PrintCommandLineFlags -XX:-ShowMessageBoxOnError -XX:ParallelGCThreads=4 -XX:MaxRAM=1G -XX:ErrorFile=\"file\" PrintAsFlag\n","filename":"test\/hotspot\/jtreg\/runtime\/7167069\/PrintAsFlag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,2 +233,0 @@\n-        excludeTestMaxRange(\"G1RSetRegionEntries\");\n-        excludeTestMaxRange(\"G1RSetSparseRegionEntries\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,7 +45,3 @@\n-        {\"-Xint\", \"-XX:+UseBiasedLocking\"},\n-        {\"-Xint\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:+UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:+UseOptoBiasInlining\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:-UseOptoBiasInlining\"}\n+        {\"-Xint\"},\n+        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\"},\n+        {\"-Xcomp\", \"-XX:-TieredCompilation\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/SyncOnValueBasedClassTest.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"detail\"});\n@@ -62,1 +62,1 @@\n-        addr = wb.NMTMallocWithPseudoStackAndType(2 * 1024, pc, 8 \/* mtInternal *\/ );\n+        addr = wb.NMTMallocWithPseudoStackAndType(2 * 1024, pc, 9 \/* mtInternal *\/ );\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocSiteTypeChange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.util.concurrent.Semaphore;\n+\n@@ -27,1 +29,1 @@\n-    private Object thread_sync = null;\n+    private Semaphore mainSync = null;\n@@ -29,1 +31,1 @@\n-    public ClassLoadingThread(ClassLoader loader, Object sync) {\n+    public ClassLoadingThread(ClassLoader loader, Semaphore sem) {\n@@ -31,1 +33,1 @@\n-        thread_sync = sync;\n+        mainSync = sem;\n@@ -50,3 +52,3 @@\n-            \/\/ Wake up the second thread\n-            synchronized (thread_sync) {\n-                thread_sync.notify();\n+            \/\/ Signal main thread to start t2.\n+            if (mainSync != null) {\n+                mainSync.release();\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ClassLoadingThread.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.concurrent.Semaphore;\n@@ -63,1 +64,0 @@\n-    private Object thread_sync = new Object();\n@@ -65,0 +65,1 @@\n+    private static Semaphore mainSem = new Semaphore(0);\n@@ -69,4 +70,3 @@\n-        \/\/ Wake up the second thread here.\n-        synchronized (thread_sync) {\n-            thread_sync.notify();\n-        }\n+        \/\/ Signal main thread to start t2.\n+        mainSem.release();\n+\n@@ -139,1 +139,1 @@\n-            threads[i] = new ClassLoadingThread(this, thread_sync);\n+            threads[i] = new ClassLoadingThread(this, parallel ? null : mainSem);\n@@ -145,6 +145,4 @@\n-                synchronized(thread_sync) {\n-                    try {\n-                        ThreadPrint.println(\"t2 waits\");\n-                        thread_sync.wait();\n-                    } catch (InterruptedException e) {}\n-                }\n+                try {\n+                    ThreadPrint.println(\"Main thread calls mainSem.acquire()\");\n+                    mainSem.acquire();\n+                } catch (InterruptedException e) {}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoader.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Non jar file in the classpath will be skipped during dump time and runtime.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @compile test-classes\/HelloMore.java\n+ * @run driver NonJarInClasspath\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class NonJarInClasspath {\n+\n+    public static void main(String[] args) throws Exception {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        String appJar2 = JarBuilder.build(\"hellomore\", \"HelloMore\");\n+\n+        String outDir = CDSTestUtils.getOutputDir();\n+        String newFile = \"non-exist.jar\";\n+        String nonJarPath = outDir + File.separator + newFile;\n+        String classPath = appJar + File.pathSeparator + nonJarPath + File.pathSeparator + appJar2;\n+        File nonJar = new File(outDir, newFile);\n+        nonJar.createNewFile();\n+\n+        TestCommon.testDump(classPath, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+        TestCommon.run(\n+            \"-cp\", classPath,\n+            \"-Xlog:class+load\",\n+            \"Hello\")\n+          .assertNormalExit(out -> {\n+              out.shouldContain(\"Hello source: shared objects file\");\n+          });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/NonJarInClasspath.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Handling of duplicated classes in dynamic archive with custom loader\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build DuplicatedCustomApp CustomLoadee CustomLoadee2 CustomLoadee3 CustomLoadee3Child\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar DuplicatedCustomApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar custom.jar CustomLoadee\n+ *                  CustomLoadee2 CustomInterface2_ia CustomInterface2_ib\n+ *                  CustomLoadee3 CustomLoadee3Child\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar DuplicatedCustomTest\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class DuplicatedCustomTest extends DynamicArchiveTestBase {\n+    private static final String ARCHIVE_NAME = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(DuplicatedCustomTest::testDefaultBase);\n+    }\n+\n+    private static void testDefaultBase() throws Exception {\n+        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n+        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n+        String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+        String customJarPath = ClassFileInstaller.getJarPath(\"custom.jar\");\n+        String mainAppClass = \"DuplicatedCustomApp\";\n+        String numberOfLoops = \"2\";\n+\n+        dump(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=debug\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, numberOfLoops)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Written dynamic archive 0x\")\n+                      .shouldContain(\"Skipping CustomLoadee: Duplicated unregistered class\")\n+                      .shouldHaveExitValue(0);\n+                });\n+\n+        run(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds=debug\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, numberOfLoops)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"DuplicatedCustomApp source: shared objects file (top)\")\n+                      .shouldContain(\"CustomLoadee source: shared objects file (top)\")\n+                      .shouldHaveExitValue(0);\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DuplicatedCustomTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import sun.hotspot.WhiteBox;\n+\n+public class DuplicatedCustomApp {\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static URLClassLoader loaders[];\n+\n+    \/\/ If DuplicatedCustomApp.class is loaded from JAR file, it means we are dumping the\n+    \/\/ dynamic archive.\n+    static boolean is_dynamic_dumping = !wb.isSharedClass(DuplicatedCustomApp.class);\n+    static boolean is_running_with_dynamic_archive = !is_dynamic_dumping;\n+\n+    public static void main(String args[]) throws Exception {\n+        String path = args[0];\n+        URL url = new File(path).toURI().toURL();\n+        URL[] urls = new URL[] {url};\n+        System.out.println(path);\n+        System.out.println(url);\n+\n+        int num_loops = 1;\n+        if (args.length > 1) {\n+            num_loops = Integer.parseInt(args[1]);\n+        }\n+        loaders = new URLClassLoader[num_loops];\n+        for (int i = 0; i < num_loops; i++) {\n+            loaders[i] = new URLClassLoader(urls);\n+        }\n+\n+        if (is_dynamic_dumping) {\n+            \/\/ Try to load the super interfaces of CustomLoadee2 in different orders\n+            for (int i = 0; i < num_loops; i++) {\n+                int a = (i + 1) % num_loops;\n+                loaders[a].loadClass(\"CustomInterface2_ia\");\n+            }\n+            for (int i = 0; i < num_loops; i++) {\n+                int a = (i + 2) % num_loops;\n+                loaders[a].loadClass(\"CustomInterface2_ib\");\n+            }\n+        }\n+\n+        for (int i = 0; i < num_loops; i++) {\n+            System.out.println(\"============================ LOOP = \" + i);\n+            URLClassLoader urlClassLoader = loaders[i];\n+            test(i, urlClassLoader, \"CustomLoadee\");\n+            test(i, urlClassLoader, \"CustomInterface2_ia\");\n+            test(i, urlClassLoader, \"CustomInterface2_ib\");\n+            test(i, urlClassLoader, \"CustomLoadee2\");\n+            test(i, urlClassLoader, \"CustomLoadee3\");\n+            test(i, urlClassLoader, \"CustomLoadee3Child\");\n+        }\n+    }\n+\n+    private static void test(int i, URLClassLoader urlClassLoader, String name) throws Exception {\n+        Class c = urlClassLoader.loadClass(name);\n+        try {\n+            c.newInstance(); \/\/ make sure the class is linked so it can be archived\n+        } catch (Throwable t) {}\n+        boolean is_shared = wb.isSharedClass(c);\n+\n+        System.out.println(\"Class = \" + c + \", loaded from \" + (is_shared ? \"CDS\" : \"Jar\"));\n+        System.out.println(\"Loader = \" + c.getClassLoader());\n+\n+        \/\/ [1] Check that the loaded class is defined by the correct loader\n+        if (c.getClassLoader() != urlClassLoader) {\n+            throw new RuntimeException(\"c.getClassLoader() == \" + c.getClassLoader() +\n+                                       \", expected == \" + urlClassLoader);\n+        }\n+\n+        if (is_running_with_dynamic_archive) {\n+            \/\/ There's only one copy of the shared class of <name> in the\n+            \/\/ CDS archive.\n+            if (i == 0) {\n+                \/\/ The first time we must be able to load it from CDS.\n+                if (!is_shared) {\n+                    throw new RuntimeException(\"Must be loaded from CDS\");\n+                }\n+            } else {\n+                \/\/ All subsequent times, we must load this from JAR file.\n+                if (is_shared) {\n+                    throw new RuntimeException(\"Must be loaded from JAR\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/DuplicatedCustomApp.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -62,2 +62,1 @@\n-            \/\/ i = 1 -- dump with agent = disable BiasedLocking\n-            \/\/ i = 2 -- dump with agent = enable BiasedLocking\n+            \/\/ i = 1 -- dump with agent\n@@ -67,1 +66,0 @@\n-            String biasedLock = (i != 2) ? \"-showversion\" : \"-XX:+UseBiasedLocking\";\n@@ -72,1 +70,1 @@\n-                                    agentArg, agentArg2, biasedLock);\n+                                    agentArg, agentArg2);\n@@ -79,1 +77,1 @@\n-                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2, biasedLock,\n+                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2,\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDump.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    protected static void test(String fileName, long pid,\n+    protected static OutputAnalyzer test(String fileName, long pid,\n@@ -203,0 +203,1 @@\n+        return output;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestDumpBase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8265465\n+ * @bug 8265465 8267075\n@@ -44,0 +44,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -46,0 +47,16 @@\n+    static final String promptStdout = \"please check stdout file\";\n+    static final String promptStderr = \"or stderr file\";\n+\n+    static void checkContainAbsoluteLogPath(OutputAnalyzer output) throws Exception {\n+       String stdText = output.getOutput();\n+       if (stdText.contains(promptStdout) &&\n+           stdText.contains(promptStderr)) {\n+           int a = stdText.indexOf(promptStdout);\n+           int b = stdText.indexOf(promptStderr);\n+           String stdOutFileName = stdText.substring(a + promptStdout.length() + 1, b - 1).trim();\n+           File   stdOutFile = new File(stdOutFileName);\n+           if (!stdOutFile.isAbsolute()) {\n+               throw new RuntimeException(\"Failed to set file name in absolute for prompting message\");\n+           }\n+        }\n+    }\n@@ -70,1 +87,0 @@\n-        app.stopApp();\n@@ -74,0 +90,7 @@\n+        \/\/ Illegal character in file name\n+        localFileName = \"mystatic:.jsa\";\n+        OutputAnalyzer output = test(localFileName, pid, noBoot,  EXPECT_FAIL);\n+        checkFileExistence(localFileName, false\/*exist*\/);\n+        checkContainAbsoluteLogPath(output);\n+        app.stopApp();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestFileSafety.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268720\n+ * @summary Constant pool NameAndType entries with valid but incompatible method\n+ *          name and signature shouldn't cause an exception until referenced by\n+ *          a method_ref.\n+ * @compile nonVoidInitSig.jcod\n+ * @run main\/othervm -Xverify:remote NameAndTypeSig\n+ *\/\n+\n+\/\/ Test constant pool NameAndType descriptors with valid but incompatible method\n+\/\/ names and signatures.\n+public class NameAndTypeSig {\n+    public static void main(String args[]) throws Throwable {\n+\n+        \/\/ Test that an unreferenced NameAndType with a valid name and signature\n+        \/\/ is allowed even for name and signature pairs such as <init>()D.\n+        Class newClass = Class.forName(\"nonVoidInitSig\");\n+\n+        \/\/ Test that a NameAndType with a valid name and signature is allowed for\n+        \/\/ name and signature pairs such as <init>()D, but not allowed by a cp\n+        \/\/ Method_ref.\n+        try {\n+            Class newClass2 = Class.forName(\"nonVoidInitSigCFE\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class nonVoidInitSigCFE has illegal signature\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+\n+        \/\/ Test that a NameAndType with a valid name and invalid signature throws a\n+        \/\/ ClassFormatError exception with a message containing the name <init> and\n+        \/\/ the bad signature.\n+        try {\n+            Class newClass2 = Class.forName(\"voidInitBadSig\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class voidInitBadSig has illegal signature \\\"()))V\\\"\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+        System.out.println(\"Test NameAndTypeSig passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/NameAndTypeSig.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The constant pool in this class contains an unused NameAndType entry (#20)\n+\/\/ that points to method <init> and signature ()D.  This is a valid NameAndType\n+\/\/ because <init> is a valid method name and ()D is a valid method signature.\n+class nonVoidInitSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"nonVoidInitSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"nonVoidInitSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()D\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()D.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class nonVoidInitSig\n+\n+\n+\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#3) that\n+\/\/ points to method <init> and signature ()D.  This is a valid NameAndType\n+\/\/ because <init> is a valid method name and ()D is a valid method signature.\n+\/\/ But, a cp Methodref (#1) that points to NameAndType with a method named\n+\/\/ <init> and a non-void return type, is invalid.\n+class nonVoidInitSigCFE {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #19; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"nonVoidInitSigCFE\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"nonVoidInitSigCFE.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()D\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class nonVoidInitSigCFE\n+\n+\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#20) that\n+\/\/ points to method <init> and signature ()))V.  This is an invalid NameAndType\n+\/\/ entry and should throw a ClassFormatError exception, with a message containing\n+\/\/ the name <init> and the bad signature, even thought the NameAndType is not\n+\/\/ referenced by a cp Methodref.\n+class voidInitBadSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"voidInitBadSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"voidInitBadSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()))V\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()))V.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class voidInitBadSig\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/nonVoidInitSig.jcod","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -31,2 +31,3 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI HandshakeDirectTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot HandshakeDirectTest\n@@ -38,0 +39,1 @@\n+import sun.hotspot.WhiteBox;\n@@ -42,1 +44,1 @@\n-    static final int DIRECT_HANDSHAKES_MARK = 500000;\n+    static final int DIRECT_HANDSHAKES_MARK = 300000;\n@@ -44,1 +46,0 @@\n-    static Semaphore[] handshakeSem = new Semaphore[WORKING_THREADS];\n@@ -46,1 +47,0 @@\n-    static boolean[] isBiased = new boolean[WORKING_THREADS];\n@@ -52,0 +52,1 @@\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n@@ -53,10 +54,3 @@\n-        while (true) {\n-            try {\n-                if (!isBiased[me]) {\n-                    handshakeSem[me].acquire();\n-                    synchronized(locks[me]) {\n-                        isBiased[me] = true;\n-                    }\n-                    handshakeSem[me].release();\n-                }\n-\n+        while (handshakeCount.get() < DIRECT_HANDSHAKES_MARK) {\n+            boolean walked = false;\n+            synchronized(locks[me]) {\n@@ -69,13 +63,5 @@\n-                handshakeSem[handshakee].acquire();\n-                if (isBiased[handshakee]) {\n-                    \/\/ Revoke biased lock\n-                    synchronized(locks[handshakee]) {\n-                        handshakeCount.incrementAndGet();\n-                    }\n-                    \/\/ Create new lock to be biased\n-                    locks[handshakee] = new Object();\n-                    isBiased[handshakee] = false;\n-                }\n-                handshakeSem[handshakee].release();\n-                if (handshakeCount.get() >= DIRECT_HANDSHAKES_MARK) {\n-                    break;\n+                \/\/ Inflate locks[handshakee] if possible\n+                System.identityHashCode(locks[handshakee]);\n+                walked = wb.handshakeReadMonitors(workingThreads[handshakee]);\n+                if (walked) {\n+                    handshakeCount.incrementAndGet();\n@@ -83,2 +69,0 @@\n-            } catch(InterruptedException ie) {\n-                throw new Error(\"Unexpected interrupt\");\n@@ -86,0 +70,1 @@\n+            locks[me] = new Object();\n@@ -92,5 +77,0 @@\n-        \/\/ Initialize semaphores\n-        for (int i = 0; i < WORKING_THREADS; i++) {\n-            handshakeSem[i] = new Semaphore(1);\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":15,"deletions":35,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8263640\n+ * @summary In case of a class path is longer than O_BUFLEN, the class path\n+ *          should not be truncated in the output from jcmd VM.command_line.\n+ * @library \/test\/lib\n+ * @run driver JcmdCmdLine\n+ *\/\n+\n+import java.io.File;\n+import java.util.List;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class JcmdCmdLine {\n+    private static LingeredApp theApp = null;\n+    private static final int BUFFER_LEN = 2000;\n+    private static final String JCMD_OPT = \"VM.command_line\";\n+    private static final String CLASS_PATH_LINE = \"java_class_path (initial):\";\n+    private static final String TRUNCATE_WARNING = \"outputStream::do_vsnprintf output truncated\";\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            theApp = new LingeredApp();\n+            theApp.setUseDefaultClasspath(false);\n+            String classPath = System.getProperty(\"test.class.path\");\n+            while (classPath.length() < BUFFER_LEN) {\n+                classPath += File.pathSeparator + classPath;\n+            }\n+            LingeredApp.startAppExactJvmOpts(theApp, \"-cp\",  classPath);\n+            long pid = theApp.getPid();\n+\n+            PidJcmdExecutor cmdExecutor = new PidJcmdExecutor(String.valueOf(pid));\n+            OutputAnalyzer output = cmdExecutor.execute(JCMD_OPT, true\/*silent*\/);\n+            output.shouldHaveExitValue(0);\n+            boolean seenClassPath = false;\n+            List<String> lines = output.asLines();\n+            for (int i = 0; i < lines.size(); i++) {\n+                String line = lines.get(i);\n+                if (line.startsWith(CLASS_PATH_LINE)) {\n+                    seenClassPath = true;\n+                    if (!line.endsWith(classPath)) {\n+                        throw new RuntimeException(\"Incomplete java_class_path line.\");\n+                    }\n+                }\n+            }\n+            if (!seenClassPath) {\n+                throw new RuntimeException(\"Missing java_class_path line.\");\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+            if (theApp.getOutput().getStderr().contains(TRUNCATE_WARNING)) {\n+                throw new RuntimeException(\"Unexpected truncation warning.\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jcmd\/JcmdCmdLine.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8149383\n- * @summary -Xlog:biasedlocking should have logging from statements in the source code\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver BiasedLockingTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class BiasedLockingTest {\n-    static void analyzeOutputOn(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Biased locking enabled\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    static void analyzeOutputOff(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"[biasedlocking]\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                                  \"-Xlog:biasedlocking\",\n-                                                                  \"-XX:BiasedLockingStartupDelay=0\",\n-                                                                  InnerClass.class.getName());\n-        analyzeOutputOn(pb);\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                   \"-Xlog:biasedlocking=off\",\n-                                                   \"-XX:BiasedLockingStartupDelay=0\",\n-                                                   InnerClass.class.getName());\n-        analyzeOutputOff(pb);\n-    }\n-\n-    public static class InnerClass {\n-        public static void main(String[] args) {\n-            System.out.println(\"Biased Locking test\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/BiasedLockingTest.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -65,1 +65,1 @@\n-\n+        output.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ThreadLoggingTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,5 @@\n-            pipe.println(\"quit\");\n+            if (pipe.isConnected()) {\n+                pipe.println(\"quit\");\n+            } else {\n+                System.out.println(\"WARNING: IOPipe is not connected\");\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/TestProcessLauncher.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-            channel.connect();\n+            channel.connect(launcher.getJdwpPort());\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/AllModulesCommandTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import java.io.IOException;\n-import java.net.ServerSocket;\n@@ -28,1 +26,1 @@\n-import jdk.test.lib.Utils;\n+import jdk.test.lib.JDWP;\n@@ -58,1 +56,1 @@\n-    private static int jdwpPort = -1;\n+    private int jdwpPort = -1;\n@@ -120,1 +118,1 @@\n-        return \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=\" + getJdwpPort();\n+        return \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\";\n@@ -124,1 +122,1 @@\n-     * Find an available port for the JDWP session\n+     * Gets JDWP port debuggee is listening on.\n@@ -128,5 +126,2 @@\n-    public static int getJdwpPort() {\n-        if (jdwpPort == -1) {\n-            jdwpPort = findFreePort();\n-            assertFalse(jdwpPort == -1, \"Can not find vailbale port for JDWP\");\n-        }\n+    public int getJdwpPort() {\n+        assertFalse(jdwpPort == -1, \"JDWP port is not detected\");\n@@ -136,8 +131,0 @@\n-    private static int findFreePort() {\n-        try (ServerSocket socket = new ServerSocket(0)) {\n-            return socket.getLocalPort();\n-        } catch (IOException e) {\n-        }\n-        return -1;\n-    }\n-\n@@ -155,0 +142,6 @@\n+        if (jdwpPort == -1) {\n+            JDWP.ListenAddress addr = JDWP.parseListenAddress(line);\n+            if (addr != null) {\n+                jdwpPort = Integer.parseInt(addr.address());\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/DebuggeeLauncher.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    public void connect() throws IOException {\n-        sock = new Socket(\"localhost\", DebuggeeLauncher.getJdwpPort());\n+    public void connect(int jdwpPort) throws IOException {\n+        sock = new Socket(\"localhost\", jdwpPort);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/JdwpChannel.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -55,1 +55,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -67,1 +67,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -79,37 +79,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoWithEATest.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -55,1 +55,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -67,1 +67,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -79,37 +79,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorStackDepthInfo\/GetOwnedMonitorStackDepthInfoWithEATest.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -124,1 +124,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -135,1 +135,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/IterateHeapWithEscapeAnalysisEnabled.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-                    \"InvocationCounter::count_increment\",\n-                    \"markWord::epoch_mask_in_place\"));\n+                    \"InvocationCounter::count_increment\"));\n@@ -96,1 +95,0 @@\n-        \/\/ longConstant markWord::biased_lock_bits 1\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    if (phase != JVMTI_PHASE_LIVE) {\n+    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE) {\n@@ -81,1 +81,1 @@\n-        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodLoad event received during non-live phase %s\\n\",\n+        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodLoad event received during wrong phase %s\\n\",\n@@ -85,1 +85,1 @@\n-        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodLoad event received during the live phase as expected\\n\\n\");\n+        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodLoad event received during the start or live phase as expected\\n\\n\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodLoad\/compmethload001\/compmethload001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-    if (phase != JVMTI_PHASE_LIVE) {\n+    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE) {\n@@ -113,1 +113,1 @@\n-        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodUnload event received during non-live phase %s\\n\",\n+        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodUnload event received during wrong phase %s\\n\",\n@@ -117,1 +117,1 @@\n-        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodUnload event received during the live phase as expected\\n\\n\");\n+        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodUnload event received during the start or live phase as expected\\n\\n\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodUnload\/compmethunload001\/compmethunload001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -52,1 +52,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -60,1 +60,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -68,25 +68,1 @@\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -103,1 +79,1 @@\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -235,1 +211,0 @@\n-        new EARelockingSimple_2Target()                                                     .run();\n@@ -241,2 +216,0 @@\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_3Target()                             .run();\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_4Target()                             .run();\n@@ -352,1 +325,0 @@\n-        new EARelockingSimple_2()                                                     .run(this);\n@@ -358,2 +330,0 @@\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_3()                             .run(this);\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_4()                             .run(this);\n@@ -796,2 +766,0 @@\n-    public static final long BiasedLockingBulkRebiasThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRebiasThreshold\");\n-    public static final long BiasedLockingBulkRevokeThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRevokeThreshold\");\n@@ -812,2 +780,0 @@\n-    public volatile Object biasToBeRevoked;\n-\n@@ -1057,40 +1023,0 @@\n-    \/**\n-     * Trigger bulk rebiasing for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n-     * @param cls The class to bulk rebias\n-     *\/\n-    public void dontinline_bulkRebiasAfterWarmup(Class<?> cls) {\n-        if (warmupDone) {\n-            try {\n-                for (int i=0; i < BiasedLockingBulkRebiasThreshold+2; i++) {\n-                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n-                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n-                        checkSum++;\n-                    }\n-                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n-                }\n-            } catch (Throwable e) {\n-                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Trigger bulk revoke of biases for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n-     * @param cls The class to bulk rebias\n-     *\/\n-    public void dontinline_bulkRevokeAfterWarmup(Class<?> cls) {\n-        if (warmupDone) {\n-            try {\n-                for (int i=0; i < BiasedLockingBulkRevokeThreshold+2; i++) {\n-                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n-                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n-                        checkSum++;\n-                    }\n-                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n-                }\n-            } catch (Throwable e) {\n-                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n-            }\n-        }\n-    }\n-\n@@ -1767,32 +1693,0 @@\n-\/**\n- * Test if the bias of an object O that escapes globally is revoked correctly if local objects\n- * escape through JVMTI. O is referenced by field l0.\n- * This tests a regression of a previous version of the implementation.\n- *\/\n-class EARelockingSimple_2 extends EATestCaseBaseDebugger {\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingSimple_2Target extends EATestCaseBaseTarget {\n-\n-    public XYVal l0;\n-\n-    public void dontinline_testMethod() {\n-        l0 = new XYVal(4, 2);         \/\/ GobalEscape\n-        XYVal l1 = new XYVal(4, 2);\n-        synchronized (l0) {\n-            synchronized (l1) {\n-                dontinline_brkpt();\n-            }\n-        }\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -1997,99 +1891,0 @@\n-\/**\n- * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame}.\n- * A bulk rebias operation is triggered at a position where all locks on the local object referenced\n- * by l1 are eliminated. This leaves the object with an outdated biased locking epoch which has to be\n- * considered when relocking.\n- * This tests a regression in a previous version.\n- *\/\n-class EARelockingArgEscapeLWLockedInCalleeFrame_3 extends EATestCaseBaseDebugger {\n-\n-    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_3Target.XYValLocal.class.getName();\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingArgEscapeLWLockedInCalleeFrame_3Target extends EATestCaseBaseTarget {\n-\n-    \/\/ Using local type to avoid side effects on biased locking heuristics\n-    public static class XYValLocal extends XYVal {\n-        public XYValLocal(int x, int y) {\n-            super(x,y);\n-        }\n-    }\n-\n-    public void dontinline_testMethod() {\n-        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n-        synchronized (l1) {                    \/\/ eliminated\n-            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n-            \/\/ trigger bulk rebias\n-            dontinline_bulkRebiasAfterWarmup(l1.getClass());\n-            \/\/ Now the epoch of l1 does not match the epoch of its class.\n-            \/\/ This has to be considered when relocking because of JVMTI access\n-            dontinline_brkpt();\n-        }\n-    }\n-\n-    @Override\n-    public boolean testFrameShouldBeDeoptimized() {\n-        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n-        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\/**\n- * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame_3}.\n- * But instead of a bulk rebias a bulk revoke operation is triggered.\n- * This leaves the object with a stale bias as the prototype header of its calls lost its bias\n- * pattern in the bulk revoke which has to be considered during relocking.\n- * This tests a regression in a previous version.\n- *\/\n-class EARelockingArgEscapeLWLockedInCalleeFrame_4 extends EATestCaseBaseDebugger {\n-\n-    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_4Target.XYValLocal.class.getName();\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingArgEscapeLWLockedInCalleeFrame_4Target extends EATestCaseBaseTarget {\n-\n-    \/\/ Using local type to avoid side effects on biased locking heuristics\n-    public static class XYValLocal extends XYVal {\n-        public XYValLocal(int x, int y) {\n-            super(x,y);\n-        }\n-    }\n-\n-    public void dontinline_testMethod() {\n-        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n-        synchronized (l1) {                    \/\/ eliminated\n-            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n-            \/\/ trigger bulk rebias\n-            dontinline_bulkRevokeAfterWarmup(l1.getClass());\n-            \/\/ Now the epoch of l1 does not match the epoch of its class.\n-            \/\/ This has to be considered when relocking because of JVMTI access\n-            dontinline_brkpt();\n-        }\n-    }\n-\n-\n-    @Override\n-    public boolean testFrameShouldBeDeoptimized() {\n-        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n-        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":5,"deletions":210,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.JDWP;\n@@ -40,1 +41,0 @@\n-import java.util.ArrayList;\n@@ -45,2 +45,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -79,1 +77,0 @@\n-    private static Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(\\\\d+)\\\\b\");\n@@ -85,4 +82,3 @@\n-            Matcher m = listenRegexp.matcher(s);\n-            if (m.find()) {\n-                \/\/ m.group(1) is transport, m.group(2) is port\n-                return Integer.parseInt(m.group(2));\n+            JDWP.ListenAddress addr = JDWP.parseListenAddress(s);\n+            if (addr != null) {\n+                return Integer.parseInt(addr.address());\n","filename":"test\/jdk\/com\/sun\/jdi\/JdwpAllowTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -46,0 +44,2 @@\n+\n+import jdk.test.lib.JDWP;\n@@ -98,3 +98,0 @@\n-    \/* warm-up predicate for debuggee *\/\n-    private static Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n-\n@@ -102,2 +99,2 @@\n-        Matcher m = listenRegexp.matcher(line);\n-        if (!m.matches()) {\n+        JDWP.ListenAddress addr = JDWP.parseListenAddress(line);\n+        if (addr == null) {\n@@ -106,2 +103,1 @@\n-        \/\/ address is 2nd group\n-        address = m.group(2);\n+        address = addr.address();\n","filename":"test\/jdk\/com\/sun\/jdi\/RunToExit.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.test.lib.JDWP;\n@@ -35,2 +36,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -127,3 +126,1 @@\n-        \/\/ debuggeeListen[0] - transport, debuggeeListen[1] - address\n-        String[] debuggeeListen = new String[2];\n-        Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n+        JDWP.ListenAddress[] listenAddress = new JDWP.ListenAddress[1];\n@@ -134,7 +131,2 @@\n-                        Matcher m = listenRegexp.matcher(s);\n-                        if (!m.matches()) {\n-                            return false;\n-                        }\n-                        debuggeeListen[0] = m.group(1);\n-                        debuggeeListen[1] = m.group(2);\n-                        return true;\n+                        listenAddress[0] = JDWP.parseListenAddress(s);\n+                        return listenAddress[0] != null;\n@@ -143,2 +135,2 @@\n-            transport = debuggeeListen[0];\n-            address = debuggeeListen[1];\n+            transport = listenAddress[0].transport();\n+            address = listenAddress[0].address();\n","filename":"test\/jdk\/com\/sun\/jdi\/lib\/jdb\/Debuggee.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+            frame.setVisible(false);\n@@ -52,0 +53,1 @@\n+                Thread.yield();\n","filename":"test\/jdk\/java\/awt\/Robot\/InfiniteLoopException.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8262731\n+   @key headful printer\n+   @summary Verify that \"PrinterJob.print\" throws the expected exception,\n+            if \"Printable.print\" throws an exception.\n+   @run main ExceptionFromPrintableIsIgnoredTest MAIN PE\n+   @run main ExceptionFromPrintableIsIgnoredTest MAIN RE\n+   @run main ExceptionFromPrintableIsIgnoredTest EDT PE\n+   @run main ExceptionFromPrintableIsIgnoredTest EDT RE\n+ *\/\n+\n+import java.awt.Graphics;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.SwingUtilities;\n+\n+public class ExceptionFromPrintableIsIgnoredTest {\n+    private enum TestThreadType {MAIN, EDT}\n+    private enum TestExceptionType {PE, RE}\n+\n+    private volatile Throwable printError;\n+\n+    public static void main(String[] args) {\n+        if (args.length < 2) {\n+            throw new RuntimeException(\"Two arguments are expected:\"\n+                    + \" test thread type and test exception type.\");\n+        }\n+\n+        new ExceptionFromPrintableIsIgnoredTest(\n+            TestThreadType.valueOf(args[0]),\n+            TestExceptionType.valueOf(args[1]));\n+    }\n+\n+    public ExceptionFromPrintableIsIgnoredTest(\n+            final TestThreadType threadType,\n+            final TestExceptionType exceptionType) {\n+        System.out.println(String.format(\n+                \"Test started. threadType='%s', exceptionType='%s'\",\n+                threadType, exceptionType));\n+\n+        String osName = System.getProperty(\"os.name\");\n+        boolean isOSX = osName.toLowerCase().startsWith(\"mac\");\n+        if ((exceptionType == TestExceptionType.RE) && !isOSX) {\n+            System.out.println(\n+                \"Currently this test scenario can be verified only on macOS.\");\n+            return;\n+        }\n+\n+        printError = null;\n+\n+        if (threadType == TestThreadType.MAIN) {\n+            runTest(exceptionType);\n+        } else if (threadType == TestThreadType.EDT) {\n+            try {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        runTest(exceptionType);\n+                    }\n+                });\n+            } catch (InterruptedException | InvocationTargetException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        if (printError == null) {\n+            throw new RuntimeException(\"No exception was thrown.\");\n+        } else if (!(printError instanceof PrinterException)) {\n+            throw new RuntimeException(\"Unexpected exception was thrown.\");\n+        }\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    private void runTest(final TestExceptionType exceptionType) {\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        if (job.getPrintService() == null) {\n+            System.out.println(\"No printers are available.\");\n+            return;\n+        }\n+\n+        job.setPrintable(new Printable() {\n+            @Override\n+            public int print(Graphics graphics, PageFormat pageFormat,\n+                    int pageIndex) throws PrinterException {\n+                if (pageIndex > 1) {\n+                    return NO_SUCH_PAGE;\n+                }\n+                if (exceptionType == TestExceptionType.PE) {\n+                    throw new PrinterException(\n+                        \"Exception from 'Printable.print'.\");\n+                } else if (exceptionType == TestExceptionType.RE) {\n+                    throw new RuntimeException(\n+                        \"Exception from 'Printable.print'.\");\n+                }\n+                return PAGE_EXISTS;\n+            }\n+        });\n+\n+        try {\n+            job.print();\n+        } catch (Throwable t) {\n+            printError = t;\n+\n+            System.out.println(\"'PrinterJob.print' threw the exception:\");\n+            t.printStackTrace(System.out);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/ExceptionFromPrintableIsIgnoredTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4847239\n+ * @summary Verify directory parameter behavior in File.createTempFile(String,String,File)\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.AclEntry;\n+import java.nio.file.attribute.AclEntryPermission;\n+import java.nio.file.attribute.AclFileAttributeView;\n+import java.nio.file.attribute.PosixFileAttributeView;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class TargetDirectory {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Target directory exists and is writable\n+        Path dir = Path.of(\"target\");\n+        File target = Files.createDirectory(dir).toFile();\n+        File tmp = File.createTempFile(\"passes\", null, target);\n+        if (!Files.exists(tmp.toPath())) {\n+            throw new RuntimeException(\"Temp file not created\");\n+        }\n+        tmp.delete();\n+\n+        \/\/ Make target directory read-only\n+        if (Files.getFileStore(dir).supportsFileAttributeView(\"posix\")) {\n+            PosixFileAttributeView view =\n+                Files.getFileAttributeView(dir, PosixFileAttributeView.class);\n+            Set<PosixFilePermission> perms = new HashSet<>();\n+            perms.add(PosixFilePermission.valueOf(\"OWNER_READ\"));\n+            view.setPermissions(perms);\n+        } else if (Files.getFileStore(dir).supportsFileAttributeView(\"acl\")) {\n+            AclFileAttributeView view = Files.getFileAttributeView(dir,\n+                AclFileAttributeView.class);\n+            List<AclEntry> entries = new ArrayList<>();\n+            for (AclEntry entry : view.getAcl()) {\n+                Set<AclEntryPermission> perms =\n+                    new HashSet<>(entry.permissions());\n+                perms.remove(AclEntryPermission.ADD_FILE);\n+                entries.add(AclEntry.newBuilder().setType(entry.type())\n+                    .setPrincipal(entry.principal()).setPermissions(perms)\n+                    .build());\n+            }\n+            view.setAcl(entries);\n+        } else {\n+            throw new RuntimeException(\"Required attribute view not supported\");\n+        }\n+\n+        \/\/ Target directory exists but is read-only\n+        try {\n+            File.createTempFile(\"readonly\", null, target);\n+            throw new RuntimeException(\"Exception not thrown for read-only target directory\");\n+        } catch (IOException expected) {\n+        } finally {\n+            target.delete();\n+        }\n+\n+        \/\/ Target directory does not exist\n+        try {\n+            File.createTempFile(\"nonexistent\", null, new File(\"void\"));\n+            throw new RuntimeException(\"Exception not thrown for non-existent target directory\");\n+        } catch (IOException expected) {\n+        }\n+\n+        \/\/ Target is a file, not a directory\n+        target = Files.createFile(Path.of(\"file\")).toFile();\n+        try {\n+            File.createTempFile(\"file\", null, target);\n+            throw new RuntimeException(\"Exception not thrown for file target\");\n+        } catch (IOException expected) {\n+        } finally {\n+            target.delete();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/File\/createTempFile\/TargetDirectory.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266791\n+ * @summary Annotation property which is compiled as an array property but\n+ *          changed observed as a singular element should throw an\n+ *          AnnotationTypeMismatchException\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @run main ArityTypeMismatchTest\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import java.lang.annotation.AnnotationTypeMismatchException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+public class ArityTypeMismatchTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/*\n+         * This test creates an annotation with a member with a non-array type where the annotation\n+         * defines an array property of this type. This can happen if the annotation class is recompiled\n+         * without recompiling the code that declares an annotation of this type. In the example, a\n+         * class is defined to be annotated as\n+         *\n+         * @AnAnnotation(value = {\"v\"}) \/\/ should no longer be an array\n+         * class Carrier { }\n+         *\n+         * where @AnAnnotation expects a singular value.\n+         *\/\n+        ClassWriter writer = new ClassWriter(0);\n+        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n+        AnnotationVisitor v = writer.visitAnnotation(Type.getDescriptor(AnAnnotation.class), true);\n+        AnnotationVisitor v2 = v.visitArray(\"value\");\n+        v2.visit(null, \"v\");\n+        v2.visitEnd();\n+        v.visitEnd();\n+        writer.visitEnd();\n+        byte[] b = writer.toByteArray();\n+        ByteArrayClassLoader cl = new ByteArrayClassLoader(ArityTypeMismatchTest.class.getClassLoader());\n+        cl.init(b);\n+        AnAnnotation sample = cl.loadClass(\"sample.Carrier\").getAnnotation(AnAnnotation.class);\n+        try {\n+            String value = sample.value();\n+            throw new IllegalStateException(\"Found value: \" + value);\n+        } catch (AnnotationTypeMismatchException e) {\n+            if (!e.element().getName().equals(\"value\")) {\n+                throw new IllegalStateException(\"Unexpected element: \" + e.element());\n+            } else if (!e.foundType().equals(\"Array with component tag: s\")) {\n+                throw new IllegalStateException(\"Unexpected type: \" + e.foundType());\n+            }\n+        }\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface AnAnnotation {\n+        String value();\n+    }\n+\n+    public static class ByteArrayClassLoader extends ClassLoader {\n+\n+        public ByteArrayClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        public void init(byte[] b) {\n+            defineClass(\"sample.Carrier\", b, 0, b.length);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArityTypeMismatchTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+                { 62,   0,  Set.of() },                      \/\/ JDK 18\n@@ -107,1 +108,5 @@\n-                { 62,   0,  Set.of()},                       \/\/ JDK 18\n+                { 62,   0,  Set.of(STATIC) },                \/\/ JDK 18\n+                { 62,   0,  Set.of(TRANSITIVE) },\n+                { 62,   0,  Set.of(STATIC, TRANSITIVE) },\n+\n+                { 63,   0,  Set.of()},                       \/\/ JDK 19\n","filename":"test\/jdk\/java\/lang\/module\/ClassFileVersionsTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268294\n+ * @modules java.net.http\/jdk.internal.net.http.websocket:open jdk.httpserver\n+ * @run main\/othervm\n+ *      --add-reads java.net.http=ALL-UNNAMED\n+ *      --add-reads java.net.http=jdk.httpserver\n+ *      java.net.http\/jdk.internal.net.http.websocket.WebSocketAndHttpTest\n+ *\/\n+public final class WebSocketServerDriver { }\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketServerDriver.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * No implementation provided for onInit() because that must always be\n+ * implemented by user\n+ *\/\n+abstract class DefaultMessageStreamHandler implements MessageStreamHandler {\n+\n+    public void onText(CharSequence data, boolean last) {}\n+\n+    public void onBinary(ByteBuffer data, boolean last) {}\n+\n+    public void onPing(ByteBuffer data) {}\n+\n+    public void onPong(ByteBuffer data) {}\n+\n+    public void onClose(int statusCode, CharSequence reason) {}\n+\n+    public void onComplete() {}\n+\n+    public void onError(Throwable e) {}\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/DefaultMessageStreamHandler.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+\/**\n+ * WebSocket server listener interface, which is the same as the client API\n+ * in java.net.http. See MessageStreamResponder for how listener methods\n+ * can send response messages back to the client\n+ *\n+ * All MessageStreamConsumer methods must be implemented (plus the handler method\n+ * declared here). DefaultMessageStreamHandler provides empty implementations of all\n+ * that can be extended, except for onInit() which must always be implemented.\n+ *\n+ *    void onText(CharSequence data, boolean last);\n+ *\n+ *    void onBinary(ByteBuffer data, boolean last);\n+ *\n+ *    void onPing(ByteBuffer data);\n+ *\n+ *    void onPong(ByteBuffer data);\n+ *\n+ *    void onClose(int statusCode, CharSequence reason);\n+ *\n+ *    void onComplete();\n+ *\n+ *    void onError(Throwable e);\n+ *\/\n+interface MessageStreamHandler extends MessageStreamConsumer {\n+\n+    \/**\n+     * called before any of the methods above to supply a\n+     * MessageStreamResponder for any new connection, which can be used to send replies\n+     * sendText(), sendBinary(), sendClose() etc\n+     *\/\n+    void onInit(MessageStreamResponder responder);\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/MessageStreamHandler.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.util.List;\n+\n+\/**\n+ * One of these supplied for each incoming client connection for use\n+ * by user written MessageStreamConsumer.\n+ *\/\n+interface MessageStreamResponder {\n+\n+    public void sendText(CharBuffer src, boolean last) throws IOException;\n+\n+    public void sendBinary(ByteBuffer src, boolean last) throws IOException;\n+\n+    public void sendPing(ByteBuffer src) throws IOException;\n+\n+    public void sendPong(ByteBuffer src) throws IOException;\n+\n+    public void sendClose(int statusCode, CharBuffer reason) throws IOException;\n+\n+    public void close();\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/MessageStreamResponder.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+package jdk.internal.net.http.websocket;\n+\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.WebSocket;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * This is the client side of the test invoked from WebSocketAndHttpTest:\n+ *\n+ * The two args are the addresses of a (local) Websocket and Http server\n+ *\n+ * The test first sends a request to the WS server and in the listener\n+ * which handles the response, it tries to send a request to the http\n+ * server. This hangs if the listener was invoked from the selector\n+ * manager thread. If invoked from a different thread then the http\n+ * response is received and the response string is mapped to string\n+ * \"succeeded\"\n+ *\/\n+public class WebSocketAndHttpClient {\n+\n+    public static void main(String[] args) throws InterruptedException {\n+\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        HttpClient httpClient = HttpClient.newBuilder().executor(executorService).build();\n+\n+        WebSocketTest wsTest = new WebSocketTest(httpClient, args[0]);\n+        HttpTest httpTest = new HttpTest(httpClient, args[1]);\n+\n+        final CompletableFuture<String> result = new CompletableFuture<>();\n+\n+        wsTest.listen(message -> {\n+            try {\n+                String r = httpTest.getData(message);\n+                result.complete(r);\n+            } catch (Exception e) {\n+                result.completeExceptionally(e);\n+            }\n+        });\n+\n+        wsTest.sendData(\"TEST_DATA\");\n+\n+        System.out.println(\"Wait for result\");\n+        try {\n+            result.join();\n+            System.out.println(\"Result: success\");\n+        } finally {\n+            executorService.shutdownNow();\n+        }\n+    }\n+\n+    static class WebSocketTest {\n+        final HttpClient httpClient;\n+        final String server;\n+        volatile WebSocket webSocket;\n+\n+        WebSocketTest(HttpClient httpClient, String server) {\n+            this.httpClient = httpClient;\n+            this.server = server;\n+        }\n+\n+        public void listen(Consumer<String> consumer) {\n+            URI uri = URI.create(server);\n+            System.out.println(\"WS API client - Connecting to \" + uri.toString());\n+            CompletableFuture<WebSocket> cf = httpClient.newWebSocketBuilder()\n+                .buildAsync(uri, new WebSocket.Listener() {\n+                    @Override\n+                    public CompletionStage<?> onText(WebSocket webSocket, CharSequence data, boolean last) {\n+                        System.out.println(\"WS API client - received data: \" + data);\n+                        consumer.accept(data.toString());\n+                        return null;\n+                    }\n+                    public void onError(WebSocket webSocket, Throwable error) {\n+                        System.out.println(\"WS API client - error\");\n+                        error.printStackTrace();\n+                    }\n+                });\n+            System.out.println(\"CF created\");\n+            webSocket = cf.join();\n+            System.out.println(\"Websocket created\");\n+        }\n+\n+        void sendData(String data) {\n+            System.out.println(\"WS API client - sending data via WebSocket: {}\" + data);\n+            webSocket.sendText(data, true).join();\n+        }\n+    }\n+\n+    static class HttpTest {\n+        final HttpClient httpClient;\n+        final String baseUrl;\n+\n+        HttpTest(HttpClient httpClient, String baseUrl) {\n+            this.httpClient = httpClient;\n+            this.baseUrl = baseUrl;\n+        }\n+\n+        private String getData(String data) throws Exception {\n+            URI uri = URI.create(baseUrl + \"?param=\" + data);\n+            HttpRequest request = HttpRequest.newBuilder().GET().uri(uri).build();\n+            System.out.println(\"Http API Client - send HTTP GET request with parameter {}\" + data);\n+            HttpResponse<String> send = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n+            return send.body();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketAndHttpClient.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.net.*;\n+import java.nio.CharBuffer;\n+import java.io.*;\n+\n+import com.sun.net.httpserver.*;\n+\n+public class WebSocketAndHttpTest {\n+    static class WHandler extends DefaultMessageStreamHandler {\n+        volatile MessageStreamResponder responder;\n+\n+        public void onText(CharSequence data, boolean last) {\n+            System.out.println(\"onText: \" + data);\n+            System.out.println(\"onText: \" + Thread.currentThread());\n+            try {\n+                responder.sendText(CharBuffer.wrap(data), true);\n+                System.out.println(\"onText: send ok\");\n+            } catch (IOException e) {\n+                System.out.println(\"onText: \" + e);\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        public void onInit(MessageStreamResponder responder) {\n+            System.out.println(\"onInit\");\n+            this.responder = responder;\n+        }\n+    }\n+\n+    static HttpHandler httpHandler = (ex) -> ex.sendResponseHeaders(200, -1);\n+\n+    public static void main(String[] args) throws Exception {\n+        HttpServer hserver = null;\n+        try {\n+            WebSocketServer server = new WebSocketServer(new WHandler());\n+            server.open();\n+            URI uri = server.getURI();\n+\n+            hserver = HttpServer.create(new InetSocketAddress(0), 4);\n+            hserver.createContext(\"\/\", httpHandler);\n+            hserver.start();\n+\n+            int port = hserver.getAddress().getPort();\n+            URI huri = new URI(\"http:\/\/127.0.0.1:\" + port + \"\/foo\");\n+\n+            WebSocketAndHttpClient.main(new String[]{uri.toString(), huri.toString()});\n+        } finally {\n+            hserver.stop(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketAndHttpTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+\n+public class WebSocketResponder implements MessageStreamResponder {\n+\n+    final MessageStreamConsumer consumer;\n+    final LinkedList<ByteBuffer> queue;\n+    volatile boolean closed = false;\n+\n+    final MessageEncoder encoder;\n+    final MessageDecoder decoder;\n+\n+    static final int BUF_SIZE = 1024;\n+\n+    public WebSocketResponder(MessageStreamConsumer consumer) {\n+        this.consumer = consumer;\n+        this.queue = new LinkedList<>();\n+        this.decoder = new MessageDecoder(consumer, true);\n+        this.encoder = new MessageEncoder(true);\n+    }\n+\n+    \/\/ own thread\n+    public void readLoop(SocketChannel chan) throws IOException {\n+        chan.configureBlocking(true);\n+        boolean eof = false;\n+        ByteBuffer buf = ByteBuffer.allocate(8 * 1024);\n+        Frame.Reader reader = new Frame.Reader();\n+        try {\n+            while (!eof) {\n+                int count;\n+                buf.clear();\n+                eof = ((count=chan.read(buf)) == -1);\n+                if (!eof) {\n+                    buf.flip();\n+                    reader.readFrame(buf, decoder);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!closed)\n+                throw e;\n+        }\n+    }\n+\n+    \/\/ own thread\n+    public void writeLoop(SocketChannel chan) throws IOException {\n+        \/\/ read queue and send data\n+        while (true) {\n+            ByteBuffer buf;\n+            synchronized(queue) {\n+                while (queue.isEmpty()) {\n+                    try {\n+                        queue.wait();\n+                    } catch (InterruptedException e) {\n+                        throw new IOException(e);\n+                    }\n+                    if (queue.isEmpty() && closed) {\n+                        chan.close();\n+                        return;\n+                    }\n+                }\n+                buf = queue.remove(0);\n+            }\n+            chan.write(buf);\n+        }\n+    }\n+\n+    \/**\n+     * Public methods below used y MessageStreamHandler to send replies\n+     * to client.\n+     *\/\n+    @Override\n+    public void sendText(CharBuffer src, boolean last) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeText(src, last, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendBinary(ByteBuffer src, boolean last) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeBinary(src, last, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendPing(ByteBuffer src) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodePing(src, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendPong(ByteBuffer src) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodePong(src, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendClose(int statusCode, CharBuffer reason) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeClose(statusCode, reason, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+        close();\n+    }\n+\n+    private void sendMessage(List<ByteBuffer> bufs) throws IOException {\n+        if (closed)\n+            throw new IOException(\"closed\");\n+        synchronized(queue) {\n+            queue.addAll(bufs);\n+            queue.notify();\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized(queue) {\n+            closed = true;\n+            queue.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketResponder.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,435 @@\n+\/*\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardSocketOptions;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.CharacterCodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+import static java.lang.System.err;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Arrays.asList;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * WebSocket Server. This is a copy of the DummyWebSocketServer test class\n+ * but which also supports sending and receiving of websocket messages\n+ * using a simple API once the connection has been established\n+ *\n+ * MessageStreamHandler is the \"listener\" API to be implemented for handling\n+ * incoming messages. MessageStreamResponder is used by that handler to send\n+ * responses back to the client.\n+ *\n+ * Performs simpler version of the WebSocket Opening Handshake over HTTP (i.e.\n+ * no proxying, cookies, etc.) Supports sequential connections, one at a time,\n+ * i.e. in order for a client to connect to the server the previous client must\n+ * disconnect first.\n+ *\n+ * Expected client request:\n+ *\n+ *     GET \/chat HTTP\/1.1\n+ *     Host: server.example.com\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n+ *     Origin: http:\/\/example.com\n+ *     Sec-WebSocket-Protocol: chat, superchat\n+ *     Sec-WebSocket-Version: 13\n+ *\n+ * This server response:\n+ *\n+ *     HTTP\/1.1 101 Switching Protocols\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n+ *     Sec-WebSocket-Protocol: chat\n+ *\/\n+public class WebSocketServer implements Closeable {\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private final Thread thread;\n+    private volatile ServerSocketChannel ssc;\n+    private volatile InetSocketAddress address;\n+    private ByteBuffer read = ByteBuffer.allocate(16384);\n+    private final CountDownLatch readReady = new CountDownLatch(1);\n+    private final MessageStreamHandler handler;\n+    private final WebSocketResponder responder;\n+    private volatile int receiveBufferSize;\n+\n+    private static class Credentials {\n+        private final String name;\n+        private final String password;\n+        private Credentials(String name, String password) {\n+            this.name = name;\n+            this.password = password;\n+        }\n+        public String name() { return name; }\n+        public String password() { return password; }\n+    }\n+\n+    public WebSocketServer(MessageStreamHandler handler) {\n+        this(handler, defaultMapping(), null, null);\n+    }\n+\n+    public WebSocketServer() {\n+        this(null, defaultMapping(), null, null);\n+    }\n+\n+    public WebSocketServer(String username, String password) {\n+        this(null, defaultMapping(), username, password);\n+    }\n+\n+    public WebSocketServer(MessageStreamHandler handler,\n+                           BiFunction<List<String>,Credentials,List<String>> mapping,\n+                           String username, String password) {\n+        requireNonNull(mapping);\n+        this.handler = handler;\n+        if (handler == null) {\n+            this.responder = null;\n+        } else {\n+            this.responder = new WebSocketResponder(handler);\n+            handler.onInit(this.responder);\n+        }\n+        Credentials credentials = username != null ?\n+                new Credentials(username, password) : null;\n+\n+        thread = new Thread(() -> {\n+            try {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    err.println(\"Accepting next connection at: \" + ssc);\n+                    SocketChannel channel = ssc.accept();\n+                    err.println(\"Accepted: \" + channel);\n+                    try {\n+                        channel.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+                        channel.configureBlocking(true);\n+                        while (true) {\n+                            StringBuilder request = new StringBuilder();\n+                            if (!readRequest(channel, request)) {\n+                                throw new IOException(\"Bad request:[\" + request + \"]\");\n+                            }\n+                            List<String> strings = asList(request.toString().split(\"\\r\\n\"));\n+                            List<String> response = mapping.apply(strings, credentials);\n+                            writeResponse(channel, response);\n+\n+                            if (response.get(0).startsWith(\"HTTP\/1.1 401\")) {\n+                                err.println(\"Sent 401 Authentication response \" + channel);\n+                                continue;\n+                            } else {\n+                                serve(channel);\n+                                break;\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        err.println(\"Error in connection: \" + channel + \", \" + e);\n+                    } finally {\n+                        err.println(\"Closed: \" + channel);\n+                        close(channel);\n+                        readReady.countDown();\n+                    }\n+                }\n+            } catch (ClosedByInterruptException ignored) {\n+            } catch (Exception e) {\n+                e.printStackTrace(err);\n+            } finally {\n+                close(ssc);\n+                err.println(\"Stopped at: \" + getURI());\n+            }\n+        });\n+        thread.setName(\"WebSocketServer\");\n+        thread.setDaemon(false);\n+    }\n+\n+    \/\/ runs in own thread. Override to implement different behavior\n+    protected void read(SocketChannel ch) throws IOException {\n+        responder.readLoop(ch);\n+    }\n+\n+    \/\/ runs in own thread. Override to implement different behavior\n+    protected void write(SocketChannel ch) throws IOException {\n+        responder.writeLoop(ch);\n+    }\n+\n+    protected final void serve(SocketChannel channel)\n+            throws InterruptedException\n+    {\n+        Thread reader = new Thread(() -> {\n+            try {\n+                read(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        Thread writer = new Thread(() -> {\n+            try {\n+                write(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        reader.start();\n+        writer.start();\n+        try {\n+            reader.join();\n+        } finally {\n+            reader.interrupt();\n+            try {\n+                writer.join();\n+            } finally {\n+                writer.interrupt();\n+            }\n+        }\n+    }\n+\n+    public ByteBuffer read() throws InterruptedException {\n+        readReady.await();\n+        return read.duplicate().asReadOnlyBuffer().flip();\n+    }\n+\n+    public void setReceiveBufferSize(int bufsize) {\n+        assert ssc == null : \"Must configure before calling open()\";\n+        this.receiveBufferSize = bufsize;\n+    }\n+\n+    public void open() throws IOException {\n+        err.println(\"Starting\");\n+        if (!started.compareAndSet(false, true)) {\n+            throw new IllegalStateException(\"Already started\");\n+        }\n+        ssc = ServerSocketChannel.open();\n+        try {\n+            ssc.configureBlocking(true);\n+            var bufsize = receiveBufferSize;\n+            if (bufsize > 0) {\n+                err.printf(\"Configuring receive buffer size to %d%n\", bufsize);\n+                try {\n+                    ssc.setOption(StandardSocketOptions.SO_RCVBUF, bufsize);\n+                } catch (IOException x) {\n+                    err.printf(\"Failed to configure receive buffer size to %d%n\", bufsize);\n+                }\n+            }\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            address = (InetSocketAddress) ssc.getLocalAddress();\n+            thread.start();\n+        } catch (IOException e) {\n+            close(ssc);\n+            throw e;\n+        }\n+        err.println(\"Started at: \" + getURI());\n+    }\n+\n+    @Override\n+    public void close() {\n+        err.println(\"Stopping: \" + getURI());\n+        thread.interrupt();\n+        close(ssc);\n+    }\n+\n+    URI getURI() {\n+        if (!started.get()) {\n+            throw new IllegalStateException(\"Not yet started\");\n+        }\n+        return URI.create(\"ws:\/\/localhost:\" + address.getPort());\n+    }\n+\n+    private boolean readRequest(SocketChannel channel, StringBuilder request)\n+            throws IOException\n+    {\n+        ByteBuffer buffer = ByteBuffer.allocate(512);\n+        while (channel.read(buffer) != -1) {\n+            \/\/ read the complete HTTP request headers, there should be no body\n+            CharBuffer decoded;\n+            buffer.flip();\n+            try {\n+                decoded = ISO_8859_1.newDecoder().decode(buffer);\n+            } catch (CharacterCodingException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            request.append(decoded);\n+            if (Pattern.compile(\"\\r\\n\\r\\n\").matcher(request).find())\n+                return true;\n+            buffer.clear();\n+        }\n+        return false;\n+    }\n+\n+    private void writeResponse(SocketChannel channel, List<String> response)\n+            throws IOException\n+    {\n+        String s = response.stream().collect(Collectors.joining(\"\\r\\n\"))\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuffer encoded;\n+        try {\n+            encoded = ISO_8859_1.newEncoder().encode(CharBuffer.wrap(s));\n+        } catch (CharacterCodingException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        while (encoded.hasRemaining()) {\n+            channel.write(encoded);\n+        }\n+    }\n+\n+    private static BiFunction<List<String>,Credentials,List<String>> defaultMapping() {\n+        return (request, credentials) -> {\n+            List<String> response = new LinkedList<>();\n+            Iterator<String> iterator = request.iterator();\n+            if (!iterator.hasNext()) {\n+                throw new IllegalStateException(\"The request is empty\");\n+            }\n+            String statusLine = iterator.next();\n+            if (!(statusLine.startsWith(\"GET \/\") && statusLine.endsWith(\" HTTP\/1.1\"))) {\n+                throw new IllegalStateException\n+                        (\"Unexpected status line: \" + request.get(0));\n+            }\n+            response.add(\"HTTP\/1.1 101 Switching Protocols\");\n+            Map<String, List<String>> requestHeaders = new HashMap<>();\n+            while (iterator.hasNext()) {\n+                String header = iterator.next();\n+                String[] split = header.split(\": \");\n+                if (split.length != 2) {\n+                    throw new IllegalStateException\n+                            (\"Unexpected header: \" + header\n+                                     + \", split=\" + Arrays.toString(split));\n+                }\n+                requestHeaders.computeIfAbsent(split[0], k -> new ArrayList<>()).add(split[1]);\n+\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Protocol\")) {\n+                throw new IllegalStateException(\"Subprotocols are not expected\");\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Extensions\")) {\n+                throw new IllegalStateException(\"Extensions are not expected\");\n+            }\n+            expectHeader(requestHeaders, \"Connection\", \"Upgrade\");\n+            response.add(\"Connection: Upgrade\");\n+            expectHeader(requestHeaders, \"Upgrade\", \"websocket\");\n+            response.add(\"Upgrade: websocket\");\n+            expectHeader(requestHeaders, \"Sec-WebSocket-Version\", \"13\");\n+            List<String> key = requestHeaders.get(\"Sec-WebSocket-Key\");\n+            if (key == null || key.isEmpty()) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key is missing\");\n+            }\n+            if (key.size() != 1) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key has too many values : \" + key);\n+            }\n+            MessageDigest sha1 = null;\n+            try {\n+                sha1 = MessageDigest.getInstance(\"SHA-1\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new InternalError(e);\n+            }\n+            String x = key.get(0) + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n+            sha1.update(x.getBytes(ISO_8859_1));\n+            String v = Base64.getEncoder().encodeToString(sha1.digest());\n+            response.add(\"Sec-WebSocket-Accept: \" + v);\n+\n+            \/\/ check authorization credentials, if required by the server\n+            if (credentials != null && !authorized(credentials, requestHeaders)) {\n+                response.clear();\n+                response.add(\"HTTP\/1.1 401 Unauthorized\");\n+                response.add(\"Content-Length: 0\");\n+                response.add(\"WWW-Authenticate: Basic realm=\\\"dummy server realm\\\"\");\n+            }\n+\n+            return response;\n+        };\n+    }\n+\n+    \/\/ Checks credentials in the request against those allowable by the server.\n+    private static boolean authorized(Credentials credentials,\n+                                      Map<String,List<String>> requestHeaders) {\n+        List<String> authorization = requestHeaders.get(\"Authorization\");\n+        if (authorization == null)\n+            return false;\n+\n+        if (authorization.size() != 1) {\n+            throw new IllegalStateException(\"Authorization unexpected count:\" + authorization);\n+        }\n+        String header = authorization.get(0);\n+        if (!header.startsWith(\"Basic \"))\n+            throw new IllegalStateException(\"Authorization not Basic: \" + header);\n+\n+        header = header.substring(\"Basic \".length());\n+        String values = new String(Base64.getDecoder().decode(header), UTF_8);\n+        int sep = values.indexOf(':');\n+        if (sep < 1) {\n+            throw new IllegalStateException(\"Authorization not colon: \" +  values);\n+        }\n+        String name = values.substring(0, sep);\n+        String password = values.substring(sep + 1);\n+\n+        if (name.equals(credentials.name()) && password.equals(credentials.password()))\n+            return true;\n+\n+        return false;\n+    }\n+\n+    protected static String expectHeader(Map<String, List<String>> headers,\n+                                         String name,\n+                                         String value) {\n+        List<String> v = headers.get(name);\n+        if (v == null) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s' header, not present in %s\",\n+                           name, headers));\n+        }\n+        if (!v.contains(value)) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s: %s', actual: '%s: %s'\",\n+                           name, value, name, v)\n+            );\n+        }\n+        return value;\n+    }\n+\n+    private static void close(AutoCloseable... acs) {\n+        for (AutoCloseable ac : acs) {\n+            try {\n+                ac.close();\n+            } catch (Exception ignored) { }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketServer.java","additions":435,"deletions":0,"binary":false,"changes":435,"status":"added"},{"patch":"@@ -1137,0 +1137,20 @@\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+#if[byte]\n+        $Type$Buffer direct1 = $Type$Buffer.allocateDirect(cap);\n+        if (!direct1.toString().equals(Basic.toString(direct1))) {\n+           fail(\"Direct buffer toString is incorrect: \"\n+                  + direct1.toString() + \" vs \" + Basic.toString(direct1));\n+        }\n+#end[byte]\n+\n+#if[!char]\n+        $Type$Buffer nondirect1 = $Type$Buffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+#end[!char]\n+    }\n+\n@@ -1158,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/Basic-X.java.template","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1137,0 +1137,20 @@\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+        ByteBuffer direct1 = ByteBuffer.allocateDirect(cap);\n+        if (!direct1.toString().equals(Basic.toString(direct1))) {\n+           fail(\"Direct buffer toString is incorrect: \"\n+                  + direct1.toString() + \" vs \" + Basic.toString(direct1));\n+        }\n+\n+\n+\n+        ByteBuffer nondirect1 = ByteBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n+    }\n+\n@@ -1158,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicByte.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicChar.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        DoubleBuffer nondirect1 = DoubleBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicDouble.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        FloatBuffer nondirect1 = FloatBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicFloat.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        IntBuffer nondirect1 = IntBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicInt.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        LongBuffer nondirect1 = LongBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicLong.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        ShortBuffer nondirect1 = ShortBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicShort.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-            \"RebuildFreeList\"\n+            \"RebuildFreeList\",\n+            \"SampleCandidates\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.oldobject;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedObject;\n+import jdk.jfr.internal.test.WhiteBox;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @run main\/othervm  -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectSize\n+ *\/\n+public class TestObjectSize {\n+\n+    private interface Leak {\n+    }\n+    private static class Leak1 implements Leak {\n+        private long field1;\n+    }\n+    private static class Leak2 implements Leak {\n+        private long field1;\n+        private long field2;\n+    }\n+    private static class Leak3 implements Leak {\n+        private long field1;\n+        private long field2;\n+        private long field3;\n+    }\n+\n+    public static List<Object> leak = new ArrayList<>(OldObjects.MIN_SIZE);\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+\n+        final Random rand = new Random(1L);\n+\n+        long sizeLeak1, sizeLeak2, sizeLeak3;\n+\n+        do {\n+            sizeLeak1 = -1;\n+            sizeLeak2 = -1;\n+            sizeLeak3 = -1;\n+\n+            try (Recording recording = new Recording()) {\n+                leak.clear();\n+                recording.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n+                recording.start();\n+\n+                for (int i = 0; i < 1000; i++) {\n+                    switch (rand.nextInt(3)) {\n+                    case 0: leak.add(new Leak1()); break;\n+                    case 1: leak.add(new Leak2()); break;\n+                    case 2: leak.add(new Leak3()); break;\n+                    }\n+                }\n+\n+                recording.stop();\n+\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                Events.hasEvents(events);\n+                for (RecordedEvent e : events) {\n+                    RecordedObject object = e.getValue(\"object\");\n+                    RecordedClass type = object.getValue(\"type\");\n+                    long objectSize = e.getLong(\"objectSize\");\n+                    System.err.println(\"type = \" + type.getName() + \", objectSize = \" + e.getLong(\"objectSize\"));\n+                    if (objectSize <= 0) {\n+                        throw new Exception(\"Object size for \" + type.getName() + \" is lower or equal to 0\");\n+                    }\n+                    if (type.getName().equals(Leak1.class.getName())) {\n+                        sizeLeak1 = objectSize;\n+                    }\n+                    if (type.getName().equals(Leak2.class.getName())) {\n+                        sizeLeak2 = objectSize;\n+                    }\n+                    if (type.getName().equals(Leak3.class.getName())) {\n+                        sizeLeak3 = objectSize;\n+                    }\n+                }\n+            }\n+        } while (sizeLeak1 == -1 || sizeLeak2 == -1 || sizeLeak3 == -1);\n+\n+        if (sizeLeak3 <= sizeLeak2) {\n+            throw new Exception(\"Object size for \" + Leak3.class.getName() + \" is lower or equal to size for\" + Leak2.class.getName());\n+        }\n+        if (sizeLeak2 <= sizeLeak1) {\n+            throw new Exception(\"Object size for \" + Leak2.class.getName() + \" is lower or equal to size for\" + Leak1.class.getName());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectSize.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -1,305 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.runtime;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.*;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.dcmd.PidJcmdExecutor;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.*;\n-import java.util.concurrent.FutureTask;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * @test\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UseBiasedLocking jdk.jfr.event.runtime.TestBiasedLockRevocationEvents\n- *\/\n-public class TestBiasedLockRevocationEvents {\n-\n-    public static void main(String[] args) throws Throwable {\n-        testSingleRevocation();\n-        testBulkRevocation();\n-        testSelfRevocation();\n-        testExitedThreadRevocation();\n-        testBulkRevocationNoRebias();\n-        testRevocationSafepointIdCorrelation();\n-    }\n-\n-    \/\/ Default value of BiasedLockingBulkRebiasThreshold is 20, and BiasedLockingBulkRevokeTreshold is 40.\n-    \/\/ Using a value that will hit the first threshold once, and the second one the next time.\n-    private static final int BULK_REVOKE_THRESHOLD = 25;\n-\n-    static void touch(Object lock) {\n-        synchronized(lock) {\n-        }\n-    }\n-\n-    static Thread triggerRevocation(int numRevokes, Class<?> lockClass) throws Throwable {\n-        Object[] locks = new Object[numRevokes];\n-        for (int i = 0; i < locks.length; ++i) {\n-            locks[i] = lockClass.getDeclaredConstructor().newInstance();\n-            touch(locks[i]);\n-        }\n-\n-        Thread biasBreaker = new Thread(\"BiasBreaker\") {\n-            @Override\n-            public void run() {\n-                for (Object lock : locks) {\n-                    touch(lock);\n-                }\n-            }\n-        };\n-\n-        biasBreaker.start();\n-        biasBreaker.join();\n-\n-        return biasBreaker;\n-    }\n-\n-    \/\/ Basic stack trace validation, checking the name of the leaf method\n-    static void validateStackTrace(RecordedStackTrace stackTrace, String leafMethodName) {\n-        List<RecordedFrame> frames = stackTrace.getFrames();\n-        Asserts.assertFalse(frames.isEmpty());\n-        String name = frames.get(0).getMethod().getName();\n-        Asserts.assertEquals(name, leafMethodName);\n-    }\n-\n-    \/\/ Validates that the given stack trace refers to lock.touch(); in triggerRevocation\n-    static void validateStackTrace(RecordedStackTrace stackTrace) {\n-        validateStackTrace(stackTrace, \"touch\");\n-    }\n-\n-    \/\/ Retrieve all biased lock revocation events related to the provided lock class, sorted by start time\n-    static List<RecordedEvent> getRevocationEvents(Recording recording, String eventTypeName, String fieldName, Class<?> lockClass) throws Throwable {\n-        return Events.fromRecording(recording).stream()\n-                .filter(e -> e.getEventType().getName().equals(eventTypeName))\n-                .filter(e -> ((RecordedClass)e.getValue(fieldName)).getName().equals(lockClass.getName()))\n-                .sorted(Comparator.comparing(RecordedEvent::getStartTime))\n-                .collect(Collectors.toList());\n-    }\n-\n-    static void testSingleRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker = triggerRevocation(1, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, biasBreaker);\n-        Events.assertEventThread(event, \"previousOwner\", Thread.currentThread());\n-\n-        RecordedClass lockClass = event.getValue(\"lockClass\");\n-        Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testBulkRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, \"revokedClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, biasBreaker);\n-        Events.assertField(event, \"disableBiasing\").equal(false);\n-\n-        RecordedClass lockClass = event.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testSelfRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockSelfRevocation);\n-        recording.start();\n-\n-        MyLock l = new MyLock();\n-        touch(l);\n-        Thread.holdsLock(l);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockSelfRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, Thread.currentThread());\n-\n-        validateStackTrace(event.getStackTrace(), \"holdsLock\");\n-    }\n-\n-    static void testExitedThreadRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockRevocation);\n-        recording.start();\n-\n-        FutureTask<MyLock> lockerTask = new FutureTask<>(() -> {\n-           MyLock l = new MyLock();\n-           touch(l);\n-           return l;\n-        });\n-\n-        Thread locker = new Thread(lockerTask, \"BiasLocker\");\n-        locker.start();\n-        locker.join();\n-\n-        \/\/ Even after joining, the VM has a bit more work to do before the thread is actually removed\n-        \/\/ from the threads list. Ensure that this has happened before proceeding.\n-        while (true) {\n-            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n-            OutputAnalyzer oa = jcmd.execute(\"Thread.print\", true);\n-            String lockerThreadFound = oa.firstMatch(\"BiasLocker\");\n-            if (lockerThreadFound == null) {\n-                break;\n-            }\n-        };\n-\n-        MyLock l = lockerTask.get();\n-        touch(l);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, Thread.currentThread());\n-        \/\/ Previous owner will usually be null, but can also be a thread that\n-        \/\/ was created after the BiasLocker thread exited due to address reuse.\n-        RecordedThread prevOwner = event.getValue(\"previousOwner\");\n-        if (prevOwner != null) {\n-            Asserts.assertNE(prevOwner.getJavaName(), \"BiasLocker\");\n-        }\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testBulkRevocationNoRebias() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker0 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-        Thread biasBreaker1 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, \"revokedClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 2);\n-\n-        \/\/ The rebias event should occur before the noRebias one\n-        RecordedEvent eventRebias = events.get(0);\n-        RecordedEvent eventNoRebias = events.get(1);\n-\n-        Events.assertEventThread(eventRebias, biasBreaker0);\n-        Events.assertField(eventRebias, \"disableBiasing\").equal(false);\n-\n-        Events.assertEventThread(eventNoRebias, biasBreaker1);\n-        Events.assertField(eventNoRebias, \"disableBiasing\").equal(true);\n-\n-        RecordedClass lockClassRebias = eventRebias.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClassRebias.getName(), MyLock.class.getName());\n-        RecordedClass lockClassNoRebias = eventNoRebias.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClassNoRebias.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(eventRebias.getStackTrace());\n-        validateStackTrace(eventNoRebias.getStackTrace());\n-    }\n-\n-    static void testRevocationSafepointIdCorrelation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.enable(EventNames.ExecuteVMOperation);\n-        recording.start();\n-\n-        triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = Events.fromRecording(recording);\n-\n-        \/\/ Determine which safepoints included bulk revocation VM operations\n-        Set<Long> vmOperationsBulk = new HashSet<>();\n-\n-        for (RecordedEvent event : events) {\n-            if (event.getEventType().getName().equals(EventNames.ExecuteVMOperation)) {\n-                String operation = event.getValue(\"operation\");\n-                Long safepointId = event.getValue(\"safepointId\");\n-\n-                if (operation.equals(\"BulkRevokeBias\")) {\n-                    vmOperationsBulk.add(safepointId);\n-                }\n-            }\n-        }\n-\n-        int bulkRevokeCount = 0;\n-\n-        \/\/ Match all revoke events to a corresponding VMOperation event\n-        for (RecordedEvent event : events) {\n-            if (event.getEventType().getName().equals(EventNames.BiasedLockClassRevocation)) {\n-                Long safepointId = event.getValue(\"safepointId\");\n-                String lockClass = ((RecordedClass)event.getValue(\"revokedClass\")).getName();\n-                if (lockClass.toString().equals(MyLock.class.getName())) {\n-                    Asserts.assertTrue(vmOperationsBulk.contains(safepointId));\n-                    bulkRevokeCount++;\n-                }\n-            }\n-        }\n-\n-        Asserts.assertGT(bulkRevokeCount, 0);\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestBiasedLockRevocationEvents.java","additions":0,"deletions":305,"binary":false,"changes":305,"status":"deleted"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary The test verifies JFR.stop\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jcmd.TestJcmdStopWithoutFilename\n+ *\/\n+public class TestJcmdStopWithoutFilename {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        JcmdHelper.jcmd(\"JFR.start name=test\");\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.stop name=test\");\n+        output.shouldNotContain(\"written to\");\n+\n+        String filename = \"output.jfr\";\n+        JcmdHelper.jcmd(\"JFR.start name=test filename=\" + filename);\n+        output = JcmdHelper.jcmd(\"JFR.stop name=test\");\n+        output.shouldContain(\"written to\").shouldContain(filename);\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdStopWithoutFilename.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.util.*;\n-import java.io.IOException;\n-\n-\/**\n- * This class provides a partial implementation of the HttpCallback\n- * interface. Use this class if you want to use the requestURI as a means\n- * of tracking multiple invocations of a request (on the server).\n- * In this case, you implement the modified request() method, which includes\n- * an integer count parameter. This parameter indicates the number of times\n- * (starting at zero) the request URI has been received.\n- *\/\n-\n-public abstract class AbstractCallback implements HttpCallback {\n-\n-    Map requests;\n-\n-    static class Request {\n-        URI uri;\n-        int count;\n-\n-        Request (URI u) {\n-            uri = u;\n-            count = 0;\n-        }\n-    }\n-\n-    AbstractCallback () {\n-        requests = Collections.synchronizedMap (new HashMap());\n-    }\n-\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    public void request (HttpTransaction msg) {\n-        URI uri = msg.getRequestURI();\n-        Request req = (Request) requests.get (uri);\n-        if (req == null) {\n-            req = new Request (uri);\n-            requests.put (uri, req);\n-        }\n-        request (msg, req.count++);\n-    }\n-\n-    \/**\n-     * Same as HttpCallback interface except that the integer n\n-     * is provided to indicate sequencing of repeated requests using\n-     * the same request URI. n starts at zero and is incremented\n-     * for each successive call.\n-     *\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     * @param n value is 0 at first call, and is incremented by 1 for\n-     *        each subsequent call using the same request URI.\n-     *\/\n-    abstract public void request (HttpTransaction msg, int n);\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/AbstractCallback.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @modules java.base\/sun.net.www\n- * @build TestHttpsServer HttpCallback\n+ * @library \/test\/lib\n@@ -37,3 +36,14 @@\n-import java.io.*;\n-import java.net.*;\n-import javax.net.ssl.*;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpRetryException;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.security.KeyStore;\n+import java.util.concurrent.Executors;\n@@ -42,1 +52,13 @@\n-public class ChunkedOutputStream implements HttpCallback {\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+\n+public class ChunkedOutputStream implements HttpHandler {\n@@ -60,20 +82,7 @@\n-    public void request(HttpTransaction req) {\n-        try {\n-            \/\/ this is needed (count++ doesn't work), 'cause we\n-            \/\/ are doing concurrent tests\n-            String path = req.getRequestURI().getPath();\n-            if (path.equals(\"\/d0\")) {\n-                count = 0;\n-            } else if (path.equals(\"\/d01\")) {\n-                count = 1;\n-            } else if (path.equals(\"\/d3\")) {\n-                count = 2;\n-            } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n-                count = 3;\n-            } else if (path.equals(\"\/d6\")) {\n-                count = 3;\n-            }  else if (path.equals(\"\/d7\")) {\n-                count = 4;\n-            }  else if (path.equals(\"\/d8\")) {\n-                count = 5;\n-            }\n+    private static String getAuthority() {\n+        InetAddress address = server.getAddress().getAddress();\n+        String hostaddr = address.getHostAddress();\n+        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n+        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n+        return hostaddr + \":\" + server.getAddress().getPort();\n+    }\n@@ -81,1 +90,22 @@\n-            switch (count) {\n+    public void handle(HttpExchange req) throws IOException {\n+        \/\/ this is needed (count++ doesn't work), 'cause we\n+        \/\/ are doing concurrent tests\n+        System.out.println(\"Request Received\");\n+        String path = req.getRequestURI().getPath();\n+        if (path.equals(\"\/d0\")) {\n+            count = 0;\n+        } else if (path.equals(\"\/d01\")) {\n+            count = 1;\n+        } else if (path.equals(\"\/d3\")) {\n+            count = 2;\n+        } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n+            count = 3;\n+        } else if (path.equals(\"\/d6\")) {\n+            count = 3;\n+        }  else if (path.equals(\"\/d7\")) {\n+            count = 4;\n+        }  else if (path.equals(\"\/d8\")) {\n+            count = 5;\n+        }\n+\n+        switch (count) {\n@@ -84,1 +114,5 @@\n-                String reqbody = req.getRequestEntityBody();\n+\n+                String reqbody = \"\";\n+                try(InputStream inputStream = req.getRequestBody()) {\n+                    reqbody = new String(inputStream.readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                }\n@@ -86,2 +120,2 @@\n-                    req.sendResponse(500, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(500, -1);\n+                    break;\n@@ -89,1 +123,1 @@\n-                String chunk = req.getRequestHeader(\"Transfer-encoding\");\n+                String chunk = req.getRequestHeaders().getFirst(\"Transfer-encoding\");\n@@ -91,2 +125,2 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n@@ -94,1 +128,0 @@\n-                req.setResponseEntityBody(reqbody);\n@@ -96,1 +129,1 @@\n-                    req.setResponseHeader(\"Connection\", \"close\");\n+                    req.getResponseHeaders().set(\"Connection\", \"close\");\n@@ -98,3 +131,3 @@\n-                req.sendResponse(200, \"OK\");\n-                if (count == 1) {\n-                    req.orderlyClose();\n+                req.sendResponseHeaders(200, 0);\n+                try (OutputStream os = req.getResponseBody()) {\n+                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -104,1 +137,1 @@\n-                reqbody = req.getRequestEntityBody();\n+                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n@@ -106,2 +139,2 @@\n-                    req.sendResponse(500, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(500, -1);\n+                    break;\n@@ -109,2 +142,1 @@\n-                int clen = Integer.parseInt (\n-                        req.getRequestHeader(\"Content-length\"));\n+                int clen = Integer.parseInt (req.getRequestHeaders().getFirst(\"Content-length\"));\n@@ -112,2 +144,7 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n+                }\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(200, 0);\n+                try (OutputStream os = req.getResponseBody()) {\n+                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -115,4 +152,0 @@\n-                req.setResponseEntityBody (reqbody);\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(200, \"OK\");\n-                req.orderlyClose();\n@@ -121,4 +154,6 @@\n-                req.setResponseHeader(\"Location\", \"https:\/\/foo.bar\/\");\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(307, \"Temporary Redirect\");\n-                req.orderlyClose();\n+                if (path.equals(\"\/d6\")) {\n+                    reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                }\n+                req.getResponseHeaders().set(\"Location\", \"https:\/\/foo.bar\/\");\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(307, -1);\n@@ -128,1 +163,1 @@\n-                reqbody = req.getRequestEntityBody();\n+                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n@@ -130,2 +165,2 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n@@ -133,3 +168,2 @@\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(200, \"OK\");\n-                req.orderlyClose();\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(200, -1);\n@@ -138,2 +172,1 @@\n-                req.sendResponse(404, \"Not Found\");\n-                req.orderlyClose();\n+                req.sendResponseHeaders(404, -1);\n@@ -141,3 +174,0 @@\n-            }\n-        } catch (IOException e) {\n-            e.printStackTrace();\n@@ -145,7 +175,1 @@\n-    }\n-\n-    public boolean dropPlainTextConnections() {\n-        System.out.println(\"Unrecognized SSL message, plaintext connection?\");\n-        System.out.println(\"TestHttpsServer receveived rogue connection: ignoring it.\");\n-        rogueCount.incrementAndGet();\n-        return true;\n+        req.close();\n@@ -182,3 +206,0 @@\n-            \/\/ on the client side, and confirm that this::dropPlainTextConnections\n-            \/\/ has ben called.\n-            if (rogueCount.get() == rogue) throw x;\n@@ -199,1 +220,1 @@\n-        os.write(str1.getBytes());\n+        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -216,1 +237,1 @@\n-        os.write (str2.getBytes());\n+        os.write (str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -233,1 +254,1 @@\n-        os.write(str2.getBytes());\n+        os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -251,1 +272,1 @@\n-            os.write(str2.getBytes());\n+            os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -266,1 +287,1 @@\n-        os.write(str1.getBytes());\n+        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -313,1 +334,1 @@\n-    static TestHttpsServer server;\n+    static HttpsServer server;\n@@ -316,0 +337,1 @@\n+        ChunkedOutputStream chunkedOutputStream = new ChunkedOutputStream();\n@@ -336,4 +358,26 @@\n-                server = new TestHttpsServer(\n-                        new ChunkedOutputStream(), 1, 10, loopback, 0);\n-                System.out.println(\"Server started: listening on: \" + server.getAuthority());\n-                testPlainText(server.getAuthority());\n+                \/\/ create and initialize a SSLContext\n+                KeyStore ks = KeyStore.getInstance(\"JKS\");\n+                KeyStore ts = KeyStore.getInstance(\"JKS\");\n+                char[] passphrase = \"passphrase\".toCharArray();\n+\n+                ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+                ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+                kmf.init(ks, passphrase);\n+\n+                TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+                tmf.init(ts);\n+\n+                SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+                sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+                server = HttpsServer.create(new InetSocketAddress(loopback, 0), 10);\n+                server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n+                server.createContext(\"\/\", chunkedOutputStream);\n+                server.setExecutor(Executors.newSingleThreadExecutor());\n+                server.start();\n+\n+                System.out.println(\"Server started: listening on: \" + getAuthority());\n+                testPlainText(getAuthority());\n@@ -342,7 +386,7 @@\n-                test1(\"https:\/\/\" + server.getAuthority() + \"\/d01\");\n-                test3(\"https:\/\/\" + server.getAuthority() + \"\/d3\");\n-                test4(\"https:\/\/\" + server.getAuthority() + \"\/d4\");\n-                test5(\"https:\/\/\" + server.getAuthority() + \"\/d5\");\n-                test6(\"https:\/\/\" + server.getAuthority() + \"\/d6\");\n-                test7(\"https:\/\/\" + server.getAuthority() + \"\/d7\");\n-                test8(\"https:\/\/\" + server.getAuthority() + \"\/d8\");\n+                test1(\"https:\/\/\" + getAuthority() + \"\/d01\");\n+                test3(\"https:\/\/\" + getAuthority() + \"\/d3\");\n+                test4(\"https:\/\/\" + getAuthority() + \"\/d4\");\n+                test5(\"https:\/\/\" + getAuthority() + \"\/d5\");\n+                test6(\"https:\/\/\" + getAuthority() + \"\/d6\");\n+                test7(\"https:\/\/\" + getAuthority() + \"\/d7\");\n+                test8(\"https:\/\/\" + getAuthority() + \"\/d8\");\n@@ -351,1 +395,1 @@\n-                    server.terminate();\n+                    server.stop(1);\n@@ -355,1 +399,1 @@\n-            server.terminate();\n+            server.stop(1);\n@@ -368,1 +412,1 @@\n-        server.terminate();\n+        server.stop(1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/ChunkedOutputStream.java","additions":139,"deletions":95,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This interface is implemented by classes that wish to handle incoming HTTP\n- * requests and generate responses. This could be a general purpose HTTP server\n- * or a test case that expects specific requests from a client.\n- * <p>\n- * The incoming request fields can be examined via the {@link HttpTransaction}\n- * object, and a response can also be generated and sent via the request object.\n- *\/\n-public interface HttpCallback {\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    void request (HttpTransaction msg);\n-\n-    \/**\n-     * Tells whether the server should simply close the\n-     * connection and ignore the request when the first\n-     * byte received by the server looks like a plain\n-     * text connection.\n-     * @return true if the request should be ignored.\n-     **\/\n-    default boolean dropPlainTextConnections() {\n-        return false;\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpCallback.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,330 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.net.*;\n-import sun.net.www.MessageHeader;\n-\n-\/**\n- * This class encapsulates a HTTP request received and a response to be\n- * generated in one transaction. It provides methods for examaining the\n- * request from the client, and for building and sending a reply.\n- *\/\n-\n-public class HttpTransaction {\n-\n-    String command;\n-    URI requesturi;\n-    TestHttpsServer.ServerWorker server;\n-    MessageHeader reqheaders, reqtrailers;\n-    String reqbody;\n-    byte[] rspbody;\n-    MessageHeader rspheaders, rsptrailers;\n-    SocketChannel ch;\n-    int rspbodylen;\n-    boolean rspchunked;\n-\n-    HttpTransaction (TestHttpsServer.ServerWorker server, String command,\n-                        URI requesturi, MessageHeader headers,\n-                        String body, MessageHeader trailers, SocketChannel ch) {\n-        this.command = command;\n-        this.requesturi = requesturi;\n-        this.reqheaders = headers;\n-        this.reqbody = body;\n-        this.reqtrailers = trailers;\n-        this.ch = ch;\n-        this.server = server;\n-    }\n-\n-    \/**\n-     * Get the value of a request header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the request header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getRequestHeader (String key) {\n-        return reqheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the value of a response header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the response header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getResponseHeader (String key) {\n-        return rspheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the request URI\n-     *\n-     * @return the request URI\n-     *\/\n-    public URI getRequestURI () {\n-        return requesturi;\n-    }\n-\n-    public String toString () {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append (\"Request from: \").append (ch.toString()).append(\"\\r\\n\");\n-        buf.append (\"Command: \").append (command).append(\"\\r\\n\");\n-        buf.append (\"Request URI: \").append (requesturi).append(\"\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        buf.append (reqheaders.toString()).append(\"\\r\\n\");\n-        buf.append (\"Body: \").append (reqbody).append(\"\\r\\n\");\n-        buf.append (\"---------Response-------\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        if (rspheaders != null) {\n-            buf.append (rspheaders.toString()).append(\"\\r\\n\");\n-        }\n-        String rbody = rspbody == null? \"\": new String (rspbody);\n-        buf.append (\"Body: \").append (rbody).append(\"\\r\\n\");\n-        return new String (buf);\n-    }\n-\n-    \/**\n-     * Get the value of a request trailer whose name is specified by\n-     * the String argument.\n-     *\n-     * @param key the name of the request trailer\n-     * @return the value of the trailer or null if it does not exist\n-     *\/\n-    public String getRequestTrailer (String key) {\n-        return reqtrailers.findValue (key);\n-    }\n-\n-    \/**\n-     * Add a response header to the response. Multiple calls with the same\n-     * key value result in multiple header lines with the same key identifier\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void addResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.add (key, val);\n-    }\n-\n-    \/**\n-     * Set a response header. Searches for first header with named key\n-     * and replaces its value with val\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void setResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.set (key, val);\n-    }\n-\n-    \/**\n-     * Add a response trailer to the response. Multiple calls with the same\n-     * key value result in multiple trailer lines with the same key identifier\n-     * @param key the name of the request trailer to add\n-     * @param val the value of the trailer\n-     *\/\n-    public void addResponseTrailer (String key, String val) {\n-        if (rsptrailers == null)\n-            rsptrailers = new MessageHeader ();\n-        rsptrailers.add (key, val);\n-    }\n-\n-    \/**\n-     * Get the request method\n-     *\n-     * @return the request method\n-     *\/\n-    public String getRequestMethod (){\n-        return command;\n-    }\n-\n-    \/**\n-     * Perform an orderly close of the TCP connection associated with this\n-     * request. This method guarantees that any response already sent will\n-     * not be reset (by this end). The implementation does a shutdownOutput()\n-     * of the TCP connection and for a period of time consumes and discards\n-     * data received on the reading side of the connection. This happens\n-     * in the background. After the period has expired the\n-     * connection is completely closed.\n-     *\/\n-\n-    public void orderlyClose () {\n-        try {\n-            server.orderlyCloseChannel (ch);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Do an immediate abortive close of the TCP connection associated\n-     * with this request.\n-     *\/\n-    public void abortiveClose () {\n-        try {\n-            server.abortiveCloseChannel(ch);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Get the SocketChannel associated with this request\n-     *\n-     * @return the socket channel\n-     *\/\n-    public SocketChannel channel() {\n-        return ch;\n-    }\n-\n-    \/**\n-     * Get the request entity body associated with this request\n-     * as a single String.\n-     *\n-     * @return the entity body in one String\n-     *\/\n-    public String getRequestEntityBody (){\n-        return reqbody;\n-    }\n-\n-    \/**\n-     * Set the entity response body with the given string\n-     * The content length is set to the length of the string\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (String body){\n-        rspbody = body.getBytes();\n-        rspbodylen = body.length();\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-    \/**\n-     * Set the entity response body with the given byte[]\n-     * The content length is set to the gven length\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (byte[] body, int len){\n-        rspbody = body;\n-        rspbodylen = len;\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-\n-\n-    \/**\n-     * Set the entity response body by reading the given inputstream\n-     *\n-     * @param is the inputstream from which to read the body\n-     *\/\n-    public void setResponseEntityBody (InputStream is) throws IOException {\n-        byte[] buf = new byte [2048];\n-        byte[] total = new byte [2048];\n-        int total_len = 2048;\n-        int c, len=0;\n-        while ((c=is.read (buf)) != -1) {\n-            if (len+c > total_len) {\n-                byte[] total1 = new byte [total_len * 2];\n-                System.arraycopy (total, 0, total1, 0, len);\n-                total = total1;\n-                total_len = total_len * 2;\n-            }\n-            System.arraycopy (buf, 0, total, len, c);\n-            len += c;\n-        }\n-        setResponseEntityBody (total, len);\n-    }\n-\n-    \/* chunked *\/\n-\n-    \/**\n-     * Set the entity response body with the given array of strings\n-     * The content encoding is set to \"chunked\" and each array element\n-     * is sent as one chunk.\n-     * @param body the array of string chunks to send in the response\n-     *\/\n-    public void setResponseEntityBody (String[] body) {\n-        StringBuffer buf = new StringBuffer ();\n-        int len = 0;\n-        for (int i=0; i<body.length; i++) {\n-            String chunklen = Integer.toHexString (body[i].length());\n-            len += body[i].length();\n-            buf.append (chunklen).append (\"\\r\\n\");\n-            buf.append (body[i]).append (\"\\r\\n\");\n-        }\n-        buf.append (\"0\\r\\n\");\n-        rspbody = new String (buf).getBytes();\n-        rspbodylen = rspbody.length;\n-        rspchunked = true;\n-        addResponseHeader (\"Transfer-encoding\", \"chunked\");\n-    }\n-\n-    \/**\n-     * Send the response with the current set of response parameters\n-     * but using the response code and string tag line as specified\n-     * @param rCode the response code to send\n-     * @param rTag the response string to send with the response code\n-     *\/\n-    public void sendResponse (int rCode, String rTag) throws IOException {\n-        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        if (rspheaders != null) {\n-            rspheaders.print (ps);\n-        } else {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush ();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        } else if (rspchunked) {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush();\n-    }\n-\n-    \/* sends one byte less than intended *\/\n-\n-    public void sendPartialResponse (int rCode, String rTag)throws IOException {\n-        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        ps.flush();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen-1);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        }\n-        ps.flush();\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpTransaction.java","additions":0,"deletions":330,"binary":false,"changes":330,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- *        HttpCallback TestHttpsServer ClosedChannelList\n- *        HttpTransaction TunnelProxy\n+ *        ClosedChannelList\n+ *        TunnelProxy\n@@ -43,5 +43,22 @@\n-import java.io.*;\n-import java.net.*;\n-import javax.net.ssl.*;\n-import java.util.*;\n-\n+import java.io.FileInputStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.ProxySelector;\n+import java.net.URL;\n+import java.security.KeyStore;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n@@ -52,1 +69,1 @@\n-    static TestHttpsServer server;\n+    static HttpsServer server;\n@@ -69,1 +86,0 @@\n-\n@@ -71,1 +87,0 @@\n-\n@@ -74,3 +89,1 @@\n-            System.setProperty(\"https.proxyPort\",\n-                        (new Integer(proxy.getLocalPort())).toString() );\n-\n+            ProxySelector.setDefault(ProxySelector.of(new InetSocketAddress(firstNonLoAddress, proxy.getLocalPort())));\n@@ -78,4 +91,0 @@\n-\n-            if (httpTrans.hasBadRequest) {\n-                throw new RuntimeException(\"Test failed : bad http request\");\n-            }\n@@ -87,1 +96,1 @@\n-               server.terminate();\n+               server.stop(1);\n@@ -138,1 +147,1 @@\n-    public static void startHttpServer() throws IOException {\n+    public static void startHttpServer() throws  Exception {\n@@ -142,1 +151,23 @@\n-        server = new TestHttpsServer(httpTrans, 1, 10, firstNonLoAddress, 0);\n+        \/\/ create and initialize a SSLContext\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+        char[] passphrase = \"passphrase\".toCharArray();\n+\n+        ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+        ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        server = HttpsServer.create(new InetSocketAddress(firstNonLoAddress, 0), 10);\n+        server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n+        server.createContext(\"\/\", httpTrans);\n+        server.setExecutor(Executors.newSingleThreadExecutor());\n+        server.start();\n@@ -147,1 +178,1 @@\n-        System.out.println(\"https server listen on: \" + server.getLocalPort());\n+        System.out.println(\"https server listen on: \" + server.getAddress().getPort());\n@@ -150,1 +181,1 @@\n-                            server.getLocalPort(), \"\/\");\n+                            server.getAddress().getPort(), \"\/\");\n@@ -153,0 +184,4 @@\n+        if(uc.getResponseCode() != 200) {\n+            uc.disconnect();\n+            throw new RuntimeException(\"Test failed : bad http request with response code : \"+ uc.getResponseCode());\n+        }\n@@ -163,2 +198,1 @@\n-class SimpleHttpTransaction implements HttpCallback {\n-    public boolean hasBadRequest = false;\n+class SimpleHttpTransaction implements HttpHandler {\n@@ -169,1 +203,1 @@\n-    public void request(HttpTransaction trans) {\n+    public void handle(HttpExchange trans) {\n@@ -175,2 +209,2 @@\n-                trans.addResponseHeader(\"Location\", location);\n-                trans.sendResponse(302, \"Moved Temporarily\");\n+                trans.getResponseHeaders().set(\"Location\", location);\n+                trans.sendResponseHeaders(302, -1);\n@@ -178,10 +212,1 @@\n-                \/\/ if the bug exsits, it'll send 2 GET commands\n-                \/\/ check 2nd GET here\n-                String duplicatedGet = trans.getRequestHeader(null);\n-                if (duplicatedGet != null &&\n-                    duplicatedGet.toUpperCase().indexOf(\"GET\") >= 0) {\n-                    trans.sendResponse(400, \"Bad Request\");\n-                    hasBadRequest = true;\n-                } else {\n-                    trans.sendResponse(200, \"OK\");\n-                }\n+                trans.sendResponseHeaders(200, -1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/B6216082.java","additions":63,"deletions":38,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,20 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n@@ -33,1 +49,0 @@\n-import java.util.*;\n@@ -46,1 +61,0 @@\n-     * @param cb the callback object which is invoked to handle each\n@@ -58,2 +72,0 @@\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n@@ -77,2 +89,0 @@\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n@@ -98,2 +108,0 @@\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n@@ -252,1 +260,0 @@\n-            HttpTransaction msg;\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TunnelProxy.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,983 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import sun.net.www.MessageHeader;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.security.*;\n-\n-\/**\n- * This class implements a simple HTTPS server. It uses multiple threads to\n- * handle connections in parallel, and will spin off a new thread to handle\n- * each request. (this is easier to implement with SSLEngine)\n- * <p>\n- * It must be instantiated with a {@link HttpCallback} object to which\n- * requests are given and must be handled.\n- * <p>\n- * Simple synchronization between the client(s) and server can be done\n- * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and\n- * {@link #rendezvous(String,int)} methods.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\n- * If you make a change in here, please don't forget to make the\n- * corresponding change in the J2SE equivalent.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\/\n-\n-public class TestHttpsServer {\n-\n-    ServerSocketChannel schan;\n-    int threads;\n-    int cperthread;\n-    HttpCallback cb;\n-    Server[] servers;\n-\n-    \/\/ ssl related fields\n-    static SSLContext sslCtx;\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified callback object\n-     * for handling requests. One thread is created to handle requests,\n-     * and up to ten TCP connections will be handled simultaneously.\n-     * @param cb the callback object which is invoked to handle each\n-     *  incoming request\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb) throws IOException {\n-        this(cb, 1, 10, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number of\n-     * threads and maximum number of connections per thread. This functions\n-     * the same as the 4 arg constructor, where the port argument is set to zero.\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n-     * @param threads the number of threads to create to handle requests\n-     *     in parallel\n-     * @param cperthread the number of simultaneous TCP connections to\n-     *     handle per thread\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread)\n-        throws IOException {\n-        this(cb, threads, cperthread, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread, int port)\n-        throws IOException {\n-        this(cb, threads, cperthread, null, port);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param address the InetAddress to bind to. {@code Null} means the\n-     *  wildcard address.\n-     * @param port the port number to bind the server to. {@code Zero}\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread, InetAddress address, int port)\n-        throws IOException {\n-        schan = ServerSocketChannel.open();\n-        InetSocketAddress addr = new InetSocketAddress(address, port);\n-        schan.socket().bind(addr);\n-        this.threads = threads;\n-        this.cb = cb;\n-        this.cperthread = cperthread;\n-\n-        try {\n-            \/\/ create and initialize a SSLContext\n-            KeyStore ks = KeyStore.getInstance(\"JKS\");\n-            KeyStore ts = KeyStore.getInstance(\"JKS\");\n-            char[] passphrase = \"passphrase\".toCharArray();\n-\n-            ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n-            ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n-\n-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-            kmf.init(ks, passphrase);\n-\n-            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-            tmf.init(ts);\n-\n-            sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-            sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-            servers = new Server[threads];\n-            for (int i=0; i<threads; i++) {\n-                servers[i] = new Server(cb, schan, cperthread);\n-                servers[i].start();\n-            }\n-        } catch (Exception ex) {\n-            throw new RuntimeException(\"test failed. cause: \"+ex.getMessage());\n-        }\n-    }\n-\n-    \/** Tell all threads in the server to exit within 5 seconds.\n-     *  This is an abortive termination. Just prior to the thread exiting\n-     *  all channels in that thread waiting to be closed are forceably closed.\n-     *\/\n-\n-    public void terminate() {\n-        for (int i=0; i<threads; i++) {\n-            servers[i].terminate ();\n-        }\n-    }\n-\n-    \/**\n-     * return the local port number to which the server is bound.\n-     * @return the local port number\n-     *\/\n-\n-    public int getLocalPort () {\n-        return schan.socket().getLocalPort ();\n-    }\n-\n-    public String getAuthority() {\n-        InetAddress address = schan.socket().getInetAddress();\n-        String hostaddr = address.getHostAddress();\n-        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n-        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n-        return hostaddr + \":\" + getLocalPort();\n-    }\n-\n-    static class Server extends Thread {\n-\n-        ServerSocketChannel schan;\n-        Selector selector;\n-        SelectionKey listenerKey;\n-        SelectionKey key; \/* the current key being processed *\/\n-        HttpCallback cb;\n-        ByteBuffer consumeBuffer;\n-        int maxconn;\n-        int nconn;\n-        ClosedChannelList clist;\n-        boolean shutdown;\n-\n-        Server(HttpCallback cb, ServerSocketChannel schan, int maxconn) {\n-            this.schan = schan;\n-            this.maxconn = maxconn;\n-            this.cb = cb;\n-            nconn = 0;\n-            consumeBuffer = ByteBuffer.allocate(512);\n-            clist = new ClosedChannelList();\n-            try {\n-                selector = Selector.open();\n-                schan.configureBlocking(false);\n-                listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);\n-            } catch (IOException e) {\n-                System.err.println(\"Server could not start: \" + e);\n-            }\n-        }\n-\n-        \/* Stop the thread as soon as possible *\/\n-        public synchronized void terminate() {\n-            shutdown = true;\n-        }\n-\n-        public void run()  {\n-            try {\n-                while (true) {\n-                    selector.select(1000);\n-                    Set selected = selector.selectedKeys();\n-                    Iterator iter = selected.iterator();\n-                    while (iter.hasNext()) {\n-                        key = (SelectionKey)iter.next();\n-                        if (key.equals (listenerKey)) {\n-                            SocketChannel sock = schan.accept();\n-                            if (sock == null) {\n-                                \/* false notification *\/\n-                                iter.remove();\n-                                continue;\n-                            }\n-                            sock.configureBlocking(true);\n-                            SSLEngine sslEng = sslCtx.createSSLEngine();\n-                            sslEng.setUseClientMode(false);\n-                            new ServerWorker(cb, sock, sslEng).start();\n-                            nconn ++;\n-                            if (nconn == maxconn) {\n-                                \/* deregister *\/\n-                                listenerKey.cancel();\n-                                listenerKey = null;\n-                            }\n-                        } else {\n-                            if (key.isReadable()) {\n-                                boolean closed = false;\n-                                SocketChannel chan = (SocketChannel)key.channel();\n-                                if (key.attachment() != null) {\n-                                    closed = consume(chan);\n-                                }\n-\n-                                if (closed) {\n-                                    chan.close();\n-                                    key.cancel();\n-                                    if (nconn == maxconn) {\n-                                        listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);\n-                                    }\n-                                    nconn --;\n-                                }\n-                            }\n-                        }\n-                        iter.remove();\n-                    }\n-                    clist.check();\n-\n-                    synchronized (this) {\n-                        if (shutdown) {\n-                            clist.terminate();\n-                            return;\n-                        }\n-                    }\n-                }\n-            } catch (IOException e) {\n-                System.out.println(\"Server exception: \" + e);\n-                \/\/ TODO finish\n-            }\n-        }\n-\n-        \/* read all the data off the channel without looking at it\n-         * return true if connection closed\n-         *\/\n-        boolean consume(SocketChannel chan) {\n-            try {\n-                consumeBuffer.clear();\n-                int c = chan.read(consumeBuffer);\n-                if (c == -1)\n-                    return true;\n-            } catch (IOException e) {\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    static class ServerWorker extends Thread {\n-        private ByteBuffer inNetBB;\n-        private ByteBuffer outNetBB;\n-        private ByteBuffer inAppBB;\n-        private ByteBuffer outAppBB;\n-\n-        SSLEngine sslEng;\n-        SocketChannel schan;\n-        HttpCallback cb;\n-        HandshakeStatus currentHSStatus;\n-        boolean initialHSComplete;\n-        boolean handshakeStarted;\n-        \/*\n-         * All inbound data goes through this buffer.\n-         *\n-         * It might be nice to use a cache of ByteBuffers so we're\n-         * not alloc\/dealloc'ing all over the place.\n-         *\/\n-\n-        \/*\n-         * Application buffers, also used for handshaking\n-         *\/\n-        private int appBBSize;\n-\n-        ServerWorker(HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {\n-            this.sslEng = sslEng;\n-            this.schan = schan;\n-            this.cb = cb;\n-            currentHSStatus = HandshakeStatus.NEED_UNWRAP;\n-            initialHSComplete = false;\n-            int netBBSize = sslEng.getSession().getPacketBufferSize();\n-            inNetBB =  ByteBuffer.allocate(netBBSize);\n-            outNetBB = ByteBuffer.allocate(netBBSize);\n-            appBBSize = sslEng.getSession().getApplicationBufferSize();\n-            inAppBB = ByteBuffer.allocate(appBBSize);\n-            outAppBB = ByteBuffer.allocate(appBBSize);\n-        }\n-\n-        public SSLEngine getSSLEngine() {\n-            return sslEng;\n-        }\n-\n-        public ByteBuffer outNetBB() {\n-            return outNetBB;\n-        }\n-\n-        public ByteBuffer outAppBB() {\n-            return outAppBB;\n-        }\n-\n-        public void run () {\n-            try {\n-                SSLEngineResult result;\n-\n-                while (!initialHSComplete) {\n-\n-                    switch (currentHSStatus) {\n-\n-                    case NEED_UNWRAP:\n-                        int bytes = schan.read(inNetBB);\n-                        if (!handshakeStarted && bytes > 0) {\n-                            handshakeStarted = true;\n-                            int byte0 = inNetBB.get(0);\n-                            if (byte0 != 0x16) {\n-                                \/\/ first byte of a TLS connection is supposed to be\n-                                \/\/ 0x16. If not it may be a plain text connection.\n-                                \/\/\n-                                \/\/ Sometime a rogue client may try to open a plain\n-                                \/\/ connection with our server. Calling this method\n-                                \/\/ gives a chance to the test logic to ignore such\n-                                \/\/ rogue connections.\n-                                \/\/\n-                                if (cb.dropPlainTextConnections()) {\n-                                    try { schan.close(); } catch (IOException x) { };\n-                                    return;\n-                                }\n-                                \/\/ else sslEng.unwrap will throw later on...\n-                            }\n-                        }\n-\n-needIO:\n-                        while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {\n-                            \/*\n-                             * Don't need to resize requestBB, since no app data should\n-                             * be generated here.\n-                             *\/\n-                            inNetBB.flip();\n-                            result = sslEng.unwrap(inNetBB, inAppBB);\n-                            inNetBB.compact();\n-                            currentHSStatus = result.getHandshakeStatus();\n-\n-                            switch (result.getStatus()) {\n-\n-                            case OK:\n-                                switch (currentHSStatus) {\n-                                case NOT_HANDSHAKING:\n-                                    throw new IOException(\n-                                                          \"Not handshaking during initial handshake\");\n-\n-                                case NEED_TASK:\n-                                    Runnable task;\n-                                    while ((task = sslEng.getDelegatedTask()) != null) {\n-                                        task.run();\n-                                        currentHSStatus = sslEng.getHandshakeStatus();\n-                                    }\n-                                    break;\n-                                }\n-\n-                                break;\n-\n-                            case BUFFER_UNDERFLOW:\n-                                break needIO;\n-\n-                            default: \/\/ BUFFER_OVERFLOW\/CLOSED:\n-                                throw new IOException(\"Received\" + result.getStatus() +\n-                                                      \"during initial handshaking\");\n-                            }\n-                        }\n-\n-                        \/*\n-                         * Just transitioned from read to write.\n-                         *\/\n-                        if (currentHSStatus != HandshakeStatus.NEED_WRAP) {\n-                            break;\n-                        }\n-\n-                        \/\/ Fall through and fill the write buffer.\n-\n-                    case NEED_WRAP:\n-                        \/*\n-                         * The flush above guarantees the out buffer to be empty\n-                         *\/\n-                        outNetBB.clear();\n-                        result = sslEng.wrap(inAppBB, outNetBB);\n-                        outNetBB.flip();\n-                        schan.write (outNetBB);\n-                        outNetBB.compact();\n-                        currentHSStatus = result.getHandshakeStatus();\n-\n-                        switch (result.getStatus()) {\n-                        case OK:\n-\n-                            if (currentHSStatus == HandshakeStatus.NEED_TASK) {\n-                                Runnable task;\n-                                while ((task = sslEng.getDelegatedTask()) != null) {\n-                                    task.run();\n-                                    currentHSStatus = sslEng.getHandshakeStatus();\n-                                }\n-                            }\n-\n-                            break;\n-\n-                        default: \/\/ BUFFER_OVERFLOW\/BUFFER_UNDERFLOW\/CLOSED:\n-                            throw new IOException(\"Received\" + result.getStatus() +\n-                                                  \"during initial handshaking\");\n-                        }\n-                        break;\n-\n-                    case FINISHED:\n-                        initialHSComplete = true;\n-                        break;\n-                    default: \/\/ NOT_HANDSHAKING\/NEED_TASK\n-                        throw new RuntimeException(\"Invalid Handshaking State\" +\n-                                                   currentHSStatus);\n-                    } \/\/ switch\n-                }\n-                \/\/ read the application data; using non-blocking mode\n-                schan.configureBlocking(false);\n-                read(schan, sslEng);\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n-        }\n-\n-        \/* return true if the connection is closed, false otherwise *\/\n-\n-        private boolean read(SocketChannel chan, SSLEngine sslEng) {\n-            HttpTransaction msg;\n-            boolean res;\n-            try {\n-                InputStream is = new BufferedInputStream(new NioInputStream(chan, sslEng, inNetBB, inAppBB));\n-                String requestline = readLine(is);\n-                MessageHeader mhead = new MessageHeader(is);\n-                String clen = mhead.findValue(\"Content-Length\");\n-                String trferenc = mhead.findValue(\"Transfer-Encoding\");\n-                String data = null;\n-                if (trferenc != null && trferenc.equals(\"chunked\"))\n-                    data = new String(readChunkedData(is));\n-                else if (clen != null)\n-                    data = new String(readNormalData(is, Integer.parseInt(clen)));\n-                String[] req = requestline.split(\" \");\n-                if (req.length < 2) {\n-                    \/* invalid request line *\/\n-                    return false;\n-                }\n-                String cmd = req[0];\n-                URI uri = null;\n-                try {\n-                    uri = new URI(req[1]);\n-                    msg = new HttpTransaction(this, cmd, uri, mhead, data, null, chan);\n-                    cb.request(msg);\n-                } catch (URISyntaxException e) {\n-                    System.err.println (\"Invalid URI: \" + e);\n-                    msg = new HttpTransaction(this, cmd, null, null, null, null, chan);\n-                    msg.sendResponse(501, \"Whatever\");\n-                }\n-                res = false;\n-            } catch (IOException e) {\n-                res = true;\n-            }\n-            return res;\n-        }\n-\n-        byte[] readNormalData(InputStream is, int len) throws IOException {\n-            byte[] buf  = new byte[len];\n-            int c, off=0, remain=len;\n-            while (remain > 0 && ((c=is.read (buf, off, remain))>0)) {\n-                remain -= c;\n-                off += c;\n-            }\n-            return buf;\n-        }\n-\n-        private void readCRLF(InputStream is) throws IOException {\n-            int cr = is.read();\n-            int lf = is.read();\n-\n-            if (((cr & 0xff) != 0x0d) ||\n-                ((lf & 0xff) != 0x0a)) {\n-                throw new IOException(\n-                    \"Expected <CR><LF>:  got '\" + cr + \"\/\" + lf + \"'\");\n-            }\n-        }\n-\n-        byte[] readChunkedData(InputStream is) throws IOException {\n-            LinkedList l = new LinkedList();\n-            int total = 0;\n-            for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {\n-                l.add(readNormalData(is, len));\n-                total += len;\n-                readCRLF(is); \/\/ CRLF at end of chunk\n-            }\n-            readCRLF(is); \/\/ CRLF at end of Chunked Stream.\n-            byte[] buf = new byte[total];\n-            Iterator i = l.iterator();\n-            int x = 0;\n-            while (i.hasNext()) {\n-                byte[] b = (byte[])i.next();\n-                System.arraycopy(b, 0, buf, x, b.length);\n-                x += b.length;\n-            }\n-            return buf;\n-        }\n-\n-        private int readChunkLen(InputStream is) throws IOException {\n-            int c, len=0;\n-            boolean done=false, readCR=false;\n-            while (!done) {\n-                c = is.read();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        int x=0;\n-                        if (c >= 'a' && c <= 'f') {\n-                            x = c - 'a' + 10;\n-                        } else if (c >= 'A' && c <= 'F') {\n-                            x = c - 'A' + 10;\n-                        } else if (c >= '0' && c <= '9') {\n-                            x = c - '0';\n-                        }\n-                        len = len * 16 + x;\n-                    }\n-                }\n-            }\n-            return len;\n-        }\n-\n-        private String readLine(InputStream is) throws IOException {\n-            boolean done=false, readCR=false;\n-            byte[] b = new byte[512];\n-            int c, l = 0;\n-\n-            while (!done) {\n-                c = is.read();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        b[l++] = (byte)c;\n-                    }\n-                }\n-            }\n-            return new String(b);\n-        }\n-\n-        \/** close the channel associated with the current key by:\n-         * 1. shutdownOutput (send a FIN)\n-         * 2. mark the key so that incoming data is to be consumed and discarded\n-         * 3. After a period, close the socket\n-         *\/\n-\n-        synchronized void orderlyCloseChannel(SocketChannel ch) throws IOException {\n-            ch.socket().shutdownOutput();\n-        }\n-\n-        synchronized void abortiveCloseChannel(SocketChannel ch) throws IOException {\n-            Socket s = ch.socket();\n-            s.setSoLinger(true, 0);\n-            ch.close();\n-        }\n-    }\n-\n-\n-    \/**\n-     * Implements blocking reading semantics on top of a non-blocking channel\n-     *\/\n-\n-    static class NioInputStream extends InputStream {\n-        SSLEngine sslEng;\n-        SocketChannel channel;\n-        Selector selector;\n-        ByteBuffer inNetBB;\n-        ByteBuffer inAppBB;\n-        SelectionKey key;\n-        int available;\n-        byte[] one;\n-        boolean closed;\n-        ByteBuffer markBuf; \/* reads may be satisifed from this buffer *\/\n-        boolean marked;\n-        boolean reset;\n-        int readlimit;\n-\n-        public NioInputStream(SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {\n-            this.sslEng = sslEng;\n-            this.channel = chan;\n-            selector = Selector.open();\n-            this.inNetBB = inNetBB;\n-            this.inAppBB = inAppBB;\n-            key = chan.register(selector, SelectionKey.OP_READ);\n-            available = 0;\n-            one = new byte[1];\n-            closed = marked = reset = false;\n-        }\n-\n-        public synchronized int read(byte[] b) throws IOException {\n-            return read(b, 0, b.length);\n-        }\n-\n-        public synchronized int read() throws IOException {\n-            return read(one, 0, 1);\n-        }\n-\n-        public synchronized int read(byte[] b, int off, int srclen) throws IOException {\n-\n-            int canreturn, willreturn;\n-\n-            if (closed)\n-                return -1;\n-\n-            if (reset) { \/* satisfy from markBuf *\/\n-                canreturn = markBuf.remaining();\n-                willreturn = canreturn > srclen ? srclen : canreturn;\n-                markBuf.get(b, off, willreturn);\n-                if (canreturn == willreturn) {\n-                    reset = false;\n-                }\n-            } else { \/* satisfy from channel *\/\n-                canreturn = available();\n-                if (canreturn == 0) {\n-                    block();\n-                    canreturn = available();\n-                }\n-                willreturn = canreturn > srclen ? srclen : canreturn;\n-                inAppBB.get(b, off, willreturn);\n-                available -= willreturn;\n-\n-                if (marked) { \/* copy into markBuf *\/\n-                    try {\n-                        markBuf.put(b, off, willreturn);\n-                    } catch (BufferOverflowException e) {\n-                        marked = false;\n-                    }\n-                }\n-            }\n-            return willreturn;\n-        }\n-\n-        public synchronized int available() throws IOException {\n-            if (closed)\n-                throw new IOException(\"Stream is closed\");\n-\n-            if (reset)\n-                return markBuf.remaining();\n-\n-            if (available > 0)\n-                return available;\n-\n-            inAppBB.clear();\n-            int bytes = channel.read(inNetBB);\n-\n-            int needed = sslEng.getSession().getApplicationBufferSize();\n-            if (needed > inAppBB.remaining()) {\n-                inAppBB = ByteBuffer.allocate(needed);\n-            }\n-            inNetBB.flip();\n-            SSLEngineResult result = sslEng.unwrap(inNetBB, inAppBB);\n-            inNetBB.compact();\n-            available = result.bytesProduced();\n-\n-            if (available > 0)\n-                inAppBB.flip();\n-            else if (available == -1)\n-                throw new IOException(\"Stream is closed\");\n-            return available;\n-        }\n-\n-        \/**\n-         * block() only called when available==0 and buf is empty\n-         *\/\n-        private synchronized void block() throws IOException {\n-            \/\/assert available == 0;\n-            int n = selector.select();\n-            \/\/assert n == 1;\n-            selector.selectedKeys().clear();\n-            available();\n-        }\n-\n-        public void close() throws IOException {\n-            if (closed)\n-                return;\n-            channel.close();\n-            closed = true;\n-        }\n-\n-        public synchronized void mark(int readlimit) {\n-            if (closed)\n-                return;\n-            this.readlimit = readlimit;\n-            markBuf = ByteBuffer.allocate(readlimit);\n-            marked = true;\n-            reset = false;\n-        }\n-\n-        public synchronized void reset() throws IOException {\n-            if (closed )\n-                return;\n-            if (!marked)\n-                throw new IOException(\"Stream not marked\");\n-            marked = false;\n-            reset = true;\n-            markBuf.flip();\n-        }\n-    }\n-\n-    static class NioOutputStream extends OutputStream {\n-        SSLEngine sslEng;\n-        SocketChannel channel;\n-        ByteBuffer outNetBB;\n-        ByteBuffer outAppBB;\n-        SelectionKey key;\n-        Selector selector;\n-        boolean closed;\n-        byte[] one;\n-\n-        public NioOutputStream(SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {\n-            this.sslEng = sslEng;\n-            this.channel = channel;\n-            this.outNetBB = outNetBB;\n-            this.outAppBB = outAppBB;\n-            selector = Selector.open();\n-            key = channel.register(selector, SelectionKey.OP_WRITE);\n-            closed = false;\n-            one = new byte[1];\n-        }\n-\n-        public synchronized void write(int b) throws IOException {\n-            one[0] = (byte)b;\n-            write(one, 0, 1);\n-        }\n-\n-        public synchronized void write(byte[] b) throws IOException {\n-            write(b, 0, b.length);\n-        }\n-\n-        public synchronized void write(byte[] b, int off, int len) throws IOException {\n-            if (closed)\n-                throw new IOException(\"stream is closed\");\n-\n-            outAppBB = ByteBuffer.allocate(len);\n-            outAppBB.put(b, off, len);\n-            outAppBB.flip();\n-            int n;\n-            outNetBB.clear();\n-            int needed = sslEng.getSession().getPacketBufferSize();\n-            if (outNetBB.capacity() < needed) {\n-                outNetBB = ByteBuffer.allocate(needed);\n-            }\n-            SSLEngineResult ret = sslEng.wrap(outAppBB, outNetBB);\n-            outNetBB.flip();\n-            int newLen = ret.bytesProduced();\n-            while ((n = channel.write (outNetBB)) < newLen) {\n-                newLen -= n;\n-                if (newLen == 0)\n-                    return;\n-                selector.select();\n-                selector.selectedKeys().clear();\n-            }\n-        }\n-\n-        public void close() throws IOException {\n-            if (closed)\n-                return;\n-            channel.close();\n-            closed = true;\n-        }\n-    }\n-\n-    \/**\n-     * Utilities for synchronization. A condition is\n-     * identified by a string name, and is initialized\n-     * upon first use (ie. setCondition() or waitForCondition()). Threads\n-     * are blocked until some thread calls (or has called) setCondition() for the same\n-     * condition.\n-     * <P>\n-     * A rendezvous built on a condition is also provided for synchronizing\n-     * N threads.\n-     *\/\n-\n-    private static HashMap conditions = new HashMap();\n-\n-    \/*\n-     * Modifiable boolean object\n-     *\/\n-    private static class BValue {\n-        boolean v;\n-    }\n-\n-    \/*\n-     * Modifiable int object\n-     *\/\n-    private static class IValue {\n-        int v;\n-        IValue(int i) {\n-            v =i;\n-        }\n-    }\n-\n-\n-    private static BValue getCond(String condition) {\n-        synchronized (conditions) {\n-            BValue cond = (BValue) conditions.get(condition);\n-            if (cond == null) {\n-                cond = new BValue();\n-                conditions.put(condition, cond);\n-            }\n-            return cond;\n-        }\n-    }\n-\n-    \/**\n-     * Set the condition to true. Any threads that are currently blocked\n-     * waiting on the condition, will be unblocked and allowed to continue.\n-     * Threads that subsequently call waitForCondition() will not block.\n-     * If the named condition did not exist prior to the call, then it is created\n-     * first.\n-     *\/\n-\n-    public static void setCondition(String condition) {\n-        BValue cond = getCond(condition);\n-        synchronized (cond) {\n-            if (cond.v) {\n-                return;\n-            }\n-            cond.v = true;\n-            cond.notifyAll();\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition does not exist, then it is created and initialized\n-     * to false. If the condition exists or has just been created and its value\n-     * is false, then the thread blocks until another thread sets the condition.\n-     * If the condition exists and is already set to true, then this call returns\n-     * immediately without blocking.\n-     *\/\n-\n-    public static void waitForCondition(String condition) {\n-        BValue cond = getCond(condition);\n-        synchronized (cond) {\n-            if (!cond.v) {\n-                try {\n-                    cond.wait();\n-                } catch (InterruptedException e) {}\n-            }\n-        }\n-    }\n-\n-    \/* conditions must be locked when accessing this *\/\n-    static HashMap rv = new HashMap();\n-\n-    \/**\n-     * Force N threads to rendezvous (ie. wait for each other) before proceeding.\n-     * The first thread(s) to call are blocked until the last\n-     * thread makes the call. Then all threads continue.\n-     * <p>\n-     * All threads that call with the same condition name, must use the same value\n-     * for N (or the results may be not be as expected).\n-     * <P>\n-     * Obviously, if fewer than N threads make the rendezvous then the result\n-     * will be a hang.\n-     *\/\n-\n-    public static void rendezvous(String condition, int N) {\n-        BValue cond;\n-        IValue iv;\n-        String name = \"RV_\"+condition;\n-\n-        \/* get the condition *\/\n-\n-        synchronized (conditions) {\n-            cond = (BValue)conditions.get(name);\n-            if (cond == null) {\n-                \/* we are first caller *\/\n-                if (N < 2) {\n-                    throw new RuntimeException(\"rendezvous must be called with N >= 2\");\n-                }\n-                cond = new BValue();\n-                conditions.put(name, cond);\n-                iv = new IValue(N-1);\n-                rv.put(name, iv);\n-            } else {\n-                \/* already initialised, just decrement the counter *\/\n-                iv = (IValue) rv.get(name);\n-                iv.v--;\n-            }\n-        }\n-\n-        if (iv.v > 0) {\n-            waitForCondition(name);\n-        } else {\n-            setCondition(name);\n-            synchronized (conditions) {\n-                clearCondition(name);\n-                rv.remove(name);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition exists and is set then remove it, so it can\n-     * be re-initialized and used again. If the condition does not exist, or\n-     * exists but is not set, then the call returns without doing anything.\n-     * Note, some higher level synchronization\n-     * may be needed between clear and the other operations.\n-     *\/\n-\n-    public static void clearCondition(String condition) {\n-        BValue cond;\n-        synchronized (conditions) {\n-            cond = (BValue) conditions.get(condition);\n-            if (cond == null) {\n-                return;\n-            }\n-            synchronized (cond) {\n-                if (cond.v) {\n-                    conditions.remove(condition);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/TestHttpsServer.java","additions":0,"deletions":983,"binary":false,"changes":983,"status":"deleted"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8266082\n+ * @summary javac should not crash when seeing type annotations in links\n+ * @compile\/fail\/ref=CrashInAnnotateTest.out -Xdoclint -XDrawDiagnostics CrashInAnnotateTest.java\n+ *\/\n+\n+import java.util.List;\n+\n+\/** {@link #equals(@Deprecated Object)}\n+ *  {@link java.util.Map.@Deprecated Entry#getKey()}\n+ *\/\n+class CrashInAnnotateTest {\n+}\n+\n+\/** {@link #compare(Object, List<List<@Deprecated Object>>)} *\/\n+class CrashInAnnotateTest2 {\n+    void compare(Object o, List<List<Object>> l) {}\n+}\n+\n+\/** {@link @Deprecated java.lang.Object#hashCode()} *\/\n+class CrashInAnnotateTest3 { }\n+\n+\/** {@link CrashInAnnotateTest4.@java.lang.Deprecated Inner#aField}\n+ *  {@link java.util.Map.@Deprecated#getKey()}\n+ *\/\n+class CrashInAnnotateTest4 {\n+    class Inner {\n+        Object aField;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+CrashInAnnotateTest.java:10:5: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:11:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:16:5: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:18:10: compiler.warn.proc.messager: no comment\n+CrashInAnnotateTest.java:21:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:24:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:25:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:28:5: compiler.warn.proc.messager: no comment\n+CrashInAnnotateTest.java:29:16: compiler.warn.proc.messager: no comment\n+6 errors\n+3 warnings\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ *                                      RELEASE_18\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetSourceVersions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-        SEVENTEEN(\"17\", 61);\n+        SEVENTEEN(\"17\", 61),\n+        EIGHTEEN(\"18\", 62);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/ClassVersionChecker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.dc.ref.annotations.not.allowed\n+\/\/ key: compiler.note.note\n+\/\/ key: compiler.note.proc.messager\n+\/\/ run: backdoor\n+\/\/ options: -processor DocCommentProcessor -proc:only\n+\n+\/** {@link #equals(@Deprecated Object)} *\/\n+class NoAnnotationsInLink {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NoAnnotationsInLink.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -124,1 +124,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -134,1 +134,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -144,1 +144,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -165,1 +165,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -184,1 +184,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -205,1 +205,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -226,1 +226,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -247,1 +247,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.err.preview.feature.disabled.classfile: Bar.class, 17\n+- compiler.err.preview.feature.disabled.classfile: Bar.class, 18\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.nopreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.preview.feature.use.classfile: Bar.class, 17\n+- compiler.warn.preview.feature.use.classfile: Bar.class, 18\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.preview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,2 @@\n-        Set.of(\"1.7\", \"1.8\", \"1.9\", \"1.10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\");\n+        Set.of(\"1.7\", \"1.8\", \"1.9\", \"1.10\", \"11\", \"12\", \"13\", \"14\",\n+               \"15\", \"16\", \"17\", \"18\");\n@@ -75,1 +76,1 @@\n-    public static final String LATEST_MAJOR_VERSION = \"61.0\";\n+    public static final String LATEST_MAJOR_VERSION = \"62.0\";\n@@ -88,1 +89,2 @@\n-        SEVENTEEN(false,  \"61.0\", \"17\", Versions::checksrc17);\n+        SEVENTEEN(false, \"61.0\", \"17\", Versions::checksrc17),\n+        EIGHTEEN(false,  \"62.0\", \"18\", Versions::checksrc18);\n@@ -304,1 +306,1 @@\n-       \/\/ Add expectedFail after new language features added in a later release.\n+        expectedFail(args, List.of(\"New17.java\"));\n@@ -310,1 +312,8 @@\n-                                  \"New14.java\", \"New15.java\", \"New16.java\"));\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n+       \/\/ Add expectedFail after new language features added in a later release.\n+    }\n+\n+   protected void checksrc18(List<String> args) {\n+       printargs(\"checksrc18\", args);\n+       expectedPass(args, List.of(\"New7.java\", \"New8.java\", \"New10.java\", \"New11.java\",\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n@@ -538,0 +547,15 @@\n+\n+        \/*\n+         * Create a file with a new feature in 17, not in 16 : sealed classes\n+         *\/\n+        writeSourceFile(\"New17.java\",\n+            \"\"\"\n+            public class New17 {\n+                public static sealed class Seal {}\n+\n+                public static final class Pinniped extends Seal {}\n+                public static final class TaperedThread extends Seal {}\n+                public static final class Wax extends Seal {}\n+            }\n+            \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class JDWP {\n+\n+    public record ListenAddress(String transport, String address) {\n+    }\n+\n+    \/\/ lazy initialized\n+    private static Pattern listenRegexp;\n+\n+    \/**\n+     * Parses debuggee output to get listening transport and address.\n+     * Returns null if the string specified does not contain required info.\n+     *\/\n+    public static ListenAddress parseListenAddress(String debuggeeOutput) {\n+        if (listenRegexp == null) {\n+            listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n+        }\n+        Matcher m = listenRegexp.matcher(debuggeeOutput);\n+        if (m.find()) {\n+            return new ListenAddress(m.group(1), m.group(2));\n+        }\n+        return null;\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/JDWP.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -83,3 +83,0 @@\n-    public final static String BiasedLockRevocation = PREFIX + \"BiasedLockRevocation\";\n-    public final static String BiasedLockSelfRevocation = PREFIX + \"BiasedLockSelfRevocation\";\n-    public final static String BiasedLockClassRevocation = PREFIX + \"BiasedLockClassRevocation\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-    return getMethodCompilationLevel(method, false \/*not ost*\/);\n+    return getMethodCompilationLevel(method, false \/*not osr*\/);\n@@ -608,0 +608,1 @@\n+  public native boolean handshakeReadMonitors(Thread t);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import sun.security.util.DisabledAlgorithmConstraints;\n+\n+import java.security.AlgorithmConstraints;\n+import java.security.CryptoPrimitive;\n+import java.util.concurrent.TimeUnit;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static sun.security.util.DisabledAlgorithmConstraints.PROPERTY_TLS_DISABLED_ALGS;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\"})\n+@State(Scope.Thread)\n+public class AlgorithmConstraintsPermits {\n+\n+    AlgorithmConstraints tlsDisabledAlgConstraints;\n+    Set<CryptoPrimitive> primitives = EnumSet.of(CryptoPrimitive.KEY_AGREEMENT);\n+\n+    @Param({\"SSLv3\", \"DES\", \"NULL\", \"TLS1.3\"})\n+    String algorithm;\n+\n+    @Setup\n+    public void setup() {\n+        tlsDisabledAlgConstraints = new DisabledAlgorithmConstraints(PROPERTY_TLS_DISABLED_ALGS);\n+    }\n+\n+    @Benchmark\n+    public boolean permits() {\n+        return tlsDisabledAlgConstraints.permits(primitives, algorithm, null);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/AlgorithmConstraintsPermits.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,12 +113,0 @@\n-    \/**\n-     * Same as {@link #testRecursiveSynchronization()} but the first call\n-     * to this method will generate the identity hashcode for this object\n-     * which effectively disables biased locking as they occupy the same\n-     * bits in the object header.\n-     *\/\n-    @Benchmark\n-    public void testRecursiveSynchronizationNoBias() {\n-        System.identityHashCode(this);\n-        factorial = fact(10);\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"}]}