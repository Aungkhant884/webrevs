{"files":[{"patch":"@@ -1198,0 +1198,2 @@\n+     *\n+     * @return {@inheritDoc SortedMap}\n","filename":"src\/java.base\/share\/classes\/java\/util\/TreeMap.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1534,1 +1534,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc ConcurrentMap}\n@@ -1545,1 +1545,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc ConcurrentMap}\n@@ -1548,0 +1548,1 @@\n+     * @return {@inheritDoc ConcurrentMap}\n@@ -1556,1 +1557,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc ConcurrentMap}\n@@ -1559,0 +1560,1 @@\n+     * @return {@inheritDoc ConcurrentMap}\n@@ -1567,1 +1569,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc ConcurrentMap}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1776,1 +1776,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc ConcurrentMap}\n@@ -1791,1 +1791,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc ConcurrentMap}\n@@ -1796,0 +1796,1 @@\n+     * @return {@inheritDoc ConcurrentMap}\n@@ -1804,1 +1805,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc ConcurrentMap}\n@@ -1809,0 +1810,1 @@\n+     * @return {@inheritDoc ConcurrentMap}\n@@ -1827,1 +1829,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc ConcurrentMap}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentSkipListMap.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -631,0 +631,1 @@\n+     * {@inheritDoc BlockingDeque}\n@@ -632,0 +633,1 @@\n+     * @return {@inheritDoc BlockingDeque}\n@@ -668,0 +670,4 @@\n+    \/**\n+     * {@inheritDoc BlockingDeque}\n+     * @return {@inheritDoc BlockingDeque}\n+     *\/\n@@ -694,0 +700,4 @@\n+    \/**\n+     * {@inheritDoc BlockingDeque}\n+     * @return {@inheritDoc BlockingDeque}\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedBlockingDeque.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -243,0 +243,5 @@\n+    \/**\n+     * {@inheritDoc ImageOutputStream}\n+     * @param pos {@inheritDoc ImageOutputStream}\n+     * @throws IOException {@inheritDoc ImageOutputStream}\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileCacheImageOutputStream.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -187,0 +187,5 @@\n+    \/**\n+     * {@inheritDoc ImageOutputStream}\n+     * @param pos {@inheritDoc ImageOutputStream}\n+     * @throws IOException {@inheritDoc ImageOutputStream}\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/MemoryCacheImageOutputStream.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -251,0 +251,4 @@\n+        \/**\n+         * {@inheritDoc java.awt.event.MouseListener}\n+         * @param e {@inheritDoc java.awt.event.MouseListener}\n+         *\/\n@@ -266,0 +270,4 @@\n+        \/**\n+         * {@inheritDoc java.awt.event.MouseListener}\n+         * @param e {@inheritDoc java.awt.event.MouseListener}\n+         *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicDesktopIconUI.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -858,0 +858,4 @@\n+        \/**\n+         * {@inheritDoc java.awt.event.MouseListener}\n+         * @param e {@inheritDoc java.awt.event.MouseListener}\n+         *\/\n@@ -914,0 +918,4 @@\n+        \/**\n+         * {@inheritDoc java.awt.event.MouseListener}\n+         * @param e {@inheritDoc java.awt.event.MouseListener}\n+         *\/\n@@ -918,0 +926,4 @@\n+        \/**\n+         * {@inheritDoc java.awt.event.MouseListener}\n+         * @param e {@inheritDoc java.awt.event.MouseListener}\n+         *\/\n@@ -1303,0 +1315,4 @@\n+        \/**\n+         * {@inheritDoc java.awt.event.MouseListener}\n+         * @param e {@inheritDoc java.awt.event.MouseListener}\n+         *\/\n@@ -1307,0 +1323,4 @@\n+        \/**\n+         * {@inheritDoc java.awt.event.MouseListener}\n+         * @param e {@inheritDoc java.awt.event.MouseListener}\n+         *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicInternalFrameUI.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ *    {&#064;inheritDoc supertype}\n@@ -37,1 +38,13 @@\n-public interface InheritDocTree extends InlineTagTree { }\n+public interface InheritDocTree extends InlineTagTree {\n+\n+    \/**\n+     * {@return the reference to a superclass or superinterface from which\n+     * to inherit documentation, or {@code null} if no reference was provided}\n+     *\n+     * @implSpec this implementation returns {@code null}.\n+     * @since 21\n+     *\/\n+    default ReferenceTree getSupertype() {\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/InheritDocTree.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -241,0 +241,11 @@\n+    \/**\n+     * Creates a new {@code InheritDocTree} object, to represent an {@code {@inheritDoc}} tag.\n+     * @param supertype a superclass or superinterface reference\n+     * @return an {@code InheritDocTree} object\n+     * @implSpec This implementation throws {@code UnsupportedOperationException}.\n+     * @since 21\n+     *\/\n+    default InheritDocTree newInheritDocTree(ReferenceTree supertype) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-     * @implSpec This implementation returns {@code null}.\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -351,1 +351,1 @@\n-        return null;\n+        return scan(node.getSupertype(), p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeScanner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1304,1 +1304,1 @@\n-            \/\/ {@inheritDoc}\n+            \/\/ {@inheritDoc class-name}\n@@ -1308,0 +1308,2 @@\n+                    DCReference ref = reference(ReferenceParser.Mode.MEMBER_DISALLOWED);\n+                    skipWhitespace();\n@@ -1310,1 +1312,7 @@\n-                        return m.at(pos).newInheritDocTree();\n+                        \/\/ for backward compatibility, use the original legacy\n+                        \/\/ method if no ref is given\n+                        if (ref == null) {\n+                            return m.at(pos).newInheritDocTree();\n+                        } else {\n+                            return m.at(pos).newInheritDocTree(ref);\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -751,0 +751,6 @@\n+        public final DCReference supertype;\n+\n+        public DCInheritDoc(DCReference supertype) {\n+            this.supertype = supertype;\n+        }\n+\n@@ -756,0 +762,5 @@\n+        @Override\n+        public ReferenceTree getSupertype() {\n+            return supertype;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -313,0 +313,4 @@\n+            if (node.getSupertype() != null) {\n+                print(\" \");\n+                print(node.getSupertype());\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocPretty.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,1 +314,6 @@\n-        DCInheritDoc tree = new DCInheritDoc();\n+        return newInheritDocTree(null);\n+    }\n+\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DCInheritDoc newInheritDocTree(ReferenceTree supertype) {\n+        DCInheritDoc tree = new DCInheritDoc((DCReference) supertype);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+doclet.inheritDocBadSupertype=cannot find the overridden method\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Optional;\n@@ -35,0 +34,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -37,0 +37,2 @@\n+import com.sun.source.doctree.InheritDocTree;\n+import com.sun.source.util.DocTreePath;\n@@ -45,0 +47,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -73,1 +76,1 @@\n-                                                   DocTree inheritDoc,\n+                                                   InheritDocTree inheritDoc,\n@@ -80,1 +83,2 @@\n-        var path = ch.getDocTreePath(inheritDoc).getParentPath();\n+        DocTreePath inheritDocPath = ch.getDocTreePath(inheritDoc);\n+        var path = inheritDocPath.getParentPath();\n@@ -82,0 +86,38 @@\n+\n+        ExecutableElement src = null;\n+        \/\/ 1. Does @inheritDoc specify a type?\n+        if (inheritDoc.getSupertype() != null) {\n+            \/\/ 2. Can we find that type?\n+            var supertype = (TypeElement) ch.getReferencedElement(inheritDoc.getSupertype());\n+            if (supertype == null) {\n+                messages.error(inheritDocPath, \"doclet.inheritDocBadSupertype\");\n+                return replacement;\n+            }\n+            \/\/ 3. Does that type have a method that this method overrides?\n+            \/\/ Skip a direct check that the type that declares this method is a subtype\n+            \/\/ of the type that @inheritDoc specifies. Do the \"overrides\" check for\n+            \/\/ individual methods. Not only will such a check find the overridden\n+            \/\/ method, but it will also filter out self-referring inheritors\n+            \/\/ (S is the same type as the type that contains {@inheritDoc S})\n+            \/\/ due to irreflexivity of the \"overrides\" relationship.\n+            \/\/\n+            \/\/ This way we do more work in erroneous case, but less in the typical\n+            \/\/ case. We don't optimize for the former.\n+            VisibleMemberTable visibleMemberTable = configuration.getVisibleMemberTable(supertype);\n+            List<Element> methods = visibleMemberTable.getAllVisibleMembers(VisibleMemberTable.Kind.METHODS);\n+            for (Element e : methods) {\n+                ExecutableElement m = (ExecutableElement) e;\n+                if (utils.elementUtils.overrides(method, m, (TypeElement) method.getEnclosingElement())) {\n+                    assert !method.equals(m) : Utils.diagnosticDescriptionOf(method);\n+                    src = m;\n+                    break;\n+                }\n+            }\n+            if (src == null) {\n+                \/\/ \"self-inheritors\" and supertypes that do not contain a method\n+                \/\/ that this method overrides\n+                messages.error(inheritDocPath, \"doclet.inheritDocBadSupertype\");\n+                return replacement;\n+            }\n+        }\n+\n@@ -85,5 +127,5 @@\n-                Optional<Documentation> r = docFinder.trySearch(method,\n-                        m -> Result.fromOptional(extractMainDescription(m, isFirstSentence, utils))).toOptional();\n-                if (r.isPresent()) {\n-                    replacement = writer.commentTagsToOutput(r.get().method, null,\n-                            r.get().mainDescription, isFirstSentence);\n+                Result<Documentation> d;\n+                if (src == null) {\n+                    d = docFinder.find(method, m -> extractMainDescription(m, isFirstSentence, utils));\n+                } else {\n+                    d = docFinder.search(src, m -> extractMainDescription(m, isFirstSentence, utils));\n@@ -91,1 +133,5 @@\n-            } catch (DocFinder.NoOverriddenMethodsFound e) {\n+                if (d instanceof Result.Conclude<Documentation> doc) {\n+                    replacement = writer.commentTagsToOutput(doc.value().method, null,\n+                            doc.value().mainDescription, isFirstSentence);\n+                }\n+            } catch (DocFinder.NoOverriddenMethodFound e) {\n@@ -100,1 +146,3 @@\n-        if (taglet != null && !(taglet instanceof InheritableTaglet)) {\n+        \/\/ taglet is null if holderTag is unknown, which it shouldn't be since we reached here\n+        assert taglet != null;\n+        if (!(taglet instanceof InheritableTaglet inheritableTaglet)) {\n@@ -106,1 +154,2 @@\n-        InheritableTaglet.Output inheritedDoc = ((InheritableTaglet) taglet).inherit(method, holderTag, isFirstSentence, configuration);\n+        InheritableTaglet.Output inheritedDoc = inheritableTaglet.inherit(method, src, holderTag, isFirstSentence, configuration);\n+\n@@ -122,1 +171,1 @@\n-    private static Optional<Documentation> extractMainDescription(ExecutableElement m,\n+    private static Result<Documentation> extractMainDescription(ExecutableElement m,\n@@ -125,1 +174,1 @@\n-        List<? extends DocTree> docTrees = extractFirstSentenceOnly\n+        var mainDescriptionTrees = extractFirstSentenceOnly\n@@ -128,1 +177,1 @@\n-        return docTrees.isEmpty() ? Optional.empty() : Optional.of(new Documentation(docTrees, m));\n+        return mainDescriptionTrees.isEmpty() ? Result.CONTINUE() : Result.CONCLUDE(new Documentation(mainDescriptionTrees, m));\n@@ -136,1 +185,1 @@\n-        return retrieveInheritedDocumentation(tagletWriter, (ExecutableElement) e, inheritDoc, tagletWriter.isFirstSentence);\n+        return retrieveInheritedDocumentation(tagletWriter, (ExecutableElement) e, (InheritDocTree) inheritDoc, tagletWriter.isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritDocTaglet.java","additions":65,"deletions":16,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,2 @@\n-     * Called by InheritDocTaglet on an inheritable taglet to expand {@inheritDoc}\n-     * found inside a tag corresponding to that taglet.\n+     * Called by InheritDocTaglet on an inheritable taglet to expand {@inheritDoc S}\n+     * found inside a tag corresponding to that taglet in a method (dst).\n@@ -55,1 +55,1 @@\n-    Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n+    Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritableTaglet.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,2 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        assert owner.getKind() == ElementKind.METHOD;\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        assert dst.getKind() == ElementKind.METHOD;\n@@ -70,1 +70,1 @@\n-        var method = (ExecutableElement) owner;\n+        var method = (ExecutableElement) dst;\n@@ -80,1 +80,1 @@\n-        CommentHelper ch = configuration.utils.getCommentHelper(owner);\n+        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n@@ -88,3 +88,11 @@\n-            var r = docFinder.trySearch(method,\n-                            m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n-                    .toOptional();\n+\n+            Optional<Documentation> r;\n+            if (src != null){\n+                r = docFinder.search((ExecutableElement) src,\n+                                m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n+                        .toOptional();\n+            } else {\n+                r = docFinder.find((ExecutableElement) dst,\n+                                m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n+                        .toOptional();\n+            }\n@@ -93,1 +101,1 @@\n-        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n@@ -66,1 +66,6 @@\n-            var r = docFinder.trySearch((ExecutableElement) owner, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n+            Optional<Documentation> r;\n+            if (src == null) {\n+                r = docFinder.find((ExecutableElement) dst, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n+            } else {\n+                r = docFinder.search((ExecutableElement) src, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n+            }\n@@ -69,1 +74,1 @@\n-        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        CommentHelper ch = configuration.utils.getCommentHelper(owner);\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,2 +166,2 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        assert owner.getKind() == ElementKind.METHOD;\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        assert dst.getKind() == ElementKind.METHOD;\n@@ -171,2 +171,8 @@\n-            var r = docFinder.trySearch((ExecutableElement) owner,\n-                    m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n+            Optional<Documentation> r;\n+            if (src == null) {\n+                r = docFinder.find((ExecutableElement) dst,\n+                        m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n+            } else {\n+                r = docFinder.search((ExecutableElement) src,\n+                        m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n+            }\n@@ -175,1 +181,1 @@\n-        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SimpleTaglet.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        CommentHelper ch = configuration.utils.getCommentHelper(owner);\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+import com.sun.source.doctree.InheritDocTree;\n@@ -55,0 +56,1 @@\n+import com.sun.source.util.DocTreePath;\n@@ -62,0 +64,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -168,1 +171,1 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n@@ -173,1 +176,1 @@\n-        throw newAssertionError(owner, tag, isFirstSentence);\n+        throw newAssertionError(dst, tag, isFirstSentence);\n@@ -196,0 +199,3 @@\n+            } else if (f instanceof Failure.NoOverrideFound e) {\n+                var path = ch.getDocTreePath(e.inheritDoc);\n+                messages.error(path, \"doclet.inheritDocBadSupertype\");\n@@ -203,1 +209,1 @@\n-        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n@@ -220,1 +226,2 @@\n-                   DocFinder.NoOverriddenMethodsFound\n+                   Failure.NoOverrideFound,\n+            DocFinder.NoOverriddenMethodFound\n@@ -256,2 +263,2 @@\n-                    r = expandShallowly(exceptionElement, executable);\n-                } catch (Failure | DocFinder.NoOverriddenMethodsFound e) {\n+                    r = expandShallowly(exceptionElement, executable, Optional.empty());\n+                } catch (Failure | DocFinder.NoOverriddenMethodFound e) {\n@@ -307,1 +314,2 @@\n-                   DocFinder.NoOverriddenMethodsFound\n+                   Failure.NoOverrideFound,\n+            DocFinder.NoOverriddenMethodFound\n@@ -325,2 +333,2 @@\n-                   DocFinder.NoOverriddenMethodsFound\n-    {\n+                   Failure.NoOverrideFound,\n+            DocFinder.NoOverriddenMethodFound {\n@@ -371,0 +379,25 @@\n+\n+            var inheritDoc = (InheritDocTree) tag.getDescription().get(i);\n+            var ch = utils.getCommentHelper(holder);\n+            \/\/ Sadly, almost exact duplicating code from InheritDocTaglet:\n+            ExecutableElement src = null;\n+            if (inheritDoc.getSupertype() != null) {\n+                var supertype = (TypeElement) ch.getReferencedElement(inheritDoc.getSupertype());\n+                if (supertype == null) {\n+                    throw new Failure.NoOverrideFound(tag, holder, inheritDoc);\n+                }\n+                VisibleMemberTable visibleMemberTable = configuration.getVisibleMemberTable(supertype);\n+                List<Element> methods = visibleMemberTable.getAllVisibleMembers(VisibleMemberTable.Kind.METHODS);\n+                for (Element e : methods) {\n+                    ExecutableElement m = (ExecutableElement) e;\n+                    if (utils.elementUtils.overrides(holder, m, (TypeElement) holder.getEnclosingElement())) {\n+                        assert !holder.equals(m) : Utils.diagnosticDescriptionOf(holder);\n+                        src = m;\n+                        break;\n+                    }\n+                }\n+                if (src == null) {\n+                    throw new Failure.NoOverrideFound(tag, holder, inheritDoc);\n+                }\n+            }\n+\n@@ -373,1 +406,1 @@\n-                tags = expandShallowly(originalExceptionElement, holder);\n+                tags = expandShallowly(originalExceptionElement, holder, Optional.ofNullable(src));\n@@ -519,0 +552,10 @@\n+\n+        static final class NoOverrideFound extends Failure {\n+\n+            private final InheritDocTree inheritDoc;\n+\n+            public NoOverrideFound(DocTree tag, ExecutableElement holder, InheritDocTree inheritDoc) {\n+                super(tag, holder);\n+                this.inheritDoc = inheritDoc;\n+            }\n+        }\n@@ -529,1 +572,2 @@\n-                                                               ExecutableElement holder)\n+                                                               ExecutableElement holder,\n+                                                               Optional<ExecutableElement> src)\n@@ -534,1 +578,1 @@\n-                   DocFinder.NoOverriddenMethodsFound\n+            DocFinder.NoOverriddenMethodFound\n@@ -565,1 +609,5 @@\n-            result = utils.docFinder().trySearch(holder, criterion);\n+            if (src.isPresent()) {\n+                result = utils.docFinder().search(src.get(), criterion);\n+            } else {\n+                result = utils.docFinder().find(holder, criterion);\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":62,"deletions":14,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.source.doctree.InheritDocTree;\n@@ -320,0 +321,5 @@\n+        @Override\n+        public R visitInheritDoc(InheritDocTree node, Void p) {\n+            return visit(node.getSupertype(), p);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -32,1 +31,0 @@\n-import java.util.function.BiFunction;\n@@ -34,1 +32,0 @@\n-\n@@ -50,2 +47,1 @@\n-    private final Function<ExecutableElement, ExecutableElement> overriddenMethodLookup;\n-    private final BiFunction<ExecutableElement, ExecutableElement, Iterable<ExecutableElement>> implementedMethodsLookup;\n+    private final Function<ExecutableElement, Iterable<? extends ExecutableElement>> overriddenMethodLookup;\n@@ -53,2 +49,1 @@\n-    DocFinder(Function<ExecutableElement, ExecutableElement> overriddenMethodLookup,\n-              BiFunction<ExecutableElement, ExecutableElement, Iterable<ExecutableElement>> implementedMethodsLookup) {\n+    DocFinder(Function<ExecutableElement, Iterable<? extends ExecutableElement>> overriddenMethodLookup) {\n@@ -56,1 +51,0 @@\n-        this.implementedMethodsLookup = implementedMethodsLookup;\n@@ -60,1 +54,1 @@\n-    public static final class NoOverriddenMethodsFound extends Exception {\n+    public static final class NoOverriddenMethodFound extends Exception {\n@@ -63,8 +57,1 @@\n-        private NoOverriddenMethodsFound() { }\n-    }\n-\n-    public <T, X extends Throwable> Result<T> search(ExecutableElement method,\n-                                                     Criterion<T, X> criterion)\n-            throws X\n-    {\n-        return search(method, true, criterion);\n+        private NoOverriddenMethodFound() { }\n@@ -74,1 +61,0 @@\n-                                                     boolean includeMethod,\n@@ -79,2 +65,2 @@\n-            return search0(method, includeMethod, false, criterion);\n-        } catch (NoOverriddenMethodsFound e) {\n+            return search0(method, true, false, criterion);\n+        } catch (NoOverriddenMethodFound e) {\n@@ -86,3 +72,3 @@\n-    public <T, X extends Throwable> Result<T> trySearch(ExecutableElement method,\n-                                                        Criterion<T, X> criterion)\n-            throws NoOverriddenMethodsFound, X\n+    public <T, X extends Throwable> Result<T> find(ExecutableElement method,\n+                                                   Criterion<T, X> criterion)\n+            throws NoOverriddenMethodFound, X\n@@ -117,1 +103,1 @@\n-            throws NoOverriddenMethodsFound, X\n+            throws NoOverriddenMethodFound, X\n@@ -121,1 +107,1 @@\n-        Iterator<ExecutableElement> methods = methodsOverriddenBy(method);\n+        Iterator<? extends ExecutableElement> methods = overriddenMethodLookup.apply(method).iterator();\n@@ -123,1 +109,1 @@\n-            throw new NoOverriddenMethodsFound();\n+            throw new NoOverriddenMethodFound();\n@@ -131,1 +117,1 @@\n-            r = search0(m, true, false \/* don't check for overrides *\/, criterion);\n+            r = criterion.apply(m);\n@@ -139,13 +125,0 @@\n-    \/\/ We see both overridden and implemented methods as overridden\n-    \/\/ (see JLS 8.4.8.1. Overriding (by Instance Methods))\n-    private Iterator<ExecutableElement> methodsOverriddenBy(ExecutableElement method) {\n-        \/\/ TODO: create a lazy iterator if required\n-        var list = new ArrayList<ExecutableElement>();\n-        ExecutableElement overridden = overriddenMethodLookup.apply(method);\n-        if (overridden != null) {\n-            list.add(overridden);\n-        }\n-        implementedMethodsLookup.apply(method, method).forEach(list::add);\n-        return list.iterator();\n-    }\n-\n@@ -211,1 +184,1 @@\n-         * conclude the search or continue it.\n+         * conclude the search or to continue it.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocFinder.java","additions":15,"deletions":42,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -38,0 +39,1 @@\n+import java.util.Collections;\n@@ -49,0 +51,1 @@\n+import java.util.NoSuchElementException;\n@@ -55,0 +58,1 @@\n+import java.util.stream.Collectors;\n@@ -67,0 +71,1 @@\n+import javax.lang.model.element.QualifiedNameable;\n@@ -121,1 +126,0 @@\n-import jdk.javadoc.internal.tool.DocEnvImpl;\n@@ -141,0 +145,1 @@\n+    private final TypeElement JAVA_LANG_OBJECT;\n@@ -147,0 +152,1 @@\n+        JAVA_LANG_OBJECT = elementUtils.getTypeElement(\"java.lang.Object\");\n@@ -2751,4 +2757,1 @@\n-        return new DocFinder(e -> {\n-            var i = overriddenMethod(e);\n-            return i == null ? null : i.overriddenMethod();\n-        }, this::implementedMethods);\n+        return new DocFinder(this::overriddenMethods);\n@@ -2757,3 +2760,117 @@\n-    private Iterable<ExecutableElement> implementedMethods(ExecutableElement originalMethod, ExecutableElement m) {\n-        var type = configuration.utils.getEnclosingTypeElement(m);\n-        return configuration.getVisibleMemberTable(type).getImplementedMethods(originalMethod);\n+    \/*\n+     * Returns an iterable over all unique methods overridden by the given\n+     * method from its enclosing type element. The methods encounter order\n+     * is that of described in the \"Automatic Supertype Search\" section of\n+     * the Documentation Comment Specification for the Standard Doclet.\n+     *\/\n+    private Iterable<? extends ExecutableElement> overriddenMethods(ExecutableElement method) {\n+        return () -> new Overrides(method);\n+    }\n+\n+    private class Overrides implements Iterator<ExecutableElement> {\n+\n+        \/\/ prefer java.util.Deque to java.util.Stack API for stacks\n+        final Deque<TypeElement> searchStack = new ArrayDeque<>();\n+        final Set<TypeElement> visited = new HashSet<>();\n+\n+        final ExecutableElement overrider;\n+        ExecutableElement next;\n+\n+        public Overrides(ExecutableElement method) {\n+            if (method.getKind() != ElementKind.METHOD) {\n+                throw new IllegalArgumentException(diagnosticDescriptionOf(method));\n+            }\n+            overrider = method;\n+            \/\/ java.lang.Object is to be searched for overrides last\n+            searchStack.push(JAVA_LANG_OBJECT);\n+            searchStack.push((TypeElement) method.getEnclosingElement());\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (next != null) {\n+                return true;\n+            }\n+            updateNext();\n+            return next != null;\n+        }\n+\n+        @Override\n+        public ExecutableElement next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            var n = next;\n+            updateNext();\n+            return n;\n+        }\n+\n+        private void updateNext() {\n+            while (!searchStack.isEmpty()) {\n+                \/\/ replace the top class or interface with its supertypes\n+                var t = searchStack.pop();\n+\n+                \/\/ <TODO refactor once java.util.List.reversed() from\n+                \/\/   SequencedCollection is available>\n+                var filteredSupertypes = typeUtils.directSupertypes(t.asType()).stream()\n+                        .map(t_ -> (TypeElement) ((DeclaredType) t_).asElement())\n+                        \/\/ filter out java.lang.Object using the fact that at\n+                        \/\/ most one class type comes first in the stream of\n+                        \/\/ direct supertypes\n+                        .dropWhile(JAVA_LANG_OBJECT::equals)\n+                        .filter(visited::add) \/\/ idempotent side effect\n+                        .collect(Collectors.toCollection(ArrayList::new));\n+                \/\/ push supertypes in reverse order, so that they are popped\n+                \/\/ back in the initial order\n+                Collections.reverse(filteredSupertypes);\n+                filteredSupertypes.forEach(searchStack::push);\n+                \/\/ <\/TODO>\n+\n+                \/\/ consider only the declared methods for consistency with\n+                \/\/ the existing facilities, such as Utils.overriddenMethod\n+                \/\/ and VisibleMemberTable.getImplementedMethods\n+                TypeElement peek = searchStack.peek();\n+                if (peek == null) {\n+                    next = null; \/\/ end-of-hierarchy\n+                    break;\n+                }\n+                if (isPlainInterface(peek) && !isPublic(peek) && !isLinkable(peek)) {\n+                    \/\/ we don't consider such interfaces directly, but may consider\n+                    \/\/ their supertypes (subject to this check for each of them)\n+                    continue;\n+                }\n+                List<Element> declaredMethods = configuration.getVisibleMemberTable(peek)\n+                        .getMembers(VisibleMemberTable.Kind.METHODS);\n+                var overridden = declaredMethods.stream()\n+                        .filter(candidate -> elementUtils.overrides(overrider, (ExecutableElement) candidate,\n+                                (TypeElement) overrider.getEnclosingElement()))\n+                        .findFirst();\n+                \/\/ assume a method may override at most one method in any\n+                \/\/ given class or interface; hence findFirst\n+                assert declaredMethods.stream()\n+                        .filter(candidate -> elementUtils.overrides(overrider, (ExecutableElement) candidate,\n+                                (TypeElement) overrider.getEnclosingElement()))\n+                        .count() <= 1 : diagnosticDescriptionOf(overrider);\n+\n+                if (overridden.isPresent()) {\n+                    next = (ExecutableElement) overridden.get();\n+                    break;\n+                }\n+\n+                \/\/ TODO we're currently ignoring simpleOverride\n+                \/\/  (it's unavailable in this data structure)\n+            }\n+\n+            \/\/ if the stack is empty, there's no unconsumed override:\n+            \/\/ if that ever fails, an iterator's client will be stuck\n+            \/\/ in an infinite loop\n+            assert !searchStack.isEmpty() || next == null\n+                    : diagnosticDescriptionOf(overrider);\n+        }\n+    }\n+\n+    public static String diagnosticDescriptionOf(Element e) {\n+        if (e == null) \/\/ shouldn't NPE if passed null\n+            return \"null\";\n+        return e + \", \" + (e instanceof QualifiedNameable q ? q.getQualifiedName() : e.getSimpleName())\n+                + \", \" + e.getKind() + \", \" + Objects.toIdentityString(e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":125,"deletions":8,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -0,0 +1,665 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6934301\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestDirectedInheritance\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestDirectedInheritance extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestDirectedInheritance().runTests(m -> new Object[]{Path.of(m.getName())});\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    \/*\n+     * Javadoc won't crash if an unknown tag uses {@inheritDoc}.\n+     *\/\n+    @Test\n+    public void testUnknownTag(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public interface I1 {\n+                    \/** @foo bar *\/\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface E1 extends I1 {\n+                    \/** @foo {@inheritDoc} *\/\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface E2 extends I1 {\n+                    \/** @foo {@inheritDoc I1} *\/\n+                    void m();\n+                }\n+                \"\"\");\n+        \/\/ DocLint should neither prevent nor cause a crash. Explicitly check that\n+        \/\/ there's no crash with DocLint on and off, but don't check that the exit\n+        \/\/ code is OK, it likely isn't (after all, there's an unknown tag).\n+        setAutomaticCheckNoStacktrace(true);\n+        { \/\/ DocLint is explicit\n+            int i = 0;\n+            for (var check : new String[]{\":all\", \":none\", \"\"}) {\n+                var outputDir = \"out-DocLint-\" + i++; \/\/ use separate output directories\n+                javadoc(\"-Xdoclint\" + check,\n+                        \"-d\", base.resolve(outputDir).toString(),\n+                        \"--source-path\", src.toString(),\n+                        \"x\");\n+            }\n+        }\n+        \/\/ DocLint is default\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+    }\n+\n+    \/*\n+     * An interface method inherits documentation from that interface's rightmost\n+     * superinterface in the `extends` clause.\n+     *\/\n+    @Test\n+    public void testInterfaceInheritsFromSuperinterface(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public interface I1 {\n+                    \/**\n+                     * I1: main description\n+                     *\n+                     * @param <A> I1: first type parameter\n+                     * @param <B> I1: second type parameter\n+                     *\n+                     * @param bObj I1: parameter\n+                     * @return I1: return\n+                     *\n+                     * @throws B I1: first description of an exception\n+                     * @throws B I1: second description of an exception\n+                     *\/\n+                    <A, B extends RuntimeException> int m(A bObj);\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface I2 {\n+                    \/**\n+                     * I2: main description\n+                     *\n+                     * @param <C> I2: first type parameter\n+                     * @param <D> I2: second type parameter\n+                     *\n+                     * @param cObj I2: parameter\n+                     * @return I2: return\n+                     *\n+                     * @throws D I2: first description of an exception\n+                     * @throws D I2: second description of an exception\n+                     *\/\n+                    <C, D extends RuntimeException> int m(C cObj);\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface E1 extends I1, I2 {\n+                    \/**\n+                     * {@inheritDoc I2}\n+                     *\n+                     * @param <E> {@inheritDoc I2}\n+                     * @param <F> {@inheritDoc I2}\n+                     *\n+                     * @param eObj {@inheritDoc I2}\n+                     * @return {@inheritDoc I2}\n+                     *\n+                     * @throws F {@inheritDoc I2}\n+                     *\/\n+                    <E, F extends RuntimeException> int m(E eObj);\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        new OutputChecker(\"x\/E1.html\").check(\"\"\"\n+                <div class=\"block\">I2: main description<\/div>\n+                \"\"\", \"\"\"\n+                <dt>Type Parameters:<\/dt>\n+                <dd><code>E<\/code> - I2: first type parameter<\/dd>\n+                <dd><code>F<\/code> - I2: second type parameter<\/dd>\n+                <dt>Parameters:<\/dt>\n+                <dd><code>eObj<\/code> - I2: parameter<\/dd>\n+                <dt>Returns:<\/dt>\n+                <dd>I2: return<\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code>F<\/code> - I2: first description of an exception<\/dd>\n+                <dd><code>F<\/code> - I2: second description of an exception<\/dd>\n+                <\/dl>\"\"\");\n+        new OutputChecker(Output.OUT).setExpectFound(false)\n+                .check(\"warning: not a direct supertype\"); \/\/ no unexpected warnings\n+    }\n+\n+    \/*\n+     * An interface method both provides and inherits the main description and\n+     * the exception documentation from all its superinterfaces.\n+     *\n+     * Note: the same does not work for @param and @return as these are one-to-one.\n+     *\/\n+    @Test\n+    public void testInterfaceInheritsFromAllSuperinterfaces(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public interface I1 {\n+                    \/**\n+                     * I1: main description\n+                     *\n+                     * @throws B I1: first description of an exception\n+                     * @throws B I1: second description of an exception\n+                     *\/\n+                    <A, B extends RuntimeException> int m(A bObj);\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface I2 {\n+                    \/**\n+                     * I2: main description\n+                     *\n+                     * @throws D I2: first description of an exception\n+                     * @throws D I2: second description of an exception\n+                     *\/\n+                    <C, D extends RuntimeException> int m(C cObj);\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface E1 extends I1, I2 {\n+                    \/**\n+                     * E1: main description\n+                     * {@inheritDoc I2}\n+                     * {@inheritDoc I1}\n+                     *\n+                     * @throws F E1: description of an exception\n+                     * @throws F {@inheritDoc I2}\n+                     * @throws F {@inheritDoc I1}\n+                     *\/\n+                    <E, F extends RuntimeException> int m(E eObj);\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        new OutputChecker(\"x\/E1.html\").check(\"\"\"\n+                <div class=\"block\">E1: main description\n+                 I2: main description\n+                 I1: main description<\/div>\"\"\", \"\"\"\n+                <dt>Throws:<\/dt>\n+                <dd><code>F<\/code> - E1: description of an exception<\/dd>\n+                <dd><code>F<\/code> - I2: first description of an exception<\/dd>\n+                <dd><code>F<\/code> - I2: second description of an exception<\/dd>\n+                <dd><code>F<\/code> - I1: first description of an exception<\/dd>\n+                <dd><code>F<\/code> - I1: second description of an exception<\/dd>\n+                <\/dl>\"\"\");\n+        new OutputChecker(Output.OUT).setExpectFound(false)\n+                .check(\"warning: not a direct supertype\"); \/\/ no unexpected warnings\n+    }\n+\n+    \/*\n+     * C1.m directedly inherits documentation from B1, which inherits A.m\n+     * along with its documentation.\n+     *\n+     * C2.m directedly inherits documentation from B2, whose m overrides A.m\n+     * and implicitly inherits its documentation.\n+     *\/\n+    @Test\n+    public void testRecursiveInheritance1(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public class A {\n+                    \/** A.m() *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class B1 extends A { }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class C1 extends B1 {\n+                    \/** {@inheritDoc B1} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class B2 extends A {\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class C2 extends B2 {\n+                    \/** {@inheritDoc B2} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        var m = \"\"\"\n+                <section class=\"detail\" id=\"m()\">\n+                <h3>m<\/h3>\n+                <div class=\"member-signature\"><span class=\"modifiers\">\\\n+                public<\/span>&nbsp;<span class=\"return-type\">void<\/span>\\\n+                &nbsp;<span class=\"element-name\">m<\/span>()<\/div>\n+                <div class=\"block\">A.m()<\/div>\"\"\";\n+        new OutputChecker(\"x\/C1.html\").check(m);\n+        new OutputChecker(\"x\/C2.html\").check(m);\n+        new OutputChecker(Output.OUT).setExpectFound(false)\n+                .check(\"warning: not a direct supertype\"); \/\/ no unexpected warnings\n+    }\n+\n+    \/*\n+     * C1.m directedly inherits documentation from B1, which in turn inherits\n+     * it undirectedly from A.\n+     *\n+     * C2.m directedly inherits documentation from B2, which in turn inherits\n+     * in directedly from A.\n+     *\/\n+    @Test\n+    public void testRecursiveInheritance2(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public class A {\n+                    \/** A.m() *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class B1 extends A {\n+                    \/** {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class C1 extends B1 {\n+                    \/** {@inheritDoc B1} *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class B2 extends A {\n+                    \/** {@inheritDoc A} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class C2 extends B2 {\n+                    \/** {@inheritDoc B2} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        var m = \"\"\"\n+                <section class=\"detail\" id=\"m()\">\n+                <h3>m<\/h3>\n+                <div class=\"member-signature\"><span class=\"modifiers\">\\\n+                public<\/span>&nbsp;<span class=\"return-type\">void<\/span>\\\n+                &nbsp;<span class=\"element-name\">m<\/span>()<\/div>\n+                <div class=\"block\">A.m()<\/div>\"\"\";\n+        new OutputChecker(\"x\/C1.html\").check(m);\n+        new OutputChecker(\"x\/C2.html\").check(m);\n+        new OutputChecker(Output.OUT).setExpectFound(false)\n+                .check(\"warning: not a direct supertype\"); \/\/ no unexpected warnings\n+    }\n+\n+    \/*\n+     * Currently, there's no special error for a documentation comment that inherits\n+     * from itself. Instead, such a comment is seen as a general case of a comment\n+     * that inherits from a documentation of a method which that comment's method\n+     * does not override (JLS says that a method does not override itself).\n+     *\n+     * TODO: DocLint might not always be able to find another type, but it\n+     *  should always be capable of detecting the same type; we could\n+     *  consider implementing this check _also_ in DocLint\n+     *\/\n+    @Test\n+    public void testSelfInheritance(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public class A {\n+                    \/** {@inheritDoc A} *\/\n+                    public Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class B {\n+                    \/** @param i {@inheritDoc B} *\/\n+                    public Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class C {\n+                    \/** @param <T> {@inheritDoc C} *\/\n+                    public <T> Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class D {\n+                    \/** @return {@inheritDoc D} *\/\n+                    public Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class E {\n+                    \/** @throws NullPointerException {@inheritDoc E} *\/\n+                    public Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class F {\n+                    \/** @throws T NullPointerException {@inheritDoc F} *\/\n+                    public <T extends RuntimeException> Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\");\n+        javadoc(\"-Xdoclint:none\", \/\/ turn off DocLint\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.ERROR);\n+        new OutputChecker(Output.OUT).setExpectOrdered(false).check(\"\"\"\n+                A.java:3: error: cannot find the overridden method\n+                    \/** {@inheritDoc A} *\/\n+                        ^\"\"\", \"\"\"\n+                B.java:3: error: cannot find the overridden method\n+                    \/** @param i {@inheritDoc B} *\/\n+                                 ^\"\"\", \"\"\"\n+                C.java:3: error: cannot find the overridden method\n+                    \/** @param <T> {@inheritDoc C} *\/\n+                                   ^\"\"\", \"\"\"\n+                D.java:3: error: cannot find the overridden method\n+                    \/** @return {@inheritDoc D} *\/\n+                                ^\"\"\", \"\"\"\n+                E.java:3: error: cannot find the overridden method\n+                    \/** @throws NullPointerException {@inheritDoc E} *\/\n+                                                     ^\"\"\", \"\"\"\n+                F.java:3: error: cannot find the overridden method\n+                    \/** @throws T NullPointerException {@inheritDoc F} *\/\n+                                                       ^\"\"\");\n+        new OutputChecker(Output.OUT).setExpectFound(false)\n+                .check(\"warning: not a direct supertype\"); \/\/ no unexpected warnings\n+    }\n+\n+    \/*\n+     * While E1.m and I.m have override-equivalent signatures, E1 does not extend I.\n+     * While E2 extends I, E2.m1 does not override I.m. In either case, there's no\n+     * (overridden) method to inherit documentation from.\n+     *\/\n+    @Test\n+    public void testInvalidSupertype1(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public interface I {\n+                    \/**\n+                     * I: main description\n+                     *\n+                     * @param <A> I: first type parameter\n+                     * @param <B> I: second type parameter\n+                     *\n+                     * @param bObj I: parameter\n+                     * @return I: return\n+                     *\n+                     * @throws B I: first description of an exception\n+                     * @throws B I: second description of an exception\n+                     *\/\n+                    <A, B extends RuntimeException> int m(A bObj);\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface E1 {\n+                    \/**\n+                     * {@inheritDoc I}\n+                     *\n+                     * @param <C> {@inheritDoc I}\n+                     * @param <D> {@inheritDoc I}\n+                     *\n+                     * @param cObj {@inheritDoc I}\n+                     * @return {@inheritDoc I}\n+                     *\n+                     * @throws D {@inheritDoc I}\n+                     *\/\n+                    <C, D extends RuntimeException> int m(C cObj);\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface E2 extends I {\n+                    \/**\n+                     * {@inheritDoc I}\n+                     *\n+                     * @param <E> {@inheritDoc I}\n+                     * @param <F> {@inheritDoc I}\n+                     *\n+                     * @param eObj {@inheritDoc I}\n+                     * @return {@inheritDoc I}\n+                     *\n+                     * @throws F {@inheritDoc I}\n+                     *\/\n+                    <E, F extends RuntimeException> int m1(E eObj);\n+                }\n+                \"\"\");\n+        javadoc(\"-Xdoclint:none\", \/\/ turn off DocLint\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.ERROR);\n+        new OutputChecker(Output.OUT).setExpectOrdered(false).check(\"\"\"\n+                E1.java:4: error: cannot find the overridden method\n+                     * {@inheritDoc I}\n+                       ^\"\"\", \"\"\"\n+                E1.java:6: error: cannot find the overridden method\n+                     * @param <C> {@inheritDoc I}\n+                                  ^\"\"\", \"\"\"\n+                E1.java:7: error: cannot find the overridden method\n+                     * @param <D> {@inheritDoc I}\n+                                  ^\"\"\", \"\"\"\n+                E1.java:9: error: cannot find the overridden method\n+                     * @param cObj {@inheritDoc I}\n+                                   ^\"\"\", \"\"\"\n+                E1.java:10: error: cannot find the overridden method\n+                     * @return {@inheritDoc I}\n+                               ^\"\"\", \"\"\"\n+                E1.java:12: error: cannot find the overridden method\n+                     * @throws D {@inheritDoc I}\n+                                 ^\"\"\");\n+        new OutputChecker(Output.OUT).setExpectOrdered(false).check(\"\"\"\n+                E2.java:4: error: cannot find the overridden method\n+                     * {@inheritDoc I}\n+                       ^\"\"\", \"\"\"\n+                E2.java:6: error: cannot find the overridden method\n+                     * @param <E> {@inheritDoc I}\n+                                  ^\"\"\", \"\"\"\n+                E2.java:7: error: cannot find the overridden method\n+                     * @param <F> {@inheritDoc I}\n+                                  ^\"\"\", \"\"\"\n+                E2.java:9: error: cannot find the overridden method\n+                     * @param eObj {@inheritDoc I}\n+                                   ^\"\"\", \"\"\"\n+                E2.java:10: error: cannot find the overridden method\n+                     * @return {@inheritDoc I}\n+                               ^\"\"\", \"\"\"\n+                E2.java:12: error: cannot find the overridden method\n+                     * @throws F {@inheritDoc I}\n+                                 ^\"\"\");\n+        new OutputChecker(Output.OUT).setExpectFound(false)\n+                .check(\"warning: not a direct supertype\"); \/\/ no unexpected warnings\n+    }\n+\n+    \/*\n+     * Cannot inherit documentation from a subtype.\n+     *\/\n+    @Test\n+    public void testInvalidSupertype2(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public interface E extends I {\n+                    \/**\n+                     * E: main description\n+                     *\n+                     * @param <A> E: first type parameter\n+                     * @param <B> E: second type parameter\n+                     *\n+                     * @param aObj E: parameter\n+                     * @return E: return\n+                     *\n+                     * @throws B E: first description of an exception\n+                     * @throws B E: second description of an exception\n+                     *\/\n+                    <A, B extends RuntimeException> int m(A aObj);\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface I {\n+                    \/**\n+                     * {@inheritDoc E}\n+                     *\n+                     * @param <C> {@inheritDoc E}\n+                     * @param <D> {@inheritDoc E}\n+                     *\n+                     * @param cObj {@inheritDoc E}\n+                     * @return {@inheritDoc E}\n+                     *\n+                     * @throws D {@inheritDoc E}\n+                     *\/\n+                    <C, D extends RuntimeException> int m(C cObj);\n+                }\n+                \"\"\");\n+        javadoc(\"-Xdoclint:none\", \/\/ turn off DocLint\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.ERROR);\n+        new OutputChecker(Output.OUT).setExpectOrdered(false).check(\"\"\"\n+                I.java:4: error: cannot find the overridden method\n+                     * {@inheritDoc E}\n+                       ^\"\"\", \"\"\"\n+                I.java:6: error: cannot find the overridden method\n+                     * @param <C> {@inheritDoc E}\n+                                  ^\"\"\", \"\"\"\n+                I.java:7: error: cannot find the overridden method\n+                     * @param <D> {@inheritDoc E}\n+                                  ^\"\"\", \"\"\"\n+                I.java:9: error: cannot find the overridden method\n+                     * @param cObj {@inheritDoc E}\n+                                   ^\"\"\", \"\"\"\n+                I.java:10: error: cannot find the overridden method\n+                     * @return {@inheritDoc E}\n+                               ^\"\"\", \"\"\"\n+                I.java:12: error: cannot find the overridden method\n+                     * @throws D {@inheritDoc E}\n+                                 ^\"\"\");\n+    }\n+\n+    @Test\n+    public void testUnknownSupertype(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+                public class A {\n+                    \/** {@inheritDoc MySuperType} *\/\n+                    public Integer m(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class B {\n+                    \/** @param i {@inheritDoc MySuperType} *\/\n+                    public Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class C {\n+                    \/** @param <T> {@inheritDoc MySuperType} *\/\n+                    public <T> Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class D {\n+                    \/** @return {@inheritDoc MySuperType} *\/\n+                    public Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class E {\n+                    \/** @throws NullPointerException {@inheritDoc MySuperType} *\/\n+                    public Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class F {\n+                    \/** @throws T NullPointerException {@inheritDoc MySuperType} *\/\n+                    public <T extends RuntimeException> Integer minus(Integer i) { return -i; }\n+                }\n+                \"\"\");\n+        javadoc(\"-Xdoclint:none\", \/\/ turn off DocLint\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.ERROR);\n+        new OutputChecker(Output.OUT).setExpectOrdered(false).check(\"\"\"\n+                A.java:3: error: cannot find the overridden method\n+                    \/** {@inheritDoc MySuperType} *\/\n+                        ^\"\"\", \"\"\"\n+                B.java:3: error: cannot find the overridden method\n+                    \/** @param i {@inheritDoc MySuperType} *\/\n+                                 ^\"\"\", \"\"\"\n+                C.java:3: error: cannot find the overridden method\n+                    \/** @param <T> {@inheritDoc MySuperType} *\/\n+                                   ^\"\"\", \"\"\"\n+                D.java:3: error: cannot find the overridden method\n+                    \/** @return {@inheritDoc MySuperType} *\/\n+                                ^\"\"\", \"\"\"\n+                E.java:3: error: cannot find the overridden method\n+                    \/** @throws NullPointerException {@inheritDoc MySuperType} *\/\n+                                                     ^\"\"\", \"\"\"\n+                F.java:3: error: cannot find the overridden method\n+                    \/** @throws T NullPointerException {@inheritDoc MySuperType} *\/\n+                                                       ^\"\"\");\n+        new OutputChecker(Output.OUT).setExpectFound(false)\n+                .check(\"warning: not a direct supertype\"); \/\/ no unexpected warnings\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDirectedInheritance\/TestDirectedInheritance.java","additions":665,"deletions":0,"binary":false,"changes":665,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284299 8287379 8298525\n+ * @bug 8284299 8287379 8298525 6934301\n@@ -75,0 +75,17 @@\n+                        \"\"\",\n+                \"\"\"\n+                        public class C extends A {\n+                            \/**\n+                             * {@summary {@inheritDoc A}}\n+                             *\n+                             * {@link Object#hashCode() {@inheritDoc A}}\n+                             * {@linkplain Object#hashCode() {@inheritDoc A}}\n+                             *\n+                             * {@index term {@inheritDoc A}}\n+                             *\n+                             * @see A {@inheritDoc A}\n+                             * @spec http:\/\/example.com {@inheritDoc A}\n+                             *\/\n+                            @Override\n+                            public void x() { }\n+                        }\n@@ -79,1 +96,2 @@\n-                src.resolve(\"B.java\").toString());\n+                src.resolve(\"B.java\").toString(),\n+                src.resolve(\"C.java\").toString());\n@@ -111,0 +129,29 @@\n+                        \"\"\",\n+                \"\"\"\n+                        warning: @inheritDoc cannot be used within this tag\n+                             * {@summary {@inheritDoc A}}\n+                               ^\n+                        \"\"\",\n+                \"\"\"\n+                        warning: @inheritDoc cannot be used within this tag\n+                             * {@link Object#hashCode() {@inheritDoc A}}\n+                               ^\n+                        \"\"\",\n+                \"\"\"\n+                        warning: @inheritDoc cannot be used within this tag\n+                             * {@linkplain Object#hashCode() {@inheritDoc A}}\n+                               ^\n+                        \"\"\",\n+                \"\"\"\n+                        warning: @inheritDoc cannot be used within this tag\n+                             * {@index term {@inheritDoc A}}\n+                               ^\n+                        \"\"\", \"\"\"\n+                        warning: @inheritDoc cannot be used within this tag\n+                             * @see A {@inheritDoc A}\n+                               ^\n+                        \"\"\",\n+                \"\"\"\n+                        warning: @inheritDoc cannot be used within this tag\n+                             * @spec http:\/\/example.com {@inheritDoc A}\n+                               ^\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInheritDocWithinInappropriateTag\/TestInheritDocWithinInappropriateTag.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,459 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8285368\n+ * @library \/tools\/lib ..\/..\/lib \/test\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @build jtreg.SkippedException\n+ * @run main TestMethodCommentsAlgorithm\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.type.TypeKind;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import javadoc.tester.JavadocTester;\n+import jtreg.SkippedException;\n+import toolbox.ToolBox;\n+\n+\/*\n+ * These tests assert search order for _undirected_ documentation inheritance by\n+ * following a series of javadoc runs on a progressively undocumented hierarchy\n+ * of supertypes.\n+ *\n+ * Design\n+ * ======\n+ *\n+ * Each test creates a hierarchy consisting of N types (T1, T2, ..., Tn) for\n+ * which the search order is to be asserted. N-1 types are created (T1, T2,\n+ * ..., T(n-1)) and one type, Tn, is implicitly present java.lang.Object.\n+ * T1 is a type under test; T2, T3, ..., T(n-1) are direct or indirect\n+ * supertypes of T1.\n+ *\n+ * By design, the index of a type is evocative of the order in which that type\n+ * should be considered for documentation inheritance. If T1 lacks a doc\n+ * comment, T2 should be considered next. If in turn T2 lacks a doc comment,\n+ * T3 should be considered after that, and so on. Finally, Tn, which is\n+ * java.lang.Object, whose documentation is ever-present, is considered.\n+ *\n+ * The test then runs javadoc N-1 times. Each run one fewer type has a doc\n+ * comment: for the i-th run (1 <= i < N), type Tj has a doc comment if and\n+ * only if j > i. So, for the i-th run, i comments are missing and N-i are\n+ * present. In particular, for the first run (i = 1) the only _missing_ doc\n+ * comment is that of T1 and for the last run (i = N-1) the only _available_\n+ * doc comment is that of java.lang.Object.\n+ *\n+ * The test challenges javadoc by asking the following question:\n+ *\n+ *     Whose documentation will T1 inherit if Tj (1 <= j <= i)\n+ *     do not have doc comments, but Tk (i < k <= N) do?\n+ *\n+ * For the i-th run the test checks that T1 inherits documentation of T(i+1).\n+ *\n+ * Technicalities\n+ * ==============\n+ *\n+ * 1. To follow search order up to and including java.lang.Object, these tests\n+ *    need to be able to inherit documentation for java.lang.Object. For that,\n+ *    the tests access doc comments of java.lang.Object. To get such access,\n+ *    the tests patch the java.base module.\n+ *\n+ * 2. The documentation for java.lang.Object is slightly amended for\n+ *    uniformity with test documentation and for additional test\n+ *    coverage.\n+ *\n+ * 3. While documentation for java.lang.Object is currently inaccessible outside\n+ *    of the JDK, these test mimic what happens when the JDK documentation is\n+ *    built.\n+ *\/\n+public class TestMethodCommentsAlgorithm extends JavadocTester {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    public static void main(String... args) throws Exception {\n+        new TestMethodCommentsAlgorithm().runTests();\n+    }\n+\n+    \/*\n+     * Tests that the documentation search order is as shown:\n+     *\n+     *               (5)\n+     *                ^\n+     *      *        \/\n+     *     [7] (3) (4)\n+     *      ^   ^   ^\n+     *       \\  |  \/\n+     *        \\ | \/\n+     *         [2] (6)\n+     *          ^   ^\n+     *          |  \/\n+     *          | \/\n+     *         [1]\n+     *\/\n+    @Test\n+    public void testMixedHierarchyEquals(Path base) throws Exception {\n+        Path p = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n+        while (!Files.exists(p.resolve(\"TEST.ROOT\"))) {\n+            p = p.getParent();\n+            if (p == null) {\n+                throw new SkippedException(\"can't find TEST.ROOT\");\n+            }\n+        }\n+        out.println(\"Test suite root: \" + p);\n+        Path javaBase = p.resolve(\"..\/..\/src\/java.base\").normalize();\n+        if (!Files.exists(javaBase)) {\n+            throw new SkippedException(\"can't find java.base\");\n+        }\n+        out.println(\"java.base: \" + javaBase);\n+\n+        for (int i = 1; i < 7; i++) {\n+            mixedHierarchyI(base, javaBase, i);\n+            new OutputChecker(\"mymodule\/x\/T1.html\").check(\"\"\"\n+                    <div class=\"block\">T%s: main description<\/div>\n+                    \"\"\".formatted(i + 1), \"\"\"\n+                    <dt>Parameters:<\/dt>\n+                    <dd><code>obj<\/code> - T%1$s: parameter description<\/dd>\n+                    <dt>Returns:<\/dt>\n+                    <dd>T%1$s: return description<\/dd>\"\"\".formatted(i + 1));\n+        }\n+    }\n+\n+    \/*\n+     * Generates source for the i-th run such that types whose index is less\n+     * than i provide no documentation and those whose index is greater or\n+     * equal to i provide documentation.\n+     *\/\n+    private void mixedHierarchyI(Path base, Path javaBase, int i) throws IOException {\n+        Path src = base.resolve(\"src-\" + i);\n+        Path mod = base.resolve(\"src-\" + i).resolve(\"mymodule\");\n+        tb.writeJavaFiles(mod, \"\"\"\n+                package x;\n+                public class T1 extends T2 implements T6 {\n+                %s\n+                    @Override public boolean equals(Object obj) { return super.equals(obj); }\n+                }\n+                \"\"\".formatted(generateDocComment(1, i)), \"\"\"\n+                package x;\n+                public class T2 \/* extends Object *\/ implements T3, T4 {\n+                %s\n+                    @Override public boolean equals(Object obj) { return super.equals(obj); }\n+                }\n+                \"\"\".formatted(generateDocComment(2, i)), \"\"\"\n+                package x;\n+                public interface T3 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(3, i)), \"\"\"\n+                package x;\n+                public interface T4 extends T5 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(4, i)), \"\"\"\n+                package x;\n+                public interface T5 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(5, i)), \"\"\"\n+                package x;\n+                public interface T6 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(6, i)), \"\"\"\n+                module mymodule { }\n+                \"\"\");\n+\n+        createPatchedJavaLangObject(javaBase.resolve(\"share\").resolve(\"classes\").toAbsolutePath(),\n+                Files.createDirectories(src.resolve(\"java.base\")).toAbsolutePath(),\n+                generateDocComment(7, i, false));\n+\n+        javadoc(\"-d\", base.resolve(\"out-\" + i).toAbsolutePath().toString(),\n+                \"-tag\", \"apiNote:a:API Note:\",\n+                \"-tag\", \"implSpec:a:Implementation Requirements:\",\n+                \"-tag\", \"implNote:a:Implementation Note:\",\n+                \"--patch-module\", \"java.base=\" + src.resolve(\"java.base\").toAbsolutePath().toString(),\n+                \"--module-source-path\", src.toAbsolutePath().toString(),\n+                \"mymodule\/x\");\n+\n+        checkExit(Exit.OK);\n+    }\n+\n+    private static String generateDocComment(int index, int run) {\n+        return generateDocComment(index, run, true);\n+    }\n+\n+    \/*\n+     * Provides a doc comment for an override of Object.equals in a type with\n+     * the specified index for the specified run.\n+     *\/\n+    private static String generateDocComment(int index, int run, boolean includeCommentMarkers) {\n+        if (index > run) {\n+            String s = \"\"\"\n+                    T%s: main description\n+                    *\n+                    * @param obj T%1$s: parameter description\n+                    * @return T%1$s: return description\"\"\";\n+            if (includeCommentMarkers)\n+                s = \"\/**\\n* \" + s + \"\\n*\/\";\n+            return s.formatted(index).indent(4);\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    \/*\n+     * Tests that the documentation search order is as shown:\n+     *\n+     *    (3) (4)\n+     *     ^   ^\n+     *      \\ \/\n+     *      (2) (5)\n+     *       ^   ^\n+     *        \\ \/\n+     *        (1)\n+     *         |\n+     *         v\n+     *        [6]\n+     *         *\n+     *\/\n+    @Test\n+    public void testInterfaceHierarchy(Path base) throws Exception {\n+        Path p = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n+        while (!Files.exists(p.resolve(\"TEST.ROOT\"))) {\n+            p = p.getParent();\n+            if (p == null) {\n+                throw new SkippedException(\"can't find TEST.ROOT\");\n+            }\n+        }\n+        System.err.println(\"Test suite root: \" + p);\n+        Path javaBase = p.resolve(\"..\/..\/src\/java.base\").normalize();\n+        if (!Files.exists(javaBase)) {\n+            throw new SkippedException(\"can't find java.base\");\n+        }\n+        System.err.println(\"java.base: \" + javaBase);\n+\n+        for (int i = 1; i < 6; i++) {\n+            interfaceHierarchyI(base, javaBase, i);\n+            new OutputChecker(\"mymodule\/x\/T1.html\").check(\"\"\"\n+                    <div class=\"block\">T%s: main description<\/div>\n+                    \"\"\".formatted(i + 1), \"\"\"\n+                    <dt>Parameters:<\/dt>\n+                    <dd><code>obj<\/code> - T%1$s: parameter description<\/dd>\n+                    <dt>Returns:<\/dt>\n+                    <dd>T%1$s: return description<\/dd>\"\"\".formatted(i + 1));\n+        }\n+    }\n+\n+    \/*\n+     * Generates source for the i-th run such that types whose index is less\n+     * than i provide no documentation and those whose index is greater or\n+     * equal to i provide documentation.\n+     *\/\n+    private void interfaceHierarchyI(Path base, Path javaBase, int i) throws IOException {\n+        Path src = base.resolve(\"src-\" + i);\n+        Path mod = base.resolve(\"src-\" + i).resolve(\"mymodule\");\n+        tb.writeJavaFiles(mod, \"\"\"\n+                package x;\n+                public interface T1 extends T2, T5 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(1, i)), \"\"\"\n+                package x;\n+                public interface T2 extends T3, T4 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(2, i)), \"\"\"\n+                package x;\n+                public interface T3 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(3, i)), \"\"\"\n+                package x;\n+                public interface T4 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(4, i)), \"\"\"\n+                package x;\n+                public interface T5 {\n+                %s\n+                    @Override boolean equals(Object obj);\n+                }\n+                \"\"\".formatted(generateDocComment(5, i)), \"\"\"\n+                module mymodule { }\n+                \"\"\");\n+\n+        createPatchedJavaLangObject(javaBase.resolve(\"share\").resolve(\"classes\").toAbsolutePath(),\n+                Files.createDirectories(src.resolve(\"java.base\")).toAbsolutePath(),\n+                generateDocComment(6, i, false));\n+\n+        javadoc(\"-d\", base.resolve(\"out-\" + i).toAbsolutePath().toString(),\n+                \"-tag\", \"apiNote:a:API Note:\",\n+                \"-tag\", \"implSpec:a:Implementation Requirements:\",\n+                \"-tag\", \"implNote:a:Implementation Note:\",\n+                \"--patch-module\", \"java.base=\" + src.resolve(\"java.base\").toAbsolutePath().toString(),\n+                \"--module-source-path\", src.toAbsolutePath().toString(),\n+                \"mymodule\/x\");\n+\n+        checkExit(Exit.OK);\n+    }\n+\n+    \/*\n+     * Takes a path to the java.base module, finds the Object.java file in\n+     * there, creates a copy of that file _with the modified doc comment_\n+     * for Object.equals in the provided destination directory and returns\n+     * the path to that created copy.\n+     *\/\n+    private Path createPatchedJavaLangObject(Path src, Path dst, String newComment)\n+            throws IOException {\n+        if (!Files.isDirectory(src) || !Files.isDirectory(dst)) {\n+            throw new IllegalArgumentException();\n+        }\n+        var obj = Path.of(\"java\/lang\/Object.java\");\n+        List<Path> files;\n+        \/\/ ensure Object.java is found and unique\n+        try (var s = Files.find(src, Integer.MAX_VALUE,\n+                (p, attr) -> attr.isRegularFile() && p.endsWith(obj))) {\n+            files = s.limit(2).toList(); \/\/ 2 is enough to deduce non-uniqueness\n+        }\n+        if (files.size() != 1) {\n+            throw new IllegalStateException(Arrays.toString(files.toArray()));\n+        }\n+        var original = files.get(0);\n+        out.println(\"found \" + original.toAbsolutePath());\n+        var source = Files.readString(original);\n+        var region = findDocCommentRegion(original);\n+        var newSource = source.substring(0, region.start)\n+                + newComment\n+                + source.substring(region.end);\n+        \/\/ create intermediate directories in the destination first, otherwise\n+        \/\/ writeString will throw java.nio.file.NoSuchFileException\n+        var copy = dst.resolve(src.relativize(original));\n+        out.println(\"to be copied to \" + copy);\n+        if (Files.notExists(copy.getParent())) {\n+            Files.createDirectories(copy.getParent());\n+        }\n+        return Files.writeString(copy, newSource, StandardOpenOption.CREATE);\n+    }\n+\n+    private static SourceRegion findDocCommentRegion(Path src) throws IOException {\n+        \/\/ to _reliably_ find the doc comment, parse the file and find source\n+        \/\/ position of the doc tree corresponding to that comment\n+        var compiler = ToolProvider.getSystemJavaCompiler();\n+        var fileManager = compiler.getStandardFileManager(null, null, null);\n+        var fileObject = fileManager.getJavaFileObjects(src).iterator().next();\n+        var task = (JavacTask) compiler.getTask(null, null, null, null, null, List.of(fileObject));\n+        Iterator<? extends CompilationUnitTree> iterator = task.parse().iterator();\n+        if (!iterator.hasNext()) {\n+            throw new AssertionError();\n+        }\n+        var tree = iterator.next();\n+        var pathToEqualsMethod = findMethod(tree);\n+        var trees = DocTrees.instance(task);\n+        DocCommentTree docCommentTree = trees.getDocCommentTree(pathToEqualsMethod);\n+        if (docCommentTree == null)\n+            throw new AssertionError(\"cannot find the doc comment for java.lang.Object#equals\");\n+        var positions = trees.getSourcePositions();\n+        long start = positions.getStartPosition(null, docCommentTree, docCommentTree);\n+        long end = positions.getEndPosition(null, docCommentTree, docCommentTree);\n+        return new SourceRegion((int) start, (int) end);\n+    }\n+\n+    private static TreePath findMethod(Tree src) {\n+\n+        class Result extends RuntimeException {\n+            final TreePath p;\n+\n+            Result(TreePath p) {\n+                super(\"\", null, false, false); \/\/ lightweight exception to short-circuit scan\n+                this.p = p;\n+            }\n+        }\n+\n+        var scanner = new TreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitMethod(MethodTree m, Void unused) {\n+                boolean solelyPublic = m.getModifiers().getFlags().equals(Set.of(Modifier.PUBLIC));\n+                if (!solelyPublic) {\n+                    return null;\n+                }\n+                var returnType = m.getReturnType();\n+                boolean returnsBoolean = returnType != null\n+                        && returnType.getKind() == Tree.Kind.PRIMITIVE_TYPE\n+                        && ((PrimitiveTypeTree) returnType).getPrimitiveTypeKind() == TypeKind.BOOLEAN;\n+                if (!returnsBoolean) {\n+                    return null;\n+                }\n+                boolean hasNameEquals = m.getName().toString().equals(\"equals\");\n+                if (!hasNameEquals) {\n+                    return null;\n+                }\n+                List<? extends VariableTree> params = m.getParameters();\n+                if (params.size() != 1)\n+                    return null;\n+                var parameterType = params.get(0).getType();\n+                if (parameterType.getKind() == Tree.Kind.IDENTIFIER &&\n+                        ((IdentifierTree) parameterType).getName().toString().equals(\"Object\")) {\n+                    throw new Result(getCurrentPath());\n+                }\n+                return null;\n+            }\n+        };\n+        try {\n+            scanner.scan(src, null);\n+            return null; \/\/ not found\n+        } catch (Result e) {\n+            return e.p; \/\/ found\n+        }\n+    }\n+\n+    record SourceRegion(int start, int end) { }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMethodCommentAlgorithm\/TestMethodCommentsAlgorithm.java","additions":459,"deletions":0,"binary":false,"changes":459,"status":"added"},{"patch":"@@ -498,1 +498,6 @@\n-                header(node, \"\");\n+                header(node);\n+                indent(+1);\n+                print(\"supertype\", node.getSupertype());\n+                indent(-1);\n+                indent();\n+                out.println(\"]\");\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8273244\n+ * @bug 7021614 8273244 6934301\n@@ -43,1 +43,3 @@\n-    InheritDoc[INHERIT_DOC, pos:4]\n+    InheritDoc[INHERIT_DOC, pos:4\n+      supertype: null\n+    ]\n@@ -55,1 +57,3 @@\n-    InheritDoc[INHERIT_DOC, pos:4]\n+    InheritDoc[INHERIT_DOC, pos:4\n+      supertype: null\n+    ]\n@@ -67,1 +71,33 @@\n-    InheritDoc[INHERIT_DOC, pos:4]\n+    InheritDoc[INHERIT_DOC, pos:4\n+      supertype: null\n+    ]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/** abc {@inheritDoc String} *\/\n+    void simple() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 2\n+    Text[TEXT, pos:0, abc_]\n+    InheritDoc[INHERIT_DOC, pos:4\n+      supertype:\n+        Reference[REFERENCE, pos:17, String]\n+    ]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/** abc {@inheritDoc java.util.List<E>} *\/\n+    void fullyQualifiedTypeWithWildCardUpperBound() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 2\n+    Text[TEXT, pos:0, abc_]\n+    InheritDoc[INHERIT_DOC, pos:4\n+      supertype:\n+        Reference[REFERENCE, pos:17, java.util.List<E>]\n+    ]\n@@ -73,2 +109,2 @@\n-    \/** abc {@inheritDoc junk} *\/\n-    void error() { }\n+    \/** abc {@inheritDoc Integer   Number} *\/\n+    void unexpectedContentAfterReference() { }\n@@ -79,1 +115,1 @@\n-    Erroneous[ERRONEOUS, pos:4, prefPos:17\n+    Erroneous[ERRONEOUS, pos:4, prefPos:27\n@@ -81,1 +117,1 @@\n-      body: {@inheritDoc_junk}\n+      body: {@inheritDoc_Integer___Number}\n","filename":"test\/langtools\/tools\/javac\/doctree\/InheritDocTest.java","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"}]}