{"files":[{"patch":"@@ -45,1 +45,1 @@\n-     * @since 21\n+     * @since 22\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/InheritDocTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-     * @since 21\n+     * @since 22\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+import static javadoc.tester.JavadocTester.Exit.OK;\n+\n@@ -223,1 +225,1 @@\n-        checkExit(Exit.OK);\n+        checkExit(OK);\n@@ -292,0 +294,69 @@\n+    \/*\n+     * Nested\/recursive `{@inheritDoc}` are processed before the comments that\n+     * refer to them. This test highlights that a lone `{@inheritDoc}` is\n+     * different from a missing\/empty comment part.\n+     *\n+     * Whenever doclet sees `{@inheritDoc}` or `{@inheritDoc <supertype>}`\n+     * while searching for a comment to inherit from up the hierarchy, it\n+     * considers the comment found. A separate and unrelated search is\n+     * then performed for that found `{@inheritDoc}`.\n+     *\n+     * The test case is wrapped in a module in order to be able to patch\n+     * java.base (otherwise it doesn't seem to work).\n+     *\/\n+    @Test\n+    public void testRecursiveInheritDocTagsAreProcessedFirst(Path base) throws Exception {\n+        Path p = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n+        while (!Files.exists(p.resolve(\"TEST.ROOT\"))) {\n+            p = p.getParent();\n+            if (p == null) {\n+                throw new SkippedException(\"can't find TEST.ROOT\");\n+            }\n+        }\n+        System.err.println(\"Test suite root: \" + p);\n+        Path javaBase = p.resolve(\"..\/..\/src\/java.base\").normalize();\n+        if (!Files.exists(javaBase)) {\n+            throw new SkippedException(\"can't find java.base\");\n+        }\n+        System.err.println(\"java.base: \" + javaBase);\n+\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src.resolve(\"mymodule\"), \"\"\"\n+                package x;\n+                public class S {\n+                    \/** {@inheritDoc} *\/\n+                    public boolean equals(Object obj) { return super.equals(obj); }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public interface I {\n+                    \/** I::equals *\/\n+                    boolean equals(Object obj);\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+                public class T extends S implements I {\n+                    public boolean equals(Object obj) { return super.equals(obj); }\n+                }\n+                \"\"\", \"\"\"\n+                module mymodule {}\n+                \"\"\");\n+\n+        createPatchedJavaLangObject(javaBase.resolve(\"share\").resolve(\"classes\").toAbsolutePath(),\n+                Files.createDirectories(src.resolve(\"java.base\")).toAbsolutePath(),\n+                \"Object::equals\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-tag\", \"apiNote:a:API Note:\",\n+                \"-tag\", \"implSpec:a:Implementation Requirements:\",\n+                \"-tag\", \"implNote:a:Implementation Note:\",\n+                \"--patch-module\", \"java.base=\" + src.resolve(\"java.base\").toAbsolutePath().toString(),\n+                \"--module-source-path\", src.toAbsolutePath().toString(),\n+                \"mymodule\/x\");\n+\n+        checkExit(Exit.OK);\n+\n+        new OutputChecker(\"mymodule\/x\/T.html\").check(\"\"\"\n+                <div class=\"block\">Object::equals<\/div>\"\"\");\n+    }\n+\n@@ -346,1 +417,1 @@\n-        checkExit(Exit.OK);\n+        checkExit(OK);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMethodCommentAlgorithm\/TestMethodCommentsAlgorithm.java","additions":73,"deletions":2,"binary":false,"changes":75,"status":"modified"}]}