{"files":[{"patch":"@@ -75,17 +75,9 @@\n-            switch(ch >>> 16) {  \/\/plane 00-16\n-            case(0):\n-                return CharacterData00.instance;\n-            case(1):\n-                return CharacterData01.instance;\n-            case(2):\n-                return CharacterData02.instance;\n-            case(3):\n-                return CharacterData03.instance;\n-            case(14):\n-                return CharacterData0E.instance;\n-            case(15):   \/\/ Private Use\n-            case(16):   \/\/ Private Use\n-                return CharacterDataPrivateUse.instance;\n-            default:\n-                return CharacterDataUndefined.instance;\n-            }\n+            return switch (ch >>> 16) {  \/\/plane 00-16\n+                case 0 -> CharacterData00.instance;\n+                case 1 -> CharacterData01.instance;\n+                case 2 -> CharacterData02.instance;\n+                case 3 -> CharacterData03.instance;\n+                case 14 -> CharacterData0E.instance;\n+                case 15, 16 -> CharacterDataPrivateUse.instance; \/\/ Both cases Private Use\n+                default -> CharacterDataUndefined.instance;\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharacterData.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -173,19 +173,8 @@\n-        switch (condition) {\n-        case FINAL_CASED:\n-            return isFinalCased(src, index, locale);\n-\n-        case AFTER_SOFT_DOTTED:\n-            return isAfterSoftDotted(src, index);\n-\n-        case MORE_ABOVE:\n-            return isMoreAbove(src, index);\n-\n-        case AFTER_I:\n-            return isAfterI(src, index);\n-\n-        case NOT_BEFORE_DOT:\n-            return !isBeforeDot(src, index);\n-\n-        default:\n-            return true;\n-        }\n+        return switch (condition) {\n+            case FINAL_CASED       -> isFinalCased(src, index, locale);\n+            case AFTER_SOFT_DOTTED -> isAfterSoftDotted(src, index);\n+            case MORE_ABOVE        -> isMoreAbove(src, index);\n+            case AFTER_I           -> isAfterI(src, index);\n+            case NOT_BEFORE_DOT    -> !isBeforeDot(src, index);\n+            default -> true;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ConditionalSpecialCasing.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -216,32 +216,21 @@\n-            switch (radix) {\n-            case 2:\n-                return toBinaryString(i);\n-\n-            case 4:\n-                return toUnsignedString0(i, 2);\n-\n-            case 8:\n-                return toOctalString(i);\n-\n-            case 10:\n-                \/*\n-                 * We can get the effect of an unsigned division by 10\n-                 * on a long value by first shifting right, yielding a\n-                 * positive value, and then dividing by 5.  This\n-                 * allows the last digit and preceding digits to be\n-                 * isolated more quickly than by an initial conversion\n-                 * to BigInteger.\n-                 *\/\n-                long quot = (i >>> 1) \/ 5;\n-                long rem = i - quot * 10;\n-                return toString(quot) + rem;\n-\n-            case 16:\n-                return toHexString(i);\n-\n-            case 32:\n-                return toUnsignedString0(i, 5);\n-\n-            default:\n-                return toUnsignedBigInteger(i).toString(radix);\n-            }\n+            return switch (radix) {\n+                case 2  -> toBinaryString(i);\n+                case 4  -> toUnsignedString0(i, 2);\n+                case 8  -> toOctalString(i);\n+                case 10 -> {\n+                    \/*\n+                     * We can get the effect of an unsigned division by 10\n+                     * on a long value by first shifting right, yielding a\n+                     * positive value, and then dividing by 5.  This\n+                     * allows the last digit and preceding digits to be\n+                     * isolated more quickly than by an initial conversion\n+                     * to BigInteger.\n+                     *\/\n+                    long quot = (i >>> 1) \/ 5;\n+                    long rem = i - quot * 10;\n+                    yield toString(quot) + rem;\n+                }\n+                case 16 -> toHexString(i);\n+                case 32 -> toUnsignedString0(i, 5);\n+                default -> toUnsignedBigInteger(i).toString(radix);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":21,"deletions":32,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1929,21 +1929,17 @@\n-        switch(exp) {\n-        case Double.MAX_EXPONENT + 1:       \/\/ NaN or infinity\n-            return Math.abs(d);\n-\n-        case Double.MIN_EXPONENT - 1:       \/\/ zero or subnormal\n-            return Double.MIN_VALUE;\n-\n-        default:\n-            assert exp <= Double.MAX_EXPONENT && exp >= Double.MIN_EXPONENT;\n-\n-            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n-            exp = exp - (DoubleConsts.SIGNIFICAND_WIDTH-1);\n-            if (exp >= Double.MIN_EXPONENT) {\n-                return powerOfTwoD(exp);\n-            }\n-            else {\n-                \/\/ return a subnormal result; left shift integer\n-                \/\/ representation of Double.MIN_VALUE appropriate\n-                \/\/ number of positions\n-                return Double.longBitsToDouble(1L <<\n-                (exp - (Double.MIN_EXPONENT - (DoubleConsts.SIGNIFICAND_WIDTH-1)) ));\n+        return switch(exp) {\n+            case Double.MAX_EXPONENT + 1 -> Math.abs(d);      \/\/ NaN or infinity\n+            case Double.MIN_EXPONENT - 1 -> Double.MIN_VALUE; \/\/ zero or subnormal\n+            default -> {\n+                assert exp <= Double.MAX_EXPONENT && exp >= Double.MIN_EXPONENT;\n+\n+                \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+                exp = exp - (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n+                if (exp >= Double.MIN_EXPONENT) {\n+                    yield powerOfTwoD(exp);\n+                } else {\n+                    \/\/ return a subnormal result; left shift integer\n+                    \/\/ representation of Double.MIN_VALUE appropriate\n+                    \/\/ number of positions\n+                    yield Double.longBitsToDouble(1L <<\n+                            (exp - (Double.MIN_EXPONENT - (DoubleConsts.SIGNIFICAND_WIDTH - 1))));\n+                }\n@@ -1951,1 +1947,1 @@\n-        }\n+        };\n@@ -1980,3 +1976,5 @@\n-        switch(exp) {\n-        case Float.MAX_EXPONENT+1:        \/\/ NaN or infinity\n-            return Math.abs(f);\n+        return switch(exp) {\n+            case Float.MAX_EXPONENT + 1 -> Math.abs(f);     \/\/ NaN or infinity\n+            case Float.MIN_EXPONENT - 1 -> Float.MIN_VALUE; \/\/ zero or subnormal\n+            default -> {\n+                assert exp <= Float.MAX_EXPONENT && exp >= Float.MIN_EXPONENT;\n@@ -1984,16 +1982,11 @@\n-        case Float.MIN_EXPONENT-1:        \/\/ zero or subnormal\n-            return Float.MIN_VALUE;\n-\n-        default:\n-            assert exp <= Float.MAX_EXPONENT && exp >= Float.MIN_EXPONENT;\n-\n-            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n-            exp = exp - (FloatConsts.SIGNIFICAND_WIDTH-1);\n-            if (exp >= Float.MIN_EXPONENT) {\n-                return powerOfTwoF(exp);\n-            } else {\n-                \/\/ return a subnormal result; left shift integer\n-                \/\/ representation of FloatConsts.MIN_VALUE appropriate\n-                \/\/ number of positions\n-                return Float.intBitsToFloat(1 <<\n-                (exp - (Float.MIN_EXPONENT - (FloatConsts.SIGNIFICAND_WIDTH-1)) ));\n+                \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+                exp = exp - (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+                if (exp >= Float.MIN_EXPONENT) {\n+                    yield powerOfTwoF(exp);\n+                } else {\n+                    \/\/ return a subnormal result; left shift integer\n+                    \/\/ representation of FloatConsts.MIN_VALUE appropriate\n+                    \/\/ number of positions\n+                    yield Float.intBitsToFloat(1 <<\n+                            (exp - (Float.MIN_EXPONENT - (FloatConsts.SIGNIFICAND_WIDTH - 1))));\n+                }\n@@ -2001,1 +1994,1 @@\n-        }\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -75,5 +75,5 @@\n-            case CONSTRUCTOR: validateConstructor(type); break;\n-            case GETTER: validateFieldType(type, false, true); break;\n-            case SETTER: validateFieldType(type, true, true); break;\n-            case STATIC_GETTER: validateFieldType(type, false, false); break;\n-            case STATIC_SETTER: validateFieldType(type, true, false); break;\n+            case CONSTRUCTOR   -> validateConstructor(type);\n+            case GETTER        -> validateFieldType(type, false, true);\n+            case SETTER        -> validateFieldType(type, true, true);\n+            case STATIC_GETTER -> validateFieldType(type, false, false);\n+            case STATIC_SETTER -> validateFieldType(type, true, false);\n@@ -137,21 +137,11 @@\n-        switch (kind) {\n-            case VIRTUAL:\n-            case SPECIAL:\n-            case INTERFACE_VIRTUAL:\n-            case INTERFACE_SPECIAL:\n-                return invocationType.dropParameterTypes(0, 1).descriptorString();\n-            case STATIC:\n-            case INTERFACE_STATIC:\n-                return invocationType.descriptorString();\n-            case CONSTRUCTOR:\n-                return invocationType.changeReturnType(CD_void).descriptorString();\n-            case GETTER:\n-            case STATIC_GETTER:\n-                return invocationType.returnType().descriptorString();\n-            case SETTER:\n-                return invocationType.parameterType(1).descriptorString();\n-            case STATIC_SETTER:\n-                return invocationType.parameterType(0).descriptorString();\n-            default:\n-                throw new IllegalStateException(kind.toString());\n-        }\n+        return switch (kind) {\n+            case VIRTUAL, SPECIAL,\n+                 INTERFACE_VIRTUAL,\n+                 INTERFACE_SPECIAL        -> invocationType.dropParameterTypes(0, 1).descriptorString();\n+            case STATIC, INTERFACE_STATIC -> invocationType.descriptorString();\n+            case CONSTRUCTOR              -> invocationType.changeReturnType(CD_void).descriptorString();\n+            case GETTER, STATIC_GETTER    -> invocationType.returnType().descriptorString();\n+            case SETTER                   -> invocationType.parameterType(1).descriptorString();\n+            case STATIC_SETTER            -> invocationType.parameterType(0).descriptorString();\n+            default -> throw new IllegalStateException(kind.toString());\n+        };\n@@ -164,24 +154,11 @@\n-        switch (kind) {\n-            case STATIC:\n-            case INTERFACE_STATIC:\n-                return lookup.findStatic(resolvedOwner, name, invocationType);\n-            case INTERFACE_VIRTUAL:\n-            case VIRTUAL:\n-                return lookup.findVirtual(resolvedOwner, name, invocationType.dropParameterTypes(0, 1));\n-            case SPECIAL:\n-            case INTERFACE_SPECIAL:\n-                return lookup.findSpecial(resolvedOwner, name, invocationType.dropParameterTypes(0, 1),\n-                                          lookup.lookupClass());\n-            case CONSTRUCTOR:\n-                return lookup.findConstructor(resolvedOwner, invocationType.changeReturnType(void.class));\n-            case GETTER:\n-                return lookup.findGetter(resolvedOwner, name, invocationType.returnType());\n-            case STATIC_GETTER:\n-                return lookup.findStaticGetter(resolvedOwner, name, invocationType.returnType());\n-            case SETTER:\n-                return lookup.findSetter(resolvedOwner, name, invocationType.parameterType(1));\n-            case STATIC_SETTER:\n-                return lookup.findStaticSetter(resolvedOwner, name, invocationType.parameterType(0));\n-            default:\n-                throw new IllegalStateException(kind.name());\n-        }\n+        return switch (kind) {\n+            case STATIC, INTERFACE_STATIC   -> lookup.findStatic(resolvedOwner, name, invocationType);\n+            case INTERFACE_VIRTUAL, VIRTUAL -> lookup.findVirtual(resolvedOwner, name, invocationType.dropParameterTypes(0, 1));\n+            case SPECIAL, INTERFACE_SPECIAL -> lookup.findSpecial(resolvedOwner, name, invocationType.dropParameterTypes(0, 1), lookup.lookupClass());\n+            case CONSTRUCTOR                -> lookup.findConstructor(resolvedOwner, invocationType.changeReturnType(void.class));\n+            case GETTER                     -> lookup.findGetter(resolvedOwner, name, invocationType.returnType());\n+            case STATIC_GETTER              -> lookup.findStaticGetter(resolvedOwner, name, invocationType.returnType());\n+            case SETTER                     -> lookup.findSetter(resolvedOwner, name, invocationType.parameterType(1));\n+            case STATIC_SETTER              -> lookup.findStaticSetter(resolvedOwner, name, invocationType.parameterType(0));\n+            default -> throw new IllegalStateException(kind.name());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","additions":27,"deletions":50,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -159,9 +159,7 @@\n-        MethodTypeDesc mtr;\n-        switch (kind) {\n-            case GETTER: mtr = MethodTypeDesc.of(fieldType, owner); break;\n-            case SETTER: mtr = MethodTypeDesc.of(CD_void, owner, fieldType); break;\n-            case STATIC_GETTER: mtr = MethodTypeDesc.of(fieldType); break;\n-            case STATIC_SETTER: mtr = MethodTypeDesc.of(CD_void, fieldType); break;\n-            default:\n-                throw new IllegalArgumentException(kind.toString());\n-        }\n+        MethodTypeDesc mtr = switch (kind) {\n+            case GETTER        -> MethodTypeDesc.of(fieldType, owner);\n+            case SETTER        -> MethodTypeDesc.of(CD_void, owner, fieldType);\n+            case STATIC_GETTER -> MethodTypeDesc.of(fieldType);\n+            case STATIC_SETTER -> MethodTypeDesc.of(CD_void, fieldType);\n+            default -> throw new IllegalArgumentException(kind.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,13 +67,8 @@\n-            switch (xtype) {\n-            case L_TYPE:\n-                return bindSingle(type, form, x);  \/\/ Use known fast path.\n-            case I_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n-            case J_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n-            case F_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n-            case D_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n-            default : throw newInternalError(\"unexpected xtype: \" + xtype);\n-            }\n+            return switch (xtype) {\n+                case L_TYPE -> bindSingle(type, form, x);  \/\/ Use known fast path.\n+                case I_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n+                case J_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n+                case F_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n+                case D_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n+                default -> throw newInternalError(\"unexpected xtype: \" + xtype);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -856,8 +856,8 @@\n-            switch (t) {\n-            case 'L': return ALOAD;\n-            case 'I': return ILOAD;\n-            case 'J': return LLOAD;\n-            case 'F': return FLOAD;\n-            case 'D': return DLOAD;\n-            default : throw newInternalError(\"unrecognized type \" + t);\n-            }\n+            return switch (t) {\n+                case 'L' -> ALOAD;\n+                case 'I' -> ILOAD;\n+                case 'J' -> LLOAD;\n+                case 'F' -> FLOAD;\n+                case 'D' -> DLOAD;\n+                default -> throw newInternalError(\"unrecognized type \" + t);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -166,5 +166,5 @@\n-        switch(whichCache) {\n-            case MethodTypeForm.LF_REBIND:   return BOUND_REINVOKER;\n-            case MethodTypeForm.LF_DELEGATE: return DELEGATE;\n-            default:                         return REINVOKER;\n-        }\n+        return switch (whichCache) {\n+            case MethodTypeForm.LF_REBIND   -> BOUND_REINVOKER;\n+            case MethodTypeForm.LF_DELEGATE -> DELEGATE;\n+            default -> REINVOKER;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-            switch (refKind) {\n-                case REF_invokeSpecial: {\n+            return switch (refKind) {\n+                case REF_invokeSpecial -> {\n@@ -98,1 +98,1 @@\n-                    return new Special(mtype, lform, member, true, callerClass);\n+                    yield new Special(mtype, lform, member, true, callerClass);\n@@ -100,1 +100,1 @@\n-                case REF_invokeInterface: {\n+                case REF_invokeInterface -> {\n@@ -105,1 +105,1 @@\n-                    return new Interface(mtype, lform, member, true, refc);\n+                    yield new Interface(mtype, lform, member, true, refc);\n@@ -107,1 +107,1 @@\n-                default: {\n+                default -> {\n@@ -109,1 +109,1 @@\n-                    return new DirectMethodHandle(mtype, lform, member, true);\n+                    yield new DirectMethodHandle(mtype, lform, member, true);\n@@ -111,1 +111,1 @@\n-            }\n+            };\n@@ -197,1 +197,0 @@\n-        int which;\n@@ -203,8 +202,8 @@\n-        switch (m.getReferenceKind()) {\n-        case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;\n-        case REF_invokeStatic:     which = LF_INVSTATIC;     break;\n-        case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;\n-        case REF_invokeInterface:  which = LF_INVINTERFACE;  break;\n-        case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;\n-        default:  throw new InternalError(m.toString());\n-        }\n+        int which = switch (m.getReferenceKind()) {\n+            case REF_invokeVirtual    -> LF_INVVIRTUAL;\n+            case REF_invokeStatic     -> LF_INVSTATIC;\n+            case REF_invokeSpecial    -> LF_INVSPECIAL;\n+            case REF_invokeInterface  -> LF_INVINTERFACE;\n+            case REF_newInvokeSpecial -> LF_NEWINVSPECIAL;\n+            default -> throw new InternalError(m.toString());\n+        };\n@@ -667,8 +666,7 @@\n-        byte formOp;\n-        switch (m.getReferenceKind()) {\n-        case REF_getField:      formOp = AF_GETFIELD;    break;\n-        case REF_putField:      formOp = AF_PUTFIELD;    break;\n-        case REF_getStatic:     formOp = AF_GETSTATIC;   break;\n-        case REF_putStatic:     formOp = AF_PUTSTATIC;   break;\n-        default:  throw new InternalError(m.toString());\n-        }\n+        byte formOp = switch (m.getReferenceKind()) {\n+            case REF_getField  -> AF_GETFIELD;\n+            case REF_putField  -> AF_PUTFIELD;\n+            case REF_getStatic -> AF_GETSTATIC;\n+            case REF_putStatic -> AF_PUTSTATIC;\n+            default -> throw new InternalError(m.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -601,14 +601,8 @@\n-            switch (implKind) {\n-                case MethodHandleInfo.REF_invokeStatic:\n-                    return INVOKESTATIC;\n-                case MethodHandleInfo.REF_newInvokeSpecial:\n-                    return INVOKESPECIAL;\n-                 case MethodHandleInfo.REF_invokeVirtual:\n-                    return INVOKEVIRTUAL;\n-                case MethodHandleInfo.REF_invokeInterface:\n-                    return INVOKEINTERFACE;\n-                case MethodHandleInfo.REF_invokeSpecial:\n-                    return INVOKESPECIAL;\n-                default:\n-                    throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n-            }\n+            return switch (implKind) {\n+                case MethodHandleInfo.REF_invokeStatic     -> INVOKESTATIC;\n+                case MethodHandleInfo.REF_newInvokeSpecial -> INVOKESPECIAL;\n+                case MethodHandleInfo.REF_invokeVirtual    -> INVOKEVIRTUAL;\n+                case MethodHandleInfo.REF_invokeInterface  -> INVOKEINTERFACE;\n+                case MethodHandleInfo.REF_invokeSpecial    -> INVOKESPECIAL;\n+                default -> throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -495,9 +495,8 @@\n-        switch (type) {\n-            case I_TYPE: return Opcodes.ILOAD;\n-            case J_TYPE: return Opcodes.LLOAD;\n-            case F_TYPE: return Opcodes.FLOAD;\n-            case D_TYPE: return Opcodes.DLOAD;\n-            case L_TYPE: return Opcodes.ALOAD;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n-        }\n+        return switch (type) {\n+            case I_TYPE -> Opcodes.ILOAD;\n+            case J_TYPE -> Opcodes.LLOAD;\n+            case F_TYPE -> Opcodes.FLOAD;\n+            case D_TYPE -> Opcodes.DLOAD;\n+            case L_TYPE -> Opcodes.ALOAD;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n@@ -515,9 +514,8 @@\n-        switch (type) {\n-            case I_TYPE: return Opcodes.ISTORE;\n-            case J_TYPE: return Opcodes.LSTORE;\n-            case F_TYPE: return Opcodes.FSTORE;\n-            case D_TYPE: return Opcodes.DSTORE;\n-            case L_TYPE: return Opcodes.ASTORE;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n-        }\n+        return switch (type) {\n+            case I_TYPE -> Opcodes.ISTORE;\n+            case J_TYPE -> Opcodes.LSTORE;\n+            case F_TYPE -> Opcodes.FSTORE;\n+            case D_TYPE -> Opcodes.DSTORE;\n+            case L_TYPE -> Opcodes.ASTORE;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n@@ -530,12 +528,12 @@\n-        switch (elementType) {\n-            case BOOLEAN: return Opcodes.T_BOOLEAN;\n-            case BYTE:    return Opcodes.T_BYTE;\n-            case CHAR:    return Opcodes.T_CHAR;\n-            case SHORT:   return Opcodes.T_SHORT;\n-            case INT:     return Opcodes.T_INT;\n-            case LONG:    return Opcodes.T_LONG;\n-            case FLOAT:   return Opcodes.T_FLOAT;\n-            case DOUBLE:  return Opcodes.T_DOUBLE;\n-            case OBJECT:  return 0; \/\/ in place of Opcodes.T_OBJECT\n-            default:      throw new InternalError();\n-        }\n+        return (byte) switch (elementType) {\n+            case BOOLEAN -> Opcodes.T_BOOLEAN;\n+            case BYTE    -> Opcodes.T_BYTE;\n+            case CHAR    -> Opcodes.T_CHAR;\n+            case SHORT   -> Opcodes.T_SHORT;\n+            case INT     -> Opcodes.T_INT;\n+            case LONG    -> Opcodes.T_LONG;\n+            case FLOAT   -> Opcodes.T_FLOAT;\n+            case DOUBLE  -> Opcodes.T_DOUBLE;\n+            case OBJECT  -> 0; \/\/ in place of Opcodes.T_OBJECT\n+            default -> throw new InternalError();\n+        };\n@@ -546,13 +544,12 @@\n-        int xas;\n-        switch (tcode) {\n-            case Opcodes.T_BOOLEAN: xas = Opcodes.BASTORE; break;\n-            case Opcodes.T_BYTE:    xas = Opcodes.BASTORE; break;\n-            case Opcodes.T_CHAR:    xas = Opcodes.CASTORE; break;\n-            case Opcodes.T_SHORT:   xas = Opcodes.SASTORE; break;\n-            case Opcodes.T_INT:     xas = Opcodes.IASTORE; break;\n-            case Opcodes.T_LONG:    xas = Opcodes.LASTORE; break;\n-            case Opcodes.T_FLOAT:   xas = Opcodes.FASTORE; break;\n-            case Opcodes.T_DOUBLE:  xas = Opcodes.DASTORE; break;\n-            case 0:                 xas = Opcodes.AASTORE; break;\n-            default:      throw new InternalError();\n-        }\n+        int xas = switch (tcode) {\n+            case Opcodes.T_BOOLEAN -> Opcodes.BASTORE;\n+            case Opcodes.T_BYTE    -> Opcodes.BASTORE;\n+            case Opcodes.T_CHAR    -> Opcodes.CASTORE;\n+            case Opcodes.T_SHORT   -> Opcodes.SASTORE;\n+            case Opcodes.T_INT     -> Opcodes.IASTORE;\n+            case Opcodes.T_LONG    -> Opcodes.LASTORE;\n+            case Opcodes.T_FLOAT   -> Opcodes.FASTORE;\n+            case Opcodes.T_DOUBLE  -> Opcodes.DASTORE;\n+            case 0                 -> Opcodes.AASTORE;\n+            default -> throw new InternalError();\n+        };\n@@ -1386,11 +1383,5 @@\n-        switch (type) {\n-            case I_TYPE:\n-            case F_TYPE:\n-            case L_TYPE:\n-                return Opcodes.POP;\n-            case J_TYPE:\n-            case D_TYPE:\n-                return Opcodes.POP2;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n-        }\n+        return switch (type) {\n+            case I_TYPE, F_TYPE, L_TYPE -> Opcodes.POP;\n+            case J_TYPE, D_TYPE         -> Opcodes.POP2;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n@@ -1666,8 +1657,8 @@\n-        switch (type) {\n-            case I_TYPE: mv.visitInsn(Opcodes.ICONST_0); break;\n-            case J_TYPE: mv.visitInsn(Opcodes.LCONST_0); break;\n-            case F_TYPE: mv.visitInsn(Opcodes.FCONST_0); break;\n-            case D_TYPE: mv.visitInsn(Opcodes.DCONST_0); break;\n-            case L_TYPE: mv.visitInsn(Opcodes.ACONST_NULL); break;\n-            default: throw new InternalError(\"unknown type: \" + type);\n-        }\n+        mv.visitInsn(switch (type) {\n+            case I_TYPE -> Opcodes.ICONST_0;\n+            case J_TYPE -> Opcodes.LCONST_0;\n+            case F_TYPE -> Opcodes.FCONST_0;\n+            case D_TYPE -> Opcodes.DCONST_0;\n+            case L_TYPE -> Opcodes.ACONST_NULL;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        });\n@@ -1781,5 +1772,6 @@\n-                case LONG:\n-                    switch (to) {\n-                    case FLOAT:   mv.visitInsn(Opcodes.L2F);  break;\n-                    case DOUBLE:  mv.visitInsn(Opcodes.L2D);  break;\n-                    default:      error = true;               break;\n+                    case LONG -> {\n+                        switch (to) {\n+                            case FLOAT  -> mv.visitInsn(Opcodes.L2F);\n+                            case DOUBLE -> mv.visitInsn(Opcodes.L2D);\n+                            default -> error = true;\n+                        }\n@@ -1787,6 +1779,6 @@\n-                    break;\n-                case FLOAT:\n-                    switch (to) {\n-                    case LONG :   mv.visitInsn(Opcodes.F2L);  break;\n-                    case DOUBLE:  mv.visitInsn(Opcodes.F2D);  break;\n-                    default:      error = true;               break;\n+                    case FLOAT -> {\n+                        switch (to) {\n+                            case LONG   -> mv.visitInsn(Opcodes.F2L);\n+                            case DOUBLE -> mv.visitInsn(Opcodes.F2D);\n+                            default -> error = true;\n+                        }\n@@ -1794,6 +1786,6 @@\n-                    break;\n-                case DOUBLE:\n-                    switch (to) {\n-                    case LONG :   mv.visitInsn(Opcodes.D2L);  break;\n-                    case FLOAT:   mv.visitInsn(Opcodes.D2F);  break;\n-                    default:      error = true;               break;\n+                    case DOUBLE -> {\n+                        switch (to) {\n+                            case LONG  -> mv.visitInsn(Opcodes.D2L);\n+                            case FLOAT -> mv.visitInsn(Opcodes.D2F);\n+                            default -> error = true;\n+                        }\n@@ -1801,4 +1793,1 @@\n-                    break;\n-                default:\n-                    error = true;\n-                    break;\n+                    default -> error = true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":72,"deletions":83,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -257,6 +257,5 @@\n-        int which;\n-        switch (name) {\n-            case \"invokeExact\":  which = MethodTypeForm.LF_EX_LINKER; break;\n-            case \"invoke\":       which = MethodTypeForm.LF_GEN_LINKER; break;\n-            default:             throw new InternalError(\"not invoker: \"+name);\n-        }\n+        int which = switch (name) {\n+            case \"invokeExact\" -> MethodTypeForm.LF_EX_LINKER;\n+            case \"invoke\"      -> MethodTypeForm.LF_GEN_LINKER;\n+            default -> throw new InternalError(\"not invoker: \" + name);\n+        };\n@@ -663,18 +662,10 @@\n-            switch (func) {\n-                case NF_checkExactType:\n-                    return getNamedFunction(\"checkExactType\", MethodType.methodType(void.class, MethodHandle.class, MethodType.class));\n-                case NF_checkGenericType:\n-                    return getNamedFunction(\"checkGenericType\", MethodType.methodType(MethodHandle.class, MethodHandle.class, MethodType.class));\n-                case NF_getCallSiteTarget:\n-                    return getNamedFunction(\"getCallSiteTarget\", MethodType.methodType(MethodHandle.class, CallSite.class));\n-                case NF_checkCustomized:\n-                    return getNamedFunction(\"checkCustomized\", MethodType.methodType(void.class, MethodHandle.class));\n-                case NF_checkVarHandleGenericType:\n-                    return getNamedFunction(\"checkVarHandleGenericType\", MethodType.methodType(MethodHandle.class, VarHandle.class, VarHandle.AccessDescriptor.class));\n-                case NF_checkVarHandleExactType:\n-                    return getNamedFunction(\"checkVarHandleExactType\", MethodType.methodType(MethodHandle.class, VarHandle.class, VarHandle.AccessDescriptor.class));\n-                case NF_directVarHandleTarget:\n-                    return getNamedFunction(\"directVarHandleTarget\", MethodType.methodType(VarHandle.class, VarHandle.class));\n-                default:\n-                    throw newInternalError(\"Unknown function: \" + func);\n-            }\n+            return switch (func) {\n+                case NF_checkExactType            -> getNamedFunction(\"checkExactType\", MethodType.methodType(void.class, MethodHandle.class, MethodType.class));\n+                case NF_checkGenericType          -> getNamedFunction(\"checkGenericType\", MethodType.methodType(MethodHandle.class, MethodHandle.class, MethodType.class));\n+                case NF_getCallSiteTarget         -> getNamedFunction(\"getCallSiteTarget\", MethodType.methodType(MethodHandle.class, CallSite.class));\n+                case NF_checkCustomized           -> getNamedFunction(\"checkCustomized\", MethodType.methodType(void.class, MethodHandle.class));\n+                case NF_checkVarHandleGenericType -> getNamedFunction(\"checkVarHandleGenericType\", MethodType.methodType(MethodHandle.class, VarHandle.class, VarHandle.AccessDescriptor.class));\n+                case NF_checkVarHandleExactType   -> getNamedFunction(\"checkVarHandleExactType\", MethodType.methodType(MethodHandle.class, VarHandle.class, VarHandle.AccessDescriptor.class));\n+                case NF_directVarHandleTarget     -> getNamedFunction(\"directVarHandleTarget\", MethodType.methodType(VarHandle.class, VarHandle.class));\n+                default -> throw newInternalError(\"Unknown function: \" + func);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -190,7 +190,7 @@\n-            switch (type) {\n-                case 'L': return L_TYPE;\n-                case 'I': return I_TYPE;\n-                case 'J': return J_TYPE;\n-                case 'F': return F_TYPE;\n-                case 'D': return D_TYPE;\n-                case 'V': return V_TYPE;\n+            return switch (type) {\n+                case 'L' -> L_TYPE;\n+                case 'I' -> I_TYPE;\n+                case 'J' -> J_TYPE;\n+                case 'F' -> F_TYPE;\n+                case 'D' -> D_TYPE;\n+                case 'V' -> V_TYPE;\n@@ -198,8 +198,3 @@\n-                case 'Z':\n-                case 'B':\n-                case 'S':\n-                case 'C':\n-                    return I_TYPE;\n-                default:\n-                    throw newInternalError(\"Unknown type char: '\"+type+\"'\");\n-            }\n+                case 'Z', 'B', 'S', 'C' -> I_TYPE;\n+                default -> throw newInternalError(\"Unknown type char: '\" + type + \"'\");\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -316,12 +316,15 @@\n-        if (refKind == originalRefKind)  return true;\n-        switch (originalRefKind) {\n-        case REF_invokeInterface:\n-            \/\/ Looking up an interface method, can get (e.g.) Object.hashCode\n-            assert(refKind == REF_invokeVirtual ||\n-                   refKind == REF_invokeSpecial) : this;\n-            return true;\n-        case REF_invokeVirtual:\n-        case REF_newInvokeSpecial:\n-            \/\/ Looked up a virtual, can get (e.g.) final String.hashCode.\n-            assert(refKind == REF_invokeSpecial) : this;\n-            return true;\n+        if (refKind == originalRefKind) return true;\n+        if (getClass().desiredAssertionStatus()) {\n+            switch (originalRefKind) {\n+                case REF_invokeInterface -> {\n+                    \/\/ Looking up an interface method, can get (e.g.) Object.hashCode\n+                    assert (refKind == REF_invokeVirtual || refKind == REF_invokeSpecial) : this;\n+                }\n+                case REF_invokeVirtual, REF_newInvokeSpecial -> {\n+                    \/\/ Looked up a virtual, can get (e.g.) final String.hashCode.\n+                    assert (refKind == REF_invokeSpecial) : this;\n+                }\n+                default -> {\n+                    assert (false) : this + \" != \" + MethodHandleNatives.refKindName((byte) originalRefKind);\n+                }\n+            }\n@@ -329,1 +332,0 @@\n-        assert(false) : this+\" != \"+MethodHandleNatives.refKindName((byte)originalRefKind);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1561,26 +1561,16 @@\n-        switch (info.getReferenceKind()) {\n-            case REF_getField:\n-                return Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.GETTER, owner, name, type.returnType()));\n-            case REF_putField:\n-                return Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.SETTER, owner, name, type.parameterType(0)));\n-            case REF_getStatic:\n-                return Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, owner, name, type.returnType()));\n-            case REF_putStatic:\n-                return Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_SETTER, owner, name, type.parameterType(0)));\n-            case REF_invokeVirtual:\n-                return Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, owner, name, type));\n-            case REF_invokeStatic:\n-                return isInterface ?\n-                        Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, owner, name, type)) :\n-                        Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, owner, name, type));\n-            case REF_invokeSpecial:\n-                return isInterface ?\n-                        Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_SPECIAL, owner, name, type)) :\n-                        Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.SPECIAL, owner, name, type));\n-            case REF_invokeInterface:\n-                return Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, owner, name, type));\n-            case REF_newInvokeSpecial:\n-                return Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.CONSTRUCTOR, owner, name, type));\n-            default:\n-                return Optional.empty();\n-        }\n+        return switch (info.getReferenceKind()) {\n+            case REF_getField         -> Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.GETTER, owner, name, type.returnType()));\n+            case REF_putField         -> Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.SETTER, owner, name, type.parameterType(0)));\n+            case REF_getStatic        -> Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, owner, name, type.returnType()));\n+            case REF_putStatic        -> Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_SETTER, owner, name, type.parameterType(0)));\n+            case REF_invokeVirtual    -> Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, owner, name, type));\n+            case REF_invokeStatic     -> isInterface ?\n+                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, owner, name, type)) :\n+                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, owner, name, type));\n+            case REF_invokeSpecial    -> isInterface ?\n+                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_SPECIAL, owner, name, type)) :\n+                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.SPECIAL, owner, name, type));\n+            case REF_invokeInterface  -> Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, owner, name, type));\n+            case REF_newInvokeSpecial -> Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.CONSTRUCTOR, owner, name, type));\n+            default -> Optional.empty();\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -112,6 +112,6 @@\n-            switch (a) {\n-                case GET: return \"getElement\";\n-                case SET: return \"setElement\";\n-                case LENGTH: return \"length\";\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> \"getElement\";\n+                case SET    -> \"setElement\";\n+                case LENGTH -> \"length\";\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -121,6 +121,6 @@\n-            switch (a) {\n-                case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;\n-                case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;\n-                case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> ArrayAccessor.OBJECT_ARRAY_GETTER;\n+                case SET    -> ArrayAccessor.OBJECT_ARRAY_SETTER;\n+                case LENGTH -> ArrayAccessor.OBJECT_ARRAY_LENGTH;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -130,6 +130,6 @@\n-            switch (a) {\n-                case GET: return ArrayAccessor.GETTER_INDEX;\n-                case SET: return ArrayAccessor.SETTER_INDEX;\n-                case LENGTH: return ArrayAccessor.LENGTH_INDEX;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> ArrayAccessor.GETTER_INDEX;\n+                case SET    -> ArrayAccessor.SETTER_INDEX;\n+                case LENGTH -> ArrayAccessor.LENGTH_INDEX;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -139,6 +139,6 @@\n-            switch (a) {\n-                case GET: return Intrinsic.ARRAY_LOAD;\n-                case SET: return Intrinsic.ARRAY_STORE;\n-                case LENGTH: return Intrinsic.ARRAY_LENGTH;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> Intrinsic.ARRAY_LOAD;\n+                case SET    -> Intrinsic.ARRAY_STORE;\n+                case LENGTH -> Intrinsic.ARRAY_LENGTH;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -216,6 +216,6 @@\n-            switch (access) {\n-                case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);\n-                case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);\n-                case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);\n-            }\n-            throw unmatchedArrayAccess(access);\n+            return switch (access) {\n+                case GET    -> MethodType.methodType(elemClass, arrayArgClass, int.class);\n+                case SET    -> MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);\n+                case LENGTH -> MethodType.methodType(int.class, arrayArgClass);\n+                default -> throw unmatchedArrayAccess(access);\n+            };\n@@ -225,6 +225,6 @@\n-            switch (access) {\n-                case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);\n-                case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);\n-                case LENGTH: return MethodType.methodType(int.class,  arrayClass);\n-            }\n-            throw unmatchedArrayAccess(access);\n+            return switch (access) {\n+                case GET    -> MethodType.methodType(elemClass, arrayClass, int.class);\n+                case SET    -> MethodType.methodType(void.class, arrayClass, int.class, elemClass);\n+                case LENGTH -> MethodType.methodType(int.class, arrayClass);\n+                default -> throw unmatchedArrayAccess(access);\n+            };\n@@ -983,1 +983,0 @@\n-        int idx;\n@@ -985,5 +984,5 @@\n-        switch (method.getName()) {\n-        case \"invoke\":       idx = 0; break;\n-        case \"invokeExact\":  idx = 1; break;\n-        default:             throw new InternalError(method.getName());\n-        }\n+        int idx = switch (method.getName()) {\n+            case \"invoke\"      -> 0;\n+            case \"invokeExact\" -> 1;\n+            default -> throw new InternalError(method.getName());\n+        };\n@@ -1398,26 +1397,18 @@\n-            switch (func) {\n-                case NF_checkSpreadArgument:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"checkSpreadArgument\", Object.class, int.class));\n-                case NF_guardWithCatch:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"guardWithCatch\", MethodHandle.class, Class.class,\n-                                    MethodHandle.class, Object[].class));\n-                case NF_tryFinally:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"tryFinally\", MethodHandle.class, MethodHandle.class, Object[].class));\n-                case NF_loop:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"loop\", BasicType[].class, LoopClauses.class, Object[].class));\n-                case NF_throwException:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"throwException\", Throwable.class));\n-                case NF_profileBoolean:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"profileBoolean\", boolean.class, int[].class));\n-                case NF_tableSwitch:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"tableSwitch\", int.class, MethodHandle.class, CasesHolder.class, Object[].class));\n-                default:\n-                    throw new InternalError(\"Undefined function: \" + func);\n-            }\n+            return switch (func) {\n+                case NF_checkSpreadArgument -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"checkSpreadArgument\", Object.class, int.class));\n+                case NF_guardWithCatch      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"guardWithCatch\", MethodHandle.class, Class.class,\n+                                                   MethodHandle.class, Object[].class));\n+                case NF_tryFinally          -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"tryFinally\", MethodHandle.class, MethodHandle.class, Object[].class));\n+                case NF_loop                -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"loop\", BasicType[].class, LoopClauses.class, Object[].class));\n+                case NF_throwException      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"throwException\", Throwable.class));\n+                case NF_profileBoolean      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"profileBoolean\", boolean.class, int[].class));\n+                case NF_tableSwitch         -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"tableSwitch\", int.class, MethodHandle.class, CasesHolder.class, Object[].class));\n+                default -> throw new InternalError(\"Undefined function: \" + func);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":59,"deletions":68,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -209,12 +209,12 @@\n-        switch (refKind) {\n-        case REF_getField:          return \"getField\";\n-        case REF_getStatic:         return \"getStatic\";\n-        case REF_putField:          return \"putField\";\n-        case REF_putStatic:         return \"putStatic\";\n-        case REF_invokeVirtual:     return \"invokeVirtual\";\n-        case REF_invokeStatic:      return \"invokeStatic\";\n-        case REF_invokeSpecial:     return \"invokeSpecial\";\n-        case REF_newInvokeSpecial:  return \"newInvokeSpecial\";\n-        case REF_invokeInterface:   return \"invokeInterface\";\n-        default:                    return \"REF_???\";\n-        }\n+        return switch (refKind) {\n+            case REF_getField         -> \"getField\";\n+            case REF_getStatic        -> \"getStatic\";\n+            case REF_putField         -> \"putField\";\n+            case REF_putStatic        -> \"putStatic\";\n+            case REF_invokeVirtual    -> \"invokeVirtual\";\n+            case REF_invokeStatic     -> \"invokeStatic\";\n+            case REF_invokeSpecial    -> \"invokeSpecial\";\n+            case REF_newInvokeSpecial -> \"newInvokeSpecial\";\n+            case REF_invokeInterface  -> \"invokeInterface\";\n+            default -> \"REF_???\";\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -277,13 +277,10 @@\n-        switch (m.getName()) {\n-        case \"toString\":\n-            return (m.getReturnType() == String.class\n-                    && m.getParameterCount() == 0);\n-        case \"hashCode\":\n-            return (m.getReturnType() == int.class\n-                    && m.getParameterCount() == 0);\n-        case \"equals\":\n-            return (m.getReturnType() == boolean.class\n-                    && m.getParameterCount() == 1\n-                    && m.getParameterTypes()[0] == Object.class);\n-        }\n-        return false;\n+        return switch (m.getName()) {\n+            case \"toString\" -> m.getReturnType() == String.class\n+                               && m.getParameterCount() == 0;\n+            case \"hashCode\" -> m.getReturnType() == int.class\n+                               && m.getParameterCount() == 0;\n+            case \"equals\"   -> m.getReturnType() == boolean.class\n+                               && m.getParameterCount() == 1\n+                               && m.getParameterTypes()[0] == Object.class;\n+            default -> false;\n+        };\n@@ -294,9 +291,6 @@\n-        switch (m.getName()) {\n-        case \"toString\":\n-            return self.getClass().getName() + \"@\" + Integer.toHexString(self.hashCode());\n-        case \"hashCode\":\n-            return System.identityHashCode(self);\n-        case \"equals\":\n-            return (self == args[0]);\n-        }\n-        return null;\n+        return switch (m.getName()) {\n+            case \"toString\" -> self.getClass().getName() + \"@\" + Integer.toHexString(self.hashCode());\n+            case \"hashCode\" -> System.identityHashCode(self);\n+            case \"equals\"   -> (self == args[0]);\n+            default -> null;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -5178,7 +5178,7 @@\n-        switch (w) {\n-        case INT:     return result.bindArgumentI(pos, (int)value);\n-        case LONG:    return result.bindArgumentJ(pos, (long)value);\n-        case FLOAT:   return result.bindArgumentF(pos, (float)value);\n-        case DOUBLE:  return result.bindArgumentD(pos, (double)value);\n-        default:      return result.bindArgumentI(pos, ValueConversions.widenSubword(value));\n-        }\n+        return switch (w) {\n+            case INT    -> result.bindArgumentI(pos, (int) value);\n+            case LONG   -> result.bindArgumentJ(pos, (long) value);\n+            case FLOAT  -> result.bindArgumentF(pos, (float) value);\n+            case DOUBLE -> result.bindArgumentD(pos, (double) value);\n+            default -> result.bindArgumentI(pos, ValueConversions.widenSubword(value));\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2285,9 +2285,5 @@\n-                switch (this) {\n-                    case FIELD:\n-                    case STATIC_FIELD:\n-                        return new ConstantDesc[] {declaringClass, varType };\n-                    case ARRAY:\n-                        return new ConstantDesc[] {declaringClass };\n-                    default:\n-                        throw new InternalError(\"Cannot reach here\");\n-                }\n+                return switch (this) {\n+                    case FIELD, STATIC_FIELD -> new ConstantDesc[]{declaringClass, varType};\n+                    case ARRAY               -> new ConstantDesc[]{declaringClass};\n+                    default -> throw new InternalError(\"Cannot reach here\");\n+                };\n@@ -2388,14 +2384,10 @@\n-            switch (kind) {\n-                case FIELD:\n-                    return lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n-                                                constantName(),\n-                                                (Class<?>) varType.resolveConstantDesc(lookup));\n-                case STATIC_FIELD:\n-                    return lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n-                                                      constantName(),\n-                                                      (Class<?>) varType.resolveConstantDesc(lookup));\n-                case ARRAY:\n-                    return MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n-                default:\n-                    throw new InternalError(\"Cannot reach here\");\n-            }\n+            return switch (kind) {\n+                case FIELD        -> lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          constantName(),\n+                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n+                case STATIC_FIELD -> lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          constantName(),\n+                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n+                case ARRAY        -> MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n+                default -> throw new InternalError(\"Cannot reach here\");\n+            };\n@@ -2414,11 +2406,7 @@\n-            switch (kind) {\n-                case FIELD:\n-                case STATIC_FIELD:\n-                    return String.format(\"VarHandleDesc[%s%s.%s:%s]\",\n-                                         (kind == Kind.STATIC_FIELD) ? \"static \" : \"\",\n-                                         declaringClass.displayName(), constantName(), varType.displayName());\n-                case ARRAY:\n-                    return String.format(\"VarHandleDesc[%s[]]\", declaringClass.displayName());\n-                default:\n-                    throw new InternalError(\"Cannot reach here\");\n-            }\n+            return switch (kind) {\n+                case FIELD, STATIC_FIELD -> String.format(\"VarHandleDesc[%s%s.%s:%s]\",\n+                                                           (kind == Kind.STATIC_FIELD) ? \"static \" : \"\",\n+                                                           declaringClass.displayName(), constantName(), varType.displayName());\n+                case ARRAY               -> String.format(\"VarHandleDesc[%s[]]\", declaringClass.displayName());\n+                default -> throw new InternalError(\"Cannot reach here\");\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":22,"deletions":34,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -342,3 +342,2 @@\n-        MethodHandle handle;\n-        switch (methodName) {\n-            case \"equals\":\n+        MethodHandle handle = switch (methodName) {\n+            case \"equals\"   -> {\n@@ -347,3 +346,3 @@\n-                handle = makeEquals(recordClass, getterList);\n-                return methodType != null ? new ConstantCallSite(handle) : handle;\n-            case \"hashCode\":\n+                yield makeEquals(recordClass, getterList);\n+            }\n+            case \"hashCode\" -> {\n@@ -352,3 +351,3 @@\n-                handle = makeHashCode(recordClass, getterList);\n-                return methodType != null ? new ConstantCallSite(handle) : handle;\n-            case \"toString\":\n+                yield makeHashCode(recordClass, getterList);\n+            }\n+            case \"toString\" -> {\n@@ -360,5 +359,5 @@\n-                handle = makeToString(recordClass, getterList, nameList);\n-                return methodType != null ? new ConstantCallSite(handle) : handle;\n-            default:\n-                throw new IllegalArgumentException(methodName);\n-        }\n+                yield makeToString(recordClass, getterList, nameList);\n+            }\n+            default -> throw new IllegalArgumentException(methodName);\n+        };\n+        return methodType != null ? new ConstantCallSite(handle) : handle;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"}]}