{"files":[{"patch":"@@ -25,2 +25,1 @@\n- * @test\n- *\n+ * @test id=default\n@@ -28,1 +27,19 @@\n- * DESCRIPTION\n+ * @requires vm.continuations\n+ * @run main\/othervm\/native -agentlib:StopThreadTest StopThreadTest\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @summary Verifies JVMTI StopThread support for bound virtual threads.\n+ * @run main\/othervm\/native -agentlib:StopThreadTest -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations StopThreadTest\n+ *\/\n+\n+\/*\n+ * @test id=platform\n+ * @summary Verifies JVMTI StopThread support for platform threads.\n+ * @run main\/othervm\/native -agentlib:StopThreadTest StopThreadTest platform\n+ *\/\n+\n+import java.lang.AssertionError;\n+\n+\/*\n@@ -30,1 +47,1 @@\n- *     The test creates a new virtual thread.\n+ *     The test creates a new virtual or platform thread.\n@@ -36,3 +53,0 @@\n- *\n- * @requires vm.continuations\n- * @run main\/othervm\/native -agentlib:StopThreadTest StopThreadTest\n@@ -40,3 +54,0 @@\n-\n-import java.lang.AssertionError;\n-\n@@ -60,0 +71,1 @@\n+    static boolean is_virtual = true;\n@@ -72,0 +84,1 @@\n+        is_virtual = !(args.length > 0 && args[0].equals(\"platform\"));\n@@ -89,1 +102,5 @@\n-            testTaskThread = Thread.ofVirtual().name(\"TestTaskThread\").start(testTask);\n+            if (is_virtual) {\n+                testTaskThread = Thread.ofVirtual().name(\"TestTaskThread\").start(testTask);\n+            } else {\n+                testTaskThread = Thread.ofPlatform().name(\"TestTaskThread\").start(testTask);\n+            }\n@@ -92,6 +109,8 @@\n-            log(\"\\nMain #A.1: unsuspended\");\n-            retCode = stopThread(testTaskThread);\n-            if (retCode != THREAD_NOT_SUSPENDED) {\n-                throwFailed(\"Main #A.1: expected THREAD_NOT_SUSPENDED instead of: \" + retCode);\n-            } else {\n-                log(\"Main #A.1: got expected THREAD_NOT_SUSPENDED\");\n+            if (is_virtual) { \/\/ this check is for virtual target thread only\n+                log(\"\\nMain #A.1: unsuspended\");\n+                retCode = stopThread(testTaskThread);\n+                if (retCode != THREAD_NOT_SUSPENDED) {\n+                    throwFailed(\"Main #A.1: expected THREAD_NOT_SUSPENDED instead of: \" + retCode);\n+                } else {\n+                    log(\"Main #A.1: got expected THREAD_NOT_SUSPENDED\");\n+                }\n@@ -114,4 +133,6 @@\n-            log(\"\\nMain #B.1: unsuspended\");\n-            retCode = stopThread(testTaskThread);\n-            if (retCode != THREAD_NOT_SUSPENDED) {\n-                throwFailed(\"Main #B.1: expected THREAD_NOT_SUSPENDED instead of: \" + retCode);\n+            if (is_virtual) { \/\/ this check is for virtual target thread only\n+                log(\"\\nMain #B.1: unsuspended\");\n+                retCode = stopThread(testTaskThread);\n+                if (retCode != THREAD_NOT_SUSPENDED) {\n+                    throwFailed(\"Main #B.1: expected THREAD_NOT_SUSPENDED instead of: \" + retCode);\n+                }\n@@ -133,1 +154,2 @@\n-            \/\/ StopThread is expected to succeed.\n+            \/\/ StopThread is called from the test task (own thread) and expected to succeed.\n+            \/\/ No suspension of the test task thread is required or can be done in this case.\n@@ -188,0 +210,1 @@\n+            Thread.interrupted(); \/\/ Work around an issue that the interrupt bit can be not cleared.\n@@ -200,0 +223,1 @@\n+            Thread.interrupted(); \/\/ Work around an issue that the interrupt bit can be not cleared.\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/StopThreadTest\/StopThreadTest.java","additions":46,"deletions":22,"binary":false,"changes":68,"status":"modified"}]}