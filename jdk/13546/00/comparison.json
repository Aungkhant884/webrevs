{"files":[{"patch":"@@ -1895,1 +1895,1 @@\n-        Send the specified asynchronous exception to the specified platform thread.\n+        Send the specified asynchronous exception to the specified thread.\n@@ -1906,2 +1906,4 @@\n-              The <code>thread<\/code> may not be a virtual thread. Otherwise, the error code\n-              <errorlink id=\"JVMTI_ERROR_UNSUPPORTED_OPERATION\"><\/errorlink> will be returned.\n+              The <functionlink id=\"StopThread\"><\/functionlink> function may be used to send\n+              an asynchronous exception to a virtual thread when it is suspended at an event.\n+              An implementation may support sending an asynchronous exception to a suspended\n+              virtual thread in other cases.\n@@ -1918,2 +1920,6 @@\n-        <error id=\"JVMTI_ERROR_UNSUPPORTED_OPERATION\">\n-          <paramlink id=\"thread\"\/> is a virtual thread.\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread is a virtual thread and was not suspended and was not the current thread.\n+        <\/error>\n+        <error id=\"JVMTI_ERROR_OPAQUE_FRAME\">\n+          The thread is a suspended virtual thread and the implementation was unable\n+          to throw an asynchronous exception from this frame.\n@@ -11977,1 +11983,2 @@\n-      Information about the frame is not available (e.g. for native frames).\n+      Information about the frame is not available (e.g. for native frames),\n+      or the frame is not suitable for the requested operation.\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1193,3 +1193,9 @@\n-  if (thread_oop != nullptr && thread_oop->is_a(vmClasses::BaseVirtualThread_klass())) {\n-    \/\/ No support for virtual threads (yet).\n-    return JVMTI_ERROR_UNSUPPORTED_OPERATION;\n+  bool is_virtual = thread_oop != nullptr && thread_oop->is_a(vmClasses::BaseVirtualThread_klass());\n+\n+  if (is_virtual && !is_JavaThread_current(java_thread, thread_oop)) {\n+    if (!JvmtiVTSuspender::is_vthread_suspended(thread_oop)) {\n+      return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    }\n+    if (java_thread == nullptr) { \/\/ unmounted virtual thread\n+      return JVMTI_ERROR_OPAQUE_FRAME;\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java        8306467 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-svc-vthread.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,4 +118,0 @@\n-  LOG(\"Testing StopThread\\n\");\n-  err = jvmti->StopThread(vthread, vthread);\n-  check_jvmti_error_unsupported_operation(jni, \"StopThread\", err);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/BoundVThreadTest\/libBoundVThreadTest.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @summary Verifies JVMTI StopThread support for virtual threads.\n+ * DESCRIPTION\n+ *     The test exercises the JVMTI function: StopThread(jthread).\n+ *     The test creates a new virtual thread.\n+ *     Its method run() invokes the following methods:\n+ *      - method A() that is blocked on a monitor\n+ *      - method B() that is stopped at a brakepoint\n+ *      - method C() that forces agent to send AssertionError exception to its own thread\n+ *     All cases are using JVMTI StopThread to send an AssertionError object.\n+ *\n+ * @requires vm.continuations\n+ * @compile --enable-preview -source ${jdk.version} StopThreadTest.java\n+ * @run main\/othervm\/native --enable-preview -agentlib:StopThreadTest StopThreadTest\n+ *\/\n+\n+import java.lang.AssertionError;\n+\n+public class StopThreadTest {\n+    private static final String agentLib = \"StopThreadTest\";\n+    static final int JVMTI_ERROR_NONE = 0;\n+    static final int THREAD_NOT_SUSPENDED = 13;\n+    static final int PASSED = 0;\n+    static final int FAILED = 2;\n+\n+    static void log(String str) { System.out.println(str); }\n+\n+    static native void prepareAgent(Class taskClass, Object exceptionObject);\n+    static native void suspendThread(Thread thread);\n+    static native void resumeThread(Thread thread);\n+    static native void ensureAtBreakpoint();\n+    static native void notifyAtBreakpoint();\n+    static native int  stopThread(Thread thread);\n+\n+    static int status = PASSED;\n+\n+    static void setFailed() { status = FAILED; }\n+\n+    public static void main(String args[]) throws Exception {\n+        if (run(args) == FAILED) {\n+            throw new RuntimeException(\"StopThreadTest failed!\");\n+        }\n+        log(\"\\nStopThreadTest passed\");\n+    }\n+\n+    public static int run(String args[]) {\n+        TestTask testTask = new TestTask();\n+        Thread testTaskThread = null;\n+        AssertionError excObject = new AssertionError();\n+        int retCode;\n+\n+        prepareAgent(TestTask.class, excObject);\n+\n+        log(\"\\nMain #A: method A() must be blocked on entering a synchronized statement\");\n+        synchronized (TestTask.lock) {\n+            testTaskThread = Thread.ofVirtual().name(\"TestTaskThread\").start(testTask);\n+            testTask.ensureStarted();\n+\n+            log(\"\\nMain #A.1: unsuspended\");\n+            retCode = stopThread(testTaskThread);\n+            if (retCode != THREAD_NOT_SUSPENDED) {\n+                log(\"Failed: Main #A.1: expected THREAD_NOT_SUSPENDED instead of: \" + retCode);\n+                setFailed();\n+            } else {\n+                log(\"Main #A.1: got expected THREAD_NOT_SUSPENDED\");\n+            }\n+\n+            log(\"\\nMain #A.2: suspended\");\n+            suspendThread(testTaskThread);\n+            retCode = stopThread(testTaskThread);\n+            if (retCode != JVMTI_ERROR_NONE) {\n+                log(\"Failed: Main #A.2: expected JVMTI_ERROR_NONE instead of: \" + retCode);\n+                setFailed();\n+            } else {\n+                log(\"Main #A.2: got expected JVMTI_ERROR_NONE\");\n+            }\n+            resumeThread(testTaskThread);\n+        }\n+        log(\"\\nMain #B: method B() must be blocked in a breakpoint event handler\");\n+        {\n+            ensureAtBreakpoint();\n+\n+            log(\"\\nMain #B.1: unsuspended\");\n+            retCode = stopThread(testTaskThread);\n+            if (retCode != THREAD_NOT_SUSPENDED) {\n+                log(\"Failed: Main #B.1: expected THREAD_NOT_SUSPENDED instead of: \" + retCode);\n+                setFailed();\n+            }\n+\n+            log(\"\\nMain #B.2: suspended\");\n+            suspendThread(testTaskThread);\n+            retCode = stopThread(testTaskThread);\n+            if (retCode != JVMTI_ERROR_NONE) {\n+                log(\"Failed: Main #B.2: expected JVMTI_ERROR_NONE\");\n+                setFailed();\n+            }\n+            resumeThread(testTaskThread);\n+\n+            notifyAtBreakpoint();\n+        }\n+\n+        log(\"\\nMain #C: method C() sends AssertionError object to its own thread\");\n+        {\n+            \/\/ StopThread is expected to succeed.\n+            testTask.ensureFinished();\n+        }\n+\n+        try {\n+            testTaskThread.join();\n+        } catch (InterruptedException ex) {\n+            System.out.println(\"# Unexpected \" + ex);\n+            setFailed();\n+        }\n+        return status;\n+    }\n+\n+\n+    static class TestTask implements Runnable {\n+        static Object lock = new Object();\n+        static void log(String str) { System.out.println(str); }\n+\n+        private volatile boolean started = false;\n+        private volatile boolean finished = false;\n+\n+        static public void sleep(long millis) {\n+            try {\n+                Thread.sleep(millis);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Interruption in TestTask.sleep: \\n\\t\" + e);\n+            }\n+        }\n+\n+        \/\/ Ensure thread is ready.\n+        public void ensureStarted() {\n+            while (!started) {\n+                sleep(1);\n+            }\n+        }\n+\n+        \/\/ Ensure thread is finished.\n+        public void ensureFinished() {\n+            while (!finished) {\n+                sleep(1);\n+            }\n+        }\n+\n+        public void run() {\n+            log(\"TestTask.run: started\");\n+            started = true;\n+\n+            boolean seenExceptionFromA = false;\n+            try {\n+                A();\n+            } catch (AssertionError ex) {\n+                log(\"TestTask.run: caught expected AssertionError from method A()\");\n+                seenExceptionFromA = true;\n+            }\n+            if (!seenExceptionFromA) {\n+                log(\"Failed: TestTask.run: expected AssertionError from method A()\");\n+                StopThreadTest.setFailed();\n+            }\n+            sleep(1); \/\/ to cause yield\n+\n+            boolean seenExceptionFromB = false;\n+            try {\n+              B();\n+            } catch (AssertionError ex) {\n+                log(\"TestTask.run: caught expected AssertionError from method B()\");\n+                seenExceptionFromB = true;\n+            }\n+            if (!seenExceptionFromB) {\n+                log(\"Failed: TestTask.run: expected AssertionError from method B()\");\n+                StopThreadTest.setFailed();\n+            }\n+            sleep(1); \/\/ to cause yield\n+\n+            boolean seenExceptionFromC = false;\n+            try {\n+                C();\n+            } catch (AssertionError ex) {\n+                log(\"TestTask.run: caught expected AssertionError from method C()\");\n+                seenExceptionFromC = true;\n+            }\n+            if (!seenExceptionFromC) {\n+                log(\"Failed: TestTask.run: expected AssertionError from method C()\");\n+                StopThreadTest.setFailed();\n+            }\n+            finished = true;\n+        }\n+\n+        \/\/ Method is blocked on entering a synchronized statement.\n+        \/\/ StopThread is used to send an AssertionError object two times:\n+        \/\/  - when not suspended: THREAD_NOT_SUSPENDED is expected\n+        \/\/  - when suspended: JVMTI_ERROR_NONE is expected\n+        static void A() {\n+            log(\"TestTask.A: started\");\n+            synchronized (lock) {\n+            }\n+            log(\"TestTask.A: finished\");\n+        }\n+\n+        \/\/ A breakpoint is set at start of this method.\n+        \/\/ StopThread is used to send an AssertionError object two times:\n+        \/\/  - when not suspended: THREAD_NOT_SUSPENDED is expected\n+        \/\/  - when suspended: expected to succeed\n+        static void B() {\n+            log(\"TestTask.B: started\");\n+        }\n+\n+        \/\/ This method uses StopThread to send an AssertionError object to\n+        \/\/ its own thread. It is expected to succeed.\n+        static void C() {\n+            log(\"TestTask.C: started\");\n+            StopThreadTest.stopThread(Thread.currentThread());\n+            log(\"TestTask.C: finished\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/StopThreadTest\/StopThreadTest.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jmethodID mid_B = NULL;\n+static jobject exception_obj = NULL;\n+static jrawMonitorID monitor = NULL;\n+static volatile bool bp_sync_reached = false;\n+\n+static void JNICALL\n+Breakpoint(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread,\n+           jmethodID method, jlocation location) {\n+  jvmtiError err;\n+\n+  if (method != mid_B) {\n+    fatal(jni, \"Breakpoint: Failed with wrong location: expected in method TestTask.B()\");\n+  }\n+  err = jvmti->ClearBreakpoint(mid_B, 0);\n+  check_jvmti_status(jni, err, \"Breakpoint: Failed in JVMTI ClearBreakpoint\");\n+\n+  LOG(\"Breakpoint: In method TestTask.B(): before sync section enter\\n\");\n+\n+  err = jvmti->RawMonitorEnter(monitor);\n+  check_jvmti_status(jni, err, \"Breakpoint: Failed in RawMonitorEnter\");\n+\n+  bp_sync_reached = true;\n+\n+  \/\/ wait for notify from notifyAtBreakpoint or JVMTI_ERROR_INTERRUPT from JVMTI StopThread\n+  err = jvmti->RawMonitorWait(monitor, 0);\n+  if (err == JVMTI_ERROR_INTERRUPT) {\n+    LOG(\"Breakpoint: In method TestTask.B(): expected JVMTI_ERROR_INTERRUPT from RawMonitorWait\\n\");\n+  } else {\n+    check_jvmti_status(jni, err, \"Breakpoint: Failed in RawMonitorWait\");\n+  }\n+  err = jvmti->RawMonitorExit(monitor);\n+  check_jvmti_status(jni, err, \"Breakpoint: Failed in RawMonitorExit\");\n+\n+  LOG(\"Breakpoint: In method TestTask.B(): after sync section exit\\n\");\n+}\n+\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  static jvmtiCapabilities caps;\n+  static jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  LOG(\"Agent init\\n\");\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    LOG(\"Agent init: Failed in GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in GetPotentialCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in GetCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  if (!caps.can_generate_breakpoint_events) {\n+    LOG(\"Agent init: Failed: Breakpoint event is not implemented\\n\");\n+    return JNI_ERR;\n+  }\n+  callbacks.Breakpoint = &Breakpoint;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in SetEventCallbacks: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  monitor = create_raw_monitor(jvmti, \"Raw monitor to test\");\n+  return JNI_OK;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_StopThreadTest_prepareAgent(JNIEnv *jni, jclass cls, jclass task_clazz, jobject exc_obj) {\n+  jvmtiError err;\n+\n+  LOG(\"Main: prepareAgent started\\n\");\n+\n+  if (jvmti == NULL) {\n+    fatal(jni, \"prepareAgent: Failed as JVMTI client was not properly loaded!\\n\");\n+  }\n+  exception_obj = jni->NewGlobalRef(exc_obj);\n+  if (exception_obj == NULL) {\n+    fatal(jni, \"prepareAgent: Failed in JNI NewGlobalRef\\n\");\n+  }\n+  mid_B = jni->GetStaticMethodID(task_clazz, \"B\", \"()V\");\n+  if (mid_B == NULL) {\n+    fatal(jni, \"prepareAgent: Failed to find Method ID for method: TestTask.B()\\n\");\n+  }\n+  err = jvmti->SetBreakpoint(mid_B, 0);\n+  check_jvmti_status(jni, err, \"prepareAgent: Failed in JVMTI SetBreakpoint\");\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  check_jvmti_status(jni, err, \"prepareAgent: Failed to enable BREAKPOINT event\");\n+\n+  LOG(\"Main: prepareAgent finished\\n\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_StopThreadTest_suspendThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  LOG(\"Main: suspendThread\\n\");\n+  jvmtiError err = jvmti->SuspendThread(thread);\n+  check_jvmti_status(jni, err, \"Agent suspendThread: Failed in JVMTI SuspendThread\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_StopThreadTest_resumeThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  LOG(\"Main: resumeThread\\n\");\n+  jvmtiError err = jvmti->ResumeThread(thread);\n+  check_jvmti_status(jni, err, \"Agent resumeThread: Failed in JVMTI ResumeThread\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_StopThreadTest_stopThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  jvmtiError err = jvmti->StopThread(thread, exception_obj);\n+  LOG(\"Main: stopThread: StopThread returned code: %s (%d)\\n\", TranslateError(err), err);\n+  return (jint)err;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_StopThreadTest_ensureAtBreakpoint(JNIEnv *jni, jclass cls) {\n+  jvmtiError err;\n+  bool need_stop = false;\n+\n+  LOG(\"Main: ensureAtBreakpoint\\n\");\n+\n+  while (!need_stop) {\n+    err = jvmti->RawMonitorEnter(monitor);\n+    check_jvmti_status(jni, err, \"ensureAtBreakpoint: Failed in RawMonitorEnter\");\n+\n+    need_stop = bp_sync_reached;\n+\n+    err = jvmti->RawMonitorExit(monitor);\n+    check_jvmti_status(jni, err, \"ensureAtBreakpoint: Failed in RawMonitorExit\");\n+\n+    sleep_ms(1); \/\/ 1 millisecond\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_StopThreadTest_notifyAtBreakpoint(JNIEnv *jni, jclass cls) {\n+  jvmtiError err;\n+\n+  LOG(\"Main: notifyAtBreakpoint\\n\");\n+\n+  err = jvmti->RawMonitorEnter(monitor);\n+  check_jvmti_status(jni, err, \"notifyAtBreakpoint: Fatal Error in RawMonitorEnter\");\n+\n+  err = jvmti->RawMonitorNotify(monitor);\n+  check_jvmti_status(jni, err, \"notifyAtBreakpoint: Fatal Error in RawMonitorNotify\");\n+\n+  err = jvmti->RawMonitorExit(monitor);\n+  check_jvmti_status(jni, err, \"notifyAtBreakpoint: Fatal Error in RawMonitorExit\");\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/StopThreadTest\/libStopThreadTest.cpp","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -26,1 +26,2 @@\n- * @summary Verifies that specific JVMTI functions returns JVMTI_ERROR_INVALID_THREAD if called with virtual threads.\n+ * @summary Verifies that specific JVMTI functions return UNSUPPORTED_OPERATION\n+ *          or OPAQUE_FRAME if called with virtual threads.\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadUnsupportedTest\/VThreadUnsupportedTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,2 @@\n- * Execute JVMTI functions which currently don't support vthreads and check that they\n- * return error code JVMTI_ERROR_INVALID_THREAD or JVMTI_ERROR_OPAQUE_FRAME correctly.\n+ * Execute JVMTI functions that don't support vthreads and check they return error\n+ * code JVMTI_ERROR_UNSUPPORTED_OPERATION or JVMTI_ERROR_OPAQUE_FRAME correctly.\n@@ -90,4 +90,0 @@\n-  LOG(\"Testing StopThread\\n\");\n-  err = jvmti->StopThread(vthread, vthread);\n-  check_jvmti_error_unsupported_operation(jni, \"StopThread\", err);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadUnsupportedTest\/libVThreadUnsupportedTest.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}