{"files":[{"patch":"@@ -64,0 +64,1 @@\n+#include \"gc\/g1\/heapRegion.hpp\"\n@@ -292,0 +293,9 @@\n+bool HeapShared::is_too_large_to_archive(oop o) {\n+  \/\/ TODO: To make the CDS heap mappable for all collectors, this function should\n+  \/\/ reject objects that may be too large for *any* collector.\n+  assert(UseG1GC, \"implementation limitation\");\n+  size_t sz = align_up(o->size() * HeapWordSize, ObjectAlignmentInBytes);\n+  size_t max = \/*G1*\/HeapRegion::min_region_size_in_words() * HeapWordSize;\n+  return (sz > max);\n+}\n+\n@@ -446,1 +456,8 @@\n-        ik->constants()->archive_resolved_references();\n+        oop rr = ik->constants()->prepare_resolved_references_for_archiving();\n+        if (rr != nullptr && !is_too_large_to_archive(rr)) {\n+          oop archived_obj = HeapShared::archive_reachable_objects_from(1, _default_subgraph_info, rr,\n+                                                                        \/*is_closed_archive=*\/false);\n+          assert(archived_obj != NULL,  \"already checked not too large to archive\");\n+          int root_index = append_root(archived_obj);\n+          ik->constants()->cache()->set_archived_references(root_index);\n+        }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -374,0 +374,1 @@\n+  static bool is_too_large_to_archive(oop o);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -270,2 +270,3 @@\n-\/\/ Archive the resolved references\n-void ConstantPool::archive_resolved_references() {\n+\/\/ Returns the _resolved_reference array after removing unarchivable items from it.\n+\/\/ Returns nullptr if this class is not supported, or _resolved_reference doesn't exist.\n+objArrayOop ConstantPool::prepare_resolved_references_for_archiving() {\n@@ -273,1 +274,1 @@\n-    return; \/\/ nothing to do\n+    return nullptr; \/\/ nothing to do\n@@ -281,1 +282,1 @@\n-    return;\n+    return nullptr;\n@@ -285,2 +286,2 @@\n-  Array<u2>* ref_map = reference_map();\n-  if (rr != NULL) {\n+  if (rr != nullptr) {\n+    Array<u2>* ref_map = reference_map();\n@@ -291,1 +292,1 @@\n-      rr->obj_at_put(i, NULL);\n+      rr->obj_at_put(i, nullptr);\n@@ -295,7 +296,5 @@\n-          oop archived_string = HeapShared::find_archived_heap_object(obj);\n-          \/\/ Update the reference to point to the archived copy\n-          \/\/ of this string.\n-          \/\/ If the string is too large to archive, NULL is\n-          \/\/ stored into rr. At run time, string_at_impl() will create and intern\n-          \/\/ the string.\n-          rr->obj_at_put(i, archived_string);\n+          assert(java_lang_String::is_instance(obj), \"must be\");\n+          typeArrayOop value = java_lang_String::value_no_keepalive(obj);\n+          if (!HeapShared::is_too_large_to_archive(value)) {\n+            rr->obj_at_put(i, obj);\n+          }\n@@ -305,8 +304,0 @@\n-\n-    oop archived = HeapShared::archive_object(rr);\n-    \/\/ If the resolved references array is not archived (too large),\n-    \/\/ the 'archived' object is NULL. No need to explicitly check\n-    \/\/ the return value of archive_object() here. At runtime, the\n-    \/\/ resolved references will be created using the normal process\n-    \/\/ when there is no archived value.\n-    _cache->set_archived_references(archived);\n@@ -314,0 +305,1 @@\n+  return rr;\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":14,"deletions":22,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -700,1 +700,1 @@\n-  void archive_resolved_references() NOT_CDS_JAVA_HEAP_RETURN;\n+  objArrayOop prepare_resolved_references_for_archiving() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -773,1 +773,1 @@\n-void ConstantPoolCache::set_archived_references(oop o) {\n+void ConstantPoolCache::set_archived_references(int root_index) {\n@@ -775,1 +775,1 @@\n-  _archived_references_index = HeapShared::append_root(o);\n+  _archived_references_index = root_index;\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-  void set_archived_references(oop o) NOT_CDS_JAVA_HEAP_RETURN;\n+  void set_archived_references(int root_index) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}