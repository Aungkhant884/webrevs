{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -817,1 +817,1 @@\n-            (resolved_klass == NULL ? \"<NULL>\" : resolved_klass->internal_name()),\n+            resolved_klass->internal_name(),\n@@ -973,5 +973,0 @@\n-  if (resolved_klass == NULL) {\n-    ResourceMark rm(THREAD);\n-    THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field->as_C_string());\n-  }\n-\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,4 +157,10 @@\n-    _name(name),\n-    _signature(signature), _resolved_klass(resolved_klass), _current_klass(current_klass), _current_method(methodHandle()),\n-    _check_access(check_access == AccessCheck::required),\n-    _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required), _tag(tag) {}\n+      _name(name),\n+      _signature(signature),\n+      _resolved_klass(resolved_klass),\n+      _current_klass(current_klass),\n+      _current_method(methodHandle()),\n+      _check_access(check_access == AccessCheck::required),\n+      _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required),\n+      _tag(tag) {\n+    assert(_resolved_klass != nullptr, \"must always have a resolved_klass\");\n+  }\n@@ -166,5 +172,3 @@\n-    _name(name),\n-    _signature(signature), _resolved_klass(resolved_klass), _current_klass(current_method->method_holder()), _current_method(current_method),\n-    _check_access(check_access == AccessCheck::required),\n-    _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required), _tag(tag) {}\n-\n+    LinkInfo(resolved_klass, name, signature, current_method->method_holder(), check_access, check_loader_constraints, tag) {\n+    _current_method = current_method;\n+  }\n@@ -172,1 +176,1 @@\n-  \/\/ Case where we just find the method and don't check access against the current class\n+  \/\/ Case where we just find the method and don't check access against the current class, used by JavaCalls\n@@ -174,3 +178,2 @@\n-    _name(name),\n-    _signature(signature), _resolved_klass(resolved_klass), _current_klass(NULL), _current_method(methodHandle()),\n-    _check_access(false), _check_loader_constraints(false), _tag(JVM_CONSTANT_Invalid) {}\n+    LinkInfo(resolved_klass, name, signature, nullptr, AccessCheck::skip, LoaderConstraintCheck::skip,\n+             JVM_CONSTANT_Invalid) {}\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"}]}