{"files":[{"patch":"@@ -2281,0 +2281,5 @@\n+        @Override\n+        public Name name() {\n+            return name;\n+        }\n+\n@@ -2319,0 +2324,5 @@\n+        @Override\n+        public Name name() {\n+            return name;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -137,0 +137,5 @@\n+        \/**\n+         * The dynamic constant's name.\n+         *\/\n+        Name name();\n+\n@@ -153,1 +158,1 @@\n-            return new Pair<>(bsmKey(types), dynamicType().poolKey(types));\n+            return new PoolKey(name(), bsmKey(types), dynamicType().poolKey(types));\n@@ -195,0 +200,2 @@\n+\n+        record PoolKey(Name name, BsmKey bsmKey, Object dynamicType) {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolConstant.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277634\n+ * @summary Verify the correct constantpool entries are created for invokedynamic instructions using\n+ *          the same bootstrap and type, but different name.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.jvm\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.JarTask toolbox.JavacTask toolbox.JavapTask toolbox.ToolBox\n+ * @run main IndyCorrectInvocationName\n+ *\/\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.Plugin;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.BootstrapMethods_attribute;\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.Code_attribute;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_InvokeDynamic_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_NameAndType_info;\n+import com.sun.tools.classfile.Instruction;\n+\n+import com.sun.tools.javac.api.BasicJavacTask;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.jvm.PoolConstant;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\n+import com.sun.tools.javac.tree.JCTree.JCLiteral;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Names;\n+\n+import toolbox.JarTask;\n+import toolbox.ToolBox;\n+\n+\n+public class IndyCorrectInvocationName implements Plugin {\n+    private static final String NL = System.lineSeparator();\n+\n+    public static void main(String... args) throws Exception {\n+        new IndyCorrectInvocationName().run();\n+    }\n+\n+    void run() throws Exception {\n+        ToolBox tb = new ToolBox();\n+        Path pluginClasses = Path.of(\"plugin-classes\");\n+        tb.writeFile(pluginClasses.resolve(\"META-INF\").resolve(\"services\").resolve(Plugin.class.getName()),\n+                IndyCorrectInvocationName.class.getName() + System.lineSeparator());\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(Path.of(ToolBox.testClasses))) {\n+            for (Path p : ds) {\n+                if (p.getFileName().toString().startsWith(\"IndyCorrectInvocationName\") ||\n+                    p.getFileName().toString().endsWith(\".class\")) {\n+                    Files.copy(p, pluginClasses.resolve(p.getFileName()));\n+                }\n+            }\n+        }\n+\n+        Path pluginJar = Path.of(\"plugin.jar\");\n+        new JarTask(tb, pluginJar)\n+                .baseDir(pluginClasses)\n+                .files(\".\")\n+                .run();\n+\n+        Path src = Path.of(\"src\");\n+            tb.writeJavaFiles(src,\n+                    \"\"\"\n+                    import java.lang.invoke.CallSite;\n+                    import java.lang.invoke.ConstantCallSite;\n+                    import java.lang.invoke.MethodHandles;\n+                    import java.lang.invoke.MethodHandles.Lookup;\n+                    import java.lang.invoke.MethodType;\n+                    public class Test{\n+                        private static final String NL = System.lineSeparator();\n+                        private static StringBuilder output = new StringBuilder();\n+                        public static void doRun() {\n+                            method(\"a\");\n+                            method(\"b\");\n+                            method(\"a\");\n+                            method(\"b\");\n+                        }\n+                        public static String run() {\n+                            doRun();\n+                            return output.toString();\n+                        }\n+                        public static void method(String name) {}\n+                        public static void actualMethod(String name) {\n+                            output.append(name).append(NL);\n+                        }\n+                        public static CallSite bootstrap(Lookup lookup, String name, MethodType type) throws Exception {\n+                            return new ConstantCallSite(MethodHandles.lookup()\n+                                                                     .findStatic(Test.class,\n+                                                                                 \"actualMethod\",\n+                                                                                 MethodType.methodType(void.class,\n+                                                                                                       String.class))\n+                                                                     .bindTo(name));\n+                        }\n+                    }\n+                    \"\"\");\n+        Path classes = Files.createDirectories(Path.of(\"classes\"));\n+\n+        new toolbox.JavacTask(tb)\n+                .classpath(pluginJar)\n+                .options(\"-XDaccessInternalAPI\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+\n+        URLClassLoader cl = new URLClassLoader(new URL[] {classes.toUri().toURL()});\n+\n+        String actual = (String) cl.loadClass(\"Test\")\n+                                   .getMethod(\"run\")\n+                                   .invoke(null);\n+        String expected = \"a\" + NL + \"b\" + NL + \"a\" + NL +\"b\" + NL;\n+        if (!Objects.equals(actual, expected)) {\n+            throw new AssertionError(\"expected: \" + expected + \"; but got: \" + actual);\n+        }\n+\n+        Path testClass = classes.resolve(\"Test.class\");\n+        ClassFile cf = ClassFile.read(testClass);\n+        BootstrapMethods_attribute bootAttr =\n+                (BootstrapMethods_attribute) cf.attributes.get(Attribute.BootstrapMethods);\n+        if (bootAttr.bootstrap_method_specifiers.length != 1) {\n+            throw new AssertionError(\"Incorrect number of bootstrap methods: \" +\n+                                     bootAttr.bootstrap_method_specifiers.length);\n+        }\n+        Code_attribute codeAttr =\n+                (Code_attribute) cf.methods[1].attributes.get(Attribute.Code);\n+        Set<Integer> seenBootstraps = new HashSet<>();\n+        Set<Integer> seenNameAndTypes = new HashSet<>();\n+        Set<String> seenNames = new HashSet<>();\n+        for (Instruction i : codeAttr.getInstructions()) {\n+            switch (i.getOpcode()) {\n+                case INVOKEDYNAMIC -> {\n+                    int idx = i.getUnsignedShort(1);\n+                    CONSTANT_InvokeDynamic_info dynamicInfo =\n+                            (CONSTANT_InvokeDynamic_info) cf.constant_pool.get(idx);\n+                    seenBootstraps.add(dynamicInfo.bootstrap_method_attr_index);\n+                    seenNameAndTypes.add(dynamicInfo.name_and_type_index);\n+                    CONSTANT_NameAndType_info nameAndTypeInfo =\n+                            cf.constant_pool.getNameAndTypeInfo(dynamicInfo.name_and_type_index);\n+                    seenNames.add(nameAndTypeInfo.getName());\n+                }\n+                case RETURN -> {}\n+                default -> throw new AssertionError(\"Unexpected instruction: \" + i.getOpcode());\n+            }\n+            }\n+        if (seenBootstraps.size() != 1) {\n+            throw new AssertionError(\"Unexpected bootstraps: \" + seenBootstraps);\n+        }\n+        if (seenNameAndTypes.size() != 2) {\n+            throw new AssertionError(\"Unexpected names and types: \" + seenNameAndTypes);\n+        }\n+        if (!seenNames.equals(Set.of(\"a\", \"b\"))) {\n+            throw new AssertionError(\"Unexpected names and types: \" + seenNames);\n+        }\n+    }\n+\n+    \/\/ Plugin impl...\n+\n+    @Override\n+    public String getName() { return \"IndyCorrectInvocationName\"; }\n+\n+    @Override\n+    public void init(JavacTask task, String... args) {\n+        Context c = ((BasicJavacTask) task).getContext();\n+        task.addTaskListener(new TaskListener() {\n+            @Override\n+            public void started(TaskEvent e) {\n+                if (e.getKind() == TaskEvent.Kind.GENERATE) {\n+                    convert(c, (JCCompilationUnit) e.getCompilationUnit());\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean autoStart() {\n+        return true;\n+    }\n+\n+    private void convert(Context context, JCCompilationUnit toplevel) {\n+        TreeMaker make = TreeMaker.instance(context);\n+        Names names = Names.instance(context);\n+        Symtab syms = Symtab.instance(context);\n+        new TreeScanner() {\n+            MethodSymbol bootstrap;\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                bootstrap = (MethodSymbol) tree.sym.members().getSymbolsByName(names.fromString(\"bootstrap\")).iterator().next();\n+                super.visitClassDef(tree);\n+            }\n+            @Override\n+            public void visitApply(JCMethodInvocation tree) {\n+                if (tree.args.size() == 1 && tree.args.head.hasTag(Tag.LITERAL)) {\n+                    String name = (String) ((JCLiteral) tree.args.head).value;\n+                    Type.MethodType indyType = new Type.MethodType(\n+                            com.sun.tools.javac.util.List.nil(),\n+                            syms.voidType,\n+                            com.sun.tools.javac.util.List.nil(),\n+                            syms.methodClass\n+                    );\n+                    Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.fromString(name),\n+                            syms.noSymbol,\n+                            bootstrap.asHandle(),\n+                            indyType,\n+                            new PoolConstant.LoadableConstant[0]);\n+\n+                    JCTree.JCFieldAccess qualifier = make.Select(make.QualIdent(bootstrap.owner), dynSym.name);\n+                    qualifier.sym = dynSym;\n+                    qualifier.type = syms.voidType;\n+                    tree.meth = qualifier;\n+                    tree.args = com.sun.tools.javac.util.List.nil();\n+                    tree.type = syms.voidType;\n+                }\n+                super.visitApply(tree);\n+            }\n+\n+        }.scan(toplevel);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/classwriter\/IndyCorrectInvocationName.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"}]}