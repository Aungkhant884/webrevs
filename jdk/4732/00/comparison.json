{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-      live = new (Compile::current()->comp_arena()->Amalloc_D(sizeof(RegMask))) RegMask();\n+      live = new (Compile::current()->comp_arena()->Amalloc_4(sizeof(RegMask))) RegMask();\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,4 +35,2 @@\n-\/\/ The byte alignment to be used by Arena::Amalloc.  See bugid 4169348.\n-\/\/ Note: this value must be a power of 2\n-\n-#define ARENA_AMALLOC_ALIGNMENT (2*BytesPerWord)\n+\/\/ The byte alignment to be used by Arena::Amalloc.\n+#define ARENA_AMALLOC_ALIGNMENT BytesPerLong\n@@ -139,1 +137,2 @@\n-  \/\/ Fast allocate in the arena.  Common case is: pointer test + increment.\n+  \/\/ Fast allocate in the arena.  Common case aligns to the size of long which is 64 bits\n+  \/\/ on both 32 and 64 bit platforms. Required for atomic long operations on 32 bits.\n@@ -154,1 +153,3 @@\n-  \/\/ Further assume size is padded out to words\n+\n+  \/\/ Allocate in the arena, assuming the size has been aligned to size of pointer, which\n+  \/\/ is 4 bytes on 32 bits, hence the name.\n@@ -156,1 +157,1 @@\n-    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n+    assert((x & (sizeof(char*)-1)) == 0, \"misaligned size\");\n@@ -169,16 +170,0 @@\n-  \/\/ Allocate with 'double' alignment. It is 8 bytes on sparc.\n-  \/\/ In other cases Amalloc_D() should be the same as Amalloc_4().\n-  void* Amalloc_D(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {\n-    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n-    debug_only(if (UseMallocOnly) return malloc(x);)\n-    if (!check_for_overflow(x, \"Arena::Amalloc_D\", alloc_failmode))\n-      return NULL;\n-    if (_hwm + x > _max) {\n-      return grow(x, alloc_failmode); \/\/ grow() returns a result aligned >= 8 bytes.\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    return C->node_arena()->Amalloc_D(x);\n+    return C->node_arena()->Amalloc_4(x);\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-  RegMask *rms = (RegMask*)C->comp_arena()->Amalloc_D(sizeof(RegMask) * NOF_STACK_MASKS);\n+  RegMask *rms = (RegMask*)C->comp_arena()->Amalloc_4(sizeof(RegMask) * NOF_STACK_MASKS);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-    _in = (Node **) ((char *) (C->node_arena()->Amalloc_D(req * sizeof(void*))));\n+    _in = (Node **) ((char *) (C->node_arena()->Amalloc_4(req * sizeof(void*))));\n@@ -502,1 +502,1 @@\n-  Node *n = (Node*)C->node_arena()->Amalloc_D(size_of() + _max*sizeof(Node*));\n+  Node *n = (Node*)C->node_arena()->Amalloc_4(size_of() + _max*sizeof(Node*));\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-    Node* n = (Node*)C->node_arena()->Amalloc_D(x);\n+    Node* n = (Node*)C->node_arena()->Amalloc_4(x);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    return compile->type_arena()->Amalloc_D(x);\n+    return compile->type_arena()->Amalloc_4(x);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}