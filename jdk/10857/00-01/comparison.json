{"files":[{"patch":"@@ -729,1 +729,1 @@\n-      \/\/ If realloc(3) failed, the old block still exists. We must re-instantiate the old\n+      \/\/ If realloc(3) failed, the old block still exists. We must revive the old\n@@ -732,2 +732,1 @@\n-      void* p = MemTracker::record_malloc(old_outer_ptr, old_size, memflags, stack);\n-      assert(p == memblock, \"sanity\");\n+      MallocTracker::revert_record_free(memblock);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -128,0 +128,4 @@\n+  \/\/ Given a memory block that has been marked as dead (via MallocHeader::mark_block_as_dead())\n+  \/\/ but has otherwise not been touched, revive it by reconstructing the canaries.\n+  inline void revive_block();\n+\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  \/\/ Note: the header may be revived later (see MallocHeader::revive_bloc()). Only\n+  \/\/ touch the canaries here, leave the other fields alone!\n@@ -54,0 +56,13 @@\n+inline void MallocHeader::revive_block() {\n+  \/\/ We expect the header to be marked as dead. All other fields shall still be valid,\n+  \/\/ see MallocHeader::mark_block_as_dead().\n+  assert(_canary == _header_canary_dead_mark, \"Expected dead header canary\");\n+  assert(get_footer() == _footer_canary_dead_mark, \"Expected dead footer canary\");\n+  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"Expected the alt canary to be dead\"));\n+\n+  _canary = _header_canary_life_mark;\n+  set_footer(_footer_canary_life_mark);\n+  NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n+}\n+\n+\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -250,0 +252,12 @@\n+\/\/ Revert a previous memory deallocation. This is to handle realloc failures where\n+\/\/ the original block is still intact.\n+void MallocSiteTable::revert_deallocation_at(size_t size, uint32_t marker) {\n+  MallocSite* site = malloc_site(marker);\n+  \/\/ Should not happen - MST entries are never removed, so the entry described by the marker must\n+  \/\/ exist.\n+  assert(site != nullptr, \"Cannot find MST entry for marker \" UINT32_FORMAT_X_0 \".\", marker);\n+  if (site != NULL) {\n+    site->allocate(size);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -163,0 +163,4 @@\n+  \/\/ Revert a previous memory deallocation. This is to handle realloc failures where\n+  \/\/ the original block is still intact.\n+  static void revert_deallocation_at(size_t size, uint32_t marker);\n+\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -214,0 +214,16 @@\n+void MallocTracker::revert_record_free(void* memblock) {\n+  assert(MemTracker::enabled(), \"Sanity\");\n+  assert(memblock != NULL, \"precondition\");\n+\n+  \/\/ We expect the malloc header to still exist, but its canaries to hold\n+  \/\/ the \"dead\" markers (see record_free()). Everything else in the header\n+  \/\/ shall still be valid. In particular, we expect the mst marker to be\n+  \/\/ valid.\n+  MallocHeader* const header = malloc_header(memblock);\n+  header->revive_block();\n+  MallocMemorySummary::record_malloc(header->size(), header->flags());\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::revert_deallocation_at(header->size(), header->mst_marker());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -297,0 +297,5 @@\n+  \/\/ Revert a previous record_free() operation on a memblock that has not been freed.\n+  \/\/ The memblock must still be valid.\n+  \/\/ This handles the case of failed realloc(3) calls.\n+  static void revert_record_free(void* memblock);\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,1 +53,3 @@\n-\/\/ Convenience asserts\n+\/\/ Mimicking the official ASSERT_xx and EXPECT_xx counterparts of the googletest suite.\n+\/\/ (ASSERT|EXPECT)_NOT_NULL: check that the given pointer is not NULL\n+\/\/ (ASSERT|EXPECT)_NULL: check that the given pointer is NULL\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}