{"files":[{"patch":"@@ -729,1 +729,1 @@\n-      \/\/ If realloc(3) failed, the old block still exists. We must revive the old\n+      \/\/ If realloc(3) failed, the old block still exists. We must re-instantiate the old\n@@ -732,1 +732,2 @@\n-      MallocTracker::revert_record_free(memblock);\n+      void* p = MemTracker::record_malloc(old_outer_ptr, old_size, memflags, stack);\n+      assert(p == memblock, \"sanity\");\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -128,4 +128,0 @@\n-  \/\/ Given a memory block that has been marked as dead (via MallocHeader::mark_block_as_dead())\n-  \/\/ but has otherwise not been touched, revive it by reconstructing the canaries.\n-  inline void revive_block();\n-\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-  \/\/ Note: the header may be revived later (see MallocHeader::revive_bloc()). Only\n-  \/\/ touch the canaries here, leave the other fields alone!\n@@ -56,13 +54,0 @@\n-inline void MallocHeader::revive_block() {\n-  \/\/ We expect the header to be marked as dead. All other fields shall still be valid,\n-  \/\/ see MallocHeader::mark_block_as_dead().\n-  assert(_canary == _header_canary_dead_mark, \"Expected dead header canary\");\n-  assert(get_footer() == _footer_canary_dead_mark, \"Expected dead footer canary\");\n-  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"Expected the alt canary to be dead\"));\n-\n-  _canary = _header_canary_life_mark;\n-  set_footer(_footer_canary_life_mark);\n-  NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n-}\n-\n-\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -252,12 +250,0 @@\n-\/\/ Revert a previous memory deallocation. This is to handle realloc failures where\n-\/\/ the original block is still intact.\n-void MallocSiteTable::revert_deallocation_at(size_t size, uint32_t marker) {\n-  MallocSite* site = malloc_site(marker);\n-  \/\/ Should not happen - MST entries are never removed, so the entry described by the marker must\n-  \/\/ exist.\n-  assert(site != nullptr, \"Cannot find MST entry for marker \" UINT32_FORMAT_X_0 \".\", marker);\n-  if (site != NULL) {\n-    site->allocate(size);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -163,4 +163,0 @@\n-  \/\/ Revert a previous memory deallocation. This is to handle realloc failures where\n-  \/\/ the original block is still intact.\n-  static void revert_deallocation_at(size_t size, uint32_t marker);\n-\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -214,16 +214,0 @@\n-void MallocTracker::revert_record_free(void* memblock) {\n-  assert(MemTracker::enabled(), \"Sanity\");\n-  assert(memblock != NULL, \"precondition\");\n-\n-  \/\/ We expect the malloc header to still exist, but its canaries to hold\n-  \/\/ the \"dead\" markers (see record_free()). Everything else in the header\n-  \/\/ shall still be valid. In particular, we expect the mst marker to be\n-  \/\/ valid.\n-  MallocHeader* const header = malloc_header(memblock);\n-  header->revive_block();\n-  MallocMemorySummary::record_malloc(header->size(), header->flags());\n-  if (MemTracker::tracking_level() == NMT_detail) {\n-    MallocSiteTable::revert_deallocation_at(header->size(), header->mst_marker());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -297,5 +297,0 @@\n-  \/\/ Revert a previous record_free() operation on a memblock that has not been freed.\n-  \/\/ The memblock must still be valid.\n-  \/\/ This handles the case of failed realloc(3) calls.\n-  static void revert_record_free(void* memblock);\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}