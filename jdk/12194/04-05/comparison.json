{"files":[{"patch":"@@ -866,0 +866,3 @@\n+\/\/ Once started the code cache marking cycle must only be finished after marking of\n+\/\/ the java heap is complete. Otherwise nmethods could appear to be not on stack even\n+\/\/ if they have frames in continuation StackChunks that were not yet visited.\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3370,16 +3370,8 @@\n-void G1CollectedHeap::start_codecache_marking_cycle_if_inactive(bool full_gc) {\n-  \/\/ We can reach here with an active code cache marking cycle either because\n-  \/\/ the previous G1 concurrent marking cycle\n-  \/\/\n-  \/\/ (1) was aborted and a full gc is about to begin or\n-  \/\/ (2) it was undone because the heap occupancy was below the threshold after\n-  \/\/     the initiating young gc (see G1ConcurrentMark::post_concurrent_undo_start())\n-  \/\/\n-  \/\/ Especially in case (2) it is important that the active codecache cycle was not\n-  \/\/ finished when executing the G1 undo operation. If it was (repeatedly) finished\n-  \/\/ then nmethods with frames in continuation StackChunks could appear as not\n-  \/\/ on stack because they were not marked as on stack in the undone concurrent marking.\n-  \/\/\n-  \/\/ Also for (2) it is important to arm nmethod entry barriers even if no new\n-  \/\/ code cache cycle is started. They are needed for a complete SATB. A full gc\n-  \/\/ on the other hand doesn't need the barriers at all.\n+void G1CollectedHeap::start_codecache_marking_cycle_if_inactive(bool concurrent_marking_start) {\n+  \/\/ We can reach here with an active code cache marking cycle either because the\n+  \/\/ previous G1 concurrent marking cycle was undone (if heap occupancy after the\n+  \/\/ concurrent start young collection was below the threshold) or aborted. See\n+  \/\/ CodeCache::on_gc_marking_cycle_finish() why this is.  We must not start a new code\n+  \/\/ cache cycle then. If we are about to start a new g1 concurrent marking cycle we\n+  \/\/ still have to arm all nmethod entry barriers. They are needed for adding oop\n+  \/\/ constants to the SATB snapshot. Full GC does not need nmethods to be armed.\n@@ -3389,1 +3381,1 @@\n-  if (!full_gc) {\n+  if (concurrent_marking_start) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -936,1 +936,1 @@\n-  static void start_codecache_marking_cycle_if_inactive(bool full_gc);\n+  static void start_codecache_marking_cycle_if_inactive(bool concurrent_marking_start);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-  G1CollectedHeap::start_codecache_marking_cycle_if_inactive(false \/* full_gc *\/);\n+  G1CollectedHeap::start_codecache_marking_cycle_if_inactive(true \/* concurrent_marking_start *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  G1CollectedHeap::start_codecache_marking_cycle_if_inactive(true \/* full_gc *\/);\n+  G1CollectedHeap::start_codecache_marking_cycle_if_inactive(false \/* concurrent_marking_start *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}