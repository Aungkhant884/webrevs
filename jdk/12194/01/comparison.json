{"files":[{"patch":"@@ -3372,6 +3372,0 @@\n-    \/\/ This is the normal case when we do not call collect when a\n-    \/\/ concurrent mark is ongoing. We then start a new code marking\n-    \/\/ cycle. If, on the other hand, a concurrent mark is ongoing, we\n-    \/\/ will be conservative and use the last code marking cycle. Code\n-    \/\/ caches marked between the two concurrent marks will live a bit\n-    \/\/ longer than needed.\n@@ -3380,0 +3374,3 @@\n+  } else {\n+    assert(G1CollectedHeap::heap()->concurrent_mark()->has_aborted(),\n+           \"Expected full gc after concurrent mark has aborted\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -795,1 +795,2 @@\n-  G1CollectedHeap::start_codecache_marking_cycle_if_inactive();\n+  CodeCache::on_gc_marking_cycle_start();\n+  CodeCache::arm_all_nmethods();\n@@ -827,0 +828,2 @@\n+  CodeCache::on_gc_marking_cycle_finish();\n+  CodeCache::arm_all_nmethods();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}