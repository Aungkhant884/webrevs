{"files":[{"patch":"@@ -3372,8 +3372,4 @@\n-    \/\/ This is the normal case when we do not call collect when a\n-    \/\/ concurrent mark is ongoing. We then start a new code marking\n-    \/\/ cycle. If, on the other hand, a concurrent mark is ongoing, we\n-    \/\/ will be conservative and use the last code marking cycle. Code\n-    \/\/ caches marked between the two concurrent marks will live a bit\n-    \/\/ longer than needed.\n-    CodeCache::on_gc_marking_cycle_start();\n-    CodeCache::arm_all_nmethods();\n+    start_codecache_marking_cycle();\n+  } else {\n+    assert(G1CollectedHeap::heap()->concurrent_mark()->has_aborted(),\n+           \"Expected full gc after concurrent mark has aborted\");\n@@ -3382,0 +3378,5 @@\n+\n+void G1CollectedHeap::start_codecache_marking_cycle() {\n+  CodeCache::on_gc_marking_cycle_start();\n+  CodeCache::arm_all_nmethods();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -936,0 +936,1 @@\n+  static void start_codecache_marking_cycle();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-  G1CollectedHeap::start_codecache_marking_cycle_if_inactive();\n+  G1CollectedHeap::start_codecache_marking_cycle();\n@@ -827,0 +827,2 @@\n+  CodeCache::on_gc_marking_cycle_finish();\n+  CodeCache::arm_all_nmethods();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}