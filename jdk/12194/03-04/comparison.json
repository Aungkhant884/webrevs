{"files":[{"patch":"@@ -3370,1 +3370,16 @@\n-void G1CollectedHeap::start_codecache_marking_cycle_if_inactive() {\n+void G1CollectedHeap::start_codecache_marking_cycle_if_inactive(bool full_gc) {\n+  \/\/ We can reach here with an active code cache marking cycle either because\n+  \/\/ the previous G1 concurrent marking cycle\n+  \/\/\n+  \/\/ (1) was aborted and a full gc is about to begin or\n+  \/\/ (2) it was undone because the heap occupancy was below the threshold after\n+  \/\/     the initiating young gc (see G1ConcurrentMark::post_concurrent_undo_start())\n+  \/\/\n+  \/\/ Especially in case (2) it is important that the active codecache cycle was not\n+  \/\/ finished when executing the G1 undo operation. If it was (repeatedly) finished\n+  \/\/ then nmethods with frames in continuation StackChunks could appear as not\n+  \/\/ on stack because they were not marked as on stack in the undone concurrent marking.\n+  \/\/\n+  \/\/ Also for (2) it is important to arm nmethod entry barriers even if no new\n+  \/\/ code cache cycle is started. They are needed for a complete SATB. A full gc\n+  \/\/ on the other hand doesn't need the barriers at all.\n@@ -3372,4 +3387,4 @@\n-    start_codecache_marking_cycle();\n-  } else {\n-    assert(G1CollectedHeap::heap()->concurrent_mark()->has_aborted(),\n-           \"Expected full gc after concurrent mark has aborted\");\n+    CodeCache::on_gc_marking_cycle_start();\n+  }\n+  if (!full_gc) {\n+    CodeCache::arm_all_nmethods();\n@@ -3377,5 +3392,0 @@\n-}\n-\n-void G1CollectedHeap::start_codecache_marking_cycle() {\n-  CodeCache::on_gc_marking_cycle_start();\n-  CodeCache::arm_all_nmethods();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -936,2 +936,1 @@\n-  static void start_codecache_marking_cycle();\n-  static void start_codecache_marking_cycle_if_inactive();\n+  static void start_codecache_marking_cycle_if_inactive(bool full_gc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-  G1CollectedHeap::start_codecache_marking_cycle();\n+  G1CollectedHeap::start_codecache_marking_cycle_if_inactive(false \/* full_gc *\/);\n@@ -827,1 +827,0 @@\n-  G1CollectedHeap::finish_codecache_marking_cycle();\n@@ -1304,0 +1303,2 @@\n+\n+    G1CollectedHeap::finish_codecache_marking_cycle();\n@@ -1320,2 +1321,0 @@\n-  G1CollectedHeap::finish_codecache_marking_cycle();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  G1CollectedHeap::start_codecache_marking_cycle_if_inactive();\n+  G1CollectedHeap::start_codecache_marking_cycle_if_inactive(true \/* full_gc *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}