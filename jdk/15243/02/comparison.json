{"files":[{"patch":"@@ -134,1 +134,0 @@\n-\n@@ -140,2 +139,0 @@\n-    bool should_add(HeapRegion* hr) { return G1CollectionSetChooser::should_add(hr); }\n-\n@@ -150,5 +147,23 @@\n-      \/\/ We will skip any region that's currently used as an old GC\n-      \/\/ alloc region (we should not consider those for collection\n-      \/\/ before we fill them up).\n-      if (should_add(r) && !G1CollectedHeap::heap()->is_old_gc_alloc_region(r)) {\n-        assert(r->rem_set()->is_complete(), \"must be %u\", r->hrm_index());\n+      \/\/ Candidates from marking are always old; also keep regions that are already\n+      \/\/ collection set candidates (some retained regions) in that list.\n+      if (!r->is_old() || r->is_collection_set_candidate()) {\n+        \/\/ Keep remembered sets and everything for these regions.\n+        return false;\n+      }\n+\n+      \/\/ Can not add a region without a remembered set to the candidates.\n+      assert(!r->rem_set()->is_updating(), \"must be\");\n+      if (!r->rem_set()->is_complete()) {\n+        return false;\n+      }\n+\n+      \/\/ Skip any region that is currently used as an old GC alloc region. We should\n+      \/\/ not consider those for collection before we fill them up as the effective\n+      \/\/ gain from them is small. I.e. we only actually reclaim from the filled part,\n+      \/\/ as the remainder is still eligible for allocation. These objects are also\n+      \/\/ likely to have already survived a few collections, so they might be longer\n+      \/\/ lived anyway.\n+      \/\/ Otherwise the Old region must satisfy the liveness condition.\n+      bool should_add = !G1CollectedHeap::heap()->is_old_gc_alloc_region(r) &&\n+                        G1CollectionSetChooser::region_occupancy_low_enough_for_evac(r->live_bytes());\n+      if (should_add) {\n@@ -156,4 +171,0 @@\n-      } else if (r->is_old() && !r->is_collection_set_candidate()) {\n-        \/\/ Keep remembered sets for humongous regions and collection set candidates,\n-        \/\/ otherwise clean them out.\n-        r->rem_set()->clear(true \/* only_cardset *\/);\n@@ -161,3 +172,1 @@\n-        assert(r->is_collection_set_candidate() || !r->is_old() || !r->rem_set()->is_tracked(),\n-               \"Missed to clear unused remembered set of region %u (%s) that is %s\",\n-               r->hrm_index(), r->get_type_str(), r->rem_set()->get_state_str());\n+        r->rem_set()->clear(true \/* only_cardset *\/);\n@@ -255,11 +264,0 @@\n-bool G1CollectionSetChooser::should_add(HeapRegion* hr) {\n-  return !hr->is_young() &&\n-         !hr->is_humongous() &&\n-         \/\/ A region might have been retained (after evacuation failure) and already put\n-         \/\/ into the candidates list during concurrent marking. These should keep being\n-         \/\/ considered as retained regions.\n-         !hr->is_collection_set_candidate() &&\n-         region_occupancy_low_enough_for_evac(hr->live_bytes()) &&\n-         hr->rem_set()->is_complete();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":24,"deletions":26,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -50,5 +50,0 @@\n-  \/\/ Determine whether to add the given region to the collection set candidates from\n-  \/\/ marking or not. Currently, we skip regions whose live bytes are over the threshold.\n-  \/\/ Regions also need a complete remembered set to be a candidate.\n-  static bool should_add(HeapRegion* hr);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}