{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-\/\/ with a NULL \"next\" value specially.\n+\/\/ differently depending on its \"next\" value.\n@@ -104,0 +104,3 @@\n+  \/\/ Make last the new end of the queue.  Any further push\/appends will\n+  \/\/ extend after last.  We will try to extend from the previous end of\n+  \/\/ queue.\n@@ -106,11 +109,16 @@\n-  bool is_old_tail_null = (old_tail == NULL);\n-  if (is_old_tail_null ||\n-      \/\/ Try to install first as old_tail's next.\n-      !is_end(Atomic::cmpxchg(next_ptr(*old_tail), end_marker(), &first))) {\n-    \/\/ Install first as the new head if either\n-    \/\/ (1) the list was empty, or\n-    \/\/ (2) a concurrent try_pop claimed old_tail, so it is no longer in the list.\n-    \/\/ Note that multiple concurrent push\/append operations cannot modify\n-    \/\/ _head simultaneously, because the Atomic::xchg() above orders these\n-    \/\/ push\/append operations so they perform Atomic::cmpxchg() on different\n-    \/\/ old_tail. Thus, the cmpxchg can only fail because of a concurrent try_pop.\n+  if (old_tail == NULL) {\n+    \/\/ If old_tail is NULL then the queue was empty, and _head must also be\n+    \/\/ NULL.  The correctness of this assertion depends on try_pop clearing\n+    \/\/ first _head then _tail when taking the last entry.\n+    assert(Atomic::load(&_head) == NULL, \"invariant\");\n+    \/\/ Fall through to common update of _head.\n+  } else if (is_end(Atomic::cmpxchg(next_ptr(*old_tail), end_marker(), &first))) {\n+    \/\/ Successfully extended the queue list from old_tail to first.  No\n+    \/\/ other push\/append could have competed with us, because we claimed\n+    \/\/ old_tail for extension.  We won any races with try_pop by changing\n+    \/\/ away from end-marker.  So we're done.\n+    return;\n+  } else {\n+    \/\/ A concurrent try_pop has claimed old_tail, so it is no longer in the\n+    \/\/ list.  The queue was logically empty.  _head is either NULL or\n+    \/\/ old_tail, depending on how far try_pop operations have progressed.\n@@ -118,6 +126,2 @@\n-    \/\/ If old_tail is NULL, old_head could be NULL, or an unseen object\n-    \/\/ that is being popped.  Otherwise, old_head must be either NULL\n-    \/\/ or the same as old_tail.\n-    assert(is_old_tail_null ||\n-           old_head == NULL || old_head == old_tail, \"invariant\");\n-    Atomic::store(&_head, &first);\n+    assert((old_head == NULL) || (old_head == old_tail), \"invariant\");\n+    \/\/ Fall through to common update of _head.\n@@ -125,0 +129,3 @@\n+  \/\/ The queue was empty, and first should become the new _head.  The queue\n+  \/\/ will appear to be empty to any further try_pops until done.\n+  Atomic::store(&_head, &first);\n@@ -164,1 +171,3 @@\n-      \/\/ was empty.\n+      \/\/ was empty.  We don't attempt to further help [Clause 2] by also\n+      \/\/ trying to set _tail to NULL, as that would just ensure that one or\n+      \/\/ the other cmpxchg is a wasted failure.\n@@ -184,5 +193,3 @@\n-    \/\/ Attempt to change the queue tail from result to NULL.  Failure of the\n-    \/\/ cmpxchg indicates that a concurrent push\/append updated the tail first.\n-    \/\/ That operation will eventually recognize the old tail (our result) is\n-    \/\/ no longer in the list and update head from the list being appended.\n-    Atomic::cmpxchg(&_tail, result, (T*)NULL);\n+    \/\/ The order of the two cmpxchgs doesn't matter algorithmically, but\n+    \/\/ dealing with _head first gives a stronger invariant in append, and is\n+    \/\/ also consistent with [Clause 1b].\n@@ -192,1 +199,1 @@\n-    \/\/ could be either a push\/extend or a try_pop in [Clause 1b].\n+    \/\/ could be either a push\/append or a try_pop in [Clause 1b].\n@@ -195,0 +202,6 @@\n+    \/\/ Attempt to change the queue tail from result to NULL.  Failure of the\n+    \/\/ cmpxchg indicates that a concurrent push\/append updated _tail first.\n+    \/\/ That operation will eventually recognize the old tail (our result) is\n+    \/\/ no longer in the list and update _head from the list being appended.\n+    Atomic::cmpxchg(&_tail, result, (T*)NULL);\n+\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":39,"deletions":26,"binary":false,"changes":65,"status":"modified"}]}