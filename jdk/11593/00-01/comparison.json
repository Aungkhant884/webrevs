{"files":[{"patch":"@@ -157,1 +157,1 @@\n-    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aScope, MemorySessionImpl bScope,\n+    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n@@ -172,1 +172,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aScope, bScope,\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n- * A confined scope, which features an owner thread. The liveness check features an additional\n- * confinement check - that is, calling any operation on this scope from a thread other than the\n+ * A confined session, which features an owner thread. The liveness check features an additional\n+ * confinement check - that is, calling any operation on this session from a thread other than the\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n- * The global, non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n- * Adding new resources to the global scope, does nothing: as the scope can never become not-alive, there is nothing to track.\n- * Acquiring and or releasing a memory scope similarly does nothing.\n+ * The global, non-closeable, shared session. Similar to a shared session, but its {@link #close()} method throws unconditionally.\n+ * Adding new resources to the global session, does nothing: as the session can never become not-alive, there is nothing to track.\n+ * Acquiring and or releasing a memory session similarly does nothing.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,4 +34,4 @@\n- * This is an implicit, GC-backed memory scope. Implicit scopes cannot be closed explicitly.\n- * While it would be possible to model an implicit scope as a non-closeable view of a shared\n- * scope, it is better to capture the fact that an implicit scope is not just a non-closeable\n- * view of some scope which might be closeable. This is useful e.g. in the implementations of\n+ * This is an implicit, GC-backed memory session. Implicit sessions cannot be closed explicitly.\n+ * While it would be possible to model an implicit session as a non-closeable view of a shared\n+ * session, it is better to capture the fact that an implicit session is not just a non-closeable\n+ * view of some session which might be closeable. This is useful e.g. in the implementations of\n@@ -39,1 +39,1 @@\n- * with a potentially closeable scope is forbidden.\n+ * with a potentially closeable session is forbidden.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ImplicitSession.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * as thread confinement. A scope has a liveness bit, which is updated when the scope is closed\n+ * as thread confinement. A session has a liveness bit, which is updated when the session is closed\n@@ -45,2 +45,2 @@\n- * There are two kinds of memory scope: confined memory scope and shared memory scope.\n- * A confined memory scope has an associated owner thread that confines some operations to\n+ * There are two kinds of memory session: confined memory session and shared memory session.\n+ * A confined memory session has an associated owner thread that confines some operations to\n@@ -48,1 +48,1 @@\n- * Shared scopes do not feature an owner thread - meaning their operations can be called, in a racy\n+ * Shared sessions do not feature an owner thread - meaning their operations can be called, in a racy\n@@ -50,2 +50,2 @@\n- * shared scopes use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n- * access is possible when a scope is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * shared sessions use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n+ * access is possible when a session is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n@@ -109,1 +109,1 @@\n-     * we register the cleanup (free\/munmap) against the scope; so, if registration fails, we still have to\n+     * we register the cleanup (free\/munmap) against the session; so, if registration fails, we still have to\n@@ -111,1 +111,1 @@\n-     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the scope\n+     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the session\n@@ -127,3 +127,3 @@\n-        \/\/ Note: from here on we no longer check the scope state. Two cases are possible: either the resource cleanup\n-        \/\/ is added to the list when the scope is still open, in which case everything works ok; or the resource\n-        \/\/ cleanup is added while the scope is being closed. In this latter case, what matters is whether we have already\n+        \/\/ Note: from here on we no longer check the session state. Two cases are possible: either the resource cleanup\n+        \/\/ is added to the list when the session is still open, in which case everything works ok; or the resource\n+        \/\/ cleanup is added while the session is being closed. In this latter case, what matters is whether we have already\n@@ -190,2 +190,2 @@\n-     * Returns true, if this scope is still open. This method may be called in any thread.\n-     * @return {@code true} if this scope is not closed yet.\n+     * Returns true, if this session is still open. This method may be called in any thread.\n+     * @return {@code true} if this session is not closed yet.\n@@ -199,1 +199,1 @@\n-     * relies on invariants associated with the memory scope implementations (volatile access\n+     * relies on invariants associated with the memory session implementations (volatile access\n@@ -216,3 +216,3 @@\n-     * Checks that this scope is still alive (see {@link #isAlive()}).\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n+     * Checks that this session is still alive (see {@link #isAlive()}).\n+     * @throws IllegalStateException if this session is already closed or if this is\n+     * a confined session and this method is called outside of the owner thread.\n@@ -238,3 +238,3 @@\n-     * Closes this scope, executing any cleanup action (where provided).\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n+     * Closes this session, executing any cleanup action (where provided).\n+     * @throws IllegalStateException if this session is already closed or if this is\n+     * a confined session and this method is called outside of the owner thread.\n@@ -254,2 +254,2 @@\n-     * A list of all cleanup actions associated with a memory scope. Cleanup actions are modelled as instances\n-     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a scope\n+     * A list of all cleanup actions associated with a memory session. Cleanup actions are modelled as instances\n+     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a session\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.ref.Cleaner;\n@@ -35,3 +34,3 @@\n- * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n- * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n- * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n+ * A shared session, which can be shared across multiple threads. Closing a shared session has to ensure that\n+ * (i) only one thread can successfully close a session (e.g. in a close vs. close race) and that\n+ * (ii) no other thread is accessing the memory associated with this session while the segment is being\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}