{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,4 @@\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n@@ -114,0 +118,4 @@\n+\n+    void removeSuccessor(InputBlock b) {\n+        successors.remove(b);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlock.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,6 @@\n+    public void removeBlockEdge(InputBlock left, InputBlock right) {\n+        InputBlockEdge edge = new InputBlockEdge(left, right);\n+        blockEdges.remove(edge);\n+        left.removeSuccessor(right);\n+    }\n+\n@@ -283,0 +289,12 @@\n+    public void permuteBlockNames(Map<String, String> namePermutation) {\n+        Map<String, InputBlock> newBlocks = new LinkedHashMap<>();\n+        for (Map.Entry<String, String> perm : namePermutation.entrySet()) {\n+            String oldName = perm.getKey();\n+            String newName = perm.getValue();\n+            InputBlock b = blocks.get(oldName);\n+            b.setName(newName);\n+            newBlocks.put(newName, b);\n+        }\n+        blocks = newBlocks;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputGraph.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -38,0 +39,1 @@\n+import com.ibm.wala.util.graph.traverse.DFS;\n@@ -51,0 +53,1 @@\n+        public List<Character> predIndices = new ArrayList<>();\n@@ -55,0 +58,6 @@\n+\n+        @Override\n+        public String toString() {\n+            return inputNode.getProperties().get(\"idx\") + \" \" +\n+                   inputNode.getProperties().get(\"name\");\n+        }\n@@ -70,0 +79,5 @@\n+    \/\/ Data structures for compact error reporting.\n+    private Set<Node> blockProjectionsWithMultipleSuccs;\n+    private Set<Node> phiInputsWithoutRegion;\n+    private Set<Node> regionsWithoutControlInput;\n+    private Set<Node> phisWithRegionlessInputs;\n@@ -228,0 +242,5 @@\n+            blockProjectionsWithMultipleSuccs = new HashSet<>();\n+            phiInputsWithoutRegion = new HashSet<>();\n+            regionsWithoutControlInput = new HashSet<>();\n+            phisWithRegionlessInputs = new HashSet<>();\n+\n@@ -232,0 +251,1 @@\n+            schedulePinned();\n@@ -235,0 +255,1 @@\n+            renameBlocks();\n@@ -249,0 +270,3 @@\n+            buildDominators(); \/\/ check() uses dominator info.\n+            check();\n+\n@@ -254,5 +278,0 @@\n-        Node root = findRoot();\n-        if(root == null) {\n-            assert false : \"No root found!\";\n-            return;\n-        }\n@@ -261,13 +280,1 @@\n-        Set<Node> reachable = new HashSet<>();\n-        reachable.add(root);\n-        Stack<Node> stack = new Stack<>();\n-        stack.push(root);\n-        while (!stack.isEmpty()) {\n-            Node cur = stack.pop();\n-            for (Node n : cur.preds) {\n-                if (!reachable.contains(n)) {\n-                    reachable.add(n);\n-                    stack.push(n);\n-                }\n-            }\n-        }\n+        Set<Node> reachable = reachableNodes();\n@@ -289,11 +296,22 @@\n-                if (this.isPhi(n) && n.preds.get(0) != null) {\n-                    \/\/ Phi nodes in same block as region nodes\n-                    block = n.preds.get(0).block;\n-                } else {\n-                    for (Node s : n.succs) {\n-                        if (reachable.contains(s)) {\n-                            if (s.block == null) {\n-                                block = null;\n-                                break;\n-                            } else {\n-                                if (block == null) {\n+\n+                for (Node s : n.succs) {\n+                    if (reachable.contains(s)) {\n+                        if (s.block == null) {\n+                            block = null;\n+                            break;\n+                        } else {\n+                            if (isPhi(s)) {\n+                                \/\/ Move inputs above their source blocks.\n+                                boolean found = false;\n+                                for (InputBlock srcBlock : sourceBlocks(n, s)) {\n+                                    found = true;\n+                                    if (block == null) {\n+                                        block = srcBlock;\n+                                    } else {\n+                                        int current = blockIndex.get(block),\n+                                            source  = blockIndex.get(srcBlock);\n+                                        block = commonDominator[current][source];\n+                                    }\n+                                }\n+                                if (!found) {\n+                                    \/\/ Can happen due to inconsistent phi-region pairs.\n@@ -301,2 +319,1 @@\n-                                } else {\n-                                    block = commonDominator[this.blockIndex.get(block)][blockIndex.get(s.block)];\n+                                    phiInputsWithoutRegion.add(n); \/\/ For error reporting.\n@@ -304,0 +321,4 @@\n+                            } else if (block == null) {\n+                                block = s.block;\n+                            } else {\n+                                block = commonDominator[this.blockIndex.get(block)][blockIndex.get(s.block)];\n@@ -325,0 +346,1 @@\n+        \/\/ Finally, schedule unreachable nodes.\n@@ -338,0 +360,34 @@\n+    \/\/ Recomputes the input array of the given node, including empty slots.\n+    private Node[] inputArray(Node n) {\n+        Node[] inputs = new Node[Collections.max(n.predIndices) + 1];\n+        for (int i = 0; i < n.preds.size(); i++) {\n+            inputs[n.predIndices.get(i)] = n.preds.get(i);\n+        }\n+        return inputs;\n+    }\n+\n+    \/\/ Finds the blocks from which node in flows into phi.\n+    private Set<InputBlock> sourceBlocks(Node in, Node phi) {\n+        Node reg = phi.preds.get(0);\n+        assert (reg != null);\n+        \/\/ Reconstruct the positional input arrays of phi-region pairs.\n+        Node[] phiInputs = inputArray(phi);\n+        Node[] regInputs = inputArray(reg);\n+\n+        Set<InputBlock> srcBlocks = new HashSet<>();\n+        for (int i = 0; i < Math.min(phiInputs.length, regInputs.length); i++) {\n+            if (phiInputs[i] == in) {\n+                if (regInputs[i] != null) {\n+                    if (regInputs[i].isCFG) {\n+                        srcBlocks.add(regInputs[i].block);\n+                    } else {\n+                        regionsWithoutControlInput.add(reg); \/\/ For error reporting.\n+                    }\n+                } else {\n+                    phisWithRegionlessInputs.add(phi); \/\/ For error reporting.\n+                }\n+            }\n+        }\n+        return srcBlocks;\n+    }\n+\n@@ -400,0 +456,91 @@\n+    \/\/ Schedule nodes pinned to region-like nodes in their blocks.\n+    \/\/ Schedule nodes pinned to block projections (e.g. IfTrue) in:\n+    \/\/ - the projection's successor block,  if the successor block has only one\n+    \/\/                                      predecessor;\n+    \/\/ - a new block created in between,    if the successor block has multiple\n+    \/\/                                      predecessors, forming a critical\n+    \/\/                                      edge (projection, successor).\n+    public void schedulePinned() {\n+\n+        Set<Node> reachable = reachableNodes();\n+        int blockCount = Collections.max(blockIndex.values()) + 1;\n+        \/\/ Map from critical edges in the initial CFG to splitter blocks.\n+        Map<InputBlockEdge, InputBlock> splitBlockMap = new HashMap<>();\n+\n+        for (Node n : nodes) {\n+            if (!reachable.contains(n) ||\n+                n.block != null) {\n+                continue;\n+            }\n+            Node ctrlIn = pinnedNode(n);\n+            if (ctrlIn == null) {\n+                continue;\n+            }\n+            InputBlock block = ctrlIn.block;\n+            if (ctrlIn.isBlockProjection) {\n+                \/\/ Block projections should not have successors in their block:\n+                \/\/ if n is pinned to a block projection, push it downwards.\n+                assert (ctrlIn.succs.size() > 0);\n+                Node ctrlSucc = null;\n+                int ctrlSuccs = 0;\n+                for (Node s : ctrlIn.succs) {\n+                    if (s.isCFG) {\n+                        ctrlSucc = s;\n+                        ctrlSuccs++;\n+                    }\n+                }\n+                if (ctrlSuccs == 1) {\n+                    \/\/ Regular case (block projections only have one control\n+                    \/\/ successor in well-formed graphs).\n+                    int ctrlSuccPreds = 0;\n+                    for (Node p : ctrlSucc.preds) {\n+                        if (isControl(p)) {\n+                            ctrlSuccPreds++;\n+                        }\n+                    }\n+                    if (ctrlSuccPreds == 1) {\n+                        \/\/ The successor block ctrlSucc has only one\n+                        \/\/ predecessor: schedule n in ctrlSucc.\n+                        block = ctrlSucc.block;\n+                    } else {\n+                        \/\/ The successor block ctrlSucc has multiple\n+                        \/\/ predecessors, forming a critical edge: schedule n in\n+                        \/\/ a new block created in between ctrlIn and ctrlSucc.\n+                        InputBlock p = ctrlIn.block, s = ctrlSucc.block;\n+                        InputBlockEdge criticalEdge = new InputBlockEdge(p, s);\n+                        InputBlock split = splitBlockMap.get(criticalEdge);\n+                        if (split == null) {\n+                            \/\/ (p, s) form a critical edge: split it here.\n+                            split = graph.addBlock(Integer.toString(blockCount + 1));\n+                            graph.removeBlockEdge(p, s);\n+                            graph.addBlockEdge(p, split);\n+                            graph.addBlockEdge(split, s);\n+                            blocks.add(split);\n+                            blockIndex.put(split, blockCount);\n+                            blockCount++;\n+                            splitBlockMap.put(criticalEdge, split);\n+                        }\n+                        block = split;\n+                    }\n+                } else {\n+                    blockProjectionsWithMultipleSuccs.add(ctrlIn); \/\/ For error reporting.\n+                }\n+            }\n+            n.block = block;\n+            block.addNode(n.inputNode.getId());\n+        }\n+    }\n+\n+    \/\/ Returns the control node to which n is pinned, or null if none.\n+    public Node pinnedNode(Node n) {\n+        if (n.preds.isEmpty()) {\n+            return null;\n+        }\n+        Node ctrlIn = n.preds.get(0);\n+        if (!isControl(ctrlIn)) {\n+            return null;\n+        }\n+        \/\/ n is pinned to ctrlIn.\n+        return ctrlIn;\n+    }\n+\n@@ -406,10 +553,1 @@\n-        Graph<InputBlock> CFG = SlowSparseNumberedGraph.make();\n-        for (InputBlock b : blocks) {\n-            CFG.addNode(b);\n-        }\n-        for (InputBlock p : blocks) {\n-            for (InputBlock s : p.getSuccessors()) {\n-                CFG.addEdge(p, s);\n-            }\n-        }\n-\n+        Graph<InputBlock> CFG = makeCFG();\n@@ -429,0 +567,59 @@\n+    \/\/ Rename blocks by reverse post-order traversal, to accomodate new blocks.\n+    private void renameBlocks() {\n+\n+        Graph<InputBlock> CFG = makeCFG();\n+        InputBlock root = findRoot().block;\n+        List<InputBlock> roots = new ArrayList<InputBlock>(1);\n+        roots.add(root);\n+        \/\/ Start from the Root node block if there are multiple root blocks.\n+        for (InputBlock b : blocks) {\n+            if (b != root && CFG.getPredNodeCount(b) == 0) {\n+                roots.add(b);\n+            }\n+        }\n+\n+        int blockCount = 0;\n+        Map<String, String> namePerm = new HashMap<>(blocks.size());\n+        for (InputBlock r : roots) {\n+            SortedSet<InputBlock> dfsSet = DFS.sortByDepthFirstOrder(CFG, r);\n+            InputBlock[] dfs = dfsSet.toArray(new InputBlock[dfsSet.size()]);\n+            for (int i = dfs.length - 1; i >= 0; i--) {\n+                InputBlock b = dfs[i];\n+                namePerm.put(b.getName(), Integer.toString(blockCount + 1));\n+                blockCount++;\n+            }\n+        }\n+\n+        graph.permuteBlockNames(namePerm);\n+        \/\/ permuteBlockNames() affects InputBlock's hashCode() and equals()\n+        \/\/ methods, so all maps that use InputBlock as keys are invalidated.\n+        blockIndex = null;\n+        dominatorMap = null;\n+    }\n+\n+    \/\/ Build an auxiliary CFG from the WALA libraries for analysis.\n+    private Graph<InputBlock> makeCFG() {\n+        Graph<InputBlock> CFG = SlowSparseNumberedGraph.make();\n+        for (InputBlock b : blocks) {\n+            CFG.addNode(b);\n+        }\n+        for (InputBlock p : blocks) {\n+            for (InputBlock s : p.getSuccessors()) {\n+                CFG.addEdge(p, s);\n+            }\n+        }\n+        return CFG;\n+    }\n+\n+    \/\/ Whether b1 dominates b2.\n+    private boolean dominates(InputBlock b1, InputBlock b2) {\n+        InputBlock bi = b2;\n+        do {\n+            if (bi.equals(b1)) {\n+                return true;\n+            }\n+            bi = dominatorMap.get(bi);\n+        } while (bi != null);\n+        return false;\n+    }\n+\n@@ -437,0 +634,4 @@\n+    private boolean isControl(Node n) {\n+        return n.inputNode.getProperties().get(\"category\").equals(\"control\");\n+    }\n+\n@@ -464,0 +665,23 @@\n+    private Set<Node> reachableNodes() {\n+        Node root = findRoot();\n+        if(root == null) {\n+            assert false : \"No root found!\";\n+            return null;\n+        }\n+        \/\/ Mark all nodes reachable in backward traversal from root\n+        Set<Node> reachable = new HashSet<>();\n+        reachable.add(root);\n+        Stack<Node> stack = new Stack<>();\n+        stack.push(root);\n+        while (!stack.isEmpty()) {\n+            Node cur = stack.pop();\n+            for (Node n : cur.preds) {\n+                if (!reachable.contains(n)) {\n+                    reachable.add(n);\n+                    stack.push(n);\n+                }\n+            }\n+        }\n+        return reachable;\n+    }\n+\n@@ -515,0 +739,1 @@\n+                toNode.predIndices.add(e.getToIndex());\n@@ -579,0 +804,83 @@\n+\n+    \/\/ Check invariants in the input graph and in the output schedule. Warn the\n+    \/\/ user rather than crashing, for robustness (an inaccuracy in the schedule\n+    \/\/ approximation should not disable all other IGV functionality).\n+    public void check() {\n+\n+        Set<Node> reachable = reachableNodes();\n+        Set<Node> notMarkedWithBlockStart = new HashSet<>();\n+        Set<Node> cfgAndInputToPhi = new HashSet<>();\n+        Set<Node> phiNonDominatingInputs = new HashSet<>();\n+        for (Node n : nodes) {\n+\n+            \/\/ Check that region nodes are well-formed.\n+            if (isRegion(n) && !n.isBlockStart) {\n+                notMarkedWithBlockStart.add(n);\n+            }\n+\n+            \/\/ Check that phi nodes are well-formed. If they are, check that\n+            \/\/ their inputs are scheduled above their source nodes.\n+            if (isPhi(n)) {\n+                if (!reachable.contains(n)) { \/\/ Dead phi.\n+                    continue;\n+                }\n+                for (int i = 1; i < n.preds.size(); i++) {\n+                    Node in = n.preds.get(i);\n+                    if (in.isCFG) {\n+                        \/\/ This can happen for nodes misclassified as CFG,\n+                        \/\/ for example x64's 'rep_stos'.\n+                        cfgAndInputToPhi.add(in);\n+                        continue;\n+                    }\n+                    for (InputBlock b : sourceBlocks(in, n)) {\n+                        Node ctrlIn = pinnedNode(in);\n+                        if (ctrlIn != null && ctrlIn.isBlockProjection) {\n+                            \/\/ If the input is pinned to a projection, it has\n+                            \/\/ been pushed downwards, skip check.\n+                            continue;\n+                        }\n+                        if (!dominates(graph.getBlock(in.inputNode), b)) {\n+                            phiNonDominatingInputs.add(in);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!blockProjectionsWithMultipleSuccs.isEmpty()) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING,\n+                blockProjectionsWithMultipleSuccs + \" have multiple successors, \" +\n+                \"this might affect the quality of the approximated schedule.\");\n+        }\n+        if (!phiInputsWithoutRegion.isEmpty()) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING,\n+                phiInputsWithoutRegion + \" are phi inputs without associated regions, \"\n+                + \"this might affect the quality of the approximated schedule.\");\n+        }\n+        if (!regionsWithoutControlInput.isEmpty()) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING,\n+                regionsWithoutControlInput + \" have no control input, \"\n+                + \"this might affect the quality of the approximated schedule.\");\n+        }\n+        if (!phisWithRegionlessInputs.isEmpty()) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING,\n+                phisWithRegionlessInputs + \" have input nodes without asociated region, \"\n+                + \"this might affect the quality of the approximated schedule.\");\n+        }\n+        if (!notMarkedWithBlockStart.isEmpty()) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING,\n+                notMarkedWithBlockStart + \" are not marked with is_block_start, \" +\n+                \"this might affect the quality of the approximated schedule.\");\n+        }\n+        if (!cfgAndInputToPhi.isEmpty()) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING,\n+                cfgAndInputToPhi + \" are CFG nodes and phi inputs, \" +\n+                \"this might affect the quality of the approximated schedule.\");\n+        }\n+        if (!phiNonDominatingInputs.isEmpty()) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING,\n+                \"inaccurate schedule: \" + phiNonDominatingInputs +\n+                \" are phi inputs but do not dominate the phi's input block.\");\n+        }\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":349,"deletions":41,"binary":false,"changes":390,"status":"modified"}]}