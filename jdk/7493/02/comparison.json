{"files":[{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.filter;\n+\n+import com.sun.hotspot.igv.data.Properties;\n+import com.sun.hotspot.igv.graph.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class WarningFilter extends AbstractFilter {\n+\n+    private final List<WarningRule> rules;\n+    private final String name;\n+    private final String warning;\n+\n+    public WarningFilter(String name, String warning) {\n+        this.name = name;\n+        this.warning = warning;\n+        rules = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public void apply(Diagram diagram) {\n+        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(diagram.getFigures());\n+        for (WarningRule rule : rules) {\n+            if (rule.getSelector() != null) {\n+                List<Figure> figures = rule.getSelector().selected(diagram);\n+                for (Figure f : figures) {\n+                    f.setWarning(warning);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void addRule(WarningRule r) {\n+        rules.add(r);\n+    }\n+\n+    public static class WarningRule {\n+\n+        private Selector selector;\n+\n+        public WarningRule(Selector selector) {\n+            this.selector = selector;\n+        }\n+\n+        public Selector getSelector() {\n+            return selector;\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/WarningFilter.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,6 @@\n+function warn(propertyToMatch, regexp, propertyToShow) {\n+    var f = new WarningFilter(\"\", \"[\" + propertyToShow + \"]\");\n+    f.addRule(new WarningFilter.WarningRule(new MatcherSelector(new Properties.RegexpPropertyMatcher(propertyToMatch, regexp))));\n+    f.apply(graph);\n+}\n+\n@@ -114,1 +120,1 @@\n-var white = Color.white;\n\\ No newline at end of file\n+var white = Color.white;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filter\/helper.js","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    public static final int WARNING_WIDTH = 16;\n@@ -55,0 +56,1 @@\n+    private String warning;\n@@ -126,0 +128,3 @@\n+            if (getWarning() != null) {\n+                widthCash += WARNING_WIDTH;\n+            }\n@@ -158,0 +163,8 @@\n+    public void setWarning(String warning) {\n+        this.warning = getProperties().resolveString(warning);\n+    }\n+\n+    public String getWarning() {\n+        return warning;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,0 +49,8 @@\n+        public static final String WARNING_BLOCK_PROJECTION_WITH_MULTIPLE_SUCCS = \"Block projection with multiple successors\";\n+        public static final String WARNING_PHI_INPUT_WITHOUT_REGION = \"Phi input without associated region\";\n+        public static final String WARNING_REGION_WITHOUT_CONTROL_INPUT = \"Region without control input\";\n+        public static final String WARNING_PHI_WITH_REGIONLESS_INPUTS = \"Phi node with input nodes without associated region\";\n+        public static final String WARNING_NOT_MARKED_WITH_BLOCK_START = \"Region not marked with is_block_start\";\n+        public static final String WARNING_CFG_AND_INPUT_TO_PHI = \"CFG node is a phi input\";\n+        public static final String WARNING_PHI_NON_DOMINATING_INPUTS = \"Phi input that does not dominate the phi's input block\";\n+\n@@ -52,0 +60,3 @@\n+        \/\/ Index of each predecessor.\n+        public List<Character> predIndices = new ArrayList<>();\n+        public List<String> warnings;\n@@ -58,0 +69,4 @@\n+        \/\/ Empty constructor for creating dummy CFG nodes without associated\n+        \/\/ input nodes.\n+        public Node() {}\n+\n@@ -84,0 +99,7 @@\n+        public void addWarning(String msg) {\n+            if (warnings == null) {\n+                warnings = new ArrayList<>();\n+            }\n+            warnings.add(msg);\n+        }\n+\n@@ -86,0 +108,3 @@\n+            if (inputNode == null) {\n+                return \"(dummy node)\";\n+            }\n@@ -93,0 +118,3 @@\n+    \/\/ CFG successors of each CFG node, excluding self edges.\n+    Map<Node, List<Node>> controlSuccs = new HashMap<>();\n+    \/\/ Nodes reachable in backward traversal from root.\n@@ -113,2 +141,0 @@\n-        \/\/ Pre-compute control successors of each node, excluding self edges.\n-        Map<Node, List<Node>> controlSuccs = new HashMap<>();\n@@ -182,1 +208,16 @@\n-                            for (Node ps : controlSuccs.get(s)) {\n+                            List<Node> projSuccs = controlSuccs.get(s);\n+                            if (projSuccs.size() > 1) {\n+                                s.addWarning(Node.WARNING_BLOCK_PROJECTION_WITH_MULTIPLE_SUCCS);\n+                            }\n+                            \/\/ If s has only one CFG successor ss (regular\n+                            \/\/ case), there is a node pinned to s, and ss has\n+                            \/\/ multiple CFG predecessors, insert a block between\n+                            \/\/ s and ss. This is done by adding a dummy CFG node\n+                            \/\/ that has no correspondence in the input graph.\n+                            if (projSuccs.size() == 1 &&\n+                                s.succs.stream().anyMatch(ss -> pinnedNode(ss) == s) &&\n+                                projSuccs.get(0).preds.stream().filter(ssp -> ssp.isCFG).count() > 1) {\n+                                stack.push(insertDummyCFGNode(s, projSuccs.get(0)));\n+                                continue;\n+                            }\n+                            for (Node ps : projSuccs) {\n@@ -233,0 +274,18 @@\n+    \/\/ Create a dummy CFG node (without correspondence in the input graph) and\n+    \/\/ insert it between p and s.\n+    private Node insertDummyCFGNode(Node p, Node s) {\n+        \/\/ Create in-between node.\n+        Node n = new Node();\n+        n.preds.add(p);\n+        n.succs.add(s);\n+        controlSuccs.put(n, Arrays.asList(s));\n+        n.isCFG = true;\n+        \/\/ Update predecessor node p.\n+        p.succs.remove(s);\n+        p.succs.add(n);\n+        controlSuccs.put(p, Arrays.asList(n));\n+        \/\/ Update successor node s.\n+        Collections.replaceAll(s.preds, p, n);\n+        return n;\n+    }\n+\n@@ -268,0 +327,1 @@\n+            schedulePinned();\n@@ -285,0 +345,2 @@\n+            check();\n+            reportWarnings();\n@@ -382,18 +444,18 @@\n-    private void scheduleLatest() {\n-        Node root = findRoot();\n-        if(root == null) {\n-            assert false : \"No root found!\";\n-            return;\n-        }\n-\n-        \/\/ Mark all nodes reachable in backward traversal from root\n-        Set<Node> reachable = new HashSet<>();\n-        reachable.add(root);\n-        Stack<Node> stack = new Stack<>();\n-        stack.push(root);\n-        while (!stack.isEmpty()) {\n-            Node cur = stack.pop();\n-            for (Node n : cur.preds) {\n-                if (!reachable.contains(n)) {\n-                    reachable.add(n);\n-                    stack.push(n);\n+    \/\/ Return latest block that dominates all successors of n, or null if any\n+    \/\/ successor is not yet scheduled.\n+    private InputBlock commonDominatorOfSuccessors(Node n, Set<Node> reachable) {\n+        InputBlock block = null;\n+        for (Node s : n.succs) {\n+            if (!reachable.contains(s)) {\n+                \/\/ Unreachable successors should not affect the schedule.\n+                continue;\n+            }\n+            if (s.block == null) {\n+                \/\/ Successor is not yet scheduled, wait for it.\n+                return null;\n+            } else if (isPhi(s)) {\n+                \/\/ Move inputs above their source blocks.\n+                boolean foundSourceBlock = false;\n+                for (InputBlock srcBlock : sourceBlocks(n, s)) {\n+                    foundSourceBlock = true;\n+                    block = getCommonDominator(block, srcBlock);\n@@ -401,0 +463,8 @@\n+                if (!foundSourceBlock) {\n+                    \/\/ Can happen due to inconsistent phi-region pairs.\n+                    block = s.block;\n+                    n.addWarning(Node.WARNING_PHI_INPUT_WITHOUT_REGION);\n+                }\n+            } else {\n+                \/\/ Common case, update current block to also dominate s.\n+                block = getCommonDominator(block, s.block);\n@@ -403,0 +473,4 @@\n+        return block;\n+    }\n+\n+    private void scheduleLatest() {\n@@ -404,0 +478,2 @@\n+        \/\/ Mark all nodes reachable in backward traversal from root\n+        Set<Node> reachable = reachableNodes();\n@@ -416,22 +492,1 @@\n-\n-                InputBlock block = null;\n-                if (this.isPhi(n) && n.preds.get(0) != null) {\n-                    \/\/ Phi nodes in same block as region nodes\n-                    block = n.preds.get(0).block;\n-                } else {\n-                    for (Node s : n.succs) {\n-                        if (reachable.contains(s)) {\n-                            if (s.block == null) {\n-                                block = null;\n-                                break;\n-                            } else {\n-                                if (block == null) {\n-                                    block = s.block;\n-                                } else {\n-                                    block = getCommonDominator(block, s.block);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n+                InputBlock block = commonDominatorOfSuccessors(n, reachable);\n@@ -467,0 +522,34 @@\n+    \/\/ Recompute the input array of the given node, including empty slots.\n+    private Node[] inputArray(Node n) {\n+        Node[] inputs = new Node[Collections.max(n.predIndices) + 1];\n+        for (int i = 0; i < n.preds.size(); i++) {\n+            inputs[n.predIndices.get(i)] = n.preds.get(i);\n+        }\n+        return inputs;\n+    }\n+\n+    \/\/ Find the blocks from which node 'in' flows into 'phi'.\n+    private Set<InputBlock> sourceBlocks(Node in, Node phi) {\n+        Node reg = phi.preds.get(0);\n+        assert (reg != null);\n+        \/\/ Reconstruct the positional input arrays of phi-region pairs.\n+        Node[] phiInputs = inputArray(phi);\n+        Node[] regInputs = inputArray(reg);\n+\n+        Set<InputBlock> srcBlocks = new HashSet<>();\n+        for (int i = 0; i < Math.min(phiInputs.length, regInputs.length); i++) {\n+            if (phiInputs[i] == in) {\n+                if (regInputs[i] != null) {\n+                    if (regInputs[i].isCFG) {\n+                        srcBlocks.add(regInputs[i].block);\n+                    } else {\n+                        reg.addWarning(Node.WARNING_REGION_WITHOUT_CONTROL_INPUT);\n+                    }\n+                } else {\n+                    phi.addWarning(Node.WARNING_PHI_WITH_REGIONLESS_INPUTS);\n+                }\n+            }\n+        }\n+        return srcBlocks;\n+    }\n+\n@@ -501,0 +590,6 @@\n+        if (ba == null) {\n+            return bb;\n+        }\n+        if (bb == null) {\n+            return ba;\n+        }\n@@ -518,0 +613,39 @@\n+    \/\/ Schedule nodes pinned to region-like nodes in the same block. Schedule\n+    \/\/ nodes pinned to block projections s in their successor block ss.\n+    \/\/ buildBlocks() guarantees that s is the only predecessor of ss.\n+    public void schedulePinned() {\n+        Set<Node> reachable = reachableNodes();\n+        for (Node n : nodes) {\n+            if (!reachable.contains(n) ||\n+                n.block != null) {\n+                continue;\n+            }\n+            Node ctrlIn = pinnedNode(n);\n+            if (ctrlIn == null) {\n+                continue;\n+            }\n+            InputBlock block = ctrlIn.block;\n+            if (ctrlIn.isBlockProjection) {\n+                \/\/ Block projections should not have successors in their block:\n+                \/\/ if n is pinned to a block projection, push it downwards.\n+                if (controlSuccs.get(ctrlIn).size() == 1) {\n+                    block = controlSuccs.get(ctrlIn).get(0).block;\n+                }\n+            }\n+            n.block = block;\n+            block.addNode(n.inputNode.getId());\n+        }\n+    }\n+\n+    \/\/ Return the control node to which 'n' is pinned, or null if none.\n+    public Node pinnedNode(Node n) {\n+        if (n.preds.isEmpty()) {\n+            return null;\n+        }\n+        Node ctrlIn = n.preds.get(0);\n+        if (!isControl(ctrlIn)) {\n+            return null;\n+        }\n+        return ctrlIn;\n+    }\n+\n@@ -563,0 +697,4 @@\n+    private static boolean isRegion(Node n) {\n+        return hasName(n, \"Region\");\n+    }\n+\n@@ -575,0 +713,12 @@\n+    \/\/ Whether b1 dominates b2. Used only for checking the schedule.\n+    private boolean dominates(InputBlock b1, InputBlock b2) {\n+        InputBlock bi = b2;\n+        do {\n+            if (bi.equals(b1)) {\n+                return true;\n+            }\n+            bi = dominatorMap.get(bi);\n+        } while (bi != null);\n+        return false;\n+    }\n+\n@@ -600,0 +750,22 @@\n+    \/\/ Find all nodes reachable in backward traversal from root.\n+    private Set<Node> reachableNodes() {\n+        Node root = findRoot();\n+        if (root == null) {\n+            assert false : \"No root found!\";\n+        }\n+        Set<Node> reachable = new HashSet<>();\n+        reachable.add(root);\n+        Stack<Node> stack = new Stack<>();\n+        stack.push(root);\n+        while (!stack.isEmpty()) {\n+            Node cur = stack.pop();\n+            for (Node n : cur.preds) {\n+                if (!reachable.contains(n)) {\n+                    reachable.add(n);\n+                    stack.push(n);\n+                }\n+            }\n+        }\n+        return reachable;\n+    }\n+\n@@ -646,0 +818,1 @@\n+                toNode.predIndices.add(e.getToIndex());\n@@ -710,0 +883,67 @@\n+\n+    \/\/ Check invariants in the input graph and in the output schedule, and add\n+    \/\/ warnings to nodes where the invariants do not hold.\n+    public void check() {\n+        Set<Node> reachable = reachableNodes();\n+        for (Node n : nodes) {\n+            \/\/ Check that region nodes are well-formed.\n+            if (isRegion(n) && !n.isBlockStart) {\n+                n.addWarning(Node.WARNING_NOT_MARKED_WITH_BLOCK_START);\n+            }\n+            if (!isPhi(n)) {\n+                continue;\n+            }\n+            if (!reachable.contains(n)) { \/\/ Dead phi.\n+                continue;\n+            }\n+            \/\/ Check that phi nodes and their inputs are well-formed.\n+            for (int i = 1; i < n.preds.size(); i++) {\n+                Node in = n.preds.get(i);\n+                if (in.isCFG) {\n+                    \/\/ This can happen for nodes misclassified as CFG, for\n+                    \/\/ example x64's 'rep_stos'.\n+                    in.addWarning(Node.WARNING_CFG_AND_INPUT_TO_PHI);\n+                    continue;\n+                }\n+                for (InputBlock b : sourceBlocks(in, n)) {\n+                    if (!dominates(graph.getBlock(in.inputNode), b)) {\n+                        in.addWarning(Node.WARNING_PHI_NON_DOMINATING_INPUTS);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Report potential and actual innacuracies in the schedule approximation.\n+    \/\/ IGV tries to warn, rather than crashing, for robustness: an inaccuracy in\n+    \/\/ the schedule approximation or an inconsistency in the input graph should\n+    \/\/ not disable all IGV functionality, and debugging inconsistent graphs is a\n+    \/\/ key use case of IGV. Warns are reported visually for each node (if the\n+    \/\/ corresponding filter is active) and textually in the IGV log.\n+    public void reportWarnings() {\n+        Map<String, Set<Node>> nodesPerWarning = new HashMap<>();\n+        for (Node n : nodes) {\n+            if (n.warnings == null || n.warnings.isEmpty()) {\n+                continue;\n+            }\n+            for (String warning : n.warnings) {\n+                if (!nodesPerWarning.containsKey(warning)) {\n+                    nodesPerWarning.put(warning, new HashSet<Node>());\n+                }\n+                nodesPerWarning.get(warning).add(n);\n+            }\n+            \/\/ Attach warnings to each node as a property to be shown in the\n+            \/\/ graph views.\n+            String nodeWarnings = String.join(\"; \", n.warnings);\n+            n.inputNode.getProperties().setProperty(\"warnings\", nodeWarnings);\n+        }\n+        \/\/ Report warnings textually.\n+        for (Map.Entry<String, Set<Node>> entry : nodesPerWarning.entrySet()) {\n+            String warning = entry.getKey();\n+            Set<Node> nodes = entry.getValue();\n+            String nodeList = nodes.toString().replace(\"[\", \"(\").replace(\"]\", \")\");\n+            String message = warning + \" \" + nodeList;\n+            ErrorManager.getDefault().log(ErrorManager.WARNING, message);\n+        }\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":283,"deletions":43,"binary":false,"changes":326,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+warn(\"warnings\", \".+\", \"warnings\")\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/showWarnings.filter","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -12,0 +12,4 @@\n+        <file name=\"Show node warnings\" url=\"filters\/showWarnings.filter\">\n+            <attr name=\"enabled\" boolvalue=\"true\"\/>\n+            <attr name=\"after\" stringvalue=\"Color by execution frequency\"\/>\n+        <\/file>\n@@ -14,1 +18,1 @@\n-            <attr name=\"after\" stringvalue=\"Color by execution frequency\"\/>\n+            <attr name=\"after\" stringvalue=\"Show node warnings\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/layer.xml","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import org.netbeans.api.visual.widget.ImageWidget;\n@@ -57,0 +58,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -76,0 +78,1 @@\n+    private static final Image warningSign = ImageUtilities.loadImage(\"com\/sun\/hotspot\/igv\/view\/images\/warning.png\");\n@@ -126,0 +129,9 @@\n+        \/\/ This widget includes the node text and possibly a warning sign to the right.\n+        Widget nodeInfoWidget = new Widget(scene);\n+        nodeInfoWidget.setLayout(LayoutFactory.createAbsoluteLayout());\n+        middleWidget.addChild(nodeInfoWidget);\n+\n+        Widget textWidget = new Widget(scene);\n+        textWidget.setLayout(LayoutFactory.createVerticalFlowLayout(textAlign, 0));\n+        nodeInfoWidget.addChild(textWidget);\n+\n@@ -132,1 +144,1 @@\n-            middleWidget.addChild(lw);\n+            textWidget.addChild(lw);\n@@ -141,0 +153,8 @@\n+        if (getFigure().getWarning() != null) {\n+            ImageWidget warningWidget = new ImageWidget(scene, warningSign);\n+            Point warningLocation = new Point(getFigure().getWidth() - Figure.WARNING_WIDTH - Figure.INSET \/ 2, 0);\n+            warningWidget.setPreferredLocation(warningLocation);\n+            warningWidget.setToolTipText(getFigure().getWarning());\n+            nodeInfoWidget.addChild(warningWidget);\n+        }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/warning.png","binary":true,"status":"added"}]}