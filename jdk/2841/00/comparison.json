{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -42,1 +42,23 @@\n-  ShouldNotReachHere();\n+  if (UseSIGTRAP) {\n+    DEBUG_ONLY( __ should_not_reach_here(\"C1SafepointPollStub::emit_code\"); )\n+  } else {\n+    assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+           \"polling page return stub not created yet\");\n+    address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+    __ bind(_entry);\n+    \/\/ Using pc relative address computation.\n+    {\n+      Label next_pc;\n+      __ bl(next_pc);\n+      __ bind(next_pc);\n+    }\n+    int current_offset = __ offset();\n+    __ mflr(R12);\n+    __ add_const_optimized(R12, R12, safepoint_offset() - current_offset);\n+    __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n+\n+    __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n+    __ mtctr(R0);\n+    __ bctr();\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1330,2 +1330,2 @@\n-  const Register return_pc        = R31;  \/\/ Must survive C-call to enable_stack_reserved_zone().\n-  const Register polling_page     = R12;\n+  const Register return_pc = R31;  \/\/ Must survive C-call to enable_stack_reserved_zone().\n+  const Register temp      = R12;\n@@ -1341,2 +1341,0 @@\n-  __ ld(polling_page, in_bytes(Thread::polling_page_offset()), R16_thread);\n-\n@@ -1354,2 +1352,5 @@\n-  __ relocate(relocInfo::poll_return_type);\n-  __ load_from_polling_page(polling_page);\n+  if (!UseSIGTRAP) {\n+    code_stub->set_safepoint_offset(__ offset());\n+    __ relocate(relocInfo::poll_return_type);\n+  }\n+  __ safepoint_poll(*code_stub->entry(), temp, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_ppc.inline.hpp\"\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/output.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+\n+#define __ masm.\n+void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  __ bind(entry->_stub_label);\n+  \/\/ Using pc relative address computation.\n+  {\n+    Label next_pc;\n+    __ bl(next_pc);\n+    __ bind(next_pc);\n+  }\n+  int current_offset = __ offset();\n+  \/\/ Code size should not depend on offset: see _stub_size computation in output.cpp\n+  __ load_const32(R12, entry->_safepoint_offset - current_offset);\n+  __ mflr(R0);\n+  __ add(R12, R12, R0);\n+  __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n+\n+  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n+  __ mtctr(R0);\n+  __ bctr();\n+}\n+#undef __\n","filename":"src\/hotspot\/cpu\/ppc\/c2_safepointPollStubTable_ppc.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -232,1 +233,1 @@\n-frame frame::sender(RegisterMap* map) const {\n+frame frame::sender_raw(RegisterMap* map) const {\n@@ -249,0 +250,10 @@\n+frame frame::sender(RegisterMap* map) const {\n+  frame result = sender_raw(map);\n+\n+  if (map->process_frames()) {\n+    StackWatermarkSet::on_iteration(map->thread(), result);\n+  }\n+\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -421,0 +421,3 @@\n+  \/\/ returns the sending frame, without applying any barriers\n+  frame sender_raw(RegisterMap* map) const;\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -830,0 +830,1 @@\n+\/\/ Apply stack watermark barrier.\n@@ -845,0 +846,17 @@\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, R11_scratch1, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  b(fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(R1_SP, noreg);\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), R16_thread);\n+  reset_last_Java_frame();\n+  pop(state);\n+  align(32);\n+  bind(fast_path);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3060,2 +3060,2 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, Register temp_reg) {\n-  ld(temp_reg, in_bytes(Thread::polling_word_offset()), R16_thread);\n+void MacroAssembler::safepoint_poll(Label& slow_path, Register temp, bool at_return, bool in_nmethod) {\n+  ld(temp, in_bytes(Thread::polling_word_offset()), R16_thread);\n@@ -3063,2 +3063,26 @@\n-  andi_(temp_reg, temp_reg, SafepointMechanism::poll_bit());\n-  bne(CCR0, slow_path);\n+  if (at_return) {\n+    Register fp = R1_SP;\n+    if (!in_nmethod) {\n+      \/\/ frame still on stack, need to get fp\n+      fp = R0;\n+      ld(fp, _abi0(callers_sp), R1_SP);\n+    }\n+\n+    if (UseSIGTRAP && in_nmethod) {\n+      \/\/ Use Signal Handler.\n+      relocate(relocInfo::poll_return_type);\n+      td(traptoGreaterThanUnsigned, fp, temp);\n+    } else {\n+      cmpld(CCR0, fp, temp);\n+      if (in_nmethod) {\n+        \/\/ Stub may be out of range for short conditional branch.\n+        bc_far_optimized(Assembler::bcondCRbiIs1, bi0(CCR0, Assembler::greater), slow_path);\n+      } else {\n+        bgt(CCR0, slow_path);\n+      }\n+    }\n+  } else {\n+    assert(!in_nmethod, \"unexpected\");\n+    andi_(temp, temp, SafepointMechanism::poll_bit());\n+    bne(CCR0, slow_path);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -669,1 +669,1 @@\n-  void safepoint_poll(Label& slow_path, Register temp_reg);\n+  void safepoint_poll(Label& slow_path, Register temp, bool at_return, bool in_nmethod);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -86,1 +86,0 @@\n-    \/\/ Is the current instruction a POTENTIAL read access to the polling page?\n@@ -95,0 +94,6 @@\n+\n+  bool is_safepoint_poll_return() {\n+    \/\/ Safepoint poll at nmethod return with watermark check.\n+    return MacroAssembler::is_td(long_at(0), Assembler::traptoGreaterThanUnsigned,\n+                                 \/* R1_SP *\/ 1, \/* any reg *\/ -1);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+\/\/ Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -1565,1 +1565,1 @@\n-    st->print(\"touch polling page\\n\\t\");\n+    st->print(\"safepoint poll\\n\\t\");\n@@ -1580,1 +1580,1 @@\n-  const Register polling_page     = R12;\n+  const Register temp             = R12;\n@@ -1585,7 +1585,0 @@\n-  }\n-\n-  if (method_needs_polling) {\n-    __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);\n-  }\n-\n-  if (!method_is_frameless) {\n@@ -1603,4 +1596,7 @@\n-    \/\/ We need to mark the code position where the load from the safepoint\n-    \/\/ polling page was emitted as relocInfo::poll_return_type here.\n-    __ relocate(relocInfo::poll_return_type);\n-    __ load_from_polling_page(polling_page);\n+    Label dummy_label;\n+    Label* code_stub = &dummy_label;\n+    if (!UseSIGTRAP && !C->output()->in_scratch_emit_size()) {\n+      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      __ relocate(relocInfo::poll_return_type);\n+    }\n+    __ safepoint_poll(*code_stub, temp, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2276,1 +2276,4 @@\n-    __ safepoint_poll(needs_safepoint, sync_state);\n+    \/\/ Note: We should not reach here with active stack watermark. There's no safepoint between\n+    \/\/       start of the native wrapper and this check where it could have been added.\n+    \/\/       We don't check the watermark in the fast path.\n+    __ safepoint_poll(needs_safepoint, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -2323,1 +2326,1 @@\n-    __ safepoint_poll(sync, sync_state);\n+    __ safepoint_poll(sync, sync_state, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -3022,1 +3025,1 @@\n-    return_pc_location = RegisterSaver::return_pc_is_lr;\n+    return_pc_location = RegisterSaver::return_pc_is_pre_saved;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1452,1 +1452,1 @@\n-  __ safepoint_poll(do_safepoint, sync_state);\n+  __ safepoint_poll(do_safepoint, sync_state, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1752,1 +1752,1 @@\n-    __ safepoint_poll(slow_path, sync_state);\n+    __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1806,1 +1806,1 @@\n-    __ safepoint_poll(slow_path, sync_state);\n+    __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -101,0 +101,1 @@\n+  constexpr static bool supports_stack_watermark_barrier() { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-  _poll_page_armed_value    = bad_page_val  + poll_bit();\n+  _poll_page_armed_value    = bad_page_val;\n","filename":"src\/hotspot\/os\/aix\/safepointMechanism_aix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -224,0 +224,1 @@\n+      CodeBlob *cb = NULL;\n@@ -234,3 +235,5 @@\n-      else if (USE_POLL_BIT_ONLY\n-               ? (sig == SIGTRAP && ((NativeInstruction*)pc)->is_safepoint_poll())\n-               : (sig == SIGSEGV && SafepointMechanism::is_poll_address(addr))) {\n+      else if ((sig == USE_POLL_BIT_ONLY ? SIGTRAP : SIGSEGV) &&\n+               ((NativeInstruction*)pc)->is_safepoint_poll() &&\n+               CodeCache::contains((void*) pc) &&\n+               ((cb = CodeCache::find_blob(pc)) != NULL) &&\n+               cb->is_compiled()) {\n@@ -245,0 +248,12 @@\n+      else if (UseSIGTRAP && sig == SIGTRAP &&\n+               ((NativeInstruction*)pc)->is_safepoint_poll_return() &&\n+               CodeCache::contains((void*) pc) &&\n+               ((cb = CodeCache::find_blob(pc)) != NULL) &&\n+               cb->is_compiled()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: safepoint_poll at return at \" INTPTR_FORMAT \" (nmethod)\", p2i(pc));\n+        }\n+        stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+        goto run_stub;\n+      }\n+\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -273,0 +273,11 @@\n+      else if (UseSIGTRAP && sig == SIGTRAP &&\n+               ((NativeInstruction*)pc)->is_safepoint_poll_return() &&\n+               CodeCache::contains((void*) pc) &&\n+               ((cb = CodeCache::find_blob(pc)) != NULL) &&\n+               cb->is_compiled()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: safepoint_poll at return at \" INTPTR_FORMAT \" (nmethod)\", p2i(pc));\n+        }\n+        stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+      }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}