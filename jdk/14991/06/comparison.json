{"files":[{"patch":"@@ -2794,1 +2794,1 @@\n-      if (Rd != Rs1) {                                                                        \\\n+      if (Rd != Rs1) {                                                                       \\\n@@ -2815,1 +2815,1 @@\n-      if (Rd != Rs1) {                                                                        \\\n+      if (Rd != Rs1) {                                                                       \\\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1375,0 +1375,61 @@\n+\/\/ According to Java SE specification, for floating-point round operations, if\n+\/\/ the input is NaN, +\/-infinity, or +\/-0, the same input is returned as the\n+\/\/ rounded result; this differs from behavior of RISC-V fcvt instructions (which\n+\/\/ round out-of-range values to the nearest max or min value), therefore special\n+\/\/ handling is needed by NaN, +\/-Infinity, +\/-0.\n+void C2_MacroAssembler::round_double_mode(FloatRegister dst, FloatRegister src, int round_mode, Register tmp1, Register tmp2, Register tmp3)\n+{\n+\n+  assert_different_registers(dst, src);\n+  assert_different_registers(tmp1, tmp2, tmp3);\n+\n+  \/\/ setting rounding mode for conversions\n+  \/\/ here we use similar modes to double->long and long->double conversions\n+  \/\/ different mode for long->double conversion matter only if long value was not representable as double\n+  \/\/ we got long value as a result of double->long conversion so it is defenitely representable\n+  RoundingMode rm;\n+  switch (round_mode) {\n+    case RoundDoubleModeNode::rmode_ceil:\n+      rm = RoundingMode::rup;\n+      break;\n+    case RoundDoubleModeNode::rmode_floor:\n+      rm = RoundingMode::rdn;\n+      break;\n+    case RoundDoubleModeNode::rmode_rint:\n+      rm = RoundingMode::rne;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  \/\/ tmp1 - is a register to store double converted to long int\n+  \/\/ tmp2 - is a register to create constant for comparsion\n+  \/\/ tmp3 - is a register were we store modidfied result of double -> long int comparison\n+  Label done, bad_val;\n+\n+  \/\/ generating constant (tmp2)\n+  \/\/ tmp2 = 100...0000\n+  addi(tmp2, zr, 1);\n+  slli(tmp2, tmp2, 63);\n+  \/\/ conversion from double to long\n+  fcvt_l_d(tmp1, src, rm);\n+\n+  \/\/ preparing converted long (tmp1)\n+  \/\/ as a result when conversion overflow we got:\n+  \/\/ tmp1 = 011...1111 or 100...0000\n+  \/\/ converting to: tmp3 = 100...0000\n+  addi(tmp3, tmp1, 1);\n+  andi(tmp3, tmp3, -2);\n+  beq(tmp3, tmp2, bad_val);\n+  \/\/ conversion from long to double\n+  fcvt_d_l(dst, tmp1, rm);\n+  \/\/ add sign of input value to result for +\/- 0 cases\n+  fsgnj_d(dst, dst, src);\n+  j(done);\n+  \/\/ if got conversion overflow return src\n+  bind(bad_val);\n+  fmv_d(dst, src);\n+\n+  bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+  void round_double_mode(FloatRegister dst, FloatRegister src, int round_mode, Register tmp1, Register tmp2, Register tmp3);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7697,0 +7697,14 @@\n+\/\/ Round Instruction\n+instruct roundD_reg(fRegD dst, fRegD src, immI rmode, iRegLNoSp tmp1, iRegLNoSp tmp2, iRegLNoSp tmp3) %{\n+  match(Set dst (RoundDoubleMode src rmode));\n+  ins_cost(2 * XFER_COST + BRANCH_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+\n+  format %{ \"RoundDoubleMode $src, $rmode\" %}\n+  ins_encode %{\n+    __ round_double_mode(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src$$reg), $rmode$$constant, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}