{"files":[{"patch":"@@ -2793,1 +2793,1 @@\n-      if (Rd != Rs1) {                                                                        \\\n+      if (Rd != Rs1) {                                                                       \\\n@@ -2814,1 +2814,1 @@\n-      if (Rd != Rs1) {                                                                        \\\n+      if (Rd != Rs1) {                                                                       \\\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4249,0 +4249,58 @@\n+\/\/ Round double with mode\n+\n+void MacroAssembler::round_double_mode(FloatRegister dst, FloatRegister src, enum Round_double_mode round_mode, Register converted_dbl, Register mask, Register converted_dbl_masked)\n+{\n+\n+  assert_different_registers(dst, src);\n+  assert_different_registers(converted_dbl, mask, converted_dbl_masked);\n+\n+  \/\/ setting roundig mode to double->long (rm_direct) and long->double (rm_back) conversions\n+  RoundingMode rm_direct, rm_back;\n+  switch (round_mode) {\n+    case Round_double_mode::rmode_ceil:\n+      rm_direct = RoundingMode::rup;\n+      rm_back = RoundingMode::rdn;\n+      break;\n+    case Round_double_mode::rmode_floor:\n+      rm_direct = RoundingMode::rdn;\n+      rm_back = RoundingMode::rup;\n+      break;\n+    case Round_double_mode::rmode_rint:\n+      rm_direct = RoundingMode::rne;\n+      rm_back = RoundingMode::rne;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  \/\/ converted_dbl - is a register to store double converted to long int\n+  \/\/ mask - is a register to create constant for comparsion\n+  \/\/ converted_dbl_masked - is a register were we stroe modidfied result of double -> long int comparison\n+  Label done, bad_val;\n+\n+  \/\/ generating constant (tmp2)\n+  \/\/ tmp2 = 100...0000\n+  addi(mask, zr, 1);\n+  slli(mask, mask, 63);\n+  \/\/ conversion from double to long\n+  fcvt_l_d(converted_dbl, src, rm_direct);\n+\n+  \/\/ preparing converted long (tmp1)\n+  \/\/ as a result when conversion overflow we got:\n+  \/\/ converted_dbl = 011...1111 or 100...0000\n+  \/\/ converting to: converted_dbl_masked = 100...0000\n+  addi(converted_dbl_masked, converted_dbl, 1);\n+  andi(converted_dbl_masked, converted_dbl_masked, -2);\n+  beq(converted_dbl_masked, mask, bad_val);\n+  \/\/ conversion from long to double\n+  fcvt_d_l(dst, converted_dbl, rm_back);\n+  \/\/ add sign of input value to result\n+  fsgnj_d(dst, dst, src);\n+  j(done);\n+  \/\/ if got conversion overflow return src\n+  bind(bad_val);\n+  fsgnj_d(dst, src, src);\n+\n+  bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1231,0 +1231,9 @@\n+  \/\/ round double modes which match Double.ceil\/floor\/int spec\n+  enum Round_double_mode {\n+    rmode_ceil,\n+    rmode_floor,\n+    rmode_rint\n+  };\n+\n+  void round_double_mode(FloatRegister dst, FloatRegister src, enum Round_double_mode round_mode, Register converted_dbl, Register mask, Register converted_dbl_masked);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4176,0 +4176,10 @@\n+pipe_class fp_rnd_d(fRegD dst, fRegD src)\n+%{\n+  instruction_count(10);\n+  multiple_bundles;\n+  src    : S1(read);\n+  dst    : S5(write);\n+  DECODE : ID;\n+  FPU    : S5;\n+%}\n+\n@@ -7692,0 +7702,28 @@\n+\/\/ Round Instruction\n+instruct roundD_reg(fRegD dst, fRegD src, immI rmode, iRegLNoSp tmp1, iRegLNoSp tmp2, iRegLNoSp tmp3, rFlagsReg cr) %{\n+  match(Set dst (RoundDoubleMode src rmode));\n+  ins_cost(2 * XFER_COST + BRANCH_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+\n+  format %{ \"RoundDoubleMode $src,$rmode\" %}\n+  ins_encode %{\n+  switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ round_double_mode(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src$$reg), MacroAssembler::Round_double_mode::rmode_rint, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ round_double_mode(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src$$reg), MacroAssembler::Round_double_mode::rmode_floor, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ round_double_mode(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src$$reg), MacroAssembler::Round_double_mode::rmode_ceil, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(fp_rnd_d);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"}]}