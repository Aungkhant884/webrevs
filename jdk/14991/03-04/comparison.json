{"files":[{"patch":"@@ -1375,0 +1375,61 @@\n+\/\/ According to Java SE specification, for floating-point round operations, if\n+\/\/ the input is NaN, +\/-infinity, or +\/-0, the same input is returned as the\n+\/\/ rounded result; this differs from behavior of RISC-V fcvt instructions (which\n+\/\/ round out-of-range values to the nearest max or min value), therefore special\n+\/\/ handling is needed by NaN, +\/-Infinity, +\/-0.\n+void C2_MacroAssembler::round_double_mode(FloatRegister dst, FloatRegister src, RoundDoubleModeNode round_mode, Register tmp1, Register tmp2, Register tmp3)\n+{\n+\n+  assert_different_registers(dst, src);\n+  assert_different_registers(tmp1, tmp2, tmp3);\n+\n+  \/\/ setting roundig mode to conversions\n+  \/\/ here we use similar modes to double->long and long->double conversions\n+  \/\/ different mode for long->double conversion matter only if long value was not representable as double\n+  \/\/ we got long value as a result of double->long conversion so it is defenitely representable\n+  RoundingMode rm;\n+  switch (round_mode) {\n+    case RoundDoubleModeNode::rmode_ceil:\n+      rm = RoundingMode::rup;\n+      break;\n+    case RoundDoubleModeNode::rmode_floor:\n+      rm = RoundingMode::rdn;\n+      break;\n+    case RoundDoubleModeNode::rmode_rint:\n+      rm = RoundingMode::rne;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  \/\/ tmp1 - is a register to store double converted to long int\n+  \/\/ tmp2 - is a register to create constant for comparsion\n+  \/\/ tmp3 - is a register were we store modidfied result of double -> long int comparison\n+  Label done, bad_val;\n+\n+  \/\/ generating constant (tmp2)\n+  \/\/ tmp2 = 100...0000\n+  addi(tmp2, zr, 1);\n+  slli(tmp2, tmp2, 63);\n+  \/\/ conversion from double to long\n+  fcvt_l_d(tmp1, src, rm);\n+\n+  \/\/ preparing converted long (tmp1)\n+  \/\/ as a result when conversion overflow we got:\n+  \/\/ tmp1 = 011...1111 or 100...0000\n+  \/\/ converting to: tmp3 = 100...0000\n+  addi(tmp3, tmp1, 1);\n+  andi(tmp3, tmp3, -2);\n+  beq(tmp3, tmp2, bad_val);\n+  \/\/ conversion from long to double\n+  fcvt_d_l(dst, tmp1, rm);\n+  \/\/ add sign of input value to result for +\/- 0 cases\n+  fsgnj_d(dst, dst, src);\n+  j(done);\n+  \/\/ if got conversion overflow return src\n+  bind(bad_val);\n+  fmv_d(dst, src);\n+\n+  bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -151,0 +151,2 @@\n+                 \n+  void round_double_mode(FloatRegister dst, FloatRegister src, RoundDoubleModeNode round_mode, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4277,61 +4277,0 @@\n-\/\/ According to Java SE specification, for floating-point round operations, if\n-\/\/ the input is NaN, +\/-infinity, or +\/-0, the same input is returned as the\n-\/\/ rounded result; this differs from behavior of RISC-V fcvt instructions (which\n-\/\/ round out-of-range values to the nearest max or min value), therefore special\n-\/\/ handling is needed by NaN, +\/-Infinity, +\/-0.\n-void MacroAssembler::round_double_mode(FloatRegister dst, FloatRegister src, enum Round_double_mode round_mode, Register tmp1, Register tmp2, Register tmp3)\n-{\n-\n-  assert_different_registers(dst, src);\n-  assert_different_registers(tmp1, tmp2, tmp3);\n-\n-  \/\/ setting roundig mode to conversions\n-  \/\/ here we use similar modes to double->long and long->double conversions\n-  \/\/ different mode for long->double conversion matter only if long value was not representable as double\n-  \/\/ we got long value as a result of double->long conversion so it is defenitely representable\n-  RoundingMode rm;\n-  switch (round_mode) {\n-    case Round_double_mode::rmode_ceil:\n-      rm = RoundingMode::rup;\n-      break;\n-    case Round_double_mode::rmode_floor:\n-      rm = RoundingMode::rdn;\n-      break;\n-    case Round_double_mode::rmode_rint:\n-      rm = RoundingMode::rne;\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  \/\/ tmp1 - is a register to store double converted to long int\n-  \/\/ tmp2 - is a register to create constant for comparsion\n-  \/\/ tmp3 - is a register were we store modidfied result of double -> long int comparison\n-  Label done, bad_val;\n-\n-  \/\/ generating constant (tmp2)\n-  \/\/ tmp2 = 100...0000\n-  addi(tmp2, zr, 1);\n-  slli(tmp2, tmp2, 63);\n-  \/\/ conversion from double to long\n-  fcvt_l_d(tmp1, src, rm);\n-\n-  \/\/ preparing converted long (tmp1)\n-  \/\/ as a result when conversion overflow we got:\n-  \/\/ tmp1 = 011...1111 or 100...0000\n-  \/\/ converting to: tmp3 = 100...0000\n-  addi(tmp3, tmp1, 1);\n-  andi(tmp3, tmp3, -2);\n-  beq(tmp3, tmp2, bad_val);\n-  \/\/ conversion from long to double\n-  fcvt_d_l(dst, tmp1, rm);\n-  \/\/ add sign of input value to result for +\/- 0 cases\n-  fsgnj_d(dst, dst, src);\n-  j(done);\n-  \/\/ if got conversion overflow return src\n-  bind(bad_val);\n-  fmv_d(dst, src);\n-\n-  bind(done);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1238,9 +1238,0 @@\n-  \/\/ round double modes which match Double.ceil\/floor\/int spec\n-  enum Round_double_mode {\n-    rmode_ceil,\n-    rmode_floor,\n-    rmode_rint\n-  };\n-\n-  void round_double_mode(FloatRegister dst, FloatRegister src, enum Round_double_mode round_mode, Register tmp1, Register tmp2, Register tmp3);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -7698,1 +7698,1 @@\n-instruct roundD_reg(fRegD dst, fRegD src, immI rmode, iRegLNoSp tmp1, iRegLNoSp tmp2, iRegLNoSp tmp3, rFlagsReg cr) %{\n+instruct roundD_reg(fRegD dst, fRegD src, immI rmode, iRegLNoSp tmp1, iRegLNoSp tmp2, iRegLNoSp tmp3) %{\n@@ -7705,16 +7705,2 @@\n-  switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ round_double_mode(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg), MacroAssembler::Round_double_mode::rmode_rint, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ round_double_mode(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg), MacroAssembler::Round_double_mode::rmode_floor, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ round_double_mode(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg), MacroAssembler::Round_double_mode::rmode_ceil, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n+    __ round_double_mode(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src$$reg), $rmode$$constant, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"}]}