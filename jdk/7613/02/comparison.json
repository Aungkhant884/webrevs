{"files":[{"patch":"@@ -741,2 +741,0 @@\n-java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java 8282270 linux-all\n-java\/awt\/Robot\/HiDPIScreenCapture\/HiDPIRobotScreenCaptureTest.java 8282270 windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.awt.Point;\n@@ -42,2 +41,2 @@\n- * @bug 8073320 8280861\n- * @summary  Linux and Windows HiDPI support\n+ * @bug 8073320\n+ * @summary  Windows HiDPI support\n@@ -48,2 +47,0 @@\n- * @run main\/othervm -Dsun.java2d.uiScale=1 HiDPIRobotScreenCaptureTest\n- * @run main\/othervm -Dsun.java2d.uiScale=2 HiDPIRobotScreenCaptureTest\n@@ -69,8 +66,1 @@\n-        \/\/ Position the frame on prime number coordinates to avoid\n-        \/\/ them being multiple of the desktop scale; this tests Linux\n-        \/\/ color picker better.\n-        \/\/ Also, the position should be far enough from the top left\n-        \/\/ corner of the screen to reduce the chance of being repositioned\n-        \/\/ by the system because that area's occupied by the global\n-        \/\/ menu bar and such.\n-        frame.setBounds(83, 97, 400, 300);\n+        frame.setBounds(83, 97, 100, 100);\n@@ -118,4 +108,4 @@\n-        checkRectColor(image, new Rectangle(0, 0, w \/ 2, h \/ 2), COLORS[0]);\n-        checkRectColor(image, new Rectangle(w \/ 2, 0, w \/ 2, h \/ 2), COLORS[1]);\n-        checkRectColor(image, new Rectangle(0, h \/ 2, w \/ 2, h \/ 2), COLORS[2]);\n-        checkRectColor(image, new Rectangle(w \/ 2, h \/ 2, w \/ 2, h \/ 2), COLORS[3]);\n+        checkRectColor(image, w \/ 4, h \/ 4, COLORS[0]);\n+        checkRectColor(image, 3 * w \/ 4, h \/ 4, COLORS[1]);\n+        checkRectColor(image, w \/ 4, 3 * h \/ 4, COLORS[2]);\n+        checkRectColor(image, 3 * w \/ 4, 3 * h \/ 4, COLORS[3]);\n@@ -124,25 +114,10 @@\n-    private static final int OFFSET = 5;\n-    static void checkRectColor(BufferedImage image, Rectangle rect, Color expectedColor) {\n-        System.out.println(\"Checking rectangle \" + rect + \" to have color \" + expectedColor);\n-        final Point[] pointsToCheck = new Point[] {\n-                new Point(rect.x + OFFSET, rect.y + OFFSET),                           \/\/ top left corner\n-                new Point(rect.x + rect.width - OFFSET, rect.y + OFFSET),              \/\/ top right corner\n-                new Point(rect.x + rect.width \/ 2, rect.y + rect.height \/ 2),          \/\/ center\n-                new Point(rect.x + OFFSET, rect.y + rect.height - OFFSET),             \/\/ bottom left corner\n-                new Point(rect.x + rect.width - OFFSET, rect.y + rect.height - OFFSET) \/\/ bottom right corner\n-        };\n-\n-        for (final var point : pointsToCheck) {\n-            System.out.print(\"Checking color at \" + point + \" to be equal to \" + expectedColor);\n-            final int actualColor = image.getRGB(point.x, point.y);\n-            if (actualColor != expectedColor.getRGB()) {\n-                System.out.println(\"... Mismatch: found \" + new Color(actualColor) + \" instead. Check image.png.\");\n-                try {\n-                    ImageIO.write(image, \"png\", new File(\"image.png\"));\n-                } catch(IOException e) {\n-                    System.out.println(\"failed to save image.png.\");\n-                    e.printStackTrace();\n-                }\n-                throw new RuntimeException(\"Wrong image color!\");\n-            } else {\n-                System.out.println(\"... OK\");\n+    static void checkRectColor(BufferedImage image, int x, int y, Color expectedColor) {\n+        System.out.println(\"Checking (\" + x + \", \" + y + \") to have color \" + expectedColor);\n+        final int actualColor = image.getRGB(x, y);\n+        if (actualColor != expectedColor.getRGB()) {\n+            System.out.println(\"... Mismatch: found \" + new Color(actualColor) + \" instead. Check image.png.\");\n+            try {\n+                ImageIO.write(image, \"png\", new File(\"image.png\"));\n+            } catch(IOException e) {\n+                System.out.println(\"failed to save image.png.\");\n+                e.printStackTrace();\n@@ -150,0 +125,3 @@\n+            throw new RuntimeException(\"Wrong image color!\");\n+        } else {\n+            System.out.println(\"... OK\");\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/HiDPIRobotScreenCaptureTest.java","additions":20,"deletions":42,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+import java.awt.image.BufferedImage;\n+import javax.swing.UIManager;\n+import javax.imageio.ImageIO;\n+import java.io.File;\n+import java.io.IOException;\n+\n@@ -43,2 +49,0 @@\n- * @run main\/othervm -Djdk.gtk.version=2 -Dsun.java2d.uiScale=2 ScreenCaptureGtkTest\n- * @run main\/othervm -Djdk.gtk.version=2 -Dsun.java2d.uiScale=3 ScreenCaptureGtkTest\n@@ -46,2 +50,0 @@\n- * @run main\/othervm -Djdk.gtk.version=3 -Dsun.java2d.uiScale=2 ScreenCaptureGtkTest\n- * @run main\/othervm -Djdk.gtk.version=3 -Dsun.java2d.uiScale=3 ScreenCaptureGtkTest\n@@ -55,0 +57,3 @@\n+        final int topOffset = 50;\n+        final int leftOffset = 50;\n+\n@@ -56,3 +61,3 @@\n-        \/\/ Position the frame on prime number coordinates to avoid\n-        \/\/ them being multiple of the desktop scale; this tests Linux\n-        \/\/ color picker better.\n+        \/\/ Position the frame such that color picker will work with\n+        \/\/ prime number coordinates to avoid them being multiple\n+        \/\/ of the desktop scale; this tests Linux color picker better.\n@@ -63,1 +68,1 @@\n-        frame.setBounds(83, 97, 400, 300);\n+        frame.setBounds(89, 99, 100, 100);\n@@ -79,1 +84,1 @@\n-                    g.fillRect(i, 0, 1, 1);\n+                    g.fillRect(leftOffset + i, topOffset, 1, 1);\n@@ -91,2 +96,1 @@\n-        final Point screenLocation = frame.getLocationOnScreen();\n-        checkPixelColors(robot, screenLocation.x, screenLocation.y);\n+        captureImageOf(frame, robot);\n@@ -94,2 +98,8 @@\n-        robot.delay(100);\n-        frame.dispose();\n+        final Point screenLocation = frame.getLocationOnScreen();\n+        try {\n+            checkPixelColors(robot, screenLocation.x + leftOffset,\n+                    screenLocation.y + topOffset);\n+        } finally {\n+            robot.delay(100);\n+            frame.dispose();\n+        }\n@@ -104,0 +114,1 @@\n+                saveImage();\n@@ -111,0 +122,20 @@\n+\n+    private static BufferedImage image;\n+\n+    static void captureImageOf(Frame frame, Robot robot) {\n+        Rectangle rect = frame.getBounds();\n+        rect.setLocation(frame.getLocationOnScreen());\n+\n+        System.out.println(\"Creating screen capture of \" + rect);\n+        image = robot.createScreenCapture(rect);\n+    }\n+\n+    static void saveImage() {\n+        System.out.println(\"Check image.png\");\n+        try {\n+            ImageIO.write(image, \"png\", new File(\"image.png\"));\n+        } catch(IOException e) {\n+            System.out.println(\"failed to save image.png.\");\n+            e.printStackTrace();\n+        }\n+    }\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"}]}