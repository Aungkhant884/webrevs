{"files":[{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.HttpHeaderParser;\n+\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Locale;\n+\n+\/*\n+ * @test\n+ * @bug 8289291\n+ * @summary Verifies that the HttpServer doesn't add the \"max\" parameter to the Keep-Alive header\n+ * that it sets in the response\n+ * @library \/test\/lib\n+ * @run main Http10KeepAliveMaxParamTest\n+ *\/\n+public class Http10KeepAliveMaxParamTest {\n+\n+    \/**\n+     * Sends a HTTP\/1.0 request with \"Connection: keep-alive\" header to the\n+     * com.sun.net.httpserver.HttpServer and then verifies that if the server responds back\n+     * with a \"Keep-Alive\" header in the response, then the header value doesn't have the\n+     * \"max\" parameter.\n+     *\/\n+    public static void main(final String[] args) throws Exception {\n+        final var bindAddr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        final int backlog = 0;\n+        final HttpServer server = HttpServer.create(bindAddr, backlog);\n+        server.createContext(\"\/\", (exchange) -> {\n+            System.out.println(\"Sending response for request \" + exchange.getRequestURI());\n+            exchange.sendResponseHeaders(200, 0);\n+            exchange.getResponseBody().close();\n+        });\n+        server.start();\n+        System.out.println(\"Server started at address \" + server.getAddress());\n+        try {\n+            try (final Socket sock = new Socket(bindAddr.getAddress(), server.getAddress().getPort())) {\n+                \/\/ send a HTTP\/1.0 request\n+                final String request = \"GET \/test\/foo HTTP\/1.0\\r\\nConnection: keep-alive\\r\\n\\r\\n\";\n+                final OutputStream os = sock.getOutputStream();\n+                os.write(request.getBytes(StandardCharsets.UTF_8));\n+                os.flush();\n+                System.out.println(\"Sent request to server:\");\n+                System.out.println(request);\n+                \/\/ read the response headers\n+                final HttpHeaderParser headerParser = new HttpHeaderParser(sock.getInputStream());\n+                \/\/ verify that the response contains 200 status code.\n+                \/\/ method is oddly named, but it returns status line of response\n+                final String statusLine = headerParser.getRequestDetails();\n+                System.out.println(\"Received status line \" + statusLine);\n+                if (statusLine == null || !statusLine.contains(\"200\")) {\n+                    throw new AssertionError(\"Unexpected response from server,\" +\n+                            \" status line = \" + statusLine);\n+                }\n+                System.out.println(\"Server responded with headers: \" + headerParser.getHeaderMap());\n+                \/\/ spec doesn't mandate the presence of the Keep-Alive header. We skip this test\n+                \/\/ if the server doesn't send one\n+                final List<String> keepAliveHeader = headerParser.getHeaderValue(\"keep-alive\");\n+                if (keepAliveHeader == null || keepAliveHeader.isEmpty()) {\n+                    \/\/ skip the test\n+                    System.out.println(\"Test SKIPPED since the server didn't return a keep-alive\" +\n+                            \" header in response\");\n+                    return;\n+                }\n+                \/\/ we expect only one keep-alive header and there shouldn't be any \"max\" parameter\n+                \/\/ in that value\n+                final String val = keepAliveHeader.get(0);\n+                if (val.toLowerCase(Locale.ROOT).contains(\"max\")) {\n+                    throw new AssertionError(\"Server wasn't supposed to send \" +\n+                            \"\\\"max\\\" parameter in keep-alive response header. \" +\n+                            \"Actual header value = \" + val);\n+                }\n+            }\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Http10KeepAliveMaxParamTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}