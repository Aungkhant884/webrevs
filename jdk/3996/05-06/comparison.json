{"files":[{"patch":"@@ -251,65 +251,0 @@\n-    \/**\n-     * Returns a filter that merges the status of this filter and another filter.\n-     * If the other filter is {@code null}, this filter is returned.\n-     * Otherwise, a filter is returned to merge the pair of {@code non-null} filters.\n-     *\n-     * @implSpec\n-     * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n-     * as follows:\n-     * <ul>\n-     *     <li>Invoke this filter on the {@code FilterInfo} to get its {@code status};\n-     *     <li>Return  {@code REJECTED} if the {@code status} is {@code REJECTED};\n-     *     <li>Invoke the {@code otherFilter} to get the {@code otherStatus};\n-     *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n-     *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n-     *          is {@code ALLOWED}, <\/li>\n-     *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n-     * <\/ul>\n-     *\n-     * @param otherFilter a filter to be merged with this filter, may be null\n-     * @return an {@link ObjectInputFilter} that merges the status of this and another filter\n-     * @since 17\n-     *\/\n-    default ObjectInputFilter merge(ObjectInputFilter otherFilter) {\n-        return (otherFilter == null) ? ObjectInputFilter.this : new Config.MergeFilter(this, otherFilter);\n-    }\n-\n-    \/**\n-     * Returns a filter that invokes this filter and maps {@code UNDECIDED} to {@code REJECTED}\n-     * for classes, with some exceptions, and otherwise returns the status.\n-     * The filter ensures that classes not {@code ALLOWED} and not {@code REJECTED} by this filter\n-     * are REJECTED, if the class is an array and the base component type is not allowed,\n-     * otherwise the result is {@code UNDECIDED}.\n-     *\n-     * <p>\n-     * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n-     * Adding a filter to reject undecided results for classes that have not been\n-     * either allowed or rejected can prevent classes from slipping through the filter.\n-     *\n-     * @implSpec\n-     * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n-     * as follows:\n-     * <ul>\n-     *     <li>Invoke this filter on the {@code FilterInfo} to get its {@code status};\n-     *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n-     *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n-     *          is {@code null};\n-     *     <li>Determine the base component type if the {@code serialClass} is\n-     *          an {@linkplain Class#isArray() array};\n-     *     <li>Return {@code UNDECIDED} if the base component type is\n-     *          a {@linkplain Class#isPrimitive() primitive class};\n-     *     <li>Invoke this filter on the {@code base component type} to get its\n-     *          {@code component status};<\/li>\n-     *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n-     *     <li>Otherwise, return {@code REJECTED}.<\/li>\n-     * <\/ul>\n-     *\n-     * @return an {@link ObjectInputFilter} that maps an {@link ObjectInputFilter.Status#UNDECIDED}\n-     *      status to {@link ObjectInputFilter.Status#REJECTED} for classes, otherwise returns the\n-     *      filter status\n-     * @since 17\n-     *\/\n-    default ObjectInputFilter rejectUndecidedClass() {\n-        return new Config.RejectUndecidedClass(this);\n-    }\n-\n@@ -406,1 +341,8 @@\n-     * {@linkplain Predicate predicate}.\n+     * {@linkplain Predicate predicate of a class}.\n+     *\n+     * <p>Composite filters combine or check the results of other filters.\n+     * The {@linkplain #merge(ObjectInputFilter, ObjectInputFilter) merge} filter combines\n+     * the status value of two filters.\n+     * The {@linkplain #rejectUndecidedClass(ObjectInputFilter) rejectUndecidedClass(filter)}\n+     * checks the result of a filter for classes when the status is {@code UNDECIDED}.\n+     * In many cases any class not {@code ALLOWED} by the filter should be {@code REJECTED}.\n@@ -922,0 +864,68 @@\n+        \/**\n+         * Returns a filter that merges the status of a filter and another filter.\n+         * If the other filter is {@code null}, the filter is returned.\n+         * Otherwise, a filter is returned to merge the pair of {@code non-null} filters.\n+         *\n+         * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n+         * as follows:\n+         * <ul>\n+         *     <li>Invoke {@code filter} on the {@code FilterInfo} to get its {@code status};\n+         *     <li>Return {@code REJECTED} if the {@code status} is {@code REJECTED};\n+         *     <li>Invoke the {@code otherFilter} to get the {@code otherStatus};\n+         *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n+         *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n+         *          is {@code ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter a filter, non-null\n+         * @param anotherFilter a filter to be merged with the filter, may be {@code null}\n+         * @return an {@link ObjectInputFilter} that merges the status of the filter and another filter\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter) {\n+            Objects.requireNonNull(filter, \"filter\");\n+            return (anotherFilter == null) ? filter : new MergeFilter(filter, anotherFilter);\n+        }\n+\n+        \/**\n+         * Returns a filter that invokes a filter and maps {@code UNDECIDED} to {@code REJECTED}\n+         * for classes, with some exceptions, and otherwise returns the status.\n+         * The filter returned checks that classes not {@code ALLOWED} and not {@code REJECTED} by the filter\n+         * are {@code REJECTED}, if the class is an array and the base component type is not allowed,\n+         * otherwise the result is {@code UNDECIDED}.\n+         *\n+         * <p>\n+         * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n+         * Adding a filter to reject undecided results for classes that have not been\n+         * either allowed or rejected can prevent classes from slipping through the filter.\n+         *\n+         * @implSpec\n+         * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n+         * as follows:\n+         * <ul>\n+         *     <li>Invoke the filter on the {@code FilterInfo} to get its {@code status};\n+         *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n+         *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n+         *          is {@code null};\n+         *     <li>Determine the base component type if the {@code serialClass} is\n+         *          an {@linkplain Class#isArray() array};\n+         *     <li>Return {@code UNDECIDED} if the base component type is\n+         *          a {@linkplain Class#isPrimitive() primitive class};\n+         *     <li>Invoke the filter on the {@code base component type} to get its\n+         *          {@code component status};<\/li>\n+         *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n+         *     <li>Otherwise, return {@code REJECTED}.<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter a filter, non-null\n+         * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n+         *      status to {@link Status#REJECTED} for classes, otherwise returns the\n+         *      filter status\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter) {\n+            Objects.requireNonNull(filter, \"filter\");\n+            return new RejectUndecidedFilter(filter);\n+        }\n+\n@@ -1322,1 +1332,1 @@\n-        private static class RejectUndecidedClass implements ObjectInputFilter {\n+        private static class RejectUndecidedFilter implements ObjectInputFilter {\n@@ -1325,1 +1335,1 @@\n-            private RejectUndecidedClass(ObjectInputFilter filter) {\n+            private RejectUndecidedFilter(ObjectInputFilter filter) {\n@@ -1352,1 +1362,1 @@\n-                    traceFilter(\"RejectUndecidedClass Array Component type {0} class: {1}, filter: {2}\",\n+                    traceFilter(\"RejectUndecidedFilter Array Component type {0} class: {1}, filter: {2}\",\n@@ -1356,1 +1366,1 @@\n-                traceFilter(\"RejectUndecidedClass {0} class: {1}, filter: {2}\",\n+                traceFilter(\"RejectUndecidedFilter {0} class: {1}, filter: {2}\",\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":80,"deletions":70,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                    filter = f.merge(filter);\n+                    filter = ObjectInputFilter.Config.merge(f, filter);\n@@ -278,1 +278,1 @@\n-                        filter = filter.rejectUndecidedClass();\n+                        filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n@@ -284,1 +284,1 @@\n-                    filter = next.merge(filter);\n+                    filter = ObjectInputFilter.Config.merge(next, filter);\n@@ -289,1 +289,1 @@\n-                    filter = filter.rejectUndecidedClass();\n+                    filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n@@ -299,1 +299,1 @@\n-                currFilter = (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n+                currFilter = (next == null) ? curr : ObjectInputFilter.Config.rejectUndecidedClass(ObjectInputFilter.Config.merge(next, curr));\n@@ -327,1 +327,1 @@\n-                    filter = filter.rejectUndecidedClass();\n+                    filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n@@ -333,1 +333,1 @@\n-                    filter = next.merge(filter).rejectUndecidedClass();\n+                    filter = ObjectInputFilter.Config.rejectUndecidedClass(ObjectInputFilter.Config.merge(next, filter));\n@@ -341,1 +341,1 @@\n-                return (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n+                return (next == null) ? curr : ObjectInputFilter.Config.rejectUndecidedClass(ObjectInputFilter.Config.merge(next, curr));\n@@ -399,4 +399,8 @@\n-         * Returns a filter that allows a class if a predicate on the class returns true.\n-         * <p>\n-         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n-         * the result is:\n+         * Returns a filter that returns {@code Status.ALLOWED} if the predicate\n+         * on the class is {@code true}.\n+         * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+         * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+         *\n+         * <p>When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+         * the predicate is applied to the {@link ObjectInputFilter.FilterInfo#serialClass() info.serialClass()},\n+         * the return Status is:\n@@ -404,2 +408,3 @@\n-         *     <li>{@link Status#ALLOWED}, if the predicate on the class returns {@code true}, <\/li>\n-         *     <li>Otherwise, return {@code otherStatus}<\/li>\n+         *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n@@ -410,1 +415,2 @@\n-         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader());\n+         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n+         *                                          || cl.getClassLoader() == null, Status.UNDECIDED);\n@@ -413,1 +419,1 @@\n-         * @param predicate a predicate to map a class to a boolean\n+         * @param predicate a predicate to test a non-null Class, non-null\n@@ -415,1 +421,3 @@\n-         * @return {@link Status#ALLOWED} if the predicate on the class returns true\n+         * @return a filter than returns {@code ALLOWED} if the predicate on the class returns {@code true},\n+         *          otherwise the {@code otherStatus}\n+         * @since 17\n@@ -424,4 +432,8 @@\n-         * Returns a filter that rejects a class if a predicate on the class returns true.\n-         * <p>\n-         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n-         * the result is:\n+         * Returns a filter that returns {@code Status.REJECTED} if the predicate\n+         * on the class is {@code true}.\n+         * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+         * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+         * the predicate is applied to the {@link ObjectInputFilter.FilterInfo#serialClass() serialClass()},\n+         * the return Status is:\n@@ -429,2 +441,3 @@\n-         *     <li>{@link Status#REJECTED}, if the predicate on the class returns {@code true}, <\/li>\n-         *     <li>Otherwise, return {@code otherStatus}<\/li>\n+         *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#REJECTED REJECTED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n@@ -435,1 +448,2 @@\n-         *     ObjectInputFilter f = rejectFilter(cl -> cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader());\n+         *     ObjectInputFilter f = rejectFilter(cl ->\n+         *          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);\n@@ -438,1 +452,1 @@\n-         * @param predicate a predicate to map a class to a boolean\n+         * @param predicate a predicate to test a non-null Class, non-null\n@@ -440,1 +454,3 @@\n-         * @return {@link Status#REJECTED} if the predicate on the class returns true\n+         * @return returns a filter that returns {@link Status#REJECTED REJECTED} if the predicate on the class\n+         *          returns {@code true}, otherwise {@link Status#UNDECIDED UNDECIDED}\n+         * @since 17\n@@ -449,11 +465,11 @@\n-         * Returns a filter that returns the result of combining a filter and another filter.\n-         * If the filter is null, the other filter is returned.\n-         * If the other filter is null, the filter is returned.\n-         * Otherwise, a new filter is returned wrapping the pair of non-null filters.\n-         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n-         * the result is:\n-         * <ul>\n-         *     <li>{@link Status#REJECTED}, if either filter returns {@link Status#REJECTED}, <\/li>\n-         *     <li>Otherwise, {@link Status#ALLOWED}, if either filter returned {@link Status#ALLOWED}, <\/li>\n-         *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n-         * <\/ul>\n+         * Returns a filter that returns {@code Status.ALLOWED} if the check is for limits\n+         * and not checking a class; otherwise {@code Status.UNDECIDED}.\n+         * If the {@link ObjectInputFilter.FilterInfo#serialClass() serialClass()} is {@code null}, the filter returns\n+         * {@code Status.ALLOWED}, otherwise return {@code Status.UNDECIDED}.\n+         * The limit values of {@link ObjectInputFilter.FilterInfo#arrayLength() arrayLength()},\n+         * {@link ObjectInputFilter.FilterInfo#depth() depth()}, {@link ObjectInputFilter.FilterInfo#references() references()},\n+         * and {@link ObjectInputFilter.FilterInfo#streamBytes() streamBytes()} are not checked.\n+         * To place a limit, create a separate filter with limits such as:\n+         * <pre>{@code\n+         * Config.createFilter(\"maxarray=10000,maxdepth=40\");\n+         * }<\/pre>\n@@ -461,16 +477,2 @@\n-         * @param filter      a filter to invoke first, may be null\n-         * @param otherFilter another filter to be checked after this filter, may be null\n-         * @return an {@link ObjectInputFilter} that returns the result of combining this filter and another filter\n-         *\/\n-        public static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter otherFilter) {\n-            if (filter == null)\n-                return otherFilter;\n-            return (otherFilter == null) ? filter :\n-                    new MergeFilter(filter, otherFilter);\n-        }\n-\n-        \/**\n-         * Returns a filter that merges the status of a list of filters.\n-         * <p>\n-         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n-         * the result is:\n+         * When the filter's {@link ObjectInputFilter#checkInput} method is invoked,\n+         * the Status returned is:\n@@ -478,4 +480,2 @@\n-         *     <li>{@link Status#UNDECIDED}, if the serialClass is null,<\/li>\n-         *     <li>Otherwize, {@link Status#REJECTED}, if any filter returns {@link Status#REJECTED}, <\/li>\n-         *     <li>Otherwise, {@link Status#ALLOWED}, if any filter returns {@link Status#ALLOWED}, <\/li>\n-         *     <li>Otherwise, return {@code otherStatus}<\/li>\n+         *     <li>{@link Status#ALLOWED ALLOWED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED UNDECIDED}<\/li>\n@@ -484,3 +484,3 @@\n-         * @param filters a List of filters evaluate\n-         * @param otherStatus the status to returned if none produce REJECTED or ALLOWED\n-         * @return an {@link ObjectInputFilter}\n+         * @return a filter that returns {@code Status.ALLOWED} if the check is for limits\n+         *          and not checking a class; otherwise {@code Status.UNDECIDED}\n+         * @since 17\n@@ -488,3 +488,2 @@\n-        public static ObjectInputFilter mergeOrUndecided(List<ObjectInputFilter> filters,\n-                                                         Status otherStatus) {\n-            return new MergeManyFilter(filters, otherStatus);\n+        public static ObjectInputFilter allowMaxLimits() {\n+            return new AllowMaxLimitsFilter(ALLOWED, UNDECIDED);\n@@ -494,4 +493,6 @@\n-         * Returns a filter that returns the complement of the status of invoking the filter.\n-         * <p>\n-         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n-         * the result is:\n+         * Returns a filter that merges the status of a filter and another filter.\n+         * If the other filter is {@code null}, the filter is returned.\n+         * Otherwise, a filter is returned to merge the pair of {@code non-null} filters.\n+         *\n+         * The filter returned implements the {@link ObjectInputFilter#checkInput(ObjectInputFilter.FilterInfo)} method\n+         * as follows:\n@@ -499,3 +500,7 @@\n-         *     <li>{@link Status#REJECTED}, if this filter returns {@link Status#ALLOWED}, <\/li>\n-         *     <li>{@link Status#ALLOWED}, if this filter  {@link Status#REJECTED}, <\/li>\n-         *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n+         *     <li>Invoke {@code filter} on the {@code FilterInfo} to get its {@code status};\n+         *     <li>Return {@code REJECTED} if the {@code status} is {@code REJECTED};\n+         *     <li>Invoke the {@code otherFilter} to get the {@code otherStatus};\n+         *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n+         *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n+         *          is {@code ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n@@ -504,2 +509,4 @@\n-         * @param filter a filter to wrap and complement its status\n-         * @return an {@link ObjectInputFilter}\n+         * @param filter a filter, non-null\n+         * @param anotherFilter a filter to be merged with the filter, may be {@code null}\n+         * @return an {@link ObjectInputFilter} that merges the status of the filter and another filter\n+         * @since 17\n@@ -507,2 +514,3 @@\n-        public static ObjectInputFilter not(ObjectInputFilter filter) {\n-            return new NotFilter(Objects.requireNonNull(filter, \"filter\"));\n+        public static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter) {\n+            Objects.requireNonNull(filter, \"filter\");\n+            return (anotherFilter == null) ? filter : new MergeFilter(filter, anotherFilter);\n@@ -512,4 +520,5 @@\n-         * Returns a filter that returns REJECTED if the a filter returns UNDECIDED.\n-         * Object serialization accepts a class if the filter returns UNDECIDED or ALLOWED.\n-         * Appending a filter to reject undefined results for classes that have not been\n-         * either allowed or rejected can prevent classes from slipping through the filter.\n+         * Returns a filter that invokes a filter and maps {@code UNDECIDED} to {@code REJECTED}\n+         * for classes, with some exceptions, and otherwise returns the status.\n+         * The filter returned checks that classes not {@code ALLOWED} and not {@code REJECTED} by the filter\n+         * are {@code REJECTED}, if the class is an array and the base component type is not allowed,\n+         * otherwise the result is {@code UNDECIDED}.\n@@ -518,2 +527,7 @@\n-         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n-         * the result is:\n+         * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n+         * Adding a filter to reject undecided results for classes that have not been\n+         * either allowed or rejected can prevent classes from slipping through the filter.\n+         *\n+         * @implSpec\n+         * The filter returned implements the {@link ObjectInputFilter#checkInput(ObjectInputFilter.FilterInfo)} method\n+         * as follows:\n@@ -521,2 +535,12 @@\n-         *     <li>{@link Status#ALLOWED}, if this filter  {@link Status#ALLOWED}, <\/li>\n-         *     <li>Otherwise, return {@link Status#REJECTED}<\/li>\n+         *     <li>Invoke the filter on the {@code FilterInfo} to get its {@code status};\n+         *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n+         *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n+         *          is {@code null};\n+         *     <li>Determine the base component type if the {@code serialClass} is\n+         *          an {@linkplain Class#isArray() array};\n+         *     <li>Return {@code UNDECIDED} if the base component type is\n+         *          a {@linkplain Class#isPrimitive() primitive class};\n+         *     <li>Invoke the filter on the {@code base component type} to get its\n+         *          {@code component status};<\/li>\n+         *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n+         *     <li>Otherwise, return {@code REJECTED}.<\/li>\n@@ -525,1 +549,1 @@\n-         * @param filter a filter to map the UNDECIDED status to REJECTED\n+         * @param filter a filter, non-null\n@@ -527,1 +551,3 @@\n-         * status to {@link Status#REJECTED}\n+         *      status to {@link Status#REJECTED} for classes, otherwise returns the\n+         *      filter status\n+         * @since 17\n@@ -529,2 +555,3 @@\n-        public static ObjectInputFilter rejectUndecided(ObjectInputFilter filter) {\n-            return new RejectUndecided(Objects.requireNonNull(filter, \"filter\"));\n+        public static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter) {\n+            Objects.requireNonNull(filter, \"filter\");\n+            return new RejectUndecidedFilter(filter);\n@@ -564,2 +591,3 @@\n-                return (info.serialClass() != null &&\n-                        predicate.test(info.serialClass())) ? ifTrueStatus : ifFalseStatus;\n+                Class<?> clazz = info.serialClass();\n+                Status status = (clazz != null && predicate.test(clazz)) ? ifTrueStatus : ifFalseStatus;\n+                return status;\n@@ -574,1 +602,30 @@\n-         * An ObjectInputFilter that merges the results of two filters.\n+         * An ObjectInputFilter to evaluate if a FilterInfo is checking only limits,\n+         * and not classes.\n+         *\/\n+        private static class AllowMaxLimitsFilter implements ObjectInputFilter {\n+            private final Status limitCheck;\n+            private final Status classCheck;\n+\n+            AllowMaxLimitsFilter(Status limitCheck, Status classCheck) {\n+                this.limitCheck = limitCheck;\n+                this.classCheck = classCheck;\n+            }\n+\n+            \/**\n+             * If the FilterInfo is only checking a limit, return the requested\n+             * status, otherwise the other status.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of corresponding to serialClass == null or not\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                return (info.serialClass() == null) ? limitCheck : classCheck;\n+            }\n+\n+            public String toString() {\n+                return \"allowMaxLimits()\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the status of two filters.\n@@ -581,2 +638,2 @@\n-                this.first = Objects.requireNonNull(first, \"first\");\n-                this.second = Objects.requireNonNull(second, \"second\");\n+                this.first = first;\n+                this.second = second;\n@@ -587,2 +644,2 @@\n-             * and ALLOWED if any of the filters returns ALLOWED.\n-             * Returns UNDECIDED if there is no class to be checked or all filters return UNDECIDED.\n+             * and ALLOWED if either of the filters returns ALLOWED.\n+             * Returns {@code UNDECIDED} if either filter returns {@code UNDECIDED}.\n@@ -593,1 +650,1 @@\n-             * UNDECIDED if there is no class to check or both filters returned UNDECIDED\n+             * {@code UNDECIDED} if both filters returned {@code UNDECIDED}\n@@ -596,1 +653,0 @@\n-                if (info.serialClass() == null) return UNDECIDED;\n@@ -617,0 +673,83 @@\n+        \/**\n+         * A filter that maps the status {@code UNDECIDED} to {@code REJECTED} when checking a class.\n+         *\/\n+        private static class RejectUndecidedFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter filter;\n+\n+            private RejectUndecidedFilter(ObjectInputFilter filter) {\n+                this.filter = Objects.requireNonNull(filter, \"filter\");\n+            }\n+\n+            \/**\n+             * Apply the filter and return the status if not UNDECIDED and checking a class.\n+             * For array classes, re-check the final component type against the filter.\n+             * Make an exception for Primitive classes that are implicitly allowed by the pattern based filter.\n+             * @param info the FilterInfo\n+             * @return the status of applying the filter and checking the class\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status status = Objects.requireNonNull(filter.checkInput(info), \"status\");\n+                Class<?> clazz = info.serialClass();\n+                if (clazz == null || !UNDECIDED.equals(status))\n+                    return status;\n+                status = REJECTED;\n+                \/\/ Find the base component type\n+                while (clazz.isArray()) {\n+                    clazz = clazz.getComponentType();\n+                }\n+                if (clazz.isPrimitive()) {\n+                    status = UNDECIDED;\n+                } else {\n+                    \/\/ for non-primitive types;  re-filter the base component type\n+                    FilterInfo clazzInfo = new SerialInfo(info, clazz);\n+                    Status clazzStatus = filter.checkInput(clazzInfo);\n+                    status = (ALLOWED.equals(clazzStatus)) ? ALLOWED : REJECTED;\n+                }\n+                return status;\n+            }\n+\n+            public String toString() {\n+                return \"rejectUndecidedClass(\" + filter + \")\";\n+            }\n+\n+            \/**\n+             * FilterInfo instance with a specific class and delegating to an existing FilterInfo.\n+             * Nested in the rejectUndecided class.\n+             *\/\n+            static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+                private final FilterInfo base;\n+                private final Class<?> clazz;\n+\n+                SerialInfo(FilterInfo base, Class<?> clazz) {\n+                    this.base = base;\n+                    this.clazz = clazz;\n+                }\n+\n+                @Override\n+                public Class<?> serialClass() {\n+                    return clazz;\n+                }\n+\n+                @Override\n+                public long arrayLength() {\n+                    return base.arrayLength();\n+                }\n+\n+                @Override\n+                public long depth() {\n+                    return base.depth();\n+                }\n+\n+                @Override\n+                public long references() {\n+                    return base.references();\n+                }\n+\n+                @Override\n+                public long streamBytes() {\n+                    return base.streamBytes();\n+                }\n+            }\n+\n+        }\n+\n@@ -663,58 +802,0 @@\n-         * An ObjectInputFilter that combines the results of two filters.\n-         *\/\n-        private static class NotFilter implements ObjectInputFilter {\n-            private final ObjectInputFilter other;\n-\n-            NotFilter(ObjectInputFilter filter) {\n-                this.other = filter;\n-            }\n-\n-            \/**\n-             * Returns the complement of the result of the filter.\n-             * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n-             * the result is:\n-             * <ul>\n-             *     <li>REJECTED, if the other filter returns {@link Status#ALLOWED}, <\/li>\n-             *     <li>ALLOWED, if the other filter returns {@link Status#REJECTED}, <\/li>\n-             *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n-             * <\/ul>\n-             *\n-             * @param info the FilterInfo\n-             * @return\n-             *\/\n-            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n-                Status status = Objects.requireNonNull(other.checkInput(info), \"status\");\n-                if (ALLOWED.equals(status)) return REJECTED;\n-                if (REJECTED.equals(status)) return ALLOWED;\n-                return UNDECIDED;\n-            }\n-        }\n-\n-        \/**\n-         * An ObjectInputFilter that rejects a class if the other filter returned UNDECIDED.\n-         *\/\n-        private static class RejectUndecided implements ObjectInputFilter {\n-            private final ObjectInputFilter filter;\n-\n-            private RejectUndecided(ObjectInputFilter filter) {\n-                this.filter = Objects.requireNonNull(filter, \"filter\");\n-            }\n-\n-            \/**\n-             * Apply the filter and return the status if ALLOWED, otherwise REJECTED.\n-             * The effect is to map UNDECIDED to REJECTED, and otherwise return the status.\n-             *\n-             * @param info the FilterInfo\n-             * @return the status of applying the filter if ALLOWED, otherwise REJECTED\n-             *\/\n-            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n-                Status status = Objects.requireNonNull(filter.checkInput(info), \"status\");\n-                return ALLOWED.equals(status) ? ObjectInputFilter.Status.ALLOWED : REJECTED;\n-            }\n-\n-            public String toString() {\n-                return \"rejectUndecided(\" + filter.toString() + \")\";\n-            }\n-        }\n-\n-        \/**\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":234,"deletions":153,"binary":false,"changes":387,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-                ObjectInputFilter f = getFilter(st1).merge(getFilter(st2));\n+                ObjectInputFilter f = Config.merge(getFilter(st1), getFilter(st2));\n@@ -288,1 +288,1 @@\n-        Assert.assertEquals(undecided.rejectUndecidedClass().checkInput(info), REJECTED, \"undecided -> rejected\");\n+        Assert.assertEquals(Config.rejectUndecidedClass(undecided).checkInput(info), REJECTED, \"undecided -> rejected\");\n@@ -290,1 +290,1 @@\n-        Assert.assertEquals(allowed.rejectUndecidedClass().checkInput(info), ALLOWED, \"allowed -> rejected\");\n+        Assert.assertEquals(Config.rejectUndecidedClass(allowed).checkInput(info), ALLOWED, \"allowed -> rejected\");\n@@ -292,1 +292,1 @@\n-        Assert.assertEquals(rejected.rejectUndecidedClass().checkInput(info), REJECTED, \"rejected -> rejected\");\n+        Assert.assertEquals(Config.rejectUndecidedClass(rejected).checkInput(info), REJECTED, \"rejected -> rejected\");\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFactoryTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}