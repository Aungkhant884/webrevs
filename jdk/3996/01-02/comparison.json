{"files":[{"patch":"@@ -39,1 +39,1 @@\n-import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n@@ -72,1 +72,1 @@\n- * {@linkplain Config#setSerialFilterFactory(BiFunction) filter factory} can better\n+ * {@linkplain Config#setSerialFilterFactory(BinaryOperator) filter factory} can better\n@@ -90,1 +90,1 @@\n- * <li>A JVM-wide filter factory can be set via {@link Config#setSerialFilterFactory(BiFunction)}\n+ * <li>A JVM-wide filter factory can be set via {@link Config#setSerialFilterFactory(BinaryOperator)}\n@@ -106,1 +106,1 @@\n- *     {@linkplain Config#setSerialFilterFactory(BiFunction) JVM-wide filter factory}.\n+ *     {@linkplain Config#setSerialFilterFactory(BinaryOperator) JVM-wide filter factory}.\n@@ -151,2 +151,1 @@\n- * public static final class FilterInThread\n- *           implements BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> {\n+ * public static final class FilterInThread implements BinaryOperator<ObjectInputFilter> {\n@@ -164,3 +163,1 @@\n- *             \/\/ no current filter, prepend next to threadFilter, both may be null or non-null\n- *\n- *             \/\/ Assemble the filters in sequence, most recently added first\n+ *             \/\/ Prepend next to the threadFilter, both may be null or non-null\n@@ -168,0 +165,4 @@\n+ *             if (filter != null) {\n+ *                 \/\/ Prepend a filter to assert that all classes have been Allowed or Rejected\n+ *                 filter = filter.rejectUndecidedClass();\n+ *             }\n@@ -171,3 +172,0 @@\n- *                 filter = next.merge(filter);\n- *             }\n- *             if (filter != null) {\n@@ -175,1 +173,1 @@\n- *                 filter = filter.rejectUndecided();\n+ *                 filter = next.merge(filter).rejectUndecidedClass();\n@@ -179,3 +177,5 @@\n- *             \/\/ Called from OIS.setObjectInputFilter with a previously set filter.\n- *             \/\/ Prepend the stream-specific filter or use the current filter\n- *             return (next == null) ? curr : next.merge(curr);\n+ *             \/\/ Called from OIS.setObjectInputFilter with a current filter and a stream-specific filter.\n+ *             \/\/ The curr filter already incorporates the thread filter and static JVM-wide filter\n+ *             \/\/ and rejection of undecided classes\n+ *             \/\/ Use the current filter or prepend the stream-specific filter and recheck for undecided\n+ *             return (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n@@ -262,3 +262,3 @@\n-     * Returns a filter that maps the status {@code UNDECIDED} to {@code Status.REJECTED},\n-     * otherwise return the {@code REJECTED} or {@code ALLOWED} status.\n-     * Object serialization accepts a class if the filter returns {@code UNDECIDED} or {@code ALLOWED}.\n+     * Returns a filter, that when applied to this filter that is checking a class, maps\n+     * {@code Status.UNDECIDED} to {@code Status.REJECTED}, otherwise returns the status of the other filter.\n+     * Object serialization accepts a class if the filter returns {@code UNDECIDED}.\n@@ -267,1 +267,0 @@\n-     *\n@@ -272,2 +271,3 @@\n-     *     <li>{@link ObjectInputFilter.Status#ALLOWED}, if this filter  {@link ObjectInputFilter.Status#ALLOWED}, <\/li>\n-     *     <li>Otherwise, return {@link ObjectInputFilter.Status#REJECTED}<\/li>\n+     *     <li>{@link ObjectInputFilter.Status#REJECTED}, if the filter is checking a class\n+     *     and the filter returns {@link ObjectInputFilter.Status#UNDECIDED}, <\/li>\n+     *     <li>Otherwise, return the status<\/li>\n@@ -277,1 +277,2 @@\n-     *      status to {@link ObjectInputFilter.Status#REJECTED}\n+     *      status to {@link ObjectInputFilter.Status#REJECTED} for classes, otherwise returns the\n+     *      filter status\n@@ -279,1 +280,1 @@\n-    default ObjectInputFilter rejectUndecided() {\n+    default ObjectInputFilter rejectUndecidedClass() {\n@@ -375,1 +376,1 @@\n-     * Setting a {@linkplain #setSerialFilterFactory(BiFunction) deserialization filter factory}\n+     * Setting a {@linkplain #setSerialFilterFactory(BinaryOperator) deserialization filter factory}\n@@ -381,1 +382,1 @@\n-     * If a JVM-wide filter factory is {@linkplain Config#setSerialFilterFactory(BiFunction) not set}\n+     * If a JVM-wide filter factory is {@linkplain Config#setSerialFilterFactory(BinaryOperator) not set}\n@@ -408,1 +409,1 @@\n-     * {@link BiFunction} interface,\n+     * {@link BinaryOperator} interface,\n@@ -411,1 +412,1 @@\n-     * can NOT be replaced with {@link #setSerialFilterFactory(BiFunction) Config.setSerialFilterFactory}.\n+     * can NOT be replaced with {@link #setSerialFilterFactory(BinaryOperator) Config.setSerialFilterFactory}.\n@@ -445,1 +446,1 @@\n-         * @see Config#setSerialFilterFactory(BiFunction)\n+         * @see Config#setSerialFilterFactory(BinaryOperator)\n@@ -447,1 +448,1 @@\n-        private static volatile BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter>\n+        private static volatile BinaryOperator<ObjectInputFilter>\n@@ -502,1 +503,1 @@\n-            BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> factory;\n+            BinaryOperator<ObjectInputFilter> factory;\n@@ -514,2 +515,2 @@\n-                    BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> f =\n-                            (BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter>)\n+                    BinaryOperator<ObjectInputFilter> f =\n+                            (BinaryOperator<ObjectInputFilter>)\n@@ -588,1 +589,1 @@\n-         * If the filter factory has been {@link #setSerialFilterFactory(BiFunction) set} it is returned,\n+         * If the filter factory has been {@link #setSerialFilterFactory(BinaryOperator) set} it is returned,\n@@ -610,1 +611,1 @@\n-        public static BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> getSerialFilterFactory() {\n+        public static BinaryOperator<ObjectInputFilter> getSerialFilterFactory() {\n@@ -641,1 +642,1 @@\n-                BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> filterFactory) {\n+                BinaryOperator<ObjectInputFilter> filterFactory) {\n@@ -1077,1 +1078,2 @@\n-                return Status.UNDECIDED;\n+                \/\/ There are no classes to check and none of the limits have been exceeded.\n+                return Status.ALLOWED;\n@@ -1246,1 +1248,1 @@\n-                implements BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> {\n+                implements BinaryOperator<ObjectInputFilter> {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":40,"deletions":38,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n@@ -195,1 +195,1 @@\n- * <li>A JVM-wide filter factory can be set via {@link Config#setSerialFilterFactory(BiFunction)}\n+ * <li>A JVM-wide filter factory can be set via {@link Config#setSerialFilterFactory(BinaryOperator)}\n@@ -211,1 +211,1 @@\n- *     {@linkplain Config#setSerialFilterFactory(BiFunction) JVM-wide filter factory}.\n+ *     {@linkplain Config#setSerialFilterFactory(BinaryOperator) JVM-wide filter factory}.\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -41,1 +42,1 @@\n-import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n@@ -95,2 +96,1 @@\n-                {new Point(1, 3), Filters.allowPlatformClasses()\n-                            .merge(ObjectInputFilter.Config.allowMaxLimits()),   \/\/ class is null in all of the metrics checks\n+                {new Point(1, 3), Filters.allowPlatformClasses(),\n@@ -98,2 +98,3 @@\n-                {new Point(1, 4), ObjectInputFilter.Config.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader(), UNDECIDED)\n-                            .merge(ObjectInputFilter.Config.allowMaxLimits()),    \/\/ allow all of the metrics checks\n+                {new Point(1, 4), ObjectInputFilter.Config.createFilter(\"java.lang.Integer\"),\n+                        InvalidClassException.class},\n+                {new Point(1, 5), ObjectInputFilter.Config.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader(), UNDECIDED),\n@@ -149,1 +150,1 @@\n-            implements BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> {\n+            implements BinaryOperator<ObjectInputFilter> {\n@@ -225,0 +226,5 @@\n+                    \/\/ Prepend a filter to assert that all classes have been Allowed or Rejected\n+                    if (filter != null) {\n+                        filter = filter.rejectUndecidedClass();\n+                    }\n+\n@@ -227,0 +233,1 @@\n+                    \/\/ The static JVM-wide filter allow, reject, or leave classes undecided\n@@ -229,0 +236,1 @@\n+                \/\/ Check that the static JVM-wide filter did not leave any classes undecided\n@@ -231,1 +239,1 @@\n-                    filter = filter.rejectUndecided();\n+                    filter = filter.rejectUndecidedClass();\n@@ -233,0 +241,2 @@\n+                \/\/ Return the filter, unless a stream-specific filter is set later\n+                \/\/ The filter may be null if no filters are configured\n@@ -237,2 +247,2 @@\n-                \/\/ Prepend the stream-specific filter or the current filter if not stream-specific filter\n-                return (next == null) ? curr : next.merge(curr);\n+                \/\/ Prepend the stream-specific filter or the current filter if no stream-specific filter\n+                return (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n@@ -244,0 +254,49 @@\n+    \/**\n+     * Simple example code from the ObjectInputFilter Class javadoc.\n+     *\/\n+    public static final class SimpleFilterInThread implements BinaryOperator<ObjectInputFilter> {\n+\n+        private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new InheritableThreadLocal<>();\n+\n+        \/\/ Construct a FilterInThread deserialization filter factory.\n+        public SimpleFilterInThread() {}\n+\n+        \/\/ Returns a composite filter of the static JVM-wide filter, a thread-specific filter,\n+        \/\/ and the stream-specific filter.\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            if (curr == null) {\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no previous filter\n+                \/\/ Prepend next to the threadFilter, both may be null or non-null\n+                var filter = filterThreadLocal.get();\n+                if (filter != null) {\n+                    \/\/ Prepend a filter to assert that all classes have been Allowed or Rejected\n+                    filter = filter.rejectUndecidedClass();\n+                }\n+                if (next != null) {\n+                    \/\/ Prepend the next filter to the thread filter, if any\n+                    \/\/ Initially this would be the static JVM-wide filter passed from the OIS constructor\n+                    \/\/ Append the filter to reject all UNDECIDED results\n+                    filter = next.merge(filter).rejectUndecidedClass();\n+                }\n+                return filter;\n+            } else {\n+                \/\/ Called from OIS.setObjectInputFilter with a current filter and a stream-specific filter.\n+                \/\/ The curr filter already incorporates the thread filter and static JVM-wide filter\n+                \/\/ and rejection of undecided classes\n+                \/\/ Use the current filter or prepend the stream-specific filter and recheck for undecided\n+                return (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n+            }\n+        }\n+\n+        \/\/ Applies the filter to the thread and invokes the runnable.\n+        public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+            var prevFilter = filterThreadLocal.get();\n+            try {\n+                filterThreadLocal.set(filter);\n+                runnable.run();\n+            } finally {\n+                filterThreadLocal.set(prevFilter);\n+            }\n+        }\n+    }\n+\n@@ -359,0 +418,21 @@\n+        \/**\n+         * Returns a filter that merges the status of a list of filters.\n+         * <p>\n+         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+         * the result is:\n+         * <ul>\n+         *     <li>{@link Status#UNDECIDED}, if the serialClass is null,<\/li>\n+         *     <li>Otherwize, {@link Status#REJECTED}, if any filter returns {@link Status#REJECTED}, <\/li>\n+         *     <li>Otherwise, {@link Status#ALLOWED}, if any filter returns {@link Status#ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@code otherStatus}<\/li>\n+         * <\/ul>\n+         *\n+         * @param filters a List of filters evaluate\n+         * @param otherStatus the status to returned if none produce REJECTED or ALLOWED\n+         * @return an {@link ObjectInputFilter}\n+         *\/\n+        public static ObjectInputFilter mergeOrUndecided(List<ObjectInputFilter> filters,\n+                                                         Status otherStatus) {\n+            return new MergeManyFilter(filters, otherStatus);\n+        }\n+\n@@ -483,0 +563,45 @@\n+        \/**\n+         * An ObjectInputFilter that merges the results of two filters.\n+         *\/\n+        private static class MergeManyFilter implements ObjectInputFilter {\n+            private final List<ObjectInputFilter> filters;\n+            private final Status otherStatus;\n+\n+            MergeManyFilter(List<ObjectInputFilter> first, Status otherStatus) {\n+                this.filters = Objects.requireNonNull(first, \"filters\");\n+                this.otherStatus = Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            }\n+\n+            \/**\n+             * Returns REJECTED if any of the filters returns REJECTED,\n+             * and ALLOWED if any of the filters returns ALLOWED.\n+             * Returns UNDECIDED if there is no class to be checked or all filters return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return Status.UNDECIDED if there is no class to check,\n+             *      Status.REJECTED if any of the filters returns REJECTED,\n+             *      Status.ALLOWED if any filter returns ALLOWED;\n+             *      otherwise returns {@code otherStatus}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                if (info.serialClass() == null)\n+                    return UNDECIDED;\n+                Status status = otherStatus;\n+                for (ObjectInputFilter filter : filters) {\n+                    Status aStatus = filter.checkInput(info);\n+                    if (REJECTED.equals(aStatus)) {\n+                        return REJECTED;\n+                    }\n+                    if (ALLOWED.equals(aStatus)) {\n+                        status = ALLOWED;\n+                    }\n+                }\n+                return status;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"mergeManyFilter(\" + filters + \")\";\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":134,"deletions":9,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-import java.util.Objects;\n-import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n@@ -65,1 +64,1 @@\n-    private static final BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> jdkSerialFilterFactory\n+    private static final BinaryOperator<ObjectInputFilter> jdkSerialFilterFactory\n@@ -289,1 +288,1 @@\n-        Assert.assertEquals(undecided.rejectUndecided().checkInput(info), REJECTED, \"undecided -> rejected\");\n+        Assert.assertEquals(undecided.rejectUndecidedClass().checkInput(info), REJECTED, \"undecided -> rejected\");\n@@ -291,1 +290,1 @@\n-        Assert.assertEquals(allowed.rejectUndecided().checkInput(info), ALLOWED, \"allowed -> rejected\");\n+        Assert.assertEquals(allowed.rejectUndecidedClass().checkInput(info), ALLOWED, \"allowed -> rejected\");\n@@ -293,1 +292,1 @@\n-        Assert.assertEquals(rejected.rejectUndecided().checkInput(info), REJECTED, \"rejected -> rejected\");\n+        Assert.assertEquals(rejected.rejectUndecidedClass().checkInput(info), REJECTED, \"rejected -> rejected\");\n@@ -327,1 +326,1 @@\n-            implements BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> {\n+            implements BinaryOperator<ObjectInputFilter> {\n@@ -387,1 +386,1 @@\n-            implements BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> {\n+            implements BinaryOperator<ObjectInputFilter> {\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFactoryTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"}]}