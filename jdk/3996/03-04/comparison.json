{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -83,2 +82,4 @@\n- * <p> When a filter is set on an {@link ObjectInputStream}, the {@link #checkInput checkInput(FilterInfo)}\n- * method is called to validate classes, the length of each array,\n+ * <p>\n+ * If a filter is set on an ObjectInputStream, the filter's {@link #checkInput checkInput(FilterInfo)}\n+ * method is invoked zero or more times while {@linkplain ObjectInputStream#readObject() reading objects}.\n+ * The method is called to validate classes, the length of each array,\n@@ -87,2 +88,0 @@\n- * The filter is invoked zero or more times\n- * while {@linkplain ObjectInputStream#readObject() reading objects}.\n@@ -123,1 +122,1 @@\n- * This allows a filter to specific about the choice it is reporting and\n+ * This allows a filter to be specific about the choice it is reporting and\n@@ -266,3 +265,8 @@\n-     * Returns a filter, that when applied to this filter that is checking a class, maps\n-     * {@code Status.UNDECIDED} to {@code Status.REJECTED}, otherwise returns the status of this filter.\n-     * Object serialization accepts a class if the filter returns {@code UNDECIDED}.\n+     * Returns a filter that invokes this filter and maps UNDECIDED to REJECTED for classes,\n+     * with some exceptions, and otherwise returns the status.\n+     * The filter ensures that classes not ALLOWED and not REJECTED by this filter\n+     * are REJECTED, if the class is an array and the base component type is not allowed,\n+     * otherwise the result is UNDECIDED.\n+     *\n+     * <p>\n+     * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n@@ -285,1 +289,1 @@\n-        return new Config.RejectUndecided(this);\n+        return new Config.RejectUndecidedClass(this);\n@@ -386,1 +390,1 @@\n-     * with the initial filter returned from the first call and the requested new filter.\n+     * with the stream's initial filter, and the requested new filter.\n@@ -404,1 +408,0 @@\n-     * For example, by calling {@link #getSerialFilter() Config.getSerialFilter}.\n@@ -423,1 +426,1 @@\n-     * be accessible via the {@linkplain ClassLoader#getSystemClassLoader() the application class loader}.\n+     * be accessible via the {@linkplain ClassLoader#getSystemClassLoader() application class loader}.\n@@ -1093,2 +1096,2 @@\n-                        traceFilter(\"Pattern ALLOWED, primitive class: {0}, filter: {1}\", clazz, this);\n-                        return Status.ALLOWED;\n+                        traceFilter(\"Pattern UNDECIDED, primitive class: {0}, filter: {1}\", clazz, this);\n+                        return UNDECIDED;\n@@ -1249,1 +1252,1 @@\n-        private static class RejectUndecided implements ObjectInputFilter {\n+        private static class RejectUndecidedClass implements ObjectInputFilter {\n@@ -1252,1 +1255,1 @@\n-            private RejectUndecided(ObjectInputFilter filter) {\n+            private RejectUndecidedClass(ObjectInputFilter filter) {\n@@ -1258,1 +1261,2 @@\n-             * Make an exception for Primitive classes that are implicitly allowed by the pattern based filte.\n+             * For array classes, re-check the final component type against the filter.\n+             * Make an exception for Primitive classes that are implicitly allowed by the pattern based filter.\n@@ -1267,1 +1271,16 @@\n-                status = (clazz.isPrimitive()) ? ALLOWED : REJECTED;\n+                status = REJECTED;\n+                \/\/ Find the base component type\n+                while (clazz.isArray()) {\n+                    clazz = clazz.getComponentType();\n+                }\n+                if (clazz.isPrimitive()) {\n+                    status = UNDECIDED;\n+                } else {\n+                    \/\/ for non-primitive types;  re-filter the base component type\n+                    FilterInfo clazzInfo = new SerialInfo(info, clazz);\n+                    Status clazzStatus = filter.checkInput(clazzInfo);\n+                    traceFilter(\"RejectUndecidedClass Array Component type {0} class: {1}, filter: {2}\",\n+                            clazzStatus, clazz, this);\n+                    if (!ALLOWED.equals(clazzStatus))\n+                        status = REJECTED;\n+                }\n@@ -1269,1 +1288,1 @@\n-                        status, clazz, this);\n+                        status, info.serialClass(), this);\n@@ -1274,1 +1293,1 @@\n-                return \"rejectUndecided(\" + filter + \")\";\n+                return \"rejectUndecidedClass(\" + filter + \")\";\n@@ -1276,0 +1295,40 @@\n+\n+            \/**\n+             * FilterInfo instance with a specific class and delegating to an existing FilterInfo.\n+             * Nested in the rejectUndecided class.\n+             *\/\n+            static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+                private final FilterInfo base;\n+                private final Class<?> clazz;\n+\n+                SerialInfo(FilterInfo base, Class<?> clazz) {\n+                    this.base = base;\n+                    this.clazz = clazz;\n+                }\n+\n+                @Override\n+                public Class<?> serialClass() {\n+                    return clazz;\n+                }\n+\n+                @Override\n+                public long arrayLength() {\n+                    return base.arrayLength();\n+                }\n+\n+                @Override\n+                public long depth() {\n+                    return base.depth();\n+                }\n+\n+                @Override\n+                public long references() {\n+                    return base.references();\n+                }\n+\n+                @Override\n+                public long streamBytes() {\n+                    return base.streamBytes();\n+                }\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":80,"deletions":21,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -369,1 +369,1 @@\n-     * <p>The serialization filter is initialized to the filter returned\n+     * <p>The deserialization filter is initialized to the filter returned\n@@ -371,1 +371,1 @@\n-     * and {@linkplain  Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n+     * and the {@linkplain Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -406,1 +406,1 @@\n-     * <p>The serialization filter is initialized to the filter returned\n+     * <p>The deserialization filter is initialized to the filter returned\n@@ -408,1 +408,1 @@\n-     * and {@linkplain  Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n+     * and the {@linkplain Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -450,1 +450,1 @@\n-     * <p>The serialization filter, when not {@code null}, is invoked for\n+     * <p>The deserialization filter, when not {@code null}, is invoked for\n@@ -462,1 +462,1 @@\n-     *          serialization.\n+     *          deserialization.\n@@ -583,1 +583,1 @@\n-     * <p>The serialization filter, when not {@code null}, is invoked for\n+     * <p>The deserialization filter, when not {@code null}, is invoked for\n@@ -891,1 +891,1 @@\n-     * field or array element abort the serialization by raising an exception\n+     * field or array element abort the deserialization by raising an exception\n@@ -1241,1 +1241,1 @@\n-     * Returns the serialization filter for this stream.\n+     * Returns the deserialization filter for this stream.\n@@ -1247,1 +1247,1 @@\n-     * @return the serialization filter for the stream; may be null\n+     * @return the deserialization filter for the stream; may be null\n@@ -1256,1 +1256,1 @@\n-     * The filter must be set and only set once before reading any objects from the stream;\n+     * The filter can be set and only set once before reading any objects from the stream;\n@@ -1259,2 +1259,2 @@\n-     * <p>The serialization filter is set to the filter returned\n-     * by invoking the {@link Config#getSerialFilterFactory()}\n+     * <p>The deserialization filter is set to the filter returned\n+     * by invoking the {@linkplain Config#getSerialFilterFactory() JVM-wide filter factory}\n@@ -1263,1 +1263,1 @@\n-     * must return a non-null filter, it is not permitted to remove filtering once established.\n+     * must return a non-null filter. It is not permitted to remove filtering once established.\n@@ -1327,1 +1327,1 @@\n-     *       if the filter has already been.\n+     *       if the filter has already been set.\n@@ -1353,1 +1353,1 @@\n-     * Invokes the serialization filter if non-null.\n+     * Invokes the deserialization filter if non-null.\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFactoryExample\n@@ -89,1 +88,1 @@\n-                        NO_EXCEPTION},\n+                        ALLOWED},\n@@ -91,5 +90,3 @@\n-                        NO_EXCEPTION},\n-                {10, Filters.allowPlatformClasses(),\n-                        NO_EXCEPTION},\n-                {new Integer[10], ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n-                        InvalidClassException.class},       \/\/ Component type is tested and not allowed\n+                        ALLOWED},\n+                {Integer.valueOf(10), Filters.allowPlatformClasses(),\n+                        ALLOWED},          \/\/ Integer is a platform class\n@@ -97,1 +94,1 @@\n-                        NO_EXCEPTION},\n+                        UNDECIDED},          \/\/ arrays of primitives are UNDECIDED -> allowed\n@@ -99,3 +96,1 @@\n-                        NO_EXCEPTION},\n-                {int.class, Filters.allowPlatformClasses(),\n-                        NO_EXCEPTION},\n+                        UNDECIDED},          \/\/ primitive classes are UNDECIDED -> allowed\n@@ -103,1 +98,3 @@\n-                        NO_EXCEPTION},\n+                        ALLOWED},          \/\/ Arrays of allowed classes are allowed\n+                {new Integer[10], ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        REJECTED},   \/\/ Base component type is checked -> REJECTED\n@@ -105,1 +102,1 @@\n-                        InvalidClassException.class},\n+                        REJECTED},   \/\/ Denied\n@@ -107,1 +104,1 @@\n-                        InvalidClassException.class},\n+                        REJECTED},   \/\/ Not a platform class\n@@ -109,1 +106,1 @@\n-                        InvalidClassException.class},\n+                        REJECTED},   \/\/ Only Integer is ALLOWED\n@@ -111,1 +108,1 @@\n-                        InvalidClassException.class},\n+                        REJECTED},   \/\/ Not platform loader is UNDECIDED -> a class that should not be undecided -> rejected\n@@ -117,1 +114,1 @@\n-    static void examples(Serializable obj, ObjectInputFilter filter, Class<?> exception) {\n+    static void examples(Serializable obj, ObjectInputFilter filter, Status expected) {\n@@ -135,1 +132,2 @@\n-            Assert.assertNull(exception, \"exception should have occurred: \" + exception);\n+            if (expected.equals(REJECTED))\n+                Assert.fail(\"IllegalClassException should have occurred\");\n@@ -138,1 +136,41 @@\n-            Assert.assertEquals(ioe.getClass(), exception, \"Wrong exception\");\n+            Assert.assertEquals(ioe.getClass(), InvalidClassException.class, \"Wrong exception\");\n+            Assert.assertTrue(expected.equals(REJECTED), \"Exception should not have occurred\");\n+        }\n+    }\n+\n+    \/**\n+     * Test various filters with various objects and the resulting status\n+     * @param obj an object\n+     * @param filter a filter\n+     * @param expected status\n+     *\/\n+    @Test(dataProvider = \"Examples\")\n+    static void checkStatus(Serializable obj, ObjectInputFilter filter, Status expected) {\n+        \/\/ Establish FilterInThread as the application-wide filter factory\n+        FilterInThread filterInThread;\n+        if (ObjectInputFilter.Config.getSerialFilterFactory() instanceof FilterInThread fit) {\n+            \/\/ Filter factory selected on the command line with -Djdk.serialFilterFactory=<classname>\n+            filterInThread = fit;\n+        } else {\n+            \/\/ Create a FilterInThread filter factory and set\n+            \/\/ An IllegalStateException will be thrown if the filter factory was already\n+            \/\/ initialized to an incompatible filter factory.\n+            filterInThread = new FilterInThread();\n+            ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+        }\n+\n+        try {\n+            filterInThread.doWithSerialFilter(filter, () -> {\n+                \/\/ Classes are serialized as themselves, otherwise pass the object's class\n+                Class<?> clazz = (obj instanceof Class<?>) ? (Class<?>)obj : obj.getClass();\n+                ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+                var compositeFilter = filterInThread.apply(null, ObjectInputFilter.Config.getSerialFilter());\n+                System.out.println(\"    filter in effect: \" + filterInThread.currFilter);\n+                if (compositeFilter != null) {\n+                    Status actualStatus = compositeFilter.checkInput(info);\n+                    Assert.assertEquals(actualStatus, expected, \"Wrong Status\");\n+                }\n+            });\n+\n+        } catch (Exception ex) {\n+            Assert.fail(\"unexpected exception\", ex);\n@@ -166,0 +204,2 @@\n+        private ObjectInputFilter currFilter;\n+\n@@ -253,1 +293,2 @@\n-                return filter;\n+                currFilter = filter;\n+                return currFilter;\n@@ -258,1 +299,2 @@\n-                return (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n+                currFilter = (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n+                return currFilter;\n@@ -261,0 +303,3 @@\n+        public String toString() {\n+            return Objects.toString(currFilter, \"none\");\n+        }\n@@ -703,0 +748,36 @@\n+    \/**\n+     * FilterInfo instance with a specific class.\n+     *\/\n+    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+        private final Class<?> clazz;\n+\n+        SerialInfo(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        @Override\n+        public Class<?> serialClass() {\n+            return clazz;\n+        }\n+\n+        @Override\n+        public long arrayLength() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long depth() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long references() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long streamBytes() {\n+            return 0;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":102,"deletions":21,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n- * @run testng\/othervm  SerialFilterTest\n- * @run testng\/othervm  -Djdk.serialSetFilterAfterRead=true SerialFilterTest\n+ * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFilterTest\n+ * @run testng\/othervm -Djdk.serialSetFilterAfterRead=true -Djdk.serialFilterTrace=true SerialFilterTest\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}