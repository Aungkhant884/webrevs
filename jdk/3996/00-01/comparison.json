{"files":[{"patch":"@@ -142,0 +142,7 @@\n+ * <h2>Example to filter every deserialization in a thread<\/h2>\n+ *\n+ * This class shows how to filter every deserialization operation that takes place in a thread.\n+ * It defines a thread-local variable to hold the thread-specific filter, and constructs a filter factory\n+ * that composes that filter with the static JVM-wide filter and the stream-specific filter.\n+ * The {@code doWithSerialFilter} method does the setup of the thread-specific filter\n+ * and invokes a Runnable.\n@@ -143,3 +150,0 @@\n- * <p>\n- * Typically, the stream-specific filter should check if a static JVM-wide filter\n- * is configured and defer to it if so. For example,\n@@ -147,7 +151,31 @@\n- * ObjectInputFilter.Status checkInput(FilterInfo info) {\n- *     ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();\n- *     if (serialFilter != null) {\n- *         ObjectInputFilter.Status status = serialFilter.checkInput(info);\n- *         if (status != ObjectInputFilter.Status.UNDECIDED) {\n- *             \/\/ The JVM-wide filter overrides this filter\n- *             return status;\n+ * public static final class FilterInThread\n+ *           implements BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> {\n+ *\n+ *     private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new InheritableThreadLocal<>();\n+ *\n+ *     \/\/ Construct a FilterInThread deserialization filter factory.\n+ *     public FilterInThread() {}\n+ *\n+ *     \/\/ Returns a composite filter of the static JVM-wide filter, a thread-specific filter,\n+ *     \/\/ and the stream-specific filter.\n+ *     public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+ *         if (curr == null) {\n+ *             \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no previous filter\n+ *             \/\/ no current filter, prepend next to threadFilter, both may be null or non-null\n+ *\n+ *             \/\/ Assemble the filters in sequence, most recently added first\n+ *             var filter = filterThreadLocal.get();\n+ *             if (next != null) {\n+ *                 \/\/ Prepend the next filter to the thread filter, if any\n+ *                 \/\/ Initially this would be the static JVM-wide filter passed from the OIS constructor\n+ *                 filter = next.merge(filter);\n+ *             }\n+ *             if (filter != null) {\n+ *                 \/\/ Append the filter to reject all UNDECIDED results\n+ *                 filter = filter.rejectUndecided();\n+ *             }\n+ *             return filter;\n+ *         } else {\n+ *             \/\/ Called from OIS.setObjectInputFilter with a previously set filter.\n+ *             \/\/ Prepend the stream-specific filter or use the current filter\n+ *             return (next == null) ? curr : next.merge(curr);\n@@ -156,2 +184,10 @@\n- *     if (info.serialClass() instanceof java.rmi.Remote) {\n- *         return Status.REJECTED;      \/\/ Do not allow Remote objects\n+ *\n+ *     \/\/ Applies the filter to the thread and invokes the runnable.\n+ *     public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+ *         var prevFilter = filterThreadLocal.get();\n+ *         try {\n+ *             filterThreadLocal.set(filter);\n+ *             runnable.run();\n+ *         } finally {\n+ *             filterThreadLocal.set(prevFilter);\n+ *         }\n@@ -159,1 +195,0 @@\n- *     return Status.UNDECIDED;\n@@ -161,1 +196,17 @@\n- *}<\/pre>\n+ * }<\/pre>\n+ * <h2>Using the Filter Factory<\/h2>\n+ * To use {@code FilterInThread} utility create an instance and configure it as the\n+ * JVM-wide filter factory.  The {@code doWithSerialFilter} method is invoked with a\n+ * filter allowing the example application and core classes:\n+ * <pre>{@code\n+ *        \/\/ Create a FilterInThread filter factory and set\n+ *        var filterInThread = new FilterInThread();\n+ *        ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+ *\n+ *        \/\/ Create a filter to allow example.* classes and reject all others\n+ *        var filter = ObjectInputFilter.Config.createFilter(\"example.*;java.base\/*;!*\");\n+ *        filterInThread.doWithSerialFilter(filter, () -> {\n+ *              byte[] bytes = ...;\n+ *              var o = deserializeObject(bytes);\n+ *        });\n+ * }<\/pre>\n@@ -192,1 +243,1 @@\n-     * Returns a filter that combines the status of this filter and another filter.\n+     * Returns a filter that merges the status of this filter and another filter.\n@@ -194,1 +245,24 @@\n-     * Otherwise, a filter is returned wrapping the pair of {@code non-null} filters.\n+     * Otherwise, a filter is returned to merge the pair of {@code non-null} filters.\n+     * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+     * the result is:\n+     * <ul>\n+     *     <li>{@link Status#REJECTED}, if either filter returns {@link Status#REJECTED}, <\/li>\n+     *     <li>Otherwise, {@link Status#ALLOWED}, if either filter returned {@link Status#ALLOWED}, <\/li>\n+     *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n+     * <\/ul>\n+     *\n+     * @param otherFilter a filter to be merged with this filter, may be null\n+     * @return an {@link ObjectInputFilter} that merges the status of this and another filter\n+     *\/\n+    default ObjectInputFilter merge(ObjectInputFilter otherFilter) {\n+        return (otherFilter == null) ? ObjectInputFilter.this : new Config.MergeFilter(this, otherFilter);\n+    }\n+\n+    \/**\n+     * Returns a filter that maps the status {@code UNDECIDED} to {@code Status.REJECTED},\n+     * otherwise return the {@code REJECTED} or {@code ALLOWED} status.\n+     * Object serialization accepts a class if the filter returns {@code UNDECIDED} or {@code ALLOWED}.\n+     * Appending a filter to reject undecided results for classes that have not been\n+     * either allowed or rejected can prevent classes from slipping through the filter.\n+     *\n+     * <p>\n@@ -198,3 +272,2 @@\n-     *     <li>{@link ObjectInputFilter.Status#REJECTED}, if either filter returns {@link ObjectInputFilter.Status#REJECTED}, <\/li>\n-     *     <li>Otherwise, {@link ObjectInputFilter.Status#ALLOWED}, if either filter returned {@link ObjectInputFilter.Status#ALLOWED}, <\/li>\n-     *     <li>Otherwise, return {@link ObjectInputFilter.Status#UNDECIDED}<\/li>\n+     *     <li>{@link ObjectInputFilter.Status#ALLOWED}, if this filter  {@link ObjectInputFilter.Status#ALLOWED}, <\/li>\n+     *     <li>Otherwise, return {@link ObjectInputFilter.Status#REJECTED}<\/li>\n@@ -203,2 +276,2 @@\n-     * @param otherFilter another filter to be checked after this filter, may be null\n-     * @return an {@link ObjectInputFilter} that combines the status of this and another filter\n+     * @return an {@link ObjectInputFilter} that maps an {@link ObjectInputFilter.Status#UNDECIDED}\n+     *      status to {@link ObjectInputFilter.Status#REJECTED}\n@@ -206,2 +279,2 @@\n-    default ObjectInputFilter andThen(ObjectInputFilter otherFilter) {\n-        return (otherFilter == null) ? ObjectInputFilter.this : new Config.PairFilter(this, otherFilter);\n+    default ObjectInputFilter rejectUndecided() {\n+        return new Config.RejectUndecided(this);\n@@ -438,1 +511,1 @@\n-                    var factoryClass= Class.forName(factoryClassName, true,\n+                    Class<?> factoryClass= Class.forName(factoryClassName, true,\n@@ -441,1 +514,2 @@\n-                    var f = (BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter>)\n+                    BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter> f =\n+                            (BiFunction<ObjectInputFilter, ObjectInputFilter, ObjectInputFilter>)\n@@ -667,1 +741,2 @@\n-         * Returns a filter that returns {@code Status.ALLOWED} if the predicate on the class is {@code true}.\n+         * Returns a filter that returns {@code Status.ALLOWED} if the predicate on the class is {@code true},\n+         * otherwise the {@code otherStatus}.\n@@ -670,3 +745,1 @@\n-         * the predicate is applied to the {@link FilterInfo#serialClass()}.\n-         * Note that {@code serialClass} may be {@code null} and the predicate should be prepared\n-         * to handle {@code null}. The result is:\n+         * the predicate is applied to the {@link FilterInfo#serialClass()}, the return Status is:\n@@ -674,2 +747,3 @@\n-         *     <li>{@link ObjectInputFilter.Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n-         *     <li>Otherwise, return {@link ObjectInputFilter.Status#UNDECIDED}<\/li>\n+         *     <li>{@link Status#UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n@@ -680,1 +754,2 @@\n-         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader());\n+         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n+         *                                          || cl.getClassLoader() == null);\n@@ -683,2 +758,4 @@\n-         * @param predicate a predicate to test a Class\n-         * @return {@link ObjectInputFilter.Status#ALLOWED} if the predicate on the class returns {@code true}\n+         * @param predicate a predicate to test a non-null Class, non-null\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return {@link Status#ALLOWED} if the predicate on the class returns {@code true},\n+         *          otherwise {@link Status#UNDECIDED}\n@@ -686,2 +763,4 @@\n-        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate) {\n-            return new Config.PredicateFilter(predicate, ALLOWED);\n+        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new Config.PredicateFilter(predicate, ALLOWED, otherStatus);\n@@ -691,1 +770,2 @@\n-         * Returns a filter that returns {@code Status.REJECTED REJECTED} if the predicate on the class is {@code true}.\n+         * Returns a filter that returns {@code Status.REJECTED} if the predicate on the class is {@code true},\n+         * otherwise the {@code otherStatus}.\n@@ -694,3 +774,1 @@\n-         * the predicate is applied to the {@link FilterInfo#serialClass()}.\n-         * Note that {@code serialClass} may be {@code null} and the predicate should be prepared\n-         * to handle {@code null}. The result is:\n+         * the predicate is applied to the {@link FilterInfo#serialClass()}, the return Status is:\n@@ -698,2 +776,3 @@\n-         *     <li>{@link ObjectInputFilter.Status#REJECTED}, if the predicate on the class returns {@code true},<\/li>\n-         *     <li>Otherwise, return {@link ObjectInputFilter.Status#UNDECIDED}<\/li>\n+         *     <li>{@link Status#UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#REJECTED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n@@ -707,2 +786,32 @@\n-         * @param predicate a predicate to test a Class\n-         * @return {@link ObjectInputFilter.Status#REJECTED} if the predicate on the class returns {@code true}\n+         * @param predicate a predicate to test a non-null Class, non-null\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return {@link Status#REJECTED} if the predicate on the class returns {@code true},\n+         *          otherwise {@link Status#UNDECIDED}\n+         *\/\n+        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new Config.PredicateFilter(predicate, REJECTED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns {@code Status.ALLOWED} if the check is for limits\n+         * and not checking a class; otherwise {@code Status.UNDECIDED}.\n+         * If the {@link FilterInfo#serialClass()} is {@code null}, the filter returns\n+         * {@code Status.ALLOWED}, otherwise return {@code Status.UNDECIDED}.\n+         * The limit values of {@link FilterInfo#arrayLength()}, {@link FilterInfo#depth()},\n+         * {@link FilterInfo#references()}, and {@link FilterInfo#streamBytes()} are not checked.\n+         * To place a limit, create a separate filter with limits such as:\n+         * <pre>{@code\n+         * Config.createFilter(\"maxarray=10000,maxdepth=40\");\n+         * }<\/pre>\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput} method is invoked,\n+         * the {@link FilterInfo#serialClass()} is checked for {@code null}.\n+         * <ul>\n+         *     <li>{@link Status#ALLOWED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @return {@link Status#REJECTED} if {@linkplain FilterInfo#serialClass()} serialClass is null}\n+         * {@code true}, otherwise {@link Status#UNDECIDED}\n@@ -710,2 +819,2 @@\n-        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate) {\n-            return new Config.PredicateFilter(predicate, REJECTED);\n+        public static ObjectInputFilter allowMaxLimits() {\n+            return new Config.AllowMaxLimitsFilter(ALLOWED, UNDECIDED);\n@@ -999,0 +1108,1 @@\n+            private final Status ifFalseStatus;\n@@ -1000,1 +1110,1 @@\n-            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus) {\n+            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus, Status ifFalseStatus) {\n@@ -1003,0 +1113,1 @@\n+                this.ifFalseStatus = ifFalseStatus;\n@@ -1006,2 +1117,2 @@\n-             * Apply the predicate to the Class being deserialized and if it returns {@code true},\n-             * return the requested status.\n+             * Apply the predicate to the class being deserialized, if the class is non-null\n+             * and if it returns {@code true}, return the requested status. Otherwise, return UNDECIDED.\n@@ -1013,1 +1124,6 @@\n-                return (predicate.test(info.serialClass())) ? ifTrueStatus : UNDECIDED;\n+                return (info.serialClass() != null &&\n+                        predicate.test(info.serialClass())) ? ifTrueStatus : ifFalseStatus;\n+            }\n+\n+            public String toString() {\n+                return \"predicate(\" + predicate + \")\";\n@@ -1018,1 +1134,2 @@\n-         * An ObjectInputFilter that combines the status of two filters.\n+         * An ObjectInputFilter to evaluate if a FilterInfo is checking only limits,\n+         * and not classes.\n@@ -1020,1 +1137,29 @@\n-        private static class PairFilter implements ObjectInputFilter {\n+        private static class AllowMaxLimitsFilter implements ObjectInputFilter {\n+            private final Status limitCheck;\n+            private final Status classCheck;\n+\n+            AllowMaxLimitsFilter(Status limitCheck, Status classCheck) {\n+                this.limitCheck = limitCheck;\n+                this.classCheck = classCheck;\n+            }\n+\n+            \/**\n+             * If the FilterInfo is only checking a limit, return the requested\n+             * status, otherwise the other status.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of corresponding to serialClass == null or not\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                return (info.serialClass() == null) ? limitCheck : classCheck;\n+            }\n+\n+            public String toString() {\n+                return \"allowMaxLimits()\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the status of two filters.\n+         *\/\n+        private static class MergeFilter implements ObjectInputFilter {\n@@ -1024,1 +1169,1 @@\n-            PairFilter(ObjectInputFilter first, ObjectInputFilter second) {\n+            MergeFilter(ObjectInputFilter first, ObjectInputFilter second) {\n@@ -1032,2 +1177,1 @@\n-             * Returns {@code UNDECIDED} if there is no class to be checked or either filter\n-             * returns {@code UNDECIDED}.\n+             * Returns {@code UNDECIDED} if either filter returns {@code UNDECIDED}.\n@@ -1038,1 +1182,1 @@\n-             * {@code UNDECIDED} if there is no class to check or both filters returned {@code UNDECIDED}\n+             * {@code UNDECIDED} if both filters returned {@code UNDECIDED}\n@@ -1052,0 +1196,33 @@\n+\n+            @Override\n+            public String toString() {\n+                return \"merge(\" + first + \", \" + second + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * A filter that maps the status {@code UNDECIDED} to {@code REJECTED}.\n+         *\/\n+        private static class RejectUndecided implements ObjectInputFilter {\n+            private final ObjectInputFilter filter;\n+\n+            private RejectUndecided(ObjectInputFilter filter) {\n+                this.filter = Objects.requireNonNull(filter, \"filter\");\n+            }\n+\n+            \/**\n+             * Apply the filter and return the status if ALLOWED, otherwise REJECTED.\n+             * The effect is to map UNDECIDED to REJECTED, and otherwise return the status.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of applying the filter if ALLOWED, otherwise REJECTED\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                return ALLOWED.equals(Objects.requireNonNull(filter.checkInput(info), \"status\"))\n+                        ? ALLOWED\n+                        : REJECTED;\n+            }\n+\n+            public String toString() {\n+                return \"rejectUndecided(\" + filter + \")\";\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":233,"deletions":56,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -370,0 +370,5 @@\n+    \/**\n+     * True if the stream-specific filter has been set; initially false.\n+     *\/\n+    private boolean streamFilterSet;\n+\n@@ -377,4 +382,2 @@\n-     * by invoking the {@link Config#getSerialFilterFactory()}\n-     * with {@code null} for the current filter and {@code null} for the requested filter.\n-     * The builtin filter factory is returned if a deserialization filter factory\n-     * {@linkplain Config#setSerialFilterFactory(BiFunction) has not been set}.\n+     * by invoking the {@link Config#getSerialFilterFactory()} with {@code null} for the current filter\n+     * and {@linkplain  Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -403,1 +406,2 @@\n-        serialFilter = Config.getSerialFilterFactory().apply(null, null);\n+        streamFilterSet = false;\n+        serialFilter = Config.getSerialFilterFactory().apply(null, Config.getSerialFilter());\n@@ -415,4 +419,2 @@\n-     * by invoking the {@link Config#getSerialFilterFactory()}\n-     * with {@code null} for the current filter and {@code null} for the requested filter.\n-     * The builtin filter factory is returned if a deserialization filter factory\n-     * {@linkplain Config#setSerialFilterFactory(BiFunction) has not been set}.\n+     * by invoking the {@link Config#getSerialFilterFactory()} with {@code null} for the current filter\n+     * and {@linkplain  Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -440,1 +442,2 @@\n-        serialFilter = Config.getSerialFilterFactory().apply(null, null);\n+        streamFilterSet = false;\n+        serialFilter = Config.getSerialFilterFactory().apply(null, Config.getSerialFilter());\n@@ -1271,0 +1274,2 @@\n+     * If there is a non-null filter for the stream, one was set in the constructor, then the filter factory\n+     * must return a replacement filter, it is not permitted to remove filtering once established.\n@@ -1331,3 +1336,4 @@\n-     * @throws IllegalStateException if an object has been read or\n-     *       if the {@link Config#getSerialFilterFactory()}\n-     *       does not allow replacement of the serial filter.\n+     * @throws IllegalStateException if an object has been read,\n+     *       if the filter factory returns {@code null} when the\n+     *       {@linkplain #getObjectInputFilter() current filter} is non-null, or\n+     *       if the filter can not be replaced.\n@@ -1346,2 +1352,5 @@\n-        \/\/ Delegate to serialFilterFactory to determine replacement policy\n-        serialFilter = Config.getSerialFilterFactory()\n+        if (streamFilterSet) {\n+            throw new IllegalStateException(\"filter can not be replaced\");\n+        }\n+        \/\/ Delegate to serialFilterFactory to compute stream filter\n+        ObjectInputFilter next =  Config.getSerialFilterFactory()\n@@ -1349,0 +1358,4 @@\n+        if (serialFilter != null && next == null) {\n+            throw new IllegalStateException(\"filter can not be replaced with null filter\");\n+        }\n+        serialFilter = next;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.ObjectInputFilter.Status;\n@@ -38,0 +39,1 @@\n+import java.util.ArrayDeque;\n@@ -42,1 +44,3 @@\n-import static java.io.ObjectInputFilter.Status.*;\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n@@ -54,1 +58,1 @@\n- * To protect deserialization of a thread or a call to an untrusted library function\n+ * To protect deserialization of a thread or a call to an untrusted library function,\n@@ -58,4 +62,3 @@\n- * a lambda to invoke with the filter in force.  Its implementation saves the filter\n- * in an InheritableThreadLocal, saving the previous value.  `InheritableThreadLocal`\n- * is used instead of `ThreadLocal` so the filter applies to any threads created\n- * from the initial thread.\n+ * a lambda to invoke with the filter in force.  Its implementation creates a stack of filters\n+ * using a `ThreadLocal`. The stack of filters is composed with the static JVM-wide filter,\n+ * and an optional stream-specific filter.\n@@ -63,1 +66,1 @@\n- * The FilterInThread filter factory is set as the JVM-wide dynamic file factory.\n+ * The FilterInThread filter factory is set as the JVM-wide filter factory.\n@@ -65,3 +68,2 @@\n- * it retrieves the filter from the thread local and uses it to filter the stream.\n- * When checking classes, if the accumulated filter results are undecided, the result\n- * is biased toward reject to prevent gaps in the filters from allowing unknown classes to be deserialized.\n+ * it retrieves the filter(s) from the thread local and combines it with the static JVM-wide filter,\n+ * and the stream-specific filter.\n@@ -70,4 +72,4 @@\n- * using `ObjectInputFilter.andThen`.  When invoked, each of the filters is invoked and the results are\n- * combined such that if either filter rejects a class, the result is rejected.\n- * If either filter allows the class, then it is allowed otherwise it is undecided.\n- * Hierarchies and chains of filters can be built using the `ObjectInputFilter.andThen` filter.\n+ * using `ObjectInputFilter.merge`.  When invoked, each of the filters is invoked and the results\n+ * are combined such that if either filter rejects a class, the result is rejected.\n+ * If either filter allows the class, then it is allowed, otherwise it is undecided.\n+ * Hierarchies and chains of filters can be built using `ObjectInputFilter.merge`.\n@@ -75,5 +77,1 @@\n- * The example shows a filter that only allows classes loaded from the platform class loader.\n- *\n- * The `doWithSerialFilter` calls can be nested and as shown replace the filter.\n- * An alternative is to append or concatenate the filters when calls are nested,\n- * narrowing the list of acceptable classes.\n+ * The `doWithSerialFilter` calls can be nested. When nested, the filters are concatenated.\n@@ -93,1 +91,1 @@\n-                {10, Filters.allowPlatformClasses(),\n+                {10, Filters.allowPlatformClasses().merge(ObjectInputFilter.Config.allowMaxLimits()),\n@@ -97,3 +95,2 @@\n-                {new Point(1, 3), Filters.rejectUndecided(\n-                        Filters.allowPlatformClasses()\n-                            .andThen(Filters.allowFilter(cl -> cl == null))),   \/\/ class is null in all of the metrics checks\n+                {new Point(1, 3), Filters.allowPlatformClasses()\n+                            .merge(ObjectInputFilter.Config.allowMaxLimits()),   \/\/ class is null in all of the metrics checks\n@@ -101,3 +98,2 @@\n-                {new Point(1, 4), Filters.rejectUndecided(\n-                        Filters.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader())\n-                            .andThen(Filters.allowFilter(cl -> cl == null))),    \/\/ allow all of the metrics checks\n+                {new Point(1, 4), ObjectInputFilter.Config.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader(), UNDECIDED)\n+                            .merge(ObjectInputFilter.Config.allowMaxLimits()),    \/\/ allow all of the metrics checks\n@@ -108,0 +104,1 @@\n+\n@@ -135,41 +132,12 @@\n-     * Write an object and return a byte array with the bytes.\n-     *\n-     * @param object object to serialize\n-     * @return the byte array of the serialized object\n-     * @throws UncheckedIOException if an exception occurs\n-     *\/\n-    static byte[] writeObject(Object object) {\n-        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-             ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n-            oos.writeObject(object);\n-            return baos.toByteArray();\n-        } catch (IOException ioe) {\n-            throw new UncheckedIOException(ioe);\n-        }\n-    }\n-\n-    \/**\n-     * Deserialize an object.\n-     *\n-     * @param bytes an object.\n-     * @throws UncheckedIOException for I\/O exceptions and ClassNotFoundException\n-     *\/\n-    static Object deserializeObject(byte[] bytes) {\n-        try {\n-            InputStream is = new ByteArrayInputStream(bytes);\n-            ObjectInputStream ois = new ObjectInputStream(is);\n-            System.out.println(\"  filter in effect: \" + ois.getObjectInputFilter());\n-            return ois.readObject();\n-        } catch (IOException ioe) {\n-            throw new UncheckedIOException(ioe);\n-        } catch (ClassNotFoundException cnfe) {\n-            throw new UncheckedIOException(new InvalidClassException(cnfe.getMessage()));\n-        }\n-    }\n-\n-    \/**\n-     * A Context-specific Deserialization Filter Factory to create filters that applies\n-     * a serial filter to all of the deserialization performed in a thread.\n-     *\n-     * The FilterInThread instance should be set as the JVM-wide filter factory\n-     * in ObjectInputFilter.Config.setSerialFilterFactory.\n+     * A Context-specific Deserialization Filter Factory to create filters that apply\n+     * a serial filter to all of the deserializations performed in a thread.\n+     * The purpose is to establish a deserialization filter that will reject all classes\n+     * that are not explicitly included.\n+     * <p>\n+     * The filter factory creates a composite filter of the stream-specific filter,\n+     * the thread-specific filter, the static JVM-wide filter, and a filter to reject all UNDECIDED cases.\n+     * The static JVM-wide filter is always included, if it is configured;\n+     * see ObjectInputFilter.Config.getSerialFilter().\n+     * <p>\n+     * To enable these protections the FilterInThread instance should be set as the\n+     * JVM-wide filter factory in ObjectInputFilter.Config.setSerialFilterFactory.\n@@ -183,2 +151,3 @@\n-        \/\/ ThreadLocal holding the serial filter to be applied, may be null\n-        private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new InheritableThreadLocal<>();\n+        \/\/ ThreadLocal holding the Deque of serial filters to be applied, not null\n+        private final ThreadLocal<ArrayDeque<ObjectInputFilter>> filterThreadLocal =\n+                ThreadLocal.withInitial(() -> new ArrayDeque<>());\n@@ -196,1 +165,3 @@\n-         * The filter is pushed on a InheritedThreadLocal, saving the old value.\n+         * The filter is pushed to a ThreadLocal, saving the old value.\n+         * If there was a previous thread filter, the new filter is appended\n+         * and made the active filter.\n@@ -204,1 +175,1 @@\n-            var prevFilter = filterThreadLocal.get();\n+            var prevFilters = filterThreadLocal.get();\n@@ -206,1 +177,2 @@\n-                filterThreadLocal.set(filter);\n+                if (filter != null)\n+                    prevFilters.addLast(filter);\n@@ -209,1 +181,4 @@\n-                filterThreadLocal.set(prevFilter);\n+                if (filter != null) {\n+                    var lastFilter = prevFilters.removeLast();\n+                    assert lastFilter == filter : \"Filter removed out of order\";\n+                }\n@@ -214,3 +189,14 @@\n-         * Returns a composite filter to be used for an ObjectInputStream.\n-         * First called from the constructor with current == null & next == null.\n-         * Maybe called later from {@code setObjectInputFilter(next)} to add a stream-specific filter.\n+         * Returns a composite filter of the stream-specific filter, the thread-specific filter,\n+         * the static JVM-wide filter, and a filter to reject all UNDECIDED cases.\n+         * The purpose is to establish a deserialization filter that will reject all classes\n+         * that are not explicitly included.\n+         * The static JVM-wide filter is always checked, if it is configured;\n+         * see ObjectInputFilter.Config.getSerialFilter().\n+         * Any or all of the filters are optional and if not supplied or configured are null.\n+         * <p>\n+         * This method is first called from the constructor with current == null and\n+         * next == static JVM-wide filter.\n+         * The filter returned is the static JVM-wide filter merged with the thread-specific filter\n+         * and followed by a filter to map all UNDECIDED status values to REJECTED.\n+         * This last step ensures that the collective group of filters covers every possible case,\n+         * any classes that are not ALLOWED will be REJECTED.\n@@ -218,2 +204,3 @@\n-         * If there is no thread filter, the stream-specific filter is returned.\n-         * If there is a thread filter, use it and then the stream-specific filter, if any.\n+         * The method mayy be called a second time from {@code ObjectInputStream.setObjectInputFilter(next)}\n+         * to add a stream-specific filter.  The stream-specific filter is prepended to the\n+         * composite filter created above when called from the constructor.\n@@ -221,2 +208,0 @@\n-         * In this algorithm, the current filter is either null, or the filter set in the\n-         * previous call which will be the threadFilter; the current filter is redundant and unused.\n@@ -224,3 +209,3 @@\n-         * @param curr the current filter, if any\n-         * @param next the next filter, if any\n-         * @return a deserialization filter to use for the stream\n+         * @param curr the current filter, may be null\n+         * @param next the next filter, may be null\n+         * @return a deserialization filter to use for the stream, may be null\n@@ -229,4 +214,25 @@\n-            var threadFilter = filterThreadLocal.get();\n-            if (threadFilter == null) {\n-                \/\/ There no thread filter so just use the stream-specific filter if any\n-                return next;\n+            if (curr == null) {\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no previous filter\n+                \/\/ no current filter, prepend next to threadFilter, both may be null or non-null\n+\n+                \/\/ Assemble the filters in sequence, most recently added first\n+                var filters = filterThreadLocal.get();\n+                ObjectInputFilter filter = null;\n+                for (ObjectInputFilter f : filters) {\n+                    filter = f.merge(filter);\n+                }\n+                if (next != null) {\n+                    \/\/ Prepend the next filter to the thread filter, if any\n+                    \/\/ Initially this would be the static JVM-wide filter passed from the OIS constructor\n+                    filter = next.merge(filter);\n+                }\n+                if (filter != null) {\n+                    \/\/ Append the filter to reject all UNDECIDED results\n+                    filter = filter.rejectUndecided();\n+                }\n+                return filter;\n+            } else {\n+                \/\/ Called from OIS.setObjectInputFilter with a previously set filter.\n+                \/\/ The curr filter already incorporates the thread filter and rejection of undecided status\n+                \/\/ Prepend the stream-specific filter or the current filter if not stream-specific filter\n+                return (next == null) ? curr : next.merge(curr);\n@@ -234,3 +240,0 @@\n-            \/\/ Assert curr == null or is the threadFilter from the previous call\n-            return threadFilter         \/\/ establish the thread filter\n-                    .andThen(next);     \/\/ followed by the stream-specific filter if any\n@@ -240,0 +243,38 @@\n+\n+    \/**\n+     * Write an object and return a byte array with the bytes.\n+     *\n+     * @param object object to serialize\n+     * @return the byte array of the serialized object\n+     * @throws UncheckedIOException if an exception occurs\n+     *\/\n+    private static byte[] writeObject(Object object) {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(object);\n+            return baos.toByteArray();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Deserialize an object.\n+     *\n+     * @param bytes an object.\n+     * @throws UncheckedIOException for I\/O exceptions and ClassNotFoundException\n+     *\/\n+    private static Object deserializeObject(byte[] bytes) {\n+        try {\n+            InputStream is = new ByteArrayInputStream(bytes);\n+            ObjectInputStream ois = new ObjectInputStream(is);\n+            System.out.println(\"  filter in effect: \" + ois.getObjectInputFilter());\n+            return ois.readObject();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new UncheckedIOException(new InvalidClassException(cnfe.getMessage()));\n+        }\n+    }\n+\n+\n@@ -250,2 +291,2 @@\n-         *     <li>{@link ObjectInputFilter.Status#ALLOWED}, if the predicate on the class returns {@code true}, <\/li>\n-         *     <li>Otherwise, return {@link ObjectInputFilter.Status#UNDECIDED}<\/li>\n+         *     <li>{@link Status#ALLOWED}, if the predicate on the class returns {@code true}, <\/li>\n+         *     <li>Otherwise, return {@code otherStatus}<\/li>\n@@ -260,1 +301,2 @@\n-         * @return {@link ObjectInputFilter.Status#ALLOWED} if the predicate on the class returns true\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return {@link Status#ALLOWED} if the predicate on the class returns true\n@@ -262,2 +304,4 @@\n-        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate) {\n-            return new PredicateFilter(predicate, ALLOWED);\n+        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new PredicateFilter(predicate, ALLOWED, otherStatus);\n@@ -272,2 +316,2 @@\n-         *     <li>{@link ObjectInputFilter.Status#REJECTED}, if the predicate on the class returns {@code true}, <\/li>\n-         *     <li>Otherwise, return {@link ObjectInputFilter.Status#UNDECIDED}<\/li>\n+         *     <li>{@link Status#REJECTED}, if the predicate on the class returns {@code true}, <\/li>\n+         *     <li>Otherwise, return {@code otherStatus}<\/li>\n@@ -282,1 +326,2 @@\n-         * @return {@link ObjectInputFilter.Status#REJECTED} if the predicate on the class returns true\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return {@link Status#REJECTED} if the predicate on the class returns true\n@@ -284,2 +329,4 @@\n-        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate) {\n-            return new PredicateFilter(predicate, REJECTED);\n+        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new PredicateFilter(predicate, REJECTED, otherStatus);\n@@ -296,3 +343,3 @@\n-         *     <li>{@link ObjectInputFilter.Status#REJECTED}, if either filter returns {@link ObjectInputFilter.Status#REJECTED}, <\/li>\n-         *     <li>Otherwise, {@link ObjectInputFilter.Status#ALLOWED}, if either filter returned {@link ObjectInputFilter.Status#ALLOWED}, <\/li>\n-         *     <li>Otherwise, return {@link ObjectInputFilter.Status#UNDECIDED}<\/li>\n+         *     <li>{@link Status#REJECTED}, if either filter returns {@link Status#REJECTED}, <\/li>\n+         *     <li>Otherwise, {@link Status#ALLOWED}, if either filter returned {@link Status#ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n@@ -305,1 +352,1 @@\n-        public static ObjectInputFilter andThen(ObjectInputFilter filter, ObjectInputFilter otherFilter) {\n+        public static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter otherFilter) {\n@@ -309,2 +356,1 @@\n-                    new PairFilter(Objects.requireNonNull(filter, \"filter\"),\n-                            Objects.requireNonNull(otherFilter, \"otherFilter\"));\n+                    new MergeFilter(filter, otherFilter);\n@@ -319,3 +365,3 @@\n-         *     <li>{@link ObjectInputFilter.Status#REJECTED}, if this filter returns {@link ObjectInputFilter.Status#ALLOWED}, <\/li>\n-         *     <li>{@link ObjectInputFilter.Status#ALLOWED}, if this filter  {@link ObjectInputFilter.Status#REJECTED}, <\/li>\n-         *     <li>Otherwise, return {@link ObjectInputFilter.Status#UNDECIDED}<\/li>\n+         *     <li>{@link Status#REJECTED}, if this filter returns {@link Status#ALLOWED}, <\/li>\n+         *     <li>{@link Status#ALLOWED}, if this filter  {@link Status#REJECTED}, <\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n@@ -332,1 +378,1 @@\n-         * Returns a filter that returns rejected if the a filter returns UNDECIDED.\n+         * Returns a filter that returns REJECTED if the a filter returns UNDECIDED.\n@@ -341,2 +387,2 @@\n-         *     <li>{@link ObjectInputFilter.Status#ALLOWED}, if this filter  {@link ObjectInputFilter.Status#ALLOWED}, <\/li>\n-         *     <li>Otherwise, return {@link ObjectInputFilter.Status#REJECTED}<\/li>\n+         *     <li>{@link Status#ALLOWED}, if this filter  {@link Status#ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@link Status#REJECTED}<\/li>\n@@ -346,2 +392,2 @@\n-         * @return an {@link ObjectInputFilter} that maps an {@link ObjectInputFilter.Status#UNDECIDED}\n-         * status to {@link ObjectInputFilter.Status#REJECTED}\n+         * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n+         * status to {@link Status#REJECTED}\n@@ -363,2 +409,1 @@\n-         * An ObjectInputFilter to evaluate a predicate mapping a class to a boolean\n-         * and using the result to return ALLOWED, REJECTED, or UNDECIDED.\n+         * An ObjectInputFilter to evaluate a predicate mapping a class to a boolean.\n@@ -369,0 +414,1 @@\n+            private final Status ifFalseStatus;\n@@ -370,1 +416,1 @@\n-            private PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus) {\n+            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus, Status ifFalseStatus) {\n@@ -373,0 +419,1 @@\n+                this.ifFalseStatus = ifFalseStatus;\n@@ -376,1 +423,2 @@\n-             * Apply the predicate to the Class and if it returns true, return the requested status.\n+             * Apply the predicate to the class being deserialized, if the class is non-null\n+             * and if it returns {@code true}, return the requested status. Otherwise, return UNDECIDED.\n@@ -379,1 +427,1 @@\n-             * @return the status of applying the predicate, otherwise UNDECIDED\n+             * @return the status of applying the predicate, otherwise {@code UNDECIDED}\n@@ -382,2 +430,6 @@\n-                Class<?> cl = info.serialClass();\n-                return (cl != null && predicate.test(cl)) ? ifTrueStatus : UNDECIDED;\n+                return (info.serialClass() != null &&\n+                        predicate.test(info.serialClass())) ? ifTrueStatus : ifFalseStatus;\n+            }\n+\n+            public String toString() {\n+                return \"predicate(\" + predicate + \")\";\n@@ -388,1 +440,1 @@\n-         * An ObjectInputFilter that combines the results of two filters.\n+         * An ObjectInputFilter that merges the results of two filters.\n@@ -390,1 +442,1 @@\n-        private static class PairFilter implements ObjectInputFilter {\n+        private static class MergeFilter implements ObjectInputFilter {\n@@ -394,3 +446,3 @@\n-            PairFilter(ObjectInputFilter first, ObjectInputFilter second) {\n-                this.first = first;\n-                this.second = second;\n+            MergeFilter(ObjectInputFilter first, ObjectInputFilter second) {\n+                this.first = Objects.requireNonNull(first, \"first\");\n+                this.second = Objects.requireNonNull(second, \"second\");\n@@ -412,1 +464,1 @@\n-                if (REJECTED.equals(firstStatus))\n+                if (REJECTED.equals(firstStatus)) {\n@@ -414,0 +466,1 @@\n+                }\n@@ -415,1 +468,1 @@\n-                if (REJECTED.equals(secondStatus))\n+                if (REJECTED.equals(secondStatus)) {\n@@ -417,0 +470,1 @@\n+                }\n@@ -422,0 +476,5 @@\n+\n+            @Override\n+            public String toString() {\n+                return \"merge(\" + first + \", \" + second + \")\";\n+            }\n@@ -439,3 +498,3 @@\n-             *     <li>REJECTED, if the other filter returns {@link ObjectInputFilter.Status#ALLOWED}, <\/li>\n-             *     <li>ALLOWED, if the other filter returns {@link ObjectInputFilter.Status#REJECTED}, <\/li>\n-             *     <li>Otherwise, return {@link ObjectInputFilter.Status#UNDECIDED}<\/li>\n+             *     <li>REJECTED, if the other filter returns {@link Status#ALLOWED}, <\/li>\n+             *     <li>ALLOWED, if the other filter returns {@link Status#REJECTED}, <\/li>\n+             *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n@@ -478,1 +537,1 @@\n-                return \"reject undecided of (\" + filter.toString() + \")\";\n+                return \"rejectUndecided(\" + filter.toString() + \")\";\n@@ -498,1 +557,2 @@\n-                        ClassLoader.getPlatformClassLoader().equals(serialClass.getClassLoader()))\n+                        (serialClass.getClassLoader() == null ||\n+                        ClassLoader.getPlatformClassLoader().equals(serialClass.getClassLoader())))\n@@ -504,1 +564,1 @@\n-                return \"platform classes allowed\";\n+                return \"allowPlatformClasses\";\n@@ -514,1 +574,0 @@\n-\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":194,"deletions":135,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-        Assert.assertNull(factory.next(), \"initially next should be null\");\n+        Assert.assertEquals(factory.next(), configFilter, \"initially next should be the configured filter\");\n@@ -222,1 +222,1 @@\n-                ObjectInputFilter f = getFilter(st1).andThen(getFilter(st2));\n+                ObjectInputFilter f = getFilter(st1).merge(getFilter(st2));\n@@ -265,1 +265,1 @@\n-        Assert.assertEquals(Config.allowFilter(predicate).checkInput(info), expected, \"Predicate result\");\n+        Assert.assertEquals(Config.allowFilter(predicate, Status.UNDECIDED).checkInput(info), expected, \"Predicate result\");\n@@ -280,1 +280,23 @@\n-        Assert.assertEquals(Config.rejectFilter(predicate).checkInput(info), expected, \"Predicate result\");\n+        Assert.assertEquals(Config.rejectFilter(predicate, Status.UNDECIDED).checkInput(info), expected, \"Predicate result\");\n+    }\n+\n+\n+    @Test\n+    static void testRejectUndecided() {\n+        FilterInfo info = new SerialInfo(Object.class); \/\/ an info structure, unused\n+\n+        ObjectInputFilter undecided = getFilter(UNDECIDED);\n+        Assert.assertEquals(undecided.rejectUndecided().checkInput(info), REJECTED, \"undecided -> rejected\");\n+        ObjectInputFilter allowed = getFilter(ALLOWED);\n+        Assert.assertEquals(allowed.rejectUndecided().checkInput(info), ALLOWED, \"allowed -> rejected\");\n+        ObjectInputFilter rejected = getFilter(REJECTED);\n+        Assert.assertEquals(rejected.rejectUndecided().checkInput(info), REJECTED, \"rejected -> rejected\");\n+    }\n+\n+    @Test\n+    static void testMaxLimits() {\n+        FilterInfo info = new SerialInfo(null); \/\/ an info structure, serialClass == null\n+        Assert.assertEquals(Config.allowMaxLimits().checkInput(info), ALLOWED, \"allowMaxLimit\");\n+\n+        info = new SerialInfo(Object.class); \/\/ an info structure, serialClass != null\n+        Assert.assertEquals(Config.allowMaxLimits().checkInput(info), UNDECIDED, \"allowMaxLimit\");\n@@ -431,1 +453,1 @@\n-            this.clazz = Objects.requireNonNull(clazz);\n+            this.clazz = clazz;\n@@ -458,0 +480,21 @@\n+\n+        @Override\n+        public String toString() {\n+            return showFilterInfo(this);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Return a string describing a FilterInfo instance.\n+     * @param info a FilterInfo instance\n+     * @return a String describing the FilterInfo instance\n+     *\/\n+    static String showFilterInfo(ObjectInputFilter.FilterInfo info) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"serialClass: \" + info.serialClass());\n+        sb.append(\", arrayLength: \" + info.arrayLength());\n+        sb.append(\", depth: \" + info.depth());\n+        sb.append(\", references: \" + info.references());\n+        sb.append(\", streamBytes: \" + info.streamBytes());\n+        return sb.toString();\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFactoryTest.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"}]}