{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.StaticProperty;\n+import sun.security.action.GetBooleanAction;\n+\n+import java.lang.reflect.InvocationTargetException;\n@@ -35,0 +40,1 @@\n+import java.util.function.BinaryOperator;\n@@ -36,0 +42,1 @@\n+import java.util.function.Predicate;\n@@ -37,2 +44,3 @@\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.util.StaticProperty;\n+import static java.io.ObjectInputFilter.Status.*;\n+import static java.lang.System.Logger.Level.TRACE;\n+import static java.lang.System.Logger.Level.INFO;\n@@ -51,2 +59,27 @@\n- * If set on an {@link ObjectInputStream}, the {@link #checkInput checkInput(FilterInfo)}\n- * method is called to validate classes, the length of each array,\n+ * <p>To protect against deserialization vulnerabilities, application developers\n+ * need a clear description of the objects that can be deserialized\n+ * by each component or library. For each context and use case, developers should\n+ * construct and apply an appropriate filter.\n+ *\n+ * <p>For simple cases, a static filter can be {@linkplain Config#setSerialFilter(ObjectInputFilter) set}\n+ * for the entire application.\n+ * For example, a filter that allows example classes, allows classes in the\n+ * {@code java.base} module, and rejects all other classes:\n+ *\n+ * <pre>{@code\n+ *     var filter = ObjectInputFilter.Config.createFilter(\"example.*;java.base\/*;!*\")\n+ *     ObjectInputFilter.Config.setSerialFilter(filter);\n+ * }<\/pre>\n+ *\n+ * <p>In an application with multiple execution contexts, the\n+ * {@linkplain Config#setSerialFilterFactory(BinaryOperator) filter factory} can better\n+ * protect individual contexts by providing a custom filter for each. When the stream\n+ * is constructed, the filter factory can identify the execution context on the available\n+ * information, for example, the current thread-local state, hierarchy of callers, library, module,\n+ * and class loader. At that point, a policy for creating or selecting filters can choose a specific filter\n+ * or composition of filters based on the context.\n+ *\n+ * <p>\n+ * If a filter is set on an ObjectInputStream, the filter's {@link #checkInput checkInput(FilterInfo)}\n+ * method is invoked zero or more times while {@linkplain ObjectInputStream#readObject() reading objects}.\n+ * The method is called to validate classes, the length of each array,\n@@ -55,0 +88,2 @@\n+ * The JVM-wide deserialization filter factory ensures that a deserialization filter can be set\n+ * on every {@link ObjectInputStream} and every object read from the stream can be checked.\n@@ -56,4 +91,20 @@\n- * A filter can be set via {@link ObjectInputStream#setObjectInputFilter setObjectInputFilter}\n- * for an individual ObjectInputStream.\n- * A filter can be set via {@link Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}\n- * to affect every {@code ObjectInputStream} that does not otherwise set a filter.\n+ * The deserialization filter for a stream is determined in one of the following ways:\n+ * <ul>\n+ * <li>A JVM-wide filter factory can be set via {@link Config#setSerialFilterFactory(BinaryOperator)}\n+ *     or the system property {@code jdk.serialFilterFactory} or\n+ *     the security property {@code jdk.serialFilterFactory}.\n+ *     The filter factory is invoked for each new ObjectInputStream and\n+ *     when a filter is set for a stream.\n+ *     The filter factory determines the filter to be used for each stream based\n+ *     on its inputs, thread context, other filters, or state that is available.\n+ * <li>If a JVM-wide filter factory is not set, a builtin deserialization filter factory\n+ *     provides the {@linkplain Config#getSerialFilter static JVM-wide filter} when invoked from the\n+ *     {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}\n+ *     and replaces the static filter when invoked from\n+ *     {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)}.\n+ *     See {@linkplain Config#getSerialFilterFactory() getSerialFilterFactory}.\n+ * <li>A stream-specific filter can be set for an individual ObjectInputStream\n+ *     via {@link ObjectInputStream#setObjectInputFilter setObjectInputFilter}.\n+ *     Note that the filter may be used directly or combined with other filters by the\n+ *     {@linkplain Config#setSerialFilterFactory(BinaryOperator) JVM-wide filter factory}.\n+ * <\/ul>\n@@ -61,4 +112,3 @@\n- * A filter determines whether the arguments are {@link Status#ALLOWED ALLOWED}\n- * or {@link Status#REJECTED REJECTED} and should return the appropriate status.\n- * If the filter cannot determine the status it should return\n- * {@link Status#UNDECIDED UNDECIDED}.\n+ * A deserialization filter determines whether the arguments are allowed or rejected and\n+ * should return the appropriate status: {@link Status#ALLOWED ALLOWED} or {@link Status#REJECTED REJECTED}.\n+ * If the filter cannot determine the status it should return {@link Status#UNDECIDED UNDECIDED}.\n@@ -68,1 +118,1 @@\n- * then it can reject a candidate class that matches and report UNDECIDED for others.\n+ * then it can reject a candidate class that matches and report {@code UNDECIDED} for others.\n@@ -72,1 +122,1 @@\n- * This allows a filter to specific about the choice it is reporting and\n+ * This allows a filter to be specific about the choice it is reporting and\n@@ -75,3 +125,28 @@\n- * <p>\n- * Typically, a custom filter should check if a system-wide filter\n- * is configured and defer to it if so. For example,\n+ * <h2>Filter Model Examples<\/h2>\n+ * For simple applications, a single predefined filter listing allowed or rejected\n+ * classes may be sufficient to manage the risk of deserializing unexpected classes.\n+ * <p>For an application composed from multiple modules or libraries, the structure\n+ * of the application can be used to identify the classes to be allowed or rejected\n+ * by each {@linkplain ObjectInputStream} in each context of the application.\n+ * The JVM-wide deserialization filter factory is invoked when each stream is constructed and\n+ * can examine the thread or program to determine a context-specific filter to be applied.\n+ * Some possible examples:\n+ * <ul>\n+ *     <li>Thread-local state can hold the filter to be applied or composed\n+ *         with a stream-specific filter.\n+ *         Filters could be pushed and popped from a virtual stack of filters\n+ *         maintained by the application or libraries.\n+ *     <li>The filter factory can identify the caller of the deserialization method\n+ *         and use module or library context to select a filter or compose an appropriate\n+ *         context-specific filter.\n+ *         A mechanism could identify a callee with restricted or unrestricted\n+ *         access to serialized classes and choose a filter accordingly.\n+ * <\/ul>\n+ * <h2>Example to filter every deserialization in a thread<\/h2>\n+ *\n+ * This class shows how to filter every deserialization operation that takes place in a thread.\n+ * It defines a thread-local variable to hold the thread-specific filter, and constructs a filter factory\n+ * that composes that filter with the static JVM-wide filter and the stream-specific filter.\n+ * The {@code doWithSerialFilter} method does the setup of the thread-specific filter\n+ * and invokes a Runnable.\n+ *\n@@ -79,7 +154,31 @@\n- * ObjectInputFilter.Status checkInput(FilterInfo info) {\n- *     ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();\n- *     if (serialFilter != null) {\n- *         ObjectInputFilter.Status status = serialFilter.checkInput(info);\n- *         if (status != ObjectInputFilter.Status.UNDECIDED) {\n- *             \/\/ The system-wide filter overrides this filter\n- *             return status;\n+ * public static final class FilterInThread implements BinaryOperator<ObjectInputFilter> {\n+ *\n+ *     private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new InheritableThreadLocal<>();\n+ *\n+ *     \/\/ Construct a FilterInThread deserialization filter factory.\n+ *     public FilterInThread() {}\n+ *\n+ *     \/\/ Returns a composite filter of the static JVM-wide filter, a thread-specific filter,\n+ *     \/\/ and the stream-specific filter.\n+ *     public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+ *         if (curr == null) {\n+ *             \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no previous filter\n+ *             \/\/ Prepend next to the threadFilter, both may be null or non-null\n+ *             var filter = filterThreadLocal.get();\n+ *             if (filter != null) {\n+ *                 \/\/ Prepend a filter to assert that all classes have been Allowed or Rejected\n+ *                 filter = filter.rejectUndecidedClass();\n+ *             }\n+ *             if (next != null) {\n+ *                 \/\/ Prepend the next filter to the thread filter, if any\n+ *                 \/\/ Initially this would be the static JVM-wide filter passed from the OIS constructor\n+ *                 \/\/ Append the filter to reject all UNDECIDED results\n+ *                 filter = next.merge(filter).rejectUndecidedClass();\n+ *             }\n+ *             return filter;\n+ *         } else {\n+ *             \/\/ Called from OIS.setObjectInputFilter with a current filter and a stream-specific filter.\n+ *             \/\/ The curr filter already incorporates the thread filter and static JVM-wide filter\n+ *             \/\/ and rejection of undecided classes\n+ *             \/\/ Use the current filter or prepend the stream-specific filter and recheck for undecided\n+ *             return (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n@@ -88,3 +187,10 @@\n- *     if (info.serialClass() != null &&\n- *         Remote.class.isAssignableFrom(info.serialClass())) {\n- *         return Status.REJECTED;      \/\/ Do not allow Remote objects\n+ *\n+ *     \/\/ Applies the filter to the thread and invokes the runnable.\n+ *     public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+ *         var prevFilter = filterThreadLocal.get();\n+ *         try {\n+ *             filterThreadLocal.set(filter);\n+ *             runnable.run();\n+ *         } finally {\n+ *             filterThreadLocal.set(prevFilter);\n+ *         }\n@@ -92,1 +198,0 @@\n- *     return Status.UNDECIDED;\n@@ -94,1 +199,17 @@\n- *}<\/pre>\n+ * }<\/pre>\n+ * <h3>Using the Filter Factory<\/h3>\n+ * To use {@code FilterInThread} utility create an instance and configure it as the\n+ * JVM-wide filter factory.  The {@code doWithSerialFilter} method is invoked with a\n+ * filter allowing the example application and core classes:\n+ * <pre>{@code\n+ *        \/\/ Create a FilterInThread filter factory and set\n+ *        var filterInThread = new FilterInThread();\n+ *        ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+ *\n+ *        \/\/ Create a filter to allow example.* classes and reject all others\n+ *        var filter = ObjectInputFilter.Config.createFilter(\"example.*;java.base\/*;!*\");\n+ *        filterInThread.doWithSerialFilter(filter, () -> {\n+ *              byte[] bytes = ...;\n+ *              var o = deserializeObject(bytes);\n+ *        });\n+ * }<\/pre>\n@@ -113,0 +234,3 @@\n+     * @apiNote Each filter implementation of {@code checkInput} should return one of the values of {@link Status}.\n+     * Returning {@code null} may result in a {@link NullPointerException} or other unpredictable behavior.\n+     *\n@@ -121,0 +245,47 @@\n+    \/**\n+     * Returns a filter that merges the status of this filter and another filter.\n+     * If the other filter is {@code null}, this filter is returned.\n+     * Otherwise, a filter is returned to merge the pair of {@code non-null} filters.\n+     * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+     * the result is:\n+     * <ul>\n+     *     <li>{@link Status#REJECTED}, if either filter returns {@link Status#REJECTED}, <\/li>\n+     *     <li>Otherwise, {@link Status#ALLOWED}, if either filter returned {@link Status#ALLOWED}, <\/li>\n+     *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n+     * <\/ul>\n+     *\n+     * @param otherFilter a filter to be merged with this filter, may be null\n+     * @return an {@link ObjectInputFilter} that merges the status of this and another filter\n+     *\/\n+    default ObjectInputFilter merge(ObjectInputFilter otherFilter) {\n+        return (otherFilter == null) ? ObjectInputFilter.this : new Config.MergeFilter(this, otherFilter);\n+    }\n+\n+    \/**\n+     * Returns a filter that invokes this filter and maps UNDECIDED to REJECTED for classes,\n+     * with some exceptions, and otherwise returns the status.\n+     * The filter ensures that classes not ALLOWED and not REJECTED by this filter\n+     * are REJECTED, if the class is an array and the base component type is not allowed,\n+     * otherwise the result is UNDECIDED.\n+     *\n+     * <p>\n+     * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n+     * Adding a filter to reject undecided results for classes that have not been\n+     * either allowed or rejected can prevent classes from slipping through the filter.\n+     * <p>\n+     * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+     * the result is:\n+     * <ul>\n+     *     <li>{@link ObjectInputFilter.Status#REJECTED}, if the filter is checking a class\n+     *     and the filter returns {@link ObjectInputFilter.Status#UNDECIDED}, <\/li>\n+     *     <li>Otherwise, return the status of this filter<\/li>\n+     * <\/ul>\n+     *\n+     * @return an {@link ObjectInputFilter} that maps an {@link ObjectInputFilter.Status#UNDECIDED}\n+     *      status to {@link ObjectInputFilter.Status#REJECTED} for classes, otherwise returns the\n+     *      filter status\n+     *\/\n+    default ObjectInputFilter rejectUndecidedClass() {\n+        return new Config.RejectUndecidedClass(this);\n+    }\n+\n@@ -200,3 +371,31 @@\n-     * A utility class to set and get the system-wide filter or create a filter\n-     * from a pattern string. If a system-wide filter is set, it will be\n-     * used for each {@link ObjectInputStream} that does not set its own filter.\n+     * A utility class to set and get the JVM-wide deserialization filter factory,\n+     * the static JVM-wide filter, or to create a filter from a pattern string.\n+     * The static filter factory and the static filter apply to the whole Java runtime,\n+     * or \"JVM-wide\", there is only one of each.\n+     * If a JVM-wide filter factory or static JVM-wide filter is set, it will determine the filter\n+     * to be used for each {@link ObjectInputStream}, and be combined with a\n+     * stream-specific filter, if one is set.\n+     * <p>\n+     * When each {@link ObjectInputStream#ObjectInputStream() ObjectInputStream}\n+     * is created the {@linkplain Config#getSerialFilterFactory() filter factory}\n+     * is invoked to determine the initial filter for the stream.\n+     * When called from the constructor, the current filter is `null` and the new filter is the\n+     * {@linkplain Config#getSerialFilter() static JVM-wide filter}. The factory determines and\n+     * returns the initial filter for the stream. The factory can create a composite filter\n+     * with other context-specific controls or just return the static JVM-wide filter.\n+     * <p>\n+     * A stream-specific filter can be set with\n+     * {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter) ObjectInputStream.setObjectInputFilter}.\n+     * If {@code ObjectInputStream.setObjectInputFilter} is called, the filter factory is called a second time\n+     * with the stream's initial filter, and the requested new filter.\n+     * The factory determines how to combine the two filters and returns a filter, replacing the filter on the stream.\n+     * <p>\n+     * Setting a {@linkplain #setSerialFilterFactory(BinaryOperator) deserialization filter factory}\n+     * allows the application provided factory to choose a filter for each stream when it is created\n+     * based on the context of the thread and call stack. It may simply return a static filter,\n+     * select a filter, compose a filter from the requested filter and any other filters including\n+     * the {@linkplain #getSerialFilter() JVM-wide filter}.\n+     * <p>\n+     * If a JVM-wide filter factory is {@linkplain Config#setSerialFilterFactory(BinaryOperator) not set}\n+     * the builtin deserialization filter factory returns the\n+     * {@linkplain Config#getSerialFilter() static JVM-wide filter}.\n@@ -207,2 +406,2 @@\n-     * The filter is configured during the initialization of the {@code ObjectInputFilter.Config}\n-     * class. For example, by calling {@link #getSerialFilter() Config.getSerialFilter}.\n+     * The JVM-wide filter is configured during the initialization of the\n+     * {@code ObjectInputFilter.Config} class.\n@@ -217,1 +416,1 @@\n-     * The syntax for each property is the same as for the\n+     * The syntax for the property value is the same as for the\n@@ -219,1 +418,17 @@\n-     *\n+     * <p>\n+     * If the Java virtual machine is started with the system property\n+     * {@systemProperty jdk.serialFilterFactory}, its value names the class to configure the\n+     * JVM-wide deserialization filter factory.\n+     * If the system property is not defined, and the {@link java.security.Security} property\n+     * {@code jdk.serialFilterFactory} is defined then it is used to configure the filter factory.\n+     * The class must be public, must have a public zero-argument constructor, implement the\n+     * {@link BinaryOperator {@literal BinaryOperator<ObjectInputFilter>}} interface, provide its implementation and\n+     * be accessible via the {@linkplain ClassLoader#getSystemClassLoader() application class loader}.\n+     * The filter factory configured using the system or security property during initialization\n+     * can NOT be replaced with {@link #setSerialFilterFactory(BinaryOperator) Config.setSerialFilterFactory}.\n+     * This ensures that a filter factory set on the command line is not overridden accidentally\n+     * or intentionally by the application.\n+     * Setting the {@code jdk.serialFilterFactory} with {@link System#setProperty(String, String)\n+     * System.setProperty} <em>does not set the filter factory<\/em>.\n+     * The syntax for the system property value and security property value is the\n+     * fully qualified class name of the deserialization filter factory.\n@@ -223,2 +438,4 @@\n-        \/* No instances. *\/\n-        private Config() {}\n+        \/**\n+         * Lock object for JVM-wide filter and filter factory.\n+         *\/\n+        private final static Object serialFilterLock = new Object();\n@@ -227,1 +444,2 @@\n-         * Lock object for system-wide filter.\n+         * The property name for the JVM-wide filter.\n+         * Used as a system property and a java.security.Security property.\n@@ -229,1 +447,1 @@\n-        private static final Object serialFilterLock = new Object();\n+        private static final String SERIAL_FILTER_PROPNAME = \"jdk.serialFilter\";\n@@ -232,1 +450,2 @@\n-         * Debug: Logger\n+         * The property name for the JVM-wide filter factory.\n+         * Used as a system property and a java.security.Security property.\n@@ -234,1 +453,1 @@\n-        private static final System.Logger configLog;\n+        private static final String SERIAL_FILTER_FACTORY_PROPNAME = \"jdk.serialFilterFactory\";\n@@ -237,1 +456,1 @@\n-         * Logger for debugging.\n+         * The property name to enable tracing of filters.\n@@ -239,5 +458,1 @@\n-        static void filterLog(System.Logger.Level level, String msg, Object... args) {\n-            if (configLog != null) {\n-                configLog.log(level, msg, args);\n-            }\n-        }\n+        private static final String SERIAL_FILTER_TRACE_PROPNAME = \"jdk.serialFilterTrace\";\n@@ -246,2 +461,1 @@\n-         * The name for the system-wide deserialization filter.\n-         * Used as a system property and a java.security.Security property.\n+         * Current static filter.\n@@ -249,1 +463,1 @@\n-        private static final String SERIAL_FILTER_PROPNAME = \"jdk.serialFilter\";\n+        private static volatile ObjectInputFilter serialFilter;\n@@ -252,3 +466,2 @@\n-         * The system-wide filter; may be null.\n-         * Lookup the filter in java.security.Security or\n-         * the system property.\n+         * Current serial filter factory.\n+         * @see Config#setSerialFilterFactory(BinaryOperator)\n@@ -256,1 +469,12 @@\n-        private static final ObjectInputFilter configuredFilter;\n+        private static volatile BinaryOperator<ObjectInputFilter>\n+                serialFilterFactory;\n+\n+        \/**\n+         * Debug: Logger\n+         *\/\n+        private static final System.Logger configLog;\n+\n+        \/**\n+         * True when tracing of filters is enabled.\n+         *\/\n+        private static final boolean traceFilters;\n@@ -259,21 +483,81 @@\n-            configuredFilter = AccessController\n-                    .doPrivileged((PrivilegedAction<ObjectInputFilter>) () -> {\n-                        String props = StaticProperty.jdkSerialFilter();\n-                        if (props == null) {\n-                            props = Security.getProperty(SERIAL_FILTER_PROPNAME);\n-                        }\n-                        if (props != null) {\n-                            System.Logger log =\n-                                    System.getLogger(\"java.io.serialization\");\n-                            log.log(System.Logger.Level.INFO,\n-                                    \"Creating serialization filter from {0}\", props);\n-                            try {\n-                                return createFilter(props);\n-                            } catch (RuntimeException re) {\n-                                log.log(System.Logger.Level.ERROR,\n-                                        \"Error configuring filter: {0}\", re);\n-                            }\n-                        }\n-                        return null;\n-                    });\n-            configLog = (configuredFilter != null) ? System.getLogger(\"java.io.serialization\") : null;\n+            \/*\n+             * Initialize the configuration containing the filter factory, JVM-wide filter, and logger.\n+             * <ul>\n+             * <li>The property 'jdk.serialFilter\" is read, either as a system property or a security property,\n+             *     and if set, defines the configured static JVM-wide filter and is logged.\n+             * <li>The property jdk.serialFilterFactory is read, either as a system property or a security property,\n+             *     and if set, defines the initial filter factory and is logged.\n+             * <li>If either property is defined, the logger is created.\n+             * <\/ul>\n+             *\/\n+\n+            \/\/ Get the values of the system properties, if they are defined\n+            String factoryClassName = StaticProperty.jdkSerialFilterFactory();\n+            if (factoryClassName == null) {\n+                \/\/ Fallback to security property\n+                factoryClassName = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+                        Security.getProperty(SERIAL_FILTER_FACTORY_PROPNAME));\n+            }\n+\n+            String filterString = StaticProperty.jdkSerialFilter();\n+            if (filterString == null) {\n+                \/\/ Fallback to security property\n+                filterString = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+                        Security.getProperty(SERIAL_FILTER_PROPNAME));\n+            }\n+\n+            traceFilters = GetBooleanAction.privilegedGetProperty(SERIAL_FILTER_TRACE_PROPNAME);\n+\n+            \/\/ Initialize the logger if either filter factory or filter property is set\n+            configLog = (filterString != null || factoryClassName != null || traceFilters)\n+                    ? System.getLogger(\"java.io.serialization\") : null;\n+\n+            \/\/ Initialize the JVM-wide filter if the jdk.serialFilter is present\n+            ObjectInputFilter filter = null;\n+            if (filterString != null) {\n+                configLog.log(INFO,\n+                        \"Creating deserialization filter from {0}\", filterString);\n+                try {\n+                    filter = createFilter(filterString);\n+                } catch (RuntimeException re) {\n+                    configLog.log(System.Logger.Level.ERROR,\n+                            \"Error configuring filter: {0}\", re);\n+                }\n+            }\n+            serialFilter = filter;\n+\n+            \/\/ Initialize the filter factory if the jdk.serialFilterFactory is defined\n+            \/\/ otherwise use the builtin filter factory.\n+            BinaryOperator<ObjectInputFilter> factory;\n+            if (factoryClassName != null) {\n+                configLog.log(INFO,\n+                        \"Creating deserialization filter factory for {0}\", factoryClassName);\n+                try {\n+                    \/\/ Load using the system class loader, the named class may be an application class.\n+                    \/\/ The static initialization of the class or constructor may create a race\n+                    \/\/ if either calls Config.setSerialFilterFactory; the command line configured\n+                    \/\/ Class should not be overridden.\n+                    Class<?> factoryClass= Class.forName(factoryClassName, true,\n+                            ClassLoader.getSystemClassLoader());\n+                    @SuppressWarnings(\"unchecked\")\n+                    BinaryOperator<ObjectInputFilter> f =\n+                            (BinaryOperator<ObjectInputFilter>)\n+                            factoryClass.getConstructor().newInstance(new Object[0]);\n+                    if (serialFilterFactory != null) {\n+                        configLog.log(System.Logger.Level.ERROR,\n+                                \"FilterFactory provided on the command line can not be overridden\");\n+                        \/\/ Do not continue if configuration not initialized\n+                        throw new ExceptionInInitializerError(\"FilterFactory provided on the command line can not be overridden\");\n+                    }\n+                    factory = f;\n+                } catch (RuntimeException | ClassNotFoundException | NoSuchMethodException |\n+                        IllegalAccessException | InstantiationException | InvocationTargetException ex) {\n+                    configLog.log(System.Logger.Level.ERROR,\n+                            \"Error configuring filter factory\", ex);\n+                    \/\/ Do not continue if configuration not initialized\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n+            } else {\n+                factory = new BuiltinFilterFactory();\n+            }\n+            serialFilterFactory = factory;\n@@ -286,1 +570,1 @@\n-         * Current configured filter.\n+         * Config has no instances.\n@@ -288,1 +572,11 @@\n-        private static volatile ObjectInputFilter serialFilter = configuredFilter;\n+        private Config() {\n+        }\n+\n+        \/**\n+         * Logger for filter actions.\n+         *\/\n+        private static void traceFilter(String msg, Object... args) {\n+            if (traceFilters && configLog != null) {\n+                configLog.log(TRACE, msg, args);\n+            }\n+        }\n@@ -291,1 +585,1 @@\n-         * Returns the system-wide serialization filter or {@code null} if not configured.\n+         * Returns the static JVM-wide deserialization filter or {@code null} if not configured.\n@@ -293,1 +587,1 @@\n-         * @return the system-wide serialization filter or {@code null} if not configured\n+         * @return the static JVM-wide deserialization filter or {@code null} if not configured\n@@ -300,1 +594,1 @@\n-         * Set the system-wide filter if it has not already been configured or set.\n+         * Set the static JVM-wide filter if it has not already been configured or set.\n@@ -302,1 +596,1 @@\n-         * @param filter the serialization filter to set as the system-wide filter; not null\n+         * @param filter the deserialization filter to set as the JVM-wide filter; not null\n@@ -321,0 +615,72 @@\n+        \/**\n+         * Returns the JVM-wide deserialization filter factory.\n+         * If the filter factory has been {@linkplain #setSerialFilterFactory(BinaryOperator) set} it is returned,\n+         * otherwise, a builtin deserialization filter factory is returned.\n+         * The filter factory provides a filter for every ObjectInputStream when invoked from\n+         * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}\n+         * and when a stream-specific filter is set with\n+         * {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.\n+         *\n+         * @implSpec\n+         * The builtin deserialization filter factory provides the\n+         * {plain#getSerialFilter static JVM-wide filter} when invoked from\n+         * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}.\n+         * When invoked {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)\n+         * to set the stream-specific filter} the requested filter replaces the static JVM-wide filter,\n+         * unless it has already been set.\n+         * The builtin deserialization filter factory implements the behavior of earlier versions of\n+         * setting the initial filter in the {@link ObjectInputStream} constructor and\n+         * {@link ObjectInputStream#setObjectInputFilter}.\n+         *\n+         * @return the JVM-wide deserialization filter factory; non-null\n+         * @since TBD\n+         *\/\n+        public static BinaryOperator<ObjectInputFilter> getSerialFilterFactory() {\n+            if (serialFilterFactory == null)\n+                throw new IllegalStateException(\"Serial filter factory initialization incomplete\");\n+            return serialFilterFactory;\n+        }\n+\n+        \/**\n+         * Set the {@linkplain #getSerialFilterFactory() JVM-wide deserialization filter factory}.\n+         * The filter factory can be configured exactly once with one of:\n+         * setting the {@code jdk.serialFilterFactory} property on the command line,\n+         * setting the {@code jdk.serialFilterFactory} property in the {@link java.security.Security}\n+         * file, or using this {@code setSerialFilterFactory} method.\n+         *\n+         * <p>The JVM-wide filter factory is invoked when an ObjectInputStream\n+         * {@linkplain ObjectInputStream#ObjectInputStream() is constructed} and when the\n+         * {@linkplain ObjectInputStream#setObjectInputFilter(ObjectInputFilter) stream-specific filter is set}.\n+         * The parameters are the current filter and a requested filter and it\n+         * returns the filter to be used for the stream.\n+         * The current and new filter may each be {@code null} and the factory may return {@code null}.\n+         * The factory determines the filter to be used for {@code ObjectInputStream} streams based\n+         * on its inputs, and any other filters, context, or state that is available.\n+         * The factory may throw runtime exceptions to signal incorrect use or invalid parameters.\n+         * See the {@linkplain ObjectInputFilter filter models} for examples of composition and delegation.\n+         *\n+         * @param filterFactory the deserialization filter factory to set as the JVM-wide filter factory; not null\n+         * @throws IllegalStateException if the builtin deserialization filter factory has already been set once\n+         * @throws SecurityException if there is security manager and the\n+         *       {@code SerializablePermission(\"serialFilter\")} is not granted\n+         * @since TBD\n+         *\/\n+        public static void setSerialFilterFactory(\n+                BinaryOperator<ObjectInputFilter> filterFactory) {\n+            Objects.requireNonNull(filterFactory, \"filterFactory\");\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null) {\n+                sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);\n+            }\n+            if (serialFilterFactory instanceof BuiltinFilterFactory) {\n+                \/\/ The factory can be set only if it has been initialized to the builtin.\n+                serialFilterFactory = filterFactory;\n+                return;\n+            }\n+            \/\/ Either the serialFilterFactory has already been set by setSerialFilterFactory\n+            \/\/ or it is {@code null}, because the Config static initialization has not completed.\n+            \/\/ In either case, the serialFilterFactory can not be set.\n+            throw new IllegalStateException(\"Serial filter factory can not replace: \" +\n+                    serialFilterFactory.getClass().getName());\n+        }\n+\n@@ -402,0 +768,84 @@\n+        \/**\n+         * Returns a filter that returns {@code Status.ALLOWED} if the predicate on the class is {@code true},\n+         * otherwise the {@code otherStatus}.\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput} method is invoked,\n+         * the predicate is applied to the {@link FilterInfo#serialClass()}, the return Status is:\n+         * <ul>\n+         *     <li>{@link Status#UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+         * <\/ul>\n+         * <p>\n+         * Example, to create a filter that will allow any class loaded from the platform classloader.\n+         * <pre><code>\n+         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n+         *                                          || cl.getClassLoader() == null, Status.UNDECIDED);\n+         * <\/code><\/pre>\n+         *\n+         * @param predicate a predicate to test a non-null Class, non-null\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return {@link Status#ALLOWED} if the predicate on the class returns {@code true},\n+         *          otherwise {@link Status#UNDECIDED}\n+         *\/\n+        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new Config.PredicateFilter(predicate, ALLOWED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns {@code Status.REJECTED} if the predicate on the class is {@code true},\n+         * otherwise the {@code otherStatus}.\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput} method is invoked,\n+         * the predicate is applied to the {@link FilterInfo#serialClass()}, the return Status is:\n+         * <ul>\n+         *     <li>{@link Status#UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#REJECTED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+         * <\/ul>\n+         * <p>\n+         * Example, to create a filter that will reject any class loaded from the application classloader.\n+         * <pre><code>\n+         *     ObjectInputFilter f = rejectFilter(cl ->\n+         *          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);\n+         * <\/code><\/pre>\n+         *\n+         * @param predicate a predicate to test a non-null Class, non-null\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return {@link Status#REJECTED} if the predicate on the class returns {@code true},\n+         *          otherwise {@link Status#UNDECIDED}\n+         *\/\n+        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new Config.PredicateFilter(predicate, REJECTED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns {@code Status.ALLOWED} if the check is for limits\n+         * and not checking a class; otherwise {@code Status.UNDECIDED}.\n+         * If the {@link FilterInfo#serialClass()} is {@code null}, the filter returns\n+         * {@code Status.ALLOWED}, otherwise return {@code Status.UNDECIDED}.\n+         * The limit values of {@link FilterInfo#arrayLength()}, {@link FilterInfo#depth()},\n+         * {@link FilterInfo#references()}, and {@link FilterInfo#streamBytes()} are not checked.\n+         * To place a limit, create a separate filter with limits such as:\n+         * <pre>{@code\n+         * Config.createFilter(\"maxarray=10000,maxdepth=40\");\n+         * }<\/pre>\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput} method is invoked,\n+         * the {@link FilterInfo#serialClass()} is checked for {@code null}.\n+         * <ul>\n+         *     <li>{@link Status#ALLOWED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @return {@link Status#REJECTED} if {@linkplain FilterInfo#serialClass()} serialClass is null}\n+         * {@code true}, otherwise {@link Status#UNDECIDED}\n+         *\/\n+        public static ObjectInputFilter allowMaxLimits() {\n+            return new Config.AllowMaxLimitsFilter(ALLOWED, UNDECIDED);\n+        }\n+\n@@ -404,1 +854,1 @@\n-         * the system-wide serialization filter. If configured, it will be\n+         * the JVM-wide deserialization filter. If configured, it will be\n@@ -408,1 +858,1 @@\n-        static final class Global implements ObjectInputFilter {\n+        final static class Global implements ObjectInputFilter {\n@@ -635,0 +1085,1 @@\n+                            traceFilter(\"Pattern array class: {0}, filter: {1}\", clazz, this);\n@@ -645,1 +1096,2 @@\n-                        return Status.UNDECIDED;\n+                        traceFilter(\"Pattern UNDECIDED, primitive class: {0}, filter: {1}\", clazz, this);\n+                        return UNDECIDED;\n@@ -653,1 +1105,3 @@\n-                        return status.orElse(Status.UNDECIDED);\n+                        Status s = status.orElse(Status.UNDECIDED);\n+                        traceFilter(\"Pattern {0}, class: {1}, filter: {2}\", s, cl, this);\n+                        return s;\n@@ -656,1 +1110,2 @@\n-                return Status.UNDECIDED;\n+                \/\/ There are no classes to check and none of the limits have been exceeded.\n+                return UNDECIDED;\n@@ -680,0 +1135,270 @@\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate a predicate mapping a class to a boolean.\n+         *\/\n+        private static class PredicateFilter implements ObjectInputFilter {\n+            private final Predicate<Class<?>> predicate;\n+            private final Status ifTrueStatus;\n+            private final Status ifFalseStatus;\n+\n+            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus, Status ifFalseStatus) {\n+                this.predicate = predicate;\n+                this.ifTrueStatus = ifTrueStatus;\n+                this.ifFalseStatus = ifFalseStatus;\n+            }\n+\n+            \/**\n+             * Apply the predicate to the class being deserialized, if the class is non-null\n+             * and if it returns {@code true}, return the requested status. Otherwise, return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of applying the predicate, otherwise {@code UNDECIDED}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Class<?> clazz = info.serialClass();\n+                Status status = (clazz != null && predicate.test(clazz)) ? ifTrueStatus : ifFalseStatus;\n+                traceFilter(\"PredicateFilter {0}, filter: {1}\", status, this);\n+                return status;\n+            }\n+\n+            public String toString() {\n+                return \"predicate(\" + predicate + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate if a FilterInfo is checking only limits,\n+         * and not classes.\n+         *\/\n+        private static class AllowMaxLimitsFilter implements ObjectInputFilter {\n+            private final Status limitCheck;\n+            private final Status classCheck;\n+\n+            AllowMaxLimitsFilter(Status limitCheck, Status classCheck) {\n+                this.limitCheck = limitCheck;\n+                this.classCheck = classCheck;\n+            }\n+\n+            \/**\n+             * If the FilterInfo is only checking a limit, return the requested\n+             * status, otherwise the other status.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of corresponding to serialClass == null or not\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                return (info.serialClass() == null) ? limitCheck : classCheck;\n+            }\n+\n+            public String toString() {\n+                return \"allowMaxLimits()\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the status of two filters.\n+         *\/\n+        private static class MergeFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter first;\n+            private final ObjectInputFilter second;\n+\n+            MergeFilter(ObjectInputFilter first, ObjectInputFilter second) {\n+                this.first = first;\n+                this.second = second;\n+            }\n+\n+            \/**\n+             * Returns REJECTED if either of the filters returns REJECTED,\n+             * and ALLOWED if either of the filters returns ALLOWED.\n+             * Returns {@code UNDECIDED} if either filter returns {@code UNDECIDED}.\n+             *\n+             * @param info the FilterInfo\n+             * @return Status.REJECTED if either of the filters returns REJECTED,\n+             * and ALLOWED if either filter returns ALLOWED; otherwise returns\n+             * {@code UNDECIDED} if both filters returned {@code UNDECIDED}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+               Status firstStatus = Objects.requireNonNull(first.checkInput(info), \"status\");\n+                if (REJECTED.equals(firstStatus)) {\n+                    traceFilter(\"MergeFilter REJECT first: {0}, filter: {1}\",\n+                            firstStatus, this);\n+                    return REJECTED;\n+                }\n+                Status secondStatus = Objects.requireNonNull(second.checkInput(info), \"other status\");\n+                if (REJECTED.equals(secondStatus)) {\n+                    traceFilter(\"MergeFilter REJECT {0}, {1}, filter: {2}\",\n+                            firstStatus, secondStatus, this);\n+                    return REJECTED;\n+                }\n+                if (ALLOWED.equals(firstStatus) || ALLOWED.equals(secondStatus)) {\n+                    traceFilter(\"MergeFilter ALLOW either: {0}, {1}, filter: {2}\",\n+                            firstStatus, secondStatus, this);\n+                    return ALLOWED;\n+                }\n+                traceFilter(\"MergeFilter UNDECIDED {0}, {1}, filter: {2}\",\n+                        firstStatus, secondStatus, this);\n+                return UNDECIDED;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"merge(\" + first + \", \" + second + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * A filter that maps the status {@code UNDECIDED} to {@code REJECTED} when checking a class.\n+         *\/\n+        private static class RejectUndecidedClass implements ObjectInputFilter {\n+            private final ObjectInputFilter filter;\n+\n+            private RejectUndecidedClass(ObjectInputFilter filter) {\n+                this.filter = Objects.requireNonNull(filter, \"filter\");\n+            }\n+\n+            \/**\n+             * Apply the filter and return the status if not UNDECIDED and checking a class.\n+             * For array classes, re-check the final component type against the filter.\n+             * Make an exception for Primitive classes that are implicitly allowed by the pattern based filter.\n+             * @param info the FilterInfo\n+             * @return the status of applying the filter and checking the class\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status status = Objects.requireNonNull(filter.checkInput(info), \"status\");\n+                Class<?> clazz = info.serialClass();\n+                if (clazz == null || !UNDECIDED.equals(status))\n+                    return status;\n+                status = REJECTED;\n+                \/\/ Find the base component type\n+                while (clazz.isArray()) {\n+                    clazz = clazz.getComponentType();\n+                }\n+                if (clazz.isPrimitive()) {\n+                    status = UNDECIDED;\n+                } else {\n+                    \/\/ for non-primitive types;  re-filter the base component type\n+                    FilterInfo clazzInfo = new SerialInfo(info, clazz);\n+                    Status clazzStatus = filter.checkInput(clazzInfo);\n+                    traceFilter(\"RejectUndecidedClass Array Component type {0} class: {1}, filter: {2}\",\n+                            clazzStatus, clazz, this);\n+                    if (!ALLOWED.equals(clazzStatus))\n+                        status = REJECTED;\n+                }\n+                traceFilter(\"RejectUndecidedClass {0} class: {1}, filter: {2}\",\n+                        status, info.serialClass(), this);\n+                return status;\n+            }\n+\n+            public String toString() {\n+                return \"rejectUndecidedClass(\" + filter + \")\";\n+            }\n+\n+            \/**\n+             * FilterInfo instance with a specific class and delegating to an existing FilterInfo.\n+             * Nested in the rejectUndecided class.\n+             *\/\n+            static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+                private final FilterInfo base;\n+                private final Class<?> clazz;\n+\n+                SerialInfo(FilterInfo base, Class<?> clazz) {\n+                    this.base = base;\n+                    this.clazz = clazz;\n+                }\n+\n+                @Override\n+                public Class<?> serialClass() {\n+                    return clazz;\n+                }\n+\n+                @Override\n+                public long arrayLength() {\n+                    return base.arrayLength();\n+                }\n+\n+                @Override\n+                public long depth() {\n+                    return base.depth();\n+                }\n+\n+                @Override\n+                public long references() {\n+                    return base.references();\n+                }\n+\n+                @Override\n+                public long streamBytes() {\n+                    return base.streamBytes();\n+                }\n+            }\n+\n+        }\n+\n+        \/**\n+         * Builtin Deserialization filter factory.\n+         * The builtin deserialization filter factory provides the\n+         * {@linkplain #getSerialFilter static serial filter} when invoked from\n+         * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}.\n+         * When invoked from {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)\n+         * to set the stream-specific filter} the requested filter replaces the static serial filter,\n+         * unless it has already been set. The stream-specific filter can only be set once,\n+         * if it has already been set, {@link IllegalStateException} is thrown.\n+         * The builtin deserialization filter factory implements the behavior of earlier versions of\n+         * setting the static serial filter in the {@link ObjectInputStream} constructor and\n+         * {@link ObjectInputStream#setObjectInputFilter}.\n+         *\n+         *\/\n+        private static final class BuiltinFilterFactory\n+                implements BinaryOperator<ObjectInputFilter> {\n+            \/**\n+             * Returns the ObjectInputFilter to be used for an ObjectInputStream.\n+             * This method implements the builtin deserialization filter factory.\n+             * If the {@code oldFilter} and {@code newFilter} are null,\n+             *     the {@link Config#getSerialFilter()} is returned.\n+             * If the {@code oldFilter} is {@code null} and {@code newFilter} is {@code not null},\n+             *     the {@code newFilter} is returned.\n+             * If the {@code oldFilter} is equal to {@link Config#getSerialFilter},\n+             *     the {@code newFilter} is returned.\n+             * Otherwise {@code IllegalStateException} exception is thrown.\n+             *\n+             * <p>This is backward compatible behavior with earlier versions of\n+             * {@link ObjectInputStream#setObjectInputFilter},\n+             * and the initial filter in the {@link ObjectInputStream} constructor.\n+             *\n+             * @param oldFilter the current filter, may be null\n+             * @param newFilter a new filter, may be null\n+             * @return an ObjectInputFilter, the new Filter\n+             * @throws IllegalStateException if the {@linkplain ObjectInputStream#getObjectInputFilter() current filter}\n+             *       is not {@code null} and is not the JVM-wide filter\n+             *\/\n+            @Override\n+            public ObjectInputFilter apply(ObjectInputFilter oldFilter, ObjectInputFilter newFilter) {\n+                if (oldFilter != null) {\n+                    \/\/ JEP 290 spec restricts setting the stream-specific filter more than once.\n+                    \/\/ Allow replacement of the JVM-wide filter but not replacement\n+                    \/\/ of a stream-specific filter that has been set.\n+                    if (oldFilter != getSerialFilter()) {\n+                        throw new IllegalStateException(\"filter can not be set more than once\");\n+                    }\n+                } else if (newFilter == null) {\n+                    \/\/ Called from constructor, default to the configured filter, (may be null)\n+                    ObjectInputFilter filter = Config.getSerialFilter();\n+                    if (filter != null)\n+                        traceFilter(\"Builtin factory: {0} -> conf: {1}\",\n+                            oldFilter, Config.getSerialFilter());\n+                    return filter;\n+                }\n+                if (newFilter != null)\n+                    traceFilter(\"Builtin factory: {0} -> new: {1}\",\n+                        oldFilter, newFilter);\n+                return newFilter;\n+            }\n+\n+            \/**\n+             * Returns the class name name of this builtin deserialization filter factory.\n+             * @return returns the class name of this builtin deserialization filter factory\n+             *\/\n+            public String toString() {\n+                return this.getClass().getName();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":813,"deletions":88,"binary":false,"changes":901,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.ObjectInputFilter.Config;\n@@ -47,0 +48,1 @@\n+import java.util.function.BinaryOperator;\n@@ -190,4 +192,13 @@\n- *\n- * <p>The contents of the stream can be filtered during deserialization.\n- * If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}\n- * on an ObjectInputStream, the {@link ObjectInputFilter} can check that\n+ * <p>\n+ * The key to disabling deserialization attacks is to prevent instances of\n+ * arbitrary classes from being deserialized, thereby preventing the direct or\n+ * indirect execution of their methods.  Each stream has an optional deserialization filter\n+ * to check the classes and resource limits during deserialization.\n+ * The JVM-wide filter factory ensures that a filter can be set on every {@link ObjectInputStream}\n+ * and every object read from the stream can be checked.\n+ * The {@linkplain #ObjectInputStream() ObjectInputStream constructors} invoke the filter factory\n+ * to select the initial filter and it is updated by {@link #setObjectInputFilter}.\n+ * {@link ObjectInputFilter} describes how to use filters and\n+ * {@link ObjectInputFilter.Config} describes how to configure the filter and filter factory.\n+ * <p>\n+ * If an ObjectInputStream has a filter, the {@link ObjectInputFilter} can check that\n@@ -197,3 +208,0 @@\n- * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}\n- * can be configured that is applied to each {@code ObjectInputStream} unless replaced\n- * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.\n@@ -350,0 +358,5 @@\n+    \/**\n+     * True if the stream-specific filter has been set; initially false.\n+     *\/\n+    private boolean streamFilterSet;\n+\n@@ -356,2 +369,3 @@\n-     * <p>The serialization filter is initialized to the value of\n-     * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.\n+     * <p>The deserialization filter is initialized to the filter returned\n+     * by invoking the {@link Config#getSerialFilterFactory()} with {@code null} for the current filter\n+     * and the {@linkplain Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -380,1 +394,2 @@\n-        serialFilter = ObjectInputFilter.Config.getSerialFilter();\n+        streamFilterSet = false;\n+        serialFilter = Config.getSerialFilterFactory().apply(null, Config.getSerialFilter());\n@@ -391,2 +406,3 @@\n-     * <p>The serialization filter is initialized to the value of\n-     * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.\n+     * <p>The deserialization filter is initialized to the filter returned\n+     * by invoking the {@link Config#getSerialFilterFactory()} with {@code null} for the current filter\n+     * and the {@linkplain Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -414,1 +430,2 @@\n-        serialFilter = ObjectInputFilter.Config.getSerialFilter();\n+        streamFilterSet = false;\n+        serialFilter = Config.getSerialFilterFactory().apply(null, Config.getSerialFilter());\n@@ -433,1 +450,1 @@\n-     * <p>The serialization filter, when not {@code null}, is invoked for\n+     * <p>The deserialization filter, when not {@code null}, is invoked for\n@@ -445,1 +462,1 @@\n-     *          serialization.\n+     *          deserialization.\n@@ -566,1 +583,1 @@\n-     * <p>The serialization filter, when not {@code null}, is invoked for\n+     * <p>The deserialization filter, when not {@code null}, is invoked for\n@@ -874,1 +891,1 @@\n-     * field or array element abort the serialization by raising an exception\n+     * field or array element abort the deserialization by raising an exception\n@@ -1224,5 +1241,5 @@\n-     * Returns the serialization filter for this stream.\n-     * The serialization filter is the most recent filter set in\n-     * {@link #setObjectInputFilter setObjectInputFilter} or\n-     * the initial system-wide filter from\n-     * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.\n+     * Returns the deserialization filter for this stream.\n+     * The filter is the result of invoking the\n+     * {@link Config#getSerialFilterFactory() JVM-wide filter factory}\n+     * either by the {@linkplain #ObjectInputStream() constructor} or the most recent invocation of\n+     * {@link #setObjectInputFilter setObjectInputFilter}.\n@@ -1230,1 +1247,1 @@\n-     * @return the serialization filter for the stream; may be null\n+     * @return the deserialization filter for the stream; may be null\n@@ -1238,2 +1255,12 @@\n-     * Set the serialization filter for the stream.\n-     * The filter's {@link ObjectInputFilter#checkInput checkInput} method is called\n+     * Set the deserialization filter for the stream.\n+     * The filter can be set and only set once before reading any objects from the stream;\n+     * for example, by calling {@link #readObject} or {@link #readUnshared}.\n+     *\n+     * <p>The deserialization filter is set to the filter returned\n+     * by invoking the {@linkplain Config#getSerialFilterFactory() JVM-wide filter factory}\n+     * with the current filter and the {@code filter} parameter.\n+     * If there is a non-null filter for the stream, one was set in the constructor, and the filter factory\n+     * must return a non-null filter. It is not permitted to remove filtering once established.\n+     * See the {@linkplain ObjectInputFilter filter models} for examples of composition and delegation.\n+     *\n+     * <p>The filter's {@link ObjectInputFilter#checkInput checkInput} method is called\n@@ -1248,2 +1275,2 @@\n-     * The filter is invoked only when reading objects from the stream and for\n-     * not primitives.\n+     * The filter is invoked only when reading objects from the stream and not for\n+     * primitives.\n@@ -1256,7 +1283,0 @@\n-     * <p>\n-     * The serialization filter is initialized to the value of\n-     * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}\n-     * when the {@code  ObjectInputStream} is constructed and can be set\n-     * to a custom filter only once.\n-     * The filter must be set before reading any objects from the stream;\n-     * for example, by calling {@link #readObject} or {@link #readUnshared}.\n@@ -1304,3 +1324,4 @@\n-     * @throws IllegalStateException if the {@linkplain #getObjectInputFilter() current filter}\n-     *       is not {@code null} and is not the system-wide filter, or\n-     *       if an object has been read\n+     * @throws IllegalStateException if an object has been read,\n+     *       if the filter factory returns {@code null} when the\n+     *       {@linkplain #getObjectInputFilter() current filter} is non-null, or\n+     *       if the filter has already been set.\n@@ -1312,0 +1333,1 @@\n+            \/\/ TBD double checks, here and in the default serialFilterFactory\n@@ -1314,5 +1336,0 @@\n-        \/\/ Allow replacement of the system-wide filter if not already set\n-        if (serialFilter != null &&\n-                serialFilter != ObjectInputFilter.Config.getSerialFilter()) {\n-            throw new IllegalStateException(\"filter can not be set more than once\");\n-        }\n@@ -1323,1 +1340,10 @@\n-        this.serialFilter = filter;\n+        if (streamFilterSet) {\n+            throw new IllegalStateException(\"filter can not be replaced\");\n+        }\n+        \/\/ Delegate to serialFilterFactory to compute stream filter\n+        ObjectInputFilter next =  Config.getSerialFilterFactory()\n+                .apply(serialFilter, filter);\n+        if (serialFilter != null && next == null) {\n+            throw new IllegalStateException(\"filter can not be replaced with null filter\");\n+        }\n+        serialFilter = next;\n@@ -1327,1 +1353,1 @@\n-     * Invokes the serialization filter if non-null.\n+     * Invokes the deserialization filter if non-null.\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":70,"deletions":44,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private static final String JDK_SERIAL_FILTER_FACTORY;\n@@ -65,0 +66,1 @@\n+        JDK_SERIAL_FILTER_FACTORY = getProperty(props, \"jdk.serialFilterFactory\", null);\n@@ -187,0 +189,14 @@\n+\n+    \/**\n+     * Return the {@code jdk.serialFilterFactory} system property.\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method. The caller of this method should take care to ensure\n+     * that the returned property is not made accessible to untrusted code.<\/strong>\n+     *\n+     * @return the {@code user.name} system property\n+     *\/\n+    public static String jdkSerialFilterFactory() {\n+        return JDK_SERIAL_FILTER_FACTORY;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,789 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InvalidClassException;\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.Status;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Predicate;\n+\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n+\n+\/* @test\n+ * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFactoryExample\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFactoryExample$FilterInThread -Djdk.serialFilterTrace=true SerialFactoryExample\n+ * @summary Test SerialFactoryExample\n+ *\/\n+\n+\/*\n+ * Context-specific Deserialization Filter Example\n+ *\n+ * To protect deserialization of a thread or a call to an untrusted library function,\n+ * a filter is set that applies to every deserialization within the thread.\n+ *\n+ * The `doWithSerialFilter` method arguments are a serial filter and\n+ * a lambda to invoke with the filter in force.  Its implementation creates a stack of filters\n+ * using a `ThreadLocal`. The stack of filters is composed with the static JVM-wide filter,\n+ * and an optional stream-specific filter.\n+ *\n+ * The FilterInThread filter factory is set as the JVM-wide filter factory.\n+ * When the filter factory is invoked during the construction of each `ObjectInputStream`,\n+ * it retrieves the filter(s) from the thread local and combines it with the static JVM-wide filter,\n+ * and the stream-specific filter.\n+ *\n+ * If more than one filter is to be applied to the stream, two filters can be composed\n+ * using `ObjectInputFilter.merge`.  When invoked, each of the filters is invoked and the results\n+ * are combined such that if either filter rejects a class, the result is rejected.\n+ * If either filter allows the class, then it is allowed, otherwise it is undecided.\n+ * Hierarchies and chains of filters can be built using `ObjectInputFilter.merge`.\n+ *\n+ * The `doWithSerialFilter` calls can be nested. When nested, the filters are concatenated.\n+ *\/\n+@Test\n+public class SerialFactoryExample {\n+\n+    private static final Class<? extends Exception> NO_EXCEPTION = null;\n+\n+    @DataProvider(name = \"Examples\")\n+    static Object[][] examples() {\n+        return new Object[][]{\n+                {new Point(1, 2), null,\n+                        ALLOWED},\n+                {new Point(1, 2), ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        ALLOWED},\n+                {Integer.valueOf(10), Filters.allowPlatformClasses(),\n+                        ALLOWED},          \/\/ Integer is a platform class\n+                {new int[10], ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        UNDECIDED},          \/\/ arrays of primitives are UNDECIDED -> allowed\n+                {int.class, ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        UNDECIDED},          \/\/ primitive classes are UNDECIDED -> allowed\n+                {new Point[] {new Point(1, 1)}, ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        ALLOWED},          \/\/ Arrays of allowed classes are allowed\n+                {new Integer[10], ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        REJECTED},   \/\/ Base component type is checked -> REJECTED\n+                {new Point(1, 2), ObjectInputFilter.Config.createFilter(\"!SerialFactoryExample$Point\"),\n+                        REJECTED},   \/\/ Denied\n+                {new Point(1, 3), Filters.allowPlatformClasses(),\n+                        REJECTED},   \/\/ Not a platform class\n+                {new Point(1, 4), ObjectInputFilter.Config.createFilter(\"java.lang.Integer\"),\n+                        REJECTED},   \/\/ Only Integer is ALLOWED\n+                {new Point(1, 5), ObjectInputFilter.Config.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader(), UNDECIDED),\n+                        REJECTED},   \/\/ Not platform loader is UNDECIDED -> a class that should not be undecided -> rejected\n+        };\n+    }\n+\n+\n+    @Test(dataProvider = \"Examples\")\n+    static void examples(Serializable obj, ObjectInputFilter filter, Status expected) {\n+        \/\/ Establish FilterInThread as the application-wide filter factory\n+        FilterInThread filterInThread;\n+        if (ObjectInputFilter.Config.getSerialFilterFactory() instanceof FilterInThread fit) {\n+            \/\/ Filter factory selected on the command line with -Djdk.serialFilterFactory=<classname>\n+            filterInThread = fit;\n+        } else {\n+            \/\/ Create a FilterInThread filter factory and set\n+            \/\/ An IllegalStateException will be thrown if the filter factory was already\n+            \/\/ initialized to an incompatible filter factory.\n+            filterInThread = new FilterInThread();\n+            ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+        }\n+        try {\n+            filterInThread.doWithSerialFilter(filter, () -> {\n+                byte[] bytes = writeObject(obj);\n+                Object o = deserializeObject(bytes);\n+            });\n+            if (expected.equals(REJECTED))\n+                Assert.fail(\"IllegalClassException should have occurred\");\n+        } catch (UncheckedIOException uioe) {\n+            IOException ioe = uioe.getCause();\n+            Assert.assertEquals(ioe.getClass(), InvalidClassException.class, \"Wrong exception\");\n+            Assert.assertTrue(expected.equals(REJECTED), \"Exception should not have occurred\");\n+        }\n+    }\n+\n+    \/**\n+     * Test various filters with various objects and the resulting status\n+     * @param obj an object\n+     * @param filter a filter\n+     * @param expected status\n+     *\/\n+    @Test(dataProvider = \"Examples\")\n+    static void checkStatus(Serializable obj, ObjectInputFilter filter, Status expected) {\n+        \/\/ Establish FilterInThread as the application-wide filter factory\n+        FilterInThread filterInThread;\n+        if (ObjectInputFilter.Config.getSerialFilterFactory() instanceof FilterInThread fit) {\n+            \/\/ Filter factory selected on the command line with -Djdk.serialFilterFactory=<classname>\n+            filterInThread = fit;\n+        } else {\n+            \/\/ Create a FilterInThread filter factory and set\n+            \/\/ An IllegalStateException will be thrown if the filter factory was already\n+            \/\/ initialized to an incompatible filter factory.\n+            filterInThread = new FilterInThread();\n+            ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+        }\n+\n+        try {\n+            filterInThread.doWithSerialFilter(filter, () -> {\n+                \/\/ Classes are serialized as themselves, otherwise pass the object's class\n+                Class<?> clazz = (obj instanceof Class<?>) ? (Class<?>)obj : obj.getClass();\n+                ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+                var compositeFilter = filterInThread.apply(null, ObjectInputFilter.Config.getSerialFilter());\n+                System.out.println(\"    filter in effect: \" + filterInThread.currFilter);\n+                if (compositeFilter != null) {\n+                    Status actualStatus = compositeFilter.checkInput(info);\n+                    Assert.assertEquals(actualStatus, expected, \"Wrong Status\");\n+                }\n+            });\n+\n+        } catch (Exception ex) {\n+            Assert.fail(\"unexpected exception\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * A Context-specific Deserialization Filter Factory to create filters that apply\n+     * a serial filter to all of the deserializations performed in a thread.\n+     * The purpose is to establish a deserialization filter that will reject all classes\n+     * that are not explicitly included.\n+     * <p>\n+     * The filter factory creates a composite filter of the stream-specific filter,\n+     * the thread-specific filter, the static JVM-wide filter, and a filter to reject all UNDECIDED cases.\n+     * The static JVM-wide filter is always included, if it is configured;\n+     * see ObjectInputFilter.Config.getSerialFilter().\n+     * <p>\n+     * To enable these protections the FilterInThread instance should be set as the\n+     * JVM-wide filter factory in ObjectInputFilter.Config.setSerialFilterFactory.\n+     *\n+     * The {@code doWithSerialFilter} is invoked with a serial filter and a lambda\n+     * to be invoked after the filter is applied.\n+     *\/\n+    public static final class FilterInThread\n+            implements BinaryOperator<ObjectInputFilter> {\n+\n+        \/\/ ThreadLocal holding the Deque of serial filters to be applied, not null\n+        private final ThreadLocal<ArrayDeque<ObjectInputFilter>> filterThreadLocal =\n+                ThreadLocal.withInitial(() -> new ArrayDeque<>());\n+\n+        private ObjectInputFilter currFilter;\n+\n+        \/**\n+         * Construct a FilterInThread deserialization filter factory.\n+         * The constructor is public so FilterInThread can be set on the command line\n+         * with {@code -Djdk.serialFilterFactory=SerialFactoryExample$FilterInThread}.\n+         *\/\n+        public FilterInThread() {\n+        }\n+\n+        \/**\n+         * Applies the filter to the thread and invokes the runnable.\n+         * The filter is pushed to a ThreadLocal, saving the old value.\n+         * If there was a previous thread filter, the new filter is appended\n+         * and made the active filter.\n+         * The runnable is invoked.\n+         * The previous filter is restored to the ThreadLocal.\n+         *\n+         * @param filter the serial filter to apply\n+         * @param runnable a runnable to invoke\n+         *\/\n+        public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+            var prevFilters = filterThreadLocal.get();\n+            try {\n+                if (filter != null)\n+                    prevFilters.addLast(filter);\n+                runnable.run();\n+            } finally {\n+                if (filter != null) {\n+                    var lastFilter = prevFilters.removeLast();\n+                    assert lastFilter == filter : \"Filter removed out of order\";\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Returns a composite filter of the stream-specific filter, the thread-specific filter,\n+         * the static JVM-wide filter, and a filter to reject all UNDECIDED cases.\n+         * The purpose is to establish a deserialization filter that will reject all classes\n+         * that are not explicitly included.\n+         * The static JVM-wide filter is always checked, if it is configured;\n+         * see ObjectInputFilter.Config.getSerialFilter().\n+         * Any or all of the filters are optional and if not supplied or configured are null.\n+         * <p>\n+         * This method is first called from the constructor with current == null and\n+         * next == static JVM-wide filter.\n+         * The filter returned is the static JVM-wide filter merged with the thread-specific filter\n+         * and followed by a filter to map all UNDECIDED status values to REJECTED.\n+         * This last step ensures that the collective group of filters covers every possible case,\n+         * any classes that are not ALLOWED will be REJECTED.\n+         * <p>\n+         * The method mayy be called a second time from {@code ObjectInputStream.setObjectInputFilter(next)}\n+         * to add a stream-specific filter.  The stream-specific filter is prepended to the\n+         * composite filter created above when called from the constructor.\n+         * <p>\n+         *\n+         * @param curr the current filter, may be null\n+         * @param next the next filter, may be null\n+         * @return a deserialization filter to use for the stream, may be null\n+         *\/\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            if (curr == null) {\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no previous filter\n+                \/\/ no current filter, prepend next to threadFilter, both may be null or non-null\n+\n+                \/\/ Assemble the filters in sequence, most recently added first\n+                var filters = filterThreadLocal.get();\n+                ObjectInputFilter filter = null;\n+                for (ObjectInputFilter f : filters) {\n+                    filter = f.merge(filter);\n+                }\n+                if (next != null) {\n+                    \/\/ Prepend a filter to assert that all classes have been Allowed or Rejected\n+                    if (filter != null) {\n+                        filter = filter.rejectUndecidedClass();\n+                    }\n+\n+                    \/\/ Prepend the next filter to the thread filter, if any\n+                    \/\/ Initially this would be the static JVM-wide filter passed from the OIS constructor\n+                    \/\/ The static JVM-wide filter allow, reject, or leave classes undecided\n+                    filter = next.merge(filter);\n+                }\n+                \/\/ Check that the static JVM-wide filter did not leave any classes undecided\n+                if (filter != null) {\n+                    \/\/ Append the filter to reject all UNDECIDED results\n+                    filter = filter.rejectUndecidedClass();\n+                }\n+                \/\/ Return the filter, unless a stream-specific filter is set later\n+                \/\/ The filter may be null if no filters are configured\n+                currFilter = filter;\n+                return currFilter;\n+            } else {\n+                \/\/ Called from OIS.setObjectInputFilter with a previously set filter.\n+                \/\/ The curr filter already incorporates the thread filter and rejection of undecided status\n+                \/\/ Prepend the stream-specific filter or the current filter if no stream-specific filter\n+                currFilter = (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n+                return currFilter;\n+            }\n+        }\n+        public String toString() {\n+            return Objects.toString(currFilter, \"none\");\n+        }\n+    }\n+\n+\n+    \/**\n+     * Simple example code from the ObjectInputFilter Class javadoc.\n+     *\/\n+    public static final class SimpleFilterInThread implements BinaryOperator<ObjectInputFilter> {\n+\n+        private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new InheritableThreadLocal<>();\n+\n+        \/\/ Construct a FilterInThread deserialization filter factory.\n+        public SimpleFilterInThread() {}\n+\n+        \/\/ Returns a composite filter of the static JVM-wide filter, a thread-specific filter,\n+        \/\/ and the stream-specific filter.\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            if (curr == null) {\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no previous filter\n+                var filter = filterThreadLocal.get();\n+                if (filter != null) {\n+                    \/\/ Prepend a filter to assert that all classes have been Allowed or Rejected\n+                    filter = filter.rejectUndecidedClass();\n+                }\n+                if (next != null) {\n+                    \/\/ Prepend the `next` filter to the thread filter, if any\n+                    \/\/ Initially this is the static JVM-wide filter passed from the OIS constructor\n+                    \/\/ Append the filter to reject all UNDECIDED results\n+                    filter = next.merge(filter).rejectUndecidedClass();\n+                }\n+                return filter;\n+            } else {\n+                \/\/ Called from OIS.setObjectInputFilter with a current filter and a stream-specific filter.\n+                \/\/ The curr filter already incorporates the thread filter and static JVM-wide filter\n+                \/\/ and rejection of undecided classes\n+                \/\/ Use the current filter or prepend the stream-specific filter and recheck for undecided\n+                return (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n+            }\n+        }\n+\n+        \/\/ Applies the filter to the thread and invokes the runnable.\n+        public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+            var prevFilter = filterThreadLocal.get();\n+            try {\n+                filterThreadLocal.set(filter);\n+                runnable.run();\n+            } finally {\n+                filterThreadLocal.set(prevFilter);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Write an object and return a byte array with the bytes.\n+     *\n+     * @param object object to serialize\n+     * @return the byte array of the serialized object\n+     * @throws UncheckedIOException if an exception occurs\n+     *\/\n+    private static byte[] writeObject(Object object) {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(object);\n+            return baos.toByteArray();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Deserialize an object.\n+     *\n+     * @param bytes an object.\n+     * @throws UncheckedIOException for I\/O exceptions and ClassNotFoundException\n+     *\/\n+    private static Object deserializeObject(byte[] bytes) {\n+        try {\n+            InputStream is = new ByteArrayInputStream(bytes);\n+            ObjectInputStream ois = new ObjectInputStream(is);\n+            System.out.println(\"  filter in effect: \" + ois.getObjectInputFilter());\n+            return ois.readObject();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new UncheckedIOException(new InvalidClassException(cnfe.getMessage()));\n+        }\n+    }\n+\n+\n+    \/**\n+     * ObjectInputFilter utilities to create filters that combine the results of other filters.\n+     *\/\n+    public static final class Filters {\n+        \/**\n+         * Returns a filter that allows a class if a predicate on the class returns true.\n+         * <p>\n+         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+         * the result is:\n+         * <ul>\n+         *     <li>{@link Status#ALLOWED}, if the predicate on the class returns {@code true}, <\/li>\n+         *     <li>Otherwise, return {@code otherStatus}<\/li>\n+         * <\/ul>\n+         * <p>\n+         * Example, to create a filter that will allow any class loaded from the platform classloader.\n+         * <pre><code>\n+         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader());\n+         * <\/code><\/pre>\n+         *\n+         * @param predicate a predicate to map a class to a boolean\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return {@link Status#ALLOWED} if the predicate on the class returns true\n+         *\/\n+        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new PredicateFilter(predicate, ALLOWED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that rejects a class if a predicate on the class returns true.\n+         * <p>\n+         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+         * the result is:\n+         * <ul>\n+         *     <li>{@link Status#REJECTED}, if the predicate on the class returns {@code true}, <\/li>\n+         *     <li>Otherwise, return {@code otherStatus}<\/li>\n+         * <\/ul>\n+         * <p>\n+         * Example, to create a filter that will reject any class loaded from the application classloader.\n+         * <pre><code>\n+         *     ObjectInputFilter f = rejectFilter(cl -> cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader());\n+         * <\/code><\/pre>\n+         *\n+         * @param predicate a predicate to map a class to a boolean\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return {@link Status#REJECTED} if the predicate on the class returns true\n+         *\/\n+        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new PredicateFilter(predicate, REJECTED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns the result of combining a filter and another filter.\n+         * If the filter is null, the other filter is returned.\n+         * If the other filter is null, the filter is returned.\n+         * Otherwise, a new filter is returned wrapping the pair of non-null filters.\n+         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+         * the result is:\n+         * <ul>\n+         *     <li>{@link Status#REJECTED}, if either filter returns {@link Status#REJECTED}, <\/li>\n+         *     <li>Otherwise, {@link Status#ALLOWED}, if either filter returned {@link Status#ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter      a filter to invoke first, may be null\n+         * @param otherFilter another filter to be checked after this filter, may be null\n+         * @return an {@link ObjectInputFilter} that returns the result of combining this filter and another filter\n+         *\/\n+        public static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter otherFilter) {\n+            if (filter == null)\n+                return otherFilter;\n+            return (otherFilter == null) ? filter :\n+                    new MergeFilter(filter, otherFilter);\n+        }\n+\n+        \/**\n+         * Returns a filter that merges the status of a list of filters.\n+         * <p>\n+         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+         * the result is:\n+         * <ul>\n+         *     <li>{@link Status#UNDECIDED}, if the serialClass is null,<\/li>\n+         *     <li>Otherwize, {@link Status#REJECTED}, if any filter returns {@link Status#REJECTED}, <\/li>\n+         *     <li>Otherwise, {@link Status#ALLOWED}, if any filter returns {@link Status#ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@code otherStatus}<\/li>\n+         * <\/ul>\n+         *\n+         * @param filters a List of filters evaluate\n+         * @param otherStatus the status to returned if none produce REJECTED or ALLOWED\n+         * @return an {@link ObjectInputFilter}\n+         *\/\n+        public static ObjectInputFilter mergeOrUndecided(List<ObjectInputFilter> filters,\n+                                                         Status otherStatus) {\n+            return new MergeManyFilter(filters, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns the complement of the status of invoking the filter.\n+         * <p>\n+         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+         * the result is:\n+         * <ul>\n+         *     <li>{@link Status#REJECTED}, if this filter returns {@link Status#ALLOWED}, <\/li>\n+         *     <li>{@link Status#ALLOWED}, if this filter  {@link Status#REJECTED}, <\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter a filter to wrap and complement its status\n+         * @return an {@link ObjectInputFilter}\n+         *\/\n+        public static ObjectInputFilter not(ObjectInputFilter filter) {\n+            return new NotFilter(Objects.requireNonNull(filter, \"filter\"));\n+        }\n+\n+        \/**\n+         * Returns a filter that returns REJECTED if the a filter returns UNDECIDED.\n+         * Object serialization accepts a class if the filter returns UNDECIDED or ALLOWED.\n+         * Appending a filter to reject undefined results for classes that have not been\n+         * either allowed or rejected can prevent classes from slipping through the filter.\n+         *\n+         * <p>\n+         * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+         * the result is:\n+         * <ul>\n+         *     <li>{@link Status#ALLOWED}, if this filter  {@link Status#ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@link Status#REJECTED}<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter a filter to map the UNDECIDED status to REJECTED\n+         * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n+         * status to {@link Status#REJECTED}\n+         *\/\n+        public static ObjectInputFilter rejectUndecided(ObjectInputFilter filter) {\n+            return new RejectUndecided(Objects.requireNonNull(filter, \"filter\"));\n+        }\n+\n+        \/**\n+         * Returns a filter that allows a class only if the class was loaded by the platform class loader.\n+         * Otherwise, it returns UNDECIDED; leaving the choice to another filter.\n+         * @return a filter that allows a class only if the class was loaded by the platform class loader\n+         *\/\n+        public static ObjectInputFilter allowPlatformClasses() {\n+            return new AllowPlatformClassFilter();\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate a predicate mapping a class to a boolean.\n+         *\/\n+        private static class PredicateFilter implements ObjectInputFilter {\n+            private final Predicate<Class<?>> predicate;\n+            private final Status ifTrueStatus;\n+            private final Status ifFalseStatus;\n+\n+            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus, Status ifFalseStatus) {\n+                this.predicate = predicate;\n+                this.ifTrueStatus = ifTrueStatus;\n+                this.ifFalseStatus = ifFalseStatus;\n+            }\n+\n+            \/**\n+             * Apply the predicate to the class being deserialized, if the class is non-null\n+             * and if it returns {@code true}, return the requested status. Otherwise, return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of applying the predicate, otherwise {@code UNDECIDED}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                return (info.serialClass() != null &&\n+                        predicate.test(info.serialClass())) ? ifTrueStatus : ifFalseStatus;\n+            }\n+\n+            public String toString() {\n+                return \"predicate(\" + predicate + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the results of two filters.\n+         *\/\n+        private static class MergeFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter first;\n+            private final ObjectInputFilter second;\n+\n+            MergeFilter(ObjectInputFilter first, ObjectInputFilter second) {\n+                this.first = Objects.requireNonNull(first, \"first\");\n+                this.second = Objects.requireNonNull(second, \"second\");\n+            }\n+\n+            \/**\n+             * Returns REJECTED if either of the filters returns REJECTED,\n+             * and ALLOWED if any of the filters returns ALLOWED.\n+             * Returns UNDECIDED if there is no class to be checked or all filters return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return Status.REJECTED if either of the filters returns REJECTED,\n+             * and ALLOWED if either filter returns ALLOWED; otherwise returns\n+             * UNDECIDED if there is no class to check or both filters returned UNDECIDED\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                if (info.serialClass() == null) return UNDECIDED;\n+                Status firstStatus = Objects.requireNonNull(first.checkInput(info), \"status\");\n+                if (REJECTED.equals(firstStatus)) {\n+                    return REJECTED;\n+                }\n+                Status secondStatus = Objects.requireNonNull(second.checkInput(info), \"other status\");\n+                if (REJECTED.equals(secondStatus)) {\n+                    return REJECTED;\n+                }\n+                if (ALLOWED.equals(firstStatus) || ALLOWED.equals(secondStatus)) {\n+                    return ALLOWED;\n+                }\n+                return UNDECIDED;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"merge(\" + first + \", \" + second + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the results of two filters.\n+         *\/\n+        private static class MergeManyFilter implements ObjectInputFilter {\n+            private final List<ObjectInputFilter> filters;\n+            private final Status otherStatus;\n+\n+            MergeManyFilter(List<ObjectInputFilter> first, Status otherStatus) {\n+                this.filters = Objects.requireNonNull(first, \"filters\");\n+                this.otherStatus = Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            }\n+\n+            \/**\n+             * Returns REJECTED if any of the filters returns REJECTED,\n+             * and ALLOWED if any of the filters returns ALLOWED.\n+             * Returns UNDECIDED if there is no class to be checked or all filters return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return Status.UNDECIDED if there is no class to check,\n+             *      Status.REJECTED if any of the filters returns REJECTED,\n+             *      Status.ALLOWED if any filter returns ALLOWED;\n+             *      otherwise returns {@code otherStatus}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                if (info.serialClass() == null)\n+                    return UNDECIDED;\n+                Status status = otherStatus;\n+                for (ObjectInputFilter filter : filters) {\n+                    Status aStatus = filter.checkInput(info);\n+                    if (REJECTED.equals(aStatus)) {\n+                        return REJECTED;\n+                    }\n+                    if (ALLOWED.equals(aStatus)) {\n+                        status = ALLOWED;\n+                    }\n+                }\n+                return status;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"mergeManyFilter(\" + filters + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that combines the results of two filters.\n+         *\/\n+        private static class NotFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter other;\n+\n+            NotFilter(ObjectInputFilter filter) {\n+                this.other = filter;\n+            }\n+\n+            \/**\n+             * Returns the complement of the result of the filter.\n+             * When used as an ObjectInputFilter by invoking the {@link ObjectInputFilter#checkInput} method,\n+             * the result is:\n+             * <ul>\n+             *     <li>REJECTED, if the other filter returns {@link Status#ALLOWED}, <\/li>\n+             *     <li>ALLOWED, if the other filter returns {@link Status#REJECTED}, <\/li>\n+             *     <li>Otherwise, return {@link Status#UNDECIDED}<\/li>\n+             * <\/ul>\n+             *\n+             * @param info the FilterInfo\n+             * @return\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status status = Objects.requireNonNull(other.checkInput(info), \"status\");\n+                if (ALLOWED.equals(status)) return REJECTED;\n+                if (REJECTED.equals(status)) return ALLOWED;\n+                return UNDECIDED;\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that rejects a class if the other filter returned UNDECIDED.\n+         *\/\n+        private static class RejectUndecided implements ObjectInputFilter {\n+            private final ObjectInputFilter filter;\n+\n+            private RejectUndecided(ObjectInputFilter filter) {\n+                this.filter = Objects.requireNonNull(filter, \"filter\");\n+            }\n+\n+            \/**\n+             * Apply the filter and return the status if ALLOWED, otherwise REJECTED.\n+             * The effect is to map UNDECIDED to REJECTED, and otherwise return the status.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of applying the filter if ALLOWED, otherwise REJECTED\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status status = Objects.requireNonNull(filter.checkInput(info), \"status\");\n+                return ALLOWED.equals(status) ? ObjectInputFilter.Status.ALLOWED : REJECTED;\n+            }\n+\n+            public String toString() {\n+                return \"rejectUndecided(\" + filter.toString() + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that allows a class only if the class was loaded by the platform class loader.\n+         * Otherwise, it returns undecided; leaving the choice to another filter.\n+         *\/\n+        private static class AllowPlatformClassFilter implements ObjectInputFilter {\n+\n+            \/**\n+             * Returns ALLOWED only if the class, if non-null, was loaded by the platformClassLoader.\n+             *\n+             * @param filter the FilterInfo\n+             * @return Status.ALLOWED only if the class loader of the class was the PlatformClassLoader;\n+             * otherwise Status.UNDECIDED\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo filter) {\n+                final Class<?> serialClass = filter.serialClass();\n+                return (serialClass != null &&\n+                        (serialClass.getClassLoader() == null ||\n+                        ClassLoader.getPlatformClassLoader().equals(serialClass.getClassLoader())))\n+                        ? ObjectInputFilter.Status.ALLOWED\n+                        : ObjectInputFilter.Status.UNDECIDED;\n+            }\n+\n+            public String toString() {\n+                return \"allowPlatformClasses\";\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * FilterInfo instance with a specific class.\n+     *\/\n+    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+        private final Class<?> clazz;\n+\n+        SerialInfo(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        @Override\n+        public Class<?> serialClass() {\n+            return clazz;\n+        }\n+\n+        @Override\n+        public long arrayLength() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long depth() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long references() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long streamBytes() {\n+            return 0;\n+        }\n+    }\n+\n+    \/**\n+     * A test class.\n+     *\/\n+    static record Point(int x, int y) implements Serializable {\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":789,"deletions":0,"binary":false,"changes":789,"status":"added"},{"patch":"@@ -0,0 +1,501 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.Config;\n+import java.io.ObjectInputFilter.FilterInfo;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serial;\n+import java.io.Serializable;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Predicate;\n+\n+import static java.io.ObjectInputFilter.Status;\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n+\n+\/* @test\n+ * @build SerialFilterFactoryTest\n+ * @run testng\/othervm  SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilter=\"*\" SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$PropertyFilterFactory SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$NotMyFilterFactory SerialFilterFactoryTest\n+ *\n+ * @summary Test Context-specific Deserialization Filters\n+ *\/\n+@Test\n+public class SerialFilterFactoryTest {\n+\n+    \/\/ A stream with just the header, enough to create a OIS\n+    private static final byte[] simpleStream = simpleStream();\n+    private static final Validator v1 = new Validator(\"v1\");\n+    private static final Validator v2 = new Validator(\"v2\");\n+    private static final BinaryOperator<ObjectInputFilter> jdkSerialFilterFactory\n+            = Config.getSerialFilterFactory();\n+    private static final MyFilterFactory contextFilterFactory = new MyFilterFactory(\"DynFF\");\n+    private static final String jdkSerialFilterFactoryProp = System.getProperty(\"jdk.serialFilterFactory\");\n+\n+    \/**\n+     * Return a byte array with a simple stream containing an Dummy object.\n+     * @return  a byte with a simple serialization object\n+     *\/\n+    private static byte[] simpleStream() {\n+        ByteArrayOutputStream boas = new ByteArrayOutputStream();\n+        try (ObjectOutputStream ois = new ObjectOutputStream(boas)) {\n+            ois.writeObject(new Dummy(\"Here\"));\n+            return boas.toByteArray();\n+        } catch (IOException ioe) {\n+            Assert.fail(\"unexpected IOE\", ioe);\n+        }\n+        throw new RuntimeException(\"should not reach here\");\n+    }\n+\n+    \/**\n+     * Initialize the filter factory, supplying one if not already set.\n+     * Does not\/can not replace any MyFilterFactory.\n+     *\n+     * @param dynFilterFactory a filter factory to use if not already set\n+     * @return the filter factory in effect\n+     *\/\n+    private static MyFilterFactory setupFilterFactory(MyFilterFactory dynFilterFactory) {\n+        if ((Config.getSerialFilterFactory() instanceof MyFilterFactory ff))\n+            return ff;\n+        Config.setSerialFilterFactory(dynFilterFactory);\n+        return dynFilterFactory;\n+    }\n+\n+    \/\/ If the configured filter has not been set, set it\n+    \/\/ It can only be set once for the process, so avoid setting it again\n+    private static ObjectInputFilter setupFilter(ObjectInputFilter serialFilter) {\n+\n+        var configFilter = Config.getSerialFilter();\n+        if (configFilter == serialFilter || configFilter instanceof Validator)\n+            return configFilter;        \/\/ if already set or a type we can use, no change\n+\n+        if (configFilter == null && serialFilter != null) {\n+            Config.setSerialFilter(serialFilter);\n+            return serialFilter;        \/\/ none set already, set it\n+        }\n+\n+        return configFilter;\n+    }\n+\n+    private static boolean isValidFilterFactory() {\n+        return !(ObjectInputFilter.Config.getSerialFilterFactory() instanceof NotMyFilterFactory);\n+    }\n+\n+    @DataProvider(name=\"FilterCases\")\n+    static Object[][] filterCases() {\n+        if (isValidFilterFactory()) {\n+            return new Object[][]{\n+                    {contextFilterFactory, null, null},  \/\/ no overrides\n+                    {contextFilterFactory, v1, null},    \/\/ context filter\n+                    {contextFilterFactory, v1, v2},      \/\/ per stream filter\n+            };\n+        } else {\n+            \/\/ There are zero cases to run with an unknown filter factory. (NotMyFilterFactory)\n+            return new Object[0][0];\n+        }\n+    }\n+\n+    \/\/ Setting the filter factory to null is not allowed.\n+    @Test(expectedExceptions=NullPointerException.class)\n+    static void testNull() {\n+        Config.setSerialFilterFactory(null);\n+    }\n+\n+    \/**\n+     * Setting and resetting the filter factory is not allowed.\n+     * The filter factory may have been on the command line (depending on which @run this is).\n+     * If the jdk.SerialFilterFactory is the built-in filter factory, set it once.\n+     * Try to set it again, the second should throw.\n+     *\/\n+    @Test\n+    static void testSecondSetShouldThrow() {\n+        var currFF = Config.getSerialFilterFactory();\n+        if (currFF.getClass().getClassLoader() == null) {\n+            try {\n+                \/\/ Not already set, set it\n+                Config.setSerialFilterFactory(contextFilterFactory);\n+                currFF = contextFilterFactory;\n+            } catch (IllegalStateException ise) {\n+                Assert.fail(\"First setSerialFilterFactory should not throw\");\n+            }\n+        }\n+        \/\/ Setting it again will throw\n+        Assert.expectThrows(IllegalStateException.class,\n+                () -> Config.setSerialFilterFactory(new MyFilterFactory(\"f11\")));\n+        var resetFF = Config.getSerialFilterFactory();\n+        Assert.assertEquals(resetFF, currFF, \"Setting again should not change filter factory\");\n+    }\n+\n+    \/**\n+     * Test that the filter factory is set when expected and is called when expected.\n+     * This test only covers the cases when a filter factory is supplied\n+     * either via a command line property or via the API.\n+     * The cases where the builtin filter factory applies are tested in SerialFilterTest.\n+     *\n+     * @param dynFilterFactory a FilterFactory to set\n+     * @param dynFilter a serial filter to be used for the configured filter\n+     * @param streamFilter a serial filter to be used for the stream filter\n+     * @throws IOException if an I\/O error occurs (should not occur)\n+     * @throws ClassNotFoundException for class not found (should not occur)\n+     *\/\n+    @Test(dataProvider=\"FilterCases\")\n+    static void testCase(MyFilterFactory dynFilterFactory, Validator dynFilter, Validator streamFilter)\n+                throws IOException, ClassNotFoundException {\n+\n+        \/\/ Set the Filter Factory and System-wide filter\n+        final ObjectInputFilter configFilter = setupFilter(dynFilter);\n+        final MyFilterFactory factory = setupFilterFactory(dynFilterFactory);\n+        factory.reset();\n+\n+        InputStream is = new ByteArrayInputStream(simpleStream);\n+        ObjectInputStream ois = new ObjectInputStream(is);\n+\n+        Assert.assertNull(factory.current(), \"initially current should be null\");\n+        Assert.assertEquals(factory.next(), configFilter, \"initially next should be the configured filter\");\n+        var currFilter = ois.getObjectInputFilter();\n+        if (currFilter != null && currFilter.getClass().getClassLoader() == null) {\n+            \/\/ Builtin loader;  defaults to configured filter\n+            Assert.assertEquals(currFilter, configFilter, \"getObjectInputFilter should be configured filter\");\n+        } else {\n+            Assert.assertEquals(currFilter, configFilter, \"getObjectInputFilter should be null\");\n+        }\n+        if (streamFilter != null) {\n+            ois.setObjectInputFilter(streamFilter);\n+            \/\/ MyFilterFactory is called when the stream filter is changed; verify values passed it\n+            Assert.assertEquals(factory.current(), currFilter, \"when setObjectInputFilter, current should be current filter\");\n+            Assert.assertEquals(factory.next(), streamFilter, \"next should be stream specific filter\");\n+\n+            \/\/ Check the OIS filter after the factory has updated it.\n+            currFilter = ois.getObjectInputFilter();\n+            Assert.assertEquals(currFilter, streamFilter, \"getObjectInputFilter should be set\");\n+        }\n+        if (currFilter instanceof Validator validator) {\n+            validator.reset();\n+            Object o = ois.readObject();       \/\/ Invoke only for the side effect of calling the Filter\n+            Assert.assertEquals(validator.count, 1, \"Wrong number of calls to the stream filter\");\n+        } else {\n+            Object o = ois.readObject();       \/\/ Invoke only for the side effect of calling the filter\n+        }\n+    }\n+\n+    @Test\n+    void testAndThen() {\n+        Status[] cases = Status.values();\n+        FilterInfo info = new SerialInfo(Object.class);\n+        for (Status st1 : cases) {\n+            for (Status st2 : cases) {\n+                ObjectInputFilter f = getFilter(st1).merge(getFilter(st2));\n+                Status r = f.checkInput(info);\n+                Assert.assertEquals(evalAndThen(st1, st2), r, \"eval andThen\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED.\n+     * @param status a status\n+     * @param otherStatus another status\n+     * @return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED\n+     *\/\n+    private Status evalAndThen(Status status, Status otherStatus) {\n+        if (REJECTED.equals(status) || REJECTED.equals(otherStatus))\n+            return REJECTED;\n+\n+        if (ALLOWED.equals(status)  || ALLOWED.equals(otherStatus))\n+            return ALLOWED;\n+\n+        return UNDECIDED;\n+    }\n+\n+    \/**\n+     * Return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class.\n+     * @return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class\n+     *\/\n+    static Predicate<Class<?>> isInteger() {\n+        return (cl) -> cl.equals(Integer.class);\n+    }\n+\n+    @DataProvider(name = \"AllowPredicateCases\")\n+    static Object[][] allowPredicateCases() {\n+        return new Object[][]{\n+                { Integer.class, isInteger(), Status.ALLOWED},\n+                { Double.class, isInteger(), Status.UNDECIDED},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"AllowPredicateCases\")\n+    void testAllowPredicates(Class<?> clazz,\n+                        Predicate<Class<?>> predicate, Status expected) {\n+        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+        Assert.assertEquals(Config.allowFilter(predicate, Status.UNDECIDED).checkInput(info), expected, \"Predicate result\");\n+    }\n+\n+    @DataProvider(name = \"RejectPredicateCases\")\n+    static Object[][] rejectPredicateCases() {\n+        return new Object[][]{\n+                { Integer.class, isInteger(), REJECTED},\n+                { Double.class, isInteger(), Status.UNDECIDED},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"RejectPredicateCases\")\n+    void testRejectPredicates(Class<?> clazz,\n+                              Predicate<Class<?>> predicate, Status expected) {\n+        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+        Assert.assertEquals(Config.rejectFilter(predicate, Status.UNDECIDED).checkInput(info), expected, \"Predicate result\");\n+    }\n+\n+\n+    @Test\n+    static void testRejectUndecided() {\n+        FilterInfo info = new SerialInfo(Object.class); \/\/ an info structure, unused\n+\n+        ObjectInputFilter undecided = getFilter(UNDECIDED);\n+        Assert.assertEquals(undecided.rejectUndecidedClass().checkInput(info), REJECTED, \"undecided -> rejected\");\n+        ObjectInputFilter allowed = getFilter(ALLOWED);\n+        Assert.assertEquals(allowed.rejectUndecidedClass().checkInput(info), ALLOWED, \"allowed -> rejected\");\n+        ObjectInputFilter rejected = getFilter(REJECTED);\n+        Assert.assertEquals(rejected.rejectUndecidedClass().checkInput(info), REJECTED, \"rejected -> rejected\");\n+    }\n+\n+    @Test\n+    static void testMaxLimits() {\n+        FilterInfo info = new SerialInfo(null); \/\/ an info structure, serialClass == null\n+        Assert.assertEquals(Config.allowMaxLimits().checkInput(info), ALLOWED, \"allowMaxLimit\");\n+\n+        info = new SerialInfo(Object.class); \/\/ an info structure, serialClass != null\n+        Assert.assertEquals(Config.allowMaxLimits().checkInput(info), UNDECIDED, \"allowMaxLimit\");\n+    }\n+\n+    \/\/ Test that if the property jdk-serialFilterFactory is set, then initial factory has the same classname\n+    @Test\n+    static void testPropertyFilterFactory() {\n+        if (jdkSerialFilterFactoryProp != null) {\n+            Assert.assertEquals(jdkSerialFilterFactory.getClass().getName(), jdkSerialFilterFactoryProp,\n+                    \"jdk.serialFilterFactory property classname mismatch\");\n+        }\n+    }\n+\n+    \/**\n+     * Returns an ObjectInputFilter that returns the requested Status.\n+     * @param status a Status, may be null\n+     * @return  an ObjectInputFilter that returns the requested Status\n+     *\/\n+    private static ObjectInputFilter getFilter(ObjectInputFilter.Status status) {\n+        return (info) -> status;\n+    }\n+\n+    \/**\n+     * A simple filter factory that retains its arguments.\n+     *\/\n+    private static class MyFilterFactory\n+            implements BinaryOperator<ObjectInputFilter> {\n+        private final String name;\n+        private ObjectInputFilter current;\n+        private ObjectInputFilter next;\n+\n+        MyFilterFactory(String name) {\n+            this.name = name;\n+            current = new Validator(\"UnsetCurrent\");\n+            next = new Validator(\"UnsetNext\");\n+        }\n+\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            this.current = curr;\n+            this.next = next;\n+            if (curr == null & next == null)\n+                return Config.getSerialFilter();    \/\/ Default to the configured filter\n+            return next;\n+        }\n+\n+        public void  reset() {\n+            current = new Validator(\"UnsetCurrent\");\n+            next = new Validator(\"UnsetNext\");\n+        }\n+\n+        public ObjectInputFilter current() {\n+            return current;\n+        }\n+\n+        public ObjectInputFilter next() {\n+            return next;\n+        }\n+\n+        public void current(ObjectInputFilter current) {\n+            this.current = current;\n+        }\n+\n+        public void next(ObjectInputFilter next) {\n+            this. next = next;\n+        }\n+\n+        public String toString() {\n+            return name + \":: curr: \" + current + \", next: \" + next;\n+        }\n+    }\n+\n+    \/**\n+     * A subclass of MyFilterFactory with a name, used when testing setting the factory using\n+     * -Djdk.setFilterFactory.\n+     *\/\n+    public static class PropertyFilterFactory extends MyFilterFactory {\n+        public PropertyFilterFactory() {\n+            super(\"UNNAMED\");\n+        }\n+    }\n+\n+    \/**\n+     * A filter factory that is not compatible with MyFilterFactory test.\n+     * Used for testing incorrect initialization.\n+     *\/\n+    public static class NotMyFilterFactory\n+            implements BinaryOperator<ObjectInputFilter> {\n+\n+        public NotMyFilterFactory() {}\n+\n+        \/**\n+         * Returns null as the filter to be used for an ObjectInputStream.\n+         *\n+         * @param curr the current filter, if any\n+         * @param next the next filter, if any\n+         * @return null\n+         *\/\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * A filter that accumulates information about the checkInput callbacks\n+     * that can be checked after readObject completes.\n+     *\/\n+    static class Validator implements ObjectInputFilter {\n+        private final String name;\n+        long count;          \/\/ Count of calls to checkInput\n+\n+        Validator(String name) {\n+            this.name = name;\n+            count = 0;\n+        }\n+\n+        void reset() {\n+            count = 0;\n+        }\n+\n+        @Override\n+        public Status checkInput(FilterInfo filter) {\n+            count++;\n+            return Status.ALLOWED;\n+        }\n+\n+        public String toString(){\n+            return name + \": count: \" + count;\n+        }\n+    }\n+\n+    \/**\n+     * A simple class to serialize.\n+     *\/\n+    private static final class Dummy implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = 1L;\n+        final String s;\n+        Dummy(String s) {\n+            this.s = s;\n+        }\n+        public String toString() {\n+            return this.getClass().getName() + \"::\" + s;\n+        }\n+    }\n+\n+    \/**\n+     * FilterInfo instance with a specific class.\n+     *\/\n+    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+        private final Class<?> clazz;\n+\n+        SerialInfo(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        @Override\n+        public Class<?> serialClass() {\n+            return clazz;\n+        }\n+\n+        @Override\n+        public long arrayLength() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long depth() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long references() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long streamBytes() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return showFilterInfo(this);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Return a string describing a FilterInfo instance.\n+     * @param info a FilterInfo instance\n+     * @return a String describing the FilterInfo instance\n+     *\/\n+    static String showFilterInfo(ObjectInputFilter.FilterInfo info) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"serialClass: \" + info.serialClass());\n+        sb.append(\", arrayLength: \" + info.arrayLength());\n+        sb.append(\", depth: \" + info.depth());\n+        sb.append(\", references: \" + info.references());\n+        sb.append(\", streamBytes: \" + info.streamBytes());\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFactoryTest.java","additions":501,"deletions":0,"binary":false,"changes":501,"status":"added"},{"patch":"@@ -55,2 +55,2 @@\n- * @run testng\/othervm  SerialFilterTest\n- * @run testng\/othervm  -Djdk.serialSetFilterAfterRead=true SerialFilterTest\n+ * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFilterTest\n+ * @run testng\/othervm -Djdk.serialSetFilterAfterRead=true -Djdk.serialFilterTrace=true SerialFilterTest\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}