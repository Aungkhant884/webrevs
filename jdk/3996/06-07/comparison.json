{"files":[{"patch":"@@ -65,2 +65,14 @@\n- * <p>For simple cases, a static filter can be {@linkplain Config#setSerialFilter(ObjectInputFilter) set}\n- * for the entire application.\n+ * <h2>Deserialization Filtering Factory and Filters<\/h2>\n+ * The parts of deserialization filtering are the filters, composite filters, and the filter factory.\n+ * Each filter performs checks on classes and resource limits and decides whether to\n+ * reject, allow, or undecided the class or resource.\n+ * Filters can be composed of other filters and merge or combine their results.\n+ * The filter factory is responsible for establishing and updating the filter\n+ * for each {@link ObjectInputStream}.\n+ *\n+ * <p>For simple cases, a static JVM-wide filter can be set for the entire application.\n+ * It can be set either with a system property on the command line or by\n+ * calling {@linkplain Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}.\n+ * In this simple case, the {@linkplain Config#getSerialFilterFactory() JVM-wide filter factory}\n+ * is the builtin filter factory; it provides the {@linkplain Config#getSerialFilter static JVM-wide filter}\n+ * for each {@linkplain ObjectInputStream ObjectInputStream}.\n@@ -70,1 +82,4 @@\n- * <pre>{@code\n+ * <pre>{@code As a command line property:\n+ *     % java -Djdk.serialFilter=\"example.*;java.base\/*;!*\" ...}<\/pre>\n+ * Or\n+ * <pre>{@code Programmatically:\n@@ -72,2 +87,1 @@\n- *     ObjectInputFilter.Config.setSerialFilter(filter);\n- * }<\/pre>\n+ *     ObjectInputFilter.Config.setSerialFilter(filter);}<\/pre>\n@@ -78,2 +92,2 @@\n- * is constructed, the filter factory can identify the execution context on the available\n- * information, for example, the current thread-local state, hierarchy of callers, library, module,\n+ * is constructed, the filter factory can identify the execution context from the available\n+ * information, including the current thread-local state, hierarchy of callers, library, module,\n@@ -82,0 +96,3 @@\n+ * The JVM-wide deserialization filter factory ensures that a context-specific deserialization\n+ * filter can be set on every {@link ObjectInputStream} and every object read from the\n+ * stream can be checked.\n@@ -83,4 +100,19 @@\n- * <p>The JVM-wide deserialization filter factory ensures that a deserialization filter can be set\n- * on every {@link ObjectInputStream} and every object read from the stream can be checked.\n- * <p>\n- * The deserialization filter factory either:\n+ * <h2>Invoking the Filter Factory<\/h2>\n+ * <p>The JVM-wide filter factory is a function invoked when each {@link ObjectInputStream}\n+ * {@linkplain ObjectInputStream#ObjectInputStream() is constructed} and when the\n+ * {@linkplain ObjectInputStream#setObjectInputFilter(ObjectInputFilter) stream-specific filter is set}.\n+ * The parameters are the current filter and a requested filter and it\n+ * returns the filter to be used for the stream. When invoked from the\n+ * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors},\n+ * the first parameter is {@code null} and the second parameter is the\n+ * {@linkplain ObjectInputFilter.Config#getSerialFilter() static JVM-wide filter}.\n+ * When invoked from {@link ObjectInputStream#setObjectInputFilter ObjectInputStream.setObjectInputFilter},\n+ * the first parameter is the filter currently set on the stream (which may have been set in the constructor,\n+ * or by a previous invocation of {@code ObjectInputStream.setObjectInputFilter},\n+ * and the second parameter is the filter given to {@code ObjectInputStream.setObjectInputFilter}.\n+ * The current and new filter may each be {@code null} and the factory may return {@code null}.\n+ * Note that the filter factory implementation can also use any contextual information\n+ * at its disposal, for example, extracted from the application thread context, or its call stack,\n+ * to compose and combine a new filter. It is not restricted to only use its two parameters.\n+ *\n+ * <p>The active deserialization filter factory is either:\n@@ -88,1 +120,1 @@\n- * <li>The filter factory can be set via {@link Config#setSerialFilterFactory(BinaryOperator)}\n+ * <li>The application specific filter factory set via {@link Config#setSerialFilterFactory(BinaryOperator)}\n@@ -91,1 +123,1 @@\n- *     The filter factory is invoked for each new ObjectInputStream and\n+ *     The filter factory is invoked for each new {@link ObjectInputStream} and\n@@ -93,2 +125,0 @@\n- *     The filter factory determines the filter to be used for each stream based\n- *     on its inputs, thread context, other filters, or state that is available.\n@@ -98,1 +128,1 @@\n- *     and replaces the static filter when invoked from\n+ *     and replaces the static filter and when invoked from\n@@ -102,4 +132,6 @@\n- * <p>The filter factory determines the filter for each stream when the stream is\n- * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) constructed} and when\n- * a stream-specific filter is set via {@link ObjectInputStream#setObjectInputFilter setObjectInputFilter}.\n- * Note that the filter may be used directly or combined with other filters by the filter factory.\n+ *\n+ * <h2>Filters<\/h2>\n+ * Filters can be created from a {@linkplain Config#createFilter(String) pattern string},\n+ * or to {@linkplain #allowFilter(Predicate, Status) allow} or\n+ * {@linkplain #rejectFilter(Predicate, Status) reject} classes based on a\n+ * {@linkplain Predicate predicate of a class}.\n@@ -112,0 +144,7 @@\n+ *\n+ * <p>Composite filters combine or check the results of other filters.\n+ * The {@link #merge(ObjectInputFilter, ObjectInputFilter) merge(filter, anotherFilter)}\n+ * filter combines the status value of two filters.\n+ * The {@link #rejectUndecidedClass(ObjectInputFilter) rejectUndecidedClass(filter)}\n+ * checks the result of a filter for classes when the status is {@code UNDECIDED}.\n+ * In many cases any class not {@code ALLOWED} by the filter should be {@code REJECTED}.\n@@ -117,1 +156,1 @@\n- * A filter designed for a particular use may be passed a class that is outside\n+ * A filter designed for a particular use may be passed a class outside\n@@ -146,0 +185,1 @@\n+ *\n@@ -148,1 +188,2 @@\n- * This class shows how to filter every deserialization operation that takes place in a thread.\n+ * This class shows how an application provided filter factory can combine filters\n+ * to filter every deserialization operation that takes place in a thread.\n@@ -152,1 +193,1 @@\n- * and invokes a Runnable.\n+ * and invokes the application provided {@link Runnable Runnable}.\n@@ -157,1 +198,1 @@\n- *     private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new InheritableThreadLocal<>();\n+ *     private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new ThreadLocal<>();\n@@ -167,1 +208,0 @@\n- *             \/\/ Prepend next to the threadFilter, both may be null or non-null\n@@ -171,1 +211,1 @@\n- *                 filter = filter.rejectUndecidedClass();\n+ *                 filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n@@ -175,1 +215,1 @@\n- *                 \/\/ Initially this would be the static JVM-wide filter passed from the OIS constructor\n+ *                 \/\/ Initially this is the static JVM-wide filter passed from the OIS constructor\n@@ -177,1 +217,2 @@\n- *                 filter = next.merge(filter).rejectUndecidedClass();\n+ *                 filter = ObjectInputFilter.Config.merge(next, filter);\n+ *                 filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n@@ -184,2 +225,7 @@\n- *             \/\/ Use the current filter or prepend the stream-specific filter and recheck for undecided\n- *             return (next == null) ? curr : next.merge(curr).rejectUndecidedClass();\n+ *             \/\/ If there is a stream-specific filter prepend it and a filter to recheck for undecided\n+ *             if (next != null) {\n+ *                 next = ObjectInputFilter.Config.merge(next, curr);\n+ *                 next = ObjectInputFilter.Config.rejectUndecidedClass(next);\n+ *                 return next;\n+ *             }\n+ *             return curr;\n@@ -240,1 +286,1 @@\n-     * @apiNote Each filter implementation of {@code checkInput} should return one of the values of {@link Status}.\n+     * @apiNote Each filter implementing {@code checkInput} should return one of the values of {@link Status}.\n@@ -251,0 +297,134 @@\n+    \/**\n+     * Returns a filter that returns {@code Status.ALLOWED} if the predicate\n+     * on the class is {@code true}.\n+     * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+     * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+     *\n+     * <p>When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+     * the predicate is applied to the {@link FilterInfo#serialClass() info.serialClass()},\n+     * the return Status is:\n+     * <ul>\n+     *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+     *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n+     *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Example, to create a filter that will allow any class loaded from the platform classloader.\n+     * <pre><code>\n+     *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n+     *                                          || cl.getClassLoader() == null, Status.UNDECIDED);\n+     * <\/code><\/pre>\n+     *\n+     * @param predicate a predicate to test a non-null Class, non-null\n+     * @param otherStatus a Status to use if the predicate is {@code false}\n+     * @return a filter that returns {@code ALLOWED} if the predicate\n+     *          on the class is {@code true}\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+        Objects.requireNonNull(predicate, \"predicate\");\n+        Objects.requireNonNull(otherStatus, \"otherStatus\");\n+        return new Config.PredicateFilter(predicate, ALLOWED, otherStatus);\n+    }\n+\n+    \/**\n+     * Returns a filter that returns {@code Status.REJECTED} if the predicate\n+     * on the class is {@code true}.\n+     * The filter returns {@code REJECTED} or the {@code otherStatus} based on the predicate\n+     * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+     *\n+     * When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+     * the predicate is applied to the {@link FilterInfo#serialClass() serialClass()},\n+     * the return Status is:\n+     * <ul>\n+     *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+     *     <li>{@link Status#REJECTED REJECTED}, if the predicate on the class returns {@code true},<\/li>\n+     *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Example, to create a filter that will reject any class loaded from the application classloader.\n+     * <pre><code>\n+     *     ObjectInputFilter f = rejectFilter(cl ->\n+     *          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);\n+     * <\/code><\/pre>\n+     *\n+     * @param predicate a predicate to test a non-null Class, non-null\n+     * @param otherStatus a Status to use if the predicate is {@code false}\n+     * @return returns a filter that returns {@code REJECTED} if the predicate\n+     *          on the class is {@code true}\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+        Objects.requireNonNull(predicate, \"predicate\");\n+        Objects.requireNonNull(otherStatus, \"otherStatus\");\n+        return new Config.PredicateFilter(predicate, REJECTED, otherStatus);\n+    }\n+\n+    \/**\n+     * Returns a filter that merges the status of a filter and another filter.\n+     * If {@code another} filter is {@code null}, the {@code filter} is returned.\n+     * Otherwise, a {@code filter} is returned to merge the pair of {@code non-null} filters.\n+     *\n+     * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n+     * as follows:\n+     * <ul>\n+     *     <li>Invoke {@code filter} on the {@code FilterInfo} to get its {@code status};\n+     *     <li>Return {@code REJECTED} if the {@code status} is {@code REJECTED};\n+     *     <li>Invoke {@code anotherFilter} to get the {@code otherStatus};\n+     *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n+     *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n+     *          is {@code ALLOWED}, <\/li>\n+     *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n+     * <\/ul>\n+     *\n+     * @param filter a filter, non-null\n+     * @param anotherFilter a filter to be merged with the filter, may be {@code null}\n+     * @return an {@link ObjectInputFilter} that merges the status of the filter and another filter\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter) {\n+        Objects.requireNonNull(filter, \"filter\");\n+        return (anotherFilter == null) ? filter : new Config.MergeFilter(filter, anotherFilter);\n+    }\n+\n+    \/**\n+     * Returns a filter that invokes a given filter and maps {@code UNDECIDED} to {@code REJECTED}\n+     * for classes, with some special cases, and otherwise returns the status.\n+     * The filter returned checks that classes not {@code ALLOWED} by the filter\n+     * are {@code REJECTED}.  Either the class is not {@code ALLOWED} or\n+     * if the class is an array and the base component type is not allowed,\n+     * otherwise the result is {@code UNDECIDED}.\n+     * <p>\n+     * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n+     * Adding a filter to reject undecided results for classes that have not been\n+     * either allowed or rejected can prevent classes from slipping through the filter.\n+     *\n+     * @implSpec\n+     * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n+     * as follows:\n+     * <ul>\n+     *     <li>Invoke the filter on the {@code FilterInfo} to get its {@code status};\n+     *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n+     *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n+     *          is {@code null};\n+     *     <li>Determine the base component type if the {@code serialClass} is\n+     *          an {@linkplain Class#isArray() array};\n+     *     <li>Return {@code UNDECIDED} if the base component type is\n+     *          a {@linkplain Class#isPrimitive() primitive class};\n+     *     <li>Invoke the filter on the {@code base component type} to get its\n+     *          {@code component status};<\/li>\n+     *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n+     *     <li>Otherwise, return {@code REJECTED}.<\/li>\n+     * <\/ul>\n+     *\n+     * @param filter a filter, non-null\n+     * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n+     *      status to {@link Status#REJECTED} for classes, otherwise returns the\n+     *      filter status\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter) {\n+        Objects.requireNonNull(filter, \"filter\");\n+        return new Config.RejectUndecidedFilter(filter);\n+    }\n+\n@@ -331,1 +511,1 @@\n-     * the static JVM-wide filter, or to create filters, including creating a filter from a pattern string.\n+     * the static JVM-wide filter, or to create a filter from a pattern string.\n@@ -333,9 +513,2 @@\n-     * or \"JVM-wide\", there is only one of each.\n-     * If a JVM-wide filter factory or static JVM-wide filter is set, it will determine the filter\n-     * to be used for each {@link ObjectInputStream}, and be combined with a\n-     * stream-specific filter, if one is set.\n-     *\n-     * <p>Filters can be created from a {@linkplain Config#createFilter(String) pattern string},\n-     * to {@linkplain #allowFilter(Predicate, Status) allow} or\n-     * {@linkplain #rejectFilter(Predicate, Status) reject} classes based on a\n-     * {@linkplain Predicate predicate of a class}.\n+     * or \"JVM-wide\", there is only one of each, for a complete description of\n+     * the function and use refer to {@link ObjectInputFilter}.\n@@ -343,37 +516,2 @@\n-     * <p>Composite filters combine or check the results of other filters.\n-     * The {@linkplain #merge(ObjectInputFilter, ObjectInputFilter) merge} filter combines\n-     * the status value of two filters.\n-     * The {@linkplain #rejectUndecidedClass(ObjectInputFilter) rejectUndecidedClass(filter)}\n-     * checks the result of a filter for classes when the status is {@code UNDECIDED}.\n-     * In many cases any class not {@code ALLOWED} by the filter should be {@code REJECTED}.\n-     * The {@linkplain #allowMaxLimits() limits allow} filter converts {@code UNDECIDED} to\n-     * {@code ALLOWED} for limit checks that are not {@code REJECTED}.\n-     * <p>\n-     * When each {@link ObjectInputStream#ObjectInputStream() ObjectInputStream}\n-     * is created the {@linkplain Config#getSerialFilterFactory() filter factory}\n-     * is invoked to determine the initial filter for the stream.\n-     * When called from the constructor, the current filter is `null` and the new filter is the\n-     * {@linkplain Config#getSerialFilter() static JVM-wide filter}. The factory determines and\n-     * returns the initial filter for the stream. The factory can create a composite filter\n-     * with other context-specific controls or just return the static filter.\n-     * <p>\n-     * A stream-specific filter can be set with\n-     * {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter) ObjectInputStream.setObjectInputFilter}.\n-     * If {@code ObjectInputStream.setObjectInputFilter} is called, the filter factory is called a second time\n-     * with the stream's initial filter, and the requested new filter.\n-     * The factory determines how to combine the two filters and returns a filter, replacing the filter on the stream.\n-     * <p>\n-     * Setting a {@linkplain #setSerialFilterFactory(BinaryOperator) deserialization filter factory}\n-     * allows the application provided factory to choose a filter for each stream when it is created\n-     * based on the context of the thread and call stack. It may simply return a static filter,\n-     * select a filter, compose a filter from the requested filter and any other filters including\n-     * the {@linkplain #getSerialFilter() static JVM-wide filter}.\n-     * <p>\n-     * If a JVM-wide filter factory is {@linkplain Config#setSerialFilterFactory(BinaryOperator) not set}\n-     * the builtin deserialization filter factory returns the\n-     * {@linkplain Config#getSerialFilter() static JVM-wide filter}.\n-     * <p>\n-     * When setting the filter, it should be stateless and idempotent,\n-     * reporting the same result when passed the same arguments.\n-     * <p>\n-     * The static JVM-wide filter is configured during the initialization of the\n+     * <p>The JVM-wide deserialization filter factory and the static JVM-wide filter\n+     * can be configured from system properties during the initialization of the\n@@ -381,1 +519,2 @@\n-     * If the Java virtual machine is started with the system property\n+     *\n+     * <p>If the Java virtual machine is started with the system property\n@@ -605,1 +744,1 @@\n-         * {plain#getSerialFilter static JVM-wide filter} when invoked from\n+         * {@linkplain #getSerialFilter static JVM-wide filter} when invoked from\n@@ -638,30 +777,29 @@\n-\n-            \/**\n-             * Set the {@linkplain #getSerialFilterFactory() JVM-wide deserialization filter factory}.\n-             * The filter factory can be configured exactly once with one of:\n-             * setting the {@code jdk.serialFilterFactory} property on the command line,\n-             * setting the {@code jdk.serialFilterFactory} property in the {@link java.security.Security}\n-             * file, or using this {@code setSerialFilterFactory} method.\n-             * The filter factory can be set only before any {@link ObjectInputStream} has been\n-             * created to avoid any inconsistency in which filter factory is being used.\n-             *\n-             * <p>The JVM-wide filter factory is invoked when an ObjectInputStream\n-             * {@linkplain ObjectInputStream#ObjectInputStream() is constructed} and when the\n-             * {@linkplain ObjectInputStream#setObjectInputFilter(ObjectInputFilter) stream-specific filter is set}.\n-             * The parameters are the current filter and a requested filter and it\n-             * returns the filter to be used for the stream.\n-             * The current and new filter may each be {@code null} and the factory may return {@code null}.\n-             * The factory determines the filter to be used for {@code ObjectInputStream} streams based\n-             * on its inputs, and any other filters, context, or state that is available.\n-             * The factory may throw runtime exceptions to signal incorrect use or invalid parameters.\n-             * See the {@linkplain ObjectInputFilter filter models} for examples of composition and delegation.\n-             *\n-             * @param filterFactory the deserialization filter factory to set as the\n-             *         JVM-wide filter factory; not null\n-             * @throws IllegalStateException if the builtin deserialization filter factory\n-             *         has already been replaced or any instance of {@link ObjectInputStream}\n-             *         has been created.\n-             * @throws SecurityException if there is security manager and the\n-             *       {@code SerializablePermission(\"serialFilter\")} is not granted\n-             * @since 17\n-             *\/\n+        \/**\n+         * Set the {@linkplain #getSerialFilterFactory() JVM-wide deserialization filter factory}.\n+         * The filter factory can be configured exactly once with one of:\n+         * setting the {@code jdk.serialFilterFactory} property on the command line,\n+         * setting the {@code jdk.serialFilterFactory} property in the {@link java.security.Security}\n+         * file, or using this {@code setSerialFilterFactory} method.\n+         * The filter factory can be set only before any {@link ObjectInputStream} has been\n+         * created to avoid any inconsistency in which filter factory is being used.\n+         *\n+         * <p>The JVM-wide filter factory is invoked when an ObjectInputStream\n+         * {@linkplain ObjectInputStream#ObjectInputStream() is constructed} and when the\n+         * {@linkplain ObjectInputStream#setObjectInputFilter(ObjectInputFilter) stream-specific filter is set}.\n+         * The parameters are the current filter and a requested filter and it\n+         * returns the filter to be used for the stream.\n+         * The current and new filter may each be {@code null} and the factory may return {@code null}.\n+         * The factory determines the filter to be used for {@code ObjectInputStream} streams based\n+         * on its inputs, any other filters, context, or state that is available.\n+         * The factory may throw runtime exceptions to signal incorrect use or invalid parameters.\n+         * See the {@linkplain ObjectInputFilter filter models} for examples of composition and delegation.\n+         *\n+         * @param filterFactory the deserialization filter factory to set as the\n+         *         JVM-wide filter factory; not null\n+         * @throws IllegalStateException if the builtin deserialization filter factory\n+         *         has already been replaced or any instance of {@link ObjectInputStream}\n+         *         has been created.\n+         * @throws SecurityException if there is security manager and the\n+         *       {@code SerializablePermission(\"serialFilter\")} is not granted\n+         * @since 17\n+         *\/\n@@ -770,162 +908,0 @@\n-        \/**\n-         * Returns a filter that returns {@code Status.ALLOWED} if the predicate\n-         * on the class is {@code true}.\n-         * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n-         * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n-         *\n-         * <p>When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n-         * the predicate is applied to the {@link FilterInfo#serialClass() info.serialClass()},\n-         * the return Status is:\n-         * <ul>\n-         *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n-         *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n-         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n-         * <\/ul>\n-         * <p>\n-         * Example, to create a filter that will allow any class loaded from the platform classloader.\n-         * <pre><code>\n-         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n-         *                                          || cl.getClassLoader() == null, Status.UNDECIDED);\n-         * <\/code><\/pre>\n-         *\n-         * @param predicate a predicate to test a non-null Class, non-null\n-         * @param otherStatus a Status to use if the predicate is {@code false}\n-         * @return a filter than returns {@code ALLOWED} if the predicate on the class returns {@code true},\n-         *          otherwise the {@code otherStatus}\n-         * @since 17\n-         *\/\n-        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n-            Objects.requireNonNull(predicate, \"predicate\");\n-            Objects.requireNonNull(otherStatus, \"otherStatus\");\n-            return new Config.PredicateFilter(predicate, ALLOWED, otherStatus);\n-        }\n-\n-        \/**\n-         * Returns a filter that returns {@code Status.REJECTED} if the predicate\n-         * on the class is {@code true}.\n-         * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n-         * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n-         *\n-         * When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n-         * the predicate is applied to the {@link FilterInfo#serialClass() serialClass()},\n-         * the return Status is:\n-         * <ul>\n-         *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n-         *     <li>{@link Status#REJECTED REJECTED}, if the predicate on the class returns {@code true},<\/li>\n-         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n-         * <\/ul>\n-         * <p>\n-         * Example, to create a filter that will reject any class loaded from the application classloader.\n-         * <pre><code>\n-         *     ObjectInputFilter f = rejectFilter(cl ->\n-         *          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);\n-         * <\/code><\/pre>\n-         *\n-         * @param predicate a predicate to test a non-null Class, non-null\n-         * @param otherStatus a Status to use if the predicate is {@code false}\n-         * @return returns a filter that returns {@link Status#REJECTED REJECTED} if the predicate on the class\n-         *          returns {@code true}, otherwise {@link Status#UNDECIDED UNDECIDED}\n-         * @since 17\n-         *\/\n-        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n-            Objects.requireNonNull(predicate, \"predicate\");\n-            Objects.requireNonNull(otherStatus, \"otherStatus\");\n-            return new Config.PredicateFilter(predicate, REJECTED, otherStatus);\n-        }\n-\n-        \/**\n-         * Returns a filter that returns {@code Status.ALLOWED} if the check is for limits\n-         * and not checking a class; otherwise {@code Status.UNDECIDED}.\n-         * If the {@link FilterInfo#serialClass() serialClass()} is {@code null}, the filter returns\n-         * {@code Status.ALLOWED}, otherwise return {@code Status.UNDECIDED}.\n-         * The limit values of {@link FilterInfo#arrayLength() arrayLength()},\n-         * {@link FilterInfo#depth() depth()}, {@link FilterInfo#references() references()},\n-         * and {@link FilterInfo#streamBytes() streamBytes()} are not checked.\n-         * To place a limit, create a separate filter with limits such as:\n-         * <pre>{@code\n-         * Config.createFilter(\"maxarray=10000,maxdepth=40\");\n-         * }<\/pre>\n-         *\n-         * When the filter's {@link ObjectInputFilter#checkInput} method is invoked,\n-         * the Status returned is:\n-         * <ul>\n-         *     <li>{@link Status#ALLOWED ALLOWED}, if the {@code serialClass} is {@code null},<\/li>\n-         *     <li>Otherwise, return {@link Status#UNDECIDED UNDECIDED}<\/li>\n-         * <\/ul>\n-         *\n-         * @return a filter that returns {@code Status.ALLOWED} if the check is for limits\n-         *          and not checking a class; otherwise {@code Status.UNDECIDED}\n-         * @since 17\n-         *\/\n-        public static ObjectInputFilter allowMaxLimits() {\n-            return new Config.AllowMaxLimitsFilter(ALLOWED, UNDECIDED);\n-        }\n-\n-        \/**\n-         * Returns a filter that merges the status of a filter and another filter.\n-         * If the other filter is {@code null}, the filter is returned.\n-         * Otherwise, a filter is returned to merge the pair of {@code non-null} filters.\n-         *\n-         * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n-         * as follows:\n-         * <ul>\n-         *     <li>Invoke {@code filter} on the {@code FilterInfo} to get its {@code status};\n-         *     <li>Return {@code REJECTED} if the {@code status} is {@code REJECTED};\n-         *     <li>Invoke the {@code otherFilter} to get the {@code otherStatus};\n-         *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n-         *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n-         *          is {@code ALLOWED}, <\/li>\n-         *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n-         * <\/ul>\n-         *\n-         * @param filter a filter, non-null\n-         * @param anotherFilter a filter to be merged with the filter, may be {@code null}\n-         * @return an {@link ObjectInputFilter} that merges the status of the filter and another filter\n-         * @since 17\n-         *\/\n-        public static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter) {\n-            Objects.requireNonNull(filter, \"filter\");\n-            return (anotherFilter == null) ? filter : new MergeFilter(filter, anotherFilter);\n-        }\n-\n-        \/**\n-         * Returns a filter that invokes a filter and maps {@code UNDECIDED} to {@code REJECTED}\n-         * for classes, with some exceptions, and otherwise returns the status.\n-         * The filter returned checks that classes not {@code ALLOWED} and not {@code REJECTED} by the filter\n-         * are {@code REJECTED}, if the class is an array and the base component type is not allowed,\n-         * otherwise the result is {@code UNDECIDED}.\n-         *\n-         * <p>\n-         * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n-         * Adding a filter to reject undecided results for classes that have not been\n-         * either allowed or rejected can prevent classes from slipping through the filter.\n-         *\n-         * @implSpec\n-         * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n-         * as follows:\n-         * <ul>\n-         *     <li>Invoke the filter on the {@code FilterInfo} to get its {@code status};\n-         *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n-         *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n-         *          is {@code null};\n-         *     <li>Determine the base component type if the {@code serialClass} is\n-         *          an {@linkplain Class#isArray() array};\n-         *     <li>Return {@code UNDECIDED} if the base component type is\n-         *          a {@linkplain Class#isPrimitive() primitive class};\n-         *     <li>Invoke the filter on the {@code base component type} to get its\n-         *          {@code component status};<\/li>\n-         *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n-         *     <li>Otherwise, return {@code REJECTED}.<\/li>\n-         * <\/ul>\n-         *\n-         * @param filter a filter, non-null\n-         * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n-         *      status to {@link Status#REJECTED} for classes, otherwise returns the\n-         *      filter status\n-         * @since 17\n-         *\/\n-        public static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter) {\n-            Objects.requireNonNull(filter, \"filter\");\n-            return new RejectUndecidedFilter(filter);\n-        }\n-\n@@ -1218,0 +1194,2 @@\n+         * @see ObjectInputFilter#allowFilter(Predicate, Status)\n+         * @see ObjectInputFilter#rejectFilter(Predicate, Status)\n@@ -1231,2 +1209,3 @@\n-             * Apply the predicate to the class being deserialized, if the class is non-null\n-             * and if it returns {@code true}, return the requested status. Otherwise, return UNDECIDED.\n+             * Returns a filter that returns {@code ifTrueStatus} or the {@code ifFalseStatus}\n+             * based on the predicate of the {@code non-null} class and {@code UNDECIDED}\n+             * if the class is {@code null}.\n@@ -1235,1 +1214,3 @@\n-             * @return the status of applying the predicate, otherwise {@code UNDECIDED}\n+             * @return a filter that returns {@code ifTrueStatus} or the {@code ifFalseStatus}\n+             *          based on the predicate of the {@code non-null} class and {@code UNDECIDED}\n+             *          if the class is {@code null}\n@@ -1244,18 +1225,0 @@\n-            public String toString() {\n-                return \"predicate(\" + predicate + \")\";\n-            }\n-        }\n-\n-        \/**\n-         * An ObjectInputFilter to evaluate if a FilterInfo is checking only limits,\n-         * and not classes.\n-         *\/\n-        private static class AllowMaxLimitsFilter implements ObjectInputFilter {\n-            private final Status limitCheck;\n-            private final Status classCheck;\n-\n-            AllowMaxLimitsFilter(Status limitCheck, Status classCheck) {\n-                this.limitCheck = limitCheck;\n-                this.classCheck = classCheck;\n-            }\n-\n@@ -1263,5 +1226,2 @@\n-             * If the FilterInfo is only checking a limit, return the requested\n-             * status, otherwise the other status.\n-             *\n-             * @param info the FilterInfo\n-             * @return the status of corresponding to serialClass == null or not\n+             * Return a String describing the filter, its predicate, and true and false status values.\n+             * @return a String describing the filter, its predicate, and true and false status values.\n@@ -1269,4 +1229,0 @@\n-            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n-                return (info.serialClass() == null) ? limitCheck : classCheck;\n-            }\n-\n@@ -1274,1 +1230,1 @@\n-                return \"allowMaxLimits()\";\n+                return \"predicate(\" + predicate + \", ifTrue: \" + ifTrueStatus + \", ifFalse:\" + ifFalseStatus+ \")\";\n@@ -1280,0 +1236,1 @@\n+         * @see ObjectInputFilter#merge(ObjectInputFilter, ObjectInputFilter)\n@@ -1292,2 +1249,2 @@\n-             * and ALLOWED if either of the filters returns ALLOWED.\n-             * Returns {@code UNDECIDED} if either filter returns {@code UNDECIDED}.\n+             * otherwise, ALLOWED if either of the filters returns ALLOWED.\n+             * otherwise, returns {@code UNDECIDED}.\n@@ -1296,3 +1253,3 @@\n-             * @return Status.REJECTED if either of the filters returns REJECTED,\n-             * and ALLOWED if either filter returns ALLOWED; otherwise returns\n-             * {@code UNDECIDED} if both filters returned {@code UNDECIDED}\n+             * @return REJECTED if either of the filters returns REJECTED,\n+             *          otherwise, ALLOWED if either of the filters returns ALLOWED.\n+             *          otherwise, returns {@code UNDECIDED}.\n@@ -1331,0 +1288,1 @@\n+         * @see ObjectInputFilter#rejectUndecidedClass(ObjectInputFilter)\n@@ -1421,2 +1379,2 @@\n-         * When invoked from {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)\n-         * to set the stream-specific filter} the requested filter replaces the static serial filter,\n+         * When invoked from {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}\n+         * to set the stream-specific filter the requested filter replaces the static serial filter,\n@@ -1428,1 +1386,1 @@\n-         *\n+         * @see Config#getSerialFilterFactory()\n@@ -1430,2 +1388,1 @@\n-        private static final class BuiltinFilterFactory\n-                implements BinaryOperator<ObjectInputFilter> {\n+        private static final class BuiltinFilterFactory implements BinaryOperator<ObjectInputFilter> {\n@@ -1477,1 +1434,1 @@\n-             * Returns the class name name of this builtin deserialization filter factory.\n+             * Returns the class name of this builtin deserialization filter factory.\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":271,"deletions":314,"binary":false,"changes":585,"status":"modified"},{"patch":"@@ -70,0 +70,17 @@\n+ * <p>The key to disabling deserialization attacks is to prevent instances of\n+ * arbitrary classes from being deserialized, thereby preventing the direct or\n+ * indirect execution of their methods.\n+ * {@link ObjectInputFilter} describes how to use filters and\n+ * {@link ObjectInputFilter.Config} describes how to configure the filter and filter factory.\n+ * Each stream has an optional deserialization filter\n+ * to check the classes and resource limits during deserialization.\n+ * The JVM-wide filter factory ensures that a filter can be set on every {@link ObjectInputStream}\n+ * and every object read from the stream can be checked.\n+ * The {@linkplain #ObjectInputStream() ObjectInputStream constructors} invoke the filter factory\n+ * to select the initial filter and it is updated by {@link #setObjectInputFilter}.\n+ * <p>\n+ * If an ObjectInputStream has a filter, the {@link ObjectInputFilter} can check that\n+ * the classes, array lengths, number of references in the stream, depth, and\n+ * number of bytes consumed from the input stream are allowed and\n+ * if not, can terminate deserialization.\n+ *\n@@ -191,16 +208,0 @@\n- * <p>\n- * The key to disabling deserialization attacks is to prevent instances of\n- * arbitrary classes from being deserialized, thereby preventing the direct or\n- * indirect execution of their methods.  Each stream has an optional deserialization filter\n- * to check the classes and resource limits during deserialization.\n- * The JVM-wide filter factory ensures that a filter can be set on every {@link ObjectInputStream}\n- * and every object read from the stream can be checked.\n- * The {@linkplain #ObjectInputStream() ObjectInputStream constructors} invoke the filter factory\n- * to select the initial filter and it is updated by {@link #setObjectInputFilter}.\n- * {@link ObjectInputFilter} describes how to use filters and\n- * {@link ObjectInputFilter.Config} describes how to configure the filter and filter factory.\n- * <p>\n- * If an ObjectInputStream has a filter, the {@link ObjectInputFilter} can check that\n- * the classes, array lengths, number of references in the stream, depth, and\n- * number of bytes consumed from the input stream are allowed and\n- * if not, can terminate deserialization.\n@@ -368,1 +369,1 @@\n-     * <p>The deserialization filter is initialized to the filter returned\n+     * <p>The constructor initializes the deserialization filter to the filter returned\n@@ -405,1 +406,1 @@\n-     * <p>The deserialization filter is initialized to the filter returned\n+     * <p>The constructor initializes the deserialization filter to the filter returned\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputStream;\n+import java.security.AccessControlException;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+\/* @test\n+ * @build FactoryWithSecurityManagerTest SerialFilterTest\n+ * @run testng\/othervm FactoryWithSecurityManagerTest\n+ * @run testng\/othervm\/policy=security.policy.without.globalFilter\n+ *          -Djava.security.manager=default FactoryWithSecurityManagerTest\n+ * @run testng\/othervm\/policy=security.policy\n+ *          -Djava.security.manager=default\n+ *          -Djdk.serialFilter=java.lang.Integer FactoryWithSecurityManagerTest\n+ *\n+ * @summary Test that setting specific filter is checked by security manager,\n+ *          setting process-wide filter is checked by security manager.\n+ *\/\n+\n+@Test\n+public class FactoryWithSecurityManagerTest {\n+\n+    byte[] bytes;\n+    boolean setSecurityManager;\n+    ObjectInputFilter filter;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        setSecurityManager = System.getSecurityManager() != null;\n+        Object toDeserialized = Long.MAX_VALUE;\n+        bytes = SerialFilterTest.writeObjects(toDeserialized);\n+        filter = ObjectInputFilter.Config.createFilter(\"java.lang.Long\");\n+    }\n+\n+    \/**\n+     * Test that setting process-wide filter is checked by security manager.\n+     *\/\n+    @Test\n+    public void testGlobalFilter() throws Exception {\n+        ObjectInputFilter global = ObjectInputFilter.Config.getSerialFilter();\n+\n+        try  {\n+            ObjectInputFilter.Config.setSerialFilter(filter);\n+            assertFalse(setSecurityManager,\n+                    \"When SecurityManager exists, without \"\n+                            + \"java.io.SerializablePermission(serialFilter) \"\n+                            + \"IllegalStateException should be thrown\");\n+        } catch (AccessControlException ex) {\n+            assertTrue(setSecurityManager);\n+            assertTrue(ex.getMessage().contains(\"java.io.SerializablePermission\"));\n+            assertTrue(ex.getMessage().contains(\"serialFilter\"));\n+        } catch (IllegalStateException ise) {\n+            \/\/ ISE should occur only if global filter already set\n+            Assert.assertNotNull(global, \"Global filter should be non-null\");\n+        }\n+    }\n+\n+    \/**\n+     * Test that setting specific filter is checked by security manager.\n+     *\/\n+    @Test(dependsOnMethods = { \"testGlobalFilter\" })\n+    public void testSpecificFilter() throws Exception {\n+        try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+             ObjectInputStream ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(filter);\n+            Object o = ois.readObject();\n+        } catch (AccessControlException ex) {\n+            assertTrue(setSecurityManager);\n+            assertTrue(ex.getMessage().contains(\"java.io.SerializablePermission\"));\n+            assertTrue(ex.getMessage().contains(\"serialFilter\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/FactoryWithSecurityManagerTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -107,1 +107,1 @@\n-                {new Point(1, 5), ObjectInputFilter.Config.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader(), UNDECIDED),\n+                {new Point(1, 5), ObjectInputFilter.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader(), UNDECIDED),\n@@ -114,1 +114,1 @@\n-    static void examples(Serializable obj, ObjectInputFilter filter, Status expected) {\n+    void examples(Serializable obj, ObjectInputFilter filter, Status expected) {\n@@ -148,1 +148,1 @@\n-    static void checkStatus(Serializable obj, ObjectInputFilter filter, Status expected) {\n+    void checkStatus(Serializable obj, ObjectInputFilter filter, Status expected) {\n@@ -273,1 +273,1 @@\n-                    filter = ObjectInputFilter.Config.merge(f, filter);\n+                    filter = ObjectInputFilter.merge(f, filter);\n@@ -278,1 +278,1 @@\n-                        filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n+                        filter = ObjectInputFilter.rejectUndecidedClass(filter);\n@@ -284,1 +284,1 @@\n-                    filter = ObjectInputFilter.Config.merge(next, filter);\n+                    filter = ObjectInputFilter.merge(next, filter);\n@@ -289,1 +289,1 @@\n-                    filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n@@ -299,1 +299,1 @@\n-                currFilter = (next == null) ? curr : ObjectInputFilter.Config.rejectUndecidedClass(ObjectInputFilter.Config.merge(next, curr));\n+                currFilter = (next == null) ? curr : ObjectInputFilter.rejectUndecidedClass(ObjectInputFilter.merge(next, curr));\n@@ -314,1 +314,2 @@\n-        private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new InheritableThreadLocal<>();\n+        \/\/ ThreadLocal to hold the serial filter to be applied\n+        private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new ThreadLocal<>();\n@@ -319,2 +320,9 @@\n-        \/\/ Returns a composite filter of the static JVM-wide filter, a thread-specific filter,\n-        \/\/ and the stream-specific filter.\n+        \/**\n+         * The filter factory, which is invoked every time a new ObjectInputStream\n+         * is created.  If a per-stream filter is already set then it returns a\n+         * filter that combines the results of invoking each filter.\n+         *\n+         * @param curr the current filter on the stream\n+         * @param next a per stream filter\n+         * @return the selected filter\n+         *\/\n@@ -323,1 +331,1 @@\n-                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no previous filter\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no current filter\n@@ -327,1 +335,1 @@\n-                    filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n@@ -330,1 +338,1 @@\n-                    \/\/ Prepend the `next` filter to the thread filter, if any\n+                    \/\/ Prepend the next filter to the thread filter, if any\n@@ -333,1 +341,2 @@\n-                    filter = ObjectInputFilter.Config.rejectUndecidedClass(ObjectInputFilter.Config.merge(next, filter));\n+                    filter = ObjectInputFilter.merge(next, filter);\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n@@ -340,2 +349,7 @@\n-                \/\/ Use the current filter or prepend the stream-specific filter and recheck for undecided\n-                return (next == null) ? curr : ObjectInputFilter.Config.rejectUndecidedClass(ObjectInputFilter.Config.merge(next, curr));\n+                \/\/ If there is a stream-specific filter prepend it and a filter to recheck for undecided\n+                if (next != null) {\n+                    next = ObjectInputFilter.merge(next, curr);\n+                    next = ObjectInputFilter.rejectUndecidedClass(next);\n+                    return next;\n+                }\n+                return curr;\n@@ -345,1 +359,6 @@\n-        \/\/ Applies the filter to the thread and invokes the runnable.\n+        \/**\n+         * Apply the filter and invoke the runnable.\n+         *\n+         * @param filter the serial filter to apply to every deserialization in the thread\n+         * @param runnable a Runnable to invoke\n+         *\/\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":37,"deletions":18,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -215,89 +215,0 @@\n-    @Test\n-    void testAndThen() {\n-        Status[] cases = Status.values();\n-        FilterInfo info = new SerialInfo(Object.class);\n-        for (Status st1 : cases) {\n-            for (Status st2 : cases) {\n-                ObjectInputFilter f = Config.merge(getFilter(st1), getFilter(st2));\n-                Status r = f.checkInput(info);\n-                Assert.assertEquals(evalAndThen(st1, st2), r, \"eval andThen\");\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED.\n-     * @param status a status\n-     * @param otherStatus another status\n-     * @return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED\n-     *\/\n-    private Status evalAndThen(Status status, Status otherStatus) {\n-        if (REJECTED.equals(status) || REJECTED.equals(otherStatus))\n-            return REJECTED;\n-\n-        if (ALLOWED.equals(status)  || ALLOWED.equals(otherStatus))\n-            return ALLOWED;\n-\n-        return UNDECIDED;\n-    }\n-\n-    \/**\n-     * Return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class.\n-     * @return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class\n-     *\/\n-    static Predicate<Class<?>> isInteger() {\n-        return (cl) -> cl.equals(Integer.class);\n-    }\n-\n-    @DataProvider(name = \"AllowPredicateCases\")\n-    static Object[][] allowPredicateCases() {\n-        return new Object[][]{\n-                { Integer.class, isInteger(), Status.ALLOWED},\n-                { Double.class, isInteger(), Status.UNDECIDED},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"AllowPredicateCases\")\n-    void testAllowPredicates(Class<?> clazz,\n-                        Predicate<Class<?>> predicate, Status expected) {\n-        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n-        Assert.assertEquals(Config.allowFilter(predicate, Status.UNDECIDED).checkInput(info), expected, \"Predicate result\");\n-    }\n-\n-    @DataProvider(name = \"RejectPredicateCases\")\n-    static Object[][] rejectPredicateCases() {\n-        return new Object[][]{\n-                { Integer.class, isInteger(), REJECTED},\n-                { Double.class, isInteger(), Status.UNDECIDED},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"RejectPredicateCases\")\n-    void testRejectPredicates(Class<?> clazz,\n-                              Predicate<Class<?>> predicate, Status expected) {\n-        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n-        Assert.assertEquals(Config.rejectFilter(predicate, Status.UNDECIDED).checkInput(info), expected, \"Predicate result\");\n-    }\n-\n-\n-    @Test\n-    static void testRejectUndecided() {\n-        FilterInfo info = new SerialInfo(Object.class); \/\/ an info structure, unused\n-\n-        ObjectInputFilter undecided = getFilter(UNDECIDED);\n-        Assert.assertEquals(Config.rejectUndecidedClass(undecided).checkInput(info), REJECTED, \"undecided -> rejected\");\n-        ObjectInputFilter allowed = getFilter(ALLOWED);\n-        Assert.assertEquals(Config.rejectUndecidedClass(allowed).checkInput(info), ALLOWED, \"allowed -> rejected\");\n-        ObjectInputFilter rejected = getFilter(REJECTED);\n-        Assert.assertEquals(Config.rejectUndecidedClass(rejected).checkInput(info), REJECTED, \"rejected -> rejected\");\n-    }\n-\n-    @Test\n-    static void testMaxLimits() {\n-        FilterInfo info = new SerialInfo(null); \/\/ an info structure, serialClass == null\n-        Assert.assertEquals(Config.allowMaxLimits().checkInput(info), ALLOWED, \"allowMaxLimit\");\n-\n-        info = new SerialInfo(Object.class); \/\/ an info structure, serialClass != null\n-        Assert.assertEquals(Config.allowMaxLimits().checkInput(info), UNDECIDED, \"allowMaxLimit\");\n-    }\n-\n@@ -306,1 +217,1 @@\n-    static void testPropertyFilterFactory() {\n+    void testPropertyFilterFactory() {\n@@ -313,0 +224,9 @@\n+    \/\/ Test that setting the filter factory after any deserialization (any testCase)\n+    \/\/ throws IllegalStateException with the specific message\n+    @Test(dependsOnMethods=\"testCase\")\n+    void testSetFactoryAfterDeserialization() throws IOException {\n+        BinaryOperator<ObjectInputFilter> factory = Config.getSerialFilterFactory();\n+        IllegalStateException ise = Assert.expectThrows(IllegalStateException.class, () -> Config.setSerialFilterFactory(factory));\n+        Assert.assertEquals(ise.getMessage(), \"FilterFactory can not be set after any deserialization\");\n+    }\n+\n@@ -444,57 +364,0 @@\n-\n-    \/**\n-     * FilterInfo instance with a specific class.\n-     *\/\n-    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n-        private final Class<?> clazz;\n-\n-        SerialInfo(Class<?> clazz) {\n-            this.clazz = clazz;\n-        }\n-\n-        @Override\n-        public Class<?> serialClass() {\n-            return clazz;\n-        }\n-\n-        @Override\n-        public long arrayLength() {\n-            return 0;\n-        }\n-\n-        @Override\n-        public long depth() {\n-            return 0;\n-        }\n-\n-        @Override\n-        public long references() {\n-            return 0;\n-        }\n-\n-        @Override\n-        public long streamBytes() {\n-            return 0;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return showFilterInfo(this);\n-        }\n-    }\n-\n-\n-    \/**\n-     * Return a string describing a FilterInfo instance.\n-     * @param info a FilterInfo instance\n-     * @return a String describing the FilterInfo instance\n-     *\/\n-    static String showFilterInfo(ObjectInputFilter.FilterInfo info) {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"serialClass: \" + info.serialClass());\n-        sb.append(\", arrayLength: \" + info.arrayLength());\n-        sb.append(\", depth: \" + info.depth());\n-        sb.append(\", references: \" + info.references());\n-        sb.append(\", streamBytes: \" + info.streamBytes());\n-        return sb.toString();\n-    }\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFactoryTest.java","additions":10,"deletions":147,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.FilterInfo;\n+import java.util.function.Predicate;\n+\n+import static java.io.ObjectInputFilter.Status;\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n+\n+\/* @test\n+ * @run testng SerialFilterFunctionTest\n+ * @summary ObjectInputFilter.Config Function Tests\n+ *\/\n+@Test\n+public class SerialFilterFunctionTest {\n+\n+    @Test\n+    void testMerge() {\n+        Status[] cases = Status.values();\n+        FilterInfo info = new SerialInfo(Object.class);\n+        for (Status st1 : cases) {\n+            ObjectInputFilter filter1 = getFilter(st1);\n+            for (Status st2 : cases) {\n+                ObjectInputFilter filter2 = getFilter(st2);\n+                ObjectInputFilter f = ObjectInputFilter.merge(filter1, filter2);\n+                Status r = f.checkInput(info);\n+                Assert.assertEquals(merge(st1, st2), r, \"merge\");\n+            }\n+            Assert.assertSame(ObjectInputFilter.merge(filter1, null), filter1, \"merge with null fail\");\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.merge(null, filter1));\n+        }\n+    }\n+\n+    \/**\n+     * Return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED.\n+     * @param status a status\n+     * @param otherStatus another status\n+     * @return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED\n+     *\/\n+    private Status merge(Status status, Status otherStatus) {\n+        if (REJECTED.equals(status) || REJECTED.equals(otherStatus))\n+            return REJECTED;\n+\n+        if (ALLOWED.equals(status)  || ALLOWED.equals(otherStatus))\n+            return ALLOWED;\n+\n+        return UNDECIDED;\n+    }\n+\n+    \/**\n+     * Return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class.\n+     * @return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class\n+     *\/\n+    static Predicate<Class<?>> isInteger() {\n+        return (cl) -> cl.equals(Integer.class);\n+    }\n+\n+    @DataProvider(name = \"AllowPredicateCases\")\n+    static Object[][] allowPredicateCases() {\n+        return new Object[][]{\n+                { Integer.class, isInteger(), Status.ALLOWED},\n+                { Double.class, isInteger(), Status.UNDECIDED},\n+                { Double.class, isInteger(), null},         \/\/ NPE\n+                { Double.class, null, Status.UNDECIDED},    \/\/ NPE\n+        };\n+    }\n+\n+    @Test(dataProvider = \"AllowPredicateCases\")\n+    void testAllowPredicates(Class<?> clazz, Predicate<Class<?>> predicate, Status expected) {\n+        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+        if (predicate == null || expected == null) {\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n+        } else {\n+            Assert.assertEquals(ObjectInputFilter.allowFilter(predicate, Status.UNDECIDED).checkInput(info),\n+                    expected, \"Predicate result\");\n+        }\n+    }\n+\n+    @DataProvider(name = \"RejectPredicateCases\")\n+    static Object[][] rejectPredicateCases() {\n+        return new Object[][]{\n+                { Integer.class, isInteger(), REJECTED},\n+                { Double.class, isInteger(), Status.UNDECIDED},\n+                { Double.class, isInteger(), null},         \/\/ NPE\n+                { Double.class, null, Status.UNDECIDED},    \/\/ NPE\n+        };\n+    }\n+\n+    @Test(dataProvider = \"RejectPredicateCases\")\n+    void testRejectPredicates(Class<?> clazz, Predicate<Class<?>> predicate, Status expected) {\n+        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+        if (predicate == null || expected == null) {\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n+        } else {\n+            Assert.assertEquals(ObjectInputFilter.rejectFilter(predicate, Status.UNDECIDED).checkInput(info), expected, \"Predicate result\");\n+        }\n+    }\n+\n+    @Test\n+    void testRejectUndecided() {\n+        FilterInfo info = new SerialInfo(Object.class); \/\/ an info structure, unused\n+\n+        ObjectInputFilter undecided = getFilter(UNDECIDED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(undecided).checkInput(info), REJECTED, \"undecided -> rejected\");\n+        ObjectInputFilter allowed = getFilter(ALLOWED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(allowed).checkInput(info), ALLOWED, \"allowed -> rejected\");\n+        ObjectInputFilter rejected = getFilter(REJECTED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(rejected).checkInput(info), REJECTED, \"rejected -> rejected\");\n+    }\n+\n+    \/**\n+     * Returns an ObjectInputFilter that returns the requested Status.\n+     * @param status a Status, may be null\n+     * @return  an ObjectInputFilter that returns the requested Status\n+     *\/\n+    private static ObjectInputFilter getFilter(ObjectInputFilter.Status status) {\n+        return (info) -> status;\n+    }\n+\n+    \/**\n+     * FilterInfo instance with a specific class.\n+     *\/\n+    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+        private final Class<?> clazz;\n+\n+        SerialInfo(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        @Override\n+        public Class<?> serialClass() {\n+            return clazz;\n+        }\n+\n+        @Override\n+        public long arrayLength() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long depth() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long references() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long streamBytes() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"serialClass: \" + serialClass());\n+            sb.append(\", arrayLength: \" + arrayLength());\n+            sb.append(\", depth: \" + depth());\n+            sb.append(\", references: \" + references());\n+            sb.append(\", streamBytes: \" + streamBytes());\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFunctionTest.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -245,1 +245,1 @@\n-    public static void t1(Object object,\n+    void t1(Object object,\n@@ -270,1 +270,1 @@\n-    static void testPatterns(String pattern) {\n+    void testPatterns(String pattern) {\n@@ -280,1 +280,1 @@\n-    static void nonResettableFilter() {\n+    void nonResettableFilter() {\n@@ -326,1 +326,1 @@\n-    static void testNonSettableAfterReadObject() throws IOException, ClassNotFoundException {\n+    void testNonSettableAfterReadObject() throws IOException, ClassNotFoundException {\n@@ -362,1 +362,1 @@\n-    static void testReadResolveToArray(Object array, int length) throws IOException {\n+    void testReadResolveToArray(Object array, int length) throws IOException {\n@@ -379,1 +379,1 @@\n-    static void testLimits(String name, long value) {\n+    void testLimits(String name, long value) {\n@@ -399,1 +399,1 @@\n-    static void testInvalidLimits(String pattern) {\n+    void testInvalidLimits(String pattern) {\n@@ -412,1 +412,1 @@\n-    static void testNullStatus() throws IOException {\n+    void testNullStatus() throws IOException {\n@@ -431,1 +431,1 @@\n-    static void testInvalidPatterns(String pattern) {\n+    void testInvalidPatterns(String pattern) {\n@@ -444,1 +444,1 @@\n-    static void testEmptyPattern() {\n+    void testEmptyPattern() {\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}