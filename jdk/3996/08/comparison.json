{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.StaticProperty;\n+import sun.security.action.GetBooleanAction;\n+\n+import java.lang.reflect.InvocationTargetException;\n@@ -35,0 +40,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BinaryOperator;\n@@ -36,0 +43,1 @@\n+import java.util.function.Predicate;\n@@ -37,2 +45,3 @@\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.util.StaticProperty;\n+import static java.io.ObjectInputFilter.Status.*;\n+import static java.lang.System.Logger.Level.TRACE;\n+import static java.lang.System.Logger.Level.INFO;\n@@ -51,2 +60,82 @@\n- * If set on an {@link ObjectInputStream}, the {@link #checkInput checkInput(FilterInfo)}\n- * method is called to validate classes, the length of each array,\n+ * <p>To protect against deserialization vulnerabilities, application developers\n+ * need a clear description of the objects that can be deserialized\n+ * by each component or library. For each context and use case, developers should\n+ * construct and apply an appropriate filter.\n+ *\n+ * <h2>Deserialization Filtering Factory and Filters<\/h2>\n+ * The parts of deserialization filtering are the filters, composite filters, and filter factory.\n+ * Each filter performs checks on classes and resource limits to determine the status as\n+ * rejected, allowed, or undecided.\n+ * Filters can be composed of other filters and merge or combine their results.\n+ * The filter factory is responsible for establishing and updating the filter\n+ * for each {@link ObjectInputStream}.\n+ *\n+ * <p>For simple cases, a static JVM-wide filter can be set for the entire application,\n+ * without setting a filter factory.\n+ * The JVM-wide filter can be set either with a system property on the command line or by\n+ * calling {@linkplain Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}.\n+ * No custom filter factory needs to be specified, defaulting to the builtin filter factory.\n+ * The builtin filter factory provides the {@linkplain Config#getSerialFilter static JVM-wide filter}\n+ * for each {@linkplain ObjectInputStream ObjectInputStream}.\n+ *\n+ * <p>For example, a filter that allows example classes, allows classes in the\n+ * {@code java.base} module, and rejects all other classes can be set:\n+ *\n+ * <pre>{@code As a command line property:\n+ *     % java -Djdk.serialFilter=\"example.*;java.base\/*;!*\" ...}<\/pre>\n+ *\n+ * <pre>{@code Or programmatically:\n+ *     var filter = ObjectInputFilter.Config.createFilter(\"example.*;java.base\/*;!*\")\n+ *     ObjectInputFilter.Config.setSerialFilter(filter);}<\/pre>\n+ *\n+ * <p>In an application with multiple execution contexts, the application can provide a\n+ * {@linkplain Config#setSerialFilterFactory(BinaryOperator) filter factory} to\n+ * protect individual contexts by providing a custom filter for each. When the stream\n+ * is constructed, the filter factory is called to identify the execution context from the available\n+ * information, including the current thread-local state, hierarchy of callers, library, module,\n+ * and class loader. At that point, the filter factory policy for creating or selecting filters\n+ * can choose a specific filter or composition of filters based on the context.\n+ * The JVM-wide deserialization filter factory ensures that a context-specific deserialization\n+ * filter can be set on every {@link ObjectInputStream} and every object read from the\n+ * stream can be checked.\n+ *\n+ * <h2>Invoking the Filter Factory<\/h2>\n+ * <p>The JVM-wide filter factory is a function invoked when each {@link ObjectInputStream}\n+ * {@linkplain ObjectInputStream#ObjectInputStream() is constructed} and when the\n+ * {@linkplain ObjectInputStream#setObjectInputFilter(ObjectInputFilter) stream-specific filter is set}.\n+ * The parameters are the current filter and a requested filter and it\n+ * returns the filter to be used for the stream. When invoked from the\n+ * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors},\n+ * the first parameter is {@code null} and the second parameter is the\n+ * {@linkplain ObjectInputFilter.Config#getSerialFilter() static JVM-wide filter}.\n+ * When invoked from {@link ObjectInputStream#setObjectInputFilter ObjectInputStream.setObjectInputFilter},\n+ * the first parameter is the filter currently set on the stream (which was set in the constructor),\n+ * and the second parameter is the filter given to {@code ObjectInputStream.setObjectInputFilter}.\n+ * The current and new filter may each be {@code null} and the factory may return {@code null}.\n+ * Note that the filter factory implementation can also use any contextual information\n+ * at its disposal, for example, extracted from the application thread context, or its call stack,\n+ * to compose and combine a new filter. It is not restricted to only use its two parameters.\n+ *\n+ * <p>The active deserialization filter factory is either:\n+ * <ul>\n+ * <li>The application specific filter factory set via {@link Config#setSerialFilterFactory(BinaryOperator)}\n+ *     or the system property {@code jdk.serialFilterFactory} or\n+ *     the security property {@code jdk.serialFilterFactory}.\n+ * <li>Otherwise, a builtin deserialization filter factory\n+ *     provides the {@linkplain Config#getSerialFilter static JVM-wide filter} when invoked from the\n+ *     {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}\n+ *     and replaces the static filter and when invoked from\n+ *     {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)}.\n+ *     See {@linkplain Config#getSerialFilterFactory() getSerialFilterFactory}.\n+ * <\/ul>\n+ *\n+ * <h2>Filters<\/h2>\n+ * Filters can be created from a {@linkplain Config#createFilter(String) pattern string},\n+ * or based on a {@linkplain Predicate predicate of a class} to\n+ * {@linkplain #allowFilter(Predicate, Status) allow} or\n+ * {@linkplain #rejectFilter(Predicate, Status) reject} classes.\n+ *.\n+ *\n+ * <p>The filter's {@link #checkInput checkInput(FilterInfo)} method is invoked\n+ * zero or more times while {@linkplain ObjectInputStream#readObject() reading objects}.\n+ * The method is called to validate classes, the length of each array,\n@@ -55,0 +144,7 @@\n+ *\n+ * <p>Composite filters combine or check the results of other filters.\n+ * The {@link #merge(ObjectInputFilter, ObjectInputFilter) merge(filter, anotherFilter)}\n+ * filter combines the status value of two filters.\n+ * The {@link #rejectUndecidedClass(ObjectInputFilter) rejectUndecidedClass(filter)}\n+ * checks the result of a filter for classes when the status is {@code UNDECIDED}.\n+ * In many cases any class not {@code ALLOWED} by the filter should be {@code REJECTED}.\n@@ -56,9 +152,3 @@\n- * A filter can be set via {@link ObjectInputStream#setObjectInputFilter setObjectInputFilter}\n- * for an individual ObjectInputStream.\n- * A filter can be set via {@link Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}\n- * to affect every {@code ObjectInputStream} that does not otherwise set a filter.\n- * <p>\n- * A filter determines whether the arguments are {@link Status#ALLOWED ALLOWED}\n- * or {@link Status#REJECTED REJECTED} and should return the appropriate status.\n- * If the filter cannot determine the status it should return\n- * {@link Status#UNDECIDED UNDECIDED}.\n+ * A deserialization filter determines whether the arguments are allowed or rejected and\n+ * should return the appropriate status: {@link Status#ALLOWED ALLOWED} or {@link Status#REJECTED REJECTED}.\n+ * If the filter cannot determine the status it should return {@link Status#UNDECIDED UNDECIDED}.\n@@ -66,1 +156,1 @@\n- * A filter designed for a particular use may be passed a class that is outside\n+ * A filter designed for a particular use may be passed a class outside\n@@ -68,1 +158,1 @@\n- * then it can reject a candidate class that matches and report UNDECIDED for others.\n+ * then it can reject a candidate class that matches and report {@code UNDECIDED} for others.\n@@ -72,1 +162,1 @@\n- * This allows a filter to specific about the choice it is reporting and\n+ * This allows a filter to be specific about the choice it is reporting and\n@@ -75,3 +165,30 @@\n- * <p>\n- * Typically, a custom filter should check if a system-wide filter\n- * is configured and defer to it if so. For example,\n+ * <h2>Filter Model Examples<\/h2>\n+ * For simple applications, a single predefined filter listing allowed or rejected\n+ * classes may be sufficient to manage the risk of deserializing unexpected classes.\n+ * <p>For an application composed from multiple modules or libraries, the structure\n+ * of the application can be used to identify the classes to be allowed or rejected\n+ * by each {@linkplain ObjectInputStream} in each context of the application.\n+ * The deserialization filter factory is invoked when each stream is constructed and\n+ * can examine the thread or program to determine a context-specific filter to be applied.\n+ * Some possible examples:\n+ * <ul>\n+ *     <li>Thread-local state can hold the filter to be applied or composed\n+ *         with a stream-specific filter.\n+ *         Filters could be pushed and popped from a virtual stack of filters\n+ *         maintained by the application or libraries.\n+ *     <li>The filter factory can identify the caller of the deserialization method\n+ *         and use module or library context to select a filter or compose an appropriate\n+ *         context-specific filter.\n+ *         A mechanism could identify a callee with restricted or unrestricted\n+ *         access to serialized classes and choose a filter accordingly.\n+ * <\/ul>\n+ *\n+ * <h2>Example to filter every deserialization in a thread<\/h2>\n+ *\n+ * This class shows how an application provided filter factory can combine filters\n+ * to check every deserialization operation that takes place in a thread.\n+ * It defines a thread-local variable to hold the thread-specific filter, and constructs a filter factory\n+ * that composes that filter with the static JVM-wide filter and the stream-specific filter.\n+ * The {@code doWithSerialFilter} method does the setup of the thread-specific filter\n+ * and invokes the application provided {@link Runnable Runnable}.\n+ *\n@@ -79,7 +196,36 @@\n- * ObjectInputFilter.Status checkInput(FilterInfo info) {\n- *     ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();\n- *     if (serialFilter != null) {\n- *         ObjectInputFilter.Status status = serialFilter.checkInput(info);\n- *         if (status != ObjectInputFilter.Status.UNDECIDED) {\n- *             \/\/ The system-wide filter overrides this filter\n- *             return status;\n+ * public static final class FilterInThread implements BinaryOperator<ObjectInputFilter> {\n+ *\n+ *     private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new ThreadLocal<>();\n+ *\n+ *     \/\/ Construct a FilterInThread deserialization filter factory.\n+ *     public FilterInThread() {}\n+ *\n+ *     \/\/ Returns a composite filter of the static JVM-wide filter, a thread-specific filter,\n+ *     \/\/ and the stream-specific filter.\n+ *     public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+ *         if (curr == null) {\n+ *             \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no current filter\n+ *             var filter = filterThreadLocal.get();\n+ *             if (filter != null) {\n+ *                 \/\/ Prepend a filter to reject all UNDECIDED results\n+ *                 filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n+ *             }\n+ *             if (next != null) {\n+ *                 \/\/ Prepend the next filter to the thread filter, if any\n+ *                 \/\/ Initially this is the static JVM-wide filter passed from the OIS constructor\n+ *                 \/\/ Append the filter to reject all UNDECIDED results\n+ *                 filter = ObjectInputFilter.Config.merge(next, filter);\n+ *                 filter = ObjectInputFilter.Config.rejectUndecidedClass(filter);\n+ *             }\n+ *             return filter;\n+ *         } else {\n+ *             \/\/ Called from OIS.setObjectInputFilter with a current filter and a stream-specific filter.\n+ *             \/\/ The curr filter already incorporates the thread filter and static JVM-wide filter\n+ *             \/\/ and rejection of undecided classes\n+ *             \/\/ If there is a stream-specific filter prepend it and a filter to recheck for undecided\n+ *             if (next != null) {\n+ *                 next = ObjectInputFilter.Config.merge(next, curr);\n+ *                 next = ObjectInputFilter.Config.rejectUndecidedClass(next);\n+ *                 return next;\n+ *             }\n+ *             return curr;\n@@ -88,3 +234,10 @@\n- *     if (info.serialClass() != null &&\n- *         Remote.class.isAssignableFrom(info.serialClass())) {\n- *         return Status.REJECTED;      \/\/ Do not allow Remote objects\n+ *\n+ *     \/\/ Applies the filter to the thread and invokes the runnable.\n+ *     public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+ *         var prevFilter = filterThreadLocal.get();\n+ *         try {\n+ *             filterThreadLocal.set(filter);\n+ *             runnable.run();\n+ *         } finally {\n+ *             filterThreadLocal.set(prevFilter);\n+ *         }\n@@ -92,1 +245,0 @@\n- *     return Status.UNDECIDED;\n@@ -94,1 +246,17 @@\n- *}<\/pre>\n+ * }<\/pre>\n+ * <h3>Using the Filter Factory<\/h3>\n+ * To use {@code FilterInThread} utility create an instance and configure it as the\n+ * JVM-wide filter factory.  The {@code doWithSerialFilter} method is invoked with a\n+ * filter allowing the example application and core classes:\n+ * <pre>{@code\n+ *        \/\/ Create a FilterInThread filter factory and set\n+ *        var filterInThread = new FilterInThread();\n+ *        ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+ *\n+ *        \/\/ Create a filter to allow example.* classes and reject all others\n+ *        var filter = ObjectInputFilter.Config.createFilter(\"example.*;java.base\/*;!*\");\n+ *        filterInThread.doWithSerialFilter(filter, () -> {\n+ *              byte[] bytes = ...;\n+ *              var o = deserializeObject(bytes);\n+ *        });\n+ * }<\/pre>\n@@ -113,0 +281,8 @@\n+     * <p>If {@code filterInfo.serialClass()} is {@code non-null}, there is a class to be checked.\n+     * If {@code serialClass()} is {@code null}, there is no class and the info contains\n+     * only metrics related to the depth of the graph being deserialized, the number of\n+     * references, and the size of the stream read.\n+     *\n+     * @apiNote Each filter implementing {@code checkInput} should return one of the values of {@link Status}.\n+     * Returning {@code null} may result in a {@link NullPointerException} or other unpredictable behavior.\n+     *\n@@ -121,0 +297,134 @@\n+    \/**\n+     * Returns a filter that returns {@code Status.ALLOWED} if the predicate\n+     * on the class is {@code true}.\n+     * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+     * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+     *\n+     * <p>When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+     * the predicate is applied to the {@link FilterInfo#serialClass() info.serialClass()},\n+     * the return Status is:\n+     * <ul>\n+     *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+     *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n+     *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Example, to create a filter that will allow any class loaded from the platform classloader.\n+     * <pre><code>\n+     *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n+     *                                          || cl.getClassLoader() == null, Status.UNDECIDED);\n+     * <\/code><\/pre>\n+     *\n+     * @param predicate a predicate to test a non-null Class, non-null\n+     * @param otherStatus a Status to use if the predicate is {@code false}\n+     * @return a filter that returns {@code ALLOWED} if the predicate\n+     *          on the class is {@code true}\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+        Objects.requireNonNull(predicate, \"predicate\");\n+        Objects.requireNonNull(otherStatus, \"otherStatus\");\n+        return new Config.PredicateFilter(predicate, ALLOWED, otherStatus);\n+    }\n+\n+    \/**\n+     * Returns a filter that returns {@code Status.REJECTED} if the predicate\n+     * on the class is {@code true}.\n+     * The filter returns {@code REJECTED} or the {@code otherStatus} based on the predicate\n+     * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+     *\n+     * When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+     * the predicate is applied to the {@link FilterInfo#serialClass() serialClass()},\n+     * the return Status is:\n+     * <ul>\n+     *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+     *     <li>{@link Status#REJECTED REJECTED}, if the predicate on the class returns {@code true},<\/li>\n+     *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Example, to create a filter that will reject any class loaded from the application classloader.\n+     * <pre><code>\n+     *     ObjectInputFilter f = rejectFilter(cl ->\n+     *          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);\n+     * <\/code><\/pre>\n+     *\n+     * @param predicate a predicate to test a non-null Class, non-null\n+     * @param otherStatus a Status to use if the predicate is {@code false}\n+     * @return returns a filter that returns {@code REJECTED} if the predicate\n+     *          on the class is {@code true}\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+        Objects.requireNonNull(predicate, \"predicate\");\n+        Objects.requireNonNull(otherStatus, \"otherStatus\");\n+        return new Config.PredicateFilter(predicate, REJECTED, otherStatus);\n+    }\n+\n+    \/**\n+     * Returns a filter that merges the status of a filter and another filter.\n+     * If {@code another} filter is {@code null}, the {@code filter} is returned.\n+     * Otherwise, a {@code filter} is returned to merge the pair of {@code non-null} filters.\n+     *\n+     * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n+     * as follows:\n+     * <ul>\n+     *     <li>Invoke {@code filter} on the {@code FilterInfo} to get its {@code status};\n+     *     <li>Return {@code REJECTED} if the {@code status} is {@code REJECTED};\n+     *     <li>Invoke {@code anotherFilter} to get the {@code otherStatus};\n+     *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n+     *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n+     *          is {@code ALLOWED}, <\/li>\n+     *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n+     * <\/ul>\n+     *\n+     * @param filter a filter, non-null\n+     * @param anotherFilter a filter to be merged with the filter, may be {@code null}\n+     * @return an {@link ObjectInputFilter} that merges the status of the filter and another filter\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter) {\n+        Objects.requireNonNull(filter, \"filter\");\n+        return (anotherFilter == null) ? filter : new Config.MergeFilter(filter, anotherFilter);\n+    }\n+\n+    \/**\n+     * Returns a filter that invokes a given filter and maps {@code UNDECIDED} to {@code REJECTED}\n+     * for classes, with some special cases, and otherwise returns the status.\n+     * The filter returned checks that classes not {@code ALLOWED} by the filter\n+     * are {@code REJECTED}.  Either the class is not {@code ALLOWED} or\n+     * if the class is an array and the base component type is not allowed,\n+     * otherwise the result is {@code UNDECIDED}.\n+     * <p>\n+     * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n+     * Adding a filter to reject undecided results for classes that have not been\n+     * either allowed or rejected can prevent classes from slipping through the filter.\n+     *\n+     * @implSpec\n+     * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n+     * as follows:\n+     * <ul>\n+     *     <li>Invoke the filter on the {@code FilterInfo} to get its {@code status};\n+     *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n+     *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n+     *          is {@code null};\n+     *     <li>Determine the base component type if the {@code serialClass} is\n+     *          an {@linkplain Class#isArray() array};\n+     *     <li>Return {@code UNDECIDED} if the base component type is\n+     *          a {@linkplain Class#isPrimitive() primitive class};\n+     *     <li>Invoke the filter on the {@code base component type} to get its\n+     *          {@code component status};<\/li>\n+     *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n+     *     <li>Otherwise, return {@code REJECTED}.<\/li>\n+     * <\/ul>\n+     *\n+     * @param filter a filter, non-null\n+     * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n+     *      status to {@link Status#REJECTED} for classes, otherwise returns the\n+     *      filter status\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter) {\n+        Objects.requireNonNull(filter, \"filter\");\n+        return new Config.RejectUndecidedFilter(filter);\n+    }\n+\n@@ -200,10 +510,11 @@\n-     * A utility class to set and get the system-wide filter or create a filter\n-     * from a pattern string. If a system-wide filter is set, it will be\n-     * used for each {@link ObjectInputStream} that does not set its own filter.\n-     * <p>\n-     * When setting the filter, it should be stateless and idempotent,\n-     * reporting the same result when passed the same arguments.\n-     * <p>\n-     * The filter is configured during the initialization of the {@code ObjectInputFilter.Config}\n-     * class. For example, by calling {@link #getSerialFilter() Config.getSerialFilter}.\n-     * If the Java virtual machine is started with the system property\n+     * A utility class to set and get the JVM-wide deserialization filter factory,\n+     * the static JVM-wide filter, or to create a filter from a pattern string.\n+     * The static filter factory and the static filter apply to the whole Java runtime,\n+     * or \"JVM-wide\", there is only one of each, for a complete description of\n+     * the function and use refer to {@link ObjectInputFilter}.\n+     *\n+     * <p>The JVM-wide deserialization filter factory and the static JVM-wide filter\n+     * can be configured from system properties during the initialization of the\n+     * {@code ObjectInputFilter.Config} class.\n+     *\n+     * <p>If the Java virtual machine is started with the system property\n@@ -217,1 +528,1 @@\n-     * The syntax for each property is the same as for the\n+     * The syntax for the property value is the same as for the\n@@ -219,1 +530,17 @@\n-     *\n+     * <p>\n+     * If the Java virtual machine is started with the system property\n+     * {@systemProperty jdk.serialFilterFactory}, its value names the class to configure the\n+     * JVM-wide deserialization filter factory.\n+     * If the system property is not defined, and the {@link java.security.Security} property\n+     * {@code jdk.serialFilterFactory} is defined then it is used to configure the filter factory.\n+     * The class must be public, must have a public zero-argument constructor, implement the\n+     * {@link BinaryOperator {@literal BinaryOperator<ObjectInputFilter>}} interface, provide its implementation and\n+     * be accessible via the {@linkplain ClassLoader#getSystemClassLoader() application class loader}.\n+     * The filter factory configured using the system or security property during initialization\n+     * can NOT be replaced with {@link #setSerialFilterFactory(BinaryOperator) Config.setSerialFilterFactory}.\n+     * This ensures that a filter factory set on the command line is not overridden accidentally\n+     * or intentionally by the application.\n+     * Setting the {@code jdk.serialFilterFactory} with {@link System#setProperty(String, String)\n+     * System.setProperty} <em>does not set the filter factory<\/em>.\n+     * The syntax for the system property value and security property value is the\n+     * fully qualified class name of the deserialization filter factory.\n@@ -223,2 +550,10 @@\n-        \/* No instances. *\/\n-        private Config() {}\n+        \/**\n+         * Lock object for filter and filter factory.\n+         *\/\n+        private final static Object serialFilterLock = new Object();\n+\n+        \/**\n+         * The property name for the filter.\n+         * Used as a system property and a java.security.Security property.\n+         *\/\n+        private static final String SERIAL_FILTER_PROPNAME = \"jdk.serialFilter\";\n@@ -227,1 +562,2 @@\n-         * Lock object for system-wide filter.\n+         * The property name for the filter factory.\n+         * Used as a system property and a java.security.Security property.\n@@ -229,1 +565,1 @@\n-        private static final Object serialFilterLock = new Object();\n+        private static final String SERIAL_FILTER_FACTORY_PROPNAME = \"jdk.serialFilterFactory\";\n@@ -232,1 +568,1 @@\n-         * Debug: Logger\n+         * The property name to enable tracing of filters.\n@@ -234,1 +570,1 @@\n-        private static final System.Logger configLog;\n+        private static final String SERIAL_FILTER_TRACE_PROPNAME = \"jdk.serialFilterTrace\";\n@@ -237,1 +573,1 @@\n-         * Logger for debugging.\n+         * Current static filter.\n@@ -239,5 +575,1 @@\n-        static void filterLog(System.Logger.Level level, String msg, Object... args) {\n-            if (configLog != null) {\n-                configLog.log(level, msg, args);\n-            }\n-        }\n+        private static volatile ObjectInputFilter serialFilter;\n@@ -246,2 +578,2 @@\n-         * The name for the system-wide deserialization filter.\n-         * Used as a system property and a java.security.Security property.\n+         * Current serial filter factory.\n+         * @see Config#setSerialFilterFactory(BinaryOperator)\n@@ -249,1 +581,1 @@\n-        private static final String SERIAL_FILTER_PROPNAME = \"jdk.serialFilter\";\n+        private static volatile BinaryOperator<ObjectInputFilter> serialFilterFactory;\n@@ -252,3 +584,2 @@\n-         * The system-wide filter; may be null.\n-         * Lookup the filter in java.security.Security or\n-         * the system property.\n+         * Boolean to indicate that the filter factory has been used and cannot be changed thereafter.\n+         * @see Config#setSerialFilterFactory(BinaryOperator)\n@@ -256,1 +587,11 @@\n-        private static final ObjectInputFilter configuredFilter;\n+        private static final AtomicBoolean filterFactoryUsed = new AtomicBoolean(false);\n+\n+        \/**\n+         * Debug: Logger\n+         *\/\n+        private static final System.Logger configLog;\n+\n+        \/**\n+         * True when tracing of filters is enabled.\n+         *\/\n+        private static final boolean traceFilters;\n@@ -259,21 +600,83 @@\n-            configuredFilter = AccessController\n-                    .doPrivileged((PrivilegedAction<ObjectInputFilter>) () -> {\n-                        String props = StaticProperty.jdkSerialFilter();\n-                        if (props == null) {\n-                            props = Security.getProperty(SERIAL_FILTER_PROPNAME);\n-                        }\n-                        if (props != null) {\n-                            System.Logger log =\n-                                    System.getLogger(\"java.io.serialization\");\n-                            log.log(System.Logger.Level.INFO,\n-                                    \"Creating serialization filter from {0}\", props);\n-                            try {\n-                                return createFilter(props);\n-                            } catch (RuntimeException re) {\n-                                log.log(System.Logger.Level.ERROR,\n-                                        \"Error configuring filter: {0}\", re);\n-                            }\n-                        }\n-                        return null;\n-                    });\n-            configLog = (configuredFilter != null) ? System.getLogger(\"java.io.serialization\") : null;\n+            \/*\n+             * Initialize the configuration containing the filter factory, static filter, and logger.\n+             * <ul>\n+             * <li>The property 'jdk.serialFilter\" is read, either as a system property or a security property,\n+             *     and if set, defines the configured static JVM-wide filter and is logged.\n+             * <li>The property jdk.serialFilterFactory is read, either as a system property or a security property,\n+             *     and if set, defines the initial filter factory and is logged.\n+             * <li>The property jdk.serialFilterTrace, is read, and if set enables tracing of filters.\n+             * <li>If either property is defined or tracing is enabled, the logger is created.\n+             * <\/ul>\n+             *\/\n+\n+            \/\/ Get the values of the system properties, if they are defined\n+            String factoryClassName = StaticProperty.jdkSerialFilterFactory();\n+            if (factoryClassName == null) {\n+                \/\/ Fallback to security property\n+                factoryClassName = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+                        Security.getProperty(SERIAL_FILTER_FACTORY_PROPNAME));\n+            }\n+\n+            String filterString = StaticProperty.jdkSerialFilter();\n+            if (filterString == null) {\n+                \/\/ Fallback to security property\n+                filterString = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+                        Security.getProperty(SERIAL_FILTER_PROPNAME));\n+            }\n+\n+            traceFilters = GetBooleanAction.privilegedGetProperty(SERIAL_FILTER_TRACE_PROPNAME);\n+\n+            \/\/ Initialize the logger if either filter factory or filter property is set\n+            configLog = (filterString != null || factoryClassName != null || traceFilters)\n+                    ? System.getLogger(\"java.io.serialization\") : null;\n+\n+            \/\/ Initialize the static filter if the jdk.serialFilter is present\n+            ObjectInputFilter filter = null;\n+            if (filterString != null) {\n+                configLog.log(INFO,\n+                        \"Creating deserialization filter from {0}\", filterString);\n+                try {\n+                    filter = createFilter(filterString);\n+                } catch (RuntimeException re) {\n+                    configLog.log(System.Logger.Level.ERROR,\n+                            \"Error configuring filter: {0}\", re);\n+                }\n+            }\n+            serialFilter = filter;\n+\n+            \/\/ Initialize the filter factory if the jdk.serialFilterFactory is defined\n+            \/\/ otherwise use the builtin filter factory.\n+            BinaryOperator<ObjectInputFilter> factory;\n+            if (factoryClassName != null) {\n+                configLog.log(INFO,\n+                        \"Creating deserialization filter factory for {0}\", factoryClassName);\n+                try {\n+                    \/\/ Load using the system class loader, the named class may be an application class.\n+                    \/\/ The static initialization of the class or constructor may create a race\n+                    \/\/ if either calls Config.setSerialFilterFactory; the command line configured\n+                    \/\/ Class should not be overridden.\n+                    Class<?> factoryClass= Class.forName(factoryClassName, true,\n+                            ClassLoader.getSystemClassLoader());\n+                    @SuppressWarnings(\"unchecked\")\n+                    BinaryOperator<ObjectInputFilter> f =\n+                            (BinaryOperator<ObjectInputFilter>)\n+                            factoryClass.getConstructor().newInstance(new Object[0]);\n+                    if (serialFilterFactory != null) {\n+                        configLog.log(System.Logger.Level.ERROR,\n+                                \"FilterFactory provided on the command line can not be overridden\");\n+                        \/\/ Do not continue if configuration not initialized\n+                        throw new ExceptionInInitializerError(\"FilterFactory provided on the command line can not be overridden\");\n+                    }\n+                    factory = f;\n+                } catch (RuntimeException | ClassNotFoundException | NoSuchMethodException |\n+                        IllegalAccessException | InstantiationException | InvocationTargetException ex) {\n+                    configLog.log(System.Logger.Level.ERROR,\n+                            \"Error configuring filter factory\", ex);\n+                    \/\/ Do not continue if configuration not initialized\n+                    throw new ExceptionInInitializerError(\n+                            \"FilterFactory configuration: jdk.serialFilterFactory: \" + ex.getMessage());\n+                }\n+            } else {\n+                factory = new BuiltinFilterFactory();\n+            }\n+            serialFilterFactory = factory;\n@@ -286,1 +689,7 @@\n-         * Current configured filter.\n+         * Config has no instances.\n+         *\/\n+        private Config() {\n+        }\n+\n+        \/**\n+         * Logger for filter actions.\n@@ -288,1 +697,5 @@\n-        private static volatile ObjectInputFilter serialFilter = configuredFilter;\n+        private static void traceFilter(String msg, Object... args) {\n+            if (traceFilters && configLog != null) {\n+                configLog.log(TRACE, msg, args);\n+            }\n+        }\n@@ -291,1 +704,1 @@\n-         * Returns the system-wide serialization filter or {@code null} if not configured.\n+         * Returns the static JVM-wide deserialization filter or {@code null} if not configured.\n@@ -293,1 +706,1 @@\n-         * @return the system-wide serialization filter or {@code null} if not configured\n+         * @return the static JVM-wide deserialization filter or {@code null} if not configured\n@@ -300,1 +713,1 @@\n-         * Set the system-wide filter if it has not already been configured or set.\n+         * Set the static JVM-wide filter if it has not already been configured or set.\n@@ -302,1 +715,1 @@\n-         * @param filter the serialization filter to set as the system-wide filter; not null\n+         * @param filter the deserialization filter to set as the JVM-wide filter; not null\n@@ -321,0 +734,94 @@\n+        \/**\n+         * Returns the JVM-wide deserialization filter factory.\n+         * If the filter factory has been {@linkplain #setSerialFilterFactory(BinaryOperator) set} it is returned,\n+         * otherwise, a builtin deserialization filter factory is returned.\n+         * The filter factory provides a filter for every ObjectInputStream when invoked from\n+         * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}\n+         * and when a stream-specific filter is set with\n+         * {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.\n+         *\n+         * @implSpec\n+         * The builtin deserialization filter factory provides the\n+         * {@linkplain #getSerialFilter static JVM-wide filter} when invoked from\n+         * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}.\n+         * When invoked {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)\n+         * to set the stream-specific filter} the requested filter replaces the static JVM-wide filter,\n+         * unless it has already been set.\n+         * The builtin deserialization filter factory implements the behavior of earlier versions of\n+         * setting the initial filter in the {@link ObjectInputStream} constructor and\n+         * {@link ObjectInputStream#setObjectInputFilter}.\n+         *\n+         * @return the JVM-wide deserialization filter factory; non-null\n+         * @since 17\n+         *\/\n+        public static BinaryOperator<ObjectInputFilter> getSerialFilterFactory() {\n+            if (serialFilterFactory == null)\n+                throw new IllegalStateException(\"Serial filter factory initialization incomplete\");\n+            return serialFilterFactory;\n+        }\n+\n+        \/**\n+         * Returns the serial filter factory singleton and prevents it from changing\n+         * thereafter.\n+         * This package private method is *only* called by {@link ObjectInputStream#ObjectInputStream()}\n+         * and  {@link ObjectInputStream#ObjectInputStream(InputStream)}.\n+         * {@link ObjectInputFilter.Config#serialFilterFactory} does the enforcement.\n+         *\n+         * @return the serial filter factory\n+         *\/\n+        \/* package-private *\/\n+        static BinaryOperator<ObjectInputFilter> getSerialFilterFactorySingleton() {\n+            filterFactoryUsed.set(true);\n+            return getSerialFilterFactory();\n+        }\n+\n+        \/**\n+         * Set the {@linkplain #getSerialFilterFactory() JVM-wide deserialization filter factory}.\n+         * The filter factory can be configured exactly once with one of:\n+         * setting the {@code jdk.serialFilterFactory} property on the command line,\n+         * setting the {@code jdk.serialFilterFactory} property in the {@link java.security.Security}\n+         * file, or using this {@code setSerialFilterFactory} method.\n+         * The filter factory can be set only before any {@link ObjectInputStream} has been\n+         * created to avoid any inconsistency in which filter factory is being used.\n+         *\n+         * <p>The JVM-wide filter factory is invoked when an ObjectInputStream\n+         * {@linkplain ObjectInputStream#ObjectInputStream() is constructed} and when the\n+         * {@linkplain ObjectInputStream#setObjectInputFilter(ObjectInputFilter) stream-specific filter is set}.\n+         * The parameters are the current filter and a requested filter and it\n+         * returns the filter to be used for the stream.\n+         * The current and new filter may each be {@code null} and the factory may return {@code null}.\n+         * The factory determines the filter to be used for {@code ObjectInputStream} streams based\n+         * on its inputs, any other filters, context, or state that is available.\n+         * The factory may throw runtime exceptions to signal incorrect use or invalid parameters.\n+         * See the {@linkplain ObjectInputFilter filter models} for examples of composition and delegation.\n+         *\n+         * @param filterFactory the deserialization filter factory to set as the\n+         *         JVM-wide filter factory; not null\n+         * @throws IllegalStateException if the builtin deserialization filter factory\n+         *         has already been replaced or any instance of {@link ObjectInputStream}\n+         *         has been created.\n+         * @throws SecurityException if there is security manager and the\n+         *       {@code SerializablePermission(\"serialFilter\")} is not granted\n+         * @since 17\n+         *\/\n+        public static void setSerialFilterFactory(BinaryOperator<ObjectInputFilter> filterFactory) {\n+            Objects.requireNonNull(filterFactory, \"filterFactory\");\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null) {\n+                sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);\n+            }\n+            if (filterFactoryUsed.getAndSet(true)) {\n+                throw new IllegalStateException(\"FilterFactory can not be set after any deserialization\");\n+            }\n+            if (serialFilterFactory instanceof BuiltinFilterFactory) {\n+                \/\/ The factory can be set only if it has been initialized to the builtin.\n+                serialFilterFactory = filterFactory;\n+                return;\n+            }\n+            \/\/ Either the serialFilterFactory has already been set by setSerialFilterFactory\n+            \/\/ or it is {@code null}, because the Config static initialization has not completed.\n+            \/\/ In either case, the serialFilterFactory can not be set.\n+            throw new IllegalStateException(\"Serial filter factory can not replace: \" +\n+                    serialFilterFactory.getClass().getName());\n+        }\n+\n@@ -404,1 +911,1 @@\n-         * the system-wide serialization filter. If configured, it will be\n+         * the JVM-wide deserialization filter. If configured, it will be\n@@ -408,1 +915,1 @@\n-        static final class Global implements ObjectInputFilter {\n+        final static class Global implements ObjectInputFilter {\n@@ -635,0 +1142,1 @@\n+                            traceFilter(\"Pattern array class: {0}, filter: {1}\", clazz, this);\n@@ -645,1 +1153,2 @@\n-                        return Status.UNDECIDED;\n+                        traceFilter(\"Pattern UNDECIDED, primitive class: {0}, filter: {1}\", clazz, this);\n+                        return UNDECIDED;\n@@ -653,1 +1162,3 @@\n-                        return status.orElse(Status.UNDECIDED);\n+                        Status s = status.orElse(Status.UNDECIDED);\n+                        traceFilter(\"Pattern {0}, class: {1}, filter: {2}\", s, cl, this);\n+                        return s;\n@@ -656,1 +1167,2 @@\n-                return Status.UNDECIDED;\n+                \/\/ There are no classes to check and none of the limits have been exceeded.\n+                return UNDECIDED;\n@@ -680,0 +1192,250 @@\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate a predicate mapping a class to a boolean.\n+         * @see ObjectInputFilter#allowFilter(Predicate, Status)\n+         * @see ObjectInputFilter#rejectFilter(Predicate, Status)\n+         *\/\n+        private static class PredicateFilter implements ObjectInputFilter {\n+            private final Predicate<Class<?>> predicate;\n+            private final Status ifTrueStatus;\n+            private final Status ifFalseStatus;\n+\n+            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus, Status ifFalseStatus) {\n+                this.predicate = predicate;\n+                this.ifTrueStatus = ifTrueStatus;\n+                this.ifFalseStatus = ifFalseStatus;\n+            }\n+\n+            \/**\n+             * Returns a filter that returns {@code ifTrueStatus} or the {@code ifFalseStatus}\n+             * based on the predicate of the {@code non-null} class and {@code UNDECIDED}\n+             * if the class is {@code null}.\n+             *\n+             * @param info the FilterInfo\n+             * @return a filter that returns {@code ifTrueStatus} or the {@code ifFalseStatus}\n+             *          based on the predicate of the {@code non-null} class and {@code UNDECIDED}\n+             *          if the class is {@code null}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Class<?> clazz = info.serialClass();\n+                Status status = (clazz != null && predicate.test(clazz)) ? ifTrueStatus : ifFalseStatus;\n+                traceFilter(\"PredicateFilter {0}, filter: {1}\", status, this);\n+                return status;\n+            }\n+\n+            \/**\n+             * Return a String describing the filter, its predicate, and true and false status values.\n+             * @return a String describing the filter, its predicate, and true and false status values.\n+             *\/\n+            public String toString() {\n+                return \"predicate(\" + predicate + \", ifTrue: \" + ifTrueStatus + \", ifFalse:\" + ifFalseStatus+ \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the status of two filters.\n+         * @see ObjectInputFilter#merge(ObjectInputFilter, ObjectInputFilter)\n+         *\/\n+        private static class MergeFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter first;\n+            private final ObjectInputFilter second;\n+\n+            MergeFilter(ObjectInputFilter first, ObjectInputFilter second) {\n+                this.first = first;\n+                this.second = second;\n+            }\n+\n+            \/**\n+             * Returns REJECTED if either of the filters returns REJECTED,\n+             * otherwise, ALLOWED if either of the filters returns ALLOWED.\n+             * otherwise, returns {@code UNDECIDED}.\n+             *\n+             * @param info the FilterInfo\n+             * @return REJECTED if either of the filters returns REJECTED,\n+             *          otherwise, ALLOWED if either of the filters returns ALLOWED.\n+             *          otherwise, returns {@code UNDECIDED}.\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+               Status firstStatus = Objects.requireNonNull(first.checkInput(info), \"status\");\n+                if (REJECTED.equals(firstStatus)) {\n+                    traceFilter(\"MergeFilter REJECT first: {0}, filter: {1}\",\n+                            firstStatus, this);\n+                    return REJECTED;\n+                }\n+                Status secondStatus = Objects.requireNonNull(second.checkInput(info), \"other status\");\n+                if (REJECTED.equals(secondStatus)) {\n+                    traceFilter(\"MergeFilter REJECT {0}, {1}, filter: {2}\",\n+                            firstStatus, secondStatus, this);\n+                    return REJECTED;\n+                }\n+                if (ALLOWED.equals(firstStatus) || ALLOWED.equals(secondStatus)) {\n+                    traceFilter(\"MergeFilter ALLOW either: {0}, {1}, filter: {2}\",\n+                            firstStatus, secondStatus, this);\n+                    return ALLOWED;\n+                }\n+                traceFilter(\"MergeFilter UNDECIDED {0}, {1}, filter: {2}\",\n+                        firstStatus, secondStatus, this);\n+                return UNDECIDED;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"merge(\" + first + \", \" + second + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * A filter that maps the status {@code UNDECIDED} to {@code REJECTED} when checking a class.\n+         * @see ObjectInputFilter#rejectUndecidedClass(ObjectInputFilter)\n+         *\/\n+        private static class RejectUndecidedFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter filter;\n+\n+            private RejectUndecidedFilter(ObjectInputFilter filter) {\n+                this.filter = Objects.requireNonNull(filter, \"filter\");\n+            }\n+\n+            \/**\n+             * Apply the filter and return the status if not UNDECIDED and checking a class.\n+             * For array classes, re-check the final component type against the filter.\n+             * Make an exception for Primitive classes that are implicitly allowed by the pattern based filter.\n+             * @param info the FilterInfo\n+             * @return the status of applying the filter and checking the class\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status status = Objects.requireNonNull(filter.checkInput(info), \"status\");\n+                Class<?> clazz = info.serialClass();\n+                if (clazz == null || !UNDECIDED.equals(status))\n+                    return status;\n+                status = REJECTED;\n+                \/\/ Find the base component type\n+                while (clazz.isArray()) {\n+                    clazz = clazz.getComponentType();\n+                }\n+                if (clazz.isPrimitive()) {\n+                    status = UNDECIDED;\n+                } else {\n+                    \/\/ for non-primitive types;  re-filter the base component type\n+                    FilterInfo clazzInfo = new SerialInfo(info, clazz);\n+                    Status clazzStatus = filter.checkInput(clazzInfo);\n+                    traceFilter(\"RejectUndecidedFilter Array Component type {0} class: {1}, filter: {2}\",\n+                            clazzStatus, clazz, this);\n+                    status = (ALLOWED.equals(clazzStatus)) ? ALLOWED : REJECTED;\n+                }\n+                traceFilter(\"RejectUndecidedFilter {0} class: {1}, filter: {2}\",\n+                        status, info.serialClass(), this);\n+                return status;\n+            }\n+\n+            public String toString() {\n+                return \"rejectUndecidedClass(\" + filter + \")\";\n+            }\n+\n+            \/**\n+             * FilterInfo instance with a specific class and delegating to an existing FilterInfo.\n+             * Nested in the rejectUndecided class.\n+             *\/\n+            static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+                private final FilterInfo base;\n+                private final Class<?> clazz;\n+\n+                SerialInfo(FilterInfo base, Class<?> clazz) {\n+                    this.base = base;\n+                    this.clazz = clazz;\n+                }\n+\n+                @Override\n+                public Class<?> serialClass() {\n+                    return clazz;\n+                }\n+\n+                @Override\n+                public long arrayLength() {\n+                    return base.arrayLength();\n+                }\n+\n+                @Override\n+                public long depth() {\n+                    return base.depth();\n+                }\n+\n+                @Override\n+                public long references() {\n+                    return base.references();\n+                }\n+\n+                @Override\n+                public long streamBytes() {\n+                    return base.streamBytes();\n+                }\n+            }\n+\n+        }\n+\n+        \/**\n+         * Builtin Deserialization filter factory.\n+         * The builtin deserialization filter factory provides the\n+         * {@linkplain #getSerialFilter static serial filter} when invoked from\n+         * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}.\n+         * When invoked from {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}\n+         * to set the stream-specific filter the requested filter replaces the static serial filter,\n+         * unless it has already been set. The stream-specific filter can only be set once,\n+         * if it has already been set, {@link IllegalStateException} is thrown.\n+         * The builtin deserialization filter factory implements the behavior of earlier versions of\n+         * setting the static serial filter in the {@link ObjectInputStream} constructor and\n+         * {@link ObjectInputStream#setObjectInputFilter}.\n+         * @see Config#getSerialFilterFactory()\n+         *\/\n+        private static final class BuiltinFilterFactory implements BinaryOperator<ObjectInputFilter> {\n+            \/**\n+             * Returns the ObjectInputFilter to be used for an ObjectInputStream.\n+             * This method implements the builtin deserialization filter factory.\n+             * If the {@code oldFilter} and {@code newFilter} are null,\n+             *     the {@link Config#getSerialFilter()} is returned.\n+             * If the {@code oldFilter} is {@code null} and {@code newFilter} is {@code not null},\n+             *     the {@code newFilter} is returned.\n+             * If the {@code oldFilter} is equal to {@link Config#getSerialFilter},\n+             *     the {@code newFilter} is returned.\n+             * Otherwise {@code IllegalStateException} exception is thrown.\n+             *\n+             * <p>This is backward compatible behavior with earlier versions of\n+             * {@link ObjectInputStream#setObjectInputFilter},\n+             * and the initial filter in the {@link ObjectInputStream} constructor.\n+             *\n+             * @param oldFilter the current filter, may be null\n+             * @param newFilter a new filter, may be null\n+             * @return an ObjectInputFilter, the new Filter\n+             * @throws IllegalStateException if the {@linkplain ObjectInputStream#getObjectInputFilter() current filter}\n+             *       is not {@code null} and is not the JVM-wide filter\n+             *\/\n+            @Override\n+            public ObjectInputFilter apply(ObjectInputFilter oldFilter, ObjectInputFilter newFilter) {\n+                if (oldFilter != null) {\n+                    \/\/ JEP 290 spec restricts setting the stream-specific filter more than once.\n+                    \/\/ Allow replacement of the JVM-wide filter but not replacement\n+                    \/\/ of a stream-specific filter that has been set.\n+                    if (oldFilter != getSerialFilter()) {\n+                        throw new IllegalStateException(\"filter can not be set more than once\");\n+                    }\n+                } else if (newFilter == null) {\n+                    \/\/ Called from constructor, default to the configured filter, (may be null)\n+                    ObjectInputFilter filter = Config.getSerialFilter();\n+                    if (filter != null)\n+                        traceFilter(\"Builtin factory: {0} -> conf: {1}\",\n+                            oldFilter, Config.getSerialFilter());\n+                    return filter;\n+                }\n+                if (newFilter != null)\n+                    traceFilter(\"Builtin factory: {0} -> new: {1}\",\n+                        oldFilter, newFilter);\n+                return newFilter;\n+            }\n+\n+            \/**\n+             * Returns the class name of this builtin deserialization filter factory.\n+             * @return returns the class name of this builtin deserialization filter factory\n+             *\/\n+            public String toString() {\n+                return this.getClass().getName();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":857,"deletions":95,"binary":false,"changes":952,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.ObjectInputFilter.Config;\n@@ -69,0 +70,17 @@\n+ * <p>The key to disabling deserialization attacks is to prevent instances of\n+ * arbitrary classes from being deserialized, thereby preventing the direct or\n+ * indirect execution of their methods.\n+ * {@link ObjectInputFilter} describes how to use filters and\n+ * {@link ObjectInputFilter.Config} describes how to configure the filter and filter factory.\n+ * Each stream has an optional deserialization filter\n+ * to check the classes and resource limits during deserialization.\n+ * The JVM-wide filter factory ensures that a filter can be set on every {@link ObjectInputStream}\n+ * and every object read from the stream can be checked.\n+ * The {@linkplain #ObjectInputStream() ObjectInputStream constructors} invoke the filter factory\n+ * to select the initial filter and it is updated by {@link #setObjectInputFilter}.\n+ * <p>\n+ * If an ObjectInputStream has a filter, the {@link ObjectInputFilter} can check that\n+ * the classes, array lengths, number of references in the stream, depth, and\n+ * number of bytes consumed from the input stream are allowed and\n+ * if not, can terminate deserialization.\n+ *\n@@ -191,10 +209,0 @@\n- * <p>The contents of the stream can be filtered during deserialization.\n- * If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}\n- * on an ObjectInputStream, the {@link ObjectInputFilter} can check that\n- * the classes, array lengths, number of references in the stream, depth, and\n- * number of bytes consumed from the input stream are allowed and\n- * if not, can terminate deserialization.\n- * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}\n- * can be configured that is applied to each {@code ObjectInputStream} unless replaced\n- * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.\n- *\n@@ -350,0 +358,5 @@\n+    \/**\n+     * True if the stream-specific filter has been set; initially false.\n+     *\/\n+    private boolean streamFilterSet;\n+\n@@ -356,2 +369,3 @@\n-     * <p>The serialization filter is initialized to the value of\n-     * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.\n+     * <p>The constructor initializes the deserialization filter to the filter returned\n+     * by invoking the {@link Config#getSerialFilterFactory()} with {@code null} for the current filter\n+     * and the {@linkplain Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -380,1 +394,2 @@\n-        serialFilter = ObjectInputFilter.Config.getSerialFilter();\n+        streamFilterSet = false;\n+        serialFilter = Config.getSerialFilterFactorySingleton().apply(null, Config.getSerialFilter());\n@@ -391,2 +406,3 @@\n-     * <p>The serialization filter is initialized to the value of\n-     * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.\n+     * <p>The constructor initializes the deserialization filter to the filter returned\n+     * by invoking the {@link Config#getSerialFilterFactory()} with {@code null} for the current filter\n+     * and the {@linkplain Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -414,1 +430,2 @@\n-        serialFilter = ObjectInputFilter.Config.getSerialFilter();\n+        streamFilterSet = false;\n+        serialFilter = Config.getSerialFilterFactorySingleton().apply(null, Config.getSerialFilter());\n@@ -433,1 +450,1 @@\n-     * <p>The serialization filter, when not {@code null}, is invoked for\n+     * <p>The deserialization filter, when not {@code null}, is invoked for\n@@ -445,1 +462,1 @@\n-     *          serialization.\n+     *          deserialization.\n@@ -566,1 +583,1 @@\n-     * <p>The serialization filter, when not {@code null}, is invoked for\n+     * <p>The deserialization filter, when not {@code null}, is invoked for\n@@ -874,1 +891,1 @@\n-     * field or array element abort the serialization by raising an exception\n+     * field or array element abort the deserialization by raising an exception\n@@ -1224,5 +1241,5 @@\n-     * Returns the serialization filter for this stream.\n-     * The serialization filter is the most recent filter set in\n-     * {@link #setObjectInputFilter setObjectInputFilter} or\n-     * the initial system-wide filter from\n-     * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.\n+     * Returns the deserialization filter for this stream.\n+     * The filter is the result of invoking the\n+     * {@link Config#getSerialFilterFactory() JVM-wide filter factory}\n+     * either by the {@linkplain #ObjectInputStream() constructor} or the most recent invocation of\n+     * {@link #setObjectInputFilter setObjectInputFilter}.\n@@ -1230,1 +1247,1 @@\n-     * @return the serialization filter for the stream; may be null\n+     * @return the deserialization filter for the stream; may be null\n@@ -1238,2 +1255,12 @@\n-     * Set the serialization filter for the stream.\n-     * The filter's {@link ObjectInputFilter#checkInput checkInput} method is called\n+     * Set the deserialization filter for the stream.\n+     * The filter can be set and only set once before reading any objects from the stream;\n+     * for example, by calling {@link #readObject} or {@link #readUnshared}.\n+     *\n+     * <p>The deserialization filter is set to the filter returned\n+     * by invoking the {@linkplain Config#getSerialFilterFactory() JVM-wide filter factory}\n+     * with the current filter and the {@code filter} parameter.\n+     * If there is a non-null filter for the stream, one was set in the constructor, and the filter factory\n+     * must return a non-null filter. It is not permitted to remove filtering once established.\n+     * See the {@linkplain ObjectInputFilter filter models} for examples of composition and delegation.\n+     *\n+     * <p>The filter's {@link ObjectInputFilter#checkInput checkInput} method is called\n@@ -1248,2 +1275,2 @@\n-     * The filter is invoked only when reading objects from the stream and for\n-     * not primitives.\n+     * The filter is invoked only when reading objects from the stream and not for\n+     * primitives.\n@@ -1256,7 +1283,0 @@\n-     * <p>\n-     * The serialization filter is initialized to the value of\n-     * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}\n-     * when the {@code  ObjectInputStream} is constructed and can be set\n-     * to a custom filter only once.\n-     * The filter must be set before reading any objects from the stream;\n-     * for example, by calling {@link #readObject} or {@link #readUnshared}.\n@@ -1304,3 +1324,4 @@\n-     * @throws IllegalStateException if the {@linkplain #getObjectInputFilter() current filter}\n-     *       is not {@code null} and is not the system-wide filter, or\n-     *       if an object has been read\n+     * @throws IllegalStateException if an object has been read,\n+     *       if the filter factory returns {@code null} when the\n+     *       {@linkplain #getObjectInputFilter() current filter} is non-null, or\n+     *       if the filter has already been set.\n@@ -1312,0 +1333,1 @@\n+            \/\/ TBD double checks, here and in the default serialFilterFactory\n@@ -1314,5 +1336,0 @@\n-        \/\/ Allow replacement of the system-wide filter if not already set\n-        if (serialFilter != null &&\n-                serialFilter != ObjectInputFilter.Config.getSerialFilter()) {\n-            throw new IllegalStateException(\"filter can not be set more than once\");\n-        }\n@@ -1323,1 +1340,11 @@\n-        this.serialFilter = filter;\n+        if (streamFilterSet) {\n+            throw new IllegalStateException(\"filter can not be replaced\");\n+        }\n+        streamFilterSet = true;\n+        \/\/ Delegate to serialFilterFactory to compute stream filter\n+        ObjectInputFilter next = Config.getSerialFilterFactory()\n+                .apply(serialFilter, filter);\n+        if (serialFilter != null && next == null) {\n+            throw new IllegalStateException(\"filter can not be replaced with null filter\");\n+        }\n+        serialFilter = next;\n@@ -1327,1 +1354,1 @@\n-     * Invokes the serialization filter if non-null.\n+     * Invokes the deserialization filter if non-null.\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":74,"deletions":47,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private static final String JDK_SERIAL_FILTER_FACTORY;\n@@ -65,0 +66,1 @@\n+        JDK_SERIAL_FILTER_FACTORY = getProperty(props, \"jdk.serialFilterFactory\", null);\n@@ -187,0 +189,14 @@\n+\n+    \/**\n+     * Return the {@code jdk.serialFilterFactory} system property.\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method. The caller of this method should take care to ensure\n+     * that the returned property is not made accessible to untrusted code.<\/strong>\n+     *\n+     * @return the {@code user.name} system property\n+     *\/\n+    public static String jdkSerialFilterFactory() {\n+        return JDK_SERIAL_FILTER_FACTORY;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -982,0 +982,12 @@\n+\n+#\n+# Deserialization system-wide filter factory\n+#\n+# A filter factory class name is used to configure the system-wide filter factory.\n+# The class must be public, must have a public zero-argument constructor, implement the\n+# java.util.stream.BinaryOperator<ObjectInputFilter> interface, provide its implementation and\n+# be accessible via the application class loader.\n+# See java.io.ObjectInputFilter for more information.\n+#\n+#jdk.serialFilterFactory=<classname>\n+\n@@ -983,1 +995,1 @@\n-# Serialization system-wide filter\n+# Deserialization system-wide filter\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,889 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InvalidClassException;\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.Status;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Predicate;\n+\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n+\n+\/* @test\n+ * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFactoryExample\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFactoryExample$FilterInThread -Djdk.serialFilterTrace=true SerialFactoryExample\n+ * @summary Test SerialFactoryExample\n+ *\/\n+\n+\/*\n+ * Context-specific Deserialization Filter Example\n+ *\n+ * To protect deserialization of a thread or a call to an untrusted library function,\n+ * a filter is set that applies to every deserialization within the thread.\n+ *\n+ * The `doWithSerialFilter` method arguments are a serial filter and\n+ * a lambda to invoke with the filter in force.  Its implementation creates a stack of filters\n+ * using a `ThreadLocal`. The stack of filters is composed with the static JVM-wide filter,\n+ * and an optional stream-specific filter.\n+ *\n+ * The FilterInThread filter factory is set as the JVM-wide filter factory.\n+ * When the filter factory is invoked during the construction of each `ObjectInputStream`,\n+ * it retrieves the filter(s) from the thread local and combines it with the static JVM-wide filter,\n+ * and the stream-specific filter.\n+ *\n+ * If more than one filter is to be applied to the stream, two filters can be composed\n+ * using `ObjectInputFilter.merge`.  When invoked, each of the filters is invoked and the results\n+ * are combined such that if either filter rejects a class, the result is rejected.\n+ * If either filter allows the class, then it is allowed, otherwise it is undecided.\n+ * Hierarchies and chains of filters can be built using `ObjectInputFilter.merge`.\n+ *\n+ * The `doWithSerialFilter` calls can be nested. When nested, the filters are concatenated.\n+ *\/\n+@Test\n+public class SerialFactoryExample {\n+\n+    private static final Class<? extends Exception> NO_EXCEPTION = null;\n+\n+    @DataProvider(name = \"Examples\")\n+    static Object[][] examples() {\n+        return new Object[][]{\n+                {new Point(1, 2), null,\n+                        ALLOWED},\n+                {new Point(1, 2), ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        ALLOWED},\n+                {Integer.valueOf(10), Filters.allowPlatformClasses(),\n+                        ALLOWED},          \/\/ Integer is a platform class\n+                {new int[10], ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        UNDECIDED},          \/\/ arrays of primitives are UNDECIDED -> allowed\n+                {int.class, ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        UNDECIDED},          \/\/ primitive classes are UNDECIDED -> allowed\n+                {new Point[] {new Point(1, 1)}, ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        ALLOWED},          \/\/ Arrays of allowed classes are allowed\n+                {new Integer[10], ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        REJECTED},   \/\/ Base component type is checked -> REJECTED\n+                {new Point(1, 2), ObjectInputFilter.Config.createFilter(\"!SerialFactoryExample$Point\"),\n+                        REJECTED},   \/\/ Denied\n+                {new Point(1, 3), Filters.allowPlatformClasses(),\n+                        REJECTED},   \/\/ Not a platform class\n+                {new Point(1, 4), ObjectInputFilter.Config.createFilter(\"java.lang.Integer\"),\n+                        REJECTED},   \/\/ Only Integer is ALLOWED\n+                {new Point(1, 5), ObjectInputFilter.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader(), UNDECIDED),\n+                        REJECTED},   \/\/ Not platform loader is UNDECIDED -> a class that should not be undecided -> rejected\n+        };\n+    }\n+\n+\n+    @Test(dataProvider = \"Examples\")\n+    void examples(Serializable obj, ObjectInputFilter filter, Status expected) {\n+        \/\/ Establish FilterInThread as the application-wide filter factory\n+        FilterInThread filterInThread;\n+        if (ObjectInputFilter.Config.getSerialFilterFactory() instanceof FilterInThread fit) {\n+            \/\/ Filter factory selected on the command line with -Djdk.serialFilterFactory=<classname>\n+            filterInThread = fit;\n+        } else {\n+            \/\/ Create a FilterInThread filter factory and set\n+            \/\/ An IllegalStateException will be thrown if the filter factory was already\n+            \/\/ initialized to an incompatible filter factory.\n+            filterInThread = new FilterInThread();\n+            ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+        }\n+        try {\n+            filterInThread.doWithSerialFilter(filter, () -> {\n+                byte[] bytes = writeObject(obj);\n+                Object o = deserializeObject(bytes);\n+            });\n+            if (expected.equals(REJECTED))\n+                Assert.fail(\"IllegalClassException should have occurred\");\n+        } catch (UncheckedIOException uioe) {\n+            IOException ioe = uioe.getCause();\n+            Assert.assertEquals(ioe.getClass(), InvalidClassException.class, \"Wrong exception\");\n+            Assert.assertTrue(expected.equals(REJECTED), \"Exception should not have occurred\");\n+        }\n+    }\n+\n+    \/**\n+     * Test various filters with various objects and the resulting status\n+     * @param obj an object\n+     * @param filter a filter\n+     * @param expected status\n+     *\/\n+    @Test(dataProvider = \"Examples\")\n+    void checkStatus(Serializable obj, ObjectInputFilter filter, Status expected) {\n+        \/\/ Establish FilterInThread as the application-wide filter factory\n+        FilterInThread filterInThread;\n+        if (ObjectInputFilter.Config.getSerialFilterFactory() instanceof FilterInThread fit) {\n+            \/\/ Filter factory selected on the command line with -Djdk.serialFilterFactory=<classname>\n+            filterInThread = fit;\n+        } else {\n+            \/\/ Create a FilterInThread filter factory and set\n+            \/\/ An IllegalStateException will be thrown if the filter factory was already\n+            \/\/ initialized to an incompatible filter factory.\n+            filterInThread = new FilterInThread();\n+            ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+        }\n+\n+        try {\n+            filterInThread.doWithSerialFilter(filter, () -> {\n+                \/\/ Classes are serialized as themselves, otherwise pass the object's class\n+                Class<?> clazz = (obj instanceof Class<?>) ? (Class<?>)obj : obj.getClass();\n+                ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+                var compositeFilter = filterInThread.apply(null, ObjectInputFilter.Config.getSerialFilter());\n+                System.out.println(\"    filter in effect: \" + filterInThread.currFilter);\n+                if (compositeFilter != null) {\n+                    Status actualStatus = compositeFilter.checkInput(info);\n+                    Assert.assertEquals(actualStatus, expected, \"Wrong Status\");\n+                }\n+            });\n+\n+        } catch (Exception ex) {\n+            Assert.fail(\"unexpected exception\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * A Context-specific Deserialization Filter Factory to create filters that apply\n+     * a serial filter to all of the deserializations performed in a thread.\n+     * The purpose is to establish a deserialization filter that will reject all classes\n+     * that are not explicitly included.\n+     * <p>\n+     * The filter factory creates a composite filter of the stream-specific filter,\n+     * the thread-specific filter, the static JVM-wide filter, and a filter to reject all UNDECIDED cases.\n+     * The static JVM-wide filter is always included, if it is configured;\n+     * see ObjectInputFilter.Config.getSerialFilter().\n+     * <p>\n+     * To enable these protections the FilterInThread instance should be set as the\n+     * JVM-wide filter factory in ObjectInputFilter.Config.setSerialFilterFactory.\n+     *\n+     * The {@code doWithSerialFilter} is invoked with a serial filter and a lambda\n+     * to be invoked after the filter is applied.\n+     *\/\n+    public static final class FilterInThread\n+            implements BinaryOperator<ObjectInputFilter> {\n+\n+        \/\/ ThreadLocal holding the Deque of serial filters to be applied, not null\n+        private final ThreadLocal<ArrayDeque<ObjectInputFilter>> filterThreadLocal =\n+                ThreadLocal.withInitial(() -> new ArrayDeque<>());\n+\n+        private ObjectInputFilter currFilter;\n+\n+        \/**\n+         * Construct a FilterInThread deserialization filter factory.\n+         * The constructor is public so FilterInThread can be set on the command line\n+         * with {@code -Djdk.serialFilterFactory=SerialFactoryExample$FilterInThread}.\n+         *\/\n+        public FilterInThread() {\n+        }\n+\n+        \/**\n+         * Applies the filter to the thread and invokes the runnable.\n+         * The filter is pushed to a ThreadLocal, saving the old value.\n+         * If there was a previous thread filter, the new filter is appended\n+         * and made the active filter.\n+         * The runnable is invoked.\n+         * The previous filter is restored to the ThreadLocal.\n+         *\n+         * @param filter the serial filter to apply\n+         * @param runnable a runnable to invoke\n+         *\/\n+        public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+            var prevFilters = filterThreadLocal.get();\n+            try {\n+                if (filter != null)\n+                    prevFilters.addLast(filter);\n+                runnable.run();\n+            } finally {\n+                if (filter != null) {\n+                    var lastFilter = prevFilters.removeLast();\n+                    assert lastFilter == filter : \"Filter removed out of order\";\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Returns a composite filter of the stream-specific filter, the thread-specific filter,\n+         * the static JVM-wide filter, and a filter to reject all UNDECIDED cases.\n+         * The purpose is to establish a deserialization filter that will reject all classes\n+         * that are not explicitly included.\n+         * The static JVM-wide filter is always checked, if it is configured;\n+         * see ObjectInputFilter.Config.getSerialFilter().\n+         * Any or all of the filters are optional and if not supplied or configured are null.\n+         * <p>\n+         * This method is first called from the constructor with current == null and\n+         * next == static JVM-wide filter.\n+         * The filter returned is the static JVM-wide filter merged with the thread-specific filter\n+         * and followed by a filter to map all UNDECIDED status values to REJECTED.\n+         * This last step ensures that the collective group of filters covers every possible case,\n+         * any classes that are not ALLOWED will be REJECTED.\n+         * <p>\n+         * The method mayy be called a second time from {@code ObjectInputStream.setObjectInputFilter(next)}\n+         * to add a stream-specific filter.  The stream-specific filter is prepended to the\n+         * composite filter created above when called from the constructor.\n+         * <p>\n+         *\n+         * @param curr the current filter, may be null\n+         * @param next the next filter, may be null\n+         * @return a deserialization filter to use for the stream, may be null\n+         *\/\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            if (curr == null) {\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no current filter\n+                \/\/ no current filter, prepend next to threadFilter, both may be null or non-null\n+\n+                \/\/ Assemble the filters in sequence, most recently added first\n+                var filters = filterThreadLocal.get();\n+                ObjectInputFilter filter = null;\n+                for (ObjectInputFilter f : filters) {\n+                    filter = ObjectInputFilter.merge(f, filter);\n+                }\n+                if (next != null) {\n+                    \/\/ Prepend a filter to reject all UNDECIDED results\n+                    if (filter != null) {\n+                        filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+                    }\n+\n+                    \/\/ Prepend the next filter to the thread filter, if any\n+                    \/\/ Initially this would be the static JVM-wide filter passed from the OIS constructor\n+                    \/\/ The static JVM-wide filter allow, reject, or leave classes undecided\n+                    filter = ObjectInputFilter.merge(next, filter);\n+                }\n+                \/\/ Check that the static JVM-wide filter did not leave any classes undecided\n+                if (filter != null) {\n+                    \/\/ Append the filter to reject all UNDECIDED results\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+                }\n+                \/\/ Return the filter, unless a stream-specific filter is set later\n+                \/\/ The filter may be null if no filters are configured\n+                currFilter = filter;\n+                return currFilter;\n+            } else {\n+                \/\/ Called from OIS.setObjectInputFilter with a previously set filter.\n+                \/\/ The curr filter already incorporates the thread filter and rejection of undecided status\n+                \/\/ Prepend the stream-specific filter or the current filter if no stream-specific filter\n+                currFilter = (next == null) ? curr : ObjectInputFilter.rejectUndecidedClass(ObjectInputFilter.merge(next, curr));\n+                return currFilter;\n+            }\n+        }\n+        public String toString() {\n+            return Objects.toString(currFilter, \"none\");\n+        }\n+    }\n+\n+\n+    \/**\n+     * Simple example code from the ObjectInputFilter Class javadoc.\n+     *\/\n+    public static final class SimpleFilterInThread implements BinaryOperator<ObjectInputFilter> {\n+\n+        \/\/ ThreadLocal to hold the serial filter to be applied\n+        private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new ThreadLocal<>();\n+\n+        \/\/ Construct a FilterInThread deserialization filter factory.\n+        public SimpleFilterInThread() {}\n+\n+        \/**\n+         * The filter factory, which is invoked every time a new ObjectInputStream\n+         * is created.  If a per-stream filter is already set then it returns a\n+         * filter that combines the results of invoking each filter.\n+         *\n+         * @param curr the current filter on the stream\n+         * @param next a per stream filter\n+         * @return the selected filter\n+         *\/\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            if (curr == null) {\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no current filter\n+                var filter = filterThreadLocal.get();\n+                if (filter != null) {\n+                    \/\/ Prepend a filter to assert that all classes have been Allowed or Rejected\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+                }\n+                if (next != null) {\n+                    \/\/ Prepend the next filter to the thread filter, if any\n+                    \/\/ Initially this is the static JVM-wide filter passed from the OIS constructor\n+                    \/\/ Append the filter to reject all UNDECIDED results\n+                    filter = ObjectInputFilter.merge(next, filter);\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+                }\n+                return filter;\n+            } else {\n+                \/\/ Called from OIS.setObjectInputFilter with a current filter and a stream-specific filter.\n+                \/\/ The curr filter already incorporates the thread filter and static JVM-wide filter\n+                \/\/ and rejection of undecided classes\n+                \/\/ If there is a stream-specific filter prepend it and a filter to recheck for undecided\n+                if (next != null) {\n+                    next = ObjectInputFilter.merge(next, curr);\n+                    next = ObjectInputFilter.rejectUndecidedClass(next);\n+                    return next;\n+                }\n+                return curr;\n+            }\n+        }\n+\n+        \/**\n+         * Apply the filter and invoke the runnable.\n+         *\n+         * @param filter the serial filter to apply to every deserialization in the thread\n+         * @param runnable a Runnable to invoke\n+         *\/\n+        public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+            var prevFilter = filterThreadLocal.get();\n+            try {\n+                filterThreadLocal.set(filter);\n+                runnable.run();\n+            } finally {\n+                filterThreadLocal.set(prevFilter);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Write an object and return a byte array with the bytes.\n+     *\n+     * @param object object to serialize\n+     * @return the byte array of the serialized object\n+     * @throws UncheckedIOException if an exception occurs\n+     *\/\n+    private static byte[] writeObject(Object object) {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(object);\n+            return baos.toByteArray();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Deserialize an object.\n+     *\n+     * @param bytes an object.\n+     * @throws UncheckedIOException for I\/O exceptions and ClassNotFoundException\n+     *\/\n+    private static Object deserializeObject(byte[] bytes) {\n+        try {\n+            InputStream is = new ByteArrayInputStream(bytes);\n+            ObjectInputStream ois = new ObjectInputStream(is);\n+            System.out.println(\"  filter in effect: \" + ois.getObjectInputFilter());\n+            return ois.readObject();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new UncheckedIOException(new InvalidClassException(cnfe.getMessage()));\n+        }\n+    }\n+\n+\n+    \/**\n+     * ObjectInputFilter utilities to create filters that combine the results of other filters.\n+     *\/\n+    public static final class Filters {\n+        \/**\n+         * Returns a filter that returns {@code Status.ALLOWED} if the predicate\n+         * on the class is {@code true}.\n+         * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+         * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+         *\n+         * <p>When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+         * the predicate is applied to the {@link ObjectInputFilter.FilterInfo#serialClass() info.serialClass()},\n+         * the return Status is:\n+         * <ul>\n+         *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+         * <\/ul>\n+         * <p>\n+         * Example, to create a filter that will allow any class loaded from the platform classloader.\n+         * <pre><code>\n+         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n+         *                                          || cl.getClassLoader() == null, Status.UNDECIDED);\n+         * <\/code><\/pre>\n+         *\n+         * @param predicate a predicate to test a non-null Class, non-null\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return a filter than returns {@code ALLOWED} if the predicate on the class returns {@code true},\n+         *          otherwise the {@code otherStatus}\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new PredicateFilter(predicate, ALLOWED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns {@code Status.REJECTED} if the predicate\n+         * on the class is {@code true}.\n+         * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+         * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+         * the predicate is applied to the {@link ObjectInputFilter.FilterInfo#serialClass() serialClass()},\n+         * the return Status is:\n+         * <ul>\n+         *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#REJECTED REJECTED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+         * <\/ul>\n+         * <p>\n+         * Example, to create a filter that will reject any class loaded from the application classloader.\n+         * <pre><code>\n+         *     ObjectInputFilter f = rejectFilter(cl ->\n+         *          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);\n+         * <\/code><\/pre>\n+         *\n+         * @param predicate a predicate to test a non-null Class, non-null\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return returns a filter that returns {@link Status#REJECTED REJECTED} if the predicate on the class\n+         *          returns {@code true}, otherwise {@link Status#UNDECIDED UNDECIDED}\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new PredicateFilter(predicate, REJECTED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns {@code Status.ALLOWED} if the check is for limits\n+         * and not checking a class; otherwise {@code Status.UNDECIDED}.\n+         * If the {@link ObjectInputFilter.FilterInfo#serialClass() serialClass()} is {@code null}, the filter returns\n+         * {@code Status.ALLOWED}, otherwise return {@code Status.UNDECIDED}.\n+         * The limit values of {@link ObjectInputFilter.FilterInfo#arrayLength() arrayLength()},\n+         * {@link ObjectInputFilter.FilterInfo#depth() depth()}, {@link ObjectInputFilter.FilterInfo#references() references()},\n+         * and {@link ObjectInputFilter.FilterInfo#streamBytes() streamBytes()} are not checked.\n+         * To place a limit, create a separate filter with limits such as:\n+         * <pre>{@code\n+         * Config.createFilter(\"maxarray=10000,maxdepth=40\");\n+         * }<\/pre>\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput} method is invoked,\n+         * the Status returned is:\n+         * <ul>\n+         *     <li>{@link Status#ALLOWED ALLOWED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @return a filter that returns {@code Status.ALLOWED} if the check is for limits\n+         *          and not checking a class; otherwise {@code Status.UNDECIDED}\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter allowMaxLimits() {\n+            return new AllowMaxLimitsFilter(ALLOWED, UNDECIDED);\n+        }\n+\n+        \/**\n+         * Returns a filter that merges the status of a filter and another filter.\n+         * If the other filter is {@code null}, the filter is returned.\n+         * Otherwise, a filter is returned to merge the pair of {@code non-null} filters.\n+         *\n+         * The filter returned implements the {@link ObjectInputFilter#checkInput(ObjectInputFilter.FilterInfo)} method\n+         * as follows:\n+         * <ul>\n+         *     <li>Invoke {@code filter} on the {@code FilterInfo} to get its {@code status};\n+         *     <li>Return {@code REJECTED} if the {@code status} is {@code REJECTED};\n+         *     <li>Invoke the {@code otherFilter} to get the {@code otherStatus};\n+         *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n+         *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n+         *          is {@code ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter a filter, non-null\n+         * @param anotherFilter a filter to be merged with the filter, may be {@code null}\n+         * @return an {@link ObjectInputFilter} that merges the status of the filter and another filter\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter) {\n+            Objects.requireNonNull(filter, \"filter\");\n+            return (anotherFilter == null) ? filter : new MergeFilter(filter, anotherFilter);\n+        }\n+\n+        \/**\n+         * Returns a filter that invokes a filter and maps {@code UNDECIDED} to {@code REJECTED}\n+         * for classes, with some exceptions, and otherwise returns the status.\n+         * The filter returned checks that classes not {@code ALLOWED} and not {@code REJECTED} by the filter\n+         * are {@code REJECTED}, if the class is an array and the base component type is not allowed,\n+         * otherwise the result is {@code UNDECIDED}.\n+         *\n+         * <p>\n+         * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n+         * Adding a filter to reject undecided results for classes that have not been\n+         * either allowed or rejected can prevent classes from slipping through the filter.\n+         *\n+         * @implSpec\n+         * The filter returned implements the {@link ObjectInputFilter#checkInput(ObjectInputFilter.FilterInfo)} method\n+         * as follows:\n+         * <ul>\n+         *     <li>Invoke the filter on the {@code FilterInfo} to get its {@code status};\n+         *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n+         *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n+         *          is {@code null};\n+         *     <li>Determine the base component type if the {@code serialClass} is\n+         *          an {@linkplain Class#isArray() array};\n+         *     <li>Return {@code UNDECIDED} if the base component type is\n+         *          a {@linkplain Class#isPrimitive() primitive class};\n+         *     <li>Invoke the filter on the {@code base component type} to get its\n+         *          {@code component status};<\/li>\n+         *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n+         *     <li>Otherwise, return {@code REJECTED}.<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter a filter, non-null\n+         * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n+         *      status to {@link Status#REJECTED} for classes, otherwise returns the\n+         *      filter status\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter) {\n+            Objects.requireNonNull(filter, \"filter\");\n+            return new RejectUndecidedFilter(filter);\n+        }\n+\n+        \/**\n+         * Returns a filter that allows a class only if the class was loaded by the platform class loader.\n+         * Otherwise, it returns UNDECIDED; leaving the choice to another filter.\n+         * @return a filter that allows a class only if the class was loaded by the platform class loader\n+         *\/\n+        public static ObjectInputFilter allowPlatformClasses() {\n+            return new AllowPlatformClassFilter();\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate a predicate mapping a class to a boolean.\n+         *\/\n+        private static class PredicateFilter implements ObjectInputFilter {\n+            private final Predicate<Class<?>> predicate;\n+            private final Status ifTrueStatus;\n+            private final Status ifFalseStatus;\n+\n+            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus, Status ifFalseStatus) {\n+                this.predicate = predicate;\n+                this.ifTrueStatus = ifTrueStatus;\n+                this.ifFalseStatus = ifFalseStatus;\n+            }\n+\n+            \/**\n+             * Apply the predicate to the class being deserialized, if the class is non-null\n+             * and if it returns {@code true}, return the requested status. Otherwise, return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of applying the predicate, otherwise {@code UNDECIDED}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Class<?> clazz = info.serialClass();\n+                Status status = (clazz != null && predicate.test(clazz)) ? ifTrueStatus : ifFalseStatus;\n+                return status;\n+            }\n+\n+            public String toString() {\n+                return \"predicate(\" + predicate + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate if a FilterInfo is checking only limits,\n+         * and not classes.\n+         *\/\n+        private static class AllowMaxLimitsFilter implements ObjectInputFilter {\n+            private final Status limitCheck;\n+            private final Status classCheck;\n+\n+            AllowMaxLimitsFilter(Status limitCheck, Status classCheck) {\n+                this.limitCheck = limitCheck;\n+                this.classCheck = classCheck;\n+            }\n+\n+            \/**\n+             * If the FilterInfo is only checking a limit, return the requested\n+             * status, otherwise the other status.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of corresponding to serialClass == null or not\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                return (info.serialClass() == null) ? limitCheck : classCheck;\n+            }\n+\n+            public String toString() {\n+                return \"allowMaxLimits()\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the status of two filters.\n+         *\/\n+        private static class MergeFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter first;\n+            private final ObjectInputFilter second;\n+\n+            MergeFilter(ObjectInputFilter first, ObjectInputFilter second) {\n+                this.first = first;\n+                this.second = second;\n+            }\n+\n+            \/**\n+             * Returns REJECTED if either of the filters returns REJECTED,\n+             * and ALLOWED if either of the filters returns ALLOWED.\n+             * Returns {@code UNDECIDED} if either filter returns {@code UNDECIDED}.\n+             *\n+             * @param info the FilterInfo\n+             * @return Status.REJECTED if either of the filters returns REJECTED,\n+             * and ALLOWED if either filter returns ALLOWED; otherwise returns\n+             * {@code UNDECIDED} if both filters returned {@code UNDECIDED}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status firstStatus = Objects.requireNonNull(first.checkInput(info), \"status\");\n+                if (REJECTED.equals(firstStatus)) {\n+                    return REJECTED;\n+                }\n+                Status secondStatus = Objects.requireNonNull(second.checkInput(info), \"other status\");\n+                if (REJECTED.equals(secondStatus)) {\n+                    return REJECTED;\n+                }\n+                if (ALLOWED.equals(firstStatus) || ALLOWED.equals(secondStatus)) {\n+                    return ALLOWED;\n+                }\n+                return UNDECIDED;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"merge(\" + first + \", \" + second + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * A filter that maps the status {@code UNDECIDED} to {@code REJECTED} when checking a class.\n+         *\/\n+        private static class RejectUndecidedFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter filter;\n+\n+            private RejectUndecidedFilter(ObjectInputFilter filter) {\n+                this.filter = Objects.requireNonNull(filter, \"filter\");\n+            }\n+\n+            \/**\n+             * Apply the filter and return the status if not UNDECIDED and checking a class.\n+             * For array classes, re-check the final component type against the filter.\n+             * Make an exception for Primitive classes that are implicitly allowed by the pattern based filter.\n+             * @param info the FilterInfo\n+             * @return the status of applying the filter and checking the class\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status status = Objects.requireNonNull(filter.checkInput(info), \"status\");\n+                Class<?> clazz = info.serialClass();\n+                if (clazz == null || !UNDECIDED.equals(status))\n+                    return status;\n+                status = REJECTED;\n+                \/\/ Find the base component type\n+                while (clazz.isArray()) {\n+                    clazz = clazz.getComponentType();\n+                }\n+                if (clazz.isPrimitive()) {\n+                    status = UNDECIDED;\n+                } else {\n+                    \/\/ for non-primitive types;  re-filter the base component type\n+                    FilterInfo clazzInfo = new SerialInfo(info, clazz);\n+                    Status clazzStatus = filter.checkInput(clazzInfo);\n+                    status = (ALLOWED.equals(clazzStatus)) ? ALLOWED : REJECTED;\n+                }\n+                return status;\n+            }\n+\n+            public String toString() {\n+                return \"rejectUndecidedClass(\" + filter + \")\";\n+            }\n+\n+            \/**\n+             * FilterInfo instance with a specific class and delegating to an existing FilterInfo.\n+             * Nested in the rejectUndecided class.\n+             *\/\n+            static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+                private final FilterInfo base;\n+                private final Class<?> clazz;\n+\n+                SerialInfo(FilterInfo base, Class<?> clazz) {\n+                    this.base = base;\n+                    this.clazz = clazz;\n+                }\n+\n+                @Override\n+                public Class<?> serialClass() {\n+                    return clazz;\n+                }\n+\n+                @Override\n+                public long arrayLength() {\n+                    return base.arrayLength();\n+                }\n+\n+                @Override\n+                public long depth() {\n+                    return base.depth();\n+                }\n+\n+                @Override\n+                public long references() {\n+                    return base.references();\n+                }\n+\n+                @Override\n+                public long streamBytes() {\n+                    return base.streamBytes();\n+                }\n+            }\n+\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the results of two filters.\n+         *\/\n+        private static class MergeManyFilter implements ObjectInputFilter {\n+            private final List<ObjectInputFilter> filters;\n+            private final Status otherStatus;\n+\n+            MergeManyFilter(List<ObjectInputFilter> first, Status otherStatus) {\n+                this.filters = Objects.requireNonNull(first, \"filters\");\n+                this.otherStatus = Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            }\n+\n+            \/**\n+             * Returns REJECTED if any of the filters returns REJECTED,\n+             * and ALLOWED if any of the filters returns ALLOWED.\n+             * Returns UNDECIDED if there is no class to be checked or all filters return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return Status.UNDECIDED if there is no class to check,\n+             *      Status.REJECTED if any of the filters returns REJECTED,\n+             *      Status.ALLOWED if any filter returns ALLOWED;\n+             *      otherwise returns {@code otherStatus}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                if (info.serialClass() == null)\n+                    return UNDECIDED;\n+                Status status = otherStatus;\n+                for (ObjectInputFilter filter : filters) {\n+                    Status aStatus = filter.checkInput(info);\n+                    if (REJECTED.equals(aStatus)) {\n+                        return REJECTED;\n+                    }\n+                    if (ALLOWED.equals(aStatus)) {\n+                        status = ALLOWED;\n+                    }\n+                }\n+                return status;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"mergeManyFilter(\" + filters + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that allows a class only if the class was loaded by the platform class loader.\n+         * Otherwise, it returns undecided; leaving the choice to another filter.\n+         *\/\n+        private static class AllowPlatformClassFilter implements ObjectInputFilter {\n+\n+            \/**\n+             * Returns ALLOWED only if the class, if non-null, was loaded by the platformClassLoader.\n+             *\n+             * @param filter the FilterInfo\n+             * @return Status.ALLOWED only if the class loader of the class was the PlatformClassLoader;\n+             * otherwise Status.UNDECIDED\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo filter) {\n+                final Class<?> serialClass = filter.serialClass();\n+                return (serialClass != null &&\n+                        (serialClass.getClassLoader() == null ||\n+                        ClassLoader.getPlatformClassLoader().equals(serialClass.getClassLoader())))\n+                        ? ObjectInputFilter.Status.ALLOWED\n+                        : ObjectInputFilter.Status.UNDECIDED;\n+            }\n+\n+            public String toString() {\n+                return \"allowPlatformClasses\";\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * FilterInfo instance with a specific class.\n+     *\/\n+    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+        private final Class<?> clazz;\n+\n+        SerialInfo(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        @Override\n+        public Class<?> serialClass() {\n+            return clazz;\n+        }\n+\n+        @Override\n+        public long arrayLength() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long depth() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long references() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long streamBytes() {\n+            return 0;\n+        }\n+    }\n+\n+    \/**\n+     * A test class.\n+     *\/\n+    static record Point(int x, int y) implements Serializable {\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":889,"deletions":0,"binary":false,"changes":889,"status":"added"},{"patch":"@@ -0,0 +1,412 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.Config;\n+import java.io.ObjectInputFilter.FilterInfo;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serial;\n+import java.io.Serializable;\n+import java.io.SerializablePermission;\n+import java.security.AccessControlException;\n+import java.security.Permission;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Predicate;\n+\n+import static java.io.ObjectInputFilter.Status;\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n+\n+\/* @test\n+ * @build SerialFilterFactoryTest\n+ * @run testng\/othervm  SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilter=\"*\" SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$PropertyFilterFactory SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$NotMyFilterFactory SerialFilterFactoryTest\n+ * @run testng\/othervm\/policy=security.policy\n+ *        -Djava.security.properties=${test.src}\/java.security-extra-factory\n+ *        -Djava.security.debug=properties SerialFilterFactoryTest\n+ * @run testng\/othervm\/fail  -Djdk.serialFilterFactory=ForcedError_NoSuchClass SerialFilterFactoryTest\n+ * @run testng\/othervm\/policy=security.policy SerialFilterFactoryTest\n+ * @run testng\/othervm\/policy=security.policy.without.globalFilter SerialFilterFactoryTest\n+\n+ *\n+ * @summary Test Context-specific Deserialization Filters\n+ *\/\n+@Test\n+public class SerialFilterFactoryTest {\n+\n+    \/\/ A stream with just the header, enough to create a OIS\n+    private static final byte[] simpleStream = simpleStream();\n+    private static final Validator v1 = new Validator(\"v1\");\n+    private static final Validator v2 = new Validator(\"v2\");\n+    private static final BinaryOperator<ObjectInputFilter> jdkSerialFilterFactory\n+            = Config.getSerialFilterFactory();\n+    private static final MyFilterFactory contextFilterFactory = new MyFilterFactory(\"DynFF\");\n+    private static final String jdkSerialFilterFactoryProp = System.getProperty(\"jdk.serialFilterFactory\");\n+\n+    \/**\n+     * Return a byte array with a simple stream containing an Dummy object.\n+     * @return  a byte with a simple serialization object\n+     *\/\n+    private static byte[] simpleStream() {\n+        ByteArrayOutputStream boas = new ByteArrayOutputStream();\n+        try (ObjectOutputStream ois = new ObjectOutputStream(boas)) {\n+            ois.writeObject(new Dummy(\"Here\"));\n+            return boas.toByteArray();\n+        } catch (IOException ioe) {\n+            Assert.fail(\"unexpected IOE\", ioe);\n+        }\n+        throw new RuntimeException(\"should not reach here\");\n+    }\n+\n+    \/**\n+     * Initialize the filter factory, supplying one if not already set.\n+     * Does not\/can not replace any MyFilterFactory.\n+     *\n+     * @param dynFilterFactory a filter factory to use if not already set\n+     * @return the filter factory in effect\n+     *\/\n+    private static MyFilterFactory setupFilterFactory(MyFilterFactory dynFilterFactory) {\n+        if ((Config.getSerialFilterFactory() instanceof MyFilterFactory ff))\n+            return ff;\n+        Config.setSerialFilterFactory(dynFilterFactory);\n+        return dynFilterFactory;\n+    }\n+\n+    \/\/ If the configured filter has not been set, set it\n+    \/\/ It can only be set once for the process, so avoid setting it again\n+    private static ObjectInputFilter setupFilter(ObjectInputFilter serialFilter) {\n+\n+        var configFilter = Config.getSerialFilter();\n+        if (configFilter == serialFilter || configFilter instanceof Validator)\n+            return configFilter;        \/\/ if already set or a type we can use, no change\n+\n+        if (configFilter == null && serialFilter != null) {\n+            Config.setSerialFilter(serialFilter);\n+            return serialFilter;        \/\/ none set already, set it\n+        }\n+\n+        return configFilter;\n+    }\n+\n+    private static boolean isValidFilterFactory() {\n+        return !(ObjectInputFilter.Config.getSerialFilterFactory() instanceof NotMyFilterFactory);\n+    }\n+\n+    \/**\n+     * Returns true if serialFilter actions are ok, either no SM or SM has serialFilter Permission\n+     *\/\n+    private static boolean hasFilterPerm() {\n+        boolean hasSerialPerm = true;\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            try {\n+                Permission p = new SerializablePermission(\"serialFilter\");\n+                sm.checkPermission(p);\n+                hasSerialPerm = true;\n+            } catch (AccessControlException ace2) {\n+                hasSerialPerm = false;      \/\/ SM and serialFilter not allowed\n+            }\n+        }\n+        return hasSerialPerm;\n+    }\n+\n+    @DataProvider(name=\"FilterCases\")\n+    static Object[][] filterCases() {\n+        if (isValidFilterFactory()) {\n+            return new Object[][]{\n+                    {contextFilterFactory, null, null},  \/\/ no overrides\n+                    {contextFilterFactory, v1, null},    \/\/ context filter\n+                    {contextFilterFactory, v1, v2},      \/\/ per stream filter\n+            };\n+        } else {\n+            \/\/ There are zero cases to run with an unknown filter factory. (NotMyFilterFactory)\n+            return new Object[0][0];\n+        }\n+    }\n+\n+    \/\/ Setting the filter factory to null is not allowed.\n+    @Test(expectedExceptions=NullPointerException.class)\n+    void testNull() {\n+        Config.setSerialFilterFactory(null);\n+    }\n+\n+    \/**\n+     * Setting and resetting the filter factory is not allowed.\n+     * The filter factory may have been on the command line (depending on which @run this is).\n+     * If the jdk.SerialFilterFactory is the built-in filter factory, set it once.\n+     * Try to set it again, the second should throw.\n+     *\/\n+    @Test\n+    void testSecondSetShouldThrow() {\n+        if (System.getSecurityManager() != null) {\n+            \/\/ Skip test when running with SM\n+            return;\n+        }\n+        var currFF = Config.getSerialFilterFactory();\n+        if (currFF.getClass().getClassLoader() == null) {\n+            try {\n+                \/\/ Not already set, set it\n+                Config.setSerialFilterFactory(contextFilterFactory);\n+                currFF = contextFilterFactory;\n+            } catch (IllegalStateException ise) {\n+                Assert.fail(\"First setSerialFilterFactory should not throw\");\n+            }\n+        }\n+        \/\/ Setting it again will throw\n+        Assert.expectThrows(IllegalStateException.class,\n+                () -> Config.setSerialFilterFactory(new MyFilterFactory(\"f11\")));\n+        var resetFF = Config.getSerialFilterFactory();\n+        Assert.assertEquals(resetFF, currFF, \"Setting again should not change filter factory\");\n+    }\n+\n+    \/**\n+     * Test that the filter factory is set when expected and is called when expected.\n+     * This test only covers the cases when a filter factory is supplied\n+     * either via a command line property or via the API.\n+     * The cases where the builtin filter factory applies are tested in SerialFilterTest.\n+     *\n+     * @param dynFilterFactory a FilterFactory to set\n+     * @param dynFilter a serial filter to be used for the configured filter\n+     * @param streamFilter a serial filter to be used for the stream filter\n+     * @throws IOException if an I\/O error occurs (should not occur)\n+     * @throws ClassNotFoundException for class not found (should not occur)\n+     *\/\n+    @Test(dataProvider=\"FilterCases\")\n+    void testCase(MyFilterFactory dynFilterFactory, Validator dynFilter, Validator streamFilter)\n+                throws IOException, ClassNotFoundException {\n+\n+        \/\/ Set the Filter Factory and System-wide filter\n+        ObjectInputFilter configFilter;\n+        MyFilterFactory factory;\n+        try {\n+            configFilter = setupFilter(dynFilter);\n+            factory = setupFilterFactory(dynFilterFactory);\n+            Assert.assertTrue(hasFilterPerm(),\n+                    \"setSerialFilterFactory and setFilterFactory succeeded without serialFilter permission\");\n+        } catch (AccessControlException ace) {\n+            Assert.assertFalse(hasFilterPerm(),\n+                    \"setSerialFilterFactory failed even with serialFilter permission\");\n+            return;         \/\/ test complete\n+        }\n+        factory.reset();\n+\n+        InputStream is = new ByteArrayInputStream(simpleStream);\n+        ObjectInputStream ois = new ObjectInputStream(is);\n+\n+        Assert.assertNull(factory.current(), \"initially current should be null\");\n+        Assert.assertEquals(factory.next(), configFilter, \"initially next should be the configured filter\");\n+        var currFilter = ois.getObjectInputFilter();\n+        if (currFilter != null && currFilter.getClass().getClassLoader() == null) {\n+            \/\/ Builtin loader;  defaults to configured filter\n+            Assert.assertEquals(currFilter, configFilter, \"getObjectInputFilter should be configured filter\");\n+        } else {\n+            Assert.assertEquals(currFilter, configFilter, \"getObjectInputFilter should be null\");\n+        }\n+        if (streamFilter != null) {\n+            ois.setObjectInputFilter(streamFilter);\n+            \/\/ MyFilterFactory is called when the stream filter is changed; verify values passed it\n+            Assert.assertEquals(factory.current(), currFilter, \"when setObjectInputFilter, current should be current filter\");\n+            Assert.assertEquals(factory.next(), streamFilter, \"next should be stream specific filter\");\n+\n+            \/\/ Check the OIS filter after the factory has updated it.\n+            currFilter = ois.getObjectInputFilter();\n+            Assert.assertEquals(currFilter, streamFilter, \"getObjectInputFilter should be set\");\n+\n+            \/\/ Verify that it can not be set again\n+            Assert.assertThrows(IllegalStateException.class, () -> ois.setObjectInputFilter(streamFilter));\n+        }\n+        if (currFilter instanceof Validator validator) {\n+            validator.reset();\n+            Object o = ois.readObject();       \/\/ Invoke only for the side effect of calling the Filter\n+            Assert.assertEquals(validator.count, 1, \"Wrong number of calls to the stream filter\");\n+        } else {\n+            Object o = ois.readObject();       \/\/ Invoke only for the side effect of calling the filter\n+        }\n+    }\n+\n+    \/\/ Test that if the property jdk-serialFilterFactory is set, then initial factory has the same classname\n+    @Test\n+    void testPropertyFilterFactory() {\n+        if (jdkSerialFilterFactoryProp != null) {\n+            Assert.assertEquals(jdkSerialFilterFactory.getClass().getName(), jdkSerialFilterFactoryProp,\n+                    \"jdk.serialFilterFactory property classname mismatch\");\n+        }\n+    }\n+\n+    \/\/ Test that setting the filter factory after any deserialization (any testCase)\n+    \/\/ throws IllegalStateException with the specific message\n+    @Test(dependsOnMethods=\"testCase\")\n+    void testSetFactoryAfterDeserialization() throws IOException {\n+        if (hasFilterPerm()) {\n+            \/\/ Only test if is allowed by SM.\n+            BinaryOperator<ObjectInputFilter> factory = Config.getSerialFilterFactory();\n+            IllegalStateException ise = Assert.expectThrows(IllegalStateException.class, () -> Config.setSerialFilterFactory(factory));\n+            Assert.assertEquals(ise.getMessage(), \"FilterFactory can not be set after any deserialization\");\n+        }\n+    }\n+\n+    \/**\n+     * Returns an ObjectInputFilter that returns the requested Status.\n+     * @param status a Status, may be null\n+     * @return  an ObjectInputFilter that returns the requested Status\n+     *\/\n+    private static ObjectInputFilter getFilter(ObjectInputFilter.Status status) {\n+        return (info) -> status;\n+    }\n+\n+    \/**\n+     * A simple filter factory that retains its arguments.\n+     *\/\n+    private static class MyFilterFactory\n+            implements BinaryOperator<ObjectInputFilter> {\n+        private final String name;\n+        private ObjectInputFilter current;\n+        private ObjectInputFilter next;\n+\n+        MyFilterFactory(String name) {\n+            this.name = name;\n+            current = new Validator(\"UnsetCurrent\");\n+            next = new Validator(\"UnsetNext\");\n+        }\n+\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            this.current = curr;\n+            this.next = next;\n+            if (curr == null & next == null)\n+                return Config.getSerialFilter();    \/\/ Default to the configured filter\n+            return next;\n+        }\n+\n+        public void  reset() {\n+            current = new Validator(\"UnsetCurrent\");\n+            next = new Validator(\"UnsetNext\");\n+        }\n+\n+        public ObjectInputFilter current() {\n+            return current;\n+        }\n+\n+        public ObjectInputFilter next() {\n+            return next;\n+        }\n+\n+        public void current(ObjectInputFilter current) {\n+            this.current = current;\n+        }\n+\n+        public void next(ObjectInputFilter next) {\n+            this. next = next;\n+        }\n+\n+        public String toString() {\n+            return name + \":: curr: \" + current + \", next: \" + next;\n+        }\n+    }\n+\n+    \/**\n+     * A subclass of MyFilterFactory with a name, used when testing setting the factory using\n+     * -Djdk.setFilterFactory.\n+     *\/\n+    public static class PropertyFilterFactory extends MyFilterFactory {\n+        public PropertyFilterFactory() {\n+            super(\"UNNAMED\");\n+        }\n+    }\n+\n+    \/**\n+     * A filter factory that is not compatible with MyFilterFactory test.\n+     * Used for testing incorrect initialization.\n+     *\/\n+    public static class NotMyFilterFactory\n+            implements BinaryOperator<ObjectInputFilter> {\n+\n+        public NotMyFilterFactory() {}\n+\n+        \/**\n+         * Returns null as the filter to be used for an ObjectInputStream.\n+         *\n+         * @param curr the current filter, if any\n+         * @param next the next filter, if any\n+         * @return null\n+         *\/\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * A filter that accumulates information about the checkInput callbacks\n+     * that can be checked after readObject completes.\n+     *\/\n+    static class Validator implements ObjectInputFilter {\n+        private final String name;\n+        long count;          \/\/ Count of calls to checkInput\n+\n+        Validator(String name) {\n+            this.name = name;\n+            count = 0;\n+        }\n+\n+        void reset() {\n+            count = 0;\n+        }\n+\n+        @Override\n+        public Status checkInput(FilterInfo filter) {\n+            count++;\n+            return Status.ALLOWED;\n+        }\n+\n+        public String toString(){\n+            return name + \": count: \" + count;\n+        }\n+    }\n+\n+    \/**\n+     * A simple class to serialize.\n+     *\/\n+    private static final class Dummy implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = 1L;\n+        final String s;\n+        Dummy(String s) {\n+            this.s = s;\n+        }\n+        public String toString() {\n+            return this.getClass().getName() + \"::\" + s;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFactoryTest.java","additions":412,"deletions":0,"binary":false,"changes":412,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.FilterInfo;\n+import java.util.function.Predicate;\n+\n+import static java.io.ObjectInputFilter.Status;\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n+\n+\/* @test\n+ * @run testng SerialFilterFunctionTest\n+ * @summary ObjectInputFilter.Config Function Tests\n+ *\/\n+@Test\n+public class SerialFilterFunctionTest {\n+\n+    @Test\n+    void testMerge() {\n+        Status[] cases = Status.values();\n+        FilterInfo info = new SerialInfo(Object.class);\n+        for (Status st1 : cases) {\n+            ObjectInputFilter filter1 = getFilter(st1);\n+            for (Status st2 : cases) {\n+                ObjectInputFilter filter2 = getFilter(st2);\n+                ObjectInputFilter f = ObjectInputFilter.merge(filter1, filter2);\n+                Status r = f.checkInput(info);\n+                Assert.assertEquals(merge(st1, st2), r, \"merge\");\n+            }\n+            Assert.assertSame(ObjectInputFilter.merge(filter1, null), filter1, \"merge with null fail\");\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.merge(null, filter1));\n+        }\n+    }\n+\n+    \/**\n+     * Return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED.\n+     * @param status a status\n+     * @param otherStatus another status\n+     * @return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED\n+     *\/\n+    private Status merge(Status status, Status otherStatus) {\n+        if (REJECTED.equals(status) || REJECTED.equals(otherStatus))\n+            return REJECTED;\n+\n+        if (ALLOWED.equals(status)  || ALLOWED.equals(otherStatus))\n+            return ALLOWED;\n+\n+        return UNDECIDED;\n+    }\n+\n+    \/**\n+     * Return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class.\n+     * @return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class\n+     *\/\n+    static Predicate<Class<?>> isInteger() {\n+        return (cl) -> cl.equals(Integer.class);\n+    }\n+\n+    @DataProvider(name = \"AllowPredicateCases\")\n+    static Object[][] allowPredicateCases() {\n+        return new Object[][]{\n+                { Integer.class, isInteger(), Status.ALLOWED},\n+                { Double.class, isInteger(), Status.UNDECIDED},\n+                { Double.class, isInteger(), null},         \/\/ NPE\n+                { Double.class, null, Status.UNDECIDED},    \/\/ NPE\n+        };\n+    }\n+\n+    @Test(dataProvider = \"AllowPredicateCases\")\n+    void testAllowPredicates(Class<?> clazz, Predicate<Class<?>> predicate, Status expected) {\n+        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+        if (predicate == null || expected == null) {\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n+        } else {\n+            Assert.assertEquals(ObjectInputFilter.allowFilter(predicate, Status.UNDECIDED).checkInput(info),\n+                    expected, \"Predicate result\");\n+        }\n+    }\n+\n+    @DataProvider(name = \"RejectPredicateCases\")\n+    static Object[][] rejectPredicateCases() {\n+        return new Object[][]{\n+                { Integer.class, isInteger(), REJECTED},\n+                { Double.class, isInteger(), Status.UNDECIDED},\n+                { Double.class, isInteger(), null},         \/\/ NPE\n+                { Double.class, null, Status.UNDECIDED},    \/\/ NPE\n+        };\n+    }\n+\n+    @Test(dataProvider = \"RejectPredicateCases\")\n+    void testRejectPredicates(Class<?> clazz, Predicate<Class<?>> predicate, Status expected) {\n+        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+        if (predicate == null || expected == null) {\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n+        } else {\n+            Assert.assertEquals(ObjectInputFilter.rejectFilter(predicate, Status.UNDECIDED).checkInput(info), expected, \"Predicate result\");\n+        }\n+    }\n+\n+    @Test\n+    void testRejectUndecided() {\n+        FilterInfo info = new SerialInfo(Object.class); \/\/ an info structure, unused\n+\n+        ObjectInputFilter undecided = getFilter(UNDECIDED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(undecided).checkInput(info), REJECTED, \"undecided -> rejected\");\n+        ObjectInputFilter allowed = getFilter(ALLOWED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(allowed).checkInput(info), ALLOWED, \"allowed -> rejected\");\n+        ObjectInputFilter rejected = getFilter(REJECTED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(rejected).checkInput(info), REJECTED, \"rejected -> rejected\");\n+    }\n+\n+    \/**\n+     * Returns an ObjectInputFilter that returns the requested Status.\n+     * @param status a Status, may be null\n+     * @return  an ObjectInputFilter that returns the requested Status\n+     *\/\n+    private static ObjectInputFilter getFilter(ObjectInputFilter.Status status) {\n+        return (info) -> status;\n+    }\n+\n+    \/**\n+     * FilterInfo instance with a specific class.\n+     *\/\n+    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+        private final Class<?> clazz;\n+\n+        SerialInfo(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        @Override\n+        public Class<?> serialClass() {\n+            return clazz;\n+        }\n+\n+        @Override\n+        public long arrayLength() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long depth() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long references() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long streamBytes() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"serialClass: \" + serialClass());\n+            sb.append(\", arrayLength: \" + arrayLength());\n+            sb.append(\", depth: \" + depth());\n+            sb.append(\", references: \" + references());\n+            sb.append(\", streamBytes: \" + streamBytes());\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFunctionTest.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n- * @run testng\/othervm  SerialFilterTest\n- * @run testng\/othervm  -Djdk.serialSetFilterAfterRead=true SerialFilterTest\n+ * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFilterTest\n+ * @run testng\/othervm -Djdk.serialSetFilterAfterRead=true -Djdk.serialFilterTrace=true SerialFilterTest\n@@ -58,1 +58,1 @@\n- * @summary Test ObjectInputFilters\n+ * @summary Test ObjectInputFilters using Builtin Filter Factory\n@@ -245,1 +245,1 @@\n-    public static void t1(Object object,\n+    void t1(Object object,\n@@ -270,1 +270,1 @@\n-    static void testPatterns(String pattern) {\n+    void testPatterns(String pattern) {\n@@ -280,1 +280,1 @@\n-    static void nonResettableFilter() {\n+    void nonResettableFilter() {\n@@ -284,2 +284,4 @@\n-        try {\n-            byte[] bytes = writeObjects(\"text1\");    \/\/ an object\n+        Validator[] filterCases = {\n+                validator1,     \/\/ setting filter to a non-null filter\n+                null,           \/\/ setting stream-specific filter to null\n+        };\n@@ -287,19 +289,22 @@\n-            try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-                 ObjectInputStream ois = new ObjectInputStream(bais)) {\n-                \/\/ Check the initial filter is the global filter; may be null\n-                ObjectInputFilter global = ObjectInputFilter.Config.getSerialFilter();\n-                ObjectInputFilter initial = ois.getObjectInputFilter();\n-                Assert.assertEquals(global, initial, \"initial filter should be the global filter\");\n-\n-                \/\/ Check if it can be set to null\n-                ois.setObjectInputFilter(null);\n-                ObjectInputFilter filter = ois.getObjectInputFilter();\n-                Assert.assertNull(filter, \"set to null should be null\");\n-\n-                ois.setObjectInputFilter(validator1);\n-                Object o = ois.readObject();\n-                try {\n-                    ois.setObjectInputFilter(validator2);\n-                    Assert.fail(\"Should not be able to set filter twice\");\n-                } catch (IllegalStateException ise) {\n-                    \/\/ success, the exception was expected\n+        for (Validator validator : filterCases) {\n+            try {\n+                byte[] bytes = writeObjects(\"text1\");    \/\/ an object\n+\n+                try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais)) {\n+                    \/\/ Check the initial filter is the global filter; may be null\n+                    ObjectInputFilter global = ObjectInputFilter.Config.getSerialFilter();\n+                    ObjectInputFilter initial = ois.getObjectInputFilter();\n+                    Assert.assertEquals(global, initial, \"initial filter should be the global filter\");\n+\n+                    ois.setObjectInputFilter(validator);\n+                    Object o = ois.readObject();\n+                    try {\n+                        ois.setObjectInputFilter(validator2);\n+                        Assert.fail(\"Should not be able to set filter twice\");\n+                    } catch (IllegalStateException ise) {\n+                        \/\/ success, the exception was expected\n+                    }\n+                } catch (EOFException eof) {\n+                    Assert.fail(\"Should not reach end-of-file\", eof);\n+                } catch (ClassNotFoundException cnf) {\n+                    Assert.fail(\"Deserializing\", cnf);\n@@ -307,4 +312,2 @@\n-            } catch (EOFException eof) {\n-                Assert.fail(\"Should not reach end-of-file\", eof);\n-            } catch (ClassNotFoundException cnf) {\n-                Assert.fail(\"Deserializing\", cnf);\n+            } catch (IOException ex) {\n+                Assert.fail(\"Unexpected IOException\", ex);\n@@ -312,2 +315,0 @@\n-        } catch (IOException ex) {\n-            Assert.fail(\"Unexpected IOException\", ex);\n@@ -326,1 +327,1 @@\n-    static void testNonSettableAfterReadObject() throws IOException, ClassNotFoundException {\n+    void testNonSettableAfterReadObject() throws IOException, ClassNotFoundException {\n@@ -362,1 +363,1 @@\n-    static void testReadResolveToArray(Object array, int length) throws IOException {\n+    void testReadResolveToArray(Object array, int length) throws IOException {\n@@ -379,1 +380,1 @@\n-    static void testLimits(String name, long value) {\n+    void testLimits(String name, long value) {\n@@ -399,1 +400,1 @@\n-    static void testInvalidLimits(String pattern) {\n+    void testInvalidLimits(String pattern) {\n@@ -412,1 +413,1 @@\n-    static void testNullStatus() throws IOException {\n+    void testNullStatus() throws IOException {\n@@ -431,1 +432,1 @@\n-    static void testInvalidPatterns(String pattern) {\n+    void testInvalidPatterns(String pattern) {\n@@ -444,1 +445,1 @@\n-    static void testEmptyPattern() {\n+    void testEmptyPattern() {\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":42,"deletions":41,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+# Deserialization Input Filter Factory\n+# See conf\/security\/java.security for pattern synatx\n+#\n+jdk.serialFilterFactory=SerialFilterFactoryTest$PropertyFilterFactory\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/java.security-extra-factory","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"}]}