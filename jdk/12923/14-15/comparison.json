{"files":[{"patch":"@@ -91,1 +91,1 @@\n-      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp\n+      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#include \"prims\/agentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -274,1 +274,1 @@\n-static void send_agent_event(AgentEvent& event, const Agent* agent) {\n+static void send_agent_event(AgentEvent& event, const JvmtiAgent* agent) {\n@@ -284,1 +284,1 @@\n-  const AgentList::Iterator it = AgentList::java_agents();\n+  const JvmtiAgentList::Iterator it =JvmtiAgentList::java_agents();\n@@ -286,1 +286,1 @@\n-    const Agent* agent = it.next();\n+    const JvmtiAgent* agent = it.next();\n@@ -293,1 +293,1 @@\n-static void send_native_agent_events(const AgentList::Iterator& it) {\n+static void send_native_agent_events(const JvmtiAgentList::Iterator& it) {\n@@ -295,1 +295,1 @@\n-    const Agent* agent = it.next();\n+    const JvmtiAgent* agent = it.next();\n@@ -304,1 +304,1 @@\n-  const AgentList::Iterator native_agents_it = AgentList::native_agents();\n+  const JvmtiAgentList::Iterator native_agents_it = JvmtiAgentList::native_agents();\n@@ -306,1 +306,1 @@\n-  const AgentList::Iterator xrun_agents_it = AgentList::xrun_agents();\n+  const JvmtiAgentList::Iterator xrun_agents_it = JvmtiAgentList::xrun_agents();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,620 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/agent.hpp\"\n-\n-#include \"cds\/cds_globals.hpp\"\n-#include \"jni.h\"\n-#include \"jvm_io.h\"\n-#include \"jvmtifiles\/jvmtiEnv.hpp\"\n-#include \"prims\/jvmtiEnvBase.hpp\"\n-#include \"prims\/jvmtiExport.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/jniHandles.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"runtime\/thread.inline.hpp\"\n-\n-static inline const char* copy_string(const char* str) {\n-  return str != nullptr ? os::strdup(str, mtServiceability) : nullptr;\n-}\n-\n-\/\/ Returns the lhs before '=', parsed_options output param gets the rhs.\n-static const char* split_options_and_allocate_copy(const char* options, const char** parsed_options) {\n-  assert(options != nullptr, \"invariant\");\n-  assert(parsed_options != nullptr, \"invariant\");\n-  const char* const equal_sign = strchr(options, '=');\n-  const size_t length = strlen(options);\n-  size_t name_length = length;\n-  if (equal_sign != nullptr) {\n-    name_length = equal_sign - options;\n-    const size_t options_length = length - name_length - 1;\n-    *parsed_options = copy_string(equal_sign + 1);\n-  } else {\n-    *parsed_options = nullptr;\n-    name_length = length;\n-  }\n-  char* const name = AllocateHeap(name_length + 1, mtServiceability);\n-  jio_snprintf(name, name_length + 1, \"%s\", options);\n-  assert(strncmp(name, options, name_length) == 0, \"invariant\");\n-  return name;\n-}\n-\n-Agent::Agent(const char* name, const char* options, bool is_absolute_path, bool dynamic \/* false *\/) :\n-  _initialization_time(),\n-  _initialization_duration(),\n-  _next(nullptr),\n-  _name(copy_string(name)),\n-  _options(copy_string(options)),\n-  _os_lib(nullptr),\n-  _os_lib_path(nullptr),\n-  _jplis(nullptr),\n-  _loaded(false),\n-  _absolute_path(is_absolute_path),\n-  _static_lib(false),\n-  _instrument_lib(strcmp(name, \"instrument\") == 0),\n-  _dynamic(dynamic),\n-  _xrun(false) {}\n-\n-Agent* Agent::next() const {\n-  return _next;\n-}\n-\n-void Agent::set_next(Agent* agent) {\n-  _next = agent;\n-}\n-\n-const char* Agent::name() const {\n-  return _name;\n-}\n-\n-const char* Agent::options() const {\n-  return _options;\n-}\n-\n-void* Agent::os_lib() const {\n-  return _os_lib;\n-}\n-\n-void Agent::set_os_lib(void* os_lib) {\n-  _os_lib = os_lib;\n-}\n-\n-void Agent::set_os_lib_path(const char* path) {\n-  assert(path != nullptr, \"invariant\");\n-  if (_os_lib_path == nullptr) {\n-    _os_lib_path = copy_string(path);\n-  }\n-  assert(strcmp(_os_lib_path, path) == 0, \"invariant\");\n-}\n-\n-const char* Agent::os_lib_path() const {\n-  return _os_lib_path;\n-}\n-\n-bool Agent::is_loaded() const {\n-  return _loaded;\n-}\n-\n-void Agent::set_loaded() {\n-  _loaded = true;\n-}\n-\n-bool Agent::is_absolute_path() const {\n-  return _absolute_path;\n-}\n-\n-bool Agent::is_static_lib() const {\n-  return _static_lib;\n-}\n-\n-void Agent::set_static_lib() {\n-  _static_lib = true;\n-}\n-\n-bool Agent::is_dynamic() const {\n-  return _dynamic;\n-}\n-\n-bool Agent:: is_instrument_lib() const {\n-  return _instrument_lib;\n-}\n-\n-bool Agent::is_xrun() const {\n-  return _xrun;\n-}\n-\n-void Agent::set_xrun() {\n-  _xrun = true;\n-}\n-\n-bool Agent::is_jplis() const {\n-  return _jplis != nullptr;\n-}\n-\n-const Ticks& Agent::initialization_time() const {\n-  return _initialization_time;\n-}\n-\n-const Tickspan& Agent::initialization_duration() const {\n-  return _initialization_duration;\n-}\n-\n-bool Agent::is_initialized() const {\n-  return _initialization_time.value() != 0;\n-}\n-\n-void Agent::initialization_begin() {\n-  assert(!is_initialized(), \"invariant\");\n-  _initialization_time = Ticks::now();\n-}\n-\n-void Agent::initialization_end() {\n-  assert(is_initialized(), \"invariant\");\n-  assert(_initialization_duration.value() == 0, \"invariant\");\n-  _initialization_duration = Ticks::now() - initialization_time();\n-}\n-\n-\/*\n- * The implementation builds a mapping bewteen JvmtiEnvs and JPLIS agents,\n- * using internal JDK implementation knowledge about the way JPLIS agents\n- * store data in their JvmtiEnv local storage.\n- *\n- * Please see JPLISAgent.h and JPLISAgent.c in module java.instrument.\n- *\n- * jvmtierror = (*jvmtienv)->SetEnvironmentLocalStorage( jvmtienv, &(agent->mNormalEnvironment));\n- *\n- * It is the pointer to the field agent->mNormalEnvironment that is stored in the jvmtiEnv local storage.\n- * It has the following type:\n- *\n- * struct _JPLISEnvironment {\n- *   jvmtiEnv*   mJVMTIEnv;         \/\/ the JVMTI environment\n- *   JPLISAgent* mAgent;            \/\/ corresponding agent\n- *   jboolean    mIsRetransformer;  \/\/ indicates if special environment\n- * };\n- *\n- * We mirror this struct to get the mAgent field as an identifier.\n- *\/\n-\n-struct JPLISEnvironmentMirror {\n-  jvmtiEnv* mJVMTIEnv; \/\/ the JVMTI environment\n-  const void* mAgent;  \/\/ corresponding agent\n-  jboolean mIsRetransformer; \/\/ indicates if special environment\n-};\n-\n-static inline const JPLISEnvironmentMirror* get_env_local_storage(JvmtiEnv* env) {\n-  assert(env != nullptr, \"invariant\");\n-  return reinterpret_cast<const JPLISEnvironmentMirror*>(env->get_env_local_storage());\n-}\n-\n-bool Agent::is_jplis(JvmtiEnv* env) const {\n-  assert(env != nullptr, \"invariant\");\n-  assert(is_instrument_lib(), \"invariant\");\n-  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n-  return jplis_env != nullptr && _jplis == jplis_env->mAgent;\n-}\n-\n-void Agent::set_jplis(const void* jplis) {\n-  assert(jplis != nullptr, \"invaiant\");\n-  assert(is_instrument_lib(), \"invariant\");\n-  assert(_jplis == nullptr, \"invariant\");\n-  if (_options != nullptr) {\n-    \/\/ For JPLIS agents, update with the java name and options.\n-    os::free(const_cast<char*>(_name));\n-    const char* options = _options;\n-    _name = split_options_and_allocate_copy(options, &_options);\n-    os::free(const_cast<char*>(options));\n-  }\n-  _jplis = jplis;\n-}\n-\n-static const char* not_found_error_msg = \"Could not find agent library \";\n-static const char* missing_module_error_msg = \"\\nModule java.instrument may be missing from runtime image.\";\n-static char ebuf[1024];\n-static char buffer[JVM_MAXPATHLEN];\n-\n-static void vm_exit(const Agent* agent, const char* sub_msg1, const char* sub_msg2) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(sub_msg1 != nullptr, \"invariant\");\n-  assert(!agent->is_instrument_lib() || sub_msg2 != nullptr, \"invariant\");\n-  const size_t len = strlen(not_found_error_msg) + strlen(agent->name()) + strlen(sub_msg1) + strlen(&ebuf[0]) + 1 + (agent->is_instrument_lib() ? strlen(sub_msg2) : 0);\n-  char* buf = NEW_C_HEAP_ARRAY(char, len, mtServiceability);\n-  if (agent->is_instrument_lib()) {\n-    jio_snprintf(buf, len, \"%s%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0], sub_msg2);\n-  } else {\n-    jio_snprintf(buf, len, \"%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0]);\n-  }\n-  vm_exit_during_initialization(buf, nullptr);\n-  FREE_C_HEAP_ARRAY(char, buf);\n-}\n-\n-#ifdef ASSERT\n-static void assert_preload(const Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(!agent->is_loaded(), \"invariant\");\n-}\n-#endif\n-\n-\/\/ Check for a statically linked-in agent, i.e. in the executable.\n-\/\/ This should be the first function called when loading an agent. It is a bit special:\n-\/\/ For statically linked agents we cant't rely on os_lib == nullptr because\n-\/\/ statically linked agents could have a handle of RTLD_DEFAULT which == 0 on some platforms.\n-\/\/ If this function returns true, then agent->is_static_lib().&& agent->is_loaded().\n-static bool load_agent_from_executable(Agent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n-  DEBUG_ONLY(assert_preload(agent);)\n-  assert(on_load_symbols != nullptr, \"invariant\");\n-  return os::find_builtin_agent(agent, &on_load_symbols[0], num_symbol_entries);\n-}\n-\n-\/\/ Load the library from the absolute path of the agent, if available.\n-static void* load_agent_from_absolute_path(Agent* agent, bool vm_exit_on_error) {\n-  DEBUG_ONLY(assert_preload(agent);)\n-  assert(agent->is_absolute_path(), \"invariant\");\n-  assert(!agent->is_instrument_lib(), \"invariant\");\n-  void* const library = os::dll_load(agent->name(), &ebuf[0], sizeof ebuf);\n-  if (library == nullptr && vm_exit_on_error) {\n-    vm_exit(agent, \" in absolute path, with error: \", nullptr);\n-  }\n-  return library;\n-}\n-\n-\/\/ Agents with relative paths are loaded from the standard dll directory.\n-static void* load_agent_from_relative_path(Agent* agent, bool vm_exit_on_error) {\n-  DEBUG_ONLY(assert_preload(agent);)\n-  assert(!agent->is_absolute_path(), \"invariant\");\n-  const char* const name = agent->name();\n-  void* library = nullptr;\n-  \/\/ Try to load the agent from the standard dll directory\n-  if (os::dll_locate_lib(&buffer[0], sizeof buffer, Arguments::get_dll_dir(), name)) {\n-    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n-  }\n-  if (library == nullptr && os::dll_build_name(&buffer[0], sizeof buffer, name)) {\n-    \/\/ Try the library path directory.\n-    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n-    if (library != nullptr) {\n-      return library;\n-    }\n-    if (vm_exit_on_error) {\n-      vm_exit(agent, \" on the library path, with error: \", missing_module_error_msg);\n-    }\n-  }\n-  return library;\n-}\n-\n-\/\/ For absolute and relative paths.\n-static void* load_library(Agent* agent, const char* on_symbols[], size_t num_symbol_entries, bool vm_exit_on_error) {\n-  return agent->is_absolute_path() ? load_agent_from_absolute_path(agent, vm_exit_on_error) :\n-                                     load_agent_from_relative_path(agent, vm_exit_on_error);\n-}\n-\n-\/\/ Type for the Agent_OnLoad and JVM_OnLoad entry points.\n-extern \"C\" {\n-  typedef jint(JNICALL* OnLoadEntry_t)(JavaVM*, char*, void*);\n-}\n-\n-\/\/ Find the OnLoad entry point for -agentlib:  -agentpath:   -Xrun agents.\n-\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n-static OnLoadEntry_t lookup_On_Load_entry_point(Agent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n-  assert(agent != nullptr, \"invariant\");\n-  if (!agent->is_loaded()) {\n-    if (!load_agent_from_executable(agent, on_load_symbols, num_symbol_entries)) {\n-      void* const library = load_library(agent, on_load_symbols, num_symbol_entries, \/* vm exit on error *\/ true);\n-      assert(library != nullptr, \"invariant\");\n-      agent->set_os_lib(library);\n-      agent->set_loaded();\n-    }\n-  }\n-  assert(agent->is_loaded(), \"invariant\");\n-  \/\/ Find the OnLoad function.\n-  return CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent, false, on_load_symbols, num_symbol_entries));\n-}\n-\n-static OnLoadEntry_t lookup_JVM_OnLoad_entry_point(Agent* lib) {\n-  const char* on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n-  return lookup_On_Load_entry_point(lib, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n-}\n-\n-static OnLoadEntry_t lookup_Agent_OnLoad_entry_point(Agent* agent) {\n-  const char* on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n-  return lookup_On_Load_entry_point(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n-}\n-\n-void Agent::convert_xrun_agent() {\n-  assert(is_xrun(), \"invariant\");\n-  assert(!is_loaded(), \"invariant\");\n-  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n-  OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(this);\n-  \/\/ If there is an JVM_OnLoad function it will get called later,\n-  \/\/ otherwise see if there is an Agent_OnLoad.\n-  if (on_load_entry == nullptr) {\n-    on_load_entry = lookup_Agent_OnLoad_entry_point(this);\n-    if (on_load_entry == nullptr) {\n-      vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", name());\n-    }\n-    _xrun = false; \/\/ converted\n-  }\n-}\n-\n-\/\/ Called after the VM is initialized for -Xrun agents which have not been converted to JVMTI agents.\n-static bool invoke_JVM_OnLoad(Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(agent->is_xrun(), \"invariant\");\n-  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n-  OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(agent);\n-  if (on_load_entry == nullptr) {\n-    vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n-  }\n-  \/\/ Invoke the JVM_OnLoad function\n-  JavaThread* thread = JavaThread::current();\n-  ThreadToNativeFromVM ttn(thread);\n-  HandleMark hm(thread);\n-  extern struct JavaVM_ main_vm;\n-  const jint err = (*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), NULL);\n-  if (err != JNI_OK) {\n-    vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n-  }\n-  return true;\n-}\n-\n-\/\/ The newest jvmtiEnv is appended to the list,\n-\/\/ hence the JvmtiEnvIterator order is from oldest to newest.\n-static JvmtiEnv* get_last_jplis_jvmtienv() {\n-  JvmtiEnvIterator it;\n-  JvmtiEnv* env = it.first();\n-  assert(env != nullptr, \"invariant\");\n-  JvmtiEnv* next = it.next(env);\n-  while (next != nullptr) {\n-    assert(env != nullptr, \"invariant\");\n-    \/\/ get_env_local_storage() lets us find which JVMTI env map to which JPLIS agent.\n-    if (next->get_env_local_storage() == nullptr) {\n-      JvmtiEnv* temp = it.next(next);\n-      if (temp != nullptr) {\n-        next = temp;\n-        continue;\n-      }\n-      break;\n-    }\n-    env = next;\n-    next = it.next(env);\n-  }\n-  assert(env != nullptr, \"invariant\");\n-  assert(env->get_env_local_storage() != nullptr, \"invariant\");\n-  return env;\n-}\n-\n-\/\/ Associate the last, i.e. most recent, JvmtiEnv that is a JPLIS agent with the current agent.\n-static void convert_to_jplis(Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(agent->is_instrument_lib(), \"invariant\");\n-  JvmtiEnv* const env = get_last_jplis_jvmtienv();\n-  assert(env != nullptr, \"invariant\");\n-  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n-  assert(jplis_env != nullptr, \"invaiant\");\n-  assert(reinterpret_cast<JvmtiEnv*>(jplis_env->mJVMTIEnv) == env, \"invariant\");\n-  agent->set_jplis(jplis_env->mAgent);\n-}\n-\n-\/\/ Use this for JavaThreads and state is _thread_in_vm.\n-class AgentJavaThreadEventTransition : StackObj {\n- private:\n-  ResourceMark _rm;\n-  ThreadToNativeFromVM _transition;\n-  HandleMark _hm;\n- public:\n-  AgentJavaThreadEventTransition(JavaThread* thread) : _rm(), _transition(thread), _hm(thread) {};\n-};\n-\n-class AgentEventMark : StackObj {\n- private:\n-  JavaThread* _thread;\n-  JNIEnv* _jni_env;\n-  JvmtiThreadState::ExceptionState _saved_exception_state;\n-\n- public:\n-  AgentEventMark(JavaThread* thread) : _thread(thread),\n-                                       _jni_env(thread->jni_environment()),\n-                                       _saved_exception_state(JvmtiThreadState::ES_CLEARED) {\n-    JvmtiThreadState* state = thread->jvmti_thread_state();\n-    \/\/ we are before an event.\n-    \/\/ Save current jvmti thread exception state.\n-    if (state != nullptr) {\n-      _saved_exception_state = state->get_exception_state();\n-    }\n-    thread->push_jni_handle_block();\n-    assert(thread == JavaThread::current(), \"thread must be current!\");\n-    thread->frame_anchor()->make_walkable();\n-  }\n-\n-  ~AgentEventMark() {\n-    _thread->pop_jni_handle_block();\n-    JvmtiThreadState* state = _thread->jvmti_thread_state();\n-    \/\/ we are continuing after an event.\n-    if (state != nullptr) {\n-      \/\/ Restore the jvmti thread exception state.\n-      state->restore_exception_state(_saved_exception_state);\n-    }\n-  }\n-};\n-\n-class AgentThreadEventMark : public AgentEventMark {\n- private:\n-  jobject _jthread;\n- public:\n-  AgentThreadEventMark(JavaThread* thread) : AgentEventMark(thread),\n-                                             _jthread(JNIHandles::make_local(thread, thread->threadObj())) {}\n-  jthread jni_thread() { return (jthread)_jthread; }\n-};\n-\n-static void unload_library(Agent* agent, void* library) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(agent->is_loaded(), \"invariant\");\n-  if (!agent->is_static_lib()) {\n-    assert(library != nullptr, \"invariant\");\n-    os::dll_unload(library);\n-  }\n-}\n-\n-\/\/ type for the Agent_OnAttach entry point\n-extern \"C\" {\n-  typedef jint(JNICALL* OnAttachEntry_t)(JavaVM*, char*, void*);\n-}\n-\n-\/\/ Loading the agent by invoking Agent_OnAttach.\n-static bool invoke_Agent_OnAttach(Agent* agent, outputStream* st) {\n-  DEBUG_ONLY(assert_preload(agent);)\n-  assert(agent->is_dynamic(), \"invariant\");\n-  assert(st != nullptr, \"invariant\");\n-  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE, \"not in live phase!\");\n-  const char* on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n-  const size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n-  void* library = nullptr;\n-  if (!load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n-    library = load_library(agent, &on_attach_symbols[0], num_symbol_entries, \/* vm_exit_on_error *\/ false);\n-    if (library == nullptr) {\n-      st->print_cr(\"%s was not loaded.\", agent->name());\n-      if (*ebuf != '\\0') {\n-        st->print_cr(\"%s\", &ebuf[0]);\n-      }\n-      return false;\n-    }\n-    agent->set_os_lib_path(&buffer[0]);\n-    agent->set_os_lib(library);\n-    agent->set_loaded();\n-  }\n-  assert(agent->is_loaded(), \"invariant\");\n-  \/\/ The library was loaded so we attempt to lookup and invoke the Agent_OnAttach function.\n-  OnAttachEntry_t on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,\n-                                                   os::find_agent_function(agent, false, &on_attach_symbols[0], num_symbol_entries));\n-\n-  if (on_attach_entry == nullptr) {\n-    st->print_cr(\"%s is not available in %s\", on_attach_symbols[0], agent->name());\n-    unload_library(agent, library);\n-    return false;\n-  }\n-\n-  \/\/ Invoke the Agent_OnAttach function\n-  JavaThread* thread = JavaThread::current();\n-  jint result = JNI_ERR;\n-  {\n-    extern struct JavaVM_ main_vm;\n-    AgentThreadEventMark jem(thread);\n-    AgentJavaThreadEventTransition jet(thread);\n-\n-    agent->initialization_begin();\n-\n-    result = (*on_attach_entry)(&main_vm, (char*)agent->options(), nullptr);\n-\n-    agent->initialization_end();\n-\n-    \/\/ Agent_OnAttach may have used JNI\n-    if (thread->is_pending_jni_exception_check()) {\n-      thread->clear_pending_jni_exception_check();\n-    }\n-  }\n-\n-  \/\/ Agent_OnAttach may have used JNI\n-  if (thread->has_pending_exception()) {\n-    thread->clear_pending_exception();\n-  }\n-\n-  st->print_cr(\"return code: %d\", result);\n-\n-  if (result != JNI_OK) {\n-    unload_library(agent, library);\n-    return false;\n-  }\n-\n-  if (agent->is_instrument_lib()) {\n-    \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n-    convert_to_jplis(agent);\n-  }\n-  return true;\n-}\n-\n-\/\/ CDS dumping does not support native JVMTI agent.\n-\/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n-static void check_cds_dump(Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(Arguments::is_dumping_archive(), \"invariant\");\n-  if (!agent->is_instrument_lib()) {\n-    vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n-  }\n-  if (!AllowArchivingWithJavaAgent) {\n-    vm_exit_during_cds_dumping(\n-      \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n-  }\n-}\n-\n-\/\/ Loading the agent by invoking Agent_OnLoad.\n-static bool invoke_Agent_OnLoad(Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(!agent->is_xrun(), \"invariant\");\n-  assert(!agent->is_dynamic(), \"invariant\");\n-  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_ONLOAD, \"invariant\");\n-  if (Arguments::is_dumping_archive()) {\n-    check_cds_dump(agent);\n-  }\n-  OnLoadEntry_t on_load_entry = lookup_Agent_OnLoad_entry_point(agent);\n-  if (on_load_entry == nullptr) {\n-    vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n-  }\n-  \/\/ Invoke the Agent_OnLoad function\n-  extern struct JavaVM_ main_vm;\n-  if ((*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), nullptr) != JNI_OK) {\n-    vm_exit_during_initialization(\"agent library failed Agent_OnLoad\", agent->name());\n-  }\n-  \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n-  if (agent->is_instrument_lib()) {\n-    convert_to_jplis(agent);\n-  }\n-  return true;\n-}\n-\n-bool Agent::load(outputStream* st \/* nullptr *\/) {\n-  if (is_xrun()) {\n-    return invoke_JVM_OnLoad(this);\n-  }\n-  return is_dynamic() ? invoke_Agent_OnAttach(this, st) : invoke_Agent_OnLoad(this);\n-}\n-\n-extern \"C\" {\n-  typedef void (JNICALL* Agent_OnUnload_t)(JavaVM*);\n-}\n-\n-void Agent::unload() {\n-  const char* on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n-  \/\/ Find the Agent_OnUnload function.\n-  Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n-                                                 os::find_agent_function(this, false, &on_unload_symbols[0], ARRAY_SIZE(on_unload_symbols)));\n-  if (unload_entry != nullptr) {\n-    \/\/ Invoke the Agent_OnUnload function\n-    JavaThread* thread = JavaThread::current();\n-    ThreadToNativeFromVM ttn(thread);\n-    HandleMark hm(thread);\n-    extern struct JavaVM_ main_vm;\n-    (*unload_entry)(&main_vm);\n-  }\n-}\n","filename":"src\/hotspot\/share\/prims\/agent.cpp","additions":0,"deletions":620,"binary":false,"changes":620,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_PRIMS_AGENT_HPP\n-#define SHARE_PRIMS_AGENT_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-class JvmtiEnv;\n-class outputStream;\n-\n-\/\/ Represents an agent launched on the command-line by -agentlib, -agentpath or -Xrun.\n-\/\/ Also agents loaded dynamically during runtime, for example using the Attach API.\n-class Agent : public CHeapObj<mtServiceability> {\n-  friend class AgentList;\n- private:\n-  Ticks _initialization_time;\n-  Tickspan _initialization_duration;\n-  Agent* _next;\n-  const char* _name;\n-  const char* _options;\n-  void* _os_lib;\n-  const char* _os_lib_path;\n-  const void* _jplis;\n-  bool _loaded;\n-  bool _absolute_path;\n-  bool _static_lib;\n-  bool _instrument_lib;\n-  bool _dynamic;\n-  bool _xrun;\n-\n-  Agent* next() const;\n-  void set_next(Agent* agent);\n-  void convert_xrun_agent();\n-  void set_xrun();\n-\n- public:\n-  Agent(const char* name, const char* options, bool is_absolute_path, bool dynamic = false);\n-  const char* name() const;\n-  const char* options() const;\n-  bool is_absolute_path() const;\n-  void* os_lib() const;\n-  void set_os_lib(void* os_lib);\n-  const char* os_lib_path() const;\n-  void set_os_lib_path(const char* path);\n-  bool is_static_lib() const;\n-  void set_static_lib();\n-  bool is_dynamic() const;\n-  bool is_xrun() const;\n-  bool is_instrument_lib() const;\n-  bool is_loaded() const;\n-  void set_loaded();\n-  bool is_jplis() const;\n-  bool is_jplis(JvmtiEnv* env) const;\n-  void set_jplis(const void* jplis);\n-  bool is_initialized() const;\n-  void initialization_begin();\n-  void initialization_end();\n-  const Ticks& initialization_time() const;\n-  const Tickspan& initialization_duration() const;\n-\n-  bool load(outputStream* st = nullptr);\n-  void unload();\n-};\n-\n-#endif \/\/ SHARE_PRIMS_AGENT_HPP\n","filename":"src\/hotspot\/share\/prims\/agent.hpp","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,263 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/agentList.hpp\"\n-\n-#include \"prims\/jvmtiEnvBase.hpp\"\n-#include \"prims\/jvmtiExport.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-Agent* AgentList::_list = nullptr;\n-\n-\/\/ Selection as a function of the filter.\n-Agent* AgentList::Iterator::select(Agent* agent) const {\n-  while (agent != nullptr) {\n-    if (_filter == ALL) {\n-      return agent;\n-    } else if (_filter == NOT_XRUN) {\n-      if (!agent->is_xrun()) {\n-        return agent;\n-      }\n-    } else if (_filter == JAVA) {\n-      if (agent->is_jplis()) {\n-        return agent;\n-      }\n-    } else if (_filter == NATIVE) {\n-      if (!agent->is_jplis() && !agent->is_xrun()) {\n-        return agent;\n-      }\n-    } else {\n-      assert(_filter == XRUN, \"invariant\");\n-      if (agent->is_xrun()) {\n-        return agent;\n-      }\n-    }\n-    agent = agent->next();\n-  }\n-  return nullptr;\n-}\n-\n-static inline Agent* head(Agent** list) {\n-  assert(list != nullptr, \"invariant\");\n-  return Atomic::load_acquire(list);\n-}\n-\n-\n-\/\/ The storage list is a single cas-linked-list, to allow for concurrent iterations. Especially during initial loading of agents,\n-\/\/ there exist an order requirement to iterate oldest -> newest. Our concurrent storage linked-list is newest -> oldest.\n-\/\/ The correct order is preserved by the iterator, by storing a filtered set of entries in a stack.\n-AgentList::Iterator::Iterator(Agent** list, Filter filter) : _stack(new GrowableArrayCHeap<Agent*, mtServiceability>(16)), _filter(filter) {\n-  Agent* next = head(list);\n-  while (next != nullptr) {\n-    next = select(next);\n-    if (next != nullptr) {\n-      _stack->push(next);\n-      next = next->next();\n-    }\n-  }\n-}\n-\n-AgentList::Iterator::~Iterator() {\n-  delete _stack;\n-}\n-\n-bool AgentList::Iterator::has_next() const {\n-  assert(_stack != nullptr, \"invariant\");\n-  return _stack->is_nonempty();\n-}\n-\n-const Agent* AgentList::Iterator::next() const {\n-  assert(has_next(), \"invariant\");\n-  return _stack->pop();\n-}\n-\n-Agent* AgentList::Iterator::next() {\n-  return const_cast<Agent*>(const_cast<const Iterator*>(this)->next());\n-}\n-\n-AgentList::Iterator AgentList::agents() {\n-  return Iterator(&_list, Iterator::NOT_XRUN);\n-}\n-\n-AgentList::Iterator AgentList::java_agents() {\n-  return Iterator(&_list, Iterator::JAVA);\n-}\n-\n-AgentList::Iterator AgentList::native_agents() {\n-  return Iterator(&_list, Iterator::NATIVE);\n-}\n-\n-AgentList::Iterator AgentList::xrun_agents() {\n-  return Iterator(&_list, Iterator::XRUN);\n-}\n-\n-AgentList::Iterator AgentList::all() {\n-  return Iterator(&_list, Iterator::ALL);\n-}\n-\n-void AgentList::add(Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  Agent* next;\n-  do {\n-    next = head(&_list);\n-    agent->set_next(next);\n-  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n-}\n-\n-void AgentList::add(const char* name, char* options, bool absolute_path) {\n-  add(new Agent(name, options, absolute_path));\n-}\n-\n-void AgentList::add_xrun(const char* name, char* options, bool absolute_path) {\n-  Agent* agent = new Agent(name, options, absolute_path);\n-  agent->set_xrun();\n-  add(agent);\n-}\n-\n-#ifdef ASSERT\n-static void assert_initialized(AgentList::Iterator& it) {\n-  while (it.has_next()) {\n-    assert(it.next()->is_initialized(), \"invariant\");\n-  }\n-}\n-#endif\n-\n-\/\/ In case an agent did not enable the VMInit callback, or if it is an -Xrun agent,\n-\/\/ it gets an initializiation timestamp here.\n-void AgentList::initialize() {\n-  Iterator it = all();\n-  while (it.has_next()) {\n-    Agent* agent = it.next();\n-    if (!agent->is_initialized()) {\n-      agent->initialization_begin();\n-    }\n-  }\n-  DEBUG_ONLY(Iterator assert_it = all(); assert_initialized(assert_it);)\n-}\n-\n-void AgentList::convert_xrun_agents() {\n-  Iterator it = xrun_agents();\n-  while (it.has_next()) {\n-    it.next()->convert_xrun_agent();\n-  }\n-}\n-\n-class JvmtiPhaseTransition : public StackObj {\n- public:\n-  JvmtiPhaseTransition() {\n-    assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n-    JvmtiExport::enter_onload_phase();\n-  }\n-  ~JvmtiPhaseTransition() {\n-    assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_ONLOAD, \"invariant\");\n-    JvmtiExport::enter_primordial_phase();\n-  }\n-};\n-\n-static void load_agents(AgentList::Iterator& it) {\n-  while (it.has_next()) {\n-    it.next()->load();\n-  }\n-}\n-\n-\/\/ Invokes Agent_OnLoad for -agentlib:.. -agentpath:  and converted -Xrun agents.\n-\/\/ Called very early -- before JavaThreads exist\n-void AgentList::load_agents() {\n-  \/\/ Convert -Xrun to -agentlib: if there is no JVM_OnLoad\n-  convert_xrun_agents();\n-  JvmtiPhaseTransition transition;\n-  Iterator it = agents();\n-  ::load_agents(it);\n-}\n-\n-\/\/ Launch -Xrun agents\n-void AgentList::load_xrun_agents() {\n-  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n-  Iterator it = xrun_agents();\n-  ::load_agents(it);\n-}\n-\n-\/\/ Invokes Agent_OnAttach for agents loaded dynamically during runtime.\n-jint AgentList::load_agent(const char* agent_name, const char* absParam,\n-                           const char* options, outputStream* st) {\n-  \/\/ The abs parameter should be \"true\" or \"false\"\n-  const bool is_absolute_path = (absParam != nullptr) && (strcmp(absParam, \"true\") == 0);\n-  Agent* const agent = new Agent(agent_name, options, is_absolute_path, \/* dynamic agent *\/ true);\n-  if (agent->load(st)) {\n-    add(agent);\n-  } else {\n-    delete agent;\n-  }\n-  \/\/ Agent_OnAttach executed so completion status is JNI_OK\n-  return JNI_OK;\n-}\n-\n-\/\/ Send any Agent_OnUnload notifications\n-void AgentList::unload_agents() {\n-  Iterator it = agents();\n-  while (it.has_next()) {\n-    it.next()->unload();\n-  }\n-}\n-\n-static bool match(JvmtiEnv* env, const Agent* agent, const void* os_module_address) {\n-  assert(env != nullptr, \"invariant\");\n-  assert(agent != nullptr, \"invariant\");\n-  if (agent->is_static_lib()) {\n-    return os::get_default_process_handle() == os_module_address;\n-  }\n-  if (agent->os_lib() != os_module_address) {\n-    return false;\n-  }\n-  return agent->is_instrument_lib() ? agent->is_jplis(env) : true;\n-}\n-\n-\/\/ The function pointer is a JVMTI callback function.\n-\/\/ Find the os module (dll) that exports this function.\n-\/\/ Now we can map a JVMTI env to its corresponding agent.\n-Agent* AgentList::lookup(JvmtiEnv* env, void* f_ptr) {\n-  assert(env != nullptr, \"invariant\");\n-  assert(f_ptr != nullptr, \"invariant\");\n-  static char ebuf[1024];\n-  static char buffer[JVM_MAXPATHLEN];\n-  int offset;\n-  if (!os::dll_address_to_library_name(reinterpret_cast<address>(f_ptr), &buffer[0], JVM_MAXPATHLEN, &offset)) {\n-    return nullptr;\n-  }\n-  assert(buffer[0] != '\\0', \"invariant\");\n-  assert(offset >= 0, \"invariant\");\n-  const void* const os_module_address = reinterpret_cast<address>(f_ptr) - offset;\n-\n-  AgentList::Iterator it = AgentList::agents();\n-  while (it.has_next()) {\n-    Agent* const agent = it.next();\n-    if (match(env, agent, os_module_address)) {\n-      agent->set_os_lib_path(&buffer[0]);\n-      return agent;\n-    }\n-  }\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/share\/prims\/agentList.cpp","additions":0,"deletions":263,"binary":false,"changes":263,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_PRIMS_AGENTLIST_HPP\n-#define SHARE_PRIMS_AGENTLIST_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"prims\/agent.hpp\"\n-\n-template <typename, MEMFLAGS>\n-class GrowableArrayCHeap;\n-class JvmtiEnv;\n-\n-\/\/ Maintains a single cas linked-list of Agents.\n-class AgentList : AllStatic {\n-  friend class Iterator;\n-  friend class JvmtiExport;\n- public:\n-  class Iterator {\n-    friend class AgentList;\n-   private:\n-    enum Filter {\n-      JAVA,\n-      NATIVE,\n-      XRUN,\n-      NOT_XRUN,\n-      ALL\n-    };\n-    GrowableArrayCHeap<Agent*, mtServiceability>* _stack;\n-    const Filter _filter;\n-    Iterator(Agent** list, Filter filter);\n-    Agent* select(Agent* agent) const;\n-   public:\n-    bool has_next() const;\n-    Agent* next();\n-    const Agent* next() const;\n-    ~Iterator();\n-  };\n-\n- private:\n-  static Agent* _list;\n-\n-  static Iterator all();\n-  static void initialize();\n-  static void convert_xrun_agents();\n-\n- public:\n-  static void add(Agent* agent);\n-  static void add(const char* name, char* options, bool absolute_path);\n-  static void add_xrun(const char* name, char* options, bool absolute_path);\n-\n-  static void load_agents();\n-  static jint load_agent(const char* agent, const char* absParam,\n-                         const char* options, outputStream* st);\n-  static void load_xrun_agents();\n-  static void unload_agents();\n-\n-  static Agent* lookup(JvmtiEnv* env, void* f_ptr);\n-\n-  static Iterator agents();\n-  static Iterator java_agents();\n-  static Iterator native_agents();\n-  static Iterator xrun_agents();\n-};\n-\n-#endif \/\/ SHARE_PRIMS_AGENTLIST_HPP\n","filename":"src\/hotspot\/share\/prims\/agentList.hpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -0,0 +1,620 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/jvmtiAgent.hpp\"\n+\n+#include \"cds\/cds_globals.hpp\"\n+#include \"jni.h\"\n+#include \"jvm_io.h\"\n+#include \"jvmtifiles\/jvmtiEnv.hpp\"\n+#include \"prims\/jvmtiEnvBase.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+static inline const char* copy_string(const char* str) {\n+  return str != nullptr ? os::strdup(str, mtServiceability) : nullptr;\n+}\n+\n+\/\/ Returns the lhs before '=', parsed_options output param gets the rhs.\n+static const char* split_options_and_allocate_copy(const char* options, const char** parsed_options) {\n+  assert(options != nullptr, \"invariant\");\n+  assert(parsed_options != nullptr, \"invariant\");\n+  const char* const equal_sign = strchr(options, '=');\n+  const size_t length = strlen(options);\n+  size_t name_length = length;\n+  if (equal_sign != nullptr) {\n+    name_length = equal_sign - options;\n+    const size_t options_length = length - name_length - 1;\n+    *parsed_options = copy_string(equal_sign + 1);\n+  } else {\n+    *parsed_options = nullptr;\n+    name_length = length;\n+  }\n+  char* const name = AllocateHeap(name_length + 1, mtServiceability);\n+  jio_snprintf(name, name_length + 1, \"%s\", options);\n+  assert(strncmp(name, options, name_length) == 0, \"invariant\");\n+  return name;\n+}\n+\n+JvmtiAgent::JvmtiAgent(const char* name, const char* options, bool is_absolute_path, bool dynamic \/* false *\/) :\n+  _initialization_time(),\n+  _initialization_duration(),\n+  _next(nullptr),\n+  _name(copy_string(name)),\n+  _options(copy_string(options)),\n+  _os_lib(nullptr),\n+  _os_lib_path(nullptr),\n+  _jplis(nullptr),\n+  _loaded(false),\n+  _absolute_path(is_absolute_path),\n+  _static_lib(false),\n+  _instrument_lib(strcmp(name, \"instrument\") == 0),\n+  _dynamic(dynamic),\n+  _xrun(false) {}\n+\n+JvmtiAgent* JvmtiAgent::next() const {\n+  return _next;\n+}\n+\n+void JvmtiAgent::set_next(JvmtiAgent* agent) {\n+  _next = agent;\n+}\n+\n+const char* JvmtiAgent::name() const {\n+  return _name;\n+}\n+\n+const char* JvmtiAgent::options() const {\n+  return _options;\n+}\n+\n+void* JvmtiAgent::os_lib() const {\n+  return _os_lib;\n+}\n+\n+void JvmtiAgent::set_os_lib(void* os_lib) {\n+  _os_lib = os_lib;\n+}\n+\n+void JvmtiAgent::set_os_lib_path(const char* path) {\n+  assert(path != nullptr, \"invariant\");\n+  if (_os_lib_path == nullptr) {\n+    _os_lib_path = copy_string(path);\n+  }\n+  assert(strcmp(_os_lib_path, path) == 0, \"invariant\");\n+}\n+\n+const char* JvmtiAgent::os_lib_path() const {\n+  return _os_lib_path;\n+}\n+\n+bool JvmtiAgent::is_loaded() const {\n+  return _loaded;\n+}\n+\n+void JvmtiAgent::set_loaded() {\n+  _loaded = true;\n+}\n+\n+bool JvmtiAgent::is_absolute_path() const {\n+  return _absolute_path;\n+}\n+\n+bool JvmtiAgent::is_static_lib() const {\n+  return _static_lib;\n+}\n+\n+void JvmtiAgent::set_static_lib() {\n+  _static_lib = true;\n+}\n+\n+bool JvmtiAgent::is_dynamic() const {\n+  return _dynamic;\n+}\n+\n+bool JvmtiAgent:: is_instrument_lib() const {\n+  return _instrument_lib;\n+}\n+\n+bool JvmtiAgent::is_xrun() const {\n+  return _xrun;\n+}\n+\n+void JvmtiAgent::set_xrun() {\n+  _xrun = true;\n+}\n+\n+bool JvmtiAgent::is_jplis() const {\n+  return _jplis != nullptr;\n+}\n+\n+const Ticks& JvmtiAgent::initialization_time() const {\n+  return _initialization_time;\n+}\n+\n+const Tickspan& JvmtiAgent::initialization_duration() const {\n+  return _initialization_duration;\n+}\n+\n+bool JvmtiAgent::is_initialized() const {\n+  return _initialization_time.value() != 0;\n+}\n+\n+void JvmtiAgent::initialization_begin() {\n+  assert(!is_initialized(), \"invariant\");\n+  _initialization_time = Ticks::now();\n+}\n+\n+void JvmtiAgent::initialization_end() {\n+  assert(is_initialized(), \"invariant\");\n+  assert(_initialization_duration.value() == 0, \"invariant\");\n+  _initialization_duration = Ticks::now() - initialization_time();\n+}\n+\n+\/*\n+ * The implementation builds a mapping bewteen JvmtiEnvs and JPLIS agents,\n+ * using internal JDK implementation knowledge about the way JPLIS agents\n+ * store data in their JvmtiEnv local storage.\n+ *\n+ * Please see JPLISAgent.h and JPLISAgent.c in module java.instrument.\n+ *\n+ * jvmtierror = (*jvmtienv)->SetEnvironmentLocalStorage( jvmtienv, &(agent->mNormalEnvironment));\n+ *\n+ * It is the pointer to the field agent->mNormalEnvironment that is stored in the jvmtiEnv local storage.\n+ * It has the following type:\n+ *\n+ * struct _JPLISEnvironment {\n+ *   jvmtiEnv*   mJVMTIEnv;         \/\/ the JVMTI environment\n+ *   JPLISAgent* mAgent;            \/\/ corresponding agent\n+ *   jboolean    mIsRetransformer;  \/\/ indicates if special environment\n+ * };\n+ *\n+ * We mirror this struct to get the mAgent field as an identifier.\n+ *\/\n+\n+struct JPLISEnvironmentMirror {\n+  jvmtiEnv* mJVMTIEnv; \/\/ the JVMTI environment\n+  const void* mAgent;  \/\/ corresponding agent\n+  jboolean mIsRetransformer; \/\/ indicates if special environment\n+};\n+\n+static inline const JPLISEnvironmentMirror* get_env_local_storage(JvmtiEnv* env) {\n+  assert(env != nullptr, \"invariant\");\n+  return reinterpret_cast<const JPLISEnvironmentMirror*>(env->get_env_local_storage());\n+}\n+\n+bool JvmtiAgent::is_jplis(JvmtiEnv* env) const {\n+  assert(env != nullptr, \"invariant\");\n+  assert(is_instrument_lib(), \"invariant\");\n+  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n+  return jplis_env != nullptr && _jplis == jplis_env->mAgent;\n+}\n+\n+void JvmtiAgent::set_jplis(const void* jplis) {\n+  assert(jplis != nullptr, \"invaiant\");\n+  assert(is_instrument_lib(), \"invariant\");\n+  assert(_jplis == nullptr, \"invariant\");\n+  if (_options != nullptr) {\n+    \/\/ For JPLIS agents, update with the java name and options.\n+    os::free(const_cast<char*>(_name));\n+    const char* options = _options;\n+    _name = split_options_and_allocate_copy(options, &_options);\n+    os::free(const_cast<char*>(options));\n+  }\n+  _jplis = jplis;\n+}\n+\n+static const char* not_found_error_msg = \"Could not find agent library \";\n+static const char* missing_module_error_msg = \"\\nModule java.instrument may be missing from runtime image.\";\n+static char ebuf[1024];\n+static char buffer[JVM_MAXPATHLEN];\n+\n+static void vm_exit(const JvmtiAgent* agent, const char* sub_msg1, const char* sub_msg2) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(sub_msg1 != nullptr, \"invariant\");\n+  assert(!agent->is_instrument_lib() || sub_msg2 != nullptr, \"invariant\");\n+  const size_t len = strlen(not_found_error_msg) + strlen(agent->name()) + strlen(sub_msg1) + strlen(&ebuf[0]) + 1 + (agent->is_instrument_lib() ? strlen(sub_msg2) : 0);\n+  char* buf = NEW_C_HEAP_ARRAY(char, len, mtServiceability);\n+  if (agent->is_instrument_lib()) {\n+    jio_snprintf(buf, len, \"%s%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0], sub_msg2);\n+  } else {\n+    jio_snprintf(buf, len, \"%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0]);\n+  }\n+  vm_exit_during_initialization(buf, nullptr);\n+  FREE_C_HEAP_ARRAY(char, buf);\n+}\n+\n+#ifdef ASSERT\n+static void assert_preload(const JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_loaded(), \"invariant\");\n+}\n+#endif\n+\n+\/\/ Check for a statically linked-in agent, i.e. in the executable.\n+\/\/ This should be the first function called when loading an agent. It is a bit special:\n+\/\/ For statically linked agents we cant't rely on os_lib == nullptr because\n+\/\/ statically linked agents could have a handle of RTLD_DEFAULT which == 0 on some platforms.\n+\/\/ If this function returns true, then agent->is_static_lib().&& agent->is_loaded().\n+static bool load_agent_from_executable(JvmtiAgent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(on_load_symbols != nullptr, \"invariant\");\n+  return os::find_builtin_agent(agent, &on_load_symbols[0], num_symbol_entries);\n+}\n+\n+\/\/ Load the library from the absolute path of the agent, if available.\n+static void* load_agent_from_absolute_path(JvmtiAgent* agent, bool vm_exit_on_error) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(agent->is_absolute_path(), \"invariant\");\n+  assert(!agent->is_instrument_lib(), \"invariant\");\n+  void* const library = os::dll_load(agent->name(), &ebuf[0], sizeof ebuf);\n+  if (library == nullptr && vm_exit_on_error) {\n+    vm_exit(agent, \" in absolute path, with error: \", nullptr);\n+  }\n+  return library;\n+}\n+\n+\/\/ Agents with relative paths are loaded from the standard dll directory.\n+static void* load_agent_from_relative_path(JvmtiAgent* agent, bool vm_exit_on_error) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(!agent->is_absolute_path(), \"invariant\");\n+  const char* const name = agent->name();\n+  void* library = nullptr;\n+  \/\/ Try to load the agent from the standard dll directory\n+  if (os::dll_locate_lib(&buffer[0], sizeof buffer, Arguments::get_dll_dir(), name)) {\n+    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n+  }\n+  if (library == nullptr && os::dll_build_name(&buffer[0], sizeof buffer, name)) {\n+    \/\/ Try the library path directory.\n+    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n+    if (library != nullptr) {\n+      return library;\n+    }\n+    if (vm_exit_on_error) {\n+      vm_exit(agent, \" on the library path, with error: \", missing_module_error_msg);\n+    }\n+  }\n+  return library;\n+}\n+\n+\/\/ For absolute and relative paths.\n+static void* load_library(JvmtiAgent* agent, const char* on_symbols[], size_t num_symbol_entries, bool vm_exit_on_error) {\n+  return agent->is_absolute_path() ? load_agent_from_absolute_path(agent, vm_exit_on_error) :\n+                                     load_agent_from_relative_path(agent, vm_exit_on_error);\n+}\n+\n+\/\/ Type for the Agent_OnLoad and JVM_OnLoad entry points.\n+extern \"C\" {\n+  typedef jint(JNICALL* OnLoadEntry_t)(JavaVM*, char*, void*);\n+}\n+\n+\/\/ Find the OnLoad entry point for -agentlib:  -agentpath:   -Xrun agents.\n+\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n+static OnLoadEntry_t lookup_On_Load_entry_point(JvmtiAgent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+  assert(agent != nullptr, \"invariant\");\n+  if (!agent->is_loaded()) {\n+    if (!load_agent_from_executable(agent, on_load_symbols, num_symbol_entries)) {\n+      void* const library = load_library(agent, on_load_symbols, num_symbol_entries, \/* vm exit on error *\/ true);\n+      assert(library != nullptr, \"invariant\");\n+      agent->set_os_lib(library);\n+      agent->set_loaded();\n+    }\n+  }\n+  assert(agent->is_loaded(), \"invariant\");\n+  \/\/ Find the OnLoad function.\n+  return CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent, false, on_load_symbols, num_symbol_entries));\n+}\n+\n+static OnLoadEntry_t lookup_JVM_OnLoad_entry_point(JvmtiAgent* lib) {\n+  const char* on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n+  return lookup_On_Load_entry_point(lib, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+static OnLoadEntry_t lookup_Agent_OnLoad_entry_point(JvmtiAgent* agent) {\n+  const char* on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n+  return lookup_On_Load_entry_point(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+void JvmtiAgent::convert_xrun_agent() {\n+  assert(is_xrun(), \"invariant\");\n+  assert(!is_loaded(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(this);\n+  \/\/ If there is an JVM_OnLoad function it will get called later,\n+  \/\/ otherwise see if there is an Agent_OnLoad.\n+  if (on_load_entry == nullptr) {\n+    on_load_entry = lookup_Agent_OnLoad_entry_point(this);\n+    if (on_load_entry == nullptr) {\n+      vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", name());\n+    }\n+    _xrun = false; \/\/ converted\n+  }\n+}\n+\n+\/\/ Called after the VM is initialized for -Xrun agents which have not been converted to JVMTI agents.\n+static bool invoke_JVM_OnLoad(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_xrun(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(agent);\n+  if (on_load_entry == nullptr) {\n+    vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n+  }\n+  \/\/ Invoke the JVM_OnLoad function\n+  JavaThread* thread = JavaThread::current();\n+  ThreadToNativeFromVM ttn(thread);\n+  HandleMark hm(thread);\n+  extern struct JavaVM_ main_vm;\n+  const jint err = (*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), NULL);\n+  if (err != JNI_OK) {\n+    vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n+  }\n+  return true;\n+}\n+\n+\/\/ The newest jvmtiEnv is appended to the list,\n+\/\/ hence the JvmtiEnvIterator order is from oldest to newest.\n+static JvmtiEnv* get_last_jplis_jvmtienv() {\n+  JvmtiEnvIterator it;\n+  JvmtiEnv* env = it.first();\n+  assert(env != nullptr, \"invariant\");\n+  JvmtiEnv* next = it.next(env);\n+  while (next != nullptr) {\n+    assert(env != nullptr, \"invariant\");\n+    \/\/ get_env_local_storage() lets us find which JVMTI env map to which JPLIS agent.\n+    if (next->get_env_local_storage() == nullptr) {\n+      JvmtiEnv* temp = it.next(next);\n+      if (temp != nullptr) {\n+        next = temp;\n+        continue;\n+      }\n+      break;\n+    }\n+    env = next;\n+    next = it.next(env);\n+  }\n+  assert(env != nullptr, \"invariant\");\n+  assert(env->get_env_local_storage() != nullptr, \"invariant\");\n+  return env;\n+}\n+\n+\/\/ Associate the last, i.e. most recent, JvmtiEnv that is a JPLIS agent with the current agent.\n+static void convert_to_jplis(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_instrument_lib(), \"invariant\");\n+  JvmtiEnv* const env = get_last_jplis_jvmtienv();\n+  assert(env != nullptr, \"invariant\");\n+  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n+  assert(jplis_env != nullptr, \"invaiant\");\n+  assert(reinterpret_cast<JvmtiEnv*>(jplis_env->mJVMTIEnv) == env, \"invariant\");\n+  agent->set_jplis(jplis_env->mAgent);\n+}\n+\n+\/\/ Use this for JavaThreads and state is _thread_in_vm.\n+class AgentJavaThreadEventTransition : StackObj {\n+ private:\n+  ResourceMark _rm;\n+  ThreadToNativeFromVM _transition;\n+  HandleMark _hm;\n+ public:\n+  AgentJavaThreadEventTransition(JavaThread* thread) : _rm(), _transition(thread), _hm(thread) {};\n+};\n+\n+class AgentEventMark : StackObj {\n+ private:\n+  JavaThread* _thread;\n+  JNIEnv* _jni_env;\n+  JvmtiThreadState::ExceptionState _saved_exception_state;\n+\n+ public:\n+  AgentEventMark(JavaThread* thread) : _thread(thread),\n+                                       _jni_env(thread->jni_environment()),\n+                                       _saved_exception_state(JvmtiThreadState::ES_CLEARED) {\n+    JvmtiThreadState* state = thread->jvmti_thread_state();\n+    \/\/ we are before an event.\n+    \/\/ Save current jvmti thread exception state.\n+    if (state != nullptr) {\n+      _saved_exception_state = state->get_exception_state();\n+    }\n+    thread->push_jni_handle_block();\n+    assert(thread == JavaThread::current(), \"thread must be current!\");\n+    thread->frame_anchor()->make_walkable();\n+  }\n+\n+  ~AgentEventMark() {\n+    _thread->pop_jni_handle_block();\n+    JvmtiThreadState* state = _thread->jvmti_thread_state();\n+    \/\/ we are continuing after an event.\n+    if (state != nullptr) {\n+      \/\/ Restore the jvmti thread exception state.\n+      state->restore_exception_state(_saved_exception_state);\n+    }\n+  }\n+};\n+\n+class AgentThreadEventMark : public AgentEventMark {\n+ private:\n+  jobject _jthread;\n+ public:\n+  AgentThreadEventMark(JavaThread* thread) : AgentEventMark(thread),\n+                                             _jthread(JNIHandles::make_local(thread, thread->threadObj())) {}\n+  jthread jni_thread() { return (jthread)_jthread; }\n+};\n+\n+static void unload_library(JvmtiAgent* agent, void* library) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_loaded(), \"invariant\");\n+  if (!agent->is_static_lib()) {\n+    assert(library != nullptr, \"invariant\");\n+    os::dll_unload(library);\n+  }\n+}\n+\n+\/\/ type for the Agent_OnAttach entry point\n+extern \"C\" {\n+  typedef jint(JNICALL* OnAttachEntry_t)(JavaVM*, char*, void*);\n+}\n+\n+\/\/ Loading the agent by invoking Agent_OnAttach.\n+static bool invoke_Agent_OnAttach(JvmtiAgent* agent, outputStream* st) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(agent->is_dynamic(), \"invariant\");\n+  assert(st != nullptr, \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE, \"not in live phase!\");\n+  const char* on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n+  const size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n+  void* library = nullptr;\n+  if (!load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n+    library = load_library(agent, &on_attach_symbols[0], num_symbol_entries, \/* vm_exit_on_error *\/ false);\n+    if (library == nullptr) {\n+      st->print_cr(\"%s was not loaded.\", agent->name());\n+      if (*ebuf != '\\0') {\n+        st->print_cr(\"%s\", &ebuf[0]);\n+      }\n+      return false;\n+    }\n+    agent->set_os_lib_path(&buffer[0]);\n+    agent->set_os_lib(library);\n+    agent->set_loaded();\n+  }\n+  assert(agent->is_loaded(), \"invariant\");\n+  \/\/ The library was loaded so we attempt to lookup and invoke the Agent_OnAttach function.\n+  OnAttachEntry_t on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,\n+                                                   os::find_agent_function(agent, false, &on_attach_symbols[0], num_symbol_entries));\n+\n+  if (on_attach_entry == nullptr) {\n+    st->print_cr(\"%s is not available in %s\", on_attach_symbols[0], agent->name());\n+    unload_library(agent, library);\n+    return false;\n+  }\n+\n+  \/\/ Invoke the Agent_OnAttach function\n+  JavaThread* thread = JavaThread::current();\n+  jint result = JNI_ERR;\n+  {\n+    extern struct JavaVM_ main_vm;\n+    AgentThreadEventMark jem(thread);\n+    AgentJavaThreadEventTransition jet(thread);\n+\n+    agent->initialization_begin();\n+\n+    result = (*on_attach_entry)(&main_vm, (char*)agent->options(), nullptr);\n+\n+    agent->initialization_end();\n+\n+    \/\/ Agent_OnAttach may have used JNI\n+    if (thread->is_pending_jni_exception_check()) {\n+      thread->clear_pending_jni_exception_check();\n+    }\n+  }\n+\n+  \/\/ Agent_OnAttach may have used JNI\n+  if (thread->has_pending_exception()) {\n+    thread->clear_pending_exception();\n+  }\n+\n+  st->print_cr(\"return code: %d\", result);\n+\n+  if (result != JNI_OK) {\n+    unload_library(agent, library);\n+    return false;\n+  }\n+\n+  if (agent->is_instrument_lib()) {\n+    \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n+    convert_to_jplis(agent);\n+  }\n+  return true;\n+}\n+\n+\/\/ CDS dumping does not support native JVMTI agent.\n+\/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n+static void check_cds_dump(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(Arguments::is_dumping_archive(), \"invariant\");\n+  if (!agent->is_instrument_lib()) {\n+    vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n+  }\n+  if (!AllowArchivingWithJavaAgent) {\n+    vm_exit_during_cds_dumping(\n+      \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n+  }\n+}\n+\n+\/\/ Loading the agent by invoking Agent_OnLoad.\n+static bool invoke_Agent_OnLoad(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_xrun(), \"invariant\");\n+  assert(!agent->is_dynamic(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_ONLOAD, \"invariant\");\n+  if (Arguments::is_dumping_archive()) {\n+    check_cds_dump(agent);\n+  }\n+  OnLoadEntry_t on_load_entry = lookup_Agent_OnLoad_entry_point(agent);\n+  if (on_load_entry == nullptr) {\n+    vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n+  }\n+  \/\/ Invoke the Agent_OnLoad function\n+  extern struct JavaVM_ main_vm;\n+  if ((*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), nullptr) != JNI_OK) {\n+    vm_exit_during_initialization(\"agent library failed Agent_OnLoad\", agent->name());\n+  }\n+  \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n+  if (agent->is_instrument_lib()) {\n+    convert_to_jplis(agent);\n+  }\n+  return true;\n+}\n+\n+bool JvmtiAgent::load(outputStream* st \/* nullptr *\/) {\n+  if (is_xrun()) {\n+    return invoke_JVM_OnLoad(this);\n+  }\n+  return is_dynamic() ? invoke_Agent_OnAttach(this, st) : invoke_Agent_OnLoad(this);\n+}\n+\n+extern \"C\" {\n+  typedef void (JNICALL* Agent_OnUnload_t)(JavaVM*);\n+}\n+\n+void JvmtiAgent::unload() {\n+  const char* on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n+  \/\/ Find the Agent_OnUnload function.\n+  Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n+                                                 os::find_agent_function(this, false, &on_unload_symbols[0], ARRAY_SIZE(on_unload_symbols)));\n+  if (unload_entry != nullptr) {\n+    \/\/ Invoke the Agent_OnUnload function\n+    JavaThread* thread = JavaThread::current();\n+    ThreadToNativeFromVM ttn(thread);\n+    HandleMark hm(thread);\n+    extern struct JavaVM_ main_vm;\n+    (*unload_entry)(&main_vm);\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":620,"deletions":0,"binary":false,"changes":620,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_PRIMS_JVMTIAGENT_HPP\n+#define SHARE_PRIMS_JVMTIAGENT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class JvmtiEnv;\n+class outputStream;\n+\n+\/\/ Represents an agent launched on the command-line by -agentlib, -agentpath or -Xrun.\n+\/\/ Also agents loaded dynamically during runtime, for example using the Attach API.\n+class JvmtiAgent : public CHeapObj<mtServiceability> {\n+  friend class JvmtiAgentList;\n+ private:\n+  Ticks _initialization_time;\n+  Tickspan _initialization_duration;\n+  JvmtiAgent* _next;\n+  const char* _name;\n+  const char* _options;\n+  void* _os_lib;\n+  const char* _os_lib_path;\n+  const void* _jplis;\n+  bool _loaded;\n+  bool _absolute_path;\n+  bool _static_lib;\n+  bool _instrument_lib;\n+  bool _dynamic;\n+  bool _xrun;\n+\n+  JvmtiAgent* next() const;\n+  void set_next(JvmtiAgent* agent);\n+  void convert_xrun_agent();\n+  void set_xrun();\n+\n+ public:\n+  JvmtiAgent(const char* name, const char* options, bool is_absolute_path, bool dynamic = false);\n+  const char* name() const;\n+  const char* options() const;\n+  bool is_absolute_path() const;\n+  void* os_lib() const;\n+  void set_os_lib(void* os_lib);\n+  const char* os_lib_path() const;\n+  void set_os_lib_path(const char* path);\n+  bool is_static_lib() const;\n+  void set_static_lib();\n+  bool is_dynamic() const;\n+  bool is_xrun() const;\n+  bool is_instrument_lib() const;\n+  bool is_loaded() const;\n+  void set_loaded();\n+  bool is_jplis() const;\n+  bool is_jplis(JvmtiEnv* env) const;\n+  void set_jplis(const void* jplis);\n+  bool is_initialized() const;\n+  void initialization_begin();\n+  void initialization_end();\n+  const Ticks& initialization_time() const;\n+  const Tickspan& initialization_duration() const;\n+\n+  bool load(outputStream* st = nullptr);\n+  void unload();\n+};\n+\n+#endif \/\/ SHARE_PRIMS_JVMTIAGENT_HPP\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n+\n+#include \"prims\/jvmtiEnvBase.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+JvmtiAgent* JvmtiAgentList::_list = nullptr;\n+\n+\/\/ Selection as a function of the filter.\n+JvmtiAgent* JvmtiAgentList::Iterator::select(JvmtiAgent* agent) const {\n+  while (agent != nullptr) {\n+    if (_filter == ALL) {\n+      return agent;\n+    } else if (_filter == NOT_XRUN) {\n+      if (!agent->is_xrun()) {\n+        return agent;\n+      }\n+    } else if (_filter == JAVA) {\n+      if (agent->is_jplis()) {\n+        return agent;\n+      }\n+    } else if (_filter == NATIVE) {\n+      if (!agent->is_jplis() && !agent->is_xrun()) {\n+        return agent;\n+      }\n+    } else {\n+      assert(_filter == XRUN, \"invariant\");\n+      if (agent->is_xrun()) {\n+        return agent;\n+      }\n+    }\n+    agent = agent->next();\n+  }\n+  return nullptr;\n+}\n+\n+static inline JvmtiAgent* head(JvmtiAgent** list) {\n+  assert(list != nullptr, \"invariant\");\n+  return Atomic::load_acquire(list);\n+}\n+\n+\n+\/\/ The storage list is a single cas-linked-list, to allow for concurrent iterations. Especially during initial loading of agents,\n+\/\/ there exist an order requirement to iterate oldest -> newest. Our concurrent storage linked-list is newest -> oldest.\n+\/\/ The correct order is preserved by the iterator, by storing a filtered set of entries in a stack.\n+JvmtiAgentList::Iterator::Iterator(JvmtiAgent** list, Filter filter) : _stack(new GrowableArrayCHeap<JvmtiAgent*, mtServiceability>(16)), _filter(filter) {\n+  JvmtiAgent* next = head(list);\n+  while (next != nullptr) {\n+    next = select(next);\n+    if (next != nullptr) {\n+      _stack->push(next);\n+      next = next->next();\n+    }\n+  }\n+}\n+\n+JvmtiAgentList::Iterator::~Iterator() {\n+  delete _stack;\n+}\n+\n+bool JvmtiAgentList::Iterator::has_next() const {\n+  assert(_stack != nullptr, \"invariant\");\n+  return _stack->is_nonempty();\n+}\n+\n+const JvmtiAgent* JvmtiAgentList::Iterator::next() const {\n+  assert(has_next(), \"invariant\");\n+  return _stack->pop();\n+}\n+\n+JvmtiAgent* JvmtiAgentList::Iterator::next() {\n+  return const_cast<JvmtiAgent*>(const_cast<const Iterator*>(this)->next());\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::agents() {\n+  return Iterator(&_list, Iterator::NOT_XRUN);\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::java_agents() {\n+  return Iterator(&_list, Iterator::JAVA);\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::native_agents() {\n+  return Iterator(&_list, Iterator::NATIVE);\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::xrun_agents() {\n+  return Iterator(&_list, Iterator::XRUN);\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::all() {\n+  return Iterator(&_list, Iterator::ALL);\n+}\n+\n+void JvmtiAgentList::add(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  JvmtiAgent* next;\n+  do {\n+    next = head(&_list);\n+    agent->set_next(next);\n+  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n+}\n+\n+void JvmtiAgentList::add(const char* name, char* options, bool absolute_path) {\n+  add(new JvmtiAgent(name, options, absolute_path));\n+}\n+\n+void JvmtiAgentList::add_xrun(const char* name, char* options, bool absolute_path) {\n+  JvmtiAgent* agent = new JvmtiAgent(name, options, absolute_path);\n+  agent->set_xrun();\n+  add(agent);\n+}\n+\n+#ifdef ASSERT\n+static void assert_initialized(JvmtiAgentList::Iterator& it) {\n+  while (it.has_next()) {\n+    assert(it.next()->is_initialized(), \"invariant\");\n+  }\n+}\n+#endif\n+\n+\/\/ In case an agent did not enable the VMInit callback, or if it is an -Xrun agent,\n+\/\/ it gets an initializiation timestamp here.\n+void JvmtiAgentList::initialize() {\n+  Iterator it = all();\n+  while (it.has_next()) {\n+    JvmtiAgent* agent = it.next();\n+    if (!agent->is_initialized()) {\n+      agent->initialization_begin();\n+    }\n+  }\n+  DEBUG_ONLY(Iterator assert_it = all(); assert_initialized(assert_it);)\n+}\n+\n+void JvmtiAgentList::convert_xrun_agents() {\n+  Iterator it = xrun_agents();\n+  while (it.has_next()) {\n+    it.next()->convert_xrun_agent();\n+  }\n+}\n+\n+class JvmtiPhaseTransition : public StackObj {\n+ public:\n+  JvmtiPhaseTransition() {\n+    assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+    JvmtiExport::enter_onload_phase();\n+  }\n+  ~JvmtiPhaseTransition() {\n+    assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_ONLOAD, \"invariant\");\n+    JvmtiExport::enter_primordial_phase();\n+  }\n+};\n+\n+static void load_agents(JvmtiAgentList::Iterator& it) {\n+  while (it.has_next()) {\n+    it.next()->load();\n+  }\n+}\n+\n+\/\/ Invokes Agent_OnLoad for -agentlib:.. -agentpath:  and converted -Xrun agents.\n+\/\/ Called very early -- before JavaThreads exist\n+void JvmtiAgentList::load_agents() {\n+  \/\/ Convert -Xrun to -agentlib: if there is no JVM_OnLoad\n+  convert_xrun_agents();\n+  JvmtiPhaseTransition transition;\n+  Iterator it = agents();\n+  ::load_agents(it);\n+}\n+\n+\/\/ Launch -Xrun agents\n+void JvmtiAgentList::load_xrun_agents() {\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  Iterator it = xrun_agents();\n+  ::load_agents(it);\n+}\n+\n+\/\/ Invokes Agent_OnAttach for agents loaded dynamically during runtime.\n+jint JvmtiAgentList::load_agent(const char* agent_name, const char* absParam,\n+                           const char* options, outputStream* st) {\n+  \/\/ The abs parameter should be \"true\" or \"false\"\n+  const bool is_absolute_path = (absParam != nullptr) && (strcmp(absParam, \"true\") == 0);\n+  JvmtiAgent* const agent = new JvmtiAgent(agent_name, options, is_absolute_path, \/* dynamic agent *\/ true);\n+  if (agent->load(st)) {\n+    add(agent);\n+  } else {\n+    delete agent;\n+  }\n+  \/\/ Agent_OnAttach executed so completion status is JNI_OK\n+  return JNI_OK;\n+}\n+\n+\/\/ Send any Agent_OnUnload notifications\n+void JvmtiAgentList::unload_agents() {\n+  Iterator it = agents();\n+  while (it.has_next()) {\n+    it.next()->unload();\n+  }\n+}\n+\n+static bool match(JvmtiEnv* env, const JvmtiAgent* agent, const void* os_module_address) {\n+  assert(env != nullptr, \"invariant\");\n+  assert(agent != nullptr, \"invariant\");\n+  if (agent->is_static_lib()) {\n+    return os::get_default_process_handle() == os_module_address;\n+  }\n+  if (agent->os_lib() != os_module_address) {\n+    return false;\n+  }\n+  return agent->is_instrument_lib() ? agent->is_jplis(env) : true;\n+}\n+\n+\/\/ The function pointer is a JVMTI callback function.\n+\/\/ Find the os module (dll) that exports this function.\n+\/\/ Now we can map a JVMTI env to its corresponding agent.\n+JvmtiAgent* JvmtiAgentList::lookup(JvmtiEnv* env, void* f_ptr) {\n+  assert(env != nullptr, \"invariant\");\n+  assert(f_ptr != nullptr, \"invariant\");\n+  static char ebuf[1024];\n+  static char buffer[JVM_MAXPATHLEN];\n+  int offset;\n+  if (!os::dll_address_to_library_name(reinterpret_cast<address>(f_ptr), &buffer[0], JVM_MAXPATHLEN, &offset)) {\n+    return nullptr;\n+  }\n+  assert(buffer[0] != '\\0', \"invariant\");\n+  assert(offset >= 0, \"invariant\");\n+  const void* const os_module_address = reinterpret_cast<address>(f_ptr) - offset;\n+\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (match(env, agent, os_module_address)) {\n+      agent->set_os_lib_path(&buffer[0]);\n+      return agent;\n+    }\n+  }\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_PRIMS_JVMTIAGENTLIST_HPP\n+#define SHARE_PRIMS_JVMTIAGENTLIST_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"prims\/jvmtiAgent.hpp\"\n+\n+template <typename, MEMFLAGS>\n+class GrowableArrayCHeap;\n+class JvmtiEnv;\n+\n+\/\/ Maintains a single cas linked-list of JvmtiAgents.\n+class JvmtiAgentList : AllStatic {\n+  friend class Iterator;\n+  friend class JvmtiExport;\n+ public:\n+  class Iterator {\n+    friend class JvmtiAgentList;\n+   private:\n+    enum Filter {\n+      JAVA,\n+      NATIVE,\n+      XRUN,\n+      NOT_XRUN,\n+      ALL\n+    };\n+    GrowableArrayCHeap<JvmtiAgent*, mtServiceability>* _stack;\n+    const Filter _filter;\n+    Iterator(JvmtiAgent** list, Filter filter);\n+    JvmtiAgent* select(JvmtiAgent* agent) const;\n+   public:\n+    bool has_next() const;\n+    JvmtiAgent* next();\n+    const JvmtiAgent* next() const;\n+    ~Iterator();\n+  };\n+\n+ private:\n+  static JvmtiAgent* _list;\n+\n+  static Iterator all();\n+  static void initialize();\n+  static void convert_xrun_agents();\n+\n+ public:\n+  static void add(JvmtiAgent* agent);\n+  static void add(const char* name, char* options, bool absolute_path);\n+  static void add_xrun(const char* name, char* options, bool absolute_path);\n+\n+  static void load_agents();\n+  static jint load_agent(const char* agent, const char* absParam,\n+                         const char* options, outputStream* st);\n+  static void load_xrun_agents();\n+  static void unload_agents();\n+\n+  static JvmtiAgent* lookup(JvmtiEnv* env, void* f_ptr);\n+\n+  static Iterator agents();\n+  static Iterator java_agents();\n+  static Iterator native_agents();\n+  static Iterator xrun_agents();\n+};\n+\n+#endif \/\/ SHARE_PRIMS_JVMTIAGENTLIST_HPP\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"prims\/agentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -694,1 +694,1 @@\n-\/\/ Lookup an agent from an JvmtiEnv.Return agent only if it is not yet initialized.\n+\/\/ Lookup an agent from an JvmtiEnv. Return agent only if it is not yet initialized.\n@@ -696,2 +696,2 @@\n-static Agent* lookup_uninitialized_agent(JvmtiEnv* env, void* callback) {\n-  Agent* const agent = AgentList::lookup(env, callback);\n+static JvmtiAgent* lookup_uninitialized_agent(JvmtiEnv* env, void* callback) {\n+  JvmtiAgent* const agent = JvmtiAgentList::lookup(env, callback);\n@@ -717,1 +717,1 @@\n-        Agent* const agent = lookup_uninitialized_agent(env, reinterpret_cast<void*>(callback));\n+        JvmtiAgent* const agent = lookup_uninitialized_agent(env, reinterpret_cast<void*>(callback));\n@@ -732,1 +732,1 @@\n-  AgentList::initialize();\n+  JvmtiAgentList::initialize();\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"prims\/agentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -289,1 +289,1 @@\n-    AgentList::Iterator it = AgentList::agents();\n+    JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"prims\/agentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -2343,1 +2343,1 @@\n-        AgentList::add_xrun(name, options, false);\n+        JvmtiAgentList::add_xrun(name, options, false);\n@@ -2415,1 +2415,1 @@\n-        AgentList::add(name, options, is_absolute_path);\n+        JvmtiAgentList::add(name, options, is_absolute_path);\n@@ -2430,1 +2430,1 @@\n-        AgentList::add(\"instrument\", options, false);\n+        JvmtiAgentList::add(\"instrument\", options, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"prims\/agentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -520,1 +520,1 @@\n-  AgentList::unload_agents();\n+  JvmtiAgentList::unload_agents();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"prims\/agent.hpp\"\n+#include \"prims\/jvmtiAgent.hpp\"\n@@ -538,1 +538,1 @@\n-void* os::find_agent_function(Agent *agent_lib, bool check_lib,\n+void* os::find_agent_function(JvmtiAgent *agent_lib, bool check_lib,\n@@ -565,1 +565,1 @@\n-bool os::find_builtin_agent(Agent* agent, const char *syms[],\n+bool os::find_builtin_agent(JvmtiAgent* agent, const char *syms[],\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-class Agent;\n@@ -39,0 +38,1 @@\n+class JvmtiAgent;\n@@ -735,1 +735,1 @@\n-  static bool find_builtin_agent(Agent *agent_lib, const char *syms[],\n+  static bool find_builtin_agent(JvmtiAgent *agent_lib, const char *syms[],\n@@ -739,1 +739,1 @@\n-  static void *find_agent_function(Agent *agent_lib, bool check_lib,\n+  static void *find_agent_function(JvmtiAgent *agent_lib, bool check_lib,\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-#include \"prims\/agentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -501,1 +501,1 @@\n-  AgentList::load_agents();\n+  JvmtiAgentList::load_agents();\n@@ -626,1 +626,1 @@\n-    AgentList::load_xrun_agents();\n+    JvmtiAgentList::load_xrun_agents();\n@@ -666,1 +666,1 @@\n-    AgentList::load_xrun_agents();\n+    JvmtiAgentList::load_xrun_agents();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"prims\/agentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -138,1 +138,1 @@\n-  return AgentList::load_agent(agent, absParam, options, out);\n+  return JvmtiAgentList::load_agent(agent, absParam, options, out);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"prims\/agentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -311,1 +311,1 @@\n-      AgentList::load_agent(\"instrument\", \"false\", _libpath.value(), output());\n+      JvmtiAgentList::load_agent(\"instrument\", \"false\", _libpath.value(), output());\n@@ -328,1 +328,1 @@\n-      AgentList::load_agent(\"instrument\", \"false\", opt, output());\n+      JvmtiAgentList::load_agent(\"instrument\", \"false\", opt, output());\n@@ -333,1 +333,1 @@\n-    AgentList::load_agent(_libpath.value(), \"true\", _option.value(), output());\n+    JvmtiAgentList::load_agent(_libpath.value(), \"true\", _option.value(), output());\n@@ -1043,1 +1043,1 @@\n-    AgentList::Iterator it = AgentList::agents();\n+    JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n@@ -1045,1 +1045,1 @@\n-      Agent* agent = it.next();\n+      JvmtiAgent* agent = it.next();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}