{"files":[{"patch":"@@ -1180,2 +1180,2 @@\n-    <Field type=\"Ticks\" name=\"initialization\" label=\"Initialization\" description=\"The time the JVM initialized the agent\" \/>\n-    <Field type=\"Tickspan\" name=\"initializationTime\" label=\"Initialization Time\" description=\"The duration of executing the initialization method exported by the agent\" \/>\n+    <Field type=\"Ticks\" name=\"initializationTime\" label=\"Initialization Time\" description=\"The time the JVM initialized the agent\" \/>\n+    <Field type=\"Tickspan\" name=\"initializationDuration\" label=\"Initialization Duration\" description=\"The duration of executing the initialization method, either premain or agentmain\" \/>\n@@ -1189,2 +1189,2 @@\n-    <Field type=\"Ticks\" name=\"initialization\" label=\"Initialization\" description=\"The time the JVM initialized the agent\" \/>\n-    <Field type=\"Tickspan\" name=\"initializationTime\" label=\"Initialization Time\" description=\"The duration of executing the initialization function exported by the agent\" \/>\n+    <Field type=\"Ticks\" name=\"initializationTime\" label=\"Initialization Time\" description=\"The time the JVM initialized the agent\" \/>\n+    <Field type=\"Tickspan\" name=\"initializationDuration\" label=\"Initialization Duration\" description=\"The duration of executing the JVMTI VMInit event callback. If no VMInit callback is specified, the duration is 0. For a dynamically loaded agent, the duration of executing the call to Agent_OnAttach.\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -278,1 +278,0 @@\n-  event.set_initialization(agent->initialization());\n@@ -280,0 +279,1 @@\n+  event.set_initializationDuration(agent->initialization_duration());\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"cds\/cds_globals.hpp\"\n+#include \"jni.h\"\n@@ -28,0 +30,10 @@\n+#include \"jvmtifiles\/jvmtiEnv.hpp\"\n+#include \"prims\/jvmtiEnvBase.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n@@ -29,3 +41,2 @@\n-static void free_string(const char* str) {\n-  assert(str != nullptr, \"invariant\");\n-  FreeHeap(const_cast<char*>(str));\n+static inline const char* copy_string(const char* str) {\n+  return str != nullptr ? os::strdup(str, mtServiceability) : nullptr;\n@@ -34,12 +45,1 @@\n-static const char* allocate_copy(const char* str) {\n-  if (str == nullptr) {\n-    return nullptr;\n-  }\n-  const size_t length = strlen(str);\n-  char* copy = AllocateHeap(length + 1, mtInternal);\n-  strncpy(copy, str, length + 1);\n-  assert(strncmp(copy, str, length + 1) == 0, \"invariant\");\n-  return copy;\n-}\n-\n-\/\/ returns the lhs before '=', parsed_options output param gets the rhs.\n+\/\/ Returns the lhs before '=', parsed_options output param gets the rhs.\n@@ -55,1 +55,1 @@\n-    *parsed_options = allocate_copy(equal_sign + 1);\n+    *parsed_options = copy_string(equal_sign + 1);\n@@ -60,1 +60,1 @@\n-  char* const name = AllocateHeap(name_length + 1, mtInternal);\n+  char* const name = AllocateHeap(name_length + 1, mtServiceability);\n@@ -66,3 +66,3 @@\n-Agent::Agent(const char* name, const char* options, bool is_absolute_path) :\n-  _init(),\n-  _init_time(),\n+Agent::Agent(const char* name, const char* options, bool is_absolute_path, bool dynamic \/* false *\/) :\n+  _initialization_time(),\n+  _initialization_duration(),\n@@ -70,2 +70,2 @@\n-  _name(allocate_copy(name)),\n-  _options(allocate_copy(options)),\n+  _name(copy_string(name)),\n+  _options(copy_string(options)),\n@@ -75,6 +75,6 @@\n-  _valid(false),\n-  _is_absolute_path(is_absolute_path),\n-  _is_static_lib(false),\n-  _is_dynamic(false),\n-  _is_instrument_lib(strcmp(name, \"instrument\") == 0),\n-  _is_xrun(false) {}\n+  _loaded(false),\n+  _absolute_path(is_absolute_path),\n+  _static_lib(false),\n+  _instrument_lib(strcmp(name, \"instrument\") == 0),\n+  _dynamic(dynamic),\n+  _xrun(false) {}\n@@ -86,0 +86,4 @@\n+void Agent::set_next(Agent* agent) {\n+  _next = agent;\n+}\n+\n@@ -94,4 +98,0 @@\n-bool Agent::is_absolute_path() const {\n-  return _is_absolute_path;\n-}\n-\n@@ -109,1 +109,1 @@\n-  _os_lib_path = allocate_copy(path);\n+  _os_lib_path = copy_string(path);\n@@ -116,0 +116,12 @@\n+bool Agent::is_loaded() const {\n+  return _loaded;\n+}\n+\n+void Agent::set_loaded() {\n+  _loaded = true;\n+}\n+\n+bool Agent::is_absolute_path() const {\n+  return _absolute_path;\n+}\n+\n@@ -117,1 +129,1 @@\n-  return _is_static_lib;\n+  return _static_lib;\n@@ -121,1 +133,1 @@\n-  _is_static_lib = true;\n+  _static_lib = true;\n@@ -125,1 +137,1 @@\n-  return _is_dynamic;\n+  return _dynamic;\n@@ -129,1 +141,1 @@\n-  return _is_instrument_lib;\n+  return _instrument_lib;\n@@ -132,2 +144,2 @@\n-bool Agent::is_valid() const {\n-  return _valid;\n+bool Agent::is_xrun() const {\n+  return _xrun;\n@@ -136,2 +148,2 @@\n-void Agent::set_valid() {\n-  _valid = true;\n+void Agent::set_xrun() {\n+  _xrun = true;\n@@ -140,2 +152,14 @@\n-const Ticks& Agent::initialization() const {\n-  return _init;\n+bool Agent::is_jplis() const {\n+  return _jplis != nullptr;\n+}\n+\n+const Ticks& Agent::initialization_time() const {\n+  return _initialization_time;\n+}\n+\n+const Tickspan& Agent::initialization_duration() const {\n+  return _initialization_duration;\n+}\n+\n+bool Agent::is_initialized() const {\n+  return _initialization_time.value() != 0;\n@@ -144,2 +168,48 @@\n-const Tickspan& Agent::initialization_time() const {\n-  return _init_time;\n+void Agent::initialization_begin() {\n+  assert(!is_initialized(), \"invariant\");\n+  _initialization_time = Ticks::now();\n+}\n+\n+void Agent::initialization_end() {\n+  assert(is_initialized(), \"invariant\");\n+  assert(_initialization_duration.value() == 0, \"invariant\");\n+  _initialization_duration = Ticks::now() - initialization_time();\n+}\n+\n+\/*\n+ * The implementation builds a mapping bewteen JvmtiEnvs and JPLIS agents,\n+ * using internal JDK implementation knowledge about the way JPLIS agents\n+ * store data in their JvmtiEnv local storage.\n+ *\n+ * Please see JPLISAgent.h and JPLISAgent.c in module java.instrument.\n+ *\n+ * jvmtierror = (*jvmtienv)->SetEnvironmentLocalStorage( jvmtienv, &(agent->mNormalEnvironment));\n+ *\n+ * It is the pointer to the field agent->mNormalEnvironment that is stored in the jvmtiEnv local storage.\n+ * It has the following type:\n+ *\n+ * struct _JPLISEnvironment {\n+ *   jvmtiEnv*   mJVMTIEnv;         \/\/ the JVMTI environment\n+ *   JPLISAgent* mAgent;            \/\/ corresponding agent\n+ *   jboolean    mIsRetransformer;  \/\/ indicates if special environment\n+ * };\n+ *\n+ * We mirror this struct to get the mAgent field as an identifier.\n+ *\/\n+\n+struct JPLISEnvironmentMirror {\n+  jvmtiEnv* mJVMTIEnv; \/\/ the JVMTI environment\n+  const void* mAgent;  \/\/ corresponding agent\n+  jboolean mIsRetransformer; \/\/ indicates if special environment\n+};\n+\n+static inline const JPLISEnvironmentMirror* get_env_local_storage(JvmtiEnv* env) {\n+  assert(env != nullptr, \"invariant\");\n+  return reinterpret_cast<const JPLISEnvironmentMirror*>(env->get_env_local_storage());\n+}\n+\n+bool Agent::is_jplis(JvmtiEnv* env) const {\n+  assert(env != nullptr, \"invariant\");\n+  assert(is_instrument_lib(), \"invariant\");\n+  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n+  return jplis_env != nullptr && _jplis == jplis_env->mAgent;\n@@ -154,1 +224,1 @@\n-    free_string(_name);\n+    os::free(const_cast<char*>(_name));\n@@ -157,1 +227,1 @@\n-    free_string(options);\n+    os::free(const_cast<char*>(options));\n@@ -162,2 +232,18 @@\n-bool Agent::is_jplis() const {\n-  return _jplis != nullptr;\n+static const char* not_found_error_msg = \"Could not find agent library \";\n+static const char* missing_module_error_msg = \"\\nModule java.instrument may be missing from runtime image.\";\n+static char ebuf[1024];\n+static char buffer[JVM_MAXPATHLEN];\n+\n+static void vm_exit(const Agent* agent, const char* sub_msg1, const char* sub_msg2) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(sub_msg1 != nullptr, \"invariant\");\n+  assert(!agent->is_instrument_lib() || sub_msg2 != nullptr, \"invariant\");\n+  const size_t len = strlen(not_found_error_msg) + strlen(agent->name()) + strlen(sub_msg1) + strlen(&ebuf[0]) + 1 + (agent->is_instrument_lib() ? strlen(sub_msg2) : 0);\n+  char* buf = NEW_C_HEAP_ARRAY(char, len, mtServiceability);\n+  if (agent->is_instrument_lib()) {\n+    jio_snprintf(buf, len, \"%s%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0], sub_msg2);\n+  } else {\n+    jio_snprintf(buf, len, \"%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0]);\n+  }\n+  vm_exit_during_initialization(buf, nullptr);\n+  FREE_C_HEAP_ARRAY(char, buf);\n@@ -166,4 +252,4 @@\n-bool Agent::is_jplis(const void* jplis) const {\n-  assert(jplis != nullptr, \"invariant\");\n-  assert(is_instrument_lib(), \"invariant\");\n-  return jplis == _jplis;\n+#ifdef ASSERT\n+static void assert_preload(const Agent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_loaded(), \"invariant\");\n@@ -171,0 +257,1 @@\n+#endif\n@@ -172,2 +259,9 @@\n-bool Agent::is_timestamped() const {\n-  return _init.value() != 0;\n+\/\/ Check for a statically linked-in agent, i.e. in the executable.\n+\/\/ This should be the first function called when loading an agent. It is a bit special:\n+\/\/ For statically linked agents we cant't rely on os_lib == nullptr because\n+\/\/ statically linked agents could have a handle of RTLD_DEFAULT which == 0 on some platforms.\n+\/\/ If this function returns true, then agent->is_static_lib().&& agent->is_loaded().\n+static bool load_agent_from_executable(Agent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(on_load_symbols != nullptr, \"invariant\");\n+  return os::find_builtin_agent(agent, &on_load_symbols[0], num_symbol_entries);\n@@ -176,3 +270,10 @@\n-void Agent::timestamp() {\n-  assert(_init.value() == 0, \"invariant\");\n-  _init = Ticks::now();\n+\/\/ Load the library from the absolute path of the agent, if available.\n+static void* load_agent_from_absolute_path(Agent* agent, bool vm_exit_on_error) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(agent->is_absolute_path(), \"invariant\");\n+  assert(!agent->is_instrument_lib(), \"invariant\");\n+  void* const library = os::dll_load(agent->name(), &ebuf[0], sizeof ebuf);\n+  if (library == nullptr && vm_exit_on_error) {\n+    vm_exit(agent, \" in absolute path, with error: \", nullptr);\n+  }\n+  return library;\n@@ -181,2 +282,21 @@\n-void Agent::initialization_begin() {\n-  timestamp();\n+\/\/ Agents with relative paths are loaded from the standard dll directory.\n+static void* load_agent_from_relative_path(Agent* agent, bool vm_exit_on_error) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(!agent->is_absolute_path(), \"invariant\");\n+  const char* const name = agent->name();\n+  void* library = nullptr;\n+  \/\/ Try to load the agent from the standard dll directory\n+  if (os::dll_locate_lib(&buffer[0], sizeof buffer, Arguments::get_dll_dir(), name)) {\n+    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n+  }\n+  if (library == nullptr && os::dll_build_name(&buffer[0], sizeof buffer, name)) {\n+    \/\/ Try the library path directory.\n+    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n+    if (library != nullptr) {\n+      return library;\n+    }\n+    if (vm_exit_on_error) {\n+      vm_exit(agent, \" on the library path, with error: \", missing_module_error_msg);\n+    }\n+  }\n+  return library;\n@@ -185,4 +305,313 @@\n-void Agent::initialization_end() {\n-  assert(is_timestamped(), \"invariant\");\n-  assert(_init_time.value() == 0, \"invariant\");\n-  _init_time = Ticks::now() - initialization();\n+\/\/ For absolute and relative paths.\n+static void* load_library(Agent* agent, const char* on_symbols[], size_t num_symbol_entries, bool vm_exit_on_error) {\n+  return agent->is_absolute_path() ? load_agent_from_absolute_path(agent, vm_exit_on_error) :\n+                                     load_agent_from_relative_path(agent, vm_exit_on_error);\n+}\n+\n+\/\/ Type for the Agent_OnLoad and JVM_OnLoad entry points.\n+extern \"C\" {\n+  typedef jint(JNICALL* OnLoadEntry_t)(JavaVM*, char*, void*);\n+}\n+\n+\/\/ Find the OnLoad entry point for -agentlib:  -agentpath:   -Xrun agents.\n+\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n+static OnLoadEntry_t lookup_On_Load_entry_point(Agent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+  assert(agent != nullptr, \"invariant\");\n+  if (!agent->is_loaded()) {\n+    if (!load_agent_from_executable(agent, on_load_symbols, num_symbol_entries)) {\n+      void* const library = load_library(agent, on_load_symbols, num_symbol_entries, \/* vm exit on error *\/ true);\n+      assert(library != nullptr, \"invariant\");\n+      agent->set_os_lib(library);\n+      agent->set_loaded();\n+    }\n+  }\n+  assert(agent->is_loaded(), \"invariant\");\n+  \/\/ Find the OnLoad function.\n+  return CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent, false, on_load_symbols, num_symbol_entries));\n+}\n+\n+static OnLoadEntry_t lookup_JVM_OnLoad_entry_point(Agent* lib) {\n+  const char* on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n+  return lookup_On_Load_entry_point(lib, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+static OnLoadEntry_t lookup_Agent_OnLoad_entry_point(Agent* agent) {\n+  const char* on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n+  return lookup_On_Load_entry_point(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+void Agent::convert_xrun_agent() {\n+  assert(is_xrun(), \"invariant\");\n+  assert(!is_loaded(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(this);\n+  \/\/ If there is an JVM_OnLoad function it will get called later,\n+  \/\/ otherwise see if there is an Agent_OnLoad.\n+  if (on_load_entry == nullptr) {\n+    on_load_entry = lookup_Agent_OnLoad_entry_point(this);\n+    if (on_load_entry == nullptr) {\n+      vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", name());\n+    }\n+    _xrun = false; \/\/ converted\n+  }\n+}\n+\n+\/\/ Called after the VM is initialized for -Xrun agents which have not been converted to JVMTI agents.\n+static bool invoke_JVM_OnLoad(Agent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_xrun(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(agent);\n+  if (on_load_entry == nullptr) {\n+    vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n+  }\n+  \/\/ Invoke the JVM_OnLoad function\n+  JavaThread* thread = JavaThread::current();\n+  ThreadToNativeFromVM ttn(thread);\n+  HandleMark hm(thread);\n+  extern struct JavaVM_ main_vm;\n+  const jint err = (*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), NULL);\n+  if (err != JNI_OK) {\n+    vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n+  }\n+  return true;\n+}\n+\n+\/\/ The newest jvmtiEnv is appended to the list,\n+\/\/ hence the JvmtiEnvIterator order is from oldest to newest.\n+static JvmtiEnv* get_last_jplis_jvmtienv() {\n+  JvmtiEnvIterator it;\n+  JvmtiEnv* env = it.first();\n+  assert(env != nullptr, \"invariant\");\n+  JvmtiEnv* next = it.next(env);\n+  while (next != nullptr) {\n+    assert(env != nullptr, \"invariant\");\n+    \/\/ get_env_local_storage() lets us find which JVMTI env map to which JPLIS agent.\n+    if (next->get_env_local_storage() == nullptr) {\n+      JvmtiEnv* temp = it.next(next);\n+      if (temp != nullptr) {\n+        next = temp;\n+        continue;\n+      }\n+      break;\n+    }\n+    env = next;\n+    next = it.next(env);\n+  }\n+  assert(env != nullptr, \"invariant\");\n+  assert(env->get_env_local_storage() != nullptr, \"invariant\");\n+  return env;\n+}\n+\n+\/\/ Associate the last, i.e. most recent, JvmtiEnv that is a JPLIS agent with the current agent.\n+static void convert_to_jplis(Agent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_instrument_lib(), \"invariant\");\n+  JvmtiEnv* const env = get_last_jplis_jvmtienv();\n+  assert(env != nullptr, \"invariant\");\n+  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n+  assert(jplis_env != nullptr, \"invaiant\");\n+  assert(reinterpret_cast<JvmtiEnv*>(jplis_env->mJVMTIEnv) == env, \"invariant\");\n+  agent->set_jplis(jplis_env->mAgent);\n+}\n+\n+\/\/ Use this for JavaThreads and state is _thread_in_vm.\n+class AgentJavaThreadEventTransition : StackObj {\n+ private:\n+  ResourceMark _rm;\n+  ThreadToNativeFromVM _transition;\n+  HandleMark _hm;\n+ public:\n+  AgentJavaThreadEventTransition(JavaThread* thread) : _rm(), _transition(thread), _hm(thread) {};\n+};\n+\n+class AgentEventMark : StackObj {\n+ private:\n+  JavaThread* _thread;\n+  JNIEnv* _jni_env;\n+  JvmtiThreadState::ExceptionState _saved_exception_state;\n+\n+ public:\n+  AgentEventMark(JavaThread* thread) : _thread(thread),\n+                                       _jni_env(thread->jni_environment()),\n+                                       _saved_exception_state(JvmtiThreadState::ES_CLEARED) {\n+    JvmtiThreadState* state = thread->jvmti_thread_state();\n+    \/\/ we are before an event.\n+    \/\/ Save current jvmti thread exception state.\n+    if (state != nullptr) {\n+      _saved_exception_state = state->get_exception_state();\n+    }\n+    thread->push_jni_handle_block();\n+    assert(thread == JavaThread::current(), \"thread must be current!\");\n+    thread->frame_anchor()->make_walkable();\n+  }\n+\n+  ~AgentEventMark() {\n+    _thread->pop_jni_handle_block();\n+    JvmtiThreadState* state = _thread->jvmti_thread_state();\n+    \/\/ we are continuing after an event.\n+    if (state != nullptr) {\n+      \/\/ Restore the jvmti thread exception state.\n+      state->restore_exception_state(_saved_exception_state);\n+    }\n+  }\n+};\n+\n+class AgentThreadEventMark : public AgentEventMark {\n+ private:\n+  jobject _jthread;\n+ public:\n+  AgentThreadEventMark(JavaThread* thread) : AgentEventMark(thread),\n+                                             _jthread(JNIHandles::make_local(thread, thread->threadObj())) {}\n+  jthread jni_thread() { return (jthread)_jthread; }\n+};\n+\n+static void unload_library(Agent* agent, void* library) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_loaded(), \"invariant\");\n+  if (!agent->is_static_lib()) {\n+    assert(library != nullptr, \"invariant\");\n+    os::dll_unload(library);\n+  }\n+}\n+\n+\/\/ type for the Agent_OnAttach entry point\n+extern \"C\" {\n+  typedef jint(JNICALL* OnAttachEntry_t)(JavaVM*, char*, void*);\n+}\n+\n+\/\/ Loading the agent by invoking Agent_OnAttach.\n+static bool invoke_Agent_OnAttach(Agent* agent, outputStream* st) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(agent->is_dynamic(), \"invariant\");\n+  assert(st != nullptr, \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE, \"not in live phase!\");\n+  const char* on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n+  const size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n+  void* library = nullptr;\n+  if (!load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n+    library = load_library(agent, &on_attach_symbols[0], num_symbol_entries, \/* vm_exit_on_error *\/ false);\n+    if (library == nullptr) {\n+      st->print_cr(\"%s was not loaded.\", agent->name());\n+      if (*ebuf != '\\0') {\n+        st->print_cr(\"%s\", &ebuf[0]);\n+      }\n+      return false;\n+    }\n+    agent->set_os_lib_path(&buffer[0]);\n+    agent->set_os_lib(library);\n+    agent->set_loaded();\n+  }\n+  assert(agent->is_loaded(), \"invariant\");\n+  \/\/ The library was loaded so we attempt to lookup and invoke the Agent_OnAttach function.\n+  OnAttachEntry_t on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,\n+                                                   os::find_agent_function(agent, false, &on_attach_symbols[0], num_symbol_entries));\n+\n+  if (on_attach_entry == nullptr) {\n+    st->print_cr(\"%s is not available in %s\", on_attach_symbols[0], agent->name());\n+    unload_library(agent, library);\n+    return false;\n+  }\n+\n+  \/\/ Invoke the Agent_OnAttach function\n+  JavaThread* thread = JavaThread::current();\n+  jint result = JNI_ERR;\n+  {\n+    extern struct JavaVM_ main_vm;\n+    AgentThreadEventMark jem(thread);\n+    AgentJavaThreadEventTransition jet(thread);\n+\n+    agent->initialization_begin();\n+\n+    result = (*on_attach_entry)(&main_vm, (char*)agent->options(), nullptr);\n+\n+    agent->initialization_end();\n+\n+    \/\/ Agent_OnAttach may have used JNI\n+    if (thread->is_pending_jni_exception_check()) {\n+      thread->clear_pending_jni_exception_check();\n+    }\n+  }\n+\n+  \/\/ Agent_OnAttach may have used JNI\n+  if (thread->has_pending_exception()) {\n+    thread->clear_pending_exception();\n+  }\n+\n+  st->print_cr(\"return code: %d\", result);\n+\n+  if (result != JNI_OK) {\n+    unload_library(agent, library);\n+    return false;\n+  }\n+\n+  if (agent->is_instrument_lib()) {\n+    \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n+    convert_to_jplis(agent);\n+  }\n+  return true;\n+}\n+\n+\/\/ CDS dumping does not support native JVMTI agent.\n+\/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n+static void check_cds_dump(Agent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(Arguments::is_dumping_archive(), \"invariant\");\n+  if (!agent->is_instrument_lib()) {\n+    vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n+  }\n+  if (!AllowArchivingWithJavaAgent) {\n+    vm_exit_during_cds_dumping(\n+      \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n+  }\n+}\n+\n+\/\/ Loading the agent by invoking Agent_OnLoad.\n+static bool invoke_Agent_OnLoad(Agent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_xrun(), \"invariant\");\n+  assert(!agent->is_dynamic(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_ONLOAD, \"invariant\");\n+  if (Arguments::is_dumping_archive()) {\n+    check_cds_dump(agent);\n+  }\n+  OnLoadEntry_t on_load_entry = lookup_Agent_OnLoad_entry_point(agent);\n+  if (on_load_entry == nullptr) {\n+    vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n+  }\n+  \/\/ Invoke the Agent_OnLoad function\n+  extern struct JavaVM_ main_vm;\n+  if ((*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), nullptr) != JNI_OK) {\n+    vm_exit_during_initialization(\"agent library failed Agent_OnLoad\", agent->name());\n+  }\n+  \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n+  if (agent->is_instrument_lib()) {\n+    convert_to_jplis(agent);\n+  }\n+  return true;\n+}\n+\n+bool Agent::load(outputStream* st \/* nullptr *\/) {\n+  if (is_xrun()) {\n+    return invoke_JVM_OnLoad(this);\n+  }\n+  return is_dynamic() ? invoke_Agent_OnAttach(this, st) : invoke_Agent_OnLoad(this);\n+}\n+\n+extern \"C\" {\n+  typedef void (JNICALL* Agent_OnUnload_t)(JavaVM*);\n+}\n+\n+void Agent::unload() {\n+  const char* on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n+  \/\/ Find the Agent_OnUnload function.\n+  Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n+                                                 os::find_agent_function(this, false, &on_unload_symbols[0], ARRAY_SIZE(on_unload_symbols)));\n+  if (unload_entry != nullptr) {\n+    \/\/ Invoke the Agent_OnUnload function\n+    JavaThread* thread = JavaThread::current();\n+    ThreadToNativeFromVM ttn(thread);\n+    HandleMark hm(thread);\n+    extern struct JavaVM_ main_vm;\n+    (*unload_entry)(&main_vm);\n+  }\n","filename":"src\/hotspot\/share\/prims\/agent.cpp","additions":493,"deletions":64,"binary":false,"changes":557,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+class JvmtiEnv;\n+class outputStream;\n+\n@@ -36,2 +39,2 @@\n-  Ticks _init;\n-  Tickspan _init_time;\n+  Ticks _initialization_time;\n+  Tickspan _initialization_duration;\n@@ -44,6 +47,6 @@\n-  bool _valid;\n-  bool _is_absolute_path;\n-  bool _is_static_lib;\n-  bool _is_dynamic;\n-  bool _is_instrument_lib;\n-  bool _is_xrun;\n+  bool _loaded;\n+  bool _absolute_path;\n+  bool _static_lib;\n+  bool _instrument_lib;\n+  bool _dynamic;\n+  bool _xrun;\n@@ -52,1 +55,3 @@\n-  void set_jplis(const void* jplis);\n+  void set_next(Agent* agent);\n+  void convert_xrun_agent();\n+  void set_xrun();\n@@ -55,0 +60,1 @@\n+  Agent(const char* name, const char* options, bool is_absolute_path, bool dynamic = false);\n@@ -60,1 +66,0 @@\n-  void set_os_lib_path(const char* path);\n@@ -62,0 +67,1 @@\n+  void set_os_lib_path(const char* path);\n@@ -65,0 +71,1 @@\n+  bool is_xrun() const;\n@@ -66,4 +73,2 @@\n-  bool is_valid() const;\n-  void set_valid();\n-  const Ticks& initialization() const;\n-  const Tickspan& initialization_time() const;\n+  bool is_loaded() const;\n+  void set_loaded();\n@@ -71,3 +76,3 @@\n-  bool is_jplis(const void* jplis) const;\n-  bool is_timestamped() const;\n-  void timestamp();\n+  bool is_jplis(JvmtiEnv* env) const;\n+  void set_jplis(const void* jplis);\n+  bool is_initialized() const;\n@@ -76,1 +81,5 @@\n-  Agent(const char* name, const char* options, bool is_absolute_path);\n+  const Ticks& initialization_time() const;\n+  const Tickspan& initialization_duration() const;\n+\n+  bool load(outputStream* st = nullptr);\n+  void unload();\n","filename":"src\/hotspot\/share\/prims\/agent.hpp","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-#include \"cds\/cds_globals.hpp\"\n-#include \"jni.h\"\n-#include \"jvmtifiles\/jvmtiEnv.hpp\"\n@@ -32,1 +29,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -34,4 +30,0 @@\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/jniHandles.hpp\"\n@@ -39,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -44,25 +35,2 @@\n-static inline Agent* head(Agent** list) {\n-  assert(list != nullptr, \"invariant\");\n-  return Atomic::load_acquire(list);\n-}\n-\n-void AgentList::add(Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  Agent* next;\n-  do {\n-    next = head(&_list);\n-    agent->_next = next;\n-  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n-}\n-\n-void AgentList::add(const char* name, char* options, bool absolute_path) {\n-  add(new Agent(name, options, absolute_path));\n-}\n-\n-void AgentList::add_xrun(const char* name, char* options, bool absolute_path) {\n-  Agent* agent = new Agent(name, options, absolute_path);\n-  agent->_is_xrun = true;\n-  add(agent);\n-}\n-\n-Agent* AgentList::Iterator::filter(Agent* agent) const {\n+\/\/ Selection as a function of the filter.\n+Agent* AgentList::Iterator::select(Agent* agent) const {\n@@ -70,2 +38,4 @@\n-    if (_type == JAVA_OR_NATIVE) {\n-      if (!agent->_is_xrun) {\n+    if (_filter == ALL) {\n+      return agent;\n+    } else if (_filter == NOT_XRUN) {\n+      if (!agent->is_xrun()) {\n@@ -74,3 +44,1 @@\n-    }\n-    if (_type == JAVA) {\n-      assert(!agent->_is_xrun, \"invariant\");\n+    } else if (_filter == JAVA) {\n@@ -80,4 +48,4 @@\n-    } else if (_type == NATIVE) {\n-        if (!agent->is_jplis() && !agent->_is_xrun) {\n-          return agent;\n-        }\n+    } else if (_filter == NATIVE) {\n+      if (!agent->is_jplis() && !agent->is_xrun()) {\n+        return agent;\n+      }\n@@ -85,2 +53,2 @@\n-      assert(_type == XRUN, \"invariant\");\n-      if (agent->_is_xrun) {\n+      assert(_filter == XRUN, \"invariant\");\n+      if (agent->is_xrun()) {\n@@ -90,1 +58,1 @@\n-    agent = agent->_next;\n+    agent = agent->next();\n@@ -95,0 +63,6 @@\n+static inline Agent* head(Agent** list) {\n+  assert(list != nullptr, \"invariant\");\n+  return Atomic::load_acquire(list);\n+}\n+\n+\n@@ -98,1 +72,1 @@\n-AgentList::Iterator::Iterator(Agent** list, Type type) : _stack(new GrowableArrayCHeap<Agent*, mtServiceability>(16)), _type(type) {\n+AgentList::Iterator::Iterator(Agent** list, Filter filter) : _stack(new GrowableArrayCHeap<Agent*, mtServiceability>(16)), _filter(filter) {\n@@ -101,1 +75,1 @@\n-    next = filter(next);\n+    next = select(next);\n@@ -104,1 +78,1 @@\n-      next = next->_next;\n+      next = next->next();\n@@ -128,1 +102,1 @@\n-  return Iterator(&_list, Iterator::JAVA_OR_NATIVE);\n+  return Iterator(&_list, Iterator::NOT_XRUN);\n@@ -143,15 +117,2 @@\n-static inline void timestamp_agents(AgentList::Iterator& it) {\n-  while (it.has_next()) {\n-    Agent* agent = it.next();\n-    if (!agent->is_timestamped()) {\n-      agent->timestamp();\n-    }\n-  }\n-}\n-\n-\/\/ In case an agent did not enable the VMInit callback, it gets a timestamp here.\n-void AgentList::timestamp() {\n-  Iterator xrun_it = xrun_agents();\n-  timestamp_agents(xrun_it);\n-  Iterator agent_it = agents();\n-  timestamp_agents(agent_it);\n+AgentList::Iterator AgentList::all() {\n+  return Iterator(&_list, Iterator::ALL);\n@@ -160,6 +121,1 @@\n-static const char* not_found_error_msg = \"Could not find agent library \";\n-static const char* missing_module_error_msg = \"\\nModule java.instrument may be missing from runtime image.\";\n-static char ebuf[1024];\n-static char buffer[JVM_MAXPATHLEN];\n-\n-static void vm_exit(const Agent* agent, const char* sub_msg1, const char* sub_msg2) {\n+void AgentList::add(Agent* agent) {\n@@ -167,11 +123,5 @@\n-  assert(sub_msg1 != nullptr, \"invariant\");\n-  assert(!agent->is_instrument_lib() || sub_msg2 != nullptr, \"invariant\");\n-  const size_t len = strlen(not_found_error_msg) + strlen(agent->name()) + strlen(sub_msg1) + strlen(&ebuf[0]) + 1 + (agent->is_instrument_lib() ? strlen(sub_msg2) : 0);\n-  char* buf = NEW_C_HEAP_ARRAY(char, len, mtInternal);\n-  if (agent->is_instrument_lib()) {\n-    jio_snprintf(buf, len, \"%s%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0], sub_msg2);\n-  } else {\n-    jio_snprintf(buf, len, \"%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0]);\n-  }\n-  vm_exit_during_initialization(buf, nullptr);\n-  FREE_C_HEAP_ARRAY(char, buf);\n+  Agent* next;\n+  do {\n+    next = head(&_list);\n+    agent->set_next(next);\n+  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n@@ -180,5 +130,2 @@\n-static void* load_agent_from_executable(Agent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(!agent->is_valid(), \"invariant\");\n-  assert(on_load_symbols != nullptr, \"invariant\");\n-  return os::find_builtin_agent(agent, &on_load_symbols[0], num_symbol_entries) ? agent->os_lib() : nullptr;\n+void AgentList::add(const char* name, char* options, bool absolute_path) {\n+  add(new Agent(name, options, absolute_path));\n@@ -187,10 +134,4 @@\n-static void* load_agent_from_absolute_path(Agent* agent, bool vm_exit_on_error) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(!agent->is_valid(), \"invariant\");\n-  assert(agent->is_absolute_path(), \"invariant\");\n-  assert(!agent->is_instrument_lib(), \"invariant\");\n-  void* const library = os::dll_load(agent->name(), &ebuf[0], sizeof ebuf);\n-  if (library == nullptr && vm_exit_on_error) {\n-    vm_exit(agent, \" in absolute path, with error: \", nullptr);\n-  }\n-  return library;\n+void AgentList::add_xrun(const char* name, char* options, bool absolute_path) {\n+  Agent* agent = new Agent(name, options, absolute_path);\n+  agent->set_xrun();\n+  add(agent);\n@@ -199,19 +140,4 @@\n-static void* load_agent_from_relative_path(Agent* agent, bool vm_exit_on_error) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(!agent->is_valid(), \"invariant\");\n-  assert(!agent->is_absolute_path(), \"invariant\");\n-  const char* const name = agent->name();\n-  void* library = nullptr;\n-  \/\/ Try to load the agent from the standard dll directory\n-  if (os::dll_locate_lib(&buffer[0], sizeof buffer, Arguments::get_dll_dir(), name)) {\n-    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n-  }\n-  if (library == nullptr && os::dll_build_name(&buffer[0], sizeof buffer, name)) {\n-    \/\/ Try the library path directory.\n-    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n-    if (library != nullptr) {\n-      return library;\n-    }\n-    if (vm_exit_on_error) {\n-      vm_exit(agent, \" on the library path, with error: \", missing_module_error_msg);\n-    }\n+#ifdef ASSERT\n+static void assert_initialized(AgentList::Iterator& it) {\n+  while (it.has_next()) {\n+    assert(it.next()->is_initialized(), \"invariant\");\n@@ -219,1 +145,0 @@\n-  return library;\n@@ -221,0 +146,1 @@\n+#endif\n@@ -222,48 +148,8 @@\n-\/*\n- * The implementation builds a mapping bewteen JVMTI envs and JPLIS agents,\n- * using internal JDK implementation knowledge about the way JPLIS agents\n- * store data in their JvmtiEnv local storage.\n- *\n- * Please see JPLISAgent.c in module java.instrument, see JPLISAgent.h and JPLISAgent.c.\n- *\n- * jvmtierror = (*jvmtienv)->SetEnvironmentLocalStorage( jvmtienv, &(agent->mNormalEnvironment));\n- *\n- * It is the pointer to the field agent->mNormalEnvironment that is stored in the jvmtiEnv local storage.\n- * It has the following type:\n- *\n- * struct _JPLISEnvironment {\n- *   jvmtiEnv*   mJVMTIEnv;              \/\/ the JVM TI environment\n- *   JPLISAgent* mAgent;                 \/\/ corresponding agent\n- *   jboolean    mIsRetransformer;       \/\/ indicates if special environment\n- * };\n- *\n- * We mirror this struct to get the mAgent field as an identifier.\n- *\/\n-\n-struct JPLISEnvironmentMirror {\n-  jvmtiEnv* mJVMTIEnv; \/\/ the JVMTI environment\n-  const void* mAgent;  \/\/ corresponding agent\n-  jboolean mIsRetransformer; \/\/ indicates if special environment\n-};\n-\n-static inline const JPLISEnvironmentMirror* get_env_local_storage(JvmtiEnv* env) {\n-  assert(env != nullptr, \"invariant\");\n-  return reinterpret_cast<const JPLISEnvironmentMirror*>(env->get_env_local_storage());\n-}\n-\n-\/\/ The newest jvmtiEnvs are appended to the list, JvmtiEnvIterator order is from oldest to newest.\n-static JvmtiEnv* get_last_jplis_jvmtienv() {\n-  JvmtiEnvIterator it;\n-  JvmtiEnv* env = it.first();\n-  assert(env != nullptr, \"invariant\");\n-  JvmtiEnv* next = it.next(env);\n-  while (next != nullptr) {\n-    assert(env != nullptr, \"invariant\");\n-    \/\/ get_env_local_storage() lets us find which JVMTI env map to which JPLIS agent.\n-    if (next->get_env_local_storage() == nullptr) {\n-      JvmtiEnv* temp = it.next(next);\n-      if (temp != nullptr) {\n-        next = temp;\n-        continue;\n-      }\n-      break;\n+\/\/ In case an agent did not enable the VMInit callback, or if it is an -Xrun agent,\n+\/\/ it gets an initializiation timestamp here.\n+void AgentList::initialize() {\n+  Iterator it = all();\n+  while (it.has_next()) {\n+    Agent* agent = it.next();\n+    if (!agent->is_initialized()) {\n+      agent->initialization_begin();\n@@ -271,2 +157,0 @@\n-    env = next;\n-    next = it.next(env);\n@@ -274,15 +158,1 @@\n-  assert(env != nullptr, \"invariant\");\n-  assert(env->get_env_local_storage() != nullptr, \"invariant\");\n-  return env;\n-}\n-\n-\/\/ Link the last, or most recent jvmtiEnv. that is a JPLIS agent, with the current agent.\n-void AgentList::convert_to_jplis(Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(agent->is_instrument_lib(), \"invariant\");\n-  JvmtiEnv* const env = get_last_jplis_jvmtienv();\n-  assert(env != nullptr, \"invariant\");\n-  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n-  assert(jplis_env != nullptr, \"invaiant\");\n-  assert(reinterpret_cast<JvmtiEnv*>(jplis_env->mJVMTIEnv) == env, \"invariant\");\n-  agent->set_jplis(jplis_env->mAgent);\n+  DEBUG_ONLY(Iterator assert_it = all(); assert_initialized(assert_it);)\n@@ -291,11 +161,4 @@\n-\/\/ CDS dumping does not support native JVMTI agent.\n-\/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n-static void check_cds_dump(Agent* agent) {\n-  assert(agent != nullptr, \"invariant\");\n-  assert(Arguments::is_dumping_archive(), \"invariant\");\n-  if (!agent->is_instrument_lib()) {\n-    vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n-  }\n-  if (!AllowArchivingWithJavaAgent) {\n-    vm_exit_during_cds_dumping(\n-      \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n+void AgentList::convert_xrun_agents() {\n+  Iterator it = xrun_agents();\n+  while (it.has_next()) {\n+    it.next()->convert_xrun_agent();\n@@ -305,18 +168,5 @@\n-\/\/ type for the Agent_OnLoad and JVM_OnLoad entry points\n-extern \"C\" {\n-  typedef jint(JNICALL* OnLoadEntry_t)(JavaVM*, char*, void*);\n-}\n-\n-\/\/ Find the OnLoad entry point for -agentlib:  -agentpath:   -Xrun agents.\n-\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n-static OnLoadEntry_t lookup_On_Load_entry_point(Agent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n-  assert(agent != nullptr, \"invariant\");\n-  if (!agent->is_valid()) {\n-    \/\/ First check to see if agent is statically linked into executable.\n-    void* library = load_agent_from_executable(agent, on_load_symbols, num_symbol_entries);\n-    if (library == nullptr) {\n-      library = agent->is_absolute_path() ? load_agent_from_absolute_path(agent, true) : load_agent_from_relative_path(agent, true);\n-    }\n-    assert(library != nullptr, \"invariant\");\n-    agent->set_os_lib(library);\n-    agent->set_valid();\n+class JvmtiPhaseTransition : public StackObj {\n+ public:\n+  JvmtiPhaseTransition() {\n+    assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+    JvmtiExport::enter_onload_phase();\n@@ -324,16 +174,5 @@\n-  assert(agent->is_valid(), \"invariant\");\n-  assert(agent->os_lib() != nullptr, \"invariant\");\n-\n-  \/\/ Find the OnLoad function.\n-  return CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent, false, on_load_symbols, num_symbol_entries));\n-}\n-\n-static OnLoadEntry_t lookup_JVM_OnLoad_entry_point(Agent* lib) {\n-  const char* on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n-  return lookup_On_Load_entry_point(lib, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n-}\n-\n-static OnLoadEntry_t lookup_Agent_OnLoad_entry_point(Agent* agent) {\n-  const char* on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n-  return lookup_On_Load_entry_point(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n-}\n+  ~JvmtiPhaseTransition() {\n+    assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_ONLOAD, \"invariant\");\n+    JvmtiExport::enter_primordial_phase();\n+  }\n+};\n@@ -341,4 +180,1 @@\n-\/\/ For backwards compatibility with -Xrun, convert Xrun agents with no JVM_OnLoad,\n-\/\/ but which have an Agent_OnLoad, to be treated like -agentpath\n-void AgentList::convert_xrun_agents() {\n-  Iterator it = xrun_agents();\n+static void load_agents(AgentList::Iterator& it) {\n@@ -346,12 +182,1 @@\n-    Agent* const agent = it.next();\n-    assert(agent->_is_xrun, \"invariant\");\n-    OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(agent);\n-    \/\/ If there is an JVM_OnLoad function it will get called later,\n-    \/\/ otherwise see if there is an Agent_OnLoad.\n-    if (on_load_entry == nullptr) {\n-      on_load_entry = lookup_Agent_OnLoad_entry_point(agent);\n-      if (on_load_entry == nullptr) {\n-        vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", agent->name());\n-      }\n-      agent->_is_xrun = false; \/\/ converted\n-    }\n+    it.next()->load();\n@@ -364,3 +189,0 @@\n-  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n-  extern struct JavaVM_ main_vm;\n-\n@@ -369,3 +191,1 @@\n-\n-  JvmtiExport::enter_onload_phase();\n-\n+  JvmtiPhaseTransition transition;\n@@ -373,49 +193,1 @@\n-  while (it.has_next()) {\n-    Agent* agent = it.next();\n-    if (Arguments::is_dumping_archive()) {\n-      check_cds_dump(agent);\n-    }\n-\n-    OnLoadEntry_t on_load_entry = lookup_Agent_OnLoad_entry_point(agent);\n-\n-    if (on_load_entry == nullptr) {\n-      vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n-    }\n-    \/\/ Invoke the Agent_OnLoad function\n-    if ((*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), nullptr) != JNI_OK) {\n-      vm_exit_during_initialization(\"agent library failed Agent_OnLoad\", agent->name());\n-    }\n-\n-    \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n-    if (agent->is_instrument_lib()) {\n-      convert_to_jplis(agent);\n-    }\n-  }\n-\n-  JvmtiExport::enter_primordial_phase();\n-}\n-\n-extern \"C\" {\n-  typedef void (JNICALL* Agent_OnUnload_t)(JavaVM*);\n-}\n-\n-\/\/ Called after the VM is initialized for -Xrun agents which have not been converted to JVMTI agents\n-void AgentList::invoke_JVM_OnLoad() {\n-  extern struct JavaVM_ main_vm;\n-  Iterator it = xrun_agents();\n-  while (it.has_next()) {\n-    Agent* agent = it.next();\n-    assert(agent->_is_xrun, \"invariant\");\n-    OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(agent);\n-    if (on_load_entry == nullptr) {\n-      vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n-    }\n-    \/\/ Invoke the JVM_OnLoad function\n-    JavaThread* thread = JavaThread::current();\n-    ThreadToNativeFromVM ttn(thread);\n-    HandleMark hm(thread);\n-    const jint err = (*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), NULL);\n-    if (err != JNI_OK) {\n-      vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n-    }\n-  }\n+  ::load_agents(it);\n@@ -427,66 +199,2 @@\n-  invoke_JVM_OnLoad();\n-}\n-\n-\/\/ Use this for JavaThreads and state is  _thread_in_vm.\n-class AgentJavaThreadEventTransition : StackObj {\n- private:\n-  ResourceMark _rm;\n-  ThreadToNativeFromVM _transition;\n-  HandleMark _hm;\n- public:\n-  AgentJavaThreadEventTransition(JavaThread* thread) : _rm(), _transition(thread), _hm(thread) {};\n-};\n-\n-class AgentEventMark : public StackObj {\n- private:\n-  JavaThread* _thread;\n-  JNIEnv* _jni_env;\n-  JvmtiThreadState::ExceptionState _saved_exception_state;\n-\n- public:\n-  AgentEventMark(JavaThread* thread) : _thread(thread),\n-    _jni_env(thread->jni_environment()),\n-    _saved_exception_state(JvmtiThreadState::ES_CLEARED) {\n-    JvmtiThreadState* state = thread->jvmti_thread_state();\n-    \/\/ we are before an event.\n-    \/\/ Save current jvmti thread exception state.\n-    if (state != NULL) {\n-      _saved_exception_state = state->get_exception_state();\n-    }\n-    thread->push_jni_handle_block();\n-    assert(thread == JavaThread::current(), \"thread must be current!\");\n-    thread->frame_anchor()->make_walkable();\n-  }\n-\n-  ~AgentEventMark() {\n-    _thread->pop_jni_handle_block();\n-    JvmtiThreadState* state = _thread->jvmti_thread_state();\n-    \/\/ we are continuing after an event.\n-    if (state != NULL) {\n-      \/\/ Restore the jvmti thread exception state.\n-      state->restore_exception_state(_saved_exception_state);\n-    }\n-  }\n-};\n-\n-class AgentThreadEventMark : public AgentEventMark {\n- private:\n-  jobject _jthread;\n- public:\n-  AgentThreadEventMark(JavaThread* thread) : AgentEventMark(thread) {\n-    _jthread = JNIHandles::make_local(thread, thread->threadObj());\n-  };\n-  jthread jni_thread() { return (jthread)_jthread; }\n-};\n-\n-static void unload_and_delete(Agent* agent, void* library) {\n-  assert(agent != nullptr, \"invariant\");\n-  if (!agent->is_static_lib()) {\n-    os::dll_unload(library);\n-  }\n-  delete agent;\n-}\n-\n-\/\/ type for the Agent_OnAttach entry point\n-extern \"C\" {\n-  typedef jint(JNICALL* OnAttachEntry_t)(JavaVM*, char*, void*);\n+  Iterator it = xrun_agents();\n+  ::load_agents(it);\n@@ -495,1 +203,1 @@\n-\/\/ Implementation for loading an agent dynamically during runtime, by invoking Agent_OnAttach.\n+\/\/ Invokes Agent_OnAttach for agents loaded dynamically during runtime.\n@@ -497,5 +205,1 @@\n-                                  const char* options, outputStream* st) {\n-  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE, \"not in live phase!\");\n-  const char* on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n-  const size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n-\n+                           const char* options, outputStream* st) {\n@@ -504,69 +208,2 @@\n-  \/\/ Initially marked as invalid. It will be set to valid if we can find the agent\n-  Agent* agent = new Agent(agent_name, options, is_absolute_path);\n-  agent->_is_dynamic = true;\n-\n-  \/\/ Check for statically linked in agent. If not found then if the path is\n-  \/\/ absolute we attempt to load the library. Otherwise we try to load it from the standard dll directory.\n-  void* library = load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries);\n-  if (library == nullptr) {\n-    library = agent->is_absolute_path() ? load_agent_from_absolute_path(agent, \/* vm exit on error *\/ false) :\n-                                          load_agent_from_relative_path(agent, \/* vm exit on error *\/ false);\n-  }\n-  if (library != nullptr) {\n-    agent->set_os_lib_path(&buffer[0]);\n-    agent->set_os_lib(library);\n-    agent->set_valid();\n-  } else {\n-    st->print_cr(\"%s was not loaded.\", agent_name);\n-    if (*ebuf != '\\0') {\n-      st->print_cr(\"%s\", ebuf);\n-    }\n-    return JNI_ERR;\n-  }\n-\n-  assert(library != nullptr, \"invariant\");\n-  assert(agent->is_valid(), \"invariant\");\n-\n-  \/\/ The library was loaded so we attempt to lookup and invoke the Agent_OnAttach function\n-  OnAttachEntry_t on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,\n-                                                   os::find_agent_function(agent, false, &on_attach_symbols[0], num_symbol_entries));\n-\n-  if (on_attach_entry == nullptr) {\n-    \/\/ Agent_OnAttach missing - unload library\n-    unload_and_delete(agent, library);\n-    st->print_cr(\"%s is not available in %s\", on_attach_symbols[0], agent->name());\n-    return JNI_ERR;\n-  }\n-\n-  \/\/ Invoke the Agent_OnAttach function\n-  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-  jint result = JNI_ERR;\n-  {\n-    extern struct JavaVM_ main_vm;\n-    AgentThreadEventMark jem(THREAD);\n-    AgentJavaThreadEventTransition jet(THREAD);\n-\n-    agent->initialization_begin();\n-\n-    result = (*on_attach_entry)(&main_vm, (char*)options, NULL);\n-\n-    agent->initialization_end();\n-\n-    \/\/ Agent_OnAttach may have used JNI\n-    if (THREAD->is_pending_jni_exception_check()) {\n-      THREAD->clear_pending_jni_exception_check();\n-    }\n-  }\n-\n-  \/\/ Agent_OnAttach may have used JNI\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-\n-  if (result == JNI_OK) {\n-    if (agent->is_instrument_lib()) {\n-      \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n-      convert_to_jplis(agent);\n-    }\n-    \/\/ If OnAttach returns JNI_OK then we add it to the list of\n-    \/\/ agents so that we can iterate over it and call Agent_OnUnload later.\n+  Agent* const agent = new Agent(agent_name, options, is_absolute_path, \/* dynamic agent *\/ true);\n+  if (agent->load(st)) {\n@@ -575,1 +212,1 @@\n-    unload_and_delete(agent, library);\n+    delete agent;\n@@ -577,1 +214,0 @@\n-  st->print_cr(\"return code: %d\", result);\n@@ -584,3 +220,0 @@\n-  extern struct JavaVM_ main_vm;\n-  const char* on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n-  size_t num_symbol_entries = ARRAY_SIZE(on_unload_symbols);\n@@ -589,14 +222,1 @@\n-    Agent* agent = it.next();\n-    \/\/ Find the Agent_OnUnload function.\n-    Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n-                                                   os::find_agent_function(agent,\n-                                                   false,\n-                                                   &on_unload_symbols[0],\n-                                                   num_symbol_entries));\n-    \/\/ Invoke the Agent_OnUnload function\n-    if (unload_entry != nullptr) {\n-      JavaThread* thread = JavaThread::current();\n-      ThreadToNativeFromVM ttn(thread);\n-      HandleMark hm(thread);\n-      (*unload_entry)(&main_vm);\n-    }\n+    it.next()->unload();\n@@ -606,8 +226,0 @@\n-static bool is_env_jplis_agent(JvmtiEnv* env, const Agent* agent) {\n-  assert(env != nullptr, \"invariant\");\n-  assert(agent != nullptr, \"invariant\");\n-  assert(agent->is_instrument_lib(), \"invariant\");\n-  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n-  return jplis_env != nullptr ? agent->is_jplis(jplis_env->mAgent) : false;\n-}\n-\n@@ -617,0 +229,3 @@\n+  if (agent->is_static_lib()) {\n+    return os::get_default_process_handle() == os_module_address;\n+  }\n@@ -620,6 +235,1 @@\n-  if (agent->is_instrument_lib()) {\n-    return is_env_jplis_agent(env, agent);\n-  }\n-  \/\/ The agent maps to the correct os library.\n-  \/\/ But if this is another JvmtiEnv for the same agent, we can't time it twice.\n-  return !agent->is_timestamped();\n+  return agent->is_instrument_lib() ? agent->is_jplis(env) : true;\n@@ -631,1 +241,0 @@\n-\/\/ Some agents create multiple JVMTI envs, but we only maintain a single 1-1 mapping to an agent where we can.\n@@ -635,0 +244,2 @@\n+  static char ebuf[1024];\n+  static char buffer[JVM_MAXPATHLEN];\n","filename":"src\/hotspot\/share\/prims\/agentList.cpp","additions":84,"deletions":473,"binary":false,"changes":557,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-class JvmtiEnv;\n-\n@@ -35,0 +33,1 @@\n+class JvmtiEnv;\n@@ -44,1 +43,1 @@\n-    enum Type {\n+    enum Filter {\n@@ -47,2 +46,3 @@\n-      JAVA_OR_NATIVE, \/\/ union of JAVA and NATIVE\n-      XRUN\n+      XRUN,\n+      NOT_XRUN,\n+      ALL\n@@ -51,3 +51,3 @@\n-    const Type _type;\n-    Iterator(Agent** list, Type type);\n-    Agent* filter(Agent* agent) const;\n+    const Filter _filter;\n+    Iterator(Agent** list, Filter filter);\n+    Agent* select(Agent* agent) const;\n@@ -64,2 +64,2 @@\n-  static void timestamp();\n-  static void invoke_JVM_OnLoad();\n+  static Iterator all();\n+  static void initialize();\n@@ -67,1 +67,0 @@\n-  static void convert_to_jplis(Agent* agent);\n","filename":"src\/hotspot\/share\/prims\/agentList.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -698,0 +698,7 @@\n+\/\/ Lookup an agent from an JvmtiEnv.Return agent only if it is not yet initialized.\n+\/\/ An agent can create multiple JvmtiEnvs, but for agent initialization, we are only interested in the initial one.\n+static Agent* lookup_uninitialized_agent(JvmtiEnv* env, void* callback) {\n+  Agent* const agent = AgentList::lookup(env, callback);\n+  return agent == nullptr || agent->is_initialized() ? nullptr : agent;\n+}\n+\n@@ -714,1 +721,1 @@\n-        Agent* const agent = AgentList::lookup(env, reinterpret_cast<void*>(callback));\n+        Agent* const agent = lookup_uninitialized_agent(env, reinterpret_cast<void*>(callback));\n@@ -726,2 +733,2 @@\n-  \/\/ Agents are timestamped as part of posting the VMInit event above.\n-  \/\/ For -Xrun agents and agents with no VMInit callback, we explicitly ensure they are also timestamped.\n+  \/\/ Agents are initialized as part of posting the VMInit event above.\n+  \/\/ For -Xrun agents and agents with no VMInit callback, we explicitly ensure they are also initialized.\n@@ -729,1 +736,1 @@\n-  AgentList::timestamp();\n+  AgentList::initialize();\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-bool os::find_builtin_agent(Agent *agent_lib, const char *syms[],\n+bool os::find_builtin_agent(Agent* agent, const char *syms[],\n@@ -571,2 +571,2 @@\n-  assert(agent_lib != nullptr, \"sanity check\");\n-  if (agent_lib->name() == nullptr) {\n+  assert(agent != nullptr, \"sanity check\");\n+  if (agent->name() == nullptr) {\n@@ -577,1 +577,1 @@\n-  save_handle = agent_lib->os_lib();\n+  save_handle = agent->os_lib();\n@@ -579,2 +579,2 @@\n-  agent_lib->set_os_lib(proc_handle);\n-  ret = find_agent_function(agent_lib, true, syms, syms_len);\n+  agent->set_os_lib(proc_handle);\n+  ret = find_agent_function(agent, true, syms, syms_len);\n@@ -583,2 +583,2 @@\n-    agent_lib->set_valid();\n-    agent_lib->set_static_lib();\n+    agent->set_static_lib();\n+    agent->set_loaded();\n@@ -587,1 +587,1 @@\n-  agent_lib->set_os_lib(save_handle);\n+  agent->set_os_lib(save_handle);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-            Instant initialization = e.getInstant(\"initialization\");\n-            if (initialization.isAfter(r.getStartTime())) {\n+            Instant initializationTime = e.getInstant(\"initializationTime\");\n+            if (initializationTime.isAfter(r.getStartTime())) {\n@@ -97,1 +97,1 @@\n-            Events.assertField(e, \"initializationTime\").atLeast(0L);\n+            Events.assertField(e, \"initializationDuration\").atLeast(0L);\n@@ -112,2 +112,2 @@\n-            Instant initialization = e.getInstant(\"initialization\");\n-            if (initialization.isAfter(r.getStartTime())) {\n+            Instant initializationTime = e.getInstant(\"initializationTime\");\n+            if (initializationTime.isAfter(r.getStartTime())) {\n@@ -116,1 +116,1 @@\n-            Events.assertField(e, \"initializationTime\").atLeast(0L);\n+            Events.assertField(e, \"initializationDuration\").atLeast(0L);\n@@ -139,2 +139,2 @@\n-                Instant initialization = e.getInstant(\"initialization\");\n-                if (initialization.isBefore(r.getStartTime())) {\n+                Instant initializationTime = e.getInstant(\"initializationTime\");\n+                if (initializationTime.isBefore(r.getStartTime())) {\n@@ -143,1 +143,1 @@\n-                if (initialization.isAfter(r.getStopTime())) {\n+                if (initializationTime.isAfter(r.getStopTime())) {\n@@ -146,3 +146,3 @@\n-                Duration initializationTime = e.getDuration(\"initializationTime\");\n-                if (initializationTime.isNegative()) {\n-                    throw new Exception(\"Expected initalizationTime to be positive value\");\n+                Duration initializationDuration = e.getDuration(\"initializationDuration\");\n+                if (initializationDuration.isNegative()) {\n+                    throw new Exception(\"Expected initalizationDuration to be positive value\");\n@@ -150,2 +150,2 @@\n-                if (initializationTime.toSeconds() > 3600) {\n-                    throw new Exception(\"Expected initializationTime to be less than 1 hour\");\n+                if (initializationDuration.toSeconds() > 3600) {\n+                    throw new Exception(\"Expected initializationDuration to be less than 1 hour\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestAgentEvent.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"}]}