{"files":[{"patch":"@@ -35,1 +35,1 @@\n-\/\/ Signal code is mostly copied from classic vm, signals_md.c   1.4 98\/08\/23\n+\n@@ -44,2 +44,0 @@\n-  \/\/ Copied from classic vm\n-  \/\/ signals_md.c       1.4 98\/08\/23\n@@ -47,1 +45,1 @@\n-                   ? os::user_handler()\n+                   ? PosixSignals::user_handler()\n@@ -85,2 +83,2 @@\n-  void* oldHandler = os::signal(sig, newHandler);\n-  if (oldHandler == os::user_handler()) {\n+  void* oldHandler = PosixSignals::install_generic_signal_handler(sig, newHandler);\n+  if (oldHandler == PosixSignals::user_handler()) {\n@@ -114,1 +112,1 @@\n-  os::signal_raise(sig);\n+  ::raise(sig);\n","filename":"src\/hotspot\/os\/posix\/jvm_posix.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2009,1 +2009,1 @@\n-    os::signal_raise(SIGKILL);\n+    ::raise(SIGKILL);\n@@ -2018,1 +2018,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,5 +99,0 @@\n-extern \"C\" {\n-  typedef void (*sa_handler_t)(int);\n-  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n-}\n-\n@@ -669,1 +664,1 @@\n-static void javaSignalHandler(int sig, siginfo_t* info, void* ucVoid) {\n+static void javaSignalHandler(int sig, siginfo_t* info, void* context) {\n@@ -672,1 +667,1 @@\n-  (void)JVM_HANDLE_XXX_SIGNAL(sig, info, ucVoid, true);\n+  (void)JVM_HANDLE_XXX_SIGNAL(sig, info, context, true);\n@@ -675,1 +670,1 @@\n-static void UserHandler(int sig, void *siginfo, void *context) {\n+static void UserHandler(int sig, siginfo_t* siginfo, void* context) {\n@@ -787,1 +782,1 @@\n-static void SR_handler(int sig, siginfo_t* siginfo, void* ucVoid);\n+static void SR_handler(int sig, siginfo_t* siginfo, void* context);\n@@ -845,1 +840,1 @@\n-void* os::user_handler() {\n+void* PosixSignals::user_handler() {\n@@ -849,1 +844,9 @@\n-void* os::signal(int signal_number, void* handler) {\n+\/\/ Used by JVM_RegisterSignal to install a signal handler.\n+\/\/ The allowed set of signals is restricted by the caller.\n+\/\/ The incoming handler is one of:\n+\/\/ - psuedo-handler: SIG_IGN or SIG_DFL\n+\/\/ - the VM's UserHandler of type sa_sigaction_t\n+\/\/ - unknown signal handling function which we assume is also\n+\/\/   of type sa_sigaction_t - this is a bug - see JDK-8295702\n+\/\/ Returns the currently installed handler.\n+void* PosixSignals::install_generic_signal_handler(int sig, void* handler) {\n@@ -855,2 +858,7 @@\n-  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n-  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n+  sigAct.sa_flags = SA_RESTART;\n+  if (HANDLER_IS_IGN_OR_DFL(handler)) {\n+    sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n+  } else {\n+    sigAct.sa_flags |= SA_SIGINFO;\n+    sigAct.sa_sigaction = CAST_TO_FN_PTR(sa_sigaction_t, handler);\n+  }\n@@ -858,1 +866,1 @@\n-  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n+  if (sigaction(sig, &sigAct, &oldSigAct)) {\n@@ -866,2 +874,28 @@\n-void os::signal_raise(int signal_number) {\n-  ::raise(signal_number);\n+\/\/ Installs the given sigaction handler for the given signal.\n+\/\/ - sigAct: the new struct sigaction to be filled in and used\n+\/\/           for this signal. The caller must provide this as it\n+\/\/           may need to be stored\/accessed by that caller.\n+\/\/ - oldSigAct: the old struct sigaction that was associated with\n+\/\/              this signal\n+\/\/ Returns 0 on success and -1 on error.\n+int PosixSignals::install_sigaction_signal_handler(struct sigaction* sigAct,\n+                                                   struct sigaction* oldSigAct,\n+                                                   int sig,\n+                                                   sa_sigaction_t handler) {\n+  sigfillset(&sigAct->sa_mask);\n+  remove_error_signals_from_set(&sigAct->sa_mask);\n+  sigAct->sa_sigaction = handler;\n+  sigAct->sa_flags = SA_SIGINFO|SA_RESTART;\n+#if defined(__APPLE__)\n+  \/\/ Needed for main thread as XNU (Mac OS X kernel) will only deliver SIGSEGV\n+  \/\/ (which starts as SIGBUS) on main thread with faulting address inside \"stack+guard pages\"\n+  \/\/ if the signal handler declares it will handle it on alternate stack.\n+  \/\/ Notice we only declare we will handle it on alt stack, but we are not\n+  \/\/ actually going to use real alt stack - this is just a workaround.\n+  \/\/ Please see ux_exception.c, method catch_mach_exception_raise for details\n+  \/\/ link http:\/\/www.opensource.apple.com\/source\/xnu\/xnu-2050.18.24\/bsd\/uxkern\/ux_exception.c\n+  if (sig == SIGSEGV) {\n+    sigAct->sa_flags |= SA_ONSTACK;\n+  }\n+#endif\n+  return sigaction(sig, sigAct, oldSigAct);\n@@ -1237,16 +1271,3 @@\n-  sigfillset(&(sigAct.sa_mask));\n-  remove_error_signals_from_set(&(sigAct.sa_mask));\n-  sigAct.sa_sigaction = javaSignalHandler;\n-  sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-#if defined(__APPLE__)\n-  \/\/ Needed for main thread as XNU (Mac OS X kernel) will only deliver SIGSEGV\n-  \/\/ (which starts as SIGBUS) on main thread with faulting address inside \"stack+guard pages\"\n-  \/\/ if the signal handler declares it will handle it on alternate stack.\n-  \/\/ Notice we only declare we will handle it on alt stack, but we are not\n-  \/\/ actually going to use real alt stack - this is just a workaround.\n-  \/\/ Please see ux_exception.c, method catch_mach_exception_raise for details\n-  \/\/ link http:\/\/www.opensource.apple.com\/source\/xnu\/xnu-2050.18.24\/bsd\/uxkern\/ux_exception.c\n-  if (sig == SIGSEGV) {\n-    sigAct.sa_flags |= SA_ONSTACK;\n-  }\n-#endif\n+  int ret = PosixSignals::install_sigaction_signal_handler(&sigAct, &oldAct,\n+                                                           sig, javaSignalHandler);\n+  assert(ret == 0, \"check\");\n@@ -1258,4 +1279,1 @@\n-\n-  int ret = sigaction(sig, &sigAct, &oldAct);\n-  assert(ret == 0, \"check\");\n-\n+#ifdef ASSERT\n@@ -1264,0 +1282,1 @@\n+#endif\n@@ -1311,1 +1330,4 @@\n-    os::signal(BREAK_SIGNAL, os::user_handler());\n+    struct sigaction sigAct, oldSigAct;\n+    int ret =  PosixSignals::install_sigaction_signal_handler(&sigAct, &oldSigAct,\n+                                                              BREAK_SIGNAL, UserHandler);\n+    assert(ret == 0, \"check\");\n@@ -1607,1 +1629,1 @@\n-static void SR_handler(int sig, siginfo_t* siginfo, void* ucVoid) {\n+static void SR_handler(int sig, siginfo_t* siginfo, void* context) {\n@@ -1650,1 +1672,1 @@\n-    suspend_save_context(osthread, siginfo, ucVoid);\n+    suspend_save_context(osthread, siginfo, context);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":61,"deletions":39,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+extern \"C\" {\n+  typedef void (*sa_handler_t)(int);\n+  typedef void (*sa_sigaction_t)(int, siginfo_t*, void*);\n+}\n+\n@@ -64,0 +69,8 @@\n+\n+  \/\/ Signal handler installation\n+  static int install_sigaction_signal_handler(struct sigaction* sigAct, \/\/ Main VM handler routine\n+                                              struct sigaction* oldAct,\n+                                              int sig,\n+                                              sa_sigaction_t handler);\n+  static void* install_generic_signal_handler(int sig, void* handler); \/\/ Used by JVM_RegisterSignal\n+  static void* user_handler(); \/\/ Needed for signal handler comparisons\n","filename":"src\/hotspot\/os\/posix\/signals_posix.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-static void crash_handler(int sig, siginfo_t* info, void* ucVoid) {\n+static void crash_handler(int sig, siginfo_t* info, void* context) {\n@@ -71,1 +71,1 @@\n-  ucontext_t* const uc = (ucontext_t*) ucVoid;\n+  ucontext_t* const uc = (ucontext_t*) context;\n@@ -87,1 +87,1 @@\n-    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {\n+    if (handle_assert_poison_fault(context, info->si_addr)) {\n@@ -93,1 +93,1 @@\n-  VMError::report_and_die(NULL, sig, pc, info, ucVoid);\n+  VMError::report_and_die(NULL, sig, pc, info, context);\n@@ -104,1 +104,4 @@\n-    os::signal(signals_to_handle[i], CAST_FROM_FN_PTR(void *, crash_handler));\n+    struct sigaction sigAct, oldSigAct;\n+    PosixSignals::install_sigaction_signal_handler(&sigAct, &oldSigAct,\n+                                                   signals_to_handle[i], crash_handler);\n+    \/\/ No point checking the return code during error reporting.\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"os_windows.hpp\"\n@@ -37,1 +38,1 @@\n-\/\/ Signal code is mostly copied from classic vm, signals_md.c   1.4 98\/08\/23\n+\n@@ -46,5 +47,3 @@\n-  \/\/ Copied from classic vm\n-  \/\/ signals_md.c       1.4 98\/08\/23\n-  void* newHandler = handler == (void *)2\n-                   ? os::user_handler()\n-                   : handler;\n+  signal_handler_t newHandler = handler == (void *)2 ?\n+                                CAST_TO_FN_PTR(signal_handler_t, os::win32::user_handler()) :\n+                                CAST_TO_FN_PTR(signal_handler_t, handler);\n@@ -68,2 +67,2 @@\n-  void* oldHandler = os::signal(sig, newHandler);\n-  if (oldHandler == os::user_handler()) {\n+  void* oldHandler = os::win32::install_signal_handler(sig, newHandler);\n+  if (oldHandler == os::win32::user_handler()) {\n@@ -87,1 +86,1 @@\n-  os::signal_raise(sig);\n+  ::raise(sig);\n","filename":"src\/hotspot\/os\/windows\/jvm_windows.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2110,1 +2110,1 @@\n-static void (*sigbreakHandler)(int) = NULL;\n+static signal_handler_t sigbreakHandler = NULL;\n@@ -2112,1 +2112,1 @@\n-static void UserHandler(int sig, void *siginfo, void *context) {\n+static void UserHandler(int sig) {\n@@ -2115,1 +2115,1 @@\n-  os::signal(sig, (void*)UserHandler);\n+  os::win32::install_signal_handler(sig, UserHandler);\n@@ -2118,2 +2118,2 @@\n-void* os::user_handler() {\n-  return (void*) UserHandler;\n+void* os::win32::user_handler() {\n+  return CAST_FROM_FN_PTR(void*, UserHandler);\n@@ -2122,5 +2122,20 @@\n-void* os::signal(int signal_number, void* handler) {\n-  if ((signal_number == SIGBREAK) && (!ReduceSignalUsage)) {\n-    void (*oldHandler)(int) = sigbreakHandler;\n-    sigbreakHandler = (void (*)(int)) handler;\n-    return (void*) oldHandler;\n+\/\/ Used mainly by JVM_RegisterSignal to install a signal handler,\n+\/\/ but also to install the VM's BREAK_HANDLER. However, due to\n+\/\/ the way Windows signals work we also have to reinstall each\n+\/\/ handler at the end of its own execution.\n+\/\/ The allowed set of signals is restricted by the caller.\n+\/\/ The incoming handler is one of:\n+\/\/ - psuedo-handler: SIG_IGN or SIG_DFL\n+\/\/ - VM defined signal handling function of type signal_handler_t\n+\/\/ - unknown signal handling function which we expect* is also\n+\/\/   of type signal_handler_t\n+\/\/\n+\/\/ * win32 defines a two-arg signal handling function for use solely with\n+\/\/   SIGFPE. As we don't allow that to be set via the Java API we know we\n+\/\/   only have the single arg version.\n+\/\/ Returns the currently installed handler.\n+void* os::win32::install_signal_handler(int sig, signal_handler_t handler) {\n+  if ((sig == SIGBREAK) && (!ReduceSignalUsage)) {\n+    void* oldHandler = CAST_FROM_FN_PTR(void*, sigbreakHandler);\n+    sigbreakHandler = handler;\n+    return oldHandler;\n@@ -2128,1 +2143,1 @@\n-    return (void*)::signal(signal_number, (void (*)(int))handler);\n+    return ::signal(sig, handler);\n@@ -2132,4 +2147,0 @@\n-void os::signal_raise(int signal_number) {\n-  raise(signal_number);\n-}\n-\n@@ -2150,1 +2161,1 @@\n-    os::signal_raise(SIGINT);\n+    ::raise(SIGINT);\n@@ -2176,1 +2187,1 @@\n-    os::signal_raise(SIGTERM);\n+    ::raise(SIGTERM);\n@@ -2229,1 +2240,1 @@\n-  os::signal(SIGBREAK, os::user_handler());\n+  os::win32::install_signal_handler(SIGBREAK, UserHandler);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+typedef void (*signal_handler_t)(int);\n+\n@@ -123,0 +125,4 @@\n+\n+  \/\/ signal support\n+  static void* install_signal_handler(int sig, signal_handler_t handler);\n+  static void* user_handler();\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -878,1 +878,1 @@\n-  \/\/ Support for signals (see JVM_RaiseSignal, JVM_RegisterSignal)\n+  \/\/ Support for signals\n@@ -881,2 +881,0 @@\n-  static void* signal(int signal_number, void* handler);\n-  static void  signal_raise(int signal_number);\n@@ -884,1 +882,0 @@\n-  static void* user_handler();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}