{"files":[{"patch":"@@ -1794,1 +1794,4 @@\n-    if (toop) {\n+    ciKlass*           klass = toop ? toop->klass() : (tkls ? tkls->klass() : NULL );\n+    if (klass && klass->is_loaded() && klass->is_interface()) {\n+      st->print(\"  Interface:\");\n+    } else if (toop) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5568,1 +5568,1 @@\n-\/\/ It will be NotNull, and exact if and only if the klass type is exact.\n+\/\/ It will be exact if and only if the klass type is exact.\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -927,0 +927,5 @@\n+  \/\/ TypeInstPtr (TypeAryPtr resp.) and TypeInstKlassPtr (TypeAryKlassPtr resp.) implement very similar meet logic.\n+  \/\/ The logic for meeting 2 instances (2 arrays resp.) is shared in the 2 utility methods below. However the logic for\n+  \/\/ the oop and klass versions can be slightly different and extra logic may have to be executed depending on what\n+  \/\/ exact case the meet falls into. The MeetResult struct is used by the utility methods to communicate what case was\n+  \/\/ encountered so the right logic specific to klasses or oops can be executed.,\n@@ -1886,1 +1891,1 @@\n-  assert( _base >= KlassPtr && _base <= AryKlassPtr, \"Not a klass pointer\" );\n+  assert(_base >= KlassPtr && _base <= AryKlassPtr, \"Not a klass pointer\");\n@@ -1895,1 +1900,1 @@\n-  assert( _base == InstKlassPtr, \"Not a klass pointer\" );\n+  assert(_base == InstKlassPtr, \"Not a klass pointer\");\n@@ -1904,1 +1909,1 @@\n-  assert( _base == AryKlassPtr, \"Not a klass pointer\" );\n+  assert(_base == AryKlassPtr, \"Not a klass pointer\");\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}