{"files":[{"patch":"@@ -338,0 +338,4 @@\n+  \/\/ Visits nodes for buckets in range [start_idx, stop_id) with FUNC.\n+  template <typename FUNC>\n+  void do_scan_for_range(FUNC& scan_f, size_t start_idx, size_t stop_idx, InternalTable *table);\n+\n@@ -389,0 +393,2 @@\n+  class BucketsClaimer;\n+\n@@ -474,0 +480,5 @@\n+  \/\/ Visit all items with SCAN_FUNC without any protection.\n+  \/\/ Thread-safe, but must be called at safepoint.\n+  template <typename SCAN_FUNC>\n+  void do_safepoint_scan(SCAN_FUNC& scan_f, BucketsClaimer* bucket_claimer);\n+\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -980,0 +980,20 @@\n+template <typename CONFIG, MEMFLAGS F>\n+template <typename FUNC>\n+inline void ConcurrentHashTable<CONFIG, F>::\n+  do_scan_for_range(FUNC& scan_f, size_t start_idx, size_t stop_idx, InternalTable* table)\n+{\n+  assert(start_idx < stop_idx, \"Must be\");\n+  assert(stop_idx <= table->_size, \"Must be\");\n+\n+  for (size_t bucket_it = start_idx; bucket_it < stop_idx; ++bucket_it) {\n+    Bucket* bucket = table->get_bucket(bucket_it);\n+    \/\/ If bucket has a redirect, the items will be in the new table.\n+    if (!bucket->have_redirect()) {\n+      bool result = visit_nodes(table->get_bucket(bucket_it), scan_f);\n+      assert(result, \"Must be\");\n+    } else {\n+      assert(bucket->is_locked(), \"Bucket must be locked.\");\n+    }\n+  }\n+}\n+\n@@ -1177,0 +1197,16 @@\n+template <typename CONFIG, MEMFLAGS F>\n+template <typename SCAN_FUNC>\n+inline void ConcurrentHashTable<CONFIG, F>::\n+  do_safepoint_scan(SCAN_FUNC& scan_f, BucketsClaimer* bucket_claimer)\n+{\n+  assert(SafepointSynchronize::is_at_safepoint(),\n+         \"must only be called in a safepoint\");\n+  size_t start_idx = 0, stop_idx = 0;\n+  InternalTable* table = NULL;\n+  while (bucket_claimer->claim(&start_idx, &stop_idx, &table)) {\n+    assert(table != NULL, \"precondition\");\n+    do_scan_for_range(scan_f, start_idx, stop_idx, table);\n+    table = NULL;\n+  }\n+}\n+\n@@ -1292,0 +1328,69 @@\n+template <typename CONFIG, MEMFLAGS F>\n+class ConcurrentHashTable<CONFIG, F>::BucketsClaimer {\n+ protected:\n+  ConcurrentHashTable<CONFIG, F>* _cht;\n+\n+  \/\/ Default size of _claim_size_log2\n+  static const size_t DEFAULT_CLAIM_SIZE_LOG2 = 12;\n+  \/\/ The table is split into ranges, every increment is one range.\n+  volatile size_t _next_to_claim;\n+  size_t _claim_size_log2; \/\/ Number of buckets in claimed range.\n+  size_t _limit;      \/\/ Limit to number of claims\n+\n+  \/\/ If there is a paused resize, we also need to operate on the already resized items.\n+  volatile size_t _next_to_claim_new_table;\n+  size_t _claim_size_log2_new_table;\n+  size_t _limit_new_table;\n+\n+public:\n+  BucketsClaimer(ConcurrentHashTable<CONFIG, F>* cht)\n+    : _cht(cht), _next_to_claim(0), _claim_size_log2(DEFAULT_CLAIM_SIZE_LOG2), _limit(0),\n+    _next_to_claim_new_table(0), _claim_size_log2_new_table(0), _limit_new_table(0) {\n+\n+      size_t size_log2 = _cht->_table->_log2_size;\n+      _claim_size_log2 = MIN2(_claim_size_log2, size_log2);\n+      size_t tmp = size_log2 > _claim_size_log2 ?\n+                   (size_log2 - _claim_size_log2) : 0;\n+      _limit = (((size_t)1) << tmp);\n+\n+      ConcurrentHashTable<CONFIG, F>::InternalTable* new_table = _cht->get_new_table();\n+\n+      if (new_table != NULL) {\n+        size_t size_log2_new_table = new_table->_log2_size;\n+        _claim_size_log2_new_table = MIN2(DEFAULT_CLAIM_SIZE_LOG2, size_log2_new_table);\n+        size_t tmp = size_log2_new_table > _claim_size_log2_new_table ?\n+                     (size_log2_new_table - _claim_size_log2_new_table) : 0;\n+        _limit_new_table = (((size_t)1) << tmp);\n+      }\n+    }\n+\n+    \/\/ Returns true if you succeeded to claim the range [start, stop).\n+    bool claim(size_t* start, size_t* stop, ConcurrentHashTable<CONFIG, F>::InternalTable** table) {\n+      if (Atomic::load(&_next_to_claim) < _limit) {\n+        size_t claimed = Atomic::fetch_and_add(&_next_to_claim, 1u);\n+        if (claimed < _limit) {\n+          *start = claimed << _claim_size_log2;\n+          *stop  = ((*start) + (((size_t)1) << _claim_size_log2));\n+          *table = _cht->get_table();\n+          return true;\n+        }\n+      }\n+\n+      if (_limit_new_table == 0) {\n+        assert(_cht->get_new_table() == NULL, \"Precondition\");\n+        return false;\n+      }\n+\n+      ConcurrentHashTable<CONFIG, F>::InternalTable* new_table = _cht->get_new_table();\n+      assert(new_table != NULL, \"Precondition\");\n+      size_t claimed = Atomic::fetch_and_add(&_next_to_claim_new_table, 1u);\n+      if (claimed < _limit_new_table) {\n+        *start = claimed << _claim_size_log2_new_table;\n+        *stop  = ((*start) + (((size_t)1) << _claim_size_log2_new_table));\n+        *table = new_table;\n+        return true;\n+      }\n+      return false;\n+    }\n+};\n+\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -1147,0 +1149,75 @@\n+\n+class ScannerThread: public WorkerThread {\n+  Semaphore _start;\n+  Semaphore* _done;\n+  TestTable* _cht;\n+  TestTable::BucketsClaimer* _bucket_claimer;\n+  size_t _num_scanned;\n+  size_t *_total_scanned;\n+protected:\n+  void run() override {\n+    _start.wait();\n+    _cht->do_safepoint_scan(*this, _bucket_claimer);\n+    Atomic::add(_total_scanned, _num_scanned);\n+    _done->signal();\n+  }\n+public:\n+  ScannerThread(Semaphore* done, TestTable* cht, TestTable::BucketsClaimer* bc, size_t *total_scanned) :\n+    _done(done), _cht(cht), _bucket_claimer(bc), _num_scanned(0), _total_scanned(total_scanned) {}\n+\n+  void run_thread() {\n+    _start.signal();\n+  }\n+\n+  bool operator()(uintptr_t* val) {\n+    return ++_num_scanned;\n+  }\n+};\n+\n+class CHTScanMT: public VM_GTestExecuteAtSafepoint {\n+  TestTable* _cht;\n+  uintptr_t _num_items;\n+public:\n+  CHTScanMT(TestTable* cht, uintptr_t num_items): _cht(cht), _num_items(num_items) { }\n+  void doit();\n+};\n+\n+void CHTScanMT::doit() {\n+  size_t total_scanned = 0;\n+  TestTable::BucketsClaimer bucket_claimer(_cht);\n+  Semaphore done(0);\n+\n+  \/\/ Create and start parallel worker threads.\n+  const int num_threads = 4;\n+  ScannerThread* st[num_threads];\n+  for (int i = 0; i < num_threads; i++) {\n+    st[i] = new ScannerThread(&done, _cht, &bucket_claimer, &total_scanned);\n+    os::create_thread(st[i], os::pgc_thread);\n+    os::start_thread(st[i]);\n+  }\n+\n+  for (int i = 0; i < num_threads; i++) {\n+    st[i]->run_thread();\n+  }\n+\n+  for (int i = 0; i < num_threads; i++) {\n+    done.wait();\n+  }\n+\n+  EXPECT_TRUE(total_scanned == (size_t)_num_items) << \" Should scan all inserted items: \" << total_scanned;\n+}\n+\n+TEST_VM(ConcurrentHashTable, concurrent_mt_scan) {\n+  TestTable* cht = new TestTable(16, 16, 2);\n+\n+  uintptr_t num_items = 99999;\n+  for (uintptr_t v = 1; v <= num_items; v++ ) {\n+    TestLookup tl(v);\n+    EXPECT_TRUE(cht->insert(JavaThread::current(), tl, v)) << \"Inserting an unique value should work.\";\n+  }\n+\n+  \/\/ Run the test at a safepoint.\n+  CHTScanMT op(cht, num_items);\n+  ThreadInVMfromNative invm(JavaThread::current());\n+  VMThread::execute(&op);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"}]}