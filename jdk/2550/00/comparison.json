{"files":[{"patch":"@@ -45,2 +45,4 @@\n-     * @param asn1Bytes\n-     * @return the decode bytes\n+     * @param asn1Bytes the ASN.1 encoded bytes\n+     * @param rawLen the intended length of decoded bytes for an integer.\n+     *               If -1, choose one automatically.\n+     * @return the decoded bytes\n@@ -51,2 +53,1 @@\n-    public static byte[] convertASN1toXMLDSIG(byte asn1Bytes[]) throws IOException {\n-\n+    public static byte[] convertASN1toXMLDSIG(byte asn1Bytes[], int rawLen) throws IOException {\n@@ -75,1 +76,7 @@\n-        int rawLen = Math.max(i, j);\n+        int maxLen = Math.max(i, j);\n+\n+        if (rawLen < 0) {\n+            rawLen = maxLen;\n+        } else if (rawLen < maxLen) {\n+            throw new IOException(\"Invalid signature length\");\n+        }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/ECDSAUtils.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.security.interfaces.ECPrivateKey;\n@@ -57,0 +58,3 @@\n+    \/** Length for each integer in signature *\/\n+    private int signIntLen = -1;\n+\n@@ -64,0 +68,1 @@\n+     * @param rawLen\n@@ -70,2 +75,2 @@\n-    public static byte[] convertASN1toXMLDSIG(byte asn1Bytes[]) throws IOException {\n-        return ECDSAUtils.convertASN1toXMLDSIG(asn1Bytes);\n+    public static byte[] convertASN1toXMLDSIG(byte asn1Bytes[], int rawLen) throws IOException {\n+        return ECDSAUtils.convertASN1toXMLDSIG(asn1Bytes, rawLen);\n@@ -182,2 +187,1 @@\n-\n-            return SignatureECDSA.convertASN1toXMLDSIG(jcebytes);\n+            return SignatureECDSA.convertASN1toXMLDSIG(jcebytes, signIntLen);\n@@ -206,0 +210,5 @@\n+            if (privateKey instanceof ECPrivateKey) {\n+                ECPrivateKey ecKey = (ECPrivateKey)privateKey;\n+                signIntLen = (ecKey.getParams().getCurve().getField().getFieldSize() + 7) \/ 8;\n+                \/\/ If not ECPrivateKey, signIntLen remains -1\n+            }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/SignatureECDSA.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.security.interfaces.ECPrivateKey;\n@@ -521,1 +522,6 @@\n-                return SignatureECDSA.convertASN1toXMLDSIG(sig);\n+                int rawLen = -1;\n+                if (key instanceof ECPrivateKey) {\n+                    ECPrivateKey ecKey = (ECPrivateKey)key;\n+                    rawLen = (ecKey.getParams().getCurve().getField().getFieldSize() + 7) \/ 8;\n+                }\n+                return SignatureECDSA.convertASN1toXMLDSIG(sig, rawLen);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignatureMethod.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8259535\n+ * @summary ECDSA SignatureValue do not always have the specified length\n+ * @modules java.xml.crypto\n+ *\/\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.InputSource;\n+\n+import javax.xml.crypto.dsig.*;\n+import javax.xml.crypto.dsig.dom.DOMSignContext;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfo;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;\n+import javax.xml.crypto.dsig.keyinfo.X509Data;\n+import javax.xml.crypto.dsig.keyinfo.X509IssuerSerial;\n+import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\n+import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.*;\n+\n+public class ShortECDSA {\n+\n+    public static final String XML = \"<testXmlFile>\\n\"\n+            + \"\\t<element>Value<\/element>\\n\"\n+            + \"<\/testXmlFile>\";\n+\n+    private static final String PRIVATE_KEY_BASE_64 =\n+              \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgP6yNCRsISznuzY4D\"\n+            + \"0cwkBjgV8uu2lQ2tCPxdam7Fx9OhRANCAAS33BazN06tOnXsLYatPvmkrEVDyRWj\"\n+            + \"yzxlCU+en8PPJ4ETUGRhz8h1fAELEkKS0Cky5M61oQVyiSxHaXhunH29\";\n+\n+    private static final XMLSignatureFactory FAC =\n+            XMLSignatureFactory.getInstance(\"DOM\");\n+\n+    public static void main(String[] args) throws Exception {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setNamespaceAware(true);\n+        Document document = factory.newDocumentBuilder().\n+                parse(new InputSource(new StringReader(XML)));\n+\n+        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(\n+                Base64.getDecoder().decode(PRIVATE_KEY_BASE_64));\n+        KeyFactory kf = KeyFactory.getInstance(\"EC\");\n+        PrivateKey privateKey = kf.generatePrivate(keySpec);\n+\n+        \/\/ Remove SunEC so neither its ASN.1 or P1363 format ECDSA will be used\n+        Security.removeProvider(\"SunEC\");\n+        Security.addProvider(new MyProvider());\n+\n+        Document signedDocument = XmlSigningUtils.signDocument(document, privateKey);\n+        NodeList nodeList = signedDocument.getElementsByTagName(\"SignatureValue\");\n+        byte[] sig = Base64.getMimeDecoder().decode(\n+                nodeList.item(0).getFirstChild().getNodeValue());\n+        if (sig.length != 64) {\n+            System.out.println(\"Length: \" + sig.length);\n+            System.out.println(HexFormat.ofDelimiter(\":\").formatHex(sig));\n+            throw new RuntimeException(\"Failed\");\n+        }\n+    }\n+\n+    public static class XmlSigningUtils {\n+\n+        public static Document signDocument(Document document, PrivateKey privateKey)\n+                throws Exception {\n+            DOMResult result = new DOMResult();\n+            TransformerFactory.newInstance().newTransformer()\n+                    .transform(new DOMSource(document), result);\n+            Document newDocument = (Document) result.getNode();\n+            FAC.newXMLSignature(buildSignedInfo(), buildKeyInfo())\n+                    .sign(new DOMSignContext(privateKey, newDocument.getDocumentElement()));\n+            return newDocument;\n+        }\n+\n+        private static SignedInfo buildSignedInfo()\n+                throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+            return FAC.newSignedInfo(\n+                    FAC.newCanonicalizationMethod(CanonicalizationMethod.EXCLUSIVE, (C14NMethodParameterSpec) null),\n+                    FAC.newSignatureMethod(SignatureMethod.ECDSA_SHA256, null),\n+                    List.of(FAC.newReference(\n+                            \"\",\n+                            FAC.newDigestMethod(DigestMethod.SHA256, null),\n+                            List.of(FAC.newTransform(Transform.ENVELOPED, (TransformParameterSpec) null)), null, null)));\n+        }\n+\n+        private static KeyInfo buildKeyInfo() {\n+            KeyInfoFactory keyInfoFactory = FAC.getKeyInfoFactory();\n+            X509IssuerSerial x509IssuerSerial = keyInfoFactory\n+                    .newX509IssuerSerial(\"CN=Me\", BigInteger.ONE);\n+            X509Data x509Data = keyInfoFactory.newX509Data(Collections.singletonList(x509IssuerSerial));\n+            return keyInfoFactory.newKeyInfo(Collections.singletonList(x509Data));\n+        }\n+    }\n+\n+    \/\/ Only provide SHA256withECDSA, no P1363 format. This triggers the convertASN1toXMLDSIG translation.\n+    public static class MyProvider extends Provider {\n+        MyProvider() {\n+            super(\"MyProvider\", \"1\", \"My provider\");\n+            put(\"Signature.SHA256withECDSA\", MyECDSA.class.getName());\n+        }\n+    }\n+\n+    public static class MyECDSA extends SignatureSpi {\n+\n+        \/\/ Hardcoded signature with short r and s\n+        public static byte[] hardcoded;\n+\n+        static {\n+            hardcoded = new byte[68];\n+            \/\/ Fill in with a number <128 so it will look like a\n+            \/\/ correct ASN.1 encoding for positive numbers.\n+            Arrays.fill(hardcoded, (byte) 0x55);\n+            hardcoded[0] = 0x30; \/\/ SEQUENCE OF\n+            hardcoded[1] = 66;   \/\/ 2 [tag,len,31] components\n+            hardcoded[2] = hardcoded[35] = 2;   \/\/ Each being an INTEGER...\n+            hardcoded[3] = hardcoded[36] = 31;  \/\/ ... of 31 bytes long\n+        }\n+\n+        protected void engineInitVerify(PublicKey publicKey) {\n+        }\n+\n+        protected void engineInitSign(PrivateKey privateKey) {\n+        }\n+\n+        protected void engineUpdate(byte b) {\n+        }\n+\n+        protected void engineUpdate(byte[] b, int off, int len) {\n+        }\n+\n+        protected byte[] engineSign() {\n+            return hardcoded;\n+        }\n+\n+        protected boolean engineVerify(byte[] sigBytes) {\n+            return false;\n+        }\n+\n+        protected void engineSetParameter(String param, Object value) {\n+        }\n+\n+        protected Object engineGetParameter(String param) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        protected void engineSetParameter(AlgorithmParameterSpec params) {\n+        }\n+\n+        protected AlgorithmParameters engineGetParameters() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        protected int engineSign(byte[] outbuf, int offset, int len) {\n+            System.arraycopy(hardcoded, 0, outbuf, offset, hardcoded.length);\n+            return hardcoded.length;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/org\/apache\/xml\/internal\/security\/ShortECDSA.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"}]}