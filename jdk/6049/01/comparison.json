{"files":[{"patch":"@@ -168,0 +168,23 @@\n+\n+        public void delete() throws KeyStoreException {\n+            \/\/ Get end-entity certificate and remove from system cert store\n+            X509Certificate[] certChain = getCertificateChain();\n+            if (certChain != null && certChain.length > 0) {\n+                try {\n+                    byte[] encoding = certChain[0].getEncoded();\n+                    removeCertificate(getName(), getAlias(), encoding,\n+                            encoding.length);\n+                } catch (CertificateException e) {\n+                    throw new KeyStoreException(\"Cannot remove entry: \", e);\n+                }\n+            }\n+            CKey privateKey = getPrivateKey();\n+            if (privateKey != null) {\n+                if (privateKey.getHCryptKey() != 0) {\n+                    destroyKeyContainer(\n+                            CKey.getContainerName(privateKey.getHCryptProvider()));\n+                } else {\n+                    removeCngKey(privateKey.getHCryptProvider());\n+                }\n+            }\n+        }\n@@ -371,2 +394,0 @@\n-            KeyEntry entry = entries.get(alias);\n-\n@@ -385,8 +406,1 @@\n-            if (entry == null) {\n-                entry =\n-                    \/\/TODO new KeyEntry(alias, key, (X509Certificate[]) chain);\n-                    new KeyEntry(alias, null, xchain);\n-                storeWithUniqueAlias(alias, entry);\n-            }\n-\n-            entry.setAlias(alias);\n+            KeyEntry oldEntry = entries.get(alias);\n@@ -395,8 +409,6 @@\n-                entry.setRSAPrivateKey(key);\n-                entry.setCertificateChain(xchain);\n-\n-            } catch (CertificateException ce) {\n-                throw new KeyStoreException(ce);\n-\n-            } catch (InvalidKeyException ike) {\n-                throw new KeyStoreException(ike);\n+                KeyEntry newEntry = new KeyEntry(alias, null, xchain);\n+                newEntry.setRSAPrivateKey(key);\n+                newEntry.setCertificateChain(xchain);\n+                entries.put(alias, newEntry);\n+            } catch (CertificateException | InvalidKeyException e) {\n+                throw new KeyStoreException(e);\n@@ -405,0 +417,3 @@\n+            if (oldEntry != null) {\n+                oldEntry.delete();\n+            }\n@@ -466,1 +481,0 @@\n-            KeyEntry entry = entries.get(alias);\n@@ -468,4 +482,3 @@\n-            if (entry == null) {\n-                entry =\n-                    new KeyEntry(alias, null, chain);\n-                storeWithUniqueAlias(alias, entry);\n+            KeyEntry oldEntry = entries.get(alias);\n+            if (oldEntry != null && oldEntry.privateKey != null) {\n+                throw new KeyStoreException(\"Cannot overwrite key entry\");\n@@ -474,9 +487,6 @@\n-            if (entry.getPrivateKey() == null) { \/\/ trusted-cert entry\n-                entry.setAlias(alias);\n-\n-                try {\n-                    entry.setCertificateChain(chain);\n-\n-                } catch (CertificateException ce) {\n-                    throw new KeyStoreException(ce);\n-                }\n+            try {\n+                KeyEntry newEntry = new KeyEntry(alias, null, chain);\n+                newEntry.setCertificateChain(chain);\n+                entries.put(alias, newEntry);\n+            } catch (CertificateException ce) {\n+                throw new KeyStoreException(ce);\n@@ -485,0 +495,3 @@\n+            if (oldEntry != null) {\n+                oldEntry.delete();\n+            }\n@@ -505,19 +518,1 @@\n-            \/\/ Get end-entity certificate and remove from system cert store\n-            X509Certificate[] certChain = entry.getCertificateChain();\n-            if (certChain != null && certChain.length > 0) {\n-\n-                try {\n-\n-                    byte[] encoding = certChain[0].getEncoded();\n-                    removeCertificate(getName(), entry.getAlias(), encoding,\n-                            encoding.length);\n-\n-                } catch (CertificateException e) {\n-                    throw new KeyStoreException(\"Cannot remove entry: \", e);\n-                }\n-            }\n-            CKey privateKey = entry.getPrivateKey();\n-            if (privateKey != null) {\n-                destroyKeyContainer(\n-                    CKey.getContainerName(privateKey.getHCryptProvider()));\n-            }\n+            entry.delete();\n@@ -880,0 +875,7 @@\n+    \/**\n+     * Removes a CNG key.\n+     *\n+     * @param k the handle of the key\n+     *\/\n+    private native void removeCngKey(long k) throws KeyStoreException;\n+\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CKeyStore.java","additions":53,"deletions":51,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-                    privateKey.getHCryptKey(), true);\n+                    privateKey, true);\n@@ -297,1 +297,1 @@\n-                    publicKey.getHCryptKey(), false);\n+                    publicKey, false);\n@@ -301,1 +301,1 @@\n-                    publicKey.getHCryptKey(), true);\n+                    publicKey, true);\n@@ -305,1 +305,1 @@\n-                    privateKey.getHCryptKey(), false);\n+                    privateKey, false);\n@@ -496,1 +496,1 @@\n-     * Encrypt\/decrypt a data buffer using Microsoft Crypto API with HCRYPTKEY.\n+     * Encrypt\/decrypt a data buffer using Microsoft Crypto API or CNG.\n@@ -499,2 +499,8 @@\n-    private native static byte[] encryptDecrypt(byte[] data, int dataSize,\n-        long hCryptKey, boolean doEncrypt) throws KeyException;\n+    private static byte[] encryptDecrypt(byte[] data, int dataSize,\n+            CKey key, boolean doEncrypt) throws KeyException {\n+        if (key.getHCryptKey() != 0) {\n+            return encryptDecrypt(data, dataSize, key.getHCryptKey(), doEncrypt);\n+        } else {\n+            return cngEncryptDecrypt(data, dataSize, key.getHCryptProvider(), doEncrypt);\n+        }\n+    }\n@@ -502,0 +508,4 @@\n+    private native static byte[] encryptDecrypt(byte[] data, int dataSize,\n+            long key, boolean doEncrypt) throws KeyException;\n+    private native static byte[] cngEncryptDecrypt(byte[] data, int dataSize,\n+            long key, boolean doEncrypt) throws KeyException;\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CRSACipher.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1802,0 +1802,10 @@\n+JNIEXPORT void JNICALL Java_sun_security_mscapi_CKeyStore_removeCngKey\n+  (JNIEnv *env, jobject clazz, jlong k)\n+{\n+    SECURITY_STATUS ss;\n+    ss = ::NCryptDeleteKey((NCRYPT_KEY_HANDLE)k, 0);\n+    if (ss != ERROR_SUCCESS) {\n+        ThrowException(env, KEY_EXCEPTION, ss);\n+    }\n+}\n+\n@@ -1926,0 +1936,63 @@\n+\/*\n+ * Class:     sun_security_mscapi_CRSACipher\n+ * Method:    cngEncryptDecrypt\n+ * Signature: ([BIJZ)[B\n+ *\/\n+JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CRSACipher_cngEncryptDecrypt\n+  (JNIEnv *env, jclass clazz, jbyteArray jData, jint jDataSize, jlong hKey,\n+   jboolean doEncrypt)\n+{\n+    SECURITY_STATUS ss;\n+    jbyteArray result = NULL;\n+    jbyte* pData = NULL;\n+    DWORD dwDataLen = jDataSize;\n+    DWORD dwBufLen = env->GetArrayLength(jData);\n+    __try\n+    {\n+        \/\/ Copy data from Java buffer to native buffer\n+        pData = new (env) jbyte[dwBufLen];\n+        if (pData == NULL) {\n+            __leave;\n+        }\n+        env->GetByteArrayRegion(jData, 0, dwBufLen, pData);\n+\n+        if (doEncrypt == JNI_TRUE) {\n+            \/\/ encrypt\n+            ss = ::NCryptEncrypt((NCRYPT_KEY_HANDLE) hKey,\n+                    (PBYTE)pData, dwDataLen,\n+                    0,\n+                    (PBYTE)pData, dwBufLen,\n+                    &dwBufLen, NCRYPT_PAD_PKCS1_FLAG);\n+            if (ss != ERROR_SUCCESS) {\n+                ThrowException(env, KEY_EXCEPTION, ss);\n+                __leave;\n+            }\n+        } else {\n+            \/\/ decrypt\n+            ss = ::NCryptDecrypt((NCRYPT_KEY_HANDLE) hKey,\n+                    (PBYTE)pData, dwDataLen,\n+                    0,\n+                    (PBYTE)pData, dwBufLen,\n+                    &dwBufLen, NCRYPT_PAD_PKCS1_FLAG);\n+            if (ss != ERROR_SUCCESS) {\n+                ThrowException(env, KEY_EXCEPTION, ss);\n+                __leave;\n+            }\n+        }\n+        \/\/ Create new byte array\n+        if ((result = env->NewByteArray(dwBufLen)) == NULL) {\n+            __leave;\n+        }\n+\n+        \/\/ Copy data from native buffer to Java buffer\n+        env->SetByteArrayRegion(result, 0, dwBufLen, (jbyte*) pData);\n+    }\n+    __finally {\n+        if (pData) {\n+            delete [] pData;\n+        }\n+    }\n+\n+    return result;\n+}\n+\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.SecurityTools;\n+\n+import java.util.Arrays;\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+import java.security.KeyStore;\n+\n+\/**\n+ * @test\n+ * @bug 8251134\n+ * @requires os.family == \"windows\"\n+ * @summary Cipher operations on CNG keys\n+ * @library \/test\/lib\n+ *\/\n+\n+public class CngCipher {\n+\n+    final static String PREFIX = \"8251134\";\n+\n+    public static void main(String[] args) throws Exception {\n+        cleanup();\n+        prepare();\n+        try {\n+            test(PREFIX + \"m\");\n+            test(PREFIX + \"c\");\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    static void prepare() throws Exception {\n+        \/\/ This will generate a MSCAPI key\n+        SecurityTools.keytool(\"-storetype Windows-MY -genkeypair -alias \"\n+                + PREFIX + \"m -keyalg RSA -dname CN=\" + PREFIX + \"m\");\n+        \/\/ This will generate a CNG key\n+        ProcessBuilder pb = new ProcessBuilder(\"powershell\", \"-Command\",\n+                \"New-SelfSignedCertificate\",  \"-DnsName\", PREFIX + \"c\",\n+                \/\/ -KeyAlgorithm not supported on Windows Server 2012\n+                \/\/\"-KeyAlgorithm\", \"RSA\",\n+                \"-CertStoreLocation\", \"Cert:\\\\CurrentUser\\\\My\");\n+        pb.inheritIO();\n+        pb.start().waitFor();\n+    }\n+\n+    static void cleanup() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"Windows-MY\");\n+        ks.load(null, null);\n+        ks.deleteEntry(PREFIX +\"c\");\n+        ks.deleteEntry(PREFIX +\"m\");\n+        ks.store(null, null);\n+    }\n+\n+    static void test(String alias) throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"Windows-MY\");\n+        ks.load(null, null);\n+        var alg = \"RSA\/ECB\/PKCS1Padding\";\n+\n+        var k1 = ks.getKey(alias, \"changeit\".toCharArray());\n+        var k2 = ks.getCertificate(alias).getPublicKey();\n+\n+        Cipher c;\n+\n+        var k = KeyGenerator.getInstance(\"AES\").generateKey();\n+        c = Cipher.getInstance(alg, \"SunMSCAPI\");\n+        c.init(Cipher.WRAP_MODE, k2);\n+        var enc = c.wrap(k);\n+        c = Cipher.getInstance(alg, \"SunMSCAPI\");\n+        c.init(Cipher.UNWRAP_MODE, k1);\n+        var dec = c.unwrap(enc, \"AES\", Cipher.SECRET_KEY);\n+        Asserts.assertTrue(Arrays.equals(k.getEncoded(), dec.getEncoded()));\n+\n+        c = Cipher.getInstance(alg, \"SunMSCAPI\");\n+        c.init(Cipher.ENCRYPT_MODE, k2);\n+        byte[] msg = \"hello you fool\".getBytes(java.nio.charset.StandardCharsets.UTF_8);\n+        c.update(msg);\n+        var enc2 = c.doFinal();\n+        c = Cipher.getInstance(alg, \"SunMSCAPI\");\n+        c.init(Cipher.DECRYPT_MODE, k1);\n+        c.update(enc2);\n+        var dec2 = c.doFinal();\n+        Asserts.assertTrue(Arrays.equals(msg, dec2));\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/mscapi\/CngCipher.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8185844\n+ * @summary ensure setEntry overwrite old entry\n+ * @library \/test\/lib\n+ * @requires os.family == \"windows\"\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ *\/\n+public class SetDupNameEntry {\n+\n+    final KeyStore keyStore;\n+    final CertAndKeyGen ckg;\n+\n+    static final String PREFIX = \"8185844\";\n+\n+    public static void main(String[] args) throws Exception {\n+        SetDupNameEntry test = new SetDupNameEntry();\n+        test.cleanup();\n+        try {\n+            test.test(true);    \/\/ test key entry\n+            test.test(false);   \/\/ test cert entry\n+        } finally {\n+            test.cleanup();\n+        }\n+    }\n+\n+    SetDupNameEntry() throws Exception {\n+        keyStore = KeyStore.getInstance(\"Windows-MY\");\n+        ckg = new CertAndKeyGen(\"RSA\", \"SHA1withRSA\");\n+    }\n+\n+    void test(boolean testKey) throws Exception {\n+        keyStore.load(null, null);\n+        int size = keyStore.size();\n+\n+        String alias = PREFIX + (testKey ? \"k\" : \"c\");\n+        for (int i = 0; i < 2; i++) {\n+            ckg.generate(1024);\n+            X509Certificate cert = ckg\n+                    .getSelfCertificate(new X500Name(\"CN=TEST\"), 1000);\n+            if (testKey) {\n+                keyStore.setKeyEntry(\n+                        alias,\n+                        ckg.getPrivateKey(),\n+                        null,\n+                        new Certificate[] { cert });\n+            } else {\n+                keyStore.setCertificateEntry(alias, cert);\n+            }\n+        }\n+        Asserts.assertEQ(keyStore.size(), size + 1);\n+\n+        keyStore.load(null, null);\n+        Asserts.assertEQ(keyStore.size(), size + 1);\n+    }\n+\n+    void cleanup() throws Exception {\n+        keyStore.load(null, null);\n+        for (String alias : Collections.list(keyStore.aliases())) {\n+            if (alias.startsWith(PREFIX)) {\n+                keyStore.deleteEntry(alias);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/mscapi\/SetDupNameEntry.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}