{"files":[{"patch":"@@ -230,3 +230,2 @@\n-\/\/ Clones skeleton predicates starting at 'old_predicate_proj' to\n-\/\/ 'new_predicate_proj' and rewires the control edges of data nodes in\n-\/\/ the loop from the old predicates to the new cloned predicates.\n+\/\/ Clones skeleton predicates starting at 'old_predicate_proj' by following its control inputs and rewires the control edges of in the loop from\n+\/\/ the old predicates to the new cloned predicates.\n@@ -234,1 +233,1 @@\n-                                                                  ProjNode* old_predicate_proj, ProjNode* iffast, ProjNode* ifslow) {\n+                                                                  ProjNode* old_predicate_proj, ProjNode* iffast_pred, ProjNode* ifslow_pred) {\n@@ -236,0 +235,1 @@\n+  assert(iffast_pred->in(0)->is_If() && ifslow_pred->in(0)->is_If(), \"sanity check\");\n@@ -241,2 +241,0 @@\n-  Node* current_proj = old_predicate_proj;\n-  Node* prev_proj = current_proj;\n@@ -259,2 +257,3 @@\n-  \/\/ Process in reverse order such that 'create_new_if_for_predicate' can be used and the original order is maintained\n-  for (int i = list.size()-1; i >= 0; i--) {\n+  \/\/ Process in reverse order such that 'create_new_if_for_predicate' can be used in 'clone_skeleton_predicate_for_unswitched_loops'\n+  \/\/ and the original order is maintained.\n+  for (int i = list.size() - 1; i >= 0; i--) {\n@@ -267,3 +266,4 @@\n-    \/\/ cloned_proj is the same type of projection as the original predicate projection (IfTrue or IfFalse)\n-    ProjNode* fast_proj = create_new_if_for_predicate(iffast, NULL, reason, iff->Opcode(), predicate_proj->is_IfTrue());\n-    ProjNode* slow_proj = create_new_if_for_predicate(ifslow, NULL, reason, iff->Opcode(), predicate_proj->is_IfTrue());\n+    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, iffast_pred, loop);\n+    assert(skeleton_predicate_has_opaque(fast_proj->in(0)->as_If()), \"must find skeleton predicate for fast loop\");\n+    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, ifslow_pred, loop);\n+    assert(skeleton_predicate_has_opaque(slow_proj->in(0)->as_If()), \"must find skeleton predicate for slow loop\");\n@@ -271,6 +271,3 @@\n-    \/\/ Replace bool input by input from original predicate\n-    _igvn.replace_input_of(fast_proj->in(0), 1, iff->in(1));\n-    _igvn.replace_input_of(slow_proj->in(0), 1, iff->in(1));\n-\n-    for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n-      Node* fast_node = predicate->out(i);\n+    \/\/ Update control dependent data nodes.\n+    for (DUIterator j = predicate->outs(); predicate->has_out(j); j++) {\n+      Node* fast_node = predicate->out(j);\n@@ -283,1 +280,1 @@\n-        --i;\n+        --j;\n@@ -286,2 +283,1 @@\n-    \/\/ Have to delay updates to the slow loop so uses of predicate are\n-    \/\/ not modified while we iterate on them.\n+    \/\/ Have to delay updates to the slow loop so uses of predicate are not modified while we iterate on them.\n@@ -295,0 +291,14 @@\n+\/\/ Clone a skeleton predicate for an unswitched loop. OpaqueLoopInit and OpaqueLoopStride nodes are cloned and uncommon\n+\/\/ traps are kept for the predicate (a Halt node is used later when creating pre\/main\/post loops and copying this cloned\n+\/\/ predicate again).\n+ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj,\n+                                                                    Deoptimization::DeoptReason reason, ProjNode* output_proj,\n+                                                                    IdealLoopTree* loop) {\n+  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, predicate, uncommon_proj, output_proj, loop);\n+  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(), predicate->is_IfTrue());\n+  _igvn.replace_input_of(proj->in(0), 1, bol);\n+  _igvn.replace_input_of(output_proj->in(0), 0, proj);\n+  set_idom(output_proj->in(0), proj, dom_depth(proj));\n+  return proj;\n+}\n+\n@@ -297,1 +307,1 @@\n-void PhaseIdealLoop::clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast, ProjNode*& ifslow) {\n+void PhaseIdealLoop::clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred) {\n@@ -321,3 +331,3 @@\n-    iffast = clone_predicate_to_unswitched_loop(predicate_proj, iffast, Deoptimization::Reason_predicate);\n-    ifslow = clone_predicate_to_unswitched_loop(predicate_proj, ifslow, Deoptimization::Reason_predicate);\n-    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, predicate_proj, iffast, ifslow);\n+    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate);\n+    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, predicate_proj, iffast_pred, ifslow_pred);\n@@ -325,2 +335,2 @@\n-    check_created_predicate_for_unswitching(iffast);\n-    check_created_predicate_for_unswitching(ifslow);\n+    check_created_predicate_for_unswitching(iffast_pred);\n+    check_created_predicate_for_unswitching(ifslow_pred);\n@@ -330,3 +340,3 @@\n-    iffast = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast, Deoptimization::Reason_profile_predicate);\n-    ifslow = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow, Deoptimization::Reason_profile_predicate);\n-    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_profile_predicate, profile_predicate_proj, iffast, ifslow);\n+    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred, Deoptimization::Reason_profile_predicate);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred, Deoptimization::Reason_profile_predicate);\n+    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_profile_predicate, profile_predicate_proj, iffast_pred, ifslow_pred);\n@@ -334,2 +344,2 @@\n-    check_created_predicate_for_unswitching(iffast);\n-    check_created_predicate_for_unswitching(ifslow);\n+    check_created_predicate_for_unswitching(iffast_pred);\n+    check_created_predicate_for_unswitching(ifslow_pred);\n@@ -341,2 +351,2 @@\n-    iffast = clone_predicate_to_unswitched_loop(limit_check_proj, iffast, Deoptimization::Reason_loop_limit_check);\n-    ifslow = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow, Deoptimization::Reason_loop_limit_check);\n+    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred, Deoptimization::Reason_loop_limit_check);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred, Deoptimization::Reason_loop_limit_check);\n@@ -344,2 +354,2 @@\n-    check_created_predicate_for_unswitching(iffast);\n-    check_created_predicate_for_unswitching(ifslow);\n+    check_created_predicate_for_unswitching(iffast_pred);\n+    check_created_predicate_for_unswitching(ifslow_pred);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1258,1 +1258,1 @@\n-        prev_proj = clone_skeleton_predicate(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_loop(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n@@ -1261,1 +1261,1 @@\n-        prev_proj = clone_skeleton_predicate(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n@@ -1335,2 +1335,5 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                               Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj) {\n+\/\/ Clone the skeleton predicate bool for a main or unswitched loop:\n+\/\/ Main loop: Set new_init and new_stride nodes as new inputs.\n+\/\/ Unswitched loop: new_init and new_stride are both NULL. Clone OpaqueLoopInit and OpaqueLoopStride instead.\n+Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                    Node* control, IdealLoopTree* outer_loop) {\n@@ -1341,0 +1344,2 @@\n+  bool is_unswitched_loop = new_init == NULL && new_stride == NULL;\n+  assert(new_init != NULL || is_unswitched_loop, \"new_init must be set when new_stride is non-null\");\n@@ -1352,2 +1357,2 @@\n-        to_clone.push(m, 1);\n-        continue;\n+      to_clone.push(m, 1);\n+      continue;\n@@ -1358,1 +1363,1 @@\n-        register_new_node(n, current_proj);\n+        register_new_node(n, control);\n@@ -1361,0 +1366,4 @@\n+        if (is_unswitched_loop && m->_idx < current && new_init == NULL) {\n+          new_init = m->clone();\n+          register_new_node(new_init, control);\n+        }\n@@ -1364,0 +1373,4 @@\n+        if (is_unswitched_loop && m->_idx < current && new_stride == NULL) {\n+          new_stride = m->clone();\n+          register_new_node(new_stride, control);\n+        }\n@@ -1370,1 +1383,1 @@\n-    for (;;) {\n+    while (true) {\n@@ -1388,1 +1401,1 @@\n-          register_new_node(next, current_proj);\n+          register_new_node(next, control);\n@@ -1396,0 +1409,3 @@\n+  assert(!is_unswitched_loop || new_init != NULL, \"new_init must always be found and cloned\");\n+  return result;\n+}\n@@ -1397,0 +1413,5 @@\n+\/\/ Clone a skeleton predicate for the main loop. new_init and new_stride are set as new inputs. Since the predicates cannot fail at runtime,\n+\/\/ Halt nodes are inserted instead of uncommon traps.\n+Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                             Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, predicate, uncommon_proj, control, outer_loop);\n@@ -1403,1 +1424,1 @@\n-  Node *frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n+  Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n@@ -1408,1 +1429,1 @@\n-  new_iff->set_req(0, prev_proj);\n+  new_iff->set_req(0, input_proj);\n@@ -1410,1 +1431,1 @@\n-  register_control(new_iff, outer_loop->_parent, prev_proj);\n+  register_control(new_iff, outer_loop->_parent, input_proj);\n@@ -1906,1 +1927,1 @@\n-        prev_proj = clone_skeleton_predicate(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -799,2 +799,4 @@\n-  Node* clone_skeleton_predicate(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                 Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj);\n+  Node* clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                               IdealLoopTree* outer_loop, Node* input_proj);\n+  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                      IdealLoopTree* outer_loop);\n@@ -1452,1 +1454,1 @@\n-  void clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast, ProjNode*& ifslow);\n+  void clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred);\n@@ -1455,1 +1457,3 @@\n-                                      ProjNode* old_predicate_proj, ProjNode* iffast, ProjNode* ifslow);\n+                                                    ProjNode* old_predicate_proj, ProjNode* iffast_pred, ProjNode* ifslow_pred);\n+  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj, Deoptimization::DeoptReason reason,\n+                                                          ProjNode* output_proj, IdealLoopTree* loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253644\n+ * @summary Test the complete cloning of skeleton predicates to unswitched loops as done when cloning them to the main loop.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchCloneSkeletonPredicates::*\n+ *                   compiler.loopopts.TestUnswitchCloneSkeletonPredicates\n+ * @run main\/othervm -Xcomp -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchCloneSkeletonPredicates::*\n+ *                   compiler.loopopts.TestUnswitchCloneSkeletonPredicates\n+ * @run main\/othervm -XX:-PartialPeelLoop compiler.loopopts.TestUnswitchCloneSkeletonPredicates\n+ *\/\n+package compiler.loopopts;\n+\n+public class TestUnswitchCloneSkeletonPredicates {\n+\n+    static int x = 0;\n+    static int y = 20;\n+    static int intArr[] = new int[21000];\n+    static int idx = 0;\n+    static boolean bFld = true;\n+    static int iFld = 20;\n+    static int iFld2 = 0 ;\n+    static int iArrFld[] = new int[50];\n+    static float fArrFld[] = new float[50];\n+\n+\n+    \/\/ Only triggers with -XX:-PartialPeelLoop\n+    \/*\n+     * The inner loop is unswitched on (1) which creates a fast and a slow loop that both have (1) removed and instead\n+     * (1) is executed before the loop at (3). With the SplitIf optimization we find that (3) dominates (2) in both loops.\n+     *\n+     * As a result, we can remove (2) from both loops. This, however, has an influence on how the loop tree is built.\n+     * Before the SplitIf optimization, the loop tree looks like this:\n+     * Loop: N0\/N0  has_sfpt\n+     *   Loop: N338\/N314  limit_check profile_predicated predicated counted [0,100),+1 (2 iters)  has_sfpt\n+     *     Loop: N459\/N458  profile_predicated predicated counted [0,10000),+1 (5271 iters)  has_sfpt (slow loop)\n+     *     Loop: N343\/N267  profile_predicated predicated counted [0,10000),+1 (5271 iters)  has_sfpt (fast loop)\n+     *\n+     * Both unswitched loop have a copy of the skeleton predicate If node that share the same Opaque4 node with its inputs.\n+     * The inner loop is never exited normally due to always returning on (4). This means that the branch that exits the\n+     * loop on the loop limit check is never taken and has an uncommon trap. Nevertheless, the loop building algorithm still\n+     * identifies the fast and the slow loop as children of N338 because of the condition (2) over which the loop is left.\n+     * However, after the above mentioned SplitIf optimization the condition (2) is removed from both loops. As a result,\n+     * the slow loops (N459) is always exited immediately (x == 100 holds) because the break is executed on the first\n+     * iteration of the loop. The loop can be removed (but these nodes are still part of the parent loop N338). The fast loop\n+     * (N343), however, is now never exited normally and always returns on the 9800th iteration over (4). The normal loop exit\n+     * over the loop limit check is never taken (uncommon trap). Due to the last loop exit (2) being removed, N343 is no longer\n+     * recognized as a child loop of N338 due to not having a backedge to the parent loop. The loop tree looks like this:\n+     * Loop: N0\/N0  has_sfpt\n+     *   Loop: N338\/N314  limit_check profile_predicated predicated counted [0,100),+1 (2 iters)  has_sfpt\n+     *   Loop: N343\/N267  profile_predicated predicated counted [0,10000),+1 (5274 iters)  has_sfpt\n+     *\n+     * As a next step, the original parent loop N338 is peeled. The fast and the slow loop still both share skeleton Opaque4 bool\n+     * nodes with all its inputs nodes up to and including the OpaqueLoopInit\/Stride nodes. These skeleton predicates are still there\n+     * even though the slow loop N459 could have been removed (the Opaque4 nodes are only removed after loop opts). Let's look at one\n+     * of the skeleton If nodes for the fast loop that uses such a Opaque4 node. The skeleton 'If' is no longer part of the original\n+     * parent loop and is therefore not peeled. But now we need some phi nodes to select the correct nodes either from the peeled\n+     * iteration or from N338 for this skeleton If of the fast loop. This is done in PhaseIdealLoop::clone_iff() which creates\n+     * a new Opaque4 node together with new Bool and Cmp nodes and then inserts some phi nodes to do the selection.\n+     *\n+     * When afterwards creating pre\/main\/post loops for the fast loop (N343) that is no child anymore, we find these phi nodes on the\n+     * path to the OpaqueLoopInit\/Stride nodes which lets the assertion PhaseIdealLoop::skeleton_predicate_has_opaque() fail. These\n+     * phi nodes on the path to the OpaqueLoopInit\/Stride nodes are unexpected.\n+     *\n+     * The solution to this problem is to clone the skeleton predicates completely, including clones of all nodes up to and including\n+     * the OpaqueLoopInit\/Stride nodes (similar to what is done when copying skeleton predicates to the main loop) instead of just\n+     * sharing Opaque4 nodes.\n+     *\/\n+    public static int test1() {\n+      int i = 0;\n+      while (i < 100) {\n+          int j = 0;\n+          \/\/ (3) <new unswitch condition>\n+          while (j < 10000)  {\n+              if (x == 100) { \/\/ (1) Loop is unswitched on this condition -> condition shared with (2)\n+                  y = 34;\n+              }\n+\n+              intArr[idx] = 34;\n+              intArr[2*j + 35] = 45;\n+\n+              if (x == 100) { \/\/ (2)\n+                  y = 35;\n+                  break;\n+              }\n+              if (j == 9800) { \/\/ (4)\n+                  return 2;\n+              }\n+              j++;\n+          }\n+          i++;\n+          intArr[i] = 45;\n+      }\n+      return y;\n+    }\n+\n+    \/\/ Only triggers with -XX:-PartialPeelLoop\n+    public static int test2() {\n+      int i = 0;\n+      while (i < 100) {\n+          int j = 0;\n+          while (j < 10000)  {\n+              if (x == 100) {\n+                  y = 34;\n+              }\n+\n+              intArr[2*j + 35] = 45;\n+\n+              if (x == 100) {\n+                  y = 35;\n+                  break;\n+              }\n+              if (j == 9800) {\n+                  return 2;\n+              }\n+              j++;\n+          }\n+          i++;\n+          intArr[i] = 45;\n+      }\n+      return y;\n+    }\n+\n+    \/\/ Only triggers with -XX:-PartialPeelLoop\n+    public static int test3() {\n+      int i = 0;\n+      while (i < 100) {\n+          int j = 0;\n+          while (j < 10000)  {\n+              if (x == 100) {\n+                  y = 34;\n+              }\n+\n+              intArr[idx] = 34;\n+              intArr[2*j + 35] = 45;\n+\n+              if (x == 100) {\n+                  y = 35;\n+                  break;\n+              }\n+              if (j == 9800) {\n+                  return 2;\n+              }\n+              j++;\n+          }\n+          i++;\n+      }\n+      return y;\n+}\n+\n+    \/\/ Test that has two loop headers for a single loop (limitation of type flow, see JDK-8255663)\n+    \/\/ which also triggers the assertion failure of this bug.\n+    public static void test4() {\n+        int unused = 500; \/\/ Required, even though unused\n+        boolean b = true;\n+        int i = 1;\n+        while (++i < 35) {\n+            iArrFld[i] = 6;\n+            switch (iFld2) {\n+            case 40:\n+                if (b) {\n+                    continue;\n+                }\n+                b = false;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that has two loop headers for a single loop (limitation of type flow, see JDK-8255663)\n+    \/\/ which also triggers the assertion failure of this bug. Only triggers with -XX:-PartialPeelLoop.\n+    public static void test5() {\n+        int j = 50;\n+        int i = 1;\n+        while (++i < 40) {\n+            j = 5;\n+            do {\n+                fArrFld[i] = 46;\n+                iFld = 5;\n+                if (bFld) break;\n+            } while (++j < 5);\n+            j = 2;\n+            do {\n+                try {\n+                    iFld = 56;\n+                } catch (ArithmeticException a_e) {}\n+                if (bFld) break;\n+            } while (++j < 2);\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 5000; i++) {\n+            test1();\n+            x++;\n+            x = x % 106;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnswitchCloneSkeletonPredicates.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"}]}