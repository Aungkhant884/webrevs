{"files":[{"patch":"@@ -138,2 +138,0 @@\n-  bool must_assert_null = false;\n-\n@@ -148,1 +146,0 @@\n-      must_assert_null = true;\n@@ -174,24 +171,0 @@\n-\n-  if (must_assert_null) {\n-    \/\/ Do not take a trap here.  It's possible that the program\n-    \/\/ will never load the field's class, and will happily see\n-    \/\/ null values in this field forever.  Don't stumble into a\n-    \/\/ trap for such a program, or we might get a long series\n-    \/\/ of useless recompilations.  (Or, we might load a class\n-    \/\/ which should not be loaded.)  If we ever see a non-null\n-    \/\/ value, we will then trap and recompile.  (The trap will\n-    \/\/ not need to mention the class index, since the class will\n-    \/\/ already have been loaded if we ever see a non-null value.)\n-    \/\/ uncommon_trap(iter().get_field_signature_index());\n-    if (PrintOpto && (Verbose || WizardMode)) {\n-      method()->print_name(); tty->print_cr(\" asserting nullness of field at bci: %d\", bci());\n-    }\n-    if (C->log() != NULL) {\n-      C->log()->elem(\"assert_null reason='field' klass='%d'\",\n-                     C->log()->identify(field->type()));\n-    }\n-    \/\/ If there is going to be a trap, put it at the next bytecode:\n-    set_bci(iter().next_bci());\n-    null_assert(peek());\n-    set_bci(iter().cur_bci()); \/\/ put it back\n-  }\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"}]}