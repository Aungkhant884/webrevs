{"files":[{"patch":"@@ -232,0 +232,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3422,1 +3422,1 @@\n-      (CheckIntrinsics ? callee->intrinsic_candidate() : true)) {\n+      callee->check_intrinsic_candidate()) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3205,0 +3205,4 @@\n+  case vmIntrinsics::_blackhole:\n+    do_blackhole(x);\n+    break;\n+\n@@ -3624,0 +3628,9 @@\n+void LIRGenerator::do_blackhole(Intrinsic *x) {\n+  assert(!x->has_receiver(), \"Should have been checked before: only static methods here\");\n+  for (int c = 0; c < x->number_of_arguments(); c++) {\n+    \/\/ Load the argument\n+    LIRItem vitem(x->argument_at(c), this);\n+    vitem.load_item();\n+    \/\/ ...and leave it unused.\n+  }\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,0 +268,1 @@\n+  void do_blackhole(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -157,0 +157,2 @@\n+\n+  CompilerOracle::tag_blackhole_if_possible(h_m);\n@@ -1215,0 +1217,1 @@\n+bool ciMethod::is_empty       () const {         FETCH_FLAG_FROM_VM(is_empty_method); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,0 +207,9 @@\n+  bool check_intrinsic_candidate() const {\n+    if (intrinsic_id() == vmIntrinsics::_blackhole) {\n+      \/\/ This is the intrinsic without an associated method, so no intrinsic_candidate\n+      \/\/ flag is set. The intrinsic is still correct.\n+      return true;\n+    }\n+    return (CheckIntrinsics ? intrinsic_candidate() : true);\n+  }\n+\n@@ -349,0 +358,1 @@\n+  bool is_empty       () const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5308,0 +5308,5 @@\n+        if (vmIntrinsics::_blackhole == id) {\n+          \/\/ The _blackhole intrinsic is a special marker. No explicit method\n+          \/\/ is defined for it.\n+          continue;\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+  case vmIntrinsics::_blackhole:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -537,0 +537,3 @@\n+  \/* special marker for blackholed methods: *\/                                                                          \\\n+  do_intrinsic(_blackhole,                java_lang_Object,       blackhole_name, star_name, F_S)                       \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -286,0 +286,1 @@\n+  template(blackhole_name,                            \"<blackhole>\")  \/*fake name*\/               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,0 +309,5 @@\n+  if (option == CompileCommand::Blackhole && !UnlockExperimentalVMOptions) {\n+    warning(\"Blackhole compile option is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions\");\n+    return;\n+  }\n+\n@@ -420,0 +425,31 @@\n+void CompilerOracle::tag_blackhole_if_possible(const methodHandle& method) {\n+  if (!check_predicate(CompileCommand::Blackhole, method)) {\n+    return;\n+  }\n+  guarantee(UnlockExperimentalVMOptions, \"Checked during initial parsing\");\n+  if (method->result_type() != T_VOID) {\n+    warning(\"Blackhole compile option only works for methods with void type: %s\",\n+            method->name_and_sig_as_C_string());\n+    return;\n+  }\n+  if (!method->is_empty_method()) {\n+    warning(\"Blackhole compile option only works for empty methods: %s\",\n+            method->name_and_sig_as_C_string());\n+    return;\n+  }\n+  if (!method->is_static()) {\n+    warning(\"Blackhole compile option only works for static methods: %s\",\n+            method->name_and_sig_as_C_string());\n+    return;\n+  }\n+  if (method->intrinsic_id() == vmIntrinsics::_blackhole) {\n+    return;\n+  }\n+  if (method->intrinsic_id() != vmIntrinsics::_none) {\n+    warning(\"Blackhole compile option only works for methods that do not have intrinsic set: %s, %s\",\n+            method->name_and_sig_as_C_string(), vmIntrinsics::name_at(method->intrinsic_id()));\n+    return;\n+  }\n+  method->set_intrinsic_id(vmIntrinsics::_blackhole);\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+  option(Blackhole,  \"blackhole\", Bool) \\\n@@ -147,0 +148,3 @@\n+  \/\/ Tags the method as blackhole candidate, if possible.\n+  static void tag_blackhole_if_possible(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -1040,0 +1041,1 @@\n+    CompilerOracle::tag_blackhole_if_possible(method);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -680,0 +680,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+macro(Blackhole)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3586,0 +3586,2 @@\n+  case Op_Blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  if ((CheckIntrinsics ? callee->intrinsic_candidate() : true) &&\n+  if (callee->check_intrinsic_candidate() &&\n@@ -672,0 +672,3 @@\n+  case vmIntrinsics::_blackhole:\n+    return inline_blackhole();\n+\n@@ -6914,0 +6917,20 @@\n+\n+\/\/------------------------------- inline_blackhole --------------------------------------\n+\/\/\n+\/\/ Make sure all arguments to this node are alive.\n+\/\/ This matches methods that were requested to be blackholed through compile commands.\n+\/\/\n+bool LibraryCallKit::inline_blackhole() {\n+  assert(callee()->is_static(), \"Should have been checked before: only static methods here\");\n+  assert(callee()->is_empty(), \"Should have been checked before: only empty methods here\");\n+  assert(callee()->holder()->is_loaded(), \"Should have been checked before: only methods for loaded classes here\");\n+\n+  \/\/ Bind call arguments as blackhole arguments to keep them alive\n+  Node* bh = insert_mem_bar(Op_Blackhole);\n+  uint nargs = callee()->arg_size();\n+  for (uint i = 0; i < nargs; i++) {\n+    bh->add_req(argument(i));\n+  }\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -347,0 +347,2 @@\n+\n+  bool inline_blackhole();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"opto\/regalloc.hpp\"\n@@ -3295,0 +3296,1 @@\n+  case Op_Blackhole:         return new BlackholeNode(C, atp, pn);\n@@ -3529,0 +3531,21 @@\n+#ifndef PRODUCT\n+void BlackholeNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n+  st->print(\"blackhole \");\n+  bool first = true;\n+  for (uint i = 0; i < req(); i++) {\n+    Node* n = in(i);\n+    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        st->print(\", \");\n+      }\n+      char buf[128];\n+      ra->dump_register(n, buf);\n+      st->print(\"%s\", buf);\n+    }\n+  }\n+  st->cr();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1340,0 +1340,20 @@\n+\/\/------------------------------BlackholeNode----------------------------\n+\/\/ Blackhole all arguments. This node would survive through the compiler\n+\/\/ the effects on its arguments, and would be finally matched to nothing.\n+class BlackholeNode : public MemBarNode {\n+public:\n+  BlackholeNode(Compile* C, int alias_idx, Node* precedent)\n+    : MemBarNode(C, alias_idx, precedent) {}\n+  virtual int   Opcode() const;\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  const RegMask &in_RegMask(uint idx) const {\n+    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n+    \/\/ and all stack slots. This would avoid any redundant register moves\n+    \/\/ for blackhole inputs.\n+    return RegMask::All;\n+  }\n+#ifndef PRODUCT\n+  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class BlackholeNode;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,7 @@\n+const RegMask RegMask::All(\n+# define BODY(I) -1,\n+  FORALL_BODY\n+# undef BODY\n+  0\n+);\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+  static const RegMask All;     \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1601,0 +1601,1 @@\n+  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+  compiler\/blackhole\/ \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeExistingIntrinsicWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeExistingIntrinsicWarningTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG =\n+        \"Blackhole compile option only works for methods that do not have intrinsic set: java.lang.Thread.onSpinWait()V, _onSpinWait\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeExistingIntrinsicWarningTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Should print the warning\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,java\/lang\/Thread.onSpinWait\"\n+        );\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,java\/lang\/Thread.onSpinWait,Blackhole\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,java\/lang\/Thread.onSpinWait\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,java\/lang\/Thread.onSpinWait,Blackhole\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeExistingIntrinsicWarningTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeExperimentalUnlockTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeExperimentalUnlockTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG = \"Blackhole compile option is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeExperimentalUnlockTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Option is disabled by default, should fail:\n+        shouldFail(\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+        shouldFail(\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+\n+        \/\/ Option should be enabled by UnlockExperimentalVMOptions\n+        shouldPass(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+        shouldPass(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1(c);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeExperimentalUnlockTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeIntrinsicTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeIntrinsicTest {\n+\n+    private static final Map<String, Runnable> TESTS;\n+\n+    static {\n+        TESTS = new LinkedHashMap<>();\n+        TESTS.put(\"bh_s_boolean_0\", BlackholeIntrinsicTest::test_boolean_0);\n+        TESTS.put(\"bh_s_byte_0\",    BlackholeIntrinsicTest::test_byte_0);\n+        TESTS.put(\"bh_s_char_0\",    BlackholeIntrinsicTest::test_char_0);\n+        TESTS.put(\"bh_s_short_0\",   BlackholeIntrinsicTest::test_short_0);\n+        TESTS.put(\"bh_s_int_0\",     BlackholeIntrinsicTest::test_int_0);\n+        TESTS.put(\"bh_s_float_0\",   BlackholeIntrinsicTest::test_float_0);\n+        TESTS.put(\"bh_s_long_0\",    BlackholeIntrinsicTest::test_long_0);\n+        TESTS.put(\"bh_s_double_0\",  BlackholeIntrinsicTest::test_double_0);\n+        TESTS.put(\"bh_s_Object_0\",  BlackholeIntrinsicTest::test_Object_0);\n+\n+        TESTS.put(\"bh_s_boolean_1\", BlackholeIntrinsicTest::test_boolean_1);\n+        TESTS.put(\"bh_s_byte_1\",    BlackholeIntrinsicTest::test_byte_1);\n+        TESTS.put(\"bh_s_char_1\",    BlackholeIntrinsicTest::test_char_1);\n+        TESTS.put(\"bh_s_short_1\",   BlackholeIntrinsicTest::test_short_1);\n+        TESTS.put(\"bh_s_int_1\",     BlackholeIntrinsicTest::test_int_1);\n+        TESTS.put(\"bh_s_float_1\",   BlackholeIntrinsicTest::test_float_1);\n+        TESTS.put(\"bh_s_long_1\",    BlackholeIntrinsicTest::test_long_1);\n+        TESTS.put(\"bh_s_double_1\",  BlackholeIntrinsicTest::test_double_1);\n+        TESTS.put(\"bh_s_Object_1\",  BlackholeIntrinsicTest::test_Object_1);\n+\n+        TESTS.put(\"bh_s_boolean_2\", BlackholeIntrinsicTest::test_boolean_2);\n+        TESTS.put(\"bh_s_byte_2\",    BlackholeIntrinsicTest::test_byte_2);\n+        TESTS.put(\"bh_s_char_2\",    BlackholeIntrinsicTest::test_char_2);\n+        TESTS.put(\"bh_s_short_2\",   BlackholeIntrinsicTest::test_short_2);\n+        TESTS.put(\"bh_s_int_2\",     BlackholeIntrinsicTest::test_int_2);\n+        TESTS.put(\"bh_s_float_2\",   BlackholeIntrinsicTest::test_float_2);\n+        TESTS.put(\"bh_s_long_2\",    BlackholeIntrinsicTest::test_long_2);\n+        TESTS.put(\"bh_s_double_2\",  BlackholeIntrinsicTest::test_double_2);\n+        TESTS.put(\"bh_s_Object_2\",  BlackholeIntrinsicTest::test_Object_2);\n+    }\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            test(args[0]);\n+        }\n+    }\n+\n+    public static void driver() throws IOException {\n+        for (String test : TESTS.keySet()) {\n+            check(test, \"-XX:TieredStopAtLevel=1\");\n+            check(test, \"-XX:-TieredCompilation\");\n+            if (Platform.is64bit()) {\n+                check(test, \"-XX:-UseCompressedOops\", \"-XX:TieredStopAtLevel=1\");\n+                check(test, \"-XX:-UseCompressedOops\", \"-XX:-TieredCompilation\");\n+            }\n+        }\n+    }\n+\n+    private static void test(String test) {\n+        Runnable r = TESTS.get(test);\n+        if (r == null) {\n+           throw new IllegalArgumentException(\"Cannot find test \" + test);\n+        }\n+        for (int t = 0; t < TRIES; t++) {\n+            r.run();\n+        }\n+    }\n+\n+    public static void check(String test, String... args) throws IOException {\n+        List<String> cmdline = new ArrayList();\n+        cmdline.add(\"-Xmx128m\");\n+        cmdline.add(\"-Xbatch\");\n+        cmdline.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        cmdline.add(\"-XX:+AbortVMOnCompilationFailure\");\n+        cmdline.add(\"-XX:+PrintCompilation\");\n+        cmdline.add(\"-XX:+PrintInlining\");\n+        cmdline.add(\"-XX:+UnlockExperimentalVMOptions\");\n+        cmdline.add(\"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\");\n+        cmdline.addAll(Arrays.asList(args));\n+        cmdline.add(\"compiler.blackhole.BlackholeIntrinsicTest\");\n+        cmdline.add(test);\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.stderrShouldBeEmpty();\n+        output.stdoutShouldMatch(\"compiler.blackhole.BlackholeTarget::\" + test + \".*intrinsic.*\");\n+    }\n+\n+    private static void test_boolean_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_0();\n+        }\n+    }\n+\n+    private static void test_byte_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_0();\n+        }\n+    }\n+\n+    private static void test_char_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_0();\n+        }\n+    }\n+\n+    private static void test_short_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_0();\n+        }\n+    }\n+\n+    private static void test_int_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_0();\n+        }\n+    }\n+\n+    private static void test_float_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_0();\n+        }\n+    }\n+\n+    private static void test_long_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_0();\n+        }\n+    }\n+\n+    private static void test_double_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_0();\n+        }\n+    }\n+\n+    private static void test_Object_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_Object_0();\n+        }\n+    }\n+\n+    private static void test_boolean_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_1((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_1((byte)c);\n+        }\n+    }\n+\n+    private static void test_char_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_1((char)c);\n+        }\n+    }\n+\n+    private static void test_short_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_1((short)c);\n+        }\n+    }\n+\n+    private static void test_int_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1(c);\n+        }\n+    }\n+\n+    private static void test_float_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_1(c);\n+        }\n+    }\n+\n+    private static void test_long_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_1(c);\n+        }\n+    }\n+\n+    private static void test_double_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_1(c);\n+        }\n+    }\n+\n+    private static void test_Object_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            BlackholeTarget.bh_s_Object_1(o);\n+        }\n+    }\n+\n+    private static void test_boolean_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n+        }\n+    }\n+\n+    private static void test_byte_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_2((byte)c, (byte)(c + 1));\n+        }\n+    }\n+\n+    private static void test_char_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_2((char)c, (char)(c + 1));\n+        }\n+    }\n+\n+    private static void test_short_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_2((short)c, (short)(c + 1));\n+        }\n+    }\n+\n+    private static void test_int_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_float_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_long_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_double_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_Object_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            BlackholeTarget.bh_s_Object_2(o1, o2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeIntrinsicTest.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeNonEmptyWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonEmptyWarningTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG = \"Blackhole compile option only works for empty methods: compiler.blackhole.BlackholeTarget.bh_s_int_1_delegate(I)V\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeNonEmptyWarningTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Should print the warning\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1_delegate(c);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonEmptyWarningTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeNonStaticWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonStaticWarningTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG = \"Blackhole compile option only works for static methods: compiler.blackhole.BlackholeTarget.bh_i_int_0()V\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeNonStaticWarningTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Should print the warning\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int_0();\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonStaticWarningTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeNonVoidWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonVoidWarningTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG = \"Blackhole compile option only works for methods with void type: compiler.blackhole.BlackholeTarget.bh_sr_int(I)I\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeNonVoidWarningTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Should print the warning\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonVoidWarningTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.lang.reflect.*;\n+\n+public class BlackholeTarget {\n+    public void call_for_null_check() {}\n+\n+    public        void    bh_i_boolean_0()           {}\n+    public        void    bh_i_byte_0()              {}\n+    public        void    bh_i_short_0()             {}\n+    public        void    bh_i_char_0()              {}\n+    public        void    bh_i_int_0()               {}\n+    public        void    bh_i_float_0()             {}\n+    public        void    bh_i_long_0()              {}\n+    public        void    bh_i_double_0()            {}\n+    public        void    bh_i_Object_0()            {}\n+\n+    public static void    bh_s_boolean_0()           {}\n+    public static void    bh_s_byte_0()              {}\n+    public static void    bh_s_short_0()             {}\n+    public static void    bh_s_char_0()              {}\n+    public static void    bh_s_int_0()               {}\n+    public static void    bh_s_float_0()             {}\n+    public static void    bh_s_long_0()              {}\n+    public static void    bh_s_double_0()            {}\n+    public static void    bh_s_Object_0()            {}\n+\n+    public static void    bh_s_boolean_1(boolean v)  {}\n+    public static void    bh_s_byte_1(byte v)        {}\n+    public static void    bh_s_short_1(short v)      {}\n+    public static void    bh_s_char_1(char v)        {}\n+    public static void    bh_s_int_1(int v)          {}\n+    public static void    bh_s_float_1(float v)      {}\n+    public static void    bh_s_long_1(long v)        {}\n+    public static void    bh_s_double_1(double v)    {}\n+    public static void    bh_s_Object_1(Object v)    {}\n+\n+    public static void    bh_s_boolean_1_delegate(boolean v)  { bh_s_boolean_1(v); }\n+    public static void    bh_s_byte_1_delegate(byte v)        { bh_s_byte_1(v);    }\n+    public static void    bh_s_short_1_delegate(short v)      { bh_s_short_1(v);   }\n+    public static void    bh_s_char_1_delegate(char v)        { bh_s_char_1(v);    }\n+    public static void    bh_s_int_1_delegate(int v)          { bh_s_int_1(v);     }\n+    public static void    bh_s_float_1_delegate(float v)      { bh_s_float_1(v);   }\n+    public static void    bh_s_long_1_delegate(long v)        { bh_s_long_1(v);    }\n+    public static void    bh_s_double_1_delegate(double v)    { bh_s_double_1(v);  }\n+    public static void    bh_s_Object_1_delegate(Object v)    { bh_s_Object_1(v);  }\n+\n+    public static void    bh_s_boolean_2(boolean v1, boolean v2) {}\n+    public static void    bh_s_byte_2(byte v1, byte v2)          {}\n+    public static void    bh_s_short_2(short v1, short v2)       {}\n+    public static void    bh_s_char_2(char v1, char v2)          {}\n+    public static void    bh_s_int_2(int v1, int v2)             {}\n+    public static void    bh_s_float_2(float v1, float v2)       {}\n+    public static void    bh_s_long_2(long v1, long v2)          {}\n+    public static void    bh_s_double_2(double v1, double v2)    {}\n+    public static void    bh_s_Object_2(Object v1, Object v2)    {}\n+\n+    public static boolean bh_sr_boolean(boolean v) { return false; }\n+    public static byte    bh_sr_byte(byte v)       { return 0;     }\n+    public static short   bh_sr_short(short v)     { return 0;     }\n+    public static char    bh_sr_char(char v)       { return 0;     }\n+    public static int     bh_sr_int(int v)         { return 0;     }\n+    public static float   bh_sr_float(float v)     { return 0;     }\n+    public static long    bh_sr_long(long v)       { return 0;     }\n+    public static double  bh_sr_double(double v)   { return 0;     }\n+    public static Object  bh_sr_Object(Object v)   { return null;  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}