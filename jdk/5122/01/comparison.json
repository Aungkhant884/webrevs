{"files":[{"patch":"@@ -3945,1 +3945,1 @@\n-    r->clear_young_index_in_cset();\n+    r->clear_index_in_cset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  hr->set_index_in_opt_cset(_num_optional_regions++);\n+  hr->set_index_in_cset(_num_optional_regions++);\n@@ -330,1 +330,1 @@\n-  hr->set_young_index_in_cset((uint)_collection_set_cur_length + 1);\n+  hr->set_index_in_cset((uint)_collection_set_cur_length + 1);\n@@ -548,1 +548,1 @@\n-    r->clear_index_in_opt_cset();\n+    r->clear_index_in_cset();\n@@ -572,1 +572,1 @@\n-    const uint idx = r->young_index_in_cset();\n+    const uint idx = r->index_in_cset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -238,1 +238,3 @@\n-      hr->clear_index_in_opt_cset();\n+      if (hr->is_old()) {\n+        hr->clear_index_in_cset();\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-    guarantee(!r->has_index_in_opt_cset(), \"Region %u still has opt collection set index %u\", r->hrm_index(), r->index_in_opt_cset());\n+    guarantee(!r->has_index_in_opt_cset(), \"Region %u still has opt collection set index %u\", r->hrm_index(), r->index_in_cset());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -474,3 +474,1 @@\n-      const uint young_index = from_region->young_index_in_cset();\n-      assert((from_region->is_young() && young_index >  0) ||\n-             (!from_region->is_young() && young_index == 0), \"invariant\" );\n+      const uint young_index = from_region->is_young() ? from_region->index_in_cset() : 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,2 @@\n-  uint index = _g1h->heap_region_containing(o)->index_in_opt_cset();\n+  assert(_g1h->heap_region_containing(o)->has_index_in_opt_cset(), \"Precondition!\");\n+  uint index = _g1h->heap_region_containing(o)->index_in_cset();\n@@ -84,1 +85,2 @@\n-  uint index = _g1h->heap_region_containing(o)->index_in_opt_cset();\n+  assert(_g1h->heap_region_containing(o)->has_index_in_opt_cset(), \"Precondition!\");\n+  uint index = _g1h->heap_region_containing(o)->index_in_cset();\n@@ -92,1 +94,1 @@\n-  assert(hr->index_in_opt_cset() < _num_optional_regions,\n+  assert(hr->index_in_cset() < _num_optional_regions,\n@@ -94,2 +96,2 @@\n-         hr->index_in_opt_cset(), _num_optional_regions, HR_FORMAT_PARAMS(hr));\n-  return &_oops_into_optional_regions[hr->index_in_opt_cset()];\n+         hr->index_in_cset(), _num_optional_regions, HR_FORMAT_PARAMS(hr));\n+  return &_oops_into_optional_regions[hr->index_in_cset()];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -466,2 +466,2 @@\n-    assert(r->young_index_in_cset() != 0 &&\n-           (uint)r->young_index_in_cset() <= _g1h->collection_set()->young_region_length(),\n+    assert(r->index_in_cset() != 0 &&\n+           (uint)r->index_in_cset() <= _g1h->collection_set()->young_region_length(),\n@@ -469,1 +469,1 @@\n-           r->young_index_in_cset(), r->hrm_index(), r->get_type_str(), _g1h->collection_set()->young_region_length());\n+           r->index_in_cset(), r->hrm_index(), r->get_type_str(), _g1h->collection_set()->young_region_length());\n@@ -524,1 +524,1 @@\n-      r->record_surv_words_in_group(_surviving_young_words[r->young_index_in_cset()]);\n+      r->record_surv_words_in_group(_surviving_young_words[r->index_in_cset()]);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  clear_young_index_in_cset();\n+  clear_index_in_cset();\n@@ -121,2 +121,1 @@\n-  clear_young_index_in_cset();\n-  clear_index_in_opt_cset();\n+  clear_index_in_cset();\n@@ -242,1 +241,1 @@\n-  _index_in_opt_cset(InvalidCSetIndex),\n+  _index_in_cset(InvalidCSetIndex),\n@@ -249,1 +248,0 @@\n-  _young_index_in_cset(-1),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -217,3 +217,4 @@\n-  \/\/ The index in the optional regions array, if this region\n-  \/\/ is considered optional during a mixed collections.\n-  uint _index_in_opt_cset;\n+  \/\/ The index in a collection set: either the actual collection set for young\n+  \/\/ regions or the optional regions array if an old region is considered\n+  \/\/ optional during a mixed collections.\n+  uint _index_in_cset;\n@@ -250,1 +251,0 @@\n-  uint  _young_index_in_cset;\n@@ -513,3 +513,2 @@\n-  uint index_in_opt_cset() const {\n-    assert(has_index_in_opt_cset(), \"Opt cset index not set.\");\n-    return _index_in_opt_cset;\n+  bool has_index_in_opt_cset() const {\n+    return is_old() && _index_in_cset != InvalidCSetIndex;\n@@ -517,3 +516,0 @@\n-  bool has_index_in_opt_cset() const { return _index_in_opt_cset != InvalidCSetIndex; }\n-  void set_index_in_opt_cset(uint index) { _index_in_opt_cset = index; }\n-  void clear_index_in_opt_cset() { _index_in_opt_cset = InvalidCSetIndex; }\n@@ -524,7 +520,13 @@\n-  uint  young_index_in_cset() const { return _young_index_in_cset; }\n-  void clear_young_index_in_cset() { _young_index_in_cset = 0; }\n-  void set_young_index_in_cset(uint index) {\n-    assert(index != UINT_MAX, \"just checking\");\n-    assert(index != 0, \"just checking\");\n-    assert(is_young(), \"pre-condition\");\n-    _young_index_in_cset = index;\n+  \/\/ Returns the index in a collection set: either the actual collection set for\n+  \/\/ young regions or the optional regions array if an old region is considered\n+  \/\/ optional during a mixed collections.\n+  uint index_in_cset() const {\n+    return _index_in_cset;\n+  }\n+\n+  void clear_index_in_cset() {\n+    _index_in_cset = InvalidCSetIndex;\n+  }\n+\n+  void set_index_in_cset(uint index) {\n+    _index_in_cset = index;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"}]}