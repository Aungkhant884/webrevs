{"files":[{"patch":"@@ -149,1 +149,1 @@\n-  hr->set_index_in_opt_cset(_num_optional_regions++);\n+  hr->set_index_in_cset(_num_optional_regions++);\n@@ -330,1 +330,1 @@\n-  hr->set_young_index_in_cset((uint)_collection_set_cur_length + 1);\n+  hr->set_index_in_cset((uint)_collection_set_cur_length + 1);\n@@ -548,1 +548,1 @@\n-    r->clear_index_in_opt_cset();\n+    r->clear_index_in_cset();\n@@ -572,1 +572,1 @@\n-    const uint idx = r->young_index_in_cset();\n+    const uint idx = r->index_in_cset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -238,1 +238,3 @@\n-      hr->clear_index_in_opt_cset();\n+      if (hr->is_old()) {\n+        hr->clear_index_in_cset();\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-    guarantee(!r->has_index_in_opt_cset(), \"Region %u still has opt collection set index %u\", r->hrm_index(), r->index_in_opt_cset());\n+    guarantee(!r->has_index_in_opt_cset(), \"Region %u still has opt collection set index %u\", r->hrm_index(), r->index_in_cset());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -474,3 +474,1 @@\n-      const uint young_index = from_region->young_index_in_cset();\n-      assert((from_region->is_young() && young_index >  0) ||\n-             (!from_region->is_young() && young_index == 0), \"invariant\" );\n+      const uint young_index = from_region->is_young() ? from_region->index_in_cset() : 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,2 @@\n-  uint index = _g1h->heap_region_containing(o)->index_in_opt_cset();\n+  assert(_g1h->heap_region_containing(o)->has_index_in_opt_cset(), \"Precondition!\");\n+  uint index = _g1h->heap_region_containing(o)->index_in_cset();\n@@ -84,1 +85,2 @@\n-  uint index = _g1h->heap_region_containing(o)->index_in_opt_cset();\n+  assert(_g1h->heap_region_containing(o)->has_index_in_opt_cset(), \"Precondition!\");\n+  uint index = _g1h->heap_region_containing(o)->index_in_cset();\n@@ -92,1 +94,1 @@\n-  assert(hr->index_in_opt_cset() < _num_optional_regions,\n+  assert(hr->index_in_cset() < _num_optional_regions,\n@@ -94,2 +96,2 @@\n-         hr->index_in_opt_cset(), _num_optional_regions, HR_FORMAT_PARAMS(hr));\n-  return &_oops_into_optional_regions[hr->index_in_opt_cset()];\n+         hr->index_in_cset(), _num_optional_regions, HR_FORMAT_PARAMS(hr));\n+  return &_oops_into_optional_regions[hr->index_in_cset()];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -466,2 +466,2 @@\n-    assert(r->young_index_in_cset() != 0 &&\n-           (uint)r->young_index_in_cset() <= _g1h->collection_set()->young_region_length(),\n+    assert(r->index_in_cset() != 0 &&\n+           (uint)r->index_in_cset() <= _g1h->collection_set()->young_region_length(),\n@@ -469,1 +469,1 @@\n-           r->young_index_in_cset(), r->hrm_index(), r->get_type_str(), _g1h->collection_set()->young_region_length());\n+           r->index_in_cset(), r->hrm_index(), r->get_type_str(), _g1h->collection_set()->young_region_length());\n@@ -524,1 +524,1 @@\n-      r->record_surv_words_in_group(_surviving_young_words[r->young_index_in_cset()]);\n+      r->record_surv_words_in_group(_surviving_young_words[r->index_in_cset()]);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -217,2 +217,3 @@\n-  \/\/ The index in a collection set: either the actual collection set for young regions or the\n-  \/\/ optional regions array if this region is considered optional during a mixed collections.\n+  \/\/ The index in a collection set: either the actual collection set for young\n+  \/\/ regions or the optional regions array if an old region is considered\n+  \/\/ optional during a mixed collections.\n@@ -512,5 +513,0 @@\n-  uint index_in_opt_cset() const {\n-    assert(has_index_in_opt_cset(), \"Opt cset index not set.\");\n-    return _index_in_cset;\n-  }\n-\n@@ -521,7 +517,0 @@\n-  void set_index_in_opt_cset(uint index) {\n-    assert(is_old(), \"pre-condition\");\n-    set_index_in_cset(index);\n-  }\n-\n-  void clear_index_in_opt_cset();\n-\n@@ -531,2 +520,5 @@\n-  uint  young_index_in_cset() const {\n-    return is_old() ? 0 : _index_in_cset;\n+  \/\/ Returns the index in a collection set: either the actual collection set for\n+  \/\/ young regions or the optional regions array if an old region is considered\n+  \/\/ optional during a mixed collections.\n+  uint index_in_cset() const {\n+    return _index_in_cset;\n@@ -543,7 +535,0 @@\n-  void set_young_index_in_cset(uint index) {\n-    assert(index != UINT_MAX, \"just checking\");\n-    assert(index != 0, \"just checking\");\n-    assert(is_young(), \"pre-condition\");\n-    set_index_in_cset(index);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -290,7 +290,0 @@\n-inline void HeapRegion::clear_index_in_opt_cset() {\n-  if (!has_index_in_opt_cset()) {\n-    return;\n-  }\n-  clear_index_in_cset();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}