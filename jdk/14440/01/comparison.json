{"files":[{"patch":"@@ -336,0 +336,1 @@\n+    _committed_regions.clear();\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"services\/virtualMemoryTracker.hpp\"\n+#include \"unittest.hpp\"\n+\n+static size_t get_committed() {\n+  VirtualMemorySnapshot snapshot;\n+  VirtualMemorySummary::snapshot(&snapshot);\n+\n+  return snapshot.by_type(mtThreadStack)->committed();\n+}\n+\n+TEST_VM(VirtualMemoryTracker, MissingRemoveReleasedRegion) {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  \/\/ Simulate the case where we miss the ending of a thread.\n+  for (int i = 100; i >= 0; --i) {\n+    size_t size = 1024 * 1024;\n+    NativeCallStack empty_stack;\n+\n+    \/\/ Get a region of mapped memory not tracked by the virtual memory tracker.\n+    address base = (address) os::reserve_memory(2 * size, false);\n+    VirtualMemoryTracker::remove_released_region(base, 2 * size);\n+    size_t init_sz = get_committed();\n+\n+    \/\/ Reserve and commit everything. We have to, since getting the snapshot 'detects'\n+    \/\/ committed but not reported memory for thread stacks and the detection will not work\n+    \/\/ on MacOSX (not implemented).\n+    VirtualMemoryTracker::add_reserved_region(base, size, empty_stack, mtThreadStack);\n+    VirtualMemoryTracker::add_committed_region(base, size, empty_stack);\n+\n+    \/\/ Now pretend we have forgotten to call remove_released_region and allocate an new\n+    \/\/ overlapping region with some commited memory.\n+    VirtualMemoryTracker::add_reserved_region(base + size \/ 2, size, empty_stack, mtThreadStack);\n+    VirtualMemoryTracker::add_committed_region(base + size \/ 2, size, empty_stack);\n+\n+    \/\/ And remove some of the the committed memory again by reserving a partially overlappinbg region.\n+    VirtualMemoryTracker::add_reserved_region(base, size, empty_stack, mtThreadStack);\n+    VirtualMemoryTracker::add_committed_region(base, size, empty_stack);\n+    size_t new_sz = get_committed();\n+\n+    \/\/ Give back the memory.\n+    VirtualMemoryTracker::remove_released_region(base, size);\n+    VirtualMemoryTracker::add_reserved_region(base, 2 * size, empty_stack, mtThreadStack);\n+    os::release_memory((char*) base, 2 * size);\n+\n+    \/\/ If a parallel thread committed memory concurrently, we get a wrong test result.\n+    \/\/ This should not happen often, so try a few times.\n+    if (new_sz - size == init_sz) {\n+      break;\n+    }\n+\n+    \/\/ If it fails too often log the values we see.\n+    if (i < 50) {\n+      tty->print_cr(\"init_sz: %d, new_sz %d, diff %d, region_size %d\", (int) init_sz, (int) new_sz, (int) (new_sz - init_sz), (int) size);\n+    }\n+\n+    \/\/ Trigger a test failure on the last run.\n+    if (i == 0) {\n+      EXPECT_TRUE(new_sz - size == init_sz) << \"new_sz: \" << new_sz << \", init_sz: \" << init_sz <<\n+                                               \", diff: \" << (new_sz - init_sz) << \", region size: \" << size;\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_virtualMemoryTracker.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}