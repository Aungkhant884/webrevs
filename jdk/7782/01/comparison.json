{"files":[{"patch":"@@ -4269,0 +4269,41 @@\n+instruct vnegID(vecD dst, vecD src)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() < 16);\n+  match(Set dst (NegVI src));\n+  ins_cost(INSN_COST);\n+  format %{ \"negr  $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n+    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(vunop_fp64);\n+%}\n+\n+instruct vnegIX(vecX dst, vecX src)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (NegVI src));\n+  ins_cost(INSN_COST);\n+  format %{ \"negr  $dst, $src\\t# vector (16B\/8H\/4S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n+    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(vunop_fp128);\n+%}\n+\n+instruct vneg2L(vecX dst, vecX src)\n+%{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (NegVL src));\n+  ins_cost(INSN_COST);\n+  format %{ \"negr  $dst,$src\\t# vector (2D)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T2D,\n+            as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(vunop_fp128);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1926,0 +1926,18 @@\n+define(`VNEGI', `\n+instruct vnegI$1(vec$1 dst, vec$1 src)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() ifelse($1, D, <, ==) 16);\n+  match(Set dst (NegVI src));\n+  ins_cost(INSN_COST);\n+  format %{ \"negr  $dst, $src\\t# vector ($2)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), ifelse($1, D, false, true));\n+    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(vunop_fp`'ifelse($1, D, 64, 128));\n+%}')dnl\n+dnl  $1  $2\n+VNEGI(D, 8B\/4H\/2S)\n+VNEGI(X, 16B\/8H\/4S)\n+dnl\n@@ -1931,1 +1949,1 @@\n-  ins_cost(INSN_COST * 3);\n+  ins_cost(INSN_COST`'ifelse($3, L, `',` * 3'));\n@@ -1934,1 +1952,1 @@\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n+    __ $1(as_FloatRegister($dst$$reg), __ T$2$5,\n@@ -1940,0 +1958,1 @@\n+VNEG(negr, 2,  L, X, D)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1939,1 +1939,28 @@\n-\/\/ vector fneg\n+\/\/ vector neg\n+\n+instruct vnegI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVI src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_neg $dst, $src\\t# vector (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegL(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_neg $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -1967,1 +1994,28 @@\n-\/\/ vector fneg - predicated\n+\/\/ vector neg - predicated\n+\n+instruct vnegI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVI dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_neg $dst_src, $pg, $dst_src\\t# vector (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_neg(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n+            as_PRegister($pg$$reg),\n+            as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVL dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_neg $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_neg(as_FloatRegister($dst_src$$reg), __ D,\n+            as_PRegister($pg$$reg),\n+            as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -527,2 +527,4 @@\n-  ins_encode %{\n-    __ $4(as_FloatRegister($dst$$reg), __ $3,\n+  ins_encode %{dnl\n+ifelse($1, `vnegI', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ $4(as_FloatRegister($dst$$reg), ifelse($1, `vnegI', `__ elemType_to_regVariant(bt)', `__ $3'),\n@@ -551,2 +553,4 @@\n-  ins_encode %{\n-    __ $4(as_FloatRegister($dst_src$$reg), __ $3,\n+  ins_encode %{dnl\n+ifelse($1, `vnegI', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ $4(as_FloatRegister($dst_src$$reg), ifelse($1, `vnegI', `__ elemType_to_regVariant(bt)', `__ $3'),\n@@ -1094,1 +1098,3 @@\n-\/\/ vector fneg\n+\/\/ vector neg\n+UNARY_OP_TRUE_PREDICATE(vnegI, NegVI, B\/H\/S, sve_neg)\n+UNARY_OP_TRUE_PREDICATE(vnegL, NegVL, D, sve_neg)\n@@ -1098,1 +1104,3 @@\n-\/\/ vector fneg - predicated\n+\/\/ vector neg - predicated\n+UNARY_OP_PREDICATE(vnegI, NegVI, B\/H\/S, sve_neg)\n+UNARY_OP_PREDICATE(vnegL, NegVL, D, sve_neg)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4215,1 +4215,1 @@\n-    \"NegVF\",\"NegVD\",\"NegVI\",\n+    \"NegVF\",\"NegVD\",\"NegVI\",\"NegVL\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -389,0 +389,1 @@\n+macro(NegVL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,0 +202,10 @@\n+#endif\n+      return false;\n+    }\n+  } else if (VectorNode::is_vector_integral_negate(sopc)) {\n+    if (!VectorNode::is_vector_integral_negate_supported(sopc, num_elem, type, false)) {\n+#ifndef PRODUCT\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support integral vector negate\",\n+                      NodeClassNames[sopc], type2name(type), num_elem);\n+      }\n@@ -280,2 +290,10 @@\n-    if (!Matcher::has_predicated_vectors() ||\n-        !Matcher::match_rule_supported_vector_masked(sopc, num_elem, type)) {\n+    bool is_supported = false;\n+    if (Matcher::has_predicated_vectors()) {\n+      if (VectorNode::is_vector_integral_negate(sopc)) {\n+        is_supported = VectorNode::is_vector_integral_negate_supported(sopc, num_elem, type, true);\n+      } else {\n+        is_supported = Matcher::match_rule_supported_vector_masked(sopc, num_elem, type);\n+      }\n+    }\n+\n+    if (!is_supported) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -138,1 +138,8 @@\n-    return (bt == T_INT ? Op_NegVI : 0);\n+    switch (bt) {\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT: return Op_NegVI;\n+      default: return 0;\n+    }\n+  case Op_NegL:\n+    return (bt == T_LONG ? Op_NegVL : 0);\n@@ -278,0 +285,3 @@\n+    if (VectorNode::is_vector_integral_negate(vopc)) {\n+      return is_vector_integral_negate_supported(vopc, vlen, bt, false);\n+    }\n@@ -352,0 +362,32 @@\n+\/\/ Check whether the architecture supports the vector negate instructions. If not, then check\n+\/\/ whether the alternative vector nodes used to implement vector negation are supported.\n+\/\/ Return false if neither of them is supported.\n+bool VectorNode::is_vector_integral_negate_supported(int opc, uint vlen, BasicType bt, bool use_predicate) {\n+  if (!use_predicate) {\n+    \/\/ Check whether the NegVI\/L is supported by the architecture.\n+    if (Matcher::match_rule_supported_vector(opc, vlen, bt)) {\n+      return true;\n+    }\n+    \/\/ Negate is implemented with \"(SubVI\/L (ReplicateI\/L 0) src)\", if NegVI\/L is not supported.\n+    int sub_opc = (bt == T_LONG) ? Op_SubL : Op_SubI;\n+    if (Matcher::match_rule_supported_vector(VectorNode::opcode(sub_opc, bt), vlen, bt) &&\n+        Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vlen, bt)) {\n+      return true;\n+    }\n+  } else {\n+    \/\/ Check whether the predicated NegVI\/L is supported by the architecture.\n+    if (Matcher::match_rule_supported_vector_masked(opc, vlen, bt)) {\n+      return true;\n+    }\n+    \/\/ Predicated negate is implemented with \"(AddVI\/L (XorV src (ReplicateI\/L -1)) (ReplicateI\/L 1))\",\n+    \/\/ if predicated NegVI\/L is not supported.\n+    int add_opc = (bt == T_LONG) ? Op_AddL : Op_AddI;\n+    if (Matcher::match_rule_supported_vector_masked(Op_XorV, vlen, bt) &&\n+        Matcher::match_rule_supported_vector_masked(VectorNode::opcode(add_opc, bt), vlen, bt) &&\n+        Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vlen, bt)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -539,0 +581,1 @@\n+  case Op_NegVL: return new NegVLNode(n1, vt);\n@@ -670,0 +713,4 @@\n+bool VectorNode::is_vector_integral_negate(int opc) {\n+  return opc == Op_NegVI || opc == Op_NegVL;\n+}\n+\n@@ -1544,0 +1591,60 @@\n+\/\/ Generate other vector nodes to implement the masked\/non-masked vector negation.\n+Node* VectorNode::degenerate_vector_integral_negate(Node* n, int vlen, BasicType bt, PhaseGVN* phase, bool is_predicated) {\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n+  \/\/ Transformation for predicated NegVI\/L\n+  if (is_predicated) {\n+      \/\/ (NegVI\/L src m) ==> (AddVI\/L (XorV src (ReplicateI\/L -1) m) (ReplicateI\/L 1) m)\n+      Node* const_minus_one = NULL;\n+      Node* const_one = NULL;\n+      int add_opc;\n+      if (bt == T_LONG) {\n+        const_minus_one = phase->longcon(-1L);\n+        const_one = phase->longcon(1L);\n+        add_opc = Op_AddL;\n+      } else {\n+        const_minus_one = phase->intcon(-1);\n+        const_one = phase->intcon(1);\n+        add_opc = Op_AddI;\n+      }\n+      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, Type::get_const_basic_type(bt)));\n+      Node* xorv = VectorNode::make(Op_XorV, n->in(1), const_minus_one, vt);\n+      xorv->add_req(n->in(2));\n+      xorv->add_flag(Node::Flag_is_predicated_vector);\n+      phase->transform(xorv);\n+      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, Type::get_const_basic_type(bt)));\n+      Node* addv = VectorNode::make(VectorNode::opcode(add_opc, bt), xorv, const_one, vt);\n+      addv->add_req(n->in(2));\n+      addv->add_flag(Node::Flag_is_predicated_vector);\n+      return addv;\n+  }\n+\n+  \/\/ NegVI\/L ==> (SubVI\/L (ReplicateI\/L 0) src)\n+  Node* const_zero = NULL;\n+  int sub_opc;\n+  if (bt == T_LONG) {\n+    const_zero = phase->longcon(0L);\n+    sub_opc = Op_SubL;\n+  } else {\n+    const_zero = phase->intcon(0);\n+    sub_opc = Op_SubI;\n+  }\n+  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, Type::get_const_basic_type(bt)));\n+  return VectorNode::make(VectorNode::opcode(sub_opc, bt), const_zero, n->in(1), vt);\n+}\n+\n+Node* NegVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  BasicType bt = vect_type()->element_basic_type();\n+  uint vlen = length();\n+  int opc = Opcode();\n+  if (is_vector_integral_negate(opc)) {\n+    if (is_predicated_vector()) {\n+      if (!Matcher::match_rule_supported_vector_masked(opc, vlen, bt)) {\n+        return degenerate_vector_integral_negate(this, vlen, bt, phase, true);\n+      }\n+    } else if (!Matcher::match_rule_supported_vector(opc, vlen, bt)) {\n+      return degenerate_vector_integral_negate(this, vlen, bt, phase, false);\n+    }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":108,"deletions":1,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+  static bool is_vector_integral_negate_supported(int opc, uint vlen, BasicType bt, bool use_predicate);\n@@ -105,0 +106,1 @@\n+  static Node* degenerate_vector_integral_negate(Node* n, int vlen, BasicType bt, PhaseGVN* phase, bool is_predicated);\n@@ -112,0 +114,1 @@\n+  static bool is_vector_integral_negate(int opc);\n@@ -477,0 +480,9 @@\n+\/\/------------------------------NegVNode---------------------------------------\n+\/\/ Vector Neg parent class (not for code generation).\n+class NegVNode : public VectorNode {\n+ public:\n+  NegVNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const = 0;\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n@@ -478,2 +490,10 @@\n-\/\/ Vector Neg int\n-class NegVINode : public VectorNode {\n+\/\/ Vector Neg byte\/short\/int\n+class NegVINode : public NegVNode {\n+ public:\n+  NegVINode(Node* in, const TypeVect* vt) : NegVNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------NegVLNode--------------------------------------\n+\/\/ Vector Neg long\n+class NegVLNode : public NegVNode {\n@@ -481,1 +501,1 @@\n-  NegVINode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}\n+  NegVLNode(Node* in, const TypeVect* vt) : NegVNode(in, vt) {}\n@@ -487,1 +507,1 @@\n-class NegVFNode : public VectorNode {\n+class NegVFNode : public NegVNode {\n@@ -489,1 +509,1 @@\n-  NegVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}\n+  NegVFNode(Node* in, const TypeVect* vt) : NegVNode(in, vt) {}\n@@ -495,1 +515,1 @@\n-class NegVDNode : public VectorNode {\n+class NegVDNode : public NegVNode {\n@@ -497,1 +517,1 @@\n-  NegVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}\n+  NegVDNode(Node* in, const TypeVect* vt) : NegVNode(in, vt) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1760,3 +1760,5 @@\n-  declare_c2_type(NegVINode, VectorNode)                                  \\\n-  declare_c2_type(NegVFNode, VectorNode)                                  \\\n-  declare_c2_type(NegVDNode, VectorNode)                                  \\\n+  declare_c2_type(NegVNode, VectorNode)                                   \\\n+  declare_c2_type(NegVINode, NegVNode)                                    \\\n+  declare_c2_type(NegVLNode, NegVNode)                                    \\\n+  declare_c2_type(NegVFNode, NegVNode)                                    \\\n+  declare_c2_type(NegVDNode, NegVNode)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -576,3 +576,0 @@\n-            } else if (op == NEG) {\n-                \/\/ FIXME: Support this in the JIT.\n-                return broadcast(0).lanewise(SUB, this);\n@@ -607,2 +604,0 @@\n-            } else if (op == NEG) {\n-                return lanewise(NOT, m).lanewise(ADD, broadcast(1), m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -576,3 +576,0 @@\n-            } else if (op == NEG) {\n-                \/\/ FIXME: Support this in the JIT.\n-                return broadcast(0).lanewise(SUB, this);\n@@ -607,2 +604,0 @@\n-            } else if (op == NEG) {\n-                return lanewise(NOT, m).lanewise(ADD, broadcast(1), m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -534,3 +534,0 @@\n-            } else if (op == NEG) {\n-                \/\/ FIXME: Support this in the JIT.\n-                return broadcast(0).lanewise(SUB, this);\n@@ -565,2 +562,0 @@\n-            } else if (op == NEG) {\n-                return lanewise(NOT, m).lanewise(ADD, broadcast(1), m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -576,3 +576,0 @@\n-            } else if (op == NEG) {\n-                \/\/ FIXME: Support this in the JIT.\n-                return broadcast(0).lanewise(SUB, this);\n@@ -607,2 +604,0 @@\n-            } else if (op == NEG) {\n-                return lanewise(NOT, m).lanewise(ADD, broadcast(1), m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -599,3 +599,0 @@\n-            } else if (op == NEG) {\n-                \/\/ FIXME: Support this in the JIT.\n-                return broadcast(0).lanewise(SUB, this);\n@@ -632,2 +629,0 @@\n-            } else if (op == NEG) {\n-                return lanewise(NOT, m).lanewise(ADD, broadcast(1), m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}