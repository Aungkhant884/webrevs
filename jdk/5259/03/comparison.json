{"files":[{"patch":"@@ -4073,0 +4073,14 @@\n+\/\/----------------------has_wide_mem-------------------------\n+bool LibraryCallKit::has_wide_mem(Node* addr, Node* base) {\n+  const TypeAryPtr* addr_t = _gvn.type(addr)->isa_aryptr();\n+  const Type*       base_t = _gvn.type(base);\n+\n+  bool in_native = (base_t == TypePtr::NULL_PTR);\n+  bool in_heap   = !TypePtr::NULL_PTR->higher_equal(base_t);\n+  bool is_mixed  = !in_heap && !in_native;\n+\n+  bool is_prim_array = (addr_t != NULL) && (addr_t->elem() != Type::BOTTOM);\n+\n+  return is_mixed || (in_heap && !is_prim_array);\n+}\n+\n@@ -4082,5 +4096,5 @@\n-  Node* src_ptr =         argument(1);   \/\/ type: oop\n-  Node* src_off = ConvL2X(argument(2));  \/\/ type: long\n-  Node* dst_ptr =         argument(4);   \/\/ type: oop\n-  Node* dst_off = ConvL2X(argument(5));  \/\/ type: long\n-  Node* size    = ConvL2X(argument(7));  \/\/ type: long\n+  Node* src_base =         argument(1);  \/\/ type: oop\n+  Node* src_off  = ConvL2X(argument(2)); \/\/ type: long\n+  Node* dst_base =         argument(4);  \/\/ type: oop\n+  Node* dst_off  = ConvL2X(argument(5)); \/\/ type: long\n+  Node* size     = ConvL2X(argument(7)); \/\/ type: long\n@@ -4091,6 +4105,2 @@\n-  Node* src = make_unsafe_address(src_ptr, src_off);\n-  Node* dst = make_unsafe_address(dst_ptr, dst_off);\n-\n-  \/\/ Conservatively insert a memory barrier on all memory slices.\n-  \/\/ Do not let writes of the copy source or destination float below the copy.\n-  insert_mem_bar(Op_MemBarCPUOrder);\n+  Node* src_addr = make_unsafe_address(src_base, src_off);\n+  Node* dst_addr = make_unsafe_address(dst_base, dst_off);\n@@ -4106,0 +4116,14 @@\n+  int flags = RC_LEAF | RC_NO_FP;\n+\n+  const TypePtr* dst_type = TypePtr::BOTTOM;\n+\n+  \/\/ Adjust memory effects\n+  if (!has_wide_mem(src_addr, src_base) && !has_wide_mem(dst_addr, dst_base)) {\n+    dst_type = _gvn.type(dst_addr)->is_ptr(); \/\/ narrow out memory\n+\n+    const TypePtr* src_type = _gvn.type(src_addr)->is_ptr();\n+    if (C->get_alias_index(src_type) == C->get_alias_index(dst_type)) {\n+      flags |= RC_NARROW_MEM; \/\/ narrow in memory\n+    }\n+  }\n+\n@@ -4107,1 +4131,1 @@\n-  make_runtime_call(RC_LEAF|RC_NO_FP,\n+  make_runtime_call(flags,\n@@ -4111,2 +4135,2 @@\n-                    TypeRawPtr::BOTTOM,\n-                    src, dst, size XTOP);\n+                    dst_type,\n+                    src_addr, dst_addr, size XTOP);\n@@ -4116,3 +4140,0 @@\n-  \/\/ Do not let reads of the copy destination float above the copy.\n-  insert_mem_bar(Op_MemBarCPUOrder);\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -235,0 +235,2 @@\n+  bool has_wide_mem(Node* addr, Node* base);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,443 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ *\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=dontinline,compiler.unsafe.UnsafeCopyMemory::test*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.unsafe.UnsafeCopyMemory\n+ *\/\n+\n+package compiler.unsafe;\n+\n+import jdk.internal.misc.Unsafe;\n+import static jdk.test.lib.Asserts.assertEQ;\n+\n+public class UnsafeCopyMemory {\n+    static private Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ On-heap arrays\n+    static int[] srcArr = new int[1];\n+    static int[] dstArr = new int[1];\n+\n+    static int[] resArr = dstArr;\n+\n+    static Object srcObj = srcArr;\n+    static Object dstObj = dstArr;\n+\n+    static long[] dstArrL = new long[1];\n+    static long[] resArrL = dstArrL;\n+\n+    \/\/ Native\n+\n+    static long SRC_BASE = UNSAFE.allocateMemory(4);\n+    static long DST_BASE = UNSAFE.allocateMemory(4);\n+\n+    static long RES_BASE = DST_BASE;\n+\n+    static void reset() {\n+        resArr[0] = 0;\n+        UNSAFE.putInt(null, RES_BASE, 0);\n+    }\n+\n+    \/* ================================================================ *\/\n+\n+    \/\/ Heap-to-heap\n+\n+    static int testHeapToHeap(int v1, int v2, int v3, int v4, int readIdx, int writeIdx) {\n+        \/\/ assert(readIdx == writeIdx == 0);\n+        srcArr[readIdx]  = v1;\n+        dstArr[writeIdx] = v2;\n+\n+        UNSAFE.copyMemory(srcArr, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                          dstArr, Unsafe.ARRAY_INT_BASE_OFFSET, 4);\n+        int r = resArr[0]; \/\/ snapshot\n+\n+        srcArr[readIdx]  = v3;\n+        dstArr[writeIdx] = v4;\n+\n+        return r;\n+    }\n+\n+    static int testHeapToHeapMixed(int v1, int v2, int v3, int v4, int readIdx, int writeIdx) {\n+        \/\/ assert(readIdx == writeIdx == 0);\n+        srcArr[readIdx]  = v1;\n+        dstArr[writeIdx] = v2;\n+\n+        UNSAFE.copyMemory(srcObj, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                          dstObj, Unsafe.ARRAY_INT_BASE_OFFSET, 4); \/\/ mixed\n+        int r = resArr[0]; \/\/ snapshot\n+\n+        srcArr[readIdx]  = v3;\n+        dstArr[writeIdx] = v4;\n+\n+        return r;\n+    }\n+\n+    static long testHeapToHeapMismatched(int v1, int v2, int v3, int v4, int readIdx, int writeIdx) {\n+        \/\/ assert(readIdx == writeIdx == 0);\n+        srcArr [readIdx]  = v1;\n+        dstArrL[writeIdx] = v2;\n+\n+        UNSAFE.copyMemory(srcArr,  Unsafe.ARRAY_INT_BASE_OFFSET,\n+                          dstArrL, Unsafe.ARRAY_LONG_BASE_OFFSET, 4); \/\/ mismatched\n+        long r = resArrL[0]; \/\/ snapshot\n+\n+        srcArr[readIdx]  = v3;\n+        dstArrL[writeIdx] = v4;\n+\n+        return r;\n+    }\n+\n+    static int testHeapToHeapLocalSrc(int v1, int v2, int v3, int v4, int writeIdx) {\n+        \/\/ assert(writeIdx == 0);\n+        int[] srcArrLocal = new int[1];\n+\n+        srcArrLocal[0] = v1;\n+        dstArr[writeIdx] = v2;\n+\n+        UNSAFE.copyMemory(srcArrLocal, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                          dstArr,      Unsafe.ARRAY_INT_BASE_OFFSET, 4);\n+        int r = resArr[0]; \/\/ snapshot\n+\n+        srcArrLocal[0] = v3;\n+        dstArr[writeIdx] = v4;\n+\n+        return r;\n+    }\n+\n+    static int testHeapToHeapLocalDst(int v1, int v2, int v3, int v4, int readIdx) {\n+        \/\/ assert(readIdx == 0);\n+        int[] dstArrLocal = new int[1];\n+\n+        srcArr[readIdx] = v1;\n+        dstArrLocal[0] = v2;\n+\n+        UNSAFE.copyMemory(srcArr,      Unsafe.ARRAY_INT_BASE_OFFSET,\n+                          dstArrLocal, Unsafe.ARRAY_INT_BASE_OFFSET, 4);\n+        int r = dstArrLocal[0]; \/\/ snapshot\n+\n+        srcArr[readIdx] = v3;\n+        dstArrLocal[0] = v4;\n+\n+        return r;\n+    }\n+\n+    static int testHeapToHeapLocalSrcMismatched(int v1, int v2, int v3, int v4, int writeIdx, boolean flag) {\n+        \/\/ assert(writeIdx == 0);\n+        \/\/ assert(b == true);\n+        int[]  srcArrIntLocal  = new int[1];\n+        long[] srcArrLongLocal = new long[1];\n+\n+        Object srcArrLocal = (flag ? srcArrIntLocal               : srcArrLongLocal);\n+        long   srcOffset   = (flag ? Unsafe.ARRAY_INT_BASE_OFFSET : Unsafe.ARRAY_LONG_BASE_OFFSET);\n+\n+        srcArrIntLocal[0]  = v1;\n+        srcArrLongLocal[0] = v1;\n+        dstArr[writeIdx] = v2;\n+\n+        UNSAFE.copyMemory(srcArrLocal, srcOffset,\n+                          dstArr,      Unsafe.ARRAY_INT_BASE_OFFSET, 4);\n+        int r = resArr[0]; \/\/ snapshot\n+\n+        srcArrIntLocal[0]  = v3;\n+        srcArrLongLocal[0] = v3;\n+        dstArr[writeIdx] = v4;\n+\n+        return r;\n+    }\n+\n+    static int testHeapToHeapLocalDstMismatched(int v1, int v2, int v3, int v4, int readIdx, boolean flag) {\n+        \/\/ assert(readIdx == 0);\n+        int[]  dstArrIntLocal  = new int[1];\n+        long[] dstArrLongLocal = new long[1];\n+\n+        Object dstArrLocal = (flag ? dstArrIntLocal               : dstArrLongLocal);\n+        long   dstOffset   = (flag ? Unsafe.ARRAY_INT_BASE_OFFSET : Unsafe.ARRAY_LONG_BASE_OFFSET);\n+\n+        srcArr[readIdx] = v1;\n+        dstArrIntLocal[0]  = v2;\n+        dstArrLongLocal[0] = v2;\n+\n+        UNSAFE.copyMemory(srcArr,     Unsafe.ARRAY_INT_BASE_OFFSET,\n+                          dstArrLocal, dstOffset, 4);\n+        int r = UNSAFE.getInt(dstArrLocal, dstOffset); \/\/ snapshot\n+\n+        srcArr[readIdx] = v3;\n+        dstArrIntLocal[0]  = v4;\n+        dstArrLongLocal[0] = v4;\n+\n+        return r;\n+    }\n+\n+    \/* ================================================================ *\/\n+\n+    \/\/ Heap-to-native\n+\n+    static int testHeapToNative(int v1, int v2, int v3, int v4, int readIdx) {\n+        \/\/ assert(readIdx == 0);\n+        srcArr[readIdx]  = v1;\n+        UNSAFE.putInt(null, DST_BASE, v2);\n+\n+        UNSAFE.copyMemory(srcArr, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                          null, DST_BASE, 4);\n+        int r = UNSAFE.getInt(RES_BASE); \/\/ snapshot\n+\n+        srcArr[readIdx]  = v3;\n+        UNSAFE.putInt(null, DST_BASE, v4);\n+\n+        return r;\n+    }\n+\n+    static int testHeapToNativeMixed(int v1, int v2, int v3, int v4, int readIdx) {\n+        \/\/ assert(readIdx == 0);\n+        srcArr[readIdx]  = v1;\n+        UNSAFE.putInt(null, DST_BASE, v2);\n+\n+        UNSAFE.copyMemory(srcObj, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                          null, DST_BASE, 4); \/\/ mixed\n+        int r = UNSAFE.getInt(RES_BASE); \/\/ snapshot\n+\n+        srcArr[readIdx]  = v3;\n+        UNSAFE.putInt(null, DST_BASE, v4);\n+\n+        return r;\n+    }\n+\n+    \/* ================================================================ *\/\n+\n+    \/\/ Native-to-heap\n+\n+    static int testNativeToHeap(int v1, int v2, int v3, int v4, int writeIdx) {\n+        \/\/ assert(writeIdx == 0);\n+        UNSAFE.putInt(null, SRC_BASE, v1);\n+        dstArr[writeIdx] = v2;\n+\n+        UNSAFE.copyMemory(null, SRC_BASE,\n+                          dstArr, Unsafe.ARRAY_INT_BASE_OFFSET, 4);\n+        int r = resArr[0]; \/\/ snapshot\n+\n+        UNSAFE.putInt(null, SRC_BASE, v3);\n+        dstArr[writeIdx] = v4;\n+\n+        return r;\n+    }\n+\n+    static int testNativeToHeapArrMixed(int v1, int v2, int v3, int v4, int writeIdx) {\n+        \/\/ assert(writeIdx == 0);\n+        UNSAFE.putInt(null, SRC_BASE, v1);\n+        dstArr[writeIdx] = v2;\n+\n+        UNSAFE.copyMemory(null, SRC_BASE,\n+                          dstObj, Unsafe.ARRAY_INT_BASE_OFFSET, 4); \/\/ mixed dst\n+        int r = resArr[0]; \/\/ snapshot\n+\n+        UNSAFE.putInt(null, SRC_BASE, v3);\n+        dstArr[writeIdx] = v4;\n+\n+        return r;\n+    }\n+\n+    \/* ================================================================ *\/\n+\n+    \/\/ Native-to-native\n+\n+    static int testNativeToNative(int v1, int v2, int v3, int v4) {\n+        UNSAFE.putInt(null, SRC_BASE, v1);\n+        UNSAFE.putInt(null, DST_BASE, v2);\n+\n+        UNSAFE.copyMemory(null, SRC_BASE,\n+                          null, DST_BASE, 4);\n+        int r = UNSAFE.getInt(RES_BASE); \/\/ snapshot\n+\n+        UNSAFE.putInt(null, SRC_BASE, v3);\n+        UNSAFE.putInt(null, DST_BASE, v4);\n+\n+        return r;\n+    }\n+\n+    static int testNativeToNativeMixed(int v1, int v2, int v3, int v4, Object base) {\n+        \/\/ assert(base == null);\n+        UNSAFE.putInt(null, SRC_BASE, v1);\n+        UNSAFE.putInt(null, DST_BASE, v2);\n+\n+        UNSAFE.copyMemory(base, SRC_BASE,\n+                          base, DST_BASE, 4); \/\/ mixed\n+        int r = UNSAFE.getInt(RES_BASE); \/\/ snapshot\n+\n+        UNSAFE.putInt(null, SRC_BASE, v3);\n+        UNSAFE.putInt(null, DST_BASE, v4);\n+\n+        return r;\n+    }\n+\n+    \/* ================================================================ *\/\n+\n+    static int v1 = 1;\n+    static int v2 = 2;\n+    static int v3 = 3;\n+    static int v4 = 4;\n+\n+    static int  readIdx0 = 0;\n+    static int writeIdx0 = 0;\n+    static Object nullBase = null;\n+\n+    static void runTests(String msg) {\n+        boolean print = (msg != null);\n+        if (print) {\n+            System.out.println(msg);\n+        }\n+        {\n+            reset();\n+            int r1 = testHeapToHeap(v1, v2, v3, v4, readIdx0, writeIdx0);\n+            int r2 = resArr[0];\n+            if (print) {\n+                System.out.println(\"testHeapToHeap: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+        {\n+            reset();\n+            int r1 = testHeapToHeapMixed(v1, v2, v3, v4, readIdx0, writeIdx0);\n+            int r2 = resArr[0];\n+            if (print) {\n+                System.out.println(\"testHeapToHeapMixed: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+        {\n+            reset();\n+            long r1 = testHeapToHeapMismatched(v1, v2, v3, v4, readIdx0, writeIdx0);\n+            long r2 = resArrL[0];\n+            if (print) {\n+                System.out.println(\"testHeapToHeapMismatched: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, (long)v1); assertEQ(r2, (long)v4);\n+        }\n+        {\n+            reset();\n+            int r1 = testHeapToHeapLocalSrc(v1, v2, v3, v4, writeIdx0);\n+            int r2 = resArr[0];\n+            if (print) {\n+                System.out.println(\"testHeapToHeapLocalSrc: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+        {\n+            reset();\n+            int r = testHeapToHeapLocalDst(v1, v2, v3, v4, readIdx0);\n+            if (print) {\n+                System.out.println(\"testHeapToHeapLocalDst: \" + r);\n+            }\n+            assertEQ(r, v1);\n+        }\n+        {\n+            reset();\n+            int r1 = testHeapToHeapLocalSrcMismatched(v1, v2, v3, v4, writeIdx0, flag);\n+            int r2 = resArr[0];\n+            if (print) {\n+                System.out.println(\"testHeapToHeapLocalSrcMismatched: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+        {\n+            reset();\n+            int r = testHeapToHeapLocalDstMismatched(v1, v2, v3, v4, readIdx0, flag);\n+            if (print) {\n+                System.out.println(\"testHeapToHeapLocalDstMismatched: \" + r);\n+            }\n+            assertEQ(r, v1);\n+        }\n+        {\n+            reset();\n+            int r1 = testHeapToNative(v1, v2, v3, v4, readIdx0);\n+            int r2 = UNSAFE.getInt(null, RES_BASE);\n+            if (print) {\n+                System.out.println(\"testHeapToNative: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+        {\n+            reset();\n+            int r1 = testHeapToNativeMixed(v1, v2, v3, v4, readIdx0);\n+            int r2 = UNSAFE.getInt(null, RES_BASE);\n+            if (print) {\n+                System.out.println(\"testHeapToNativeMixed: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+\n+        \/\/ Native-to-*\n+        {\n+            reset();\n+            int r1 = testNativeToHeap(v1, v2, v3, v4, writeIdx0);\n+            int r2 = resArr[0];\n+            if (print) {\n+                System.out.println(\"testNativeToHeap: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+        {\n+            reset();\n+            int r1 = testNativeToHeapArrMixed(v1, v2, v3, v4, writeIdx0);\n+            int r2 = resArr[0];\n+            if (print) {\n+                System.out.println(\"testNativeToHeapMixed: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+        {\n+            reset();\n+            int r1 = testNativeToNative(v1, v2, v3, v4);\n+            int r2 = UNSAFE.getInt(null, RES_BASE);\n+            if (print) {\n+                System.out.println(\"testNativeToNative: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+        {\n+            reset();\n+            int r1 = testNativeToNativeMixed(v1, v2, v3, v4, nullBase);\n+            int r2 = UNSAFE.getInt(null, RES_BASE);\n+            if (print) {\n+                System.out.println(\"testNativeToNativeMixed: \" + r1 + \" \" + r2);\n+            }\n+            assertEQ(r1, v1); assertEQ(r2, v4);\n+        }\n+    }\n+\n+    static boolean flag = false;\n+\n+    public static void main(String[] args) {\n+        runTests(\"INTERPRETED\");\n+        for (int i = 0; i < 20_000; i++) {\n+            flag = (i % 2 == 0);\n+            runTests(null);\n+        }\n+        runTests(\"COMPILED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeCopyMemory.java","additions":443,"deletions":0,"binary":false,"changes":443,"status":"added"}]}