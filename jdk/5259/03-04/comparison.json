{"files":[{"patch":"@@ -4073,4 +4073,6 @@\n-\/\/----------------------has_wide_mem-------------------------\n-bool LibraryCallKit::has_wide_mem(Node* addr, Node* base) {\n-  const TypeAryPtr* addr_t = _gvn.type(addr)->isa_aryptr();\n-  const Type*       base_t = _gvn.type(base);\n+\/\/----------------------inline_unsafe_copyMemory-------------------------\n+\/\/ public native void Unsafe.copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);\n+\n+static bool has_wide_mem(PhaseGVN& gvn, Node* addr, Node* base) {\n+  const TypeAryPtr* addr_t = gvn.type(addr)->isa_aryptr();\n+  const Type*       base_t = gvn.type(base);\n@@ -4082,3 +4084,12 @@\n-  bool is_prim_array = (addr_t != NULL) && (addr_t->elem() != Type::BOTTOM);\n-\n-  return is_mixed || (in_heap && !is_prim_array);\n+  if (is_mixed) {\n+    return true; \/\/ mixed accesses can touch both on-heap and off-heap memory\n+  }\n+  if (in_heap) {\n+    bool is_prim_array = (addr_t != NULL) && (addr_t->elem() != Type::BOTTOM);\n+    if (!is_prim_array) {\n+      \/\/ Though Unsafe.copyMemory() ensures at runtime for on-heap accesses that base is a primitive array,\n+      \/\/ there's not enough type information available to determine proper memory slice for it.\n+      return true;\n+    }\n+  }\n+  return false;\n@@ -4087,2 +4098,0 @@\n-\/\/----------------------inline_unsafe_copyMemory-------------------------\n-\/\/ public native void Unsafe.copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);\n@@ -4120,2 +4129,3 @@\n-  \/\/ Adjust memory effects\n-  if (!has_wide_mem(src_addr, src_base) && !has_wide_mem(dst_addr, dst_base)) {\n+  \/\/ Adjust memory effects of the runtime call based on input values.\n+  if (!has_wide_mem(_gvn, src_addr, src_base) &&\n+      !has_wide_mem(_gvn, dst_addr, dst_base)) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -235,2 +235,0 @@\n-  bool has_wide_mem(Node* addr, Node* base);\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key stress randomness\n@@ -31,1 +32,1 @@\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeCopyMemory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}