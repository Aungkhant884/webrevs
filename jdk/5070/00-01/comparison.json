{"files":[{"patch":"@@ -2393,2 +2393,5 @@\n-    } else if (tag.is_symbol() || tag.is_string()) {\n-      Symbol* entry = slot_at(i);\n+    } else if (tag.is_symbol()) {\n+      Symbol* entry = symbol_at(i);\n+      guarantee(entry->refcount() != 0, \"should have nonzero reference count\");\n+    } else if (tag.is_string()) {\n+      Symbol* entry = unresolved_string_at(i);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,7 +139,0 @@\n-  Symbol* slot_at(int which) const;\n-\n-  void slot_at_put(int which, Symbol* s) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    assert(s != 0, \"Caught something\");\n-    *(intptr_t*)&base()[which] = (intptr_t)s;\n-  }\n@@ -330,2 +323,3 @@\n-    release_tag_at_put(which, JVM_CONSTANT_String);\n-    slot_at_put(which, s);\n+    assert(s->refcount() != 0, \"should have nonzero refcount\");\n+    tag_at_put(which, JVM_CONSTANT_String);\n+    *symbol_at_addr(which) = s;\n@@ -484,2 +478,1 @@\n-    Symbol* sym = slot_at(which);\n-    return sym;\n+    return *symbol_at_addr(which);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,9 +33,0 @@\n-inline Symbol* ConstantPool::slot_at(int which) const {\n-  assert(is_within_bounds(which), \"index out of bounds\");\n-  assert(!tag_at(which).is_unresolved_klass() && !tag_at(which).is_unresolved_klass_in_error(), \"Corrupted constant pool\");\n-  \/\/ Uses volatile because the klass slot changes without a lock.\n-  intptr_t adr = Atomic::load_acquire(obj_at_addr(which));\n-  assert(adr != 0 || which == 0, \"cp entry for klass should not be zero\");\n-  return (Symbol*)adr;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}