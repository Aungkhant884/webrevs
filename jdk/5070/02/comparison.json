{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,1 +345,0 @@\n-  \/\/ Clear LSB in symbol address; it can be set by CPSlot.\n@@ -347,1 +346,1 @@\n-    return (Symbol*)(intptr_t(*p) & ~1);\n+    return *p;\n@@ -350,5 +349,0 @@\n-  \/\/ Store symbol, adjusting new pointer if the original pointer was adjusted\n-  \/\/ (symbol references in constant pool slots have their LSB set to 1).\n-  static void store_symbol(Symbol** p, Symbol* sym) {\n-    *p = (Symbol*)(intptr_t(sym) | (intptr_t(*p) & 1));\n-  }\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-      \/\/ In some rare cases (see CPSlot in constantPool.hpp) we store some flags in the lowest\n-      \/\/ 2 bits of a MetaspaceObj pointer. Unmask these when manipulating the pointer.\n+      \/\/ In some rare cases we store some flags in the lowest 2 bits of a\n+      \/\/ MetaspaceObj pointer. Unmask these when manipulating the pointer.\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2394,2 +2394,2 @@\n-      CPSlot entry = slot_at(i);\n-      guarantee(entry.get_symbol()->refcount() != 0, \"should have nonzero reference count\");\n+      Symbol* entry = symbol_at(i);\n+      guarantee(entry->refcount() != 0, \"should have nonzero reference count\");\n@@ -2397,2 +2397,2 @@\n-      CPSlot entry = slot_at(i);\n-      guarantee(entry.get_symbol()->refcount() != 0, \"should have nonzero reference count\");\n+      Symbol* entry = unresolved_string_at(i);\n+      guarantee(entry->refcount() != 0, \"should have nonzero reference count\");\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,16 +52,0 @@\n-class CPSlot {\n- friend class ConstantPool;\n-  intptr_t _ptr;\n-  enum TagBits  {_pseudo_bit = 1};\n- public:\n-\n-  CPSlot(intptr_t ptr): _ptr(ptr) {}\n-  CPSlot(Symbol* ptr, int tag_bits = 0): _ptr((intptr_t)ptr | tag_bits) {}\n-\n-  intptr_t value()   { return _ptr; }\n-\n-  Symbol* get_symbol() {\n-    return (Symbol*)(_ptr & ~_pseudo_bit);\n-  }\n-};\n-\n@@ -155,7 +139,0 @@\n-  CPSlot slot_at(int which) const;\n-\n-  void slot_at_put(int which, CPSlot s) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    assert(s.value() != 0, \"Caught something\");\n-    *(intptr_t*)&base()[which] = s.value();\n-  }\n@@ -345,0 +322,2 @@\n+  \/\/ Note that release_tag_at_put is not needed here because this is called only when\n+  \/\/ constructing a ConstantPool in a single thread, with no possibility of concurrent access.\n@@ -346,2 +325,3 @@\n-    release_tag_at_put(which, JVM_CONSTANT_String);\n-    slot_at_put(which, CPSlot(s));\n+    assert(s->refcount() != 0, \"should have nonzero refcount\");\n+    tag_at_put(which, JVM_CONSTANT_String);\n+    *symbol_at_addr(which) = s;\n@@ -500,2 +480,1 @@\n-    Symbol* sym = slot_at(which).get_symbol();\n-    return sym;\n+    return *symbol_at_addr(which);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":6,"deletions":27,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -33,9 +33,0 @@\n-inline CPSlot ConstantPool::slot_at(int which) const {\n-  assert(is_within_bounds(which), \"index out of bounds\");\n-  assert(!tag_at(which).is_unresolved_klass() && !tag_at(which).is_unresolved_klass_in_error(), \"Corrupted constant pool\");\n-  \/\/ Uses volatile because the klass slot changes without a lock.\n-  intptr_t adr = Atomic::load_acquire(obj_at_addr(which));\n-  assert(adr != 0 || which == 0, \"cp entry for klass should not be zero\");\n-  return CPSlot(adr);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-\/\/ fieldDescriptor or _ptr in a CPSlot) is reference counted.\n+\/\/ fieldDescriptor or symbol in a constant pool) is reference counted.\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}