{"files":[{"patch":"@@ -9233,97 +9233,0 @@\n-\/\/ Intel and SPARC both implement Ideal Node LoadPLocked and\n-\/\/ Store{PIL}Conditional instructions using a normal load for the\n-\/\/ LoadPLocked and a CAS for the Store{PIL}Conditional.\n-\/\/\n-\/\/ The ideal code appears only to use LoadPLocked\/StorePLocked as a\n-\/\/ pair to lock object allocations from Eden space when not using\n-\/\/ TLABs.\n-\/\/\n-\/\/ There does not appear to be a Load{IL}Locked Ideal Node and the\n-\/\/ Ideal code appears to use Store{IL}Conditional as an alias for CAS\n-\/\/ and to use StoreIConditional only for 32-bit and StoreLConditional\n-\/\/ only for 64-bit.\n-\/\/\n-\/\/ We implement LoadPLocked and StorePLocked instructions using,\n-\/\/ respectively the AArch64 hw load-exclusive and store-conditional\n-\/\/ instructions. Whereas we must implement each of\n-\/\/ Store{IL}Conditional using a CAS which employs a pair of\n-\/\/ instructions comprising a load-exclusive followed by a\n-\/\/ store-conditional.\n-\n-\n-\/\/ Locked-load (linked load) of the current heap-top\n-\/\/ used when updating the eden heap top\n-\/\/ implemented using ldaxr on AArch64\n-\n-instruct loadPLocked(iRegPNoSp dst, indirect mem)\n-%{\n-  match(Set dst (LoadPLocked mem));\n-\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  format %{ \"ldaxr $dst, $mem\\t# ptr linked acquire\" %}\n-\n-  ins_encode(aarch64_enc_ldaxr(dst, mem));\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flag (EQ) on success.\n-\/\/ implemented using stlxr on AArch64.\n-\n-instruct storePConditional(memory8 heap_top_ptr, iRegP oldval, iRegP newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));\n-\n-  ins_cost(VOLATILE_REF_COST);\n-\n- \/\/ TODO\n- \/\/ do we need to do a store-conditional release or can we just use a\n- \/\/ plain store-conditional?\n-\n-  format %{\n-    \"stlxr rscratch1, $newval, $heap_top_ptr\\t# ptr cond release\"\n-    \"cmpw rscratch1, zr\\t# EQ on successful write\"\n-  %}\n-\n-  ins_encode(aarch64_enc_stlxr(newval, heap_top_ptr));\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct storeLConditional(indirect mem, iRegLNoSp oldval, iRegLNoSp newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreLConditional mem (Binary oldval newval)));\n-\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  format %{\n-    \"cmpxchg rscratch1, $mem, $oldval, $newval, $mem\\t# if $mem == $oldval then $mem <-- $newval\"\n-    \"cmpw rscratch1, zr\\t# EQ on successful write\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ storeIConditional also has acquire semantics, for no better reason\n-\/\/ than matching storeLConditional.  At the time of writing this\n-\/\/ comment storeIConditional was not used anywhere by AArch64.\n-instruct storeIConditional(indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreIConditional mem (Binary oldval newval)));\n-\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  format %{\n-    \"cmpxchgw rscratch1, $mem, $oldval, $newval, $mem\\t# if $mem == $oldval then $mem <-- $newval\"\n-    \"cmpw rscratch1, zr\\t# EQ on successful write\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgw_acq(mem, oldval, newval));\n-\n-  ins_pipe(pipe_slow);\n-%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":97,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -5433,57 +5433,0 @@\n-\/\/----------Conditional_store--------------------------------------------------\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flags (EQ) on success.\n-\n-\/\/ LoadP-locked.\n-instruct loadPLocked(iRegP dst, memoryex mem) %{\n-  match(Set dst (LoadPLocked mem));\n-  size(4);\n-  format %{ \"LDREX  $dst,$mem\" %}\n-  ins_encode %{\n-    __ ldrex($dst$$Register,$mem$$Address);\n-  %}\n-  ins_pipe(iload_mem);\n-%}\n-\n-instruct storePConditional( memoryex heap_top_ptr, iRegP oldval, iRegP newval, iRegI tmp, flagsRegP pcc ) %{\n-  predicate(_kids[1]->_kids[0]->_leaf->Opcode() == Op_LoadPLocked); \/\/ only works in conjunction with a LoadPLocked node\n-  match(Set pcc (StorePConditional heap_top_ptr (Binary oldval newval)));\n-  effect( TEMP tmp );\n-  size(8);\n-  format %{ \"STREX  $tmp,$newval,$heap_top_ptr\\n\\t\"\n-            \"CMP    $tmp, 0\" %}\n-  ins_encode %{\n-    __ strex($tmp$$Register, $newval$$Register, $heap_top_ptr$$Address);\n-    __ cmp($tmp$$Register, 0);\n-  %}\n-  ins_pipe( long_memory_op );\n-%}\n-\n-\/\/ Conditional-store of an intx value.\n-instruct storeXConditional( memoryex mem, iRegX oldval, iRegX newval, iRegX tmp, flagsReg icc ) %{\n-  match(Set icc (StoreIConditional mem (Binary oldval newval)));\n-  effect( TEMP tmp );\n-  size(28);\n-  format %{ \"loop: \\n\\t\"\n-            \"LDREX    $tmp, $mem\\t! If $oldval==[$mem] Then store $newval into [$mem], DOESN'T set $newval=[$mem] in any case\\n\\t\"\n-            \"XORS     $tmp,$tmp, $oldval\\n\\t\"\n-            \"STREX.eq $tmp, $newval, $mem\\n\\t\"\n-            \"CMP.eq   $tmp, 1 \\n\\t\"\n-            \"B.eq     loop \\n\\t\"\n-            \"TEQ      $tmp, 0\\n\\t\"\n-            \"membar   LoadStore|LoadLoad\" %}\n-  ins_encode %{\n-    Label loop;\n-    __ bind(loop);\n-    __ ldrex($tmp$$Register, $mem$$Address);\n-    __ eors($tmp$$Register, $tmp$$Register, $oldval$$Register);\n-    __ strex($tmp$$Register, $newval$$Register, $mem$$Address, eq);\n-    __ cmp($tmp$$Register, 1, eq);\n-    __ b(loop, eq);\n-    __ teq($tmp$$Register, 0);\n-    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadStore | MacroAssembler::LoadLoad), noreg);\n-  %}\n-  ins_pipe( long_memory_op );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":57,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -7456,56 +7456,0 @@\n-\/\/----------Conditional_store--------------------------------------------------\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flags (EQ) on success. Implemented with a CASA on Sparc.\n-\n-\/\/ As compareAndSwapL, but return flag register instead of boolean value in\n-\/\/ int register.\n-\/\/ Used by sun\/misc\/AtomicLongCSImpl.java.\n-\/\/ Mem_ptr must be a memory operand, else this node does not get\n-\/\/ Flag_needs_anti_dependence_check set by adlc. If this is not set this node\n-\/\/ can be rematerialized which leads to errors.\n-instruct storeLConditional_regP_regL_regL(flagsReg crx, indirect mem_ptr, iRegLsrc oldVal, iRegLsrc newVal, flagsRegCR0 cr0) %{\n-  match(Set crx (StoreLConditional mem_ptr (Binary oldVal newVal)));\n-  effect(TEMP cr0);\n-  format %{ \"CMPXCHGD if ($crx = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool\" %}\n-  ins_encode %{\n-    __ cmpxchgd($crx$$CondRegister, R0, $oldVal$$Register, $newVal$$Register, $mem_ptr$$Register,\n-                MacroAssembler::MemBarAcq, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, NULL, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ As compareAndSwapP, but return flag register instead of boolean value in\n-\/\/ int register.\n-\/\/ This instruction is matched if UseTLAB is off.\n-\/\/ Mem_ptr must be a memory operand, else this node does not get\n-\/\/ Flag_needs_anti_dependence_check set by adlc. If this is not set this node\n-\/\/ can be rematerialized which leads to errors.\n-instruct storePConditional_regP_regP_regP(flagsRegCR0 cr0, indirect mem_ptr, iRegPsrc oldVal, iRegPsrc newVal) %{\n-  match(Set cr0 (StorePConditional mem_ptr (Binary oldVal newVal)));\n-  ins_cost(2*MEMORY_REF_COST);\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-\n-  format %{ \"STDCX_  if ($cr0 = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool\" %}\n-  ins_encode %{\n-    __ stdcx_($newVal$$Register, $mem_ptr$$Register);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ Implement LoadPLocked. Must be ordered against changes of the memory location\n-\/\/ by storePConditional.\n-\/\/ Don't know whether this is ever used.\n-instruct loadPLocked(iRegPdst dst, memory mem) %{\n-  match(Set dst (LoadPLocked mem));\n-  ins_cost(2*MEMORY_REF_COST);\n-\n-  format %{ \"LDARX   $dst, $mem \\t\/\/ loadPLocked\\n\\t\" %}\n-  size(4);\n-  ins_encode %{\n-    __ ldarx($dst$$Register, $mem$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":56,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -5137,102 +5137,0 @@\n-\/\/ Intel and SPARC both implement Ideal Node LoadPLocked and\n-\/\/ Store{PIL}Conditional instructions using a normal load for the\n-\/\/ LoadPLocked and a CAS for the Store{PIL}Conditional.\n-\/\/\n-\/\/ The ideal code appears only to use LoadPLocked\/storePConditional as a\n-\/\/ pair to lock object allocations from Eden space when not using\n-\/\/ TLABs.\n-\/\/\n-\/\/ There does not appear to be a Load{IL}Locked Ideal Node and the\n-\/\/ Ideal code appears to use Store{IL}Conditional as an alias for CAS\n-\/\/ and to use StoreIConditional only for 32-bit and StoreLConditional\n-\/\/ only for 64-bit.\n-\/\/\n-\/\/ We implement LoadPLocked and storePConditional instructions using,\n-\/\/ respectively the RISCV hw load-reserve and store-conditional\n-\/\/ instructions. Whereas we must implement each of\n-\/\/ Store{IL}Conditional using a CAS which employs a pair of\n-\/\/ instructions comprising a load-reserve followed by a\n-\/\/ store-conditional.\n-\n-\n-\/\/ Locked-load (load reserved) of the current heap-top\n-\/\/ used when updating the eden heap top\n-\/\/ implemented using lr_d on RISCV64\n-instruct loadPLocked(iRegPNoSp dst, indirect mem)\n-%{\n-  match(Set dst (LoadPLocked mem));\n-\n-  ins_cost(ALU_COST * 2 + LOAD_COST);\n-\n-  format %{ \"lr.d $dst, $mem\\t# ptr load reserved, #@loadPLocked\" %}\n-\n-  ins_encode %{\n-    __ la(t0, Address(as_Register($mem$$base), $mem$$disp));\n-    __ lr_d($dst$$Register, t0, Assembler::aq);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ implemented using sc_d on RISCV64.\n-instruct storePConditional(memory heap_top_ptr, iRegP oldval, iRegP newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));\n-\n-  ins_cost(ALU_COST * 2 + STORE_COST);\n-\n-  format %{\n-    \"sc_d t1, $newval $heap_top_ptr,\\t# ptr store conditional, #@storePConditional\"\n-  %}\n-\n-  ins_encode %{\n-    __ la(t0, Address(as_Register($heap_top_ptr$$base), $heap_top_ptr$$disp));\n-    __ sc_d($cr$$Register, $newval$$Register, t0, Assembler::rl);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct storeLConditional(indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreLConditional mem (Binary oldval newval)));\n-\n-  ins_cost(LOAD_COST + STORE_COST + 2 * BRANCH_COST);\n-\n-  format %{\n-    \"cmpxchg t1, $mem, $oldval, $newval, $mem\\t# if $mem == $oldval then $mem <-- $newval\"\n-    \"xorr $cr, $cr, $oldval\\t# $cr == 0 on successful write, #@storeLConditional\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $cr$$Register);\n-    __ xorr($cr$$Register,$cr$$Register, $oldval$$Register);\n-  %}\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ storeIConditional also has acquire semantics, for no better reason\n-\/\/ than matching storeLConditional.\n-instruct storeIConditional(indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreIConditional mem (Binary oldval newval)));\n-\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2);\n-\n-  format %{\n-    \"cmpxchgw t1, $mem, $oldval, $newval, $mem\\t# if $mem == $oldval then $mem <-- $newval\"\n-    \"xorr $cr, $cr, $oldval\\t# $cr == 0 on successful write, #@storeIConditional\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $cr$$Register);\n-    __ xorr($cr$$Register,$cr$$Register, $oldval$$Register);\n-  %}\n-\n-  ins_pipe(pipe_slow);\n-%}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":102,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -5293,48 +5293,0 @@\n-\/\/----------Conditional_store--------------------------------------------------\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flags (EQ) on success.\n-\n-\/\/ Implement LoadPLocked. Must be ordered against changes of the memory location\n-\/\/ by storePConditional.\n-\/\/ Don't know whether this is ever used.\n-instruct loadPLocked(iRegP dst, memory mem) %{\n-  match(Set dst (LoadPLocked mem));\n-  ins_cost(MEMORY_REF_COST);\n-  size(Z_DISP3_SIZE);\n-  format %{ \"LG      $dst,$mem\\t # LoadPLocked\" %}\n-  opcode(LG_ZOPC, LG_ZOPC);\n-  ins_encode(z_form_rt_mem_opt(dst, mem));\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-\/\/ As compareAndSwapP, but return flag register instead of boolean value in\n-\/\/ int register.\n-\/\/ This instruction is matched if UseTLAB is off. Needed to pass\n-\/\/ option tests.  Mem_ptr must be a memory operand, else this node\n-\/\/ does not get Flag_needs_anti_dependence_check set by adlc. If this\n-\/\/ is not set this node can be rematerialized which leads to errors.\n-instruct storePConditional(indirect mem_ptr, rarg5RegP oldval, iRegP_N2P newval, flagsReg cr) %{\n-  match(Set cr (StorePConditional mem_ptr (Binary oldval newval)));\n-  effect(KILL oldval);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  format %{ \"storePConditional $oldval,$newval,$mem_ptr\" %}\n-  ins_encode(z_enc_casL(oldval, newval, mem_ptr));\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-\/\/ As compareAndSwapL, but return flag register instead of boolean value in\n-\/\/ int register.\n-\/\/ Used by sun\/misc\/AtomicLongCSImpl.java. Mem_ptr must be a memory\n-\/\/ operand, else this node does not get\n-\/\/ Flag_needs_anti_dependence_check set by adlc. If this is not set\n-\/\/ this node can be rematerialized which leads to errors.\n-instruct storeLConditional(indirect mem_ptr, rarg5RegL oldval, iRegL newval, flagsReg cr) %{\n-  match(Set cr (StoreLConditional mem_ptr (Binary oldval newval)));\n-  effect(KILL oldval);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  format %{ \"storePConditional $oldval,$newval,$mem_ptr\" %}\n-  ins_encode(z_enc_casL(oldval, newval, mem_ptr));\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -7260,55 +7260,0 @@\n-\/\/ Load-locked - same as a regular pointer load when used with compare-swap\n-instruct loadPLocked(eRegP dst, memory mem) %{\n-  match(Set dst (LoadPLocked mem));\n-\n-  ins_cost(125);\n-  format %{ \"MOV    $dst,$mem\\t# Load ptr. locked\" %}\n-  opcode(0x8B);\n-  ins_encode( OpcP, RegMem(dst,mem));\n-  ins_pipe( ialu_reg_mem );\n-%}\n-\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.\n-instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{\n-  match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));\n-  \/\/ EAX is killed if there is contention, but then it's also unused.\n-  \/\/ In the common case of no contention, EAX holds the new oop address.\n-  format %{ \"CMPXCHG $heap_top_ptr,$newval\\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr\" %}\n-  ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval,heap_top_ptr) );\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-\/\/ Conditional-store of an int value.\n-\/\/ ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG on Intel.\n-instruct storeIConditional( memory mem, eAXRegI oldval, rRegI newval, eFlagsReg cr ) %{\n-  match(Set cr (StoreIConditional mem (Binary oldval newval)));\n-  effect(KILL oldval);\n-  format %{ \"CMPXCHG $mem,$newval\\t# If EAX==$mem Then store $newval into $mem\" %}\n-  ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval, mem) );\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-\/\/ Conditional-store of a long value.\n-\/\/ ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG8 on Intel.\n-instruct storeLConditional( memory mem, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{\n-  match(Set cr (StoreLConditional mem (Binary oldval newval)));\n-  effect(KILL oldval);\n-  format %{ \"XCHG   EBX,ECX\\t# correct order for CMPXCHG8 instruction\\n\\t\"\n-            \"CMPXCHG8 $mem,ECX:EBX\\t# If EDX:EAX==$mem Then store ECX:EBX into $mem\\n\\t\"\n-            \"XCHG   EBX,ECX\"\n-  %}\n-  ins_encode %{\n-    \/\/ Note: we need to swap rbx, and rcx before and after the\n-    \/\/       cmpxchg8 instruction because the instruction uses\n-    \/\/       rcx as the high order word of the new value to store but\n-    \/\/       our register encoding uses rbx.\n-    __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));\n-    __ lock();\n-    __ cmpxchg8($mem$$Address);\n-    __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":55,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -8027,65 +8027,0 @@\n-\/\/ LoadP-locked same as a regular LoadP when used with compare-swap\n-instruct loadPLocked(rRegP dst, memory mem)\n-%{\n-  match(Set dst (LoadPLocked mem));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movq    $dst, $mem\\t# ptr locked\" %}\n-  ins_encode %{\n-    __ movq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n-%}\n-\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.\n-\n-instruct storePConditional(memory heap_top_ptr,\n-                           rax_RegP oldval, rRegP newval,\n-                           rFlagsReg cr)\n-%{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));\n-\n-  format %{ \"cmpxchgq $heap_top_ptr, $newval\\t# (ptr) \"\n-            \"If rax == $heap_top_ptr then store $newval into $heap_top_ptr\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgq($newval$$Register, $heap_top_ptr$$Address);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-\/\/ Conditional-store of an int value.\n-\/\/ ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.\n-instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreIConditional mem (Binary oldval newval)));\n-  effect(KILL oldval);\n-\n-  format %{ \"cmpxchgl $mem, $newval\\t# If rax == $mem then store $newval into $mem\" %}\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem(newval, mem),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem));\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-\/\/ Conditional-store of a long value.\n-\/\/ ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.\n-instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreLConditional mem (Binary oldval newval)));\n-  effect(KILL oldval);\n-\n-  format %{ \"cmpxchgq $mem, $newval\\t# If rax == $mem then store $newval into $mem\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgq($newval$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":65,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -265,1 +265,0 @@\n-  if( strcmp(opType,\"LoadPLocked\")==0 )  return Form::idealP;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3516,2 +3516,0 @@\n-    \"LoadPLocked\",\n-    \"StorePConditional\", \"StoreIConditional\", \"StoreLConditional\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2825,2 +2825,0 @@\n-               u->Opcode() == Op_StoreIConditional ||\n-               u->Opcode() == Op_StoreLConditional ||\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,0 @@\n-macro(LoadPLocked)\n@@ -340,3 +339,0 @@\n-macro(StorePConditional)\n-macro(StoreIConditional)\n-macro(StoreLConditional)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3240,1 +3240,0 @@\n-  case Op_StorePConditional:\n@@ -3243,2 +3242,0 @@\n-  case Op_StoreIConditional:\n-  case Op_StoreLConditional:\n@@ -3284,1 +3281,0 @@\n-  case Op_LoadPLocked:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -584,2 +584,1 @@\n-    case Op_LoadN:\n-    case Op_LoadPLocked: {\n+    case Op_LoadN: {\n@@ -638,1 +637,0 @@\n-    case Op_StorePConditional:\n@@ -741,2 +739,1 @@\n-    case Op_LoadN:\n-    case Op_LoadPLocked: {\n+    case Op_LoadN: {\n@@ -797,2 +794,1 @@\n-    case Op_StoreNKlass:\n-    case Op_StorePConditional:{\n+    case Op_StoreNKlass:{\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3438,4 +3438,1 @@\n-            ((bol->in(1)->Opcode() == Op_StorePConditional) ||\n-             (bol->in(1)->Opcode() == Op_StoreIConditional) ||\n-             (bol->in(1)->Opcode() == Op_StoreLConditional) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndExchangeB) ||\n+            ((bol->in(1)->Opcode() == Op_CompareAndExchangeB) ||\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2329,3 +2329,0 @@\n-    case Op_StorePConditional:\n-    case Op_StoreIConditional:\n-    case Op_StoreLConditional:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -799,13 +799,0 @@\n-\/\/------------------------------LoadPLockedNode---------------------------------\n-\/\/ Load-locked a pointer from memory (either object or array).\n-\/\/ On Sparc & Intel this is implemented as a normal pointer load.\n-\/\/ On PowerPC and friends it's a real load-locked.\n-class LoadPLockedNode : public LoadPNode {\n-public:\n-  LoadPLockedNode(Node *c, Node *mem, Node *adr, MemOrd mo)\n-    : LoadPNode(c, mem, adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, mo) {}\n-  virtual int Opcode() const;\n-  virtual int store_Opcode() const { return Op_StorePConditional; }\n-  virtual bool depends_only_on_test() const { return true; }\n-};\n-\n@@ -868,33 +855,0 @@\n-\/\/------------------------------StorePConditionalNode---------------------------\n-\/\/ Conditionally store pointer to memory, if no change since prior\n-\/\/ load-locked.  Sets flags for success or failure of the store.\n-class StorePConditionalNode : public LoadStoreConditionalNode {\n-public:\n-  StorePConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }\n-  virtual int Opcode() const;\n-  \/\/ Produces flags\n-  virtual uint ideal_reg() const { return Op_RegFlags; }\n-};\n-\n-\/\/------------------------------StoreIConditionalNode---------------------------\n-\/\/ Conditionally store int to memory, if no change since prior\n-\/\/ load-locked.  Sets flags for success or failure of the store.\n-class StoreIConditionalNode : public LoadStoreConditionalNode {\n-public:\n-  StoreIConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ii ) : LoadStoreConditionalNode(c, mem, adr, val, ii) { }\n-  virtual int Opcode() const;\n-  \/\/ Produces flags\n-  virtual uint ideal_reg() const { return Op_RegFlags; }\n-};\n-\n-\/\/------------------------------StoreLConditionalNode---------------------------\n-\/\/ Conditionally store long to memory, if no change since prior\n-\/\/ load-locked.  Sets flags for success or failure of the store.\n-class StoreLConditionalNode : public LoadStoreConditionalNode {\n-public:\n-  StoreLConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }\n-  virtual int Opcode() const;\n-  \/\/ Produces flags\n-  virtual uint ideal_reg() const { return Op_RegFlags; }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1656,1 +1656,0 @@\n-  declare_c2_type(LoadPLockedNode, LoadPNode)                             \\\n@@ -1659,2 +1658,0 @@\n-  declare_c2_type(StorePConditionalNode, LoadStoreNode)                   \\\n-  declare_c2_type(StoreLConditionalNode, LoadStoreNode)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}