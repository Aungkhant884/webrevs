{"files":[{"patch":"@@ -199,0 +199,8 @@\n+\t<LI><P><B>{@systemProperty http.keepAlive.time.server}<\/B> and\n+        <B>{@systemProperty http.keepAlive.time.proxy}<\/B> <\/P>\n+\t<P>These properties modify the behavior of the {@code HttpURLConnection} keep alive cache \n+        for idle server and proxy connections respectively. If the server (or proxy) has not specified \n+        a keep alive time, and this property is set, then idle connections will be closed after the \n+        specified number of seconds. Note, that if the property is set, and the server \n+        specifies a keep alive time in a \"Keep-Alive\" response header, then the time specified \n+        by the server (or proxy) is used.<\/P>\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,7 +125,7 @@\n-    \/**Idle timeout value, in milliseconds. Zero means infinity,\n-     * iff keepingAlive=true.\n-     * Unfortunately, we can't always believe this one.  If I'm connected\n-     * through a Netscape proxy to a server that sent me a keep-alive\n-     * time of 15 sec, the proxy unilaterally terminates my connection\n-     * after 5 sec.  So we have to hard code our effective timeout to\n-     * 4 sec for the case where we're using a proxy. *SIGH*\n+    \/*\n+     * The timeout if specified by the server. Following values possible\n+     *  0: the server specified no keep alive headers\n+     * -1: the server provided \"Connection: keep-alive\" but did not specify a\n+     *     a particular time in a \"Keep-Alive:\" headers\n+     * Positive values are the number of seconds specified by the server\n+     * in a \"Keep-Alive\" header\n@@ -901,1 +901,1 @@\n-                        keepAliveTimeout = p.findInt(\"timeout\", usingProxy?60:5);\n+                        keepAliveTimeout = p.findInt(\"timeout\", -1);\n@@ -1154,0 +1154,4 @@\n+    public boolean getUsingProxy() {\n+        return usingProxy;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+import sun.net.www.protocol.http.HttpURLConnection;\n+import sun.util.logging.PlatformLogger;\n@@ -57,0 +59,26 @@\n+    \/\/ Keep alive time set according to priority specified here:\n+    \/\/ 1. If server specifies a time with a Keep-Alive header\n+    \/\/ 2. If user specifies a time with system property below\n+    \/\/ 3. Default values which depend on proxy vs server and whether\n+    \/\/    a Connection: keep-alive header was sent by server\n+\n+    \/\/ name suffixed with \"server\" or \"proxy\"\n+    private static final String keepAliveProp = \"http.keepAlive.time.\";\n+\n+    private static final int userKeepAliveServer;\n+    private static final int userKeepAliveProxy;\n+\n+    static final PlatformLogger logger = HttpURLConnection.getHttpLogger();\n+\n+    @SuppressWarnings(\"removal\")\n+    static int getUserKeepAliveSeconds(String type) {\n+        int v = AccessController.doPrivileged(\n+            new GetIntegerAction(keepAliveProp+type, -1)).intValue();\n+        return v < -1 ? -1 : v;\n+    }\n+\n+    static {\n+        userKeepAliveServer = getUserKeepAliveSeconds(\"server\");\n+        userKeepAliveProxy = getUserKeepAliveSeconds(\"proxy\");\n+    }\n+\n@@ -130,2 +158,15 @@\n-                v = new ClientVector(keepAliveTimeout > 0 ?\n-                        keepAliveTimeout * 1000 : LIFETIME);\n+                if (keepAliveTimeout == 0) {\n+                    keepAliveTimeout = getUserKeepAlive(http.getUsingProxy());\n+                    if (keepAliveTimeout == -1) {\n+                        \/\/ same default for server and proxy\n+                        keepAliveTimeout = 5;\n+                    }\n+                } else if (keepAliveTimeout == -1) {\n+                    keepAliveTimeout = getUserKeepAlive(http.getUsingProxy());\n+                    if (keepAliveTimeout == -1) {\n+                        \/\/ different default for server and proxy\n+                        keepAliveTimeout = http.getUsingProxy() ? 60 : 5;\n+                    }\n+                }\n+                assert keepAliveTimeout > 0;\n+                v = new ClientVector(keepAliveTimeout * 1000);\n@@ -142,0 +183,5 @@\n+    \/\/ returns the keep alive set by user in system property or -1 if not set\n+    private static int getUserKeepAlive(boolean isProxy) {\n+        return isProxy ? userKeepAliveProxy : userKeepAliveServer;\n+    }\n+\n@@ -184,0 +230,1 @@\n+\n@@ -280,0 +327,5 @@\n+                    if (KeepAliveCache.logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+                        String msg = \"cached HttpClient was idle for \"\n+                                + Long.toString(currentTime - e.idleStartTime);\n+                        KeepAliveCache.logger.finest(msg);\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":54,"deletions":2,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @bug 8278067\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=30 KeepAliveProperty long\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=1 KeepAliveProperty short\n+ *\/\n+\n+import java.net.*;\n+import java.io.*;\n+import java.nio.charset.*;\n+import java.util.logging.*;\n+import jdk.test.lib.net.URIBuilder;\n+import static java.net.Proxy.NO_PROXY;\n+\n+public class KeepAliveProperty {\n+\n+    static volatile boolean pass = false;\n+\n+    static class Server extends Thread {\n+        ServerSocket server;\n+        Server (ServerSocket server) {\n+            super ();\n+            this.server = server;\n+        }\n+        void readAll (Socket s) throws IOException {\n+            byte[] buf = new byte [128];\n+            int c;\n+            String request = \"\";\n+            InputStream is = s.getInputStream ();\n+            while ((c=is.read(buf)) > 0) {\n+                request += new String(buf, 0, c, StandardCharsets.US_ASCII);\n+                if (request.contains(\"\\r\\n\\r\\n\")) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+\n+        Socket s = null;\n+        String BODY;\n+        String CLEN;\n+        PrintStream out;\n+\n+        public void run() {\n+            try {\n+                s = server.accept();\n+                readAll(s);\n+\n+                BODY = \"Hello world\";\n+                CLEN = \"Content-Length: \" + BODY.length() + \"\\r\\n\";\n+                out = new PrintStream(new BufferedOutputStream(s.getOutputStream() ));\n+\n+                \/* send the header *\/\n+                out.print(\"HTTP\/1.1 200 OK\\r\\n\");\n+                out.print(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+                out.print(CLEN);\n+                out.print(\"\\r\\n\");\n+                out.print(BODY);\n+                out.flush();\n+            } catch (Exception e) {\n+                pass = false;\n+                try {\n+                    if (s != null)\n+                        s.close();\n+                    server.close();\n+                } catch (IOException unused) {}\n+                return;\n+            }\n+\n+            \/\/ second request may legitimately fail\n+\n+            try {\n+                \/\/ wait for second request.\n+                readAll(s);\n+\n+                BODY = \"Goodbye world\";\n+                CLEN = \"Content-Length: \" + BODY.length() + \"\\r\\n\";\n+\n+                \/* send the header *\/\n+                out.print(\"HTTP\/1.1 200 OK\\r\\n\");\n+                out.print(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+                out.print(CLEN);\n+                out.print(\"\\r\\n\");\n+                out.print(BODY);\n+                out.flush();\n+                pass = true;\n+            } catch (Exception e) {\n+                pass = expectClose;\n+            } finally {\n+                try {\n+                    if (s != null)\n+                        s.close();\n+                    server.close();\n+                } catch (IOException unused) {}\n+            }\n+        }\n+    }\n+\n+    static String fetch(URL url) throws Exception {\n+        InputStream in = url.openConnection(NO_PROXY).getInputStream();\n+        String s = \"\";\n+        byte b[] = new byte[128];\n+        int n;\n+        do {\n+            n = in.read(b);\n+            if (n > 0)\n+                s += new String(b, 0, n, StandardCharsets.US_ASCII);\n+        } while (n > 0);\n+        in.close();\n+        return s;\n+    }\n+\n+    static volatile boolean expectClose;\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ exercise the logging code\n+        Logger logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+        logger.setLevel(Level.FINEST);\n+        ConsoleHandler h = new ConsoleHandler();\n+        h.setLevel(Level.FINEST);\n+        logger.addHandler(h);\n+\n+        expectClose = args[0].equals(\"short\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ServerSocket ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(loopback, 0));\n+        Server s = new Server(ss);\n+        s.start();\n+\n+        URL url = URIBuilder.newBuilder()\n+            .scheme(\"http\")\n+            .loopback()\n+            .port(ss.getLocalPort())\n+            .toURL();\n+        System.out.println(\"URL: \" + url);\n+\n+        if (!fetch(url).equals(\"Hello world\"))\n+            throw new RuntimeException(\"Failed on first request\");\n+\n+        \/\/ Wait a while to see if connection is closed\n+        Thread.sleep(3 * 1000);\n+\n+        try {\n+            if (!fetch(url).equals(\"Goodbye world\"))\n+                throw new RuntimeException(\"Failed on second request\");\n+        } catch (Exception e) {\n+            if (!expectClose)\n+                throw e;\n+        }\n+\n+        if (!pass)\n+            throw new RuntimeException(\"Failed in server\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveProperty.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}