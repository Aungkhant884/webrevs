{"files":[{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/safefetch.hpp\"\n@@ -76,0 +77,4 @@\n+#ifdef ASSERT\n+extern \"C\" void disnm(intptr_t p);\n+#endif\n+\n@@ -204,1 +209,9 @@\n-  assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n+  \/\/ assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n+#ifdef ASSERT\n+  address address_is = target_addr_for_insn(insn_addr);\n+  if (!(address_is == target)) {\n+    tty->print_cr(\"%p at %p should be %p\", address_is, insn_addr, target);\n+    disnm((intptr_t)insn_addr);\n+    assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n+  }\n+#endif\n@@ -247,0 +260,22 @@\n+\/\/ If insn1 and insn2 use the same register to form an address, either\n+\/\/ by an offsetted LDR or a simple ADD, return the offset. If the\n+\/\/ second instruction is an LDR, the offset may be scaled.\n+static bool offset_for(uint32_t insn1, uint32_t insn2, ptrdiff_t &byte_offset) {\n+  if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n+      Instruction_aarch64::extract(insn1, 4, 0) ==\n+      Instruction_aarch64::extract(insn2, 9, 5)) {\n+    \/\/ Load\/store register (unsigned immediate)\n+    byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+    uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n+    byte_offset <<= size;\n+    return true;\n+  } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n+             Instruction_aarch64::extract(insn1, 4, 0) ==\n+             Instruction_aarch64::extract(insn2, 4, 0)) {\n+    \/\/ add (immediate)\n+    byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -308,1 +343,6 @@\n-        \/\/\n+        \/\/   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+        \/\/       movk    Rx, #imm12<<32\n+        \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n+        \/\/   5 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+        \/\/       movk    Rx, #imm12<<32\n+        \/\/       add     Ry, Rx, #offset_in_page\n@@ -310,12 +350,2 @@\n-        if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n-            Instruction_aarch64::extract(insn, 4, 0) ==\n-            Instruction_aarch64::extract(insn2, 9, 5)) {\n-          \/\/ Load\/store register (unsigned immediate)\n-          uint32_t byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n-          uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n-          return address(target_page + (byte_offset << size));\n-        } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n-                   Instruction_aarch64::extract(insn, 4, 0) ==\n-                   Instruction_aarch64::extract(insn2, 4, 0)) {\n-          \/\/ add (immediate)\n-          uint32_t byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+        ptrdiff_t byte_offset;\n+        if (offset_for(insn, insn2, byte_offset)) {\n@@ -324,1 +354,1 @@\n-          \/\/ movk\n+          \/\/ adrp;movk\n@@ -331,2 +361,9 @@\n-          \/\/ Naked adrp, maybe.\n-          return (address)target_page;\n+          \/\/ We know the destination 4k page. Maybe we have a third\n+          \/\/ instruction.\n+          int *insn3_addr = &((int*)insn_addr)[2];\n+          uint32_t insn3 = SafeFetch32(insn3_addr, -1);\n+          if (offset_for(insn, insn3, byte_offset)) {\n+            return address(target_page + byte_offset);\n+          }\n+          \/\/ Naked adrp, maybe?\n+          return address(target_page);\n@@ -335,1 +372,1 @@\n-        \/\/ adr\n+        \/\/ adr, unshiifted\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":55,"deletions":18,"binary":false,"changes":73,"status":"modified"}]}