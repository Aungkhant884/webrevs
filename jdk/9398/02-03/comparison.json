{"files":[{"patch":"@@ -143,0 +143,3 @@\n+class RelocActions {\n+protected:\n+  typedef int (RelocActions::* reloc_insn)(address insn_addr, address &target, ptrdiff_t *offset);\n@@ -144,40 +147,28 @@\n-\/\/ Patch any kind of instruction; there may be several instructions.\n-\/\/ Return the total length (in bytes) of the instructions.\n-int MacroAssembler::pd_patch_instruction_size(address insn_addr, address target) {\n-  int instructions = 1;\n-  assert((uint64_t)target < (1ull << 48), \"48-bit overflow in address constant\");\n-  intptr_t offset = (target - insn_addr) >> 2;\n-  uint32_t insn = *(uint32_t*)insn_addr;\n-\n-  \/\/ branches, all kinds\n-  uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n-  switch(dispatch) {\n-    case 0b001010:\n-    case 0b001011: {\n-      \/\/ Unconditional branch (immediate)\n-      Instruction_aarch64::spatch(insn_addr, 25, 0, offset);\n-      break;\n-    }\n-    case 0b101010: \/\/ Conditional branch (immediate)\n-    case 0b011010: \/\/ Compare & branch (immediate)\n-    {\n-      Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n-      break;\n-    }\n-    case 0b011011: {\n-      \/\/ Test & branch (immediate)\n-      Instruction_aarch64::spatch(insn_addr, 18, 5, offset);\n-      break;\n-    }\n-    case 0b001100:\n-    case 0b001110:\n-    case 0b011100:\n-    case 0b011110:\n-    case 0b101100:\n-    case 0b101110:\n-    case 0b111100:\n-    case 0b111110: {\n-      \/\/ load\/store\n-      if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n-        \/\/ Load register (literal)\n-        Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+  virtual reloc_insn adrpMem() = 0;\n+  virtual reloc_insn adrpAdd() = 0;\n+  virtual reloc_insn adrpMovk() = 0;\n+\n+public:\n+  virtual int unconditionalBranch(address insn_addr, address &target) = 0;\n+  virtual int conditionalBranch(address insn_addr, address &target) = 0;\n+  virtual int testAndBranch(address insn_addr, address &target) = 0;\n+  virtual int loadStore(address insn_addr, address &target) = 0;\n+  virtual int adr(address insn_addr, address &target) = 0;\n+  virtual int adrp(address insn_addr, address &target, reloc_insn inner) = 0;\n+  virtual int adrpMem_impl(address insn_addr, address &target, ptrdiff_t *offset) = 0;\n+  virtual int adrpAdd_impl(address insn_addr, address &target, ptrdiff_t *offset) = 0;\n+  virtual int adrpMovk_impl(address insn_addr, address &target, ptrdiff_t *offset) = 0;\n+  virtual int immediate(address insn_addr, address &target) = 0;\n+  virtual void verify(address insn_addr, address &target) = 0;\n+\n+  int act(address insn_addr, address &target) {\n+    int instructions = 1;\n+    \/\/ assert((uint64_t)target < (1ull << 48), \"48-bit overflow in address constant\");\n+    \/\/ intptr_t offset = (target - insn_addr) >> 2;\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+\n+    uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n+    switch(dispatch) {\n+      case 0b001010:\n+      case 0b001011: {\n+        unconditionalBranch(insn_addr, target);\n@@ -185,3 +176,0 @@\n-      } else {\n-        \/\/ nothing to do\n-        assert(target == 0, \"did not expect to relocate target for polling page load\");\n@@ -189,54 +177,25 @@\n-      break;\n-    }\n-    case 0b001000:\n-    case 0b011000:\n-    case 0b101000:\n-    case 0b111000: {\n-      \/\/ adr\/adrp\n-      assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n-      \/\/ PC-rel. addressing\n-      offset = target-insn_addr;\n-      int shift = Instruction_aarch64::extract(insn, 31, 31);\n-      if (shift) {\n-        instructions = 2;\n-        uintptr_t dest = (uintptr_t)target;\n-        uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n-        uintptr_t adr_page = (uintptr_t)target >> 12;\n-        uint32_t offset_lo = dest & 0xfff;\n-        offset = adr_page - pc_page;\n-\n-        \/\/ We handle 3 types of PC-relative addressing\n-        \/\/   1 - adrp    Rx, target_page\n-        \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-        \/\/   2 - adrp    Rx, target_page\n-        \/\/       add     Ry, Rx, #offset_in_page\n-        \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-        \/\/       movk    Rx, #imm16<<32\n-        \/\/\n-        uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n-        if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n-            Instruction_aarch64::extract(insn, 4, 0) ==\n-            Instruction_aarch64::extract(insn2, 9, 5)) {\n-          \/\/ Load\/store register (unsigned immediate)\n-          uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n-          Instruction_aarch64::patch(insn_addr + sizeof (uint32_t),\n-                                     21, 10, offset_lo >> size);\n-          guarantee(((dest >> size) << size) == dest, \"misaligned target\");\n-          instructions = 2;\n-        } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n-                   Instruction_aarch64::extract(insn, 4, 0) ==\n-                   Instruction_aarch64::extract(insn2, 4, 0)) {\n-          \/\/ add (immediate)\n-          Instruction_aarch64::patch(insn_addr + sizeof (uint32_t),\n-                                     21, 10, offset_lo);\n-          instructions = 2;\n-        } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &&\n-                   Instruction_aarch64::extract(insn, 4, 0) ==\n-                   Instruction_aarch64::extract(insn2, 4, 0)) {\n-          \/\/ movk #imm16<<32\n-          Instruction_aarch64::patch(insn_addr + 4, 20, 5, (uintptr_t)target >> 32);\n-          uintptr_t dest = ((uintptr_t)target & 0xffffffffULL) | ((uintptr_t)insn_addr & 0xffff00000000ULL);\n-          uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n-          uintptr_t adr_page = (uintptr_t)dest >> 12;\n-          offset = adr_page - pc_page;\n-          instructions = 2;\n+      case 0b101010:   \/\/ Conditional branch (immediate)\n+      case 0b011010: { \/\/ Compare & branch (immediate)\n+          conditionalBranch(insn_addr, target);\n+          break;\n+      }\n+      case 0b011011: {\n+        testAndBranch(insn_addr, target);\n+        break;\n+      }\n+      case 0b001100:\n+      case 0b001110:\n+      case 0b011100:\n+      case 0b011110:\n+      case 0b101100:\n+      case 0b101110:\n+      case 0b111100:\n+      case 0b111110: {\n+        \/\/ load\/store\n+        if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n+          \/\/ Load register (literal)\n+          loadStore(insn_addr, target);\n+          break;\n+        } else {\n+          \/\/ nothing to do\n+          assert(target == 0, \"did not expect to relocate target for polling page load\");\n@@ -244,0 +203,44 @@\n+        break;\n+      }\n+      case 0b001000:\n+      case 0b011000:\n+      case 0b101000:\n+      case 0b111000: {\n+        \/\/ adr\/adrp\n+        assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+        int shift = Instruction_aarch64::extract(insn, 31, 31);\n+        if (shift) {\n+          uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+          if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n+              Instruction_aarch64::extract(insn, 4, 0) ==\n+              Instruction_aarch64::extract(insn2, 9, 5)) {\n+            adrp(insn_addr, target, adrpMem());\n+            instructions = 2;\n+          } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n+                     Instruction_aarch64::extract(insn, 4, 0) ==\n+                     Instruction_aarch64::extract(insn2, 4, 0)) {\n+            adrp(insn_addr, target, adrpAdd());\n+            instructions = 2;\n+          } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &&\n+                     Instruction_aarch64::extract(insn, 4, 0) ==\n+                     Instruction_aarch64::extract(insn2, 4, 0)) {\n+            adrp(insn_addr, target, adrpMovk());\n+            instructions = 2;\n+          } else {\n+            ShouldNotReachHere();\n+          }\n+        } else {\n+          adr(insn_addr, target);\n+        }\n+        break;\n+      }\n+      case 0b001001:\n+      case 0b011001:\n+      case 0b101001:\n+      case 0b111001: {\n+        immediate(insn_addr, target);\n+        instructions = 3;\n+        break;\n+      }\n+      default: {\n+        ShouldNotReachHere();\n@@ -245,6 +248,0 @@\n-      \/\/ Naked adrp: danger!\n-      int offset_lo = offset & 3;\n-      offset >>= 2;\n-      Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n-      Instruction_aarch64::patch(insn_addr, 30, 29, offset_lo);\n-      break;\n@@ -252,15 +249,57 @@\n-    case 0b001001:\n-    case 0b011001:\n-    case 0b101001:\n-    case 0b111001: {\n-      \/\/ immediate constant\n-      assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n-      uint64_t dest = (uint64_t)target;\n-      \/\/ Move wide constant\n-      assert(nativeInstruction_at(insn_addr+4)->is_movk(), \"wrong insns in patch\");\n-      assert(nativeInstruction_at(insn_addr+8)->is_movk(), \"wrong insns in patch\");\n-      Instruction_aarch64::patch(insn_addr, 20, 5, dest & 0xffff);\n-      Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest >>= 16) & 0xffff);\n-      Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest >>= 16) & 0xffff);\n-      instructions = 3;\n-      break;\n+\n+    verify(insn_addr, target);\n+    return instructions * NativeInstruction::instruction_size;\n+  }\n+};\n+\n+class Patcher : public RelocActions {\n+  virtual reloc_insn adrpMem() { return &RelocActions::adrpMem_impl; }\n+  virtual reloc_insn adrpAdd() { return &RelocActions::adrpAdd_impl; }\n+  virtual reloc_insn adrpMovk() { return &RelocActions::adrpMovk_impl; }\n+\n+public:\n+  virtual int unconditionalBranch(address insn_addr, address &target) {\n+    intptr_t offset = (target - insn_addr) >> 2;\n+    Instruction_aarch64::spatch(insn_addr, 25, 0, offset);\n+    return 1;\n+  }\n+  virtual int conditionalBranch(address insn_addr, address &target) {\n+    intptr_t offset = (target - insn_addr) >> 2;\n+    Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+    return 1;\n+  }\n+  virtual int testAndBranch(address insn_addr, address &target) {\n+    intptr_t offset = (target - insn_addr) >> 2;\n+    Instruction_aarch64::spatch(insn_addr, 18, 5, offset);\n+    return 1;\n+  }\n+  virtual int loadStore(address insn_addr, address &target) {\n+    intptr_t offset = (target - insn_addr) >> 2;\n+    Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+    return 1;\n+  }\n+  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n+    int instructions = 1;\n+#ifdef ASSERT\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+#endif\n+    \/\/ PC-rel. addressing\n+    ptrdiff_t offset = target - insn_addr;\n+    if (inner) {\n+      instructions = 2;\n+      uintptr_t dest = (uintptr_t)target;\n+      uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n+      uintptr_t adr_page = (uintptr_t)target >> 12;\n+      uint32_t offset_lo = dest & 0xfff;\n+      offset = adr_page - pc_page;\n+\n+      \/\/ We handle 3 types of PC-relative addressing\n+      \/\/   1 - adrp    Rx, target_page\n+      \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n+      \/\/   2 - adrp    Rx, target_page\n+      \/\/       add     Ry, Rx, #offset_in_page\n+      \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+      \/\/       movk    Rx, #imm16<<32\n+      \/\/\n+      instructions = ((*this).*inner)(insn_addr, target, NULL);\n@@ -268,2 +307,59 @@\n-    default: {\n-      ShouldNotReachHere();\n+\n+    int offset_lo = offset & 3;\n+    offset >>= 2;\n+    Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+    Instruction_aarch64::patch(insn_addr, 30, 29, offset_lo);\n+    return instructions;\n+  }\n+  virtual int adr(address insn_addr, address &target) {\n+#ifdef ASSERT\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+#endif\n+    \/\/ PC-rel. addressing\n+    ptrdiff_t offset = target - insn_addr;\n+    int offset_lo = offset & 3;\n+    offset >>= 2;\n+    Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+    Instruction_aarch64::patch(insn_addr, 30, 29, offset_lo);\n+    return 1;\n+  }\n+  virtual int adrpMem_impl(address insn_addr, address &target, ptrdiff_t *) {\n+    uintptr_t dest = (uintptr_t)target;\n+    int offset_lo = dest & 0xfff;\n+    uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+    uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n+    Instruction_aarch64::patch(insn_addr + sizeof (uint32_t), 21, 10, offset_lo >> size);\n+    guarantee(((dest >> size) << size) == dest, \"misaligned target\");\n+    return 2;\n+  }\n+  virtual int adrpAdd_impl(address insn_addr, address &target, ptrdiff_t *) {\n+    uintptr_t dest = (uintptr_t)target;\n+    int offset_lo = dest & 0xfff;\n+    Instruction_aarch64::patch(insn_addr + sizeof (uint32_t), 21, 10, offset_lo);\n+    return 2;\n+  }\n+  virtual int adrpMovk_impl(address insn_addr, address &target, ptrdiff_t *) {\n+    uintptr_t dest = (uintptr_t)target;\n+    Instruction_aarch64::patch(insn_addr + sizeof (uint32_t), 20, 5, (uintptr_t)target >> 32);\n+    return 2;\n+  }\n+  virtual int immediate(address insn_addr, address &target) {\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n+    uint64_t dest = (uint64_t)target;\n+    \/\/ Move wide constant\n+    assert(nativeInstruction_at(insn_addr+4)->is_movk(), \"wrong insns in patch\");\n+    assert(nativeInstruction_at(insn_addr+8)->is_movk(), \"wrong insns in patch\");\n+    Instruction_aarch64::patch(insn_addr, 20, 5, dest & 0xffff);\n+    Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest >>= 16) & 0xffff);\n+    Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest >>= 16) & 0xffff);\n+    return 3;\n+  }\n+  virtual void verify(address insn_addr, address &target) {\n+#ifdef ASSERT\n+    address address_is = MacroAssembler::target_addr_for_insn(insn_addr);\n+    if (!(address_is == target)) {\n+      tty->print_cr(\"%p at %p should be %p\", address_is, insn_addr, target);\n+      disnm((intptr_t)insn_addr);\n+      assert(address_is == target, \"should be\");\n@@ -271,0 +367,39 @@\n+#endif\n+  }\n+};\n+\n+#if 0\n+\/\/ If insn1 and insn2 use the same register to form an address, either\n+\/\/ by an offsetted LDR or a simple ADD, return the offset. If the\n+\/\/ second instruction is an LDR, the offset may be scaled.\n+static bool offset_for(uint32_t insn1, uint32_t insn2, ptrdiff_t &byte_offset) {\n+  if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n+      Instruction_aarch64::extract(insn1, 4, 0) ==\n+      Instruction_aarch64::extract(insn2, 9, 5)) {\n+    \/\/ Load\/store register (unsigned immediate)\n+    byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+    uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n+    byte_offset <<= size;\n+    return true;\n+  } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n+             Instruction_aarch64::extract(insn1, 4, 0) ==\n+             Instruction_aarch64::extract(insn2, 4, 0)) {\n+    \/\/ add (immediate)\n+    byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+    return true;\n+  }\n+  return false;\n+}\n+#endif\n+\n+class Reader : public RelocActions {\n+  virtual reloc_insn adrpMem() { return &RelocActions::adrpMem_impl; }\n+  virtual reloc_insn adrpAdd() { return &RelocActions::adrpAdd_impl; }\n+  virtual reloc_insn adrpMovk() { return &RelocActions::adrpMovk_impl; }\n+\n+public:\n+  virtual int loadStore(address insn_addr, address &target) {\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    intptr_t offset = Instruction_aarch64::sextract(insn, 23, 5);\n+    target = address(((uint64_t)insn_addr + (offset << 2)));\n+    return 1;\n@@ -272,1 +407,20 @@\n-  \/\/ assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n+  virtual int unconditionalBranch(address insn_addr, address &target) {\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    intptr_t offset = Instruction_aarch64::sextract(insn, 25, 0);\n+    target = address(((uint64_t)insn_addr + (offset << 2)));\n+    return 1;\n+  }\n+  virtual int conditionalBranch(address insn_addr, address &target) {\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    intptr_t offset = Instruction_aarch64::sextract(insn, 23, 5);\n+    target = address(((uint64_t)insn_addr + (offset << 2)));\n+    return 1;\n+  }\n+  virtual int testAndBranch(address insn_addr, address &target) {\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    intptr_t offset = Instruction_aarch64::sextract(insn, 18, 5);\n+    target = address(((uint64_t)insn_addr + (offset << 2)));\n+    return 1;\n+  }\n+  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n+    int instructions = 1;\n@@ -274,5 +428,28 @@\n-  address address_is = target_addr_for_insn(insn_addr);\n-  if (!(address_is == target)) {\n-    tty->print_cr(\"%p at %p should be %p\", address_is, insn_addr, target);\n-    disnm((intptr_t)insn_addr);\n-    assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+#endif\n+    \/\/ PC-rel. addressing\n+    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n+    \/\/ if (inner) {\n+      int shift = 12;\n+      offset <<= shift;\n+      uint64_t target_page = ((uint64_t)insn_addr) + offset;\n+      target_page &= ((uint64_t)-1) << shift;\n+      uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+      target = address(target_page);\n+      ptrdiff_t byte_offset;\n+      ((*this).*inner)(insn_addr, target, &byte_offset);\n+      instructions = 2;\n+    \/\/ } else {\n+    \/\/   target = address((uint64_t)insn_addr + offset);\n+    \/\/ }\n+    return instructions;\n+  }\n+  virtual int adr(address insn_addr, address &target) {\n+    \/\/ PC-rel. addressing\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n+    target = address((uint64_t)insn_addr + offset);\n+    return 1;\n@@ -280,0 +457,31 @@\n+  virtual int adrpMem_impl(address insn_addr, address &target, ptrdiff_t *offset) {\n+    uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+    \/\/ Load\/store register (unsigned immediate)\n+    ptrdiff_t byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+    uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n+    byte_offset <<= size;\n+    target += byte_offset;\n+    return 2;\n+  }\n+  virtual int adrpAdd_impl(address insn_addr, address &target, ptrdiff_t *offset) {\n+    uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+    \/\/ add (immediate)\n+    ptrdiff_t byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+    target += byte_offset;\n+    return 2;\n+  }\n+  virtual int adrpMovk_impl(address insn_addr, address &target, ptrdiff_t *offset) {\n+    uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+    uint64_t dest = uint64_t(target);\n+    dest = (dest & 0xffffffff) |\n+      ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) << 32);\n+    target = address(dest);\n+\n+#if 0\n+    \/\/ We know the destination 4k page. Maybe we have a third\n+    \/\/ instruction.\n+    int *insn3_addr = &((int*)insn_addr)[2];\n+    uint32_t insn3 = SafeFetch32(insn3_addr, -1);\n+    if (offset_for(insn, insn3, byte_offset)) {\n+      return address(target_page + byte_offset);\n+    }\n@@ -281,1 +489,290 @@\n-  return instructions * NativeInstruction::instruction_size;\n+    return 2;\n+  }\n+  virtual int immediate(address insn_addr, address &target) {\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n+    \/\/ immediate constant\n+    assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n+    uint32_t *insns = (uint32_t *)insn_addr;\n+    \/\/ Move wide constant: movz, movk, movk.  See movptr().\n+    assert(nativeInstruction_at(insns+1)->is_movk(), \"wrong insns in patch\");\n+    assert(nativeInstruction_at(insns+2)->is_movk(), \"wrong insns in patch\");\n+    target = address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n+                 + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n+                 + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n+\n+    assert(nativeInstruction_at(insn_addr+4)->is_movk(), \"wrong insns in patch\");\n+    assert(nativeInstruction_at(insn_addr+8)->is_movk(), \"wrong insns in patch\");\n+\n+    return 3;\n+  }\n+  virtual void verify(address insn_addr, address &target) {\n+  }\n+};\n+\n+static Reader reader;\n+\n+address MacroAssembler::target_addr_for_insn(address insn_addr, uint32_t insn) {\n+  address target;\n+  reader.act(insn_addr, target);\n+  return target;\n+}\n+\n+\/\/ address MacroAssembler::target_addr_for_insn(address insn_addr, uint32_t insn) {\n+\/\/   \/\/ branches, all kinds\n+\/\/   uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n+\/\/   intptr_t offset = 0;\n+\n+\/\/   switch(dispatch) {\n+\/\/     case 0b001100:\n+\/\/     case 0b001110:\n+\/\/     case 0b011100:\n+\/\/     case 0b011110:\n+\/\/     case 0b101100:\n+\/\/     case 0b101110:\n+\/\/     case 0b111100:\n+\/\/     case 0b111110: {\n+\/\/       \/\/ load\/store\n+\/\/       if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n+\/\/         \/\/ Load register (literal)\n+\/\/         offset = Instruction_aarch64::sextract(insn, 23, 5);\n+\/\/         return address(((uint64_t)insn_addr + (offset << 2)));\n+\/\/         break;\n+\/\/       }\n+\/\/       ShouldNotReachHere();\n+\/\/     }\n+\/\/     case 0b001010:\n+\/\/     case 0b001011: {\n+\/\/       \/\/ Unconditional branch (immediate)\n+\/\/       offset = Instruction_aarch64::sextract(insn, 25, 0);\n+\/\/       break;\n+\/\/     }\n+\/\/     case 0b101010: \/\/ Conditional branch (immediate)\n+\/\/     case 0b011010: \/\/ Compare & branch (immediate)\n+\/\/     {\n+\/\/       offset = Instruction_aarch64::sextract(insn, 23, 5);\n+\/\/       break;\n+\/\/     }\n+\/\/     case 0b011011: {\n+\/\/       \/\/ Test & branch (immediate)\n+\/\/       offset = Instruction_aarch64::sextract(insn, 18, 5);\n+\/\/       break;\n+\/\/     }\n+\/\/     case 0b001000:\n+\/\/     case 0b011000:\n+\/\/     case 0b101000:\n+\/\/     case 0b111000: {\n+\/\/       \/\/ adr\/adrp\n+\n+\/\/       \/\/ PC-rel. addressing\n+\/\/       offset = Instruction_aarch64::extract(insn, 30, 29);\n+\/\/       offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n+\/\/       int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;\n+\/\/       if (shift) {\n+\/\/         \/\/ adrp\n+\/\/         offset <<= shift;\n+\/\/         uint64_t target_page = ((uint64_t)insn_addr) + offset;\n+\/\/         target_page &= ((uint64_t)-1) << shift;\n+\/\/         \/\/ Return the target address for the following sequences\n+\/\/         \/\/   1 - adrp    Rx, target_page\n+\/\/         \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n+\/\/         \/\/   2 - adrp    Rx, target_page\n+\/\/         \/\/       add     Ry, Rx, #offset_in_page\n+\/\/         \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+\/\/         \/\/       movk    Rx, #imm12<<32\n+\/\/         \/\/   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+\/\/         \/\/       movk    Rx, #imm12<<32\n+\/\/         \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n+\/\/         \/\/   5 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+\/\/         \/\/       movk    Rx, #imm12<<32\n+\/\/         \/\/       add     Ry, Rx, #offset_in_page\n+\/\/         uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+\/\/         ptrdiff_t byte_offset;\n+\/\/         if (offset_for(insn, insn2, byte_offset)) {\n+\/\/           return address(target_page + byte_offset);\n+\/\/         } else {\n+\/\/           \/\/ adrp;movk\n+\/\/           if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &&\n+\/\/               Instruction_aarch64::extract(insn, 4, 0) ==\n+\/\/               Instruction_aarch64::extract(insn2, 4, 0)) {\n+\/\/             target_page = (target_page & 0xffffffff) |\n+\/\/               ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) << 32);\n+\/\/           }\n+\/\/           \/\/ We know the destination 4k page. Maybe we have a third\n+\/\/           \/\/ instruction.\n+\/\/           int *insn3_addr = &((int*)insn_addr)[2];\n+\/\/           uint32_t insn3 = SafeFetch32(insn3_addr, -1);\n+\/\/           if (offset_for(insn, insn3, byte_offset)) {\n+\/\/             return address(target_page + byte_offset);\n+\/\/           }\n+\/\/           \/\/ Naked adrp, maybe?\n+\/\/           return address(target_page);\n+\/\/         }\n+\/\/       } else {\n+\/\/         \/\/ adr, unshiifted\n+\/\/         \/\/ Offset is in bytes\n+\/\/         return address((uint64_t)insn_addr + offset);\n+\/\/       }\n+\/\/     }\n+\/\/     case 0b001001:\n+\/\/     case 0b011001:\n+\/\/     case 0b101001:\n+\/\/     case 0b111001: {\n+\/\/       \/\/ immediate constant\n+\/\/       assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n+\/\/       uint32_t *insns = (uint32_t *)insn_addr;\n+\/\/       \/\/ Move wide constant: movz, movk, movk.  See movptr().\n+\/\/       assert(nativeInstruction_at(insns+1)->is_movk(), \"wrong insns in patch\");\n+\/\/       assert(nativeInstruction_at(insns+2)->is_movk(), \"wrong insns in patch\");\n+\/\/       return address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n+\/\/                      + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n+\/\/                      + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n+\/\/     }\n+\/\/     default:\n+\/\/       ShouldNotReachHere();\n+\/\/     }\n+\/\/   return address(((uint64_t)insn_addr + (offset << 2)));\n+\/\/ }\n+\n+static Patcher patcher;\n+\n+\/\/ Patch any kind of instruction; there may be several instructions.\n+\/\/ Return the total length (in bytes) of the instructions.\n+int MacroAssembler::pd_patch_instruction_size(address insn_addr, address target) {\n+\n+  return patcher.act(insn_addr, target);\n+\n+\/\/   int instructions = 1;\n+\/\/   assert((uint64_t)target < (1ull << 48), \"48-bit overflow in address constant\");\n+\/\/   intptr_t offset = (target - insn_addr) >> 2;\n+\/\/   uint32_t insn = *(uint32_t*)insn_addr;\n+\n+\/\/   uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n+\/\/   switch(dispatch) {\n+\/\/     case 0b001010:\n+\/\/     case 0b001011: {\n+\/\/       \/\/ Unconditional branch (immediate)\n+\/\/       Instruction_aarch64::spatch(insn_addr, 25, 0, offset);\n+\/\/       break;\n+\/\/     }\n+\/\/     case 0b101010: \/\/ Conditional branch (immediate)\n+\/\/     case 0b011010: \/\/ Compare & branch (immediate)\n+\/\/     {\n+\/\/       Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+\/\/       break;\n+\/\/     }\n+\/\/     case 0b011011: {\n+\/\/       \/\/ Test & branch (immediate)\n+\/\/       Instruction_aarch64::spatch(insn_addr, 18, 5, offset);\n+\/\/       break;\n+\/\/     }\n+\/\/     case 0b001100:\n+\/\/     case 0b001110:\n+\/\/     case 0b011100:\n+\/\/     case 0b011110:\n+\/\/     case 0b101100:\n+\/\/     case 0b101110:\n+\/\/     case 0b111100:\n+\/\/     case 0b111110: {\n+\/\/       \/\/ load\/store\n+\/\/       if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n+\/\/         \/\/ Load register (literal)\n+\/\/         Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+\/\/         break;\n+\/\/       } else {\n+\/\/         \/\/ nothing to do\n+\/\/         assert(target == 0, \"did not expect to relocate target for polling page load\");\n+\/\/       }\n+\/\/       break;\n+\/\/     }\n+\/\/     case 0b001000:\n+\/\/     case 0b011000:\n+\/\/     case 0b101000:\n+\/\/     case 0b111000: {\n+\/\/       \/\/ adr\/adrp\n+\/\/       assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+\/\/       \/\/ PC-rel. addressing\n+\/\/       offset = target-insn_addr;\n+\/\/       int shift = Instruction_aarch64::extract(insn, 31, 31);\n+\/\/       if (shift) {\n+\/\/         instructions = 2;\n+\/\/         uintptr_t dest = (uintptr_t)target;\n+\/\/         uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n+\/\/         uintptr_t adr_page = (uintptr_t)target >> 12;\n+\/\/         uint32_t offset_lo = dest & 0xfff;\n+\/\/         offset = adr_page - pc_page;\n+\n+\/\/         \/\/ We handle 3 types of PC-relative addressing\n+\/\/         \/\/   1 - adrp    Rx, target_page\n+\/\/         \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n+\/\/         \/\/   2 - adrp    Rx, target_page\n+\/\/         \/\/       add     Ry, Rx, #offset_in_page\n+\/\/         \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+\/\/         \/\/       movk    Rx, #imm16<<32\n+\/\/         \/\/\n+\/\/         uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+\/\/         if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n+\/\/             Instruction_aarch64::extract(insn, 4, 0) ==\n+\/\/             Instruction_aarch64::extract(insn2, 9, 5)) {\n+\/\/           \/\/ Load\/store register (unsigned immediate)\n+\/\/           uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n+\/\/           Instruction_aarch64::patch(insn_addr + sizeof (uint32_t),\n+\/\/                                      21, 10, offset_lo >> size);\n+\/\/           guarantee(((dest >> size) << size) == dest, \"misaligned target\");\n+\/\/           instructions = 2;\n+\/\/         } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n+\/\/                    Instruction_aarch64::extract(insn, 4, 0) ==\n+\/\/                    Instruction_aarch64::extract(insn2, 4, 0)) {\n+\/\/           \/\/ add (immediate)\n+\/\/           Instruction_aarch64::patch(insn_addr + sizeof (uint32_t),\n+\/\/                                      21, 10, offset_lo);\n+\/\/           instructions = 2;\n+\/\/         } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &&\n+\/\/                    Instruction_aarch64::extract(insn, 4, 0) ==\n+\/\/                    Instruction_aarch64::extract(insn2, 4, 0)) {\n+\/\/           \/\/ movk #imm16<<32\n+\/\/           Instruction_aarch64::patch(insn_addr + 4, 20, 5, (uintptr_t)target >> 32);\n+\/\/           uintptr_t dest = ((uintptr_t)target & 0xffffffffULL) | ((uintptr_t)insn_addr & 0xffff00000000ULL);\n+\/\/           uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n+\/\/           uintptr_t adr_page = (uintptr_t)dest >> 12;\n+\/\/           offset = adr_page - pc_page;\n+\/\/           instructions = 2;\n+\/\/         }\n+\/\/       }\n+\/\/       \/\/ Naked adrp: danger!\n+\/\/       int offset_lo = offset & 3;\n+\/\/       offset >>= 2;\n+\/\/       Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+\/\/       Instruction_aarch64::patch(insn_addr, 30, 29, offset_lo);\n+\/\/       break;\n+\/\/     }\n+\/\/     case 0b001001:\n+\/\/     case 0b011001:\n+\/\/     case 0b101001:\n+\/\/     case 0b111001: {\n+\/\/       \/\/ immediate constant\n+\/\/       assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n+\/\/       uint64_t dest = (uint64_t)target;\n+\/\/       \/\/ Move wide constant\n+\/\/       assert(nativeInstruction_at(insn_addr+4)->is_movk(), \"wrong insns in patch\");\n+\/\/       assert(nativeInstruction_at(insn_addr+8)->is_movk(), \"wrong insns in patch\");\n+\/\/       Instruction_aarch64::patch(insn_addr, 20, 5, dest & 0xffff);\n+\/\/       Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest >>= 16) & 0xffff);\n+\/\/       Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest >>= 16) & 0xffff);\n+\/\/       instructions = 3;\n+\/\/       break;\n+\/\/     }\n+\/\/     default: {\n+\/\/       ShouldNotReachHere();\n+\/\/     }\n+\/\/   }\n+\/\/   \/\/ assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n+\/\/ #ifdef ASSERT\n+\/\/   address address_is = target_addr_for_insn(insn_addr);\n+\/\/   if (!(address_is == target)) {\n+\/\/     tty->print_cr(\"%p at %p should be %p\", address_is, insn_addr, target);\n+\/\/     disnm((intptr_t)insn_addr);\n+\/\/     assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n+\/\/   }\n+\/\/ #endif\n+\/\/   return instructions * NativeInstruction::instruction_size;\n@@ -323,137 +820,0 @@\n-\/\/ If insn1 and insn2 use the same register to form an address, either\n-\/\/ by an offsetted LDR or a simple ADD, return the offset. If the\n-\/\/ second instruction is an LDR, the offset may be scaled.\n-static bool offset_for(uint32_t insn1, uint32_t insn2, ptrdiff_t &byte_offset) {\n-  if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n-      Instruction_aarch64::extract(insn1, 4, 0) ==\n-      Instruction_aarch64::extract(insn2, 9, 5)) {\n-    \/\/ Load\/store register (unsigned immediate)\n-    byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n-    uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n-    byte_offset <<= size;\n-    return true;\n-  } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n-             Instruction_aarch64::extract(insn1, 4, 0) ==\n-             Instruction_aarch64::extract(insn2, 4, 0)) {\n-    \/\/ add (immediate)\n-    byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n-    return true;\n-  }\n-  return false;\n-}\n-\n-address MacroAssembler::target_addr_for_insn(address insn_addr, uint32_t insn) {\n-  \/\/ branches, all kinds\n-  uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n-  intptr_t offset = 0;\n-  switch(dispatch) {\n-    case 0b001100:\n-    case 0b001110:\n-    case 0b011100:\n-    case 0b011110:\n-    case 0b101100:\n-    case 0b101110:\n-    case 0b111100:\n-    case 0b111110: {\n-      \/\/ load\/store\n-      if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n-        \/\/ Load register (literal)\n-        offset = Instruction_aarch64::sextract(insn, 23, 5);\n-        return address(((uint64_t)insn_addr + (offset << 2)));\n-        break;\n-      }\n-      ShouldNotReachHere();\n-    }\n-    case 0b001010:\n-    case 0b001011: {\n-      \/\/ Unconditional branch (immediate)\n-      offset = Instruction_aarch64::sextract(insn, 25, 0);\n-      break;\n-    }\n-    case 0b101010: \/\/ Conditional branch (immediate)\n-    case 0b011010: \/\/ Compare & branch (immediate)\n-    {\n-      offset = Instruction_aarch64::sextract(insn, 23, 5);\n-      break;\n-    }\n-    case 0b011011: {\n-      \/\/ Test & branch (immediate)\n-      offset = Instruction_aarch64::sextract(insn, 18, 5);\n-      break;\n-    }\n-    case 0b001000:\n-    case 0b011000:\n-    case 0b101000:\n-    case 0b111000: {\n-      \/\/ adr\/adrp\n-\n-      \/\/ PC-rel. addressing\n-      offset = Instruction_aarch64::extract(insn, 30, 29);\n-      offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n-      int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;\n-      if (shift) {\n-        \/\/ adrp\n-        offset <<= shift;\n-        uint64_t target_page = ((uint64_t)insn_addr) + offset;\n-        target_page &= ((uint64_t)-1) << shift;\n-        \/\/ Return the target address for the following sequences\n-        \/\/   1 - adrp    Rx, target_page\n-        \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-        \/\/   2 - adrp    Rx, target_page\n-        \/\/       add     Ry, Rx, #offset_in_page\n-        \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-        \/\/       movk    Rx, #imm12<<32\n-        \/\/   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-        \/\/       movk    Rx, #imm12<<32\n-        \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-        \/\/   5 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-        \/\/       movk    Rx, #imm12<<32\n-        \/\/       add     Ry, Rx, #offset_in_page\n-        uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n-        ptrdiff_t byte_offset;\n-        if (offset_for(insn, insn2, byte_offset)) {\n-          return address(target_page + byte_offset);\n-        } else {\n-          \/\/ adrp;movk\n-          if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &&\n-              Instruction_aarch64::extract(insn, 4, 0) ==\n-              Instruction_aarch64::extract(insn2, 4, 0)) {\n-            target_page = (target_page & 0xffffffff) |\n-              ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) << 32);\n-          }\n-          \/\/ We know the destination 4k page. Maybe we have a third\n-          \/\/ instruction.\n-          int *insn3_addr = &((int*)insn_addr)[2];\n-          uint32_t insn3 = SafeFetch32(insn3_addr, -1);\n-          if (offset_for(insn, insn3, byte_offset)) {\n-            return address(target_page + byte_offset);\n-          }\n-          \/\/ Naked adrp, maybe?\n-          return address(target_page);\n-        }\n-      } else {\n-        \/\/ adr, unshiifted\n-        \/\/ Offset is in bytes\n-        return address((uint64_t)insn_addr + offset);\n-      }\n-    }\n-    case 0b001001:\n-    case 0b011001:\n-    case 0b101001:\n-    case 0b111001: {\n-      \/\/ immediate constant\n-      assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n-      uint32_t *insns = (uint32_t *)insn_addr;\n-      \/\/ Move wide constant: movz, movk, movk.  See movptr().\n-      assert(nativeInstruction_at(insns+1)->is_movk(), \"wrong insns in patch\");\n-      assert(nativeInstruction_at(insns+2)->is_movk(), \"wrong insns in patch\");\n-      return address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n-                     + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n-                     + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n-    }\n-    default:\n-      ShouldNotReachHere();\n-    }\n-  return address(((uint64_t)insn_addr + (offset << 2)));\n-}\n-\n@@ -462,1 +822,1 @@\n-    return 0;\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":625,"deletions":265,"binary":false,"changes":890,"status":"modified"}]}