{"files":[{"patch":"@@ -158,4 +158,0 @@\n-void Assembler::adrp(Register reg1, const Address &dest, uint64_t &byte_offset) {\n-  ShouldNotReachHere();\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-  static void patch(address a, int msb, int lsb, uint64_t val) {\n+  static ALWAYSINLINE void patch(address a, int msb, int lsb, uint64_t val) {\n@@ -721,1 +721,1 @@\n-  void adrp(Register Rd, const Address &dest, uint64_t &offset);\n+  void adrp(Register Rd, const Address &dest, uint64_t &offset) = delete;\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2701,1 +2701,1 @@\n-  if (offset) __ add(res, res, offset);\n+  __ add(res, res, offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,1 +173,6 @@\n-  lea(rdispatch, Address(rdispatch, offset));\n+  \/\/ Use add() here after ARDP, rather than lea().\n+  \/\/ lea() does not generate anything if its offset is zero.\n+  \/\/ However, relocs expect to find either an ADD or a load\/store\n+  \/\/ insn after an ADRP.  add() always generates an ADD insn, even\n+  \/\/ for add(Rn, Rn, 0).\n+  add(rdispatch, rdispatch, offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-int MacroAssembler::pd_patch_instruction_size(address branch, address target) {\n+int MacroAssembler::pd_patch_instruction_size(address insn_addr, address target) {\n@@ -81,57 +81,52 @@\n-  intptr_t offset = (target - branch) >> 2;\n-  unsigned insn = *(unsigned*)branch;\n-  if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n-    \/\/ Load register (literal)\n-    Instruction_aarch64::spatch(branch, 23, 5, offset);\n-  } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {\n-    \/\/ Unconditional branch (immediate)\n-    Instruction_aarch64::spatch(branch, 25, 0, offset);\n-  } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {\n-    \/\/ Conditional branch (immediate)\n-    Instruction_aarch64::spatch(branch, 23, 5, offset);\n-  } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {\n-    \/\/ Compare & branch (immediate)\n-    Instruction_aarch64::spatch(branch, 23, 5, offset);\n-  } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {\n-    \/\/ Test & branch (immediate)\n-    Instruction_aarch64::spatch(branch, 18, 5, offset);\n-  } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {\n-    \/\/ PC-rel. addressing\n-    offset = target-branch;\n-    int shift = Instruction_aarch64::extract(insn, 31, 31);\n-    if (shift) {\n-      uint64_t dest = (uint64_t)target;\n-      uint64_t pc_page = (uint64_t)branch >> 12;\n-      uint64_t adr_page = (uint64_t)target >> 12;\n-      unsigned offset_lo = dest & 0xfff;\n-      offset = adr_page - pc_page;\n-\n-      \/\/ We handle 4 types of PC relative addressing\n-      \/\/   1 - adrp    Rx, target_page\n-      \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-      \/\/   2 - adrp    Rx, target_page\n-      \/\/       add     Ry, Rx, #offset_in_page\n-      \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-      \/\/       movk    Rx, #imm16<<32\n-      \/\/   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-      \/\/ In the first 3 cases we must check that Rx is the same in the adrp and the\n-      \/\/ subsequent ldr\/str, add or movk instruction. Otherwise we could accidentally end\n-      \/\/ up treating a type 4 relocation as a type 1, 2 or 3 just because it happened\n-      \/\/ to be followed by a random unrelated ldr\/str, add or movk instruction.\n-      \/\/\n-      unsigned insn2 = ((unsigned*)branch)[1];\n-      if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n-                Instruction_aarch64::extract(insn, 4, 0) ==\n-                        Instruction_aarch64::extract(insn2, 9, 5)) {\n-        \/\/ Load\/store register (unsigned immediate)\n-        unsigned size = Instruction_aarch64::extract(insn2, 31, 30);\n-        Instruction_aarch64::patch(branch + sizeof (unsigned),\n-                                    21, 10, offset_lo >> size);\n-        guarantee(((dest >> size) << size) == dest, \"misaligned target\");\n-        instructions = 2;\n-      } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n-                Instruction_aarch64::extract(insn, 4, 0) ==\n-                        Instruction_aarch64::extract(insn2, 4, 0)) {\n-        \/\/ add (immediate)\n-        Instruction_aarch64::patch(branch + sizeof (unsigned),\n-                                   21, 10, offset_lo);\n+  intptr_t offset = (target - insn_addr) >> 2;\n+  uint32_t insn = *(uint32_t*)insn_addr;\n+\n+  \/\/ branches, all kinds\n+  uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n+  switch(dispatch) {\n+    case 0b001010:\n+    case 0b001011: {\n+      \/\/ Unconditional branch (immediate)\n+      Instruction_aarch64::spatch(insn_addr, 25, 0, offset);\n+      break;\n+    }\n+    case 0b101010: \/\/ Compare & branch (immediate)\n+    case 0b011010: \/\/ Conditional branch (immediate)\n+    {\n+      Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+      break;\n+    }\n+    case 0b011011: {\n+      \/\/ Test & branch (immediate)\n+      Instruction_aarch64::spatch(insn_addr, 18, 5, offset);\n+      break;\n+    }\n+    case 0b001100:\n+    case 0b001110:\n+    case 0b011100:\n+    case 0b011110:\n+    case 0b101100:\n+    case 0b101110:\n+    case 0b111100:\n+    case 0b111110: {\n+      \/\/ load\/store\n+      if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n+        \/\/ Load register (literal)\n+        Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+        break;\n+      } else {\n+        \/\/ nothing to do\n+        assert(target == 0, \"did not expect to relocate target for polling page load\");\n+      }\n+      break;\n+    }\n+    case 0b001000:\n+    case 0b011000:\n+    case 0b101000:\n+    case 0b111000: {\n+      \/\/ adr\/adrp\n+      assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+      \/\/ PC-rel. addressing\n+      offset = target-insn_addr;\n+      int shift = Instruction_aarch64::extract(insn, 31, 31);\n+      if (shift) {\n@@ -139,8 +134,4 @@\n-      } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &&\n-                   Instruction_aarch64::extract(insn, 4, 0) ==\n-                     Instruction_aarch64::extract(insn2, 4, 0)) {\n-        \/\/ movk #imm16<<32\n-        Instruction_aarch64::patch(branch + 4, 20, 5, (uint64_t)target >> 32);\n-        uintptr_t dest = ((uintptr_t)target & 0xffffffffULL) | ((uintptr_t)branch & 0xffff00000000ULL);\n-        uintptr_t pc_page = (uintptr_t)branch >> 12;\n-        uintptr_t adr_page = (uintptr_t)dest >> 12;\n+        uintptr_t dest = (uintptr_t)target;\n+        uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n+        uintptr_t adr_page = (uintptr_t)target >> 12;\n+        uint32_t offset_lo = dest & 0xfff;\n@@ -148,1 +139,37 @@\n-        instructions = 2;\n+\n+        \/\/ We handle 3 types of PC-relative addressing\n+        \/\/   1 - adrp    Rx, target_page\n+        \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n+        \/\/   2 - adrp    Rx, target_page\n+        \/\/       add     Ry, Rx, #offset_in_page\n+        \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+        \/\/       movk    Rx, #imm16<<32\n+        \/\/\n+        uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+        if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n+            Instruction_aarch64::extract(insn, 4, 0) ==\n+            Instruction_aarch64::extract(insn2, 9, 5)) {\n+          \/\/ Load\/store register (unsigned immediate)\n+          uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n+          Instruction_aarch64::patch(insn_addr + sizeof (uint32_t),\n+                                     21, 10, offset_lo >> size);\n+          guarantee(((dest >> size) << size) == dest, \"misaligned target\");\n+          instructions = 2;\n+        } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n+                   Instruction_aarch64::extract(insn, 4, 0) ==\n+                   Instruction_aarch64::extract(insn2, 4, 0)) {\n+          \/\/ add (immediate)\n+          Instruction_aarch64::patch(insn_addr + sizeof (uint32_t),\n+                                     21, 10, offset_lo);\n+          instructions = 2;\n+        } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &&\n+                   Instruction_aarch64::extract(insn, 4, 0) ==\n+                   Instruction_aarch64::extract(insn2, 4, 0)) {\n+          \/\/ movk #imm16<<32\n+          Instruction_aarch64::patch(insn_addr + 4, 20, 5, (uintptr_t)target >> 32);\n+          uintptr_t dest = ((uintptr_t)target & 0xffffffffULL) | ((uintptr_t)insn_addr & 0xffff00000000ULL);\n+          uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n+          uintptr_t adr_page = (uintptr_t)dest >> 12;\n+          offset = adr_page - pc_page;\n+          instructions = 2;\n+        }\n@@ -150,0 +177,25 @@\n+      \/\/ Naked adrp: danger!\n+      int offset_lo = offset & 3;\n+      offset >>= 2;\n+      Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n+      Instruction_aarch64::patch(insn_addr, 30, 29, offset_lo);\n+      break;\n+    }\n+    case 0b001001:\n+    case 0b011001:\n+    case 0b101001:\n+    case 0b111001: {\n+      \/\/ immediate constant\n+      assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n+      uint64_t dest = (uint64_t)target;\n+      \/\/ Move wide constant\n+      assert(nativeInstruction_at(insn_addr+4)->is_movk(), \"wrong insns in patch\");\n+      assert(nativeInstruction_at(insn_addr+8)->is_movk(), \"wrong insns in patch\");\n+      Instruction_aarch64::patch(insn_addr, 20, 5, dest & 0xffff);\n+      Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest >>= 16) & 0xffff);\n+      Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest >>= 16) & 0xffff);\n+      instructions = 3;\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n@@ -151,19 +203,0 @@\n-    int offset_lo = offset & 3;\n-    offset >>= 2;\n-    Instruction_aarch64::spatch(branch, 23, 5, offset);\n-    Instruction_aarch64::patch(branch, 30, 29, offset_lo);\n-  } else if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100) {\n-    uint64_t dest = (uint64_t)target;\n-    \/\/ Move wide constant\n-    assert(nativeInstruction_at(branch+4)->is_movk(), \"wrong insns in patch\");\n-    assert(nativeInstruction_at(branch+8)->is_movk(), \"wrong insns in patch\");\n-    Instruction_aarch64::patch(branch, 20, 5, dest & 0xffff);\n-    Instruction_aarch64::patch(branch+4, 20, 5, (dest >>= 16) & 0xffff);\n-    Instruction_aarch64::patch(branch+8, 20, 5, (dest >>= 16) & 0xffff);\n-    assert(target_addr_for_insn(branch) == target, \"should be\");\n-    instructions = 3;\n-  } else if (NativeInstruction::is_ldrw_to_zr(address(&insn))) {\n-    \/\/ nothing to do\n-    assert(target == 0, \"did not expect to relocate target for polling page load\");\n-  } else {\n-    ShouldNotReachHere();\n@@ -171,0 +204,1 @@\n+  assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n@@ -213,1 +247,3 @@\n-address MacroAssembler::target_addr_for_insn(address insn_addr, unsigned insn) {\n+address MacroAssembler::target_addr_for_insn(address insn_addr, uint32_t insn) {\n+  \/\/ branches, all kinds\n+  uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n@@ -215,59 +251,82 @@\n-  if ((Instruction_aarch64::extract(insn, 29, 24) & 0b011011) == 0b00011000) {\n-    \/\/ Load register (literal)\n-    offset = Instruction_aarch64::sextract(insn, 23, 5);\n-    return address(((uint64_t)insn_addr + (offset << 2)));\n-  } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {\n-    \/\/ Unconditional branch (immediate)\n-    offset = Instruction_aarch64::sextract(insn, 25, 0);\n-  } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {\n-    \/\/ Conditional branch (immediate)\n-    offset = Instruction_aarch64::sextract(insn, 23, 5);\n-  } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {\n-    \/\/ Compare & branch (immediate)\n-    offset = Instruction_aarch64::sextract(insn, 23, 5);\n-   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {\n-    \/\/ Test & branch (immediate)\n-    offset = Instruction_aarch64::sextract(insn, 18, 5);\n-  } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {\n-    \/\/ PC-rel. addressing\n-    offset = Instruction_aarch64::extract(insn, 30, 29);\n-    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n-    int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;\n-    if (shift) {\n-      offset <<= shift;\n-      uint64_t target_page = ((uint64_t)insn_addr) + offset;\n-      target_page &= ((uint64_t)-1) << shift;\n-      \/\/ Return the target address for the following sequences\n-      \/\/   1 - adrp    Rx, target_page\n-      \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-      \/\/   2 - adrp    Rx, target_page\n-      \/\/       add     Ry, Rx, #offset_in_page\n-      \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-      \/\/       movk    Rx, #imm12<<32\n-      \/\/   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-      \/\/\n-      \/\/ In the first two cases  we check that the register is the same and\n-      \/\/ return the target_page + the offset within the page.\n-      \/\/ Otherwise we assume it is a page aligned relocation and return\n-      \/\/ the target page only.\n-      \/\/\n-      unsigned insn2 = ((unsigned*)insn_addr)[1];\n-      if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n-                Instruction_aarch64::extract(insn, 4, 0) ==\n-                        Instruction_aarch64::extract(insn2, 9, 5)) {\n-        \/\/ Load\/store register (unsigned immediate)\n-        unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n-        unsigned int size = Instruction_aarch64::extract(insn2, 31, 30);\n-        return address(target_page + (byte_offset << size));\n-      } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n-                Instruction_aarch64::extract(insn, 4, 0) ==\n-                        Instruction_aarch64::extract(insn2, 4, 0)) {\n-        \/\/ add (immediate)\n-        unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n-        return address(target_page + byte_offset);\n-      } else {\n-        if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &&\n-               Instruction_aarch64::extract(insn, 4, 0) ==\n-                 Instruction_aarch64::extract(insn2, 4, 0)) {\n-          target_page = (target_page & 0xffffffff) |\n-                         ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) << 32);\n+  switch(dispatch) {\n+    case 0b001100:\n+    case 0b001110:\n+    case 0b011100:\n+    case 0b011110:\n+    case 0b101100:\n+    case 0b101110:\n+    case 0b111100:\n+    case 0b111110: {\n+      \/\/ load\/store\n+      if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n+        \/\/ Load register (literal)\n+        offset = Instruction_aarch64::sextract(insn, 23, 5);\n+        return address(((uint64_t)insn_addr + (offset << 2)));\n+        break;\n+      }\n+      ShouldNotReachHere();\n+    }\n+    case 0b001010:\n+    case 0b001011: {\n+      \/\/ Unconditional branch (immediate)\n+      offset = Instruction_aarch64::sextract(insn, 25, 0);\n+      break;\n+    }\n+    case 0b101010: \/\/ Compare & branch (immediate)\n+    case 0b011010: \/\/ Conditional branch (immediate)\n+    {\n+      offset = Instruction_aarch64::sextract(insn, 23, 5);\n+      break;\n+    }\n+    case 0b011011: {\n+      \/\/ Test & branch (immediate)\n+      offset = Instruction_aarch64::sextract(insn, 18, 5);\n+      break;\n+    }\n+    case 0b001000:\n+    case 0b011000:\n+    case 0b101000:\n+    case 0b111000: {\n+      \/\/ adr\/adrp\n+\n+      \/\/ PC-rel. addressing\n+      offset = Instruction_aarch64::extract(insn, 30, 29);\n+      offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n+      int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;\n+      if (shift) {\n+        \/\/ adrp\n+        offset <<= shift;\n+        uint64_t target_page = ((uint64_t)insn_addr) + offset;\n+        target_page &= ((uint64_t)-1) << shift;\n+        \/\/ Return the target address for the following sequences\n+        \/\/   1 - adrp    Rx, target_page\n+        \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n+        \/\/   2 - adrp    Rx, target_page\n+        \/\/       add     Ry, Rx, #offset_in_page\n+        \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n+        \/\/       movk    Rx, #imm12<<32\n+        \/\/\n+        uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+        if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n+            Instruction_aarch64::extract(insn, 4, 0) ==\n+            Instruction_aarch64::extract(insn2, 9, 5)) {\n+          \/\/ Load\/store register (unsigned immediate)\n+          uint32_t byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+          uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n+          return address(target_page + (byte_offset << size));\n+        } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n+                   Instruction_aarch64::extract(insn, 4, 0) ==\n+                   Instruction_aarch64::extract(insn2, 4, 0)) {\n+          \/\/ add (immediate)\n+          uint32_t byte_offset = Instruction_aarch64::extract(insn2, 21, 10);\n+          return address(target_page + byte_offset);\n+        } else {\n+          \/\/ movk\n+          if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &&\n+              Instruction_aarch64::extract(insn, 4, 0) ==\n+              Instruction_aarch64::extract(insn2, 4, 0)) {\n+            target_page = (target_page & 0xffffffff) |\n+              ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) << 32);\n+          }\n+          \/\/ Naked adrp, maybe.\n+          return (address)target_page;\n@@ -275,1 +334,4 @@\n-        return (address)target_page;\n+      } else {\n+        \/\/ adr\n+        \/\/ Offset is in bytes\n+        return address((uint64_t)insn_addr + offset);\n@@ -277,1 +339,16 @@\n-    } else {\n+    }\n+    case 0b001001:\n+    case 0b011001:\n+    case 0b101001:\n+    case 0b111001: {\n+      \/\/ immediate constant\n+      assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n+      uint32_t *insns = (uint32_t *)insn_addr;\n+      \/\/ Move wide constant: movz, movk, movk.  See movptr().\n+      assert(nativeInstruction_at(insns+1)->is_movk(), \"wrong insns in patch\");\n+      assert(nativeInstruction_at(insns+2)->is_movk(), \"wrong insns in patch\");\n+      return address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n+                     + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n+                     + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n+    }\n+    default:\n@@ -280,11 +357,0 @@\n-  } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {\n-    uint32_t *insns = (uint32_t *)insn_addr;\n-    \/\/ Move wide constant: movz, movk, movk.  See movptr().\n-    assert(nativeInstruction_at(insns+1)->is_movk(), \"wrong insns in patch\");\n-    assert(nativeInstruction_at(insns+2)->is_movk(), \"wrong insns in patch\");\n-    return address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n-                   + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n-                   + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n-  } else {\n-    ShouldNotReachHere();\n-  }\n@@ -3453,1 +3519,0 @@\n-  uint64_t offset;\n@@ -3462,2 +3527,5 @@\n-    adrp(table0, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n-    if (offset) add(table0, table0, offset);\n+    {\n+      uint64_t offset;\n+      adrp(table0, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n+      add(table0, table0, offset);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":230,"deletions":162,"binary":false,"changes":392,"status":"modified"}]}