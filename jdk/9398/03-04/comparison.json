{"files":[{"patch":"@@ -188,1 +188,1 @@\n-    rf(Rd, 0);\n+    zrf(Rd, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,1 +179,3 @@\n-      __ adrp(rscratch1, ExternalAddress((address) Universe::heap()->end_addr()), offset);\n+      ExternalAddress adr((address) Universe::heap()->end_addr());\n+      __ adrp(rscratch1, adr, offset);\n+      __ movk(rscratch1, ((uint64_t)adr.target() >> 32), 32);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  typedef int (RelocActions::* reloc_insn)(address insn_addr, address &target, ptrdiff_t *offset);\n+  typedef int (RelocActions::* reloc_insn)(address insn_addr, address &target);\n@@ -158,3 +158,3 @@\n-  virtual int adrpMem_impl(address insn_addr, address &target, ptrdiff_t *offset) = 0;\n-  virtual int adrpAdd_impl(address insn_addr, address &target, ptrdiff_t *offset) = 0;\n-  virtual int adrpMovk_impl(address insn_addr, address &target, ptrdiff_t *offset) = 0;\n+  virtual int adrpMem_impl(address insn_addr, address &target) = 0;\n+  virtual int adrpAdd_impl(address insn_addr, address &target) = 0;\n+  virtual int adrpMovk_impl(address insn_addr, address &target) = 0;\n@@ -166,2 +166,0 @@\n-    \/\/ assert((uint64_t)target < (1ull << 48), \"48-bit overflow in address constant\");\n-    \/\/ intptr_t offset = (target - insn_addr) >> 2;\n@@ -281,2 +279,1 @@\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n-    int instructions = 1;\n+  virtual int adr(address insn_addr, address &target) {\n@@ -289,19 +286,0 @@\n-    if (inner) {\n-      instructions = 2;\n-      uintptr_t dest = (uintptr_t)target;\n-      uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n-      uintptr_t adr_page = (uintptr_t)target >> 12;\n-      uint32_t offset_lo = dest & 0xfff;\n-      offset = adr_page - pc_page;\n-\n-      \/\/ We handle 3 types of PC-relative addressing\n-      \/\/   1 - adrp    Rx, target_page\n-      \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-      \/\/   2 - adrp    Rx, target_page\n-      \/\/       add     Ry, Rx, #offset_in_page\n-      \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-      \/\/       movk    Rx, #imm16<<32\n-      \/\/\n-      instructions = ((*this).*inner)(insn_addr, target, NULL);\n-    }\n-\n@@ -312,1 +290,1 @@\n-    return instructions;\n+    return 1;\n@@ -314,1 +292,2 @@\n-  virtual int adr(address insn_addr, address &target) {\n+  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n+    int instructions = 1;\n@@ -319,1 +298,0 @@\n-    \/\/ PC-rel. addressing\n@@ -321,0 +299,12 @@\n+    if (inner) {\n+      instructions = 2;\n+      uintptr_t dest = (uintptr_t)target;\n+      uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n+      uintptr_t adr_page = (uintptr_t)target >> 12;\n+      uint32_t offset_lo = dest & 0xfff;\n+      offset = adr_page - pc_page;\n+      instructions = ((*this).*inner)(insn_addr, target);\n+    }\n+    \/\/ movk has handled the upper bits. Now we extract the lower 19\n+    \/\/ bits of the signed offset field for the ADRP.\n+    offset = offset << (64-19) >> (64-19);\n@@ -325,1 +315,1 @@\n-    return 1;\n+    return instructions;\n@@ -327,1 +317,1 @@\n-  virtual int adrpMem_impl(address insn_addr, address &target, ptrdiff_t *) {\n+  virtual int adrpMem_impl(address insn_addr, address &target) {\n@@ -336,1 +326,1 @@\n-  virtual int adrpAdd_impl(address insn_addr, address &target, ptrdiff_t *) {\n+  virtual int adrpAdd_impl(address insn_addr, address &target) {\n@@ -342,1 +332,1 @@\n-  virtual int adrpMovk_impl(address insn_addr, address &target, ptrdiff_t *) {\n+  virtual int adrpMovk_impl(address insn_addr, address &target) {\n@@ -371,1 +361,0 @@\n-#if 0\n@@ -393,1 +382,0 @@\n-#endif\n@@ -425,24 +413,0 @@\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n-    int instructions = 1;\n-#ifdef ASSERT\n-    uint32_t insn = *(uint32_t*)insn_addr;\n-    assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n-#endif\n-    \/\/ PC-rel. addressing\n-    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n-    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n-    \/\/ if (inner) {\n-      int shift = 12;\n-      offset <<= shift;\n-      uint64_t target_page = ((uint64_t)insn_addr) + offset;\n-      target_page &= ((uint64_t)-1) << shift;\n-      uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n-      target = address(target_page);\n-      ptrdiff_t byte_offset;\n-      ((*this).*inner)(insn_addr, target, &byte_offset);\n-      instructions = 2;\n-    \/\/ } else {\n-    \/\/   target = address((uint64_t)insn_addr + offset);\n-    \/\/ }\n-    return instructions;\n-  }\n@@ -457,1 +421,16 @@\n-  virtual int adrpMem_impl(address insn_addr, address &target, ptrdiff_t *offset) {\n+  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n+    uint32_t insn = *(uint32_t*)insn_addr;\n+    assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n+    \/\/ if (inner) {\n+    int shift = 12;\n+    offset <<= shift;\n+    uint64_t target_page = ((uint64_t)insn_addr) + offset;\n+    target_page &= ((uint64_t)-1) << shift;\n+    uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n+    target = address(target_page);\n+    ((*this).*inner)(insn_addr, target);\n+    return 2;\n+  }\n+  virtual int adrpMem_impl(address insn_addr, address &target) {\n@@ -466,1 +445,1 @@\n-  virtual int adrpAdd_impl(address insn_addr, address &target, ptrdiff_t *offset) {\n+  virtual int adrpAdd_impl(address insn_addr, address &target) {\n@@ -473,1 +452,1 @@\n-  virtual int adrpMovk_impl(address insn_addr, address &target, ptrdiff_t *offset) {\n+  virtual int adrpMovk_impl(address insn_addr, address &target) {\n@@ -480,1 +459,0 @@\n-#if 0\n@@ -483,0 +461,1 @@\n+    uint32_t insn = *(uint32_t*)insn_addr;\n@@ -485,0 +464,1 @@\n+    ptrdiff_t byte_offset;\n@@ -486,1 +466,1 @@\n-      return address(target_page + byte_offset);\n+      target += byte_offset;\n@@ -488,1 +468,0 @@\n-#endif\n@@ -492,4 +471,0 @@\n-    uint32_t insn = *(uint32_t*)insn_addr;\n-    assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n-    \/\/ immediate constant\n-    assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n@@ -497,0 +472,2 @@\n+    uint32_t insn = insns[0];\n+    assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n@@ -521,116 +498,0 @@\n-\/\/ address MacroAssembler::target_addr_for_insn(address insn_addr, uint32_t insn) {\n-\/\/   \/\/ branches, all kinds\n-\/\/   uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n-\/\/   intptr_t offset = 0;\n-\n-\/\/   switch(dispatch) {\n-\/\/     case 0b001100:\n-\/\/     case 0b001110:\n-\/\/     case 0b011100:\n-\/\/     case 0b011110:\n-\/\/     case 0b101100:\n-\/\/     case 0b101110:\n-\/\/     case 0b111100:\n-\/\/     case 0b111110: {\n-\/\/       \/\/ load\/store\n-\/\/       if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n-\/\/         \/\/ Load register (literal)\n-\/\/         offset = Instruction_aarch64::sextract(insn, 23, 5);\n-\/\/         return address(((uint64_t)insn_addr + (offset << 2)));\n-\/\/         break;\n-\/\/       }\n-\/\/       ShouldNotReachHere();\n-\/\/     }\n-\/\/     case 0b001010:\n-\/\/     case 0b001011: {\n-\/\/       \/\/ Unconditional branch (immediate)\n-\/\/       offset = Instruction_aarch64::sextract(insn, 25, 0);\n-\/\/       break;\n-\/\/     }\n-\/\/     case 0b101010: \/\/ Conditional branch (immediate)\n-\/\/     case 0b011010: \/\/ Compare & branch (immediate)\n-\/\/     {\n-\/\/       offset = Instruction_aarch64::sextract(insn, 23, 5);\n-\/\/       break;\n-\/\/     }\n-\/\/     case 0b011011: {\n-\/\/       \/\/ Test & branch (immediate)\n-\/\/       offset = Instruction_aarch64::sextract(insn, 18, 5);\n-\/\/       break;\n-\/\/     }\n-\/\/     case 0b001000:\n-\/\/     case 0b011000:\n-\/\/     case 0b101000:\n-\/\/     case 0b111000: {\n-\/\/       \/\/ adr\/adrp\n-\n-\/\/       \/\/ PC-rel. addressing\n-\/\/       offset = Instruction_aarch64::extract(insn, 30, 29);\n-\/\/       offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n-\/\/       int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;\n-\/\/       if (shift) {\n-\/\/         \/\/ adrp\n-\/\/         offset <<= shift;\n-\/\/         uint64_t target_page = ((uint64_t)insn_addr) + offset;\n-\/\/         target_page &= ((uint64_t)-1) << shift;\n-\/\/         \/\/ Return the target address for the following sequences\n-\/\/         \/\/   1 - adrp    Rx, target_page\n-\/\/         \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-\/\/         \/\/   2 - adrp    Rx, target_page\n-\/\/         \/\/       add     Ry, Rx, #offset_in_page\n-\/\/         \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-\/\/         \/\/       movk    Rx, #imm12<<32\n-\/\/         \/\/   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-\/\/         \/\/       movk    Rx, #imm12<<32\n-\/\/         \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-\/\/         \/\/   5 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-\/\/         \/\/       movk    Rx, #imm12<<32\n-\/\/         \/\/       add     Ry, Rx, #offset_in_page\n-\/\/         uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n-\/\/         ptrdiff_t byte_offset;\n-\/\/         if (offset_for(insn, insn2, byte_offset)) {\n-\/\/           return address(target_page + byte_offset);\n-\/\/         } else {\n-\/\/           \/\/ adrp;movk\n-\/\/           if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &&\n-\/\/               Instruction_aarch64::extract(insn, 4, 0) ==\n-\/\/               Instruction_aarch64::extract(insn2, 4, 0)) {\n-\/\/             target_page = (target_page & 0xffffffff) |\n-\/\/               ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) << 32);\n-\/\/           }\n-\/\/           \/\/ We know the destination 4k page. Maybe we have a third\n-\/\/           \/\/ instruction.\n-\/\/           int *insn3_addr = &((int*)insn_addr)[2];\n-\/\/           uint32_t insn3 = SafeFetch32(insn3_addr, -1);\n-\/\/           if (offset_for(insn, insn3, byte_offset)) {\n-\/\/             return address(target_page + byte_offset);\n-\/\/           }\n-\/\/           \/\/ Naked adrp, maybe?\n-\/\/           return address(target_page);\n-\/\/         }\n-\/\/       } else {\n-\/\/         \/\/ adr, unshiifted\n-\/\/         \/\/ Offset is in bytes\n-\/\/         return address((uint64_t)insn_addr + offset);\n-\/\/       }\n-\/\/     }\n-\/\/     case 0b001001:\n-\/\/     case 0b011001:\n-\/\/     case 0b101001:\n-\/\/     case 0b111001: {\n-\/\/       \/\/ immediate constant\n-\/\/       assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n-\/\/       uint32_t *insns = (uint32_t *)insn_addr;\n-\/\/       \/\/ Move wide constant: movz, movk, movk.  See movptr().\n-\/\/       assert(nativeInstruction_at(insns+1)->is_movk(), \"wrong insns in patch\");\n-\/\/       assert(nativeInstruction_at(insns+2)->is_movk(), \"wrong insns in patch\");\n-\/\/       return address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n-\/\/                      + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n-\/\/                      + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n-\/\/     }\n-\/\/     default:\n-\/\/       ShouldNotReachHere();\n-\/\/     }\n-\/\/   return address(((uint64_t)insn_addr + (offset << 2)));\n-\/\/ }\n-\n@@ -642,1 +503,0 @@\n-\n@@ -644,135 +504,0 @@\n-\n-\/\/   int instructions = 1;\n-\/\/   assert((uint64_t)target < (1ull << 48), \"48-bit overflow in address constant\");\n-\/\/   intptr_t offset = (target - insn_addr) >> 2;\n-\/\/   uint32_t insn = *(uint32_t*)insn_addr;\n-\n-\/\/   uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n-\/\/   switch(dispatch) {\n-\/\/     case 0b001010:\n-\/\/     case 0b001011: {\n-\/\/       \/\/ Unconditional branch (immediate)\n-\/\/       Instruction_aarch64::spatch(insn_addr, 25, 0, offset);\n-\/\/       break;\n-\/\/     }\n-\/\/     case 0b101010: \/\/ Conditional branch (immediate)\n-\/\/     case 0b011010: \/\/ Compare & branch (immediate)\n-\/\/     {\n-\/\/       Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n-\/\/       break;\n-\/\/     }\n-\/\/     case 0b011011: {\n-\/\/       \/\/ Test & branch (immediate)\n-\/\/       Instruction_aarch64::spatch(insn_addr, 18, 5, offset);\n-\/\/       break;\n-\/\/     }\n-\/\/     case 0b001100:\n-\/\/     case 0b001110:\n-\/\/     case 0b011100:\n-\/\/     case 0b011110:\n-\/\/     case 0b101100:\n-\/\/     case 0b101110:\n-\/\/     case 0b111100:\n-\/\/     case 0b111110: {\n-\/\/       \/\/ load\/store\n-\/\/       if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n-\/\/         \/\/ Load register (literal)\n-\/\/         Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n-\/\/         break;\n-\/\/       } else {\n-\/\/         \/\/ nothing to do\n-\/\/         assert(target == 0, \"did not expect to relocate target for polling page load\");\n-\/\/       }\n-\/\/       break;\n-\/\/     }\n-\/\/     case 0b001000:\n-\/\/     case 0b011000:\n-\/\/     case 0b101000:\n-\/\/     case 0b111000: {\n-\/\/       \/\/ adr\/adrp\n-\/\/       assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n-\/\/       \/\/ PC-rel. addressing\n-\/\/       offset = target-insn_addr;\n-\/\/       int shift = Instruction_aarch64::extract(insn, 31, 31);\n-\/\/       if (shift) {\n-\/\/         instructions = 2;\n-\/\/         uintptr_t dest = (uintptr_t)target;\n-\/\/         uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n-\/\/         uintptr_t adr_page = (uintptr_t)target >> 12;\n-\/\/         uint32_t offset_lo = dest & 0xfff;\n-\/\/         offset = adr_page - pc_page;\n-\n-\/\/         \/\/ We handle 3 types of PC-relative addressing\n-\/\/         \/\/   1 - adrp    Rx, target_page\n-\/\/         \/\/       ldr\/str Ry, [Rx, #offset_in_page]\n-\/\/         \/\/   2 - adrp    Rx, target_page\n-\/\/         \/\/       add     Ry, Rx, #offset_in_page\n-\/\/         \/\/   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)\n-\/\/         \/\/       movk    Rx, #imm16<<32\n-\/\/         \/\/\n-\/\/         uint32_t insn2 = ((uint32_t*)insn_addr)[1];\n-\/\/         if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &&\n-\/\/             Instruction_aarch64::extract(insn, 4, 0) ==\n-\/\/             Instruction_aarch64::extract(insn2, 9, 5)) {\n-\/\/           \/\/ Load\/store register (unsigned immediate)\n-\/\/           uint32_t size = Instruction_aarch64::extract(insn2, 31, 30);\n-\/\/           Instruction_aarch64::patch(insn_addr + sizeof (uint32_t),\n-\/\/                                      21, 10, offset_lo >> size);\n-\/\/           guarantee(((dest >> size) << size) == dest, \"misaligned target\");\n-\/\/           instructions = 2;\n-\/\/         } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &&\n-\/\/                    Instruction_aarch64::extract(insn, 4, 0) ==\n-\/\/                    Instruction_aarch64::extract(insn2, 4, 0)) {\n-\/\/           \/\/ add (immediate)\n-\/\/           Instruction_aarch64::patch(insn_addr + sizeof (uint32_t),\n-\/\/                                      21, 10, offset_lo);\n-\/\/           instructions = 2;\n-\/\/         } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &&\n-\/\/                    Instruction_aarch64::extract(insn, 4, 0) ==\n-\/\/                    Instruction_aarch64::extract(insn2, 4, 0)) {\n-\/\/           \/\/ movk #imm16<<32\n-\/\/           Instruction_aarch64::patch(insn_addr + 4, 20, 5, (uintptr_t)target >> 32);\n-\/\/           uintptr_t dest = ((uintptr_t)target & 0xffffffffULL) | ((uintptr_t)insn_addr & 0xffff00000000ULL);\n-\/\/           uintptr_t pc_page = (uintptr_t)insn_addr >> 12;\n-\/\/           uintptr_t adr_page = (uintptr_t)dest >> 12;\n-\/\/           offset = adr_page - pc_page;\n-\/\/           instructions = 2;\n-\/\/         }\n-\/\/       }\n-\/\/       \/\/ Naked adrp: danger!\n-\/\/       int offset_lo = offset & 3;\n-\/\/       offset >>= 2;\n-\/\/       Instruction_aarch64::spatch(insn_addr, 23, 5, offset);\n-\/\/       Instruction_aarch64::patch(insn_addr, 30, 29, offset_lo);\n-\/\/       break;\n-\/\/     }\n-\/\/     case 0b001001:\n-\/\/     case 0b011001:\n-\/\/     case 0b101001:\n-\/\/     case 0b111001: {\n-\/\/       \/\/ immediate constant\n-\/\/       assert(Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100, \"must be\");\n-\/\/       uint64_t dest = (uint64_t)target;\n-\/\/       \/\/ Move wide constant\n-\/\/       assert(nativeInstruction_at(insn_addr+4)->is_movk(), \"wrong insns in patch\");\n-\/\/       assert(nativeInstruction_at(insn_addr+8)->is_movk(), \"wrong insns in patch\");\n-\/\/       Instruction_aarch64::patch(insn_addr, 20, 5, dest & 0xffff);\n-\/\/       Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest >>= 16) & 0xffff);\n-\/\/       Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest >>= 16) & 0xffff);\n-\/\/       instructions = 3;\n-\/\/       break;\n-\/\/     }\n-\/\/     default: {\n-\/\/       ShouldNotReachHere();\n-\/\/     }\n-\/\/   }\n-\/\/   \/\/ assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n-\/\/ #ifdef ASSERT\n-\/\/   address address_is = target_addr_for_insn(insn_addr);\n-\/\/   if (!(address_is == target)) {\n-\/\/     tty->print_cr(\"%p at %p should be %p\", address_is, insn_addr, target);\n-\/\/     disnm((intptr_t)insn_addr);\n-\/\/     assert(target_addr_for_insn(insn_addr) == target, \"should be\");\n-\/\/   }\n-\/\/ #endif\n-\/\/   return instructions * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":47,"deletions":322,"binary":false,"changes":369,"status":"modified"},{"patch":"@@ -6962,0 +6962,6 @@\n+    {\n+      ExternalAddress longWayAway(__ pc() - (1ll << 34));\n+      uint64_t offset;\n+      __ adrp(rscratch1, longWayAway, offset);\n+      __ add(rscratch1, rscratch1, offset);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}