{"files":[{"patch":"@@ -2088,8 +2088,0 @@\n-\/\/ The address where this shared heap region is actually mapped at runtime. This function\n-\/\/ can be called only after we have determined the value for ArchiveHeapLoader::mapped_heap_delta().\n-address FileMapInfo::heap_region_mapped_address() {\n-  assert(UseSharedSpaces, \"runtime only\");\n-  assert(ArchiveHeapLoader::can_map(), \"cannot be used by ArchiveHeapLoader::can_load() mode\");\n-  return heap_region_requested_address() + ArchiveHeapLoader::mapped_heap_delta();\n-}\n-\n@@ -2097,11 +2089,0 @@\n-  init_heap_region_relocation();\n-\n-  if (_heap_pointers_need_patching) {\n-    char* bitmap_base = map_bitmap_region();\n-    if (bitmap_base == nullptr) {\n-      log_info(cds)(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n-      _heap_pointers_need_patching = false;\n-      return false;\n-    }\n-  }\n-\n@@ -2133,1 +2114,1 @@\n-void FileMapInfo::init_heap_region_relocation() {\n+bool FileMapInfo::map_heap_region_impl() {\n@@ -2135,4 +2116,0 @@\n-  _heap_pointers_need_patching = false;\n-\n-  MemRegion heap_range = G1CollectedHeap::heap()->reserved();\n-  MemRegion archive_range = get_heap_region_requested_range();\n@@ -2140,30 +2117,0 @@\n-  address requested_bottom = (address)archive_range.start();\n-  address heap_end = (address)heap_range.end();\n-  assert(is_aligned(heap_end, HeapRegion::GrainBytes), \"must be\");\n-\n-  \/\/ We map the archive heap region at the very top of the heap to avoid fragmentation.\n-  \/\/ To do that, we make sure that the bottom of the archived region is at the same\n-  \/\/ address as the bottom of the highest possible G1 region.\n-  address mapped_bottom = heap_end - align_up(archive_range.byte_size(), HeapRegion::GrainBytes);\n-\n-  if (UseCompressedOops &&\n-      (narrow_oop_mode() != CompressedOops::mode() ||\n-       narrow_oop_shift() != CompressedOops::shift())) {\n-    log_info(cds)(\"CDS heap data needs to be relocated because the archive was created with an incompatible oop encoding mode.\");\n-    _heap_pointers_need_patching = true;\n-  } else if (requested_bottom != mapped_bottom) {\n-    log_info(cds)(\"CDS heap data needs to be relocated because it is mapped at a different address @ \" INTPTR_FORMAT,\n-                  p2i(mapped_bottom));\n-    _heap_pointers_need_patching = true;\n-  }\n-\n-  ptrdiff_t delta = 0;\n-  if (_heap_pointers_need_patching) {\n-    delta = mapped_bottom - requested_bottom;\n-  }\n-\n-  log_info(cds)(\"CDS heap data relocation delta = \" INTX_FORMAT \" bytes\", delta);\n-  ArchiveHeapLoader::init_mapped_heap_relocation(delta, narrow_oop_shift());\n-}\n-\n-bool FileMapInfo::map_heap_region_impl() {\n@@ -2172,7 +2119,1 @@\n-\n-  if (size > 0) {\n-    HeapWord* start = (HeapWord*)heap_region_mapped_address();\n-    _mapped_heap_memregion = MemRegion(start, size \/ HeapWordSize);\n-    log_info(cds)(\"Trying to map heap data at \" INTPTR_FORMAT \", size = \" SIZE_FORMAT_W(8) \" bytes\",\n-                  p2i(start), size);\n-  } else {\n+  if (size == 0) {\n@@ -2182,5 +2123,4 @@\n-  \/\/ Check that the region is within the java heap\n-  if (!G1CollectedHeap::heap()->check_archive_addresses(_mapped_heap_memregion)) {\n-    log_info(cds)(\"Unable to allocate region, range is not within java heap.\");\n-    return false;\n-  }\n+  size_t word_size = size \/ HeapWordSize;\n+  address requested_start = heap_region_requested_address();\n+\n+  log_info(cds)(\"Preferred address to map heap data (to avoid relocation) is \" INTPTR_FORMAT, p2i(requested_start));\n@@ -2189,2 +2129,3 @@\n-  if (!G1CollectedHeap::heap()->alloc_archive_regions(_mapped_heap_memregion)) {\n-    log_info(cds)(\"Unable to allocate region, java heap range is already in use.\");\n+  HeapWord* start = G1CollectedHeap::heap()->alloc_archive_region(word_size, (HeapWord*)requested_start);\n+  if (start == nullptr) {\n+    log_info(cds)(\"UseSharedSpaces: Unable to allocate java heap region for archive heap.\");\n@@ -2194,0 +2135,2 @@\n+  _mapped_heap_memregion = MemRegion(start, word_size);\n+\n@@ -2211,1 +2154,1 @@\n-    log_info(cds)(\"mapped heap region is corrupt\");\n+    log_info(cds)(\"UseSharedSpaces: mapped heap region is corrupt\");\n@@ -2215,0 +2158,27 @@\n+  \/\/ If the requested range is different from the range allocated by GC, then\n+  \/\/ the pointers need to be patched.\n+  address mapped_start = (address) _mapped_heap_memregion.start();\n+  ptrdiff_t delta = mapped_start - requested_start;\n+  if (UseCompressedOops &&\n+      (narrow_oop_mode() != CompressedOops::mode() ||\n+       narrow_oop_shift() != CompressedOops::shift())) {\n+    _heap_pointers_need_patching = true;\n+  }\n+  if (delta != 0) {\n+    _heap_pointers_need_patching = true;\n+  }\n+  ArchiveHeapLoader::init_mapped_heap_relocation(delta, narrow_oop_shift());\n+\n+  if (_heap_pointers_need_patching) {\n+    char* bitmap_base = map_bitmap_region();\n+    if (bitmap_base == NULL) {\n+      log_info(cds)(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n+      dealloc_heap_region();\n+      unmap_region(MetaspaceShared::hp);\n+      _heap_pointers_need_patching = false;\n+      return false;\n+    }\n+  }\n+  log_info(cds)(\"Heap data mapped at \" INTPTR_FORMAT \", size = \" SIZE_FORMAT_W(8) \" bytes\",\n+                p2i(mapped_start), _mapped_heap_memregion.byte_size());\n+  log_info(cds)(\"CDS heap data relocation delta = \" INTX_FORMAT \" bytes\", delta);\n@@ -2268,1 +2238,0 @@\n-  assert(!HeapShared::is_heap_region(i), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":39,"deletions":70,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -564,1 +564,0 @@\n-  address heap_region_mapped_address() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -514,4 +514,0 @@\n-bool G1CollectedHeap::check_archive_addresses(MemRegion range) {\n-  return _hrm.reserved().contains(range);\n-}\n-\n@@ -535,1 +531,1 @@\n-bool G1CollectedHeap::alloc_archive_regions(MemRegion range) {\n+HeapWord* G1CollectedHeap::alloc_archive_region(size_t word_size, HeapWord* preferred_addr) {\n@@ -541,0 +537,6 @@\n+  if (reserved.word_size() <= word_size) {\n+    log_info(gc, heap)(\"Unable to allocate regions as archive heap is too large; size requested = \" SIZE_FORMAT\n+                       \" bytes, heap = \" SIZE_FORMAT \" bytes\", word_size, reserved.word_size());\n+    return nullptr;\n+  }\n+\n@@ -545,5 +547,0 @@\n-  \/\/ For the specified MemRegion range, allocate the corresponding G1\n-  \/\/ region(s) and mark them as old region(s).\n-  HeapWord* start_address = range.start();\n-  size_t word_size = range.word_size();\n-  HeapWord* last_address = range.last();\n@@ -551,7 +548,4 @@\n-\n-  guarantee(reserved.contains(start_address) && reserved.contains(last_address),\n-            \"MemRegion outside of heap [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-            p2i(start_address), p2i(last_address));\n-\n-  \/\/ Perform the actual region allocation, exiting if it fails.\n-  \/\/ Then note how much new space we have allocated.\n+  \/\/ Attempt to allocate towards the end of the heap.\n+  HeapWord* start_addr = reserved.end() - align_up(word_size, HeapRegion::GrainWords);\n+  MemRegion range = MemRegion(start_addr, word_size);\n+  HeapWord* last_address = range.last();\n@@ -559,1 +553,1 @@\n-    return false;\n+    return nullptr;\n@@ -565,1 +559,0 @@\n-\n@@ -582,1 +575,1 @@\n-  return true;\n+  return start_addr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -703,7 +703,0 @@\n-  \/\/ Facility for allocating a fixed range within the heap and marking\n-  \/\/ the containing regions as 'old'. For use at JVM init time, when the\n-  \/\/ caller may mmap archived heap data at the specified range.\n-\n-  \/\/ Verify that the range is within the reserved heap.\n-  bool check_archive_addresses(MemRegion range);\n-\n@@ -715,3 +708,7 @@\n-  \/\/ Commit the appropriate G1 region(s) containing the specified range\n-  \/\/ and mark them as 'old' region(s).\n-  bool alloc_archive_regions(MemRegion range);\n+  \/\/ Commit the required number of G1 region(s) according to the size requested\n+  \/\/ and mark them as 'old' region(s). Preferred address is treated as a hint for\n+  \/\/ the location of the archive space in the heap. The returned address may or may\n+  \/\/ not be same as the preferred address.\n+  \/\/ This API is only used for allocating heap space for the archived heap objects\n+  \/\/ in the CDS archive.\n+  HeapWord* alloc_archive_region(size_t word_size, HeapWord* preferred_addr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"}]}