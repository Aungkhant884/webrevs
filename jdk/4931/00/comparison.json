{"files":[{"patch":"@@ -27,2 +27,3 @@\n-import compiler.lib.ir_framework.shared.TestFormat;\n-import compiler.lib.ir_framework.shared.TestFormatException;\n+import compiler.lib.ir_framework.shared.*;\n+import jdk.test.lib.Platform;\n+import sun.hotspot.WhiteBox;\n@@ -32,1 +33,0 @@\n-import java.util.regex.Pattern;\n@@ -51,0 +51,4 @@\n+    private static final String COMPOSITE_PREFIX = \"#PRE#\"; \/\/ Prefix for regexes that require an additional user-defined string.\n+    private static final String IS_REPLACED = \"#IS_REPLACED#\"; \/\/ Is replaced by an additional user-defined string.\n+    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n+    private static final String LOAD_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n@@ -52,4 +56,4 @@\n-    public static final String ALLOC = \"(.*precise klass .*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_instance_Java\" + END;\n-    public static final String ALLOC_OF = \"(.*precise klass .*\";\n-    public static final String ALLOC_ARRAY = \"(.*precise klass \\\\[L.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_array_Java\" + END;\n-    public static final String ALLOC_ARRAY_OF = \"(.*precise klass \\\\[L.*\";\n+    public static final String ALLOC = \"(.*precise klass .*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+    public static final String ALLOC_OF = COMPOSITE_PREFIX + \"(.*precise klass .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+    public static final String ALLOC_ARRAY = \"(.*precise klass \\\\[L.*\\\\R((.*(?i:mov|xor|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+    public static final String ALLOC_ARRAY_OF = COMPOSITE_PREFIX + \"(.*precise klass \\\\[L.*\" + IS_REPLACED + \";:.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n@@ -57,3 +61,4 @@\n-    public static final String CHECKCAST_ARRAY = \"(cmp.*precise klass \\\\[.*;:\" + END;\n-    public static final String CHECKCAST_ARRAY_OF = \"(cmp.*precise klass \\\\[.*\";\n-    public static final String CHECKCAST_ARRAYCOPY = \"(.*call_leaf_nofp,runtime  checkcast_arraycopy.*\" + END;\n+    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*precise klass \\\\[.*;:|.*(?i:mov|or).*precise klass \\\\[.*;:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+    public static final String CHECKCAST_ARRAY_OF = COMPOSITE_PREFIX + \"(((?i:cmp|CLFI|CLR).*precise klass \\\\[.*\" + IS_REPLACED + \";:|.*(?i:mov|or).*precise klass \\\\[.*\" + IS_REPLACED + \";:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+    \/\/ Does not work on s390 (a rule containing this regex will be skipped on s390).\n+    public static final String CHECKCAST_ARRAYCOPY = \"(.*((?i:call_leaf_nofp,runtime)|CALL,\\\\s?runtime leaf nofp|BCTRL.*.leaf call).*checkcast_arraycopy.*\" + END;\n@@ -72,10 +77,10 @@\n-    public static final String STORE_OF_CLASS = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@\\\\S*\";\n-    public static final String STORE_B_OF_CLASS = START + \"StoreB\" + MID + \"@\\\\S*\";\n-    public static final String STORE_C_OF_CLASS = START + \"StoreC\" + MID + \"@\\\\S*\";\n-    public static final String STORE_I_OF_CLASS = START + \"StoreI\" + MID + \"@\\\\S*\";\n-    public static final String STORE_L_OF_CLASS = START + \"StoreL\" + MID + \"@\\\\S*\";\n-    public static final String STORE_F_OF_CLASS = START + \"StoreF\" + MID + \"@\\\\S*\";\n-    public static final String STORE_D_OF_CLASS = START + \"StoreD\" + MID + \"@\\\\S*\";\n-    public static final String STORE_P_OF_CLASS = START + \"StoreP\" + MID + \"@\\\\S*\";\n-    public static final String STORE_N_OF_CLASS = START + \"StoreN\" + MID + \"@\\\\S*\";\n-    public static final String STORE_OF_FIELD = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\";\n+    public static final String STORE_OF_CLASS = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_B_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreB\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_C_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreC\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_I_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreI\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_L_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreL\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_F_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreF\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_D_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreD\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_P_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreP\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_N_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreN\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_OF_FIELD = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n@@ -94,12 +99,12 @@\n-    public static final String LOAD_OF_CLASS = START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_B_OF_CLASS = START + \"LoadB\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_UB_OF_CLASS = START + \"LoadUB\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_S_OF_CLASS = START + \"LoadS\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_US_OF_CLASS = START + \"LoadUS\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_I_OF_CLASS = START + \"LoadI\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_L_OF_CLASS = START + \"LoadL\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_F_OF_CLASS = START + \"LoadF\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_D_OF_CLASS = START + \"LoadD\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_P_OF_CLASS = START + \"LoadP\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_N_OF_CLASS = START + \"LoadN\" + MID + \"@\\\\S*\";\n-    public static final String LOAD_OF_FIELD = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\";\n+    public static final String LOAD_OF_CLASS = COMPOSITE_PREFIX + START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + \"@\\\\S*\"+  IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_B_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadB\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_UB_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadUB\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_S_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadS\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_US_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadUS\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_I_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadI\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_L_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadL\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_F_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadF\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_D_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadD\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_P_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadP\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_N_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadN\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    public static final String LOAD_OF_FIELD = COMPOSITE_PREFIX + START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n@@ -108,2 +113,2 @@\n-    public static final String LOOP   = START + \"Loop\" + MID + \"\" + END;\n-    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + \"\" + END;\n+    public static final String LOOP   = START + \"Loop\" + MID + END;\n+    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + END;\n@@ -121,0 +126,1 @@\n+    \/\/ Does not work for VM builds without JVMCI like x86_32 (a rule containing this regex will be skipped without having JVMCI built).\n@@ -126,9 +132,0 @@\n-\n-    private static final String ALLOC_OF_POSTFIX =  \":.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_instance_Java\" + END;\n-    private static final String ALLOC_ARRAY_OF_POSTFIX = \";:.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_array_Java\" + END;\n-    private static final String CHECKCAST_ARRAY_OF_POSTFIX = \";:\" + END;\n-    private static final String STORE_OF_FIELD_POSTFIX = \",.*\" + END;\n-    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n-    private static final String LOAD_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n-    private static final String LOAD_OF_FIELD_POSTFIX = \",.*\" + END;\n-\n@@ -142,15 +139,3 @@\n-            switch (node) {\n-                case ALLOC_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, ALLOC_OF_POSTFIX, \"ALLOC_OF\");\n-                case ALLOC_ARRAY_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, ALLOC_ARRAY_OF_POSTFIX, \"ALLOC_ARRAY_OF\");\n-                case CHECKCAST_ARRAY_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, CHECKCAST_ARRAY_OF_POSTFIX, \"CHECKCAST_ARRAY_OF\");\n-                case STORE_OF_CLASS, STORE_B_OF_CLASS, STORE_C_OF_CLASS, STORE_D_OF_CLASS, STORE_F_OF_CLASS, STORE_I_OF_CLASS,\n-                        STORE_L_OF_CLASS, STORE_N_OF_CLASS, STORE_P_OF_CLASS\n-                        -> mergeCompositeNodes(nodes, mergedNodes, i, node, STORE_OF_CLASS_POSTFIX, \"STORE_OF_CLASS\");\n-                case STORE_OF_FIELD -> mergeCompositeNodes(nodes, mergedNodes, i, node, STORE_OF_FIELD_POSTFIX, \"STORE_OF_FIELD\");\n-                case LOAD_OF_CLASS, LOAD_B_OF_CLASS, LOAD_UB_OF_CLASS, LOAD_D_OF_CLASS, LOAD_F_OF_CLASS, LOAD_I_OF_CLASS, LOAD_L_OF_CLASS,\n-                        LOAD_N_OF_CLASS, LOAD_P_OF_CLASS, LOAD_S_OF_CLASS, LOAD_US_OF_CLASS\n-                        -> mergeCompositeNodes(nodes, mergedNodes, i, node, LOAD_OF_CLASS_POSTFIX, \"LOAD_OF_CLASS\");\n-                case LOAD_OF_FIELD -> mergeCompositeNodes(nodes, mergedNodes, i, node, LOAD_OF_FIELD_POSTFIX, \"LOAD_OF_FIELD\");\n-                default -> {\n-                    i--; \/\/ No composite node, do not increment by 2.\n-                    mergedNodes.add(node);\n+            if (node.startsWith(COMPOSITE_PREFIX)) {\n+                if (i + 1 == nodes.length) {\n+                    reportMissingCompositeValue(node, i);\n@@ -158,0 +143,4 @@\n+                \/\/ Replace placeholder with user defined string.\n+                node = node.substring(COMPOSITE_PREFIX.length()).replaceAll(IS_REPLACED, nodes[i + 1]);\n+            } else {\n+                i--; \/\/ No composite node, do not increment by 2.\n@@ -159,0 +148,1 @@\n+            mergedNodes.add(node);\n@@ -163,3 +153,53 @@\n-    private static void mergeCompositeNodes(String[] nodes, List<String> mergedNodes, int i, String node, String postFix, String varName) {\n-        TestFormat.check(i + 1 < nodes.length, \"Must provide class name at index \" + (i + 1) + \" right after \" + varName);\n-        mergedNodes.add(node + Pattern.quote(nodes[i + 1]) + postFix);\n+    \/**\n+     * Is default regex supported on current platform, used VM build, etc.?\n+     * Throws a {@link CheckedTestFrameworkException} if the default regex is unsupported.\n+     *\/\n+    public static void checkDefaultRegexSupported(String node) throws CheckedTestFrameworkException {\n+        switch (node) {\n+            case INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP -> {\n+                if (!WhiteBox.getWhiteBox().isJVMCISupportedByGC()) {\n+                    throw new CheckedTestFrameworkException(\"INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP is unsupported in builds without JVMCI.\");\n+                }\n+            }\n+            case CHECKCAST_ARRAYCOPY -> {\n+                if (Platform.isS390x()) {\n+                    throw new CheckedTestFrameworkException(\"CHECKCAST_ARRAYCOPY is unsupported on s390.\");\n+                }\n+            }\n+            \/\/ default: do nothing -> default regex is supported\n+        }\n+    }\n+\n+    \/**\n+     * Mapping from string variable value to string variable name for better error reporting.\n+     *\/\n+    private static void reportMissingCompositeValue(String node, int i) {\n+        String varName = switch (node) {\n+            case ALLOC_OF -> \"ALLOC_OF\";\n+            case ALLOC_ARRAY_OF -> \"ALLOC_ARRAY_OF\";\n+            case CHECKCAST_ARRAY_OF -> \"CHECKCAST_ARRAY_OF\";\n+            case STORE_OF_CLASS -> \"STORE_OF_CLASS\";\n+            case STORE_B_OF_CLASS -> \"STORE_B_OF_CLASS\";\n+            case STORE_C_OF_CLASS -> \"STORE_C_OF_CLASS\";\n+            case STORE_D_OF_CLASS -> \"STORE_D_OF_CLASS\";\n+            case STORE_F_OF_CLASS -> \"STORE_F_OF_CLASS\";\n+            case STORE_I_OF_CLASS -> \"STORE_I_OF_CLASS\";\n+            case STORE_L_OF_CLASS -> \"STORE_L_OF_CLASS\";\n+            case STORE_N_OF_CLASS -> \"STORE_N_OF_CLASS\";\n+            case STORE_P_OF_CLASS -> \"STORE_P_OF_CLASS\";\n+            case STORE_OF_FIELD -> \"STORE_OF_FIELD\";\n+            case LOAD_OF_CLASS -> \"LOAD_OF_CLASS\";\n+            case LOAD_B_OF_CLASS -> \"LOAD_B_OF_CLASS\";\n+            case LOAD_UB_OF_CLASS -> \"LOAD_UB_OF_CLASS\";\n+            case LOAD_D_OF_CLASS -> \"LOAD_D_OF_CLASS\";\n+            case LOAD_F_OF_CLASS -> \"LOAD_F_OF_CLASS\";\n+            case LOAD_I_OF_CLASS -> \"LOAD_I_OF_CLASS\";\n+            case LOAD_L_OF_CLASS -> \"LOAD_L_OF_CLASS\";\n+            case LOAD_N_OF_CLASS -> \"LOAD_N_OF_CLASS\";\n+            case LOAD_P_OF_CLASS -> \"LOAD_P_OF_CLASS\";\n+            case LOAD_S_OF_CLASS -> \"LOAD_S_OF_CLASS\";\n+            case LOAD_US_OF_CLASS -> \"LOAD_US_OF_CLASS\";\n+            case LOAD_OF_FIELD -> \"LOAD_OF_FIELD\";\n+            default -> throw new TestFrameworkException(\"Missing variable mapping for \" + node);\n+        };\n+        TestFormat.fail(\"Must provide additional value at index \" + (i + 1) + \" right after \" + varName);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":101,"deletions":61,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n- * Examples on how to write base tests can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.BaseTestExample}\n- * and also as part of the internal testing in the package {@link jdk.test.lib.hotspot.ir_framework.tests}.\n+ * Examples on how to write base tests can be found in {@link ir_framework.examples.BaseTestExample}\n+ * and also as part of the internal testing in the package {@link ir_framework.tests}.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        processSocketOutput(socket.getOutput());\n+        processSocketOutput(socket);\n@@ -166,3 +166,6 @@\n-    private void processSocketOutput(String output) {\n-        if (TestFramework.TESTLIST || TestFramework.EXCLUDELIST) {\n-            StringBuilder builder = new StringBuilder();\n+    private void processSocketOutput(TestFrameworkSocket socket) {\n+        String output = socket.getOutput();\n+        if (socket.hasStdOut()) {\n+            StringBuilder testListBuilder = new StringBuilder();\n+            StringBuilder messagesBuilder = new StringBuilder();\n+            StringBuilder nonStdOutBuilder = new StringBuilder();\n@@ -170,2 +173,0 @@\n-            System.out.println(System.lineSeparator() + \"Run flag defined test list\");\n-            System.out.println(\"--------------------------\");\n@@ -175,2 +176,9 @@\n-                    line = \"> \" + line.substring(TestFrameworkSocket.STDOUT_PREFIX.length());\n-                    System.out.println(line);\n+                    \/\/ Exclude [STDOUT] from message.\n+                    line = line.substring(TestFrameworkSocket.STDOUT_PREFIX.length());\n+                    if (line.startsWith(TestFrameworkSocket.TESTLIST_TAG)) {\n+                        \/\/ Exclude [TESTLIST] from message for better formatting.\n+                        line = \"> \" + line.substring(TestFrameworkSocket.TESTLIST_TAG.length() + 1);\n+                        testListBuilder.append(line).append(System.lineSeparator());\n+                    } else {\n+                        messagesBuilder.append(line).append(System.lineSeparator());\n+                    }\n@@ -178,1 +186,1 @@\n-                    builder.append(line).append(System.lineSeparator());\n+                    nonStdOutBuilder.append(line).append(System.lineSeparator());\n@@ -182,1 +190,12 @@\n-            irEncoding = builder.toString();\n+            if (!testListBuilder.isEmpty()) {\n+                System.out.println(\"Run flag defined test list\");\n+                System.out.println(\"--------------------------\");\n+                System.out.println(testListBuilder.toString());\n+                System.out.println();\n+            }\n+            if (!messagesBuilder.isEmpty()) {\n+                System.out.println(\"Messages from Test VM\");\n+                System.out.println(\"---------------------\");\n+                System.out.println(messagesBuilder.toString());\n+            }\n+            irEncoding = nonStdOutBuilder.toString();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+    public static final String TESTLIST_TAG = \"[TESTLIST]\";\n+    public static final String DEFAULT_REGEX_TAG = \"[DEFAULT_REGEX]\";\n+\n@@ -54,0 +57,1 @@\n+    private boolean receivedStdOut = false;\n@@ -91,0 +95,3 @@\n+                    if (next.startsWith(STDOUT_PREFIX)) {\n+                        receivedStdOut = true;\n+                    }\n@@ -111,2 +118,2 @@\n-    public static void write(String msg, String type) {\n-        write(msg, type, false);\n+    public static void write(String msg, String tag) {\n+        write(msg, tag, false);\n@@ -118,1 +125,1 @@\n-    public static void write(String msg, String type, boolean stdout) {\n+    public static void write(String msg, String tag, boolean stdout) {\n@@ -132,1 +139,1 @@\n-                msg = STDOUT_PREFIX + msg;\n+                msg = STDOUT_PREFIX + tag + \" \" + msg;\n@@ -148,1 +155,1 @@\n-            System.out.println(\"Written \" + type + \" to socket:\");\n+            System.out.println(\"Written \" + tag + \" to socket:\");\n@@ -181,0 +188,7 @@\n+\n+    \/**\n+     * Return whether test VM sent messages to be put on stdout (starting with {@link ::STDOUT_PREFIX}).\n+     *\/\n+    public boolean hasStdOut() {\n+        return receivedStdOut;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkSocket.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,0 +99,3 @@\n+        if (isDefaultRegexUnsupported(irAnno)) {\n+            return false;\n+        }\n@@ -144,0 +147,1 @@\n+    }\n@@ -145,0 +149,13 @@\n+    private boolean isDefaultRegexUnsupported(IR irAnno) {\n+        try {\n+            for (String s : irAnno.failOn()) {\n+                IRNode.checkDefaultRegexSupported(s);\n+            }\n+            for (String s : irAnno.counts()) {\n+                IRNode.checkDefaultRegexSupported(s);\n+            }\n+        } catch (CheckedTestFrameworkException e) {\n+            TestFrameworkSocket.write(\"Skip Rule \" + ruleIndex + \": \" + e.getMessage(), TestFrameworkSocket.DEFAULT_REGEX_TAG, true);\n+            return true;\n+        }\n+        return false;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-                TestFrameworkSocket.write(\"Run \" + test.toString(), \"testfilter\", true);\n+                TestFrameworkSocket.write(\"Run \" + test.toString(), TestFrameworkSocket.TESTLIST_TAG, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.test.lib.Platform;\n+import sun.hotspot.WhiteBox;\n@@ -44,1 +46,4 @@\n- * @run main\/othervm -DPrintIREncoding=true ir_framework.tests.TestIRMatching\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                               -XX:+WhiteBoxAPI -DPrintIREncoding=true  ir_framework.tests.TestIRMatching\n@@ -49,0 +54,7 @@\n+    private static final List<Exception> exceptions = new ArrayList<>();\n+\n+    private static void addException(Exception e) {\n+        System.out.println(TestFramework.getLastTestVMOutput());\n+        exceptions.add(e);\n+    }\n+\n@@ -58,1 +70,1 @@\n-        String[] allocMatches = { \"MyClass\", \"call,static  wrapper for: _new_instance_Java\" };\n+        String[] allocMatches = { \"MyClass\", \"wrapper for: _new_instance_Java\" };\n@@ -91,1 +103,1 @@\n-        String[] allocArrayMatches = { \"MyClass\", \"call,static  wrapper for: _new_array_Java\"};\n+        String[] allocArrayMatches = { \"MyClass\", \"wrapper for: _new_array_Java\"};\n@@ -108,1 +120,1 @@\n-        runCheck(new String[] {\"-XX:-UseCompressedClassPointers\"},\n+        runCheck(new String[] {\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-UseCompressedClassPointers\"},\n@@ -173,1 +185,3 @@\n-                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"intrinsic_or_type_checked_inlining\"),\n+                 WhiteBox.getWhiteBox().isJVMCISupportedByGC() ?\n+                    BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"intrinsic_or_type_checked_inlining\")\n+                    : GoodRuleConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 2),\n@@ -187,3 +201,12 @@\n-        runCheck(BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 1, \"cmp\", \"precise klass\"),\n-                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 1,\"cmp\", \"precise klass\", \"MyClass\"),\n-                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 2,\"cmp\", \"precise klass\", \"ir_framework\/tests\/MyClass\"),\n+\n+        String cmp;\n+        if (Platform.isPPC() || Platform.isX86()) {\n+            cmp = \"CMP\";\n+        } else if (Platform.isS390x()){\n+            cmp = \"CLFI\";\n+        } else {\n+            cmp = \"cmp\";\n+        }\n+        runCheck(BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 1, cmp, \"precise klass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 1,cmp, \"precise klass\", \"MyClass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 2,cmp, \"precise klass\", \"ir_framework\/tests\/MyClass\"),\n@@ -191,1 +214,3 @@\n-                 BadFailOnConstraint.create(CheckCastArray.class, \"arrayCopy(java.lang.Object[],java.lang.Class)\", 1, \"checkcast_arraycopy\")\n+                 Platform.isS390x() ? \/\/ There is no checkcast_arraycopy stub for C2 on s390\n+                     GoodFailOnConstraint.create(CheckCastArray.class, \"arrayCopy(java.lang.Object[],java.lang.Class)\", 1)\n+                     : BadFailOnConstraint.create(CheckCastArray.class, \"arrayCopy(java.lang.Object[],java.lang.Class)\", 1, \"checkcast_arraycopy\")\n@@ -201,1 +226,1 @@\n-            runWithArguments(CompilationOutputOfFails.class);\n+            runWithArgumentsFail(CompilationOutputOfFails.class);\n@@ -204,22 +229,42 @@\n-            System.out.flush();\n-            String output = baos.toString();\n-            baos.reset();\n-            Pattern pattern = Pattern.compile(\">>> Compilation.*both\\\\d.*\\\\RPrintIdeal:(?:(?!PrintOpto|>>> Compilation)[\\\\S\\\\s])+PrintOptoAssembly\");\n-            Matcher matcher = pattern.matcher(output);\n-            Asserts.assertEQ(matcher.results().count(), (long)7, \"Could not find all both methods: \" + output);\n-            pattern = Pattern.compile(\">>> Compilation.*ideal\\\\d.*\\\\RPrintIdeal:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n-            matcher = pattern.matcher(output);\n-            int count = 0;\n-            while (matcher.find()) {\n-                String match = matcher.group();\n-                Asserts.assertFalse(match.contains(\"PrintOptoAssembly\"), \"Cannot contain opto assembly: \" + output);\n-                count++;\n-            }\n-            Asserts.assertEQ(count, 7, \"Could not find all ideal methods: \" + output);\n-            pattern = Pattern.compile(\">>> Compilation.*opto\\\\d.*\\\\RPrintOptoAssembly:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n-            matcher = pattern.matcher(output);\n-            count = 0;\n-            while (matcher.find()) {\n-                String match = matcher.group();\n-                Asserts.assertFalse(match.contains(\"PrintIdeal\"), \"Cannot contain opto assembly: \" + output);\n-                count++;\n+            try {\n+                boolean failed = false;\n+                System.out.flush();\n+                String output = baos.toString();\n+                baos.reset();\n+                Pattern pattern = Pattern.compile(\">>> Compilation.*both\\\\d.*\\\\RPrintIdeal:(?:(?!PrintOpto|>>> Compilation)[\\\\S\\\\s])+PrintOptoAssembly\");\n+                Matcher matcher = pattern.matcher(output);\n+                long bothCount = matcher.results().count();\n+                if (bothCount != 7L) {\n+                    exceptions.add(new RuntimeException(\"Could not find all both() methods, expected 7 but found \" + bothCount));\n+                    failed = true;\n+                }\n+                pattern = Pattern.compile(\">>> Compilation.*ideal\\\\d.*\\\\RPrintIdeal:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+                matcher = pattern.matcher(output);\n+                int count = 0;\n+                while (matcher.find()) {\n+                    String match = matcher.group();\n+                    Asserts.assertFalse(match.contains(\"PrintOptoAssembly\"), \"Cannot contain opto assembly: \" + output);\n+                    count++;\n+                }\n+                if (count != 7) {\n+                    exceptions.add(new RuntimeException(\"Could not find all ideal() methods, expected 7 but found \" + count));\n+                    failed = true;\n+                }\n+                pattern = Pattern.compile(\">>> Compilation.*opto\\\\d.*\\\\RPrintOptoAssembly:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+                matcher = pattern.matcher(output);\n+                count = 0;\n+                while (matcher.find()) {\n+                    String match = matcher.group();\n+                    Asserts.assertFalse(match.contains(\"PrintIdeal\"), \"Cannot contain opto assembly: \" + output);\n+                    count++;\n+                }\n+                if (count != 7) {\n+                    exceptions.add(new RuntimeException(\"Could not find all opto() methods, expected 7 but found \" + count));\n+                    failed = true;\n+                }\n+                if (failed) {\n+                    System.err.println(TestFramework.getLastTestVMOutput());\n+                    System.err.println(output);\n+                }\n+            } catch (Exception e1) {\n+                addException(e1);\n@@ -227,1 +272,2 @@\n-            Asserts.assertEQ(count, 7, \"Could not find all opto methods\");\n+        } catch (Exception e) {\n+            addException(e);\n@@ -251,0 +297,10 @@\n+\n+        if (!exceptions.isEmpty()) {\n+            System.err.println(\"TestIRMatching failed with one or more exceptions:\");\n+            for (Exception e : exceptions) {\n+                System.err.println(e.getMessage());\n+                e.printStackTrace(System.err);\n+                System.err.println(\"---------\");\n+            }\n+            throw new RuntimeException(\"TestIRMatching failed with one or more exceptions - check stderr and stdout\");\n+        }\n@@ -254,0 +310,8 @@\n+        try {\n+            new TestFramework(clazz).addFlags(args).start();\n+        } catch (Exception e) {\n+            addException(e);\n+        }\n+    }\n+\n+    private static void runWithArgumentsFail(Class<?> clazz, String... args) {\n@@ -263,0 +327,2 @@\n+        } catch (Exception e) {\n+            addException(e);\n@@ -272,0 +338,2 @@\n+        } catch (Exception e) {\n+            addException(e);\n@@ -284,1 +352,1 @@\n-            throw e1;\n+            exceptions.add(e1);\n@@ -294,1 +362,7 @@\n-            constraint.checkConstraint(e);\n+            try {\n+                constraint.checkConstraint(e);\n+            } catch (Exception e1) {\n+                addException(e);\n+            }\n+        } catch (Exception e) {\n+            addException(e);\n@@ -396,1 +470,1 @@\n-    private MyClass myClass;\n+    private MyClassEmpty myClass;\n@@ -429,1 +503,1 @@\n-    @IR(failOn = {IRNode.STORE_OF_CLASS, \"MyClass\", IRNode.ALLOC, IRNode.CALL})\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"MyClassEmpty\", IRNode.ALLOC, IRNode.CALL})\n@@ -431,1 +505,1 @@\n-        myClass = new MyClass();\n+        myClass = new MyClassEmpty();\n@@ -435,1 +509,1 @@\n-    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"MyClass\"})\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"MyClassEmpty\"})\n@@ -437,1 +511,1 @@\n-        myClass = new MyClass();\n+        myClass = new MyClassEmpty();\n@@ -441,1 +515,1 @@\n-    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"ir_framework\/tests\/MyClassSub\"})\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"ir_framework\/tests\/MyClassEmptySub\"})\n@@ -443,1 +517,1 @@\n-        myClass = new MyClassSub();\n+        myClass = new MyClassEmptySub();\n@@ -567,0 +641,1 @@\n+    MyClassEmpty myClassEmpty = new MyClassEmpty();\n@@ -650,3 +725,3 @@\n-    @IR(counts = {IRNode.STORE_OF_FIELD, \"myClass\", \"1\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"1\",\n-                  IRNode.STORE_OF_CLASS, \"\/GoodCount\", \"1\", IRNode.STORE_OF_CLASS, \"MyClass\", \"0\"},\n-        failOn = {IRNode.STORE_OF_CLASS, \"MyClass\"})\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"myClassEmpty\", \"1\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"\/GoodCount\", \"1\", IRNode.STORE_OF_CLASS, \"MyClassEmpty\", \"0\"},\n+        failOn = {IRNode.STORE_OF_CLASS, \"MyClassEmpty\"})\n@@ -654,1 +729,1 @@\n-        myClass = new MyClass();\n+        myClassEmpty = new MyClassEmpty();\n@@ -1125,1 +1200,1 @@\n-        arrayCopy(mArr, MyClass2[].class);\n+        arrayCopy(mArr, MyClassEmpty[].class);\n@@ -1174,1 +1249,1 @@\n-    @IR(counts = {\"call\", \"1\"})\n+    @IR(counts = {\"call\", \"0\"})\n@@ -1183,1 +1258,1 @@\n-    @IR(counts = {\"call\", \"1\"})\n+    @IR(counts = {\"call\", \"0\"})\n@@ -1278,1 +1353,1 @@\n-    @IR(counts = {\"call\", \"1\"})\n+    @IR(counts = {\"call\", \"0\"})\n@@ -1287,1 +1362,1 @@\n-    @IR(counts = {\"call\", \"1\"})\n+    @IR(counts = {\"call\", \"0\"})\n@@ -1296,1 +1371,1 @@\n-    @IR(counts = {\"call\", \"1\"})\n+    @IR(counts = {\"call\", \"0\"})\n@@ -1305,1 +1380,1 @@\n-    @IR(counts = {\"call\", \"1\"})\n+    @IR(counts = {\"call\", \"0\"})\n@@ -1331,1 +1406,3 @@\n-class MyClass2 {}\n+class MyClassEmpty {}\n+\n+class MyClassEmptySub extends MyClassEmpty {}\n@@ -1378,1 +1455,1 @@\n-        return \"Constraint \" + getClass().getSimpleName() + \", method: \" + methodName + \", rule: \" + ruleIdx;\n+        return \"Constraint \" + getClass().getSimpleName() + \", \" + errorPrefix();\n@@ -1386,1 +1463,1 @@\n-        return \"Method \" + methodName + \", Rule \" + ruleIdx;\n+        return \"Class \" + klass.getSimpleName() + \", Method \" + methodName + \", Rule \" + ruleIdx;\n@@ -1408,2 +1485,0 @@\n-\n-    protected void checkOnMethod(String method) {}\n@@ -1541,1 +1616,3 @@\n-                            Asserts.assertTrue(matches.stream().allMatch(regexString::contains),\n+                            \/\/ Do matching on actual match and not on regex string\n+                            String actualMatch = regexString.split(\"\\\\R\", 2)[1];\n+                            Asserts.assertTrue(matches.stream().allMatch(actualMatch::contains),\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":136,"deletions":59,"binary":false,"changes":195,"status":"modified"}]}