{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,20 @@\n-traceid JfrTraceId::load_raw(jclass jc) {\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static traceid load_primitive(const oop mirror) {\n+  assert(java_lang_Class::is_primitive(mirror), \"invariant\");\n+  const Klass* const tak = java_lang_Class::array_klass_acquire(mirror);\n+  traceid id;\n+  if (tak == NULL) {\n+    \/\/ The first klass id is reserved for the void.class\n+    id = LAST_TYPE_ID + 1;\n+  } else {\n+    id = JfrTraceId::load_raw(tak) + 1;\n+  }\n+  JfrTraceIdEpoch::set_changed_tag_state();\n+  return id;\n+}\n+\n+traceid JfrTraceId::load(jclass jc, bool raw \/* false *\/) {\n@@ -162,3 +181,8 @@\n-  const oop my_oop = JNIHandles::resolve(jc);\n-  assert(my_oop != NULL, \"invariant\");\n-  return load_raw(java_lang_Class::as_Klass(my_oop));\n+  const oop mirror = JNIHandles::resolve(jc);\n+  assert(mirror != NULL, \"invariant\");\n+  const Klass* const k = java_lang_Class::as_Klass(mirror);\n+  return k != NULL ? (raw ? load_raw(k) : load(k)) : load_primitive(mirror);\n+}\n+\n+traceid JfrTraceId::load_raw(jclass jc) {\n+  return load(jc, true);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-  static traceid load(jclass jc);\n+  static traceid load(jclass jc, bool raw = false);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,0 @@\n-inline traceid JfrTraceId::load(jclass jc) {\n-  return JfrTraceIdLoadBarrier::load(jc);\n-}\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"runtime\/jniHandles.inline.hpp\"\n@@ -73,28 +71,0 @@\n-\n-\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n-\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n-\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n-\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n-\/\/ It will use a reserved constant.\n-static traceid load_primitive(const oop mirror) {\n-  assert(java_lang_Class::is_primitive(mirror), \"invariant\");\n-  const Klass* const tak = java_lang_Class::array_klass_acquire(mirror);\n-  traceid id;\n-  if (tak == NULL) {\n-    \/\/ The first klass id is reserved for the void.class\n-    id = LAST_TYPE_ID + 1;\n-  } else {\n-    id = JfrTraceId::load_raw(tak) + 1;\n-  }\n-  JfrTraceIdEpoch::set_changed_tag_state();\n-  return id;\n-}\n-\n-traceid JfrTraceIdLoadBarrier::load(jclass jc) {\n-  assert(jc != NULL, \"invariant\");\n-  assert(JavaThread::current()->thread_state() == _thread_in_vm, \"invariant\");\n-  const oop mirror = JNIHandles::resolve(jc);\n-  assert(mirror != NULL, \"invariant\");\n-  const Klass* const k = java_lang_Class::as_Klass(mirror);\n-  return k != NULL ? load(k) : load_primitive(mirror);\n-}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.cpp","additions":1,"deletions":31,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -81,1 +80,0 @@\n-  static traceid load(jclass jc);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}