{"files":[{"patch":"@@ -2687,0 +2687,2 @@\n+     *                                                                  \\\n+     * If shift is zero, an 'orr', actually a 'mov', is generated.      \\\n@@ -2689,4 +2691,9 @@\n-    int cVal = (1 << (((T >> 1) + 3) + (isSHR ? 1 : 0)));               \\\n-    int encodedShift = isSHR ? cVal - shift : cVal + shift;             \\\n-    f(0, 31), f(T & 1, 30), f(opc, 29), f(0b011110, 28, 23),            \\\n-    f(encodedShift, 22, 16); f(opc2, 15, 10), rf(Vn, 5), rf(Vd, 0);     \\\n+    if (shift == 0) {                                                   \\\n+      f(0, 31), f(T & 1, 30), f(0b001110101, 29, 21);                   \\\n+      rf(Vn, 16), f(0b000111, 15, 10), rf(Vn, 5), rf(Vd, 0);            \\\n+    } else {                                                            \\\n+      int cVal = (1 << (((T >> 1) + 3) + (isSHR ? 1 : 0)));             \\\n+      int encodedShift = isSHR ? cVal - shift : cVal + shift;           \\\n+      f(0, 31), f(T & 1, 30), f(opc, 29), f(0b011110, 28, 23),          \\\n+      f(encodedShift, 22, 16); f(opc2, 15, 10), rf(Vn, 5), rf(Vd, 0);   \\\n+    }                                                                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,494 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+import jdk.incubator.vector.*;\n+\n+\/**\n+ * @test\n+ * @bug 8261142\n+ * @summary AArch64: Incorrect instruction encoding when right-shifting vectors with shift amount equals to the element width\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:-EnableVectorReboxing compiler.vectorapi.TestVectorShiftImm\n+ *\/\n+\n+public class TestVectorShiftImm {\n+    private static final int LARGE_LEN = 128;\n+    private static final int NUM_ITERS = 200000;\n+\n+    private static final int NUM_OPS          = 5;\n+    private static final int MAX_TESTS_PER_OP = 6;\n+\n+    private static byte[]  bytesA,    bytesB;\n+    private static short[] shortsA,   shortsB;\n+    private static int[]   integersA, integersB;\n+    private static long[]  longsA,    longsB;\n+\n+    private static byte  tBytes[][],    gBytes[][];\n+    private static short tShorts[][],   gShorts[][];\n+    private static int   tIntegers[][], gIntegers[][];\n+    private static long  tLongs[][],    gLongs[][];\n+\n+    private static Random r = new Random(32781);\n+\n+    static final VectorSpecies<Byte> byte64SPECIES  = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> byte128SPECIES = ByteVector.SPECIES_128;\n+\n+    static final VectorSpecies<Short> short64SPECIES  = ShortVector.SPECIES_64;\n+    static final VectorSpecies<Short> short128SPECIES = ShortVector.SPECIES_128;\n+\n+    static final VectorSpecies<Integer> integer64SPECIES  = IntVector.SPECIES_64;\n+    static final VectorSpecies<Integer> integer128SPECIES = IntVector.SPECIES_128;\n+\n+    static final VectorSpecies<Long> long128SPECIES = LongVector.SPECIES_128;\n+\n+    static String[] opNames = {\"LSHL\", \"ASHR\", \"LSHR\", \"ASHRACC\", \"LSHRACC\"};\n+\n+    public static void main(String args[]) {\n+        test_init();\n+\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            test_vector_api_bytes();\n+            test_vector_api_shorts();\n+            test_vector_api_integers();\n+            test_vector_api_longs();\n+        }\n+\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+    static void test_vector_api_bytes() {\n+         shift_bytes(tBytes, true);\n+    }\n+\n+    static void shift_bytes(byte arrBytes[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 8; i++) {\n+            int op = 0;\n+            ByteVector vba = ByteVector.fromArray(byte64SPECIES, bytesA, 8 * i);\n+            ByteVector vbb = ByteVector.fromArray(byte64SPECIES, bytesB, 8 * i);\n+\n+            vbb.lanewise(VectorOperators.LSHL, 1).intoArray(arrBytes[op], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 8).intoArray(arrBytes[op  + 1], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 13).intoArray(arrBytes[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrBytes[op + 3], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 19).intoArray(arrBytes[op + 4], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 24).intoArray(arrBytes[op + 5], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.ASHR, 1).intoArray(arrBytes[op], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 8).intoArray(arrBytes[op + 1], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 13).intoArray(arrBytes[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrBytes[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 19).intoArray(arrBytes[op + 3], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 24).intoArray(arrBytes[op + 3], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.LSHR, 1).intoArray(arrBytes[op], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 8).intoArray(arrBytes[op + 1], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 13).intoArray(arrBytes[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrBytes[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 19).intoArray(arrBytes[op + 3], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 24).intoArray(arrBytes[op + 3], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[op], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[op + 1], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[op + 2], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[op + 2], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[op + 3], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[op + 3], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[op], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[op + 1], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[op + 2], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[op + 2], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[op + 3], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[op + 3], 8 * i);\n+        }\n+\n+        for (int i = 0; i < LARGE_LEN \/ 16; i++) {\n+            int op = 0;\n+            ByteVector vba = ByteVector.fromArray(byte128SPECIES, bytesA, 16 * i);\n+            ByteVector vbb = ByteVector.fromArray(byte128SPECIES, bytesB, 16 * i);\n+\n+            vbb.lanewise(VectorOperators.LSHL, 1).intoArray(arrBytes[op], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 8).intoArray(arrBytes[op  + 1], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 13).intoArray(arrBytes[op + 2], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrBytes[op + 3], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 19).intoArray(arrBytes[op + 4], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 24).intoArray(arrBytes[op + 5], 16 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.ASHR, 1).intoArray(arrBytes[op], 16 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 8).intoArray(arrBytes[op + 1], 16 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 13).intoArray(arrBytes[op + 2], 16 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrBytes[op + 2], 16 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 19).intoArray(arrBytes[op + 3], 16 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 24).intoArray(arrBytes[op + 3], 16 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.LSHR, 1).intoArray(arrBytes[op], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 8).intoArray(arrBytes[op + 1], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 13).intoArray(arrBytes[op + 2], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrBytes[op + 2], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 19).intoArray(arrBytes[op + 3], 16 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 24).intoArray(arrBytes[op + 3], 16 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[op], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[op + 1], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[op + 2], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[op + 2], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[op + 3], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[op + 3], 16 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[op], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[op + 1], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[op + 2], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[op + 2], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[op + 3], 16 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[op + 3], 16 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tBytes[i], gBytes[i]), i);\n+            }\n+        }\n+    }\n+\n+    static void test_vector_api_shorts() {\n+         shift_shorts(tShorts, true);\n+    }\n+\n+    static void shift_shorts(short arrShorts[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 4; i++) {\n+            int op = 0;\n+            ShortVector vba = ShortVector.fromArray(short64SPECIES, shortsA, 4 * i);\n+            ShortVector vbb = ShortVector.fromArray(short64SPECIES, shortsB, 4 * i);\n+\n+            vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrShorts[op], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrShorts[op  + 1], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrShorts[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrShorts[op + 3], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 35).intoArray(arrShorts[op + 4], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrShorts[op + 5], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrShorts[op], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrShorts[op + 1], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrShorts[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrShorts[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 35).intoArray(arrShorts[op + 3], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrShorts[op + 3], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrShorts[op], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrShorts[op + 1], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrShorts[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrShorts[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 35).intoArray(arrShorts[op + 3], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrShorts[op + 3], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[op], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[op + 1], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[op + 2], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[op + 2], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 35)).intoArray(arrShorts[op + 3], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[op + 3], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[op], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[op + 1], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[op + 2], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[op + 2], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 35)).intoArray(arrShorts[op + 3], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[op + 3], 4 * i);\n+        }\n+\n+        for (int i = 0; i < LARGE_LEN \/ 8; i++) {\n+            int op = 0;\n+            ShortVector vba = ShortVector.fromArray(short128SPECIES, shortsA, 8 * i);\n+            ShortVector vbb = ShortVector.fromArray(short128SPECIES, shortsB, 8 * i);\n+\n+            vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrShorts[op], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrShorts[op  + 1], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrShorts[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrShorts[op + 3], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 35).intoArray(arrShorts[op + 4], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrShorts[op + 5], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrShorts[op], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrShorts[op + 1], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrShorts[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrShorts[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 35).intoArray(arrShorts[op + 3], 8 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrShorts[op + 3], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrShorts[op], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrShorts[op + 1], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrShorts[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrShorts[op + 2], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 35).intoArray(arrShorts[op + 3], 8 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrShorts[op + 3], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[op], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[op + 1], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[op + 2], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[op + 2], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 35)).intoArray(arrShorts[op + 3], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[op + 3], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[op], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[op + 1], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[op + 2], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[op + 2], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 35)).intoArray(arrShorts[op + 3], 8 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[op + 3], 8 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tShorts[i], gShorts[i]), i);\n+            }\n+        }\n+    }\n+\n+    static void test_vector_api_integers() {\n+         shift_integers(tIntegers, true);\n+    }\n+\n+    static void shift_integers(int arrIntegers[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 2; i++) {\n+            int op = 0;\n+            IntVector vba = IntVector.fromArray(integer64SPECIES, integersA, 2 * i);\n+            IntVector vbb = IntVector.fromArray(integer64SPECIES, integersB, 2 * i);\n+\n+            vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrIntegers[op], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrIntegers[op  + 1], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrIntegers[op + 2], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrIntegers[op + 3], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 35).intoArray(arrIntegers[op + 4], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrIntegers[op + 5], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrIntegers[op], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrIntegers[op + 1], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrIntegers[op + 2], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrIntegers[op + 2], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 35).intoArray(arrIntegers[op + 3], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrIntegers[op + 3], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrIntegers[op], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrIntegers[op + 1], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrIntegers[op + 2], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrIntegers[op + 2], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 35).intoArray(arrIntegers[op + 3], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrIntegers[op + 3], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrIntegers[op], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrIntegers[op + 1], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrIntegers[op + 2], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[op + 2], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 35)).intoArray(arrIntegers[op + 3], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrIntegers[op + 3], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrIntegers[op], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrIntegers[op + 1], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrIntegers[op + 2], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[op + 2], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 35)).intoArray(arrIntegers[op + 3], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrIntegers[op + 3], 2 * i);\n+        }\n+\n+        for (int i = 0; i < LARGE_LEN \/ 4; i++) {\n+            int op = 0;\n+            IntVector vba = IntVector.fromArray(integer128SPECIES, integersA, 4 * i);\n+            IntVector vbb = IntVector.fromArray(integer128SPECIES, integersB, 4 * i);\n+\n+            vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrIntegers[op], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrIntegers[op  + 1], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrIntegers[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrIntegers[op + 3], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 35).intoArray(arrIntegers[op + 4], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrIntegers[op + 5], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrIntegers[op], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrIntegers[op + 1], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrIntegers[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrIntegers[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 35).intoArray(arrIntegers[op + 3], 4 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrIntegers[op + 3], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrIntegers[op], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrIntegers[op + 1], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrIntegers[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrIntegers[op + 2], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 35).intoArray(arrIntegers[op + 3], 4 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrIntegers[op + 3], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrIntegers[op], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrIntegers[op + 1], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrIntegers[op + 2], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[op + 2], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 35)).intoArray(arrIntegers[op + 3], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrIntegers[op + 3], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrIntegers[op], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrIntegers[op + 1], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrIntegers[op + 2], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[op + 2], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 35)).intoArray(arrIntegers[op + 3], 4 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrIntegers[op + 3], 4 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tIntegers[i], gIntegers[i]), i);\n+            }\n+        }\n+    }\n+\n+    static void test_vector_api_longs() {\n+         shift_longs(tLongs, true);\n+    }\n+\n+    static void shift_longs(long arrLongs[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 2; i++) {\n+            int op = 0;\n+            LongVector vba = LongVector.fromArray(long128SPECIES, longsA, 2 * i);\n+            LongVector vbb = LongVector.fromArray(long128SPECIES, longsB, 2 * i);\n+\n+            vbb.lanewise(VectorOperators.LSHL, 37).intoArray(arrLongs[op], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 64).intoArray(arrLongs[op  + 1], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 99).intoArray(arrLongs[op + 2], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 128).intoArray(arrLongs[op + 3], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 157).intoArray(arrLongs[op + 4], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHL, 192).intoArray(arrLongs[op + 5], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.ASHR, 37).intoArray(arrLongs[op], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 64).intoArray(arrLongs[op  + 1], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 99).intoArray(arrLongs[op + 2], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 128).intoArray(arrLongs[op + 3], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 157).intoArray(arrLongs[op + 4], 2 * i);\n+            vbb.lanewise(VectorOperators.ASHR, 192).intoArray(arrLongs[op + 5], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vbb.lanewise(VectorOperators.LSHR, 37).intoArray(arrLongs[op], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 64).intoArray(arrLongs[op  + 1], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 99).intoArray(arrLongs[op + 2], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 128).intoArray(arrLongs[op + 3], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 157).intoArray(arrLongs[op + 4], 2 * i);\n+            vbb.lanewise(VectorOperators.LSHR, 192).intoArray(arrLongs[op + 5], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 37)).intoArray(arrLongs[op], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 64)).intoArray(arrLongs[op + 1], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 99)).intoArray(arrLongs[op + 2], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 128)).intoArray(arrLongs[op + 2], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 157)).intoArray(arrLongs[op + 3], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.ASHR, 192)).intoArray(arrLongs[op + 3], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 37)).intoArray(arrLongs[op], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 64)).intoArray(arrLongs[op + 1], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 99)).intoArray(arrLongs[op + 2], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 128)).intoArray(arrLongs[op + 2], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 157)).intoArray(arrLongs[op + 3], 2 * i);\n+            vba.add(vbb.lanewise(VectorOperators.LSHR, 192)).intoArray(arrLongs[op + 3], 2 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tLongs[i], gLongs[i]), i);\n+            }\n+        }\n+    }\n+\n+    static void test_init() {\n+        int count = LARGE_LEN;\n+\n+        bytesA    = new byte[count];\n+        shortsA   = new short[count];\n+        integersA = new int[count];\n+        longsA    = new long[count];\n+\n+        bytesB    = new byte[count];\n+        shortsB   = new short[count];\n+        integersB = new int[count];\n+        longsB    = new long[count];\n+\n+        tBytes    = new byte[MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tShorts   = new short[MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tIntegers = new int[MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tLongs    = new long[MAX_TESTS_PER_OP * NUM_OPS][count];\n+\n+        gBytes    = new byte[MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gShorts   = new short[MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gIntegers = new int[MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gLongs    = new long[MAX_TESTS_PER_OP * NUM_OPS][count];\n+\n+        for (int i = 0; i < count; i++) {\n+            bytesA[i]    = (byte) r.nextInt();\n+            shortsA[i]   = (short) r.nextInt();\n+            integersA[i] = r.nextInt();\n+            longsA[i]    = r.nextLong();\n+\n+            bytesB[i]    = (byte) r.nextInt();\n+            shortsB[i]   = (short) r.nextInt();\n+            integersB[i] = r.nextInt();\n+            longsB[i]    = r.nextLong();\n+        }\n+\n+        shift_bytes(gBytes,   false);\n+        shift_shorts(gShorts, false);\n+        shift_integers(gIntegers, false);\n+        shift_longs(gLongs, false);\n+    }\n+\n+    static void assertTrue(boolean okay, int i) {\n+        if (!okay) {\n+            throw new RuntimeException(\"Test Failed, verify index \" + i + \", shift operation \" + opNames[i \/ MAX_TESTS_PER_OP]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShiftImm.java","additions":494,"deletions":0,"binary":false,"changes":494,"status":"added"}]}