{"files":[{"patch":"@@ -2688,0 +2688,1 @@\n+    assert(!isSHR || (isSHR && (shift != 0)), \"Zero right shift\");      \\\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -530,0 +530,27 @@\n+  \/\/ AdvSIMD shift by immediate.\n+  \/\/ These are \"user friendly\" variants which allow a shift count of 0.\n+#define WRAP(INSN)                                                                \\\n+  void INSN(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift) {  \\\n+    if (shift == 0) {                                                             \\\n+      SIMD_Arrangement arrange = (T & 1) == 0 ? T8B : T16B;                       \\\n+      Assembler::orr(Vd, arrange, Vn, Vn);                                        \\\n+    } else {                                                                      \\\n+      Assembler::INSN(Vd, T, Vn, shift);                                          \\\n+    }                                                                             \\\n+  }                                                                               \\\n+\n+  WRAP(shl) WRAP(sshr) WRAP(ushr)\n+#undef WRAP\n+\n+#define WRAP(INSN)                                                                \\\n+  void INSN(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift) {  \\\n+    if (shift == 0) {                                                             \\\n+      Assembler::addv(Vd, T, Vd, Vn);                                             \\\n+    } else {                                                                      \\\n+      Assembler::INSN(Vd, T, Vn, shift);                                          \\\n+    }                                                                             \\\n+  }                                                                               \\\n+\n+  WRAP(usra) WRAP(ssra)\n+#undef WRAP\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,656 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+import jdk.incubator.vector.*;\n+\n+\/**\n+ * @test\n+ * @bug 8261142\n+ * @summary AArch64: Incorrect instruction encoding when right-shifting vectors with shift amount equals to the element width\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run main\/othervm -XX:CompileThreshold=1000 -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=print,compiler\/vectorapi\/TestVectorShiftImm.shift_*\n+ *                   -Dvlen=64 compiler.vectorapi.TestVectorShiftImm\n+ * @run main\/othervm -XX:CompileThreshold=1000 -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=print,compiler\/vectorapi\/TestVectorShiftImm.shift_*\n+ *                   -Dvlen=128 compiler.vectorapi.TestVectorShiftImm\n+ *\/\n+\n+public class TestVectorShiftImm {\n+    private static final int LARGE_LEN = 256;\n+    private static final int NUM_ITERS = 50000;\n+\n+    private static final int NUM_OPS          = 5;\n+    private static final int ACCUMULATE_OP_S  = 3;\n+    private static final int MAX_TESTS_PER_OP = 6;\n+    private static final int VLENS            = 2;\n+\n+    private static byte[]  bytesA,    bytesB;\n+    private static short[] shortsA,   shortsB;\n+    private static int[]   integersA, integersB;\n+    private static long[]  longsA,    longsB;\n+\n+    private static byte  tBytes[][],    gBytes[][];\n+    private static short tShorts[][],   gShorts[][];\n+    private static int   tIntegers[][], gIntegers[][];\n+    private static long  tLongs[][],    gLongs[][];\n+\n+    private static Random r = new Random(32781);\n+\n+    static final VectorSpecies<Byte> byte64SPECIES  = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> byte128SPECIES = ByteVector.SPECIES_128;\n+\n+    static final VectorSpecies<Short> short64SPECIES  = ShortVector.SPECIES_64;\n+    static final VectorSpecies<Short> short128SPECIES = ShortVector.SPECIES_128;\n+\n+    static final VectorSpecies<Integer> integer64SPECIES  = IntVector.SPECIES_64;\n+    static final VectorSpecies<Integer> integer128SPECIES = IntVector.SPECIES_128;\n+\n+    static final VectorSpecies<Long> long128SPECIES = LongVector.SPECIES_128;\n+\n+    static String[] opNames = {\"LSHL\", \"ASHR\", \"LSHR\", \"ASHR_AND_ACCUMULATE\", \"LSHR_AND_ACCUMULATE\"};\n+\n+    static boolean allTestsPassed = true;\n+    static StringBuilder errMsg = new StringBuilder();\n+\n+    public static void main(String args[]) {\n+\n+        int vlen = Integer.parseInt(System.getProperty(\"vlen\", \"\"));\n+\n+        test_init();\n+\n+        if (vlen == 64) {\n+            test_shift_and_accumulate_vlen64();\n+            test_shift_immediate_vlen64();\n+        }\n+\n+        if (vlen == 128) {\n+            test_shift_and_accumulate_vlen128();\n+            test_shift_immediate_vlen128();\n+        }\n+\n+        if (allTestsPassed) {\n+            System.out.println(\"Test PASSED\");\n+        } else {\n+            throw new RuntimeException(\"Test Failed, failed tests:\\n\" + errMsg.toString());\n+        }\n+    }\n+\n+    static void test_shift_and_accumulate_vlen64() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_and_accumulate_bytes64(tBytes,        true);\n+            shift_and_accumulate_shorts64(tShorts,      true);\n+            shift_and_accumulate_integers64(tIntegers,  true);\n+        }\n+    }\n+\n+    static void test_shift_and_accumulate_vlen128() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_and_accumulate_bytes128(tBytes,        true);\n+            shift_and_accumulate_shorts128(tShorts,      true);\n+            shift_and_accumulate_integers128(tIntegers,  true);\n+            shift_and_accumulate_longs128(tLongs,        true);\n+        }\n+    }\n+\n+    static void test_shift_immediate_vlen64() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_bytes64(tBytes,        true);\n+            shift_shorts64(tShorts,      true);\n+            shift_integers64(tIntegers,  true);\n+        }\n+    }\n+\n+    static void test_shift_immediate_vlen128() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_bytes128(tBytes,        true);\n+            shift_shorts128(tShorts,      true);\n+            shift_integers128(tIntegers,  true);\n+            shift_longs128(tLongs,        true);\n+        }\n+    }\n+\n+    static int shift_op_byte_LSHL(ByteVector vbb, byte arrBytes[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.LSHL, 1).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 8).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 13).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 19).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 24).intoArray(arrBytes[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_byte_ASHR(ByteVector vbb, byte arrBytes[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.ASHR, 1).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 8).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 13).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 19).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 24).intoArray(arrBytes[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_byte_LSHR(ByteVector vbb, byte arrBytes[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.LSHR, 1).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 8).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 13).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 19).intoArray(arrBytes[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 24).intoArray(arrBytes[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_byte_ASHR_and_ADD(ByteVector vba, ByteVector vbb, byte arrBytes[][], int end, int ind) {\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_byte_LSHR_and_ADD(ByteVector vba, ByteVector vbb, byte arrBytes[][], int end, int ind) {\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[end++], ind);\n+        return end;\n+    }\n+\n+    static void shift_bytes64(byte arrBytes[][], boolean verify) {\n+        int start = 0, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 16) {\n+            end = start;\n+            ByteVector vbb64 = ByteVector.fromArray(byte64SPECIES, bytesB, i);\n+            end = shift_op_byte_LSHL(vbb64, arrBytes, end, i);\n+            end = shift_op_byte_ASHR(vbb64, arrBytes, end, i);\n+            end = shift_op_byte_LSHR(vbb64, arrBytes, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_bytes64(byte arrBytes[][], boolean verify) {\n+        int start = ACCUMULATE_OP_S * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 16) {\n+            end = start;\n+            ByteVector vba64 = ByteVector.fromArray(byte64SPECIES, bytesA, i);\n+            ByteVector vbb64 = ByteVector.fromArray(byte64SPECIES, bytesB, i);\n+            end = shift_op_byte_ASHR_and_ADD(vba64, vbb64, arrBytes, end,  i);\n+            end = shift_op_byte_LSHR_and_ADD(vba64, vbb64, arrBytes, end,  i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_bytes128(byte arrBytes[][], boolean verify) {\n+        int start = NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 32) {\n+            end = start;\n+            ByteVector vbb128 = ByteVector.fromArray(byte128SPECIES, bytesB, i);\n+            end = shift_op_byte_LSHL(vbb128, arrBytes, end, i);\n+            end = shift_op_byte_ASHR(vbb128, arrBytes, end, i);\n+            end = shift_op_byte_LSHR(vbb128, arrBytes, end, i);\n+\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_bytes128(byte arrBytes[][], boolean verify) {\n+        int start = (NUM_OPS + ACCUMULATE_OP_S) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 32) {\n+            end = start;\n+            ByteVector vba128 = ByteVector.fromArray(byte128SPECIES, bytesA, i);\n+            ByteVector vbb128 = ByteVector.fromArray(byte128SPECIES, bytesB, i);\n+            end = shift_op_byte_ASHR_and_ADD(vba128, vbb128, arrBytes, end,  i);\n+            end = shift_op_byte_LSHR_and_ADD(vba128, vbb128, arrBytes, end,  i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static int shift_op_short_LSHL(ShortVector vbb, short arrShorts[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 43).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrShorts[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_short_ASHR(ShortVector vbb, short arrShorts[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 43).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrShorts[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_short_LSHR(ShortVector vbb, short arrShorts[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 43).intoArray(arrShorts[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrShorts[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_short_ASHR_and_ADD(ShortVector vba, ShortVector vbb, short arrShorts[][], int end, int ind) {\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 43)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_short_LSHR_and_ADD(ShortVector vba, ShortVector vbb, short arrShorts[][], int end, int ind) {\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 43)).intoArray(arrShorts[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[end++], ind);\n+        return end;\n+    }\n+\n+    static void shift_shorts64(short arrShorts[][], boolean verify) {\n+        int start = 0, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 8) {\n+            end = start;\n+            ShortVector vbb64 = ShortVector.fromArray(short64SPECIES, shortsB, i);\n+            end = shift_op_short_LSHL(vbb64, arrShorts, end, i);\n+            end = shift_op_short_ASHR(vbb64, arrShorts, end, i);\n+            end = shift_op_short_LSHR(vbb64, arrShorts, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_shorts64(short arrShorts[][], boolean verify) {\n+        int start = ACCUMULATE_OP_S * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 8) {\n+            end = start;\n+            ShortVector vba64 = ShortVector.fromArray(short64SPECIES, shortsA, i);\n+            ShortVector vbb64 = ShortVector.fromArray(short64SPECIES, shortsB, i);\n+            end = shift_op_short_ASHR_and_ADD(vba64, vbb64, arrShorts, end,    i);\n+            end = shift_op_short_LSHR_and_ADD(vba64, vbb64, arrShorts, end,    i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_shorts128(short arrShorts[][], boolean verify) {\n+        int start = NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 16) {\n+            end = start;\n+            ShortVector vbb128 = ShortVector.fromArray(short128SPECIES, shortsB, i);\n+            end = shift_op_short_LSHL(vbb128, arrShorts, end, i);\n+            end = shift_op_short_ASHR(vbb128, arrShorts, end, i);\n+            end = shift_op_short_LSHR(vbb128, arrShorts, end, i);\n+\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_shorts128(short arrShorts[][], boolean verify) {\n+        int start = (NUM_OPS + ACCUMULATE_OP_S) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 16) {\n+            end = start;\n+            ShortVector vba128 = ShortVector.fromArray(short128SPECIES, shortsA, i);\n+            ShortVector vbb128 = ShortVector.fromArray(short128SPECIES, shortsB, i);\n+            end = shift_op_short_ASHR_and_ADD(vba128, vbb128, arrShorts, end,    i);\n+            end = shift_op_short_LSHR_and_ADD(vba128, vbb128, arrShorts, end,    i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static int shift_op_integer_LSHL(IntVector vbb, int arrIntegers[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.LSHL, 17).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 53).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 64).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 76).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 96).intoArray(arrIntegers[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_integer_ASHR(IntVector vbb, int arrIntegers[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.ASHR, 17).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 53).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 64).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 76).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 96).intoArray(arrIntegers[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_integer_LSHR(IntVector vbb, int arrIntegers[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.LSHR, 17).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 53).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 64).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 76).intoArray(arrIntegers[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 96).intoArray(arrIntegers[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_integer_ASHR_and_ADD(IntVector vba, IntVector vbb, int arrIntegers[][], int end, int ind) {\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 17)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 53)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 64)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 76)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 96)).intoArray(arrIntegers[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_integer_LSHR_and_ADD(IntVector vba, IntVector vbb, int arrIntegers[][], int end, int ind) {\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 17)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 53)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 64)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 76)).intoArray(arrIntegers[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 96)).intoArray(arrIntegers[end++], ind);\n+        return end;\n+    }\n+\n+    static void shift_integers64(int arrIntegers[][], boolean verify) {\n+        int start = 0, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 4) {\n+            end = start;\n+            IntVector vbb64 = IntVector.fromArray(integer64SPECIES, integersB, i);\n+            end = shift_op_integer_LSHL(vbb64, arrIntegers, end, i);\n+            end = shift_op_integer_ASHR(vbb64, arrIntegers, end, i);\n+            end = shift_op_integer_LSHR(vbb64, arrIntegers, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_integers64(int arrIntegers[][], boolean verify) {\n+        int start = ACCUMULATE_OP_S * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 4) {\n+            end = start;\n+            IntVector vba64 = IntVector.fromArray(integer64SPECIES, integersA,  i);\n+            IntVector vbb64 = IntVector.fromArray(integer64SPECIES, integersB,  i);\n+            end = shift_op_integer_ASHR_and_ADD(vba64, vbb64, arrIntegers, end, i);\n+            end = shift_op_integer_LSHR_and_ADD(vba64, vbb64, arrIntegers, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_integers128(int arrIntegers[][], boolean verify) {\n+        int start = NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 8) {\n+            end = start;\n+            IntVector vbb128 = IntVector.fromArray(integer128SPECIES, integersB, i);\n+            end = shift_op_integer_LSHL(vbb128, arrIntegers, end, i);\n+            end = shift_op_integer_ASHR(vbb128, arrIntegers, end, i);\n+            end = shift_op_integer_LSHR(vbb128, arrIntegers, end, i);\n+\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_integers128(int arrIntegers[][], boolean verify) {\n+        int start = (NUM_OPS + ACCUMULATE_OP_S) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 8) {\n+            end = start;\n+            IntVector vba128 = IntVector.fromArray(integer128SPECIES, integersA,  i);\n+            IntVector vbb128 = IntVector.fromArray(integer128SPECIES, integersB,  i);\n+            end = shift_op_integer_ASHR_and_ADD(vba128, vbb128, arrIntegers, end, i);\n+            end = shift_op_integer_LSHR_and_ADD(vba128, vbb128, arrIntegers, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static int shift_op_long_LSHL(LongVector vbb, long arrLongs[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.LSHL, 37).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 64).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 99).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 128).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 157).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHL, 192).intoArray(arrLongs[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_long_ASHR(LongVector vbb, long arrLongs[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.ASHR, 37).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 64).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 99).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 128).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 157).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.ASHR, 192).intoArray(arrLongs[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_long_LSHR(LongVector vbb, long arrLongs[][], int end, int ind) {\n+        vbb.lanewise(VectorOperators.LSHR, 37).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 64).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 99).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 128).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 157).intoArray(arrLongs[end++], ind);\n+        vbb.lanewise(VectorOperators.LSHR, 192).intoArray(arrLongs[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_long_ASHR_and_ADD(LongVector vba, LongVector vbb, long arrLongs[][], int end, int ind) {\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 37)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 64)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 99)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 128)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 157)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.ASHR, 192)).intoArray(arrLongs[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_op_long_LSHR_and_ADD(LongVector vba, LongVector vbb, long arrLongs[][], int end, int ind) {\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 37)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 64)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 99)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 128)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 157)).intoArray(arrLongs[end++], ind);\n+        vba.add(vbb.lanewise(VectorOperators.LSHR, 192)).intoArray(arrLongs[end++], ind);\n+        return end;\n+    }\n+\n+    static void shift_longs128(long arrLongs[][], boolean verify) {\n+        int start = NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 2) {\n+            end = start;\n+            LongVector vbb128 = LongVector.fromArray(long128SPECIES, longsB, i);\n+            end = shift_op_long_LSHL(vbb128, arrLongs, end, i);\n+            end = shift_op_long_ASHR(vbb128, arrLongs, end, i);\n+            end = shift_op_long_LSHR(vbb128, arrLongs, end, i);\n+\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"LONG\", Arrays.equals(tLongs[i], gLongs[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_longs128(long arrLongs[][], boolean verify) {\n+        int start = (NUM_OPS + ACCUMULATE_OP_S) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN; i += 2) {\n+            end = start;\n+            LongVector vba128 = LongVector.fromArray(long128SPECIES, longsA, i);\n+            LongVector vbb128 = LongVector.fromArray(long128SPECIES, longsB, i);\n+            end = shift_op_long_ASHR_and_ADD(vba128, vbb128, arrLongs, end,  i);\n+            end = shift_op_long_LSHR_and_ADD(vba128, vbb128, arrLongs, end,  i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"LONG\", Arrays.equals(tLongs[i], gLongs[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void test_init() {\n+        int count = LARGE_LEN;\n+\n+        bytesA    = new byte[count];\n+        shortsA   = new short[count];\n+        integersA = new int[count];\n+        longsA    = new long[count];\n+\n+        bytesB    = new byte[count];\n+        shortsB   = new short[count];\n+        integersB = new int[count];\n+        longsB    = new long[count];\n+\n+        tBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tLongs    = new long[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+\n+        gBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gLongs    = new long[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+\n+        for (int i = 0; i < count; i++) {\n+            bytesA[i]    = (byte) r.nextInt();\n+            shortsA[i]   = (short) r.nextInt();\n+            integersA[i] = r.nextInt();\n+            longsA[i]    = r.nextLong();\n+\n+            bytesB[i]    = (byte) r.nextInt();\n+            shortsB[i]   = (short) r.nextInt();\n+            integersB[i] = r.nextInt();\n+            longsB[i]    = r.nextLong();\n+        }\n+\n+        shift_bytes64(gBytes,        false);\n+        shift_bytes128(gBytes,       false);\n+        shift_shorts64(gShorts,      false);\n+        shift_shorts128(gShorts,     false);\n+        shift_integers64(gIntegers,  false);\n+        shift_integers128(gIntegers, false);\n+        shift_longs128(gLongs,       false);\n+\n+        shift_and_accumulate_bytes64(gBytes,        false);\n+        shift_and_accumulate_bytes128(gBytes,       false);\n+        shift_and_accumulate_shorts64(gShorts,      false);\n+        shift_and_accumulate_shorts128(gShorts,     false);\n+        shift_and_accumulate_integers64(gIntegers,  false);\n+        shift_and_accumulate_integers128(gIntegers, false);\n+        shift_and_accumulate_longs128(gLongs,       false);\n+    }\n+\n+    static void assertTrue(String type, boolean okay, int i, int vlen) {\n+        int op = i % (MAX_TESTS_PER_OP * NUM_OPS) \/ MAX_TESTS_PER_OP;\n+        if (!okay) {\n+            allTestsPassed = false;\n+            if (!errMsg.toString().contains(\"type \" + type + \" index \" + i)) {\n+                errMsg.append(\"type \" + type + \" index \" + i + \", operation \" + opNames[op] + \", vector length \"+ vlen + \".\\n\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShiftImm.java","additions":656,"deletions":0,"binary":false,"changes":656,"status":"added"}]}