{"files":[{"patch":"@@ -530,1 +530,2 @@\n-  \/\/ NEON shift instructions\n+  \/\/ AdvSIMD shift by immediate.\n+  \/\/ These are \"user friendly\" variants which allow a shift count of 0.\n@@ -534,2 +535,2 @@\n-        SIMD_Arrangement arrange = (T & 1) == 0 ? T8B : T16B;                     \\\n-        Assembler::orr(Vd, arrange, Vn, Vn);                                      \\\n+      SIMD_Arrangement arrange = (T & 1) == 0 ? T8B : T16B;                       \\\n+      Assembler::orr(Vd, arrange, Vn, Vn);                                        \\\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    private static final int NUM_OPS          = 5;\n+    private static final int NUM_OPS          = 3;\n@@ -70,1 +70,1 @@\n-    static String[] opNames = {\"LSHL\", \"ASHR\", \"LSHR\", \"ASHRACC\", \"LSHRACC\"};\n+    static String[] opNames = {\"LSHL\", \"ASHR\", \"LSHR\"};\n@@ -117,16 +117,0 @@\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[op], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[op  + 1], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[op + 2], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[op + 3], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[op + 4], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[op + 5], 8 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[op], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[op  + 1], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[op + 2], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[op + 3], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[op + 4], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[op + 5], 8 * i);\n@@ -168,16 +152,0 @@\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[op], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[op  + 1], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[op + 2], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[op + 3], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[op + 4], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[op + 5], 16 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[op], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[op  + 1], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[op + 2], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[op + 3], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[op + 4], 16 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[op + 5], 16 * i);\n@@ -225,16 +193,0 @@\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[op], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[op + 1], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[op + 2], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[op + 3], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 35)).intoArray(arrShorts[op + 4], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[op + 5], 4 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[op], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[op + 1], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[op + 2], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[op + 3], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 35)).intoArray(arrShorts[op + 4], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[op + 5], 4 * i);\n@@ -276,16 +228,0 @@\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[op], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[op + 1], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[op + 2], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[op + 3], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 35)).intoArray(arrShorts[op + 4], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[op + 5], 8 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[op], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[op + 1], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[op + 2], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[op + 3], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 35)).intoArray(arrShorts[op + 4], 8 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[op + 5], 8 * i);\n@@ -333,16 +269,0 @@\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrIntegers[op], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrIntegers[op + 1], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrIntegers[op + 2], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[op + 3], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 35)).intoArray(arrIntegers[op + 4], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrIntegers[op + 5], 2 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrIntegers[op], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrIntegers[op + 1], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrIntegers[op + 2], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[op + 3], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 35)).intoArray(arrIntegers[op + 4], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrIntegers[op + 5], 2 * i);\n@@ -384,16 +304,0 @@\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 9)).intoArray(arrIntegers[op], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 16)).intoArray(arrIntegers[op + 1], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 27)).intoArray(arrIntegers[op + 2], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[op + 3], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 35)).intoArray(arrIntegers[op + 4], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 48)).intoArray(arrIntegers[op + 5], 4 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 9)).intoArray(arrIntegers[op], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 16)).intoArray(arrIntegers[op + 1], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 27)).intoArray(arrIntegers[op + 2], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[op + 3], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 35)).intoArray(arrIntegers[op + 4], 4 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 48)).intoArray(arrIntegers[op + 5], 4 * i);\n@@ -441,16 +345,0 @@\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 37)).intoArray(arrLongs[op], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 64)).intoArray(arrLongs[op  + 1], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 99)).intoArray(arrLongs[op  + 2], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 128)).intoArray(arrLongs[op + 3], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 157)).intoArray(arrLongs[op + 4], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.ASHR, 192)).intoArray(arrLongs[op + 5], 2 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 37)).intoArray(arrLongs[op], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 64)).intoArray(arrLongs[op  + 1], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 99)).intoArray(arrLongs[op  + 2], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 128)).intoArray(arrLongs[op + 3], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 157)).intoArray(arrLongs[op + 4], 2 * i);\n-            vba.add(vbb.lanewise(VectorOperators.LSHR, 192)).intoArray(arrLongs[op + 5], 2 * i);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShiftImm.java","additions":2,"deletions":114,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+import jdk.incubator.vector.*;\n+\n+\/**\n+ * @test\n+ * @bug 8261142\n+ * @summary AArch64: Incorrect instruction encoding when right-shifting vectors with shift amount equals to the element width\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run main\/othervm compiler.vectorapi.TestVectorShiftImmAndAccumulate\n+ *\/\n+\n+public class TestVectorShiftImmAndAccumulate {\n+    private static final int LARGE_LEN = 128;\n+    private static final int NUM_ITERS = 200000;\n+\n+    private static final int NUM_OPS          = 2;\n+    private static final int MAX_TESTS_PER_OP = 6;\n+    private static final int VLENS            = 2;\n+\n+    private static byte[]  bytesA,    bytesB;\n+    private static short[] shortsA,   shortsB;\n+    private static int[]   integersA, integersB;\n+    private static long[]  longsA,    longsB;\n+\n+    private static byte  tBytes[][],    gBytes[][];\n+    private static short tShorts[][],   gShorts[][];\n+    private static int   tIntegers[][], gIntegers[][];\n+    private static long  tLongs[][],    gLongs[][];\n+\n+    private static Random r = new Random(32781);\n+\n+    static final VectorSpecies<Byte> byte64SPECIES  = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> byte128SPECIES = ByteVector.SPECIES_128;\n+\n+    static final VectorSpecies<Short> short64SPECIES  = ShortVector.SPECIES_64;\n+    static final VectorSpecies<Short> short128SPECIES = ShortVector.SPECIES_128;\n+\n+    static final VectorSpecies<Integer> integer64SPECIES  = IntVector.SPECIES_64;\n+    static final VectorSpecies<Integer> integer128SPECIES = IntVector.SPECIES_128;\n+\n+    static final VectorSpecies<Long> long128SPECIES = LongVector.SPECIES_128;\n+\n+    static String[] opNames = {\"ASHR_AND_ACCUMULATE\", \"LSHR_AND_ACCUMULATE\"};\n+\n+    public static void main(String args[]) {\n+        test_init();\n+\n+        test_shift_and_accumulte_vlen64();\n+        test_shift_and_accumulte_vlen128();\n+\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+    static void test_shift_and_accumulte_vlen64() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_bytes64(tBytes,        true);\n+            shift_shorts64(tShorts,      true);\n+            shift_integers64(tIntegers,  true);\n+        }\n+    }\n+\n+    static void test_shift_and_accumulte_vlen128() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_bytes128(tBytes,        true);\n+            shift_shorts128(tShorts,      true);\n+            shift_integers128(tIntegers,  true);\n+            shift_longs128(tLongs,        true);\n+        }\n+    }\n+\n+    static void shift_bytes64(byte arrBytes[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 8; i++) {\n+            int op = 0;\n+            ByteVector vba64 = ByteVector.fromArray(byte64SPECIES, bytesA, 8 * i);\n+            ByteVector vbb64 = ByteVector.fromArray(byte64SPECIES, bytesB, 8 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[op], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[op  + 1], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[op + 2], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[op + 3], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[op + 4], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[op + 5], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[op], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[op  + 1], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[op + 2], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[op + 3], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[op + 4], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[op + 5], 8 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tBytes[i], gBytes[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_bytes128(byte arrBytes[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 16; i++) {\n+            int op = NUM_OPS * MAX_TESTS_PER_OP;\n+            ByteVector vba128 = ByteVector.fromArray(byte128SPECIES, bytesA, 16 * i);\n+            ByteVector vbb128 = ByteVector.fromArray(byte128SPECIES, bytesB, 16 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[op], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[op  + 1], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[op + 2], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[op + 3], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[op + 4], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[op + 5], 16 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[op], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[op  + 1], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[op + 2], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[op + 3], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[op + 4], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[op + 5], 16 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = NUM_OPS * MAX_TESTS_PER_OP; i < VLENS * NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tBytes[i], gBytes[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_shorts64(short arrShorts[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 4; i++) {\n+            int op = 0;\n+            ShortVector vba64 = ShortVector.fromArray(short64SPECIES, shortsA, 4 * i);\n+            ShortVector vbb64 = ShortVector.fromArray(short64SPECIES, shortsB, 4 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[op], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[op + 1], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[op + 2], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[op + 3], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 35)).intoArray(arrShorts[op + 4], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[op + 5], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[op], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[op + 1], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[op + 2], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[op + 3], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 35)).intoArray(arrShorts[op + 4], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[op + 5], 4 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tShorts[i], gShorts[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_shorts128(short arrShorts[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 8; i++) {\n+            int op = NUM_OPS * MAX_TESTS_PER_OP;\n+            ShortVector vba128 = ShortVector.fromArray(short128SPECIES, shortsA, 8 * i);\n+            ShortVector vbb128 = ShortVector.fromArray(short128SPECIES, shortsB, 8 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[op], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[op + 1], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[op + 2], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[op + 3], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 35)).intoArray(arrShorts[op + 4], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[op + 5], 8 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[op], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[op + 1], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[op + 2], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[op + 3], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 35)).intoArray(arrShorts[op + 4], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[op + 5], 8 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = NUM_OPS * MAX_TESTS_PER_OP; i < VLENS * NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tShorts[i], gShorts[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_integers64(int arrIntegers[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 2; i++) {\n+            int op = 0;\n+            IntVector vba64 = IntVector.fromArray(integer64SPECIES, integersA, 2 * i);\n+            IntVector vbb64 = IntVector.fromArray(integer64SPECIES, integersB, 2 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 9)).intoArray(arrIntegers[op], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 16)).intoArray(arrIntegers[op + 1], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 27)).intoArray(arrIntegers[op + 2], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[op + 3], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 35)).intoArray(arrIntegers[op + 4], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 48)).intoArray(arrIntegers[op + 5], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 9)).intoArray(arrIntegers[op], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 16)).intoArray(arrIntegers[op + 1], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 27)).intoArray(arrIntegers[op + 2], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[op + 3], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 35)).intoArray(arrIntegers[op + 4], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 48)).intoArray(arrIntegers[op + 5], 2 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tIntegers[i], gIntegers[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_integers128(int arrIntegers[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 4; i++) {\n+            int op = NUM_OPS * MAX_TESTS_PER_OP;\n+            IntVector vba128 = IntVector.fromArray(integer128SPECIES, integersA, 4 * i);\n+            IntVector vbb128 = IntVector.fromArray(integer128SPECIES, integersB, 4 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 9)).intoArray(arrIntegers[op], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 16)).intoArray(arrIntegers[op + 1], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 27)).intoArray(arrIntegers[op + 2], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[op + 3], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 35)).intoArray(arrIntegers[op + 4], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 48)).intoArray(arrIntegers[op + 5], 4 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 9)).intoArray(arrIntegers[op], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 16)).intoArray(arrIntegers[op + 1], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 27)).intoArray(arrIntegers[op + 2], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[op + 3], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 35)).intoArray(arrIntegers[op + 4], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 48)).intoArray(arrIntegers[op + 5], 4 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = NUM_OPS * MAX_TESTS_PER_OP; i < VLENS * NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tIntegers[i], gIntegers[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_longs128(long arrLongs[][], boolean verify) {\n+        for (int i = 0; i < LARGE_LEN \/ 2; i++) {\n+            int op = 0;\n+            LongVector vba128 = LongVector.fromArray(long128SPECIES, longsA, 2 * i);\n+            LongVector vbb128 = LongVector.fromArray(long128SPECIES, longsB, 2 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 37)).intoArray(arrLongs[op], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 64)).intoArray(arrLongs[op  + 1], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 99)).intoArray(arrLongs[op  + 2], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 128)).intoArray(arrLongs[op + 3], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 157)).intoArray(arrLongs[op + 4], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 192)).intoArray(arrLongs[op + 5], 2 * i);\n+            op += MAX_TESTS_PER_OP;\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 37)).intoArray(arrLongs[op], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 64)).intoArray(arrLongs[op  + 1], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 99)).intoArray(arrLongs[op  + 2], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 128)).intoArray(arrLongs[op + 3], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 157)).intoArray(arrLongs[op + 4], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 192)).intoArray(arrLongs[op + 5], 2 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n+                assertTrue(Arrays.equals(tLongs[i], gLongs[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void test_init() {\n+        int count = LARGE_LEN;\n+\n+        bytesA    = new byte[count];\n+        shortsA   = new short[count];\n+        integersA = new int[count];\n+        longsA    = new long[count];\n+\n+        bytesB    = new byte[count];\n+        shortsB   = new short[count];\n+        integersB = new int[count];\n+        longsB    = new long[count];\n+\n+        tBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tLongs    = new long[MAX_TESTS_PER_OP * NUM_OPS][count];\n+\n+        gBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gLongs    = new long[MAX_TESTS_PER_OP * NUM_OPS][count];\n+\n+        for (int i = 0; i < count; i++) {\n+            bytesA[i]    = (byte) r.nextInt();\n+            shortsA[i]   = (short) r.nextInt();\n+            integersA[i] = r.nextInt();\n+            longsA[i]    = r.nextLong();\n+\n+            bytesB[i]    = (byte) r.nextInt();\n+            shortsB[i]   = (short) r.nextInt();\n+            integersB[i] = r.nextInt();\n+            longsB[i]    = r.nextLong();\n+        }\n+\n+        shift_bytes64(gBytes,        false);\n+        shift_bytes128(gBytes,       false);\n+        shift_shorts64(gShorts,      false);\n+        shift_shorts128(gShorts,     false);\n+        shift_integers64(gIntegers,  false);\n+        shift_integers128(gIntegers, false);\n+        shift_longs128(gLongs,       false);\n+    }\n+\n+    static void assertTrue(boolean okay, int i, int vlen) {\n+        if (!okay) {\n+            throw new RuntimeException(\"Test Failed, verify index \" + i + \", operation \" + opNames[i \/ MAX_TESTS_PER_OP \/ (vlen \/ 64)] + \", vector length \"+ vlen);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShiftImmAndAccumulate.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"}]}