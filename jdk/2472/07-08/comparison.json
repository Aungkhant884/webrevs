{"files":[{"patch":"@@ -37,1 +37,2 @@\n- * @run main\/othervm compiler.vectorapi.TestVectorShiftImm\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:CompileThreshold=1000 compiler.vectorapi.TestVectorShiftImm 128\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:CompileThreshold=1000 compiler.vectorapi.TestVectorShiftImm 64\n@@ -41,2 +42,2 @@\n-    private static final int LARGE_LEN = 128;\n-    private static final int NUM_ITERS = 200000;\n+    private static final int LARGE_LEN = 256;\n+    private static final int NUM_ITERS = 20000;\n@@ -44,1 +45,2 @@\n-    private static final int NUM_OPS          = 3;\n+    private static final int NUM_OPS          = 5;\n+    private static final int ACCUMULATE_OP_S  = 3;\n@@ -46,0 +48,1 @@\n+    private static final int VLENS            = 2;\n@@ -70,1 +73,4 @@\n-    static String[] opNames = {\"LSHL\", \"ASHR\", \"LSHR\"};\n+    static String[] opNames = {\"LSHL\", \"ASHR\", \"LSHR\", \"ASHR_AND_ACCUMULATE\", \"LSHR_AND_ACCUMULATE\"};\n+\n+    static boolean allTestsPassed = true;\n+    static StringBuilder errMsg = new StringBuilder();\n@@ -73,0 +79,7 @@\n+\n+        if (args.length < 1) {\n+            throw new RuntimeException(\"Please pass which vector length to test : 64 \/ 128.\");\n+        }\n+\n+        int vlen = Integer.parseInt(args[0]);\n+\n@@ -75,0 +88,18 @@\n+        if (vlen == 64) {\n+            test_shift_and_accumulate_vlen64();\n+            test_shift_immediate_vlen64();\n+        }\n+\n+        if (vlen == 128) {\n+            test_shift_and_accumulate_vlen128();\n+            test_shift_immediate_vlen128();\n+        }\n+\n+        if (allTestsPassed) {\n+            System.out.println(\"Test PASSED\");\n+        } else {\n+            throw new RuntimeException(\"Test Failed, failed tests:\\n\" + errMsg.toString());\n+        }\n+    }\n+\n+    static void test_shift_and_accumulate_vlen64() {\n@@ -76,4 +107,3 @@\n-            test_vector_api_bytes();\n-            test_vector_api_shorts();\n-            test_vector_api_integers();\n-            test_vector_api_longs();\n+            shift_and_accumulate_bytes64(tBytes,        true);\n+            shift_and_accumulate_shorts64(tShorts,      true);\n+            shift_and_accumulate_integers64(tIntegers,  true);\n@@ -81,0 +111,1 @@\n+    }\n@@ -82,1 +113,7 @@\n-        System.out.println(\"Test PASSED\");\n+    static void test_shift_and_accumulate_vlen128() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_and_accumulate_bytes128(tBytes,        true);\n+            shift_and_accumulate_shorts128(tShorts,      true);\n+            shift_and_accumulate_integers128(tIntegers,  true);\n+            shift_and_accumulate_longs128(tLongs,        true);\n+        }\n@@ -85,2 +122,6 @@\n-    static void test_vector_api_bytes() {\n-         shift_bytes(tBytes, true);\n+    static void test_shift_immediate_vlen64() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_bytes64(tBytes,        true);\n+            shift_shorts64(tShorts,      true);\n+            shift_integers64(tIntegers,  true);\n+        }\n@@ -89,1 +130,12 @@\n-    static void shift_bytes(byte arrBytes[][], boolean verify) {\n+    static void test_shift_immediate_vlen128() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_bytes128(tBytes,        true);\n+            shift_shorts128(tShorts,      true);\n+            shift_integers128(tIntegers,  true);\n+            shift_longs128(tLongs,        true);\n+        }\n+    }\n+\n+    static void shift_bytes64(byte arrBytes[][], boolean verify) {\n+        int start = 0, end = 0;\n+\n@@ -91,26 +143,25 @@\n-            int op = 0;\n-            ByteVector vba = ByteVector.fromArray(byte64SPECIES, bytesA, 8 * i);\n-            ByteVector vbb = ByteVector.fromArray(byte64SPECIES, bytesB, 8 * i);\n-\n-            vbb.lanewise(VectorOperators.LSHL, 1).intoArray(arrBytes[op], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 8).intoArray(arrBytes[op  + 1], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 13).intoArray(arrBytes[op + 2], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrBytes[op + 3], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 19).intoArray(arrBytes[op + 4], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 24).intoArray(arrBytes[op + 5], 8 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.ASHR, 1).intoArray(arrBytes[op], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 8).intoArray(arrBytes[op  + 1], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 13).intoArray(arrBytes[op + 2], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrBytes[op + 3], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 19).intoArray(arrBytes[op + 4], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 24).intoArray(arrBytes[op + 5], 8 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.LSHR, 1).intoArray(arrBytes[op], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 8).intoArray(arrBytes[op  + 1], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 13).intoArray(arrBytes[op + 2], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrBytes[op + 3], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 19).intoArray(arrBytes[op + 4], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 24).intoArray(arrBytes[op + 5], 8 * i);\n+            end = start;\n+\n+            ByteVector vba64 = ByteVector.fromArray(byte64SPECIES, bytesA, 8 * i);\n+            ByteVector vbb64 = ByteVector.fromArray(byte64SPECIES, bytesB, 8 * i);\n+\n+            vbb64.lanewise(VectorOperators.LSHL, 1).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 8).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 13).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 16).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 19).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 24).intoArray(arrBytes[end++], 8 * i);\n+\n+            vbb64.lanewise(VectorOperators.ASHR, 1).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 8).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 13).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 16).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 19).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 24).intoArray(arrBytes[end++], 8 * i);\n+\n+            vbb64.lanewise(VectorOperators.LSHR, 1).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 8).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 13).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 16).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 19).intoArray(arrBytes[end++], 8 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 24).intoArray(arrBytes[end++], 8 * i);\n@@ -120,2 +171,2 @@\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tBytes[i], gBytes[i]), i);\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, 64);\n@@ -124,0 +175,73 @@\n+    }\n+\n+    static void shift_and_accumulate_bytes64(byte arrBytes[][], boolean verify) {\n+        int start = ACCUMULATE_OP_S * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN \/ 8; i++) {\n+            end = start;\n+\n+            ByteVector vba64 = ByteVector.fromArray(byte64SPECIES, bytesA, 8 * i);\n+            ByteVector vbb64 = ByteVector.fromArray(byte64SPECIES, bytesB, 8 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[end++], 8 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[end++], 8 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[end++], 8 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_bytes128(byte arrBytes[][], boolean verify) {\n+        int start = NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN \/ 16; i++) {\n+            end = start;\n+\n+            ByteVector vba128 = ByteVector.fromArray(byte128SPECIES, bytesA, 16 * i);\n+            ByteVector vbb128 = ByteVector.fromArray(byte128SPECIES, bytesB, 16 * i);\n+\n+            vbb128.lanewise(VectorOperators.LSHL, 1).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 8).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 13).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 16).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 19).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 24).intoArray(arrBytes[end++], 16 * i);\n+\n+            vbb128.lanewise(VectorOperators.ASHR, 1).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 8).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 13).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 16).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 19).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 24).intoArray(arrBytes[end++], 16 * i);\n+\n+            vbb128.lanewise(VectorOperators.LSHR, 1).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 8).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 13).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 16).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 19).intoArray(arrBytes[end++], 16 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 24).intoArray(arrBytes[end++], 16 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_bytes128(byte arrBytes[][], boolean verify) {\n+        int start = (NUM_OPS + ACCUMULATE_OP_S) * MAX_TESTS_PER_OP, end = 0;\n@@ -126,26 +250,18 @@\n-            int op = 0;\n-            ByteVector vba = ByteVector.fromArray(byte128SPECIES, bytesA, 16 * i);\n-            ByteVector vbb = ByteVector.fromArray(byte128SPECIES, bytesB, 16 * i);\n-\n-            vbb.lanewise(VectorOperators.LSHL, 1).intoArray(arrBytes[op], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 8).intoArray(arrBytes[op  + 1], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 13).intoArray(arrBytes[op + 2], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrBytes[op + 3], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 19).intoArray(arrBytes[op + 4], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 24).intoArray(arrBytes[op + 5], 16 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.ASHR, 1).intoArray(arrBytes[op], 16 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 8).intoArray(arrBytes[op  + 1], 16 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 13).intoArray(arrBytes[op + 2], 16 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrBytes[op + 3], 16 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 19).intoArray(arrBytes[op + 4], 16 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 24).intoArray(arrBytes[op + 5], 16 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.LSHR, 1).intoArray(arrBytes[op], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 8).intoArray(arrBytes[op  + 1], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 13).intoArray(arrBytes[op + 2], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrBytes[op + 3], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 19).intoArray(arrBytes[op + 4], 16 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 24).intoArray(arrBytes[op + 5], 16 * i);\n+            end = start;\n+\n+            ByteVector vba128 = ByteVector.fromArray(byte128SPECIES, bytesA, 16 * i);\n+            ByteVector vbb128 = ByteVector.fromArray(byte128SPECIES, bytesB, 16 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[end++], 16 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[end++], 16 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[end++], 16 * i);\n@@ -155,2 +271,2 @@\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tBytes[i], gBytes[i]), i);\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, 128);\n@@ -161,2 +277,36 @@\n-    static void test_vector_api_shorts() {\n-         shift_shorts(tShorts, true);\n+    static void shift_shorts64(short arrShorts[][], boolean verify) {\n+        int start = 0, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN \/ 4; i++) {\n+            end = start;\n+\n+            ShortVector vba64 = ShortVector.fromArray(short64SPECIES, shortsA, 4 * i);\n+            ShortVector vbb64 = ShortVector.fromArray(short64SPECIES, shortsB, 4 * i);\n+\n+            vbb64.lanewise(VectorOperators.LSHL, 1).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 8).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 13).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 16).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 19).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 24).intoArray(arrShorts[end++], 4 * i);\n+\n+            vbb64.lanewise(VectorOperators.ASHR, 1).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 8).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 13).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 16).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 19).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 24).intoArray(arrShorts[end++], 4 * i);\n+\n+            vbb64.lanewise(VectorOperators.LSHR, 1).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 8).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 13).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 16).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 19).intoArray(arrShorts[end++], 4 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 24).intoArray(arrShorts[end++], 4 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, 64);\n+            }\n+        }\n@@ -165,1 +315,3 @@\n-    static void shift_shorts(short arrShorts[][], boolean verify) {\n+    static void shift_and_accumulate_shorts64(short arrShorts[][], boolean verify) {\n+        int start = ACCUMULATE_OP_S * MAX_TESTS_PER_OP, end = 0;\n+\n@@ -167,26 +319,18 @@\n-            int op = 0;\n-            ShortVector vba = ShortVector.fromArray(short64SPECIES, shortsA, 4 * i);\n-            ShortVector vbb = ShortVector.fromArray(short64SPECIES, shortsB, 4 * i);\n-\n-            vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrShorts[op], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrShorts[op + 1], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrShorts[op + 2], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrShorts[op + 3], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 35).intoArray(arrShorts[op + 4], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrShorts[op + 5], 4 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrShorts[op], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrShorts[op + 1], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrShorts[op + 2], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrShorts[op + 3], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 35).intoArray(arrShorts[op + 4], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrShorts[op + 5], 4 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrShorts[op], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrShorts[op + 1], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrShorts[op + 2], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrShorts[op + 3], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 35).intoArray(arrShorts[op + 4], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrShorts[op + 5], 4 * i);\n+            end = start;\n+\n+            ShortVector vba64 = ShortVector.fromArray(short64SPECIES, shortsA, 4 * i);\n+            ShortVector vbb64 = ShortVector.fromArray(short64SPECIES, shortsB, 4 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 1)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 8)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 13)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 19)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 24)).intoArray(arrShorts[end++], 4 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 1)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 8)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 13)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 19)).intoArray(arrShorts[end++], 4 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 24)).intoArray(arrShorts[end++], 4 * i);\n@@ -196,2 +340,2 @@\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tShorts[i], gShorts[i]), i);\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, 64);\n@@ -200,0 +344,4 @@\n+    }\n+\n+    static void shift_shorts128(short arrShorts[][], boolean verify) {\n+        int start = NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n@@ -202,26 +350,25 @@\n-            int op = 0;\n-            ShortVector vba = ShortVector.fromArray(short128SPECIES, shortsA, 8 * i);\n-            ShortVector vbb = ShortVector.fromArray(short128SPECIES, shortsB, 8 * i);\n-\n-            vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrShorts[op], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrShorts[op + 1], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrShorts[op + 2], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrShorts[op + 3], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 35).intoArray(arrShorts[op + 4], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrShorts[op + 5], 8 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrShorts[op], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrShorts[op + 1], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrShorts[op + 2], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrShorts[op + 3], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 35).intoArray(arrShorts[op + 4], 8 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrShorts[op + 5], 8 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrShorts[op], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrShorts[op + 1], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrShorts[op + 2], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrShorts[op + 3], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 35).intoArray(arrShorts[op + 4], 8 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrShorts[op + 5], 8 * i);\n+            end = start;\n+\n+            ShortVector vba128 = ShortVector.fromArray(short128SPECIES, shortsA, 8 * i);\n+            ShortVector vbb128 = ShortVector.fromArray(short128SPECIES, shortsB, 8 * i);\n+\n+            vbb128.lanewise(VectorOperators.LSHL, 1).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 8).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 13).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 16).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 19).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 24).intoArray(arrShorts[end++], 8 * i);\n+\n+            vbb128.lanewise(VectorOperators.ASHR, 1).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 8).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 13).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 16).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 19).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 24).intoArray(arrShorts[end++], 8 * i);\n+\n+            vbb128.lanewise(VectorOperators.LSHR, 1).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 8).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 13).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 16).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 19).intoArray(arrShorts[end++], 8 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 24).intoArray(arrShorts[end++], 8 * i);\n@@ -231,2 +378,2 @@\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tShorts[i], gShorts[i]), i);\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, 128);\n@@ -237,2 +384,29 @@\n-    static void test_vector_api_integers() {\n-         shift_integers(tIntegers, true);\n+    static void shift_and_accumulate_shorts128(short arrShorts[][], boolean verify) {\n+        int start = (NUM_OPS + ACCUMULATE_OP_S) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN \/ 8; i++) {\n+            end = start;\n+\n+            ShortVector vba128 = ShortVector.fromArray(short128SPECIES, shortsA, 8 * i);\n+            ShortVector vbb128 = ShortVector.fromArray(short128SPECIES, shortsB, 8 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 1)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 8)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 13)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 19)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 24)).intoArray(arrShorts[end++], 8 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 1)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 8)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 13)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 19)).intoArray(arrShorts[end++], 8 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 24)).intoArray(arrShorts[end++], 8 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, 128);\n+            }\n+        }\n@@ -241,1 +415,3 @@\n-    static void shift_integers(int arrIntegers[][], boolean verify) {\n+    static void shift_integers64(int arrInts[][], boolean verify) {\n+        int start = 0, end = 0;\n+\n@@ -243,26 +419,25 @@\n-            int op = 0;\n-            IntVector vba = IntVector.fromArray(integer64SPECIES, integersA, 2 * i);\n-            IntVector vbb = IntVector.fromArray(integer64SPECIES, integersB, 2 * i);\n-\n-            vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrIntegers[op], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrIntegers[op + 1], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrIntegers[op + 2], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrIntegers[op + 3], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 35).intoArray(arrIntegers[op + 4], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrIntegers[op + 5], 2 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrIntegers[op], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrIntegers[op + 1], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrIntegers[op + 2], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrIntegers[op + 3], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 35).intoArray(arrIntegers[op + 4], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrIntegers[op + 5], 2 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrIntegers[op], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrIntegers[op + 1], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrIntegers[op + 2], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrIntegers[op + 3], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 35).intoArray(arrIntegers[op + 4], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrIntegers[op + 5], 2 * i);\n+            end = start;\n+\n+            IntVector vba64 = IntVector.fromArray(integer64SPECIES, integersA, 2 * i);\n+            IntVector vbb64 = IntVector.fromArray(integer64SPECIES, integersB, 2 * i);\n+\n+            vbb64.lanewise(VectorOperators.LSHL, 9).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 32).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 47).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 64).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 73).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHL, 96).intoArray(arrInts[end++], 2 * i);\n+\n+            vbb64.lanewise(VectorOperators.ASHR, 9).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 32).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 47).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 64).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 73).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.ASHR, 96).intoArray(arrInts[end++], 2 * i);\n+\n+            vbb64.lanewise(VectorOperators.LSHR, 9).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 32).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 47).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 64).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 73).intoArray(arrInts[end++], 2 * i);\n+            vbb64.lanewise(VectorOperators.LSHR, 96).intoArray(arrInts[end++], 2 * i);\n@@ -272,2 +447,2 @@\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tIntegers[i], gIntegers[i]), i);\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, 64);\n@@ -276,0 +451,73 @@\n+    }\n+\n+    static void shift_and_accumulate_integers64(int arrInts[][], boolean verify) {\n+        int start = ACCUMULATE_OP_S * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN \/ 2; i++) {\n+            end = start;\n+\n+            IntVector vba64 = IntVector.fromArray(integer64SPECIES, integersA, 2 * i);\n+            IntVector vbb64 = IntVector.fromArray(integer64SPECIES, integersB, 2 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 9)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 32)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 47)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 64)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 73)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 96)).intoArray(arrInts[end++], 2 * i);\n+\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 9)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 32)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 47)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 64)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 73)).intoArray(arrInts[end++], 2 * i);\n+            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 96)).intoArray(arrInts[end++], 2 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, 64);\n+            }\n+        }\n+    }\n+\n+    static void shift_integers128(int arrInts[][], boolean verify) {\n+        int start = NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN \/ 4; i++) {\n+            end = start;\n+\n+            IntVector vba128 = IntVector.fromArray(integer128SPECIES, integersA, 4 * i);\n+            IntVector vbb128 = IntVector.fromArray(integer128SPECIES, integersB, 4 * i);\n+\n+            vbb128.lanewise(VectorOperators.LSHL, 9).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 32).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 47).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 64).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 73).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 96).intoArray(arrInts[end++], 4 * i);\n+\n+            vbb128.lanewise(VectorOperators.ASHR, 9).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 32).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 47).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 64).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 73).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 96).intoArray(arrInts[end++], 4 * i);\n+\n+            vbb128.lanewise(VectorOperators.LSHR, 9).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 32).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 47).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 64).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 73).intoArray(arrInts[end++], 4 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 96).intoArray(arrInts[end++], 4 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, 128);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate_integers128(int arrInts[][], boolean verify) {\n+        int start = (NUM_OPS + ACCUMULATE_OP_S) * MAX_TESTS_PER_OP, end = 0;\n@@ -278,26 +526,18 @@\n-            int op = 0;\n-            IntVector vba = IntVector.fromArray(integer128SPECIES, integersA, 4 * i);\n-            IntVector vbb = IntVector.fromArray(integer128SPECIES, integersB, 4 * i);\n-\n-            vbb.lanewise(VectorOperators.LSHL, 9).intoArray(arrIntegers[op], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 16).intoArray(arrIntegers[op + 1], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 27).intoArray(arrIntegers[op + 2], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 32).intoArray(arrIntegers[op + 3], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 35).intoArray(arrIntegers[op + 4], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 48).intoArray(arrIntegers[op + 5], 4 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.ASHR, 9).intoArray(arrIntegers[op], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 16).intoArray(arrIntegers[op + 1], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 27).intoArray(arrIntegers[op + 2], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 32).intoArray(arrIntegers[op + 3], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 35).intoArray(arrIntegers[op + 4], 4 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 48).intoArray(arrIntegers[op + 5], 4 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.LSHR, 9).intoArray(arrIntegers[op], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 16).intoArray(arrIntegers[op + 1], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 27).intoArray(arrIntegers[op + 2], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 32).intoArray(arrIntegers[op + 3], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 35).intoArray(arrIntegers[op + 4], 4 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 48).intoArray(arrIntegers[op + 5], 4 * i);\n+            end = start;\n+\n+            IntVector vba128 = IntVector.fromArray(integer128SPECIES, integersA, 4 * i);\n+            IntVector vbb128 = IntVector.fromArray(integer128SPECIES, integersB, 4 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 9)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 32)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 47)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 64)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 73)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 96)).intoArray(arrInts[end++], 4 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 9)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 32)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 47)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 64)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 73)).intoArray(arrInts[end++], 4 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 96)).intoArray(arrInts[end++], 4 * i);\n@@ -307,2 +547,2 @@\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tIntegers[i], gIntegers[i]), i);\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, 128);\n@@ -313,2 +553,36 @@\n-    static void test_vector_api_longs() {\n-         shift_longs(tLongs, true);\n+    static void shift_longs128(long arrLongs[][], boolean verify) {\n+        int start = NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < LARGE_LEN \/ 2; i++) {\n+            end = start;\n+\n+            LongVector vba128 = LongVector.fromArray(long128SPECIES, longsA, 2 * i);\n+            LongVector vbb128 = LongVector.fromArray(long128SPECIES, longsB, 2 * i);\n+\n+            vbb128.lanewise(VectorOperators.LSHL, 37).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 64).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 99).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 128).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 157).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHL, 192).intoArray(arrLongs[end++], 2 * i);\n+\n+            vbb128.lanewise(VectorOperators.ASHR, 37).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 64).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 99).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 128).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 157).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.ASHR, 192).intoArray(arrLongs[end++], 2 * i);\n+\n+            vbb128.lanewise(VectorOperators.LSHR, 37).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 64).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 99).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 128).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 157).intoArray(arrLongs[end++], 2 * i);\n+            vbb128.lanewise(VectorOperators.LSHR, 192).intoArray(arrLongs[end++], 2 * i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"LONG\", Arrays.equals(tLongs[i], gLongs[i]), i, 128);\n+            }\n+        }\n@@ -317,1 +591,3 @@\n-    static void shift_longs(long arrLongs[][], boolean verify) {\n+    static void shift_and_accumulate_longs128(long arrLongs[][], boolean verify) {\n+        int start = (NUM_OPS + ACCUMULATE_OP_S) * MAX_TESTS_PER_OP, end = 0;\n+\n@@ -319,26 +595,18 @@\n-            int op = 0;\n-            LongVector vba = LongVector.fromArray(long128SPECIES, longsA, 2 * i);\n-            LongVector vbb = LongVector.fromArray(long128SPECIES, longsB, 2 * i);\n-\n-            vbb.lanewise(VectorOperators.LSHL, 37).intoArray(arrLongs[op], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 64).intoArray(arrLongs[op  + 1], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 99).intoArray(arrLongs[op  + 2], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 128).intoArray(arrLongs[op + 3], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 157).intoArray(arrLongs[op + 4], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHL, 192).intoArray(arrLongs[op + 5], 2 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.ASHR, 37).intoArray(arrLongs[op], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 64).intoArray(arrLongs[op  + 1], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 99).intoArray(arrLongs[op  + 2], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 128).intoArray(arrLongs[op + 3], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 157).intoArray(arrLongs[op + 4], 2 * i);\n-            vbb.lanewise(VectorOperators.ASHR, 192).intoArray(arrLongs[op + 5], 2 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vbb.lanewise(VectorOperators.LSHR, 37).intoArray(arrLongs[op], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 64).intoArray(arrLongs[op  + 1], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 99).intoArray(arrLongs[op  + 2], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 128).intoArray(arrLongs[op + 3], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 157).intoArray(arrLongs[op + 4], 2 * i);\n-            vbb.lanewise(VectorOperators.LSHR, 192).intoArray(arrLongs[op + 5], 2 * i);\n+            end = start;\n+\n+            LongVector vba128 = LongVector.fromArray(long128SPECIES, longsA, 2 * i);\n+            LongVector vbb128 = LongVector.fromArray(long128SPECIES, longsB, 2 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 37)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 64)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 99)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 128)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 157)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 192)).intoArray(arrLongs[end++], 2 * i);\n+\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 37)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 64)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 99)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 128)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 157)).intoArray(arrLongs[end++], 2 * i);\n+            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 192)).intoArray(arrLongs[end++], 2 * i);\n@@ -348,2 +616,2 @@\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tLongs[i], gLongs[i]), i);\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"LONG\", Arrays.equals(tLongs[i], gLongs[i]), i, 128);\n@@ -354,0 +622,1 @@\n+\n@@ -367,4 +636,4 @@\n-        tBytes    = new byte[MAX_TESTS_PER_OP * NUM_OPS][count];\n-        tShorts   = new short[MAX_TESTS_PER_OP * NUM_OPS][count];\n-        tIntegers = new int[MAX_TESTS_PER_OP * NUM_OPS][count];\n-        tLongs    = new long[MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tLongs    = new long[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n@@ -372,4 +641,4 @@\n-        gBytes    = new byte[MAX_TESTS_PER_OP * NUM_OPS][count];\n-        gShorts   = new short[MAX_TESTS_PER_OP * NUM_OPS][count];\n-        gIntegers = new int[MAX_TESTS_PER_OP * NUM_OPS][count];\n-        gLongs    = new long[MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gLongs    = new long[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n@@ -389,4 +658,15 @@\n-        shift_bytes(gBytes,   false);\n-        shift_shorts(gShorts, false);\n-        shift_integers(gIntegers, false);\n-        shift_longs(gLongs, false);\n+        shift_bytes64(gBytes,        false);\n+        shift_bytes128(gBytes,       false);\n+        shift_shorts64(gShorts,      false);\n+        shift_shorts128(gShorts,     false);\n+        shift_integers64(gIntegers,  false);\n+        shift_integers128(gIntegers, false);\n+        shift_longs128(gLongs,       false);\n+\n+        shift_and_accumulate_bytes64(gBytes,        false);\n+        shift_and_accumulate_bytes128(gBytes,       false);\n+        shift_and_accumulate_shorts64(gShorts,      false);\n+        shift_and_accumulate_shorts128(gShorts,     false);\n+        shift_and_accumulate_integers64(gIntegers,  false);\n+        shift_and_accumulate_integers128(gIntegers, false);\n+        shift_and_accumulate_longs128(gLongs,       false);\n@@ -395,1 +675,2 @@\n-    static void assertTrue(boolean okay, int i) {\n+    static void assertTrue(String type, boolean okay, int i, int vlen) {\n+        int op = i % (MAX_TESTS_PER_OP * NUM_OPS) \/ MAX_TESTS_PER_OP;\n@@ -397,1 +678,4 @@\n-            throw new RuntimeException(\"Test Failed, verify index \" + i + \", shift operation \" + opNames[i \/ MAX_TESTS_PER_OP]);\n+            allTestsPassed = false;\n+            if (!errMsg.toString().contains(\"type \" + type + \" index \" + i)) {\n+                errMsg.append(\"type \" + type + \" index \" + i + \", operation \" + opNames[op] + \", vector length \"+ vlen + \".\\n\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShiftImm.java","additions":516,"deletions":232,"binary":false,"changes":748,"status":"modified"},{"patch":"@@ -1,351 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.vectorapi;\n-\n-import java.util.Random;\n-import java.util.Arrays;\n-\n-import jdk.incubator.vector.*;\n-\n-\/**\n- * @test\n- * @bug 8261142\n- * @summary AArch64: Incorrect instruction encoding when right-shifting vectors with shift amount equals to the element width\n- * @modules jdk.incubator.vector\n- *\n- * @run main\/othervm compiler.vectorapi.TestVectorShiftImmAndAccumulate\n- *\/\n-\n-public class TestVectorShiftImmAndAccumulate {\n-    private static final int LARGE_LEN = 128;\n-    private static final int NUM_ITERS = 200000;\n-\n-    private static final int NUM_OPS          = 2;\n-    private static final int MAX_TESTS_PER_OP = 6;\n-    private static final int VLENS            = 2;\n-\n-    private static byte[]  bytesA,    bytesB;\n-    private static short[] shortsA,   shortsB;\n-    private static int[]   integersA, integersB;\n-    private static long[]  longsA,    longsB;\n-\n-    private static byte  tBytes[][],    gBytes[][];\n-    private static short tShorts[][],   gShorts[][];\n-    private static int   tIntegers[][], gIntegers[][];\n-    private static long  tLongs[][],    gLongs[][];\n-\n-    private static Random r = new Random(32781);\n-\n-    static final VectorSpecies<Byte> byte64SPECIES  = ByteVector.SPECIES_64;\n-    static final VectorSpecies<Byte> byte128SPECIES = ByteVector.SPECIES_128;\n-\n-    static final VectorSpecies<Short> short64SPECIES  = ShortVector.SPECIES_64;\n-    static final VectorSpecies<Short> short128SPECIES = ShortVector.SPECIES_128;\n-\n-    static final VectorSpecies<Integer> integer64SPECIES  = IntVector.SPECIES_64;\n-    static final VectorSpecies<Integer> integer128SPECIES = IntVector.SPECIES_128;\n-\n-    static final VectorSpecies<Long> long128SPECIES = LongVector.SPECIES_128;\n-\n-    static String[] opNames = {\"ASHR_AND_ACCUMULATE\", \"LSHR_AND_ACCUMULATE\"};\n-\n-    public static void main(String args[]) {\n-        test_init();\n-\n-        test_shift_and_accumulte_vlen64();\n-        test_shift_and_accumulte_vlen128();\n-\n-        System.out.println(\"Test PASSED\");\n-    }\n-\n-    static void test_shift_and_accumulte_vlen64() {\n-        for (int i = 0; i < NUM_ITERS; i++) {\n-            shift_bytes64(tBytes,        true);\n-            shift_shorts64(tShorts,      true);\n-            shift_integers64(tIntegers,  true);\n-        }\n-    }\n-\n-    static void test_shift_and_accumulte_vlen128() {\n-        for (int i = 0; i < NUM_ITERS; i++) {\n-            shift_bytes128(tBytes,        true);\n-            shift_shorts128(tShorts,      true);\n-            shift_integers128(tIntegers,  true);\n-            shift_longs128(tLongs,        true);\n-        }\n-    }\n-\n-    static void shift_bytes64(byte arrBytes[][], boolean verify) {\n-        for (int i = 0; i < LARGE_LEN \/ 8; i++) {\n-            int op = 0;\n-            ByteVector vba64 = ByteVector.fromArray(byte64SPECIES, bytesA, 8 * i);\n-            ByteVector vbb64 = ByteVector.fromArray(byte64SPECIES, bytesB, 8 * i);\n-\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[op], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[op  + 1], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[op + 2], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[op + 3], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[op + 4], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[op + 5], 8 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[op], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[op  + 1], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[op + 2], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[op + 3], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[op + 4], 8 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[op + 5], 8 * i);\n-        }\n-\n-        if (verify) {\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tBytes[i], gBytes[i]), i, 64);\n-            }\n-        }\n-    }\n-\n-    static void shift_bytes128(byte arrBytes[][], boolean verify) {\n-        for (int i = 0; i < LARGE_LEN \/ 16; i++) {\n-            int op = NUM_OPS * MAX_TESTS_PER_OP;\n-            ByteVector vba128 = ByteVector.fromArray(byte128SPECIES, bytesA, 16 * i);\n-            ByteVector vbb128 = ByteVector.fromArray(byte128SPECIES, bytesB, 16 * i);\n-\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 1)).intoArray(arrBytes[op], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 8)).intoArray(arrBytes[op  + 1], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 13)).intoArray(arrBytes[op + 2], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 16)).intoArray(arrBytes[op + 3], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 19)).intoArray(arrBytes[op + 4], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 24)).intoArray(arrBytes[op + 5], 16 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 1)).intoArray(arrBytes[op], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 8)).intoArray(arrBytes[op  + 1], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 13)).intoArray(arrBytes[op + 2], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 16)).intoArray(arrBytes[op + 3], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 19)).intoArray(arrBytes[op + 4], 16 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 24)).intoArray(arrBytes[op + 5], 16 * i);\n-        }\n-\n-        if (verify) {\n-            for (int i = NUM_OPS * MAX_TESTS_PER_OP; i < VLENS * NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tBytes[i], gBytes[i]), i, 128);\n-            }\n-        }\n-    }\n-\n-    static void shift_shorts64(short arrShorts[][], boolean verify) {\n-        for (int i = 0; i < LARGE_LEN \/ 4; i++) {\n-            int op = 0;\n-            ShortVector vba64 = ShortVector.fromArray(short64SPECIES, shortsA, 4 * i);\n-            ShortVector vbb64 = ShortVector.fromArray(short64SPECIES, shortsB, 4 * i);\n-\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[op], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[op + 1], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[op + 2], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[op + 3], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 35)).intoArray(arrShorts[op + 4], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[op + 5], 4 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[op], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[op + 1], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[op + 2], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[op + 3], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 35)).intoArray(arrShorts[op + 4], 4 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[op + 5], 4 * i);\n-        }\n-\n-        if (verify) {\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tShorts[i], gShorts[i]), i, 64);\n-            }\n-        }\n-    }\n-\n-    static void shift_shorts128(short arrShorts[][], boolean verify) {\n-        for (int i = 0; i < LARGE_LEN \/ 8; i++) {\n-            int op = NUM_OPS * MAX_TESTS_PER_OP;\n-            ShortVector vba128 = ShortVector.fromArray(short128SPECIES, shortsA, 8 * i);\n-            ShortVector vbb128 = ShortVector.fromArray(short128SPECIES, shortsB, 8 * i);\n-\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 9)).intoArray(arrShorts[op], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 16)).intoArray(arrShorts[op + 1], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 27)).intoArray(arrShorts[op + 2], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 32)).intoArray(arrShorts[op + 3], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 35)).intoArray(arrShorts[op + 4], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 48)).intoArray(arrShorts[op + 5], 8 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 9)).intoArray(arrShorts[op], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 16)).intoArray(arrShorts[op + 1], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 27)).intoArray(arrShorts[op + 2], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 32)).intoArray(arrShorts[op + 3], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 35)).intoArray(arrShorts[op + 4], 8 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 48)).intoArray(arrShorts[op + 5], 8 * i);\n-        }\n-\n-        if (verify) {\n-            for (int i = NUM_OPS * MAX_TESTS_PER_OP; i < VLENS * NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tShorts[i], gShorts[i]), i, 128);\n-            }\n-        }\n-    }\n-\n-    static void shift_integers64(int arrIntegers[][], boolean verify) {\n-        for (int i = 0; i < LARGE_LEN \/ 2; i++) {\n-            int op = 0;\n-            IntVector vba64 = IntVector.fromArray(integer64SPECIES, integersA, 2 * i);\n-            IntVector vbb64 = IntVector.fromArray(integer64SPECIES, integersB, 2 * i);\n-\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 9)).intoArray(arrIntegers[op], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 16)).intoArray(arrIntegers[op + 1], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 27)).intoArray(arrIntegers[op + 2], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[op + 3], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 35)).intoArray(arrIntegers[op + 4], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.ASHR, 48)).intoArray(arrIntegers[op + 5], 2 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 9)).intoArray(arrIntegers[op], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 16)).intoArray(arrIntegers[op + 1], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 27)).intoArray(arrIntegers[op + 2], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[op + 3], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 35)).intoArray(arrIntegers[op + 4], 2 * i);\n-            vba64.add(vbb64.lanewise(VectorOperators.LSHR, 48)).intoArray(arrIntegers[op + 5], 2 * i);\n-        }\n-\n-        if (verify) {\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tIntegers[i], gIntegers[i]), i, 64);\n-            }\n-        }\n-    }\n-\n-    static void shift_integers128(int arrIntegers[][], boolean verify) {\n-        for (int i = 0; i < LARGE_LEN \/ 4; i++) {\n-            int op = NUM_OPS * MAX_TESTS_PER_OP;\n-            IntVector vba128 = IntVector.fromArray(integer128SPECIES, integersA, 4 * i);\n-            IntVector vbb128 = IntVector.fromArray(integer128SPECIES, integersB, 4 * i);\n-\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 9)).intoArray(arrIntegers[op], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 16)).intoArray(arrIntegers[op + 1], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 27)).intoArray(arrIntegers[op + 2], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 32)).intoArray(arrIntegers[op + 3], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 35)).intoArray(arrIntegers[op + 4], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 48)).intoArray(arrIntegers[op + 5], 4 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 9)).intoArray(arrIntegers[op], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 16)).intoArray(arrIntegers[op + 1], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 27)).intoArray(arrIntegers[op + 2], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 32)).intoArray(arrIntegers[op + 3], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 35)).intoArray(arrIntegers[op + 4], 4 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 48)).intoArray(arrIntegers[op + 5], 4 * i);\n-        }\n-\n-        if (verify) {\n-            for (int i = NUM_OPS * MAX_TESTS_PER_OP; i < VLENS * NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tIntegers[i], gIntegers[i]), i, 128);\n-            }\n-        }\n-    }\n-\n-    static void shift_longs128(long arrLongs[][], boolean verify) {\n-        for (int i = 0; i < LARGE_LEN \/ 2; i++) {\n-            int op = 0;\n-            LongVector vba128 = LongVector.fromArray(long128SPECIES, longsA, 2 * i);\n-            LongVector vbb128 = LongVector.fromArray(long128SPECIES, longsB, 2 * i);\n-\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 37)).intoArray(arrLongs[op], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 64)).intoArray(arrLongs[op  + 1], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 99)).intoArray(arrLongs[op  + 2], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 128)).intoArray(arrLongs[op + 3], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 157)).intoArray(arrLongs[op + 4], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.ASHR, 192)).intoArray(arrLongs[op + 5], 2 * i);\n-            op += MAX_TESTS_PER_OP;\n-\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 37)).intoArray(arrLongs[op], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 64)).intoArray(arrLongs[op  + 1], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 99)).intoArray(arrLongs[op  + 2], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 128)).intoArray(arrLongs[op + 3], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 157)).intoArray(arrLongs[op + 4], 2 * i);\n-            vba128.add(vbb128.lanewise(VectorOperators.LSHR, 192)).intoArray(arrLongs[op + 5], 2 * i);\n-        }\n-\n-        if (verify) {\n-            for (int i = 0; i < NUM_OPS * MAX_TESTS_PER_OP; i++) {\n-                assertTrue(Arrays.equals(tLongs[i], gLongs[i]), i, 128);\n-            }\n-        }\n-    }\n-\n-    static void test_init() {\n-        int count = LARGE_LEN;\n-\n-        bytesA    = new byte[count];\n-        shortsA   = new short[count];\n-        integersA = new int[count];\n-        longsA    = new long[count];\n-\n-        bytesB    = new byte[count];\n-        shortsB   = new short[count];\n-        integersB = new int[count];\n-        longsB    = new long[count];\n-\n-        tBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n-        tShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n-        tIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n-        tLongs    = new long[MAX_TESTS_PER_OP * NUM_OPS][count];\n-\n-        gBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n-        gShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n-        gIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n-        gLongs    = new long[MAX_TESTS_PER_OP * NUM_OPS][count];\n-\n-        for (int i = 0; i < count; i++) {\n-            bytesA[i]    = (byte) r.nextInt();\n-            shortsA[i]   = (short) r.nextInt();\n-            integersA[i] = r.nextInt();\n-            longsA[i]    = r.nextLong();\n-\n-            bytesB[i]    = (byte) r.nextInt();\n-            shortsB[i]   = (short) r.nextInt();\n-            integersB[i] = r.nextInt();\n-            longsB[i]    = r.nextLong();\n-        }\n-\n-        shift_bytes64(gBytes,        false);\n-        shift_bytes128(gBytes,       false);\n-        shift_shorts64(gShorts,      false);\n-        shift_shorts128(gShorts,     false);\n-        shift_integers64(gIntegers,  false);\n-        shift_integers128(gIntegers, false);\n-        shift_longs128(gLongs,       false);\n-    }\n-\n-    static void assertTrue(boolean okay, int i, int vlen) {\n-        if (!okay) {\n-            throw new RuntimeException(\"Test Failed, verify index \" + i + \", operation \" + opNames[i \/ MAX_TESTS_PER_OP \/ (vlen \/ 64)] + \", vector length \"+ vlen);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShiftImmAndAccumulate.java","additions":0,"deletions":351,"binary":false,"changes":351,"status":"deleted"}]}