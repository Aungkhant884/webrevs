{"files":[{"patch":"@@ -2688,0 +2688,1 @@\n+    assert(!isSHR || (isSHR && (shift != 0)), \"Zero right shift\");      \\\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -530,0 +530,27 @@\n+  \/\/ AdvSIMD shift by immediate.\n+  \/\/ These are \"user friendly\" variants which allow a shift count of 0.\n+#define WRAP(INSN)                                                                \\\n+  void INSN(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift) {  \\\n+    if (shift == 0) {                                                             \\\n+      SIMD_Arrangement arrange = (T & 1) == 0 ? T8B : T16B;                       \\\n+      Assembler::orr(Vd, arrange, Vn, Vn);                                        \\\n+    } else {                                                                      \\\n+      Assembler::INSN(Vd, T, Vn, shift);                                          \\\n+    }                                                                             \\\n+  }                                                                               \\\n+\n+  WRAP(shl) WRAP(sshr) WRAP(ushr)\n+#undef WRAP\n+\n+#define WRAP(INSN)                                                                \\\n+  void INSN(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift) {  \\\n+    if (shift == 0) {                                                             \\\n+      Assembler::addv(Vd, T, Vd, Vn);                                             \\\n+    } else {                                                                      \\\n+      Assembler::INSN(Vd, T, Vn, shift);                                          \\\n+    }                                                                             \\\n+  }                                                                               \\\n+\n+  WRAP(usra) WRAP(ssra)\n+#undef WRAP\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,450 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+import jdk.incubator.vector.*;\n+\n+\/**\n+ * @test\n+ * @bug 8261142\n+ * @summary AArch64: Incorrect instruction encoding when right-shifting vectors with shift amount equals to the element width\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run main\/othervm -XX:CompileCommand=print,compiler\/vectorapi\/TestVectorShiftImm.shift*\n+ *                   -XX:-TieredCompilation -Dvlen=64 compiler.vectorapi.TestVectorShiftImm\n+ * @run main\/othervm -XX:CompileCommand=print,compiler\/vectorapi\/TestVectorShiftImm.shift*\n+ *                   -XX:-TieredCompilation -Dvlen=128 compiler.vectorapi.TestVectorShiftImm\n+ *\/\n+\n+public class TestVectorShiftImm {\n+    private static final int ARR_LEN = 16;\n+    private static final int NUM_ITERS = 100000;\n+\n+    private static final int NUM_OPS          = 5;\n+    private static final int ACCUMULATE_OP_S  = 3;\n+    private static final int MAX_TESTS_PER_OP = 6;\n+    private static final int VLENS            = 2;\n+\n+    private static byte[]  bytesA,    bytesB;\n+    private static short[] shortsA,   shortsB;\n+    private static int[]   integersA, integersB;\n+    private static long[]  longsA,    longsB;\n+\n+    private static byte  tBytes[][],    gBytes[][];\n+    private static short tShorts[][],   gShorts[][];\n+    private static int   tIntegers[][], gIntegers[][];\n+    private static long  tLongs[][],    gLongs[][];\n+\n+    private static Random r = new Random(32781);\n+\n+    static final VectorSpecies<Byte> byte64SPECIES  = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> byte128SPECIES = ByteVector.SPECIES_128;\n+\n+    static final VectorSpecies<Short> short64SPECIES  = ShortVector.SPECIES_64;\n+    static final VectorSpecies<Short> short128SPECIES = ShortVector.SPECIES_128;\n+\n+    static final VectorSpecies<Integer> integer64SPECIES  = IntVector.SPECIES_64;\n+    static final VectorSpecies<Integer> integer128SPECIES = IntVector.SPECIES_128;\n+\n+    static final VectorSpecies<Long> long128SPECIES = LongVector.SPECIES_128;\n+\n+    static String[] opNames = {\"LSHL\", \"ASHR\", \"LSHR\", \"ASHR_AND_ACCUMULATE\", \"LSHR_AND_ACCUMULATE\"};\n+\n+    static boolean allTestsPassed = true;\n+    static StringBuilder errMsg = new StringBuilder();\n+\n+    public static void main(String args[]) {\n+\n+        int vlen = Integer.parseInt(System.getProperty(\"vlen\", \"\"));\n+\n+        test_init();\n+\n+        if (vlen == 64) {\n+            test_vlen64();\n+        }\n+\n+        if(vlen == 128) {\n+            test_vlen128();\n+        }\n+\n+        if (allTestsPassed) {\n+            System.out.println(\"Test PASSED\");\n+        } else {\n+            throw new RuntimeException(\"Test Failed, failed tests:\\n\" + errMsg.toString());\n+        }\n+    }\n+\n+    static void test_vlen64() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_and_accumulate(tBytes, true, byte64SPECIES, 64);\n+            shift_and_accumulate(tShorts, true, short64SPECIES, 64);\n+            shift_and_accumulate(tIntegers, true, integer64SPECIES, 64);\n+\n+            shift(tBytes, true, byte64SPECIES, 64);\n+            shift(tShorts, true, short64SPECIES, 64);\n+            shift(tIntegers, true, integer64SPECIES, 64);\n+        }\n+    }\n+\n+    static void test_vlen128() {\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            shift_and_accumulate(tBytes, true, byte128SPECIES, 128);\n+            shift_and_accumulate(tShorts, true, short128SPECIES, 128);\n+            shift_and_accumulate(tIntegers, true, integer128SPECIES, 128);\n+            shift_and_accumulate(tLongs, true, long128SPECIES, 128);\n+\n+            shift(tBytes, true, byte128SPECIES, 128);\n+            shift(tShorts, true, short128SPECIES, 128);\n+            shift(tIntegers, true, integer128SPECIES, 128);\n+            shift(tLongs, true, long128SPECIES, 128);\n+        }\n+    }\n+\n+    \/**\n+     * Tests for type byte.\n+     *\/\n+\n+    static int shift_with_op(VectorOperators.Binary op, ByteVector vbb,\n+                             byte arr[][], int end, int ind) {\n+        vbb.lanewise(op, 1).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 8).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 13).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 16).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 19).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 24).intoArray(arr[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_with_op_and_add(VectorOperators.Binary op,\n+                                     ByteVector vba, ByteVector vbb,\n+                                     byte arr[][], int end, int ind) {\n+        vba.add(vbb.lanewise(op, 1)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 8)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 13)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 16)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 19)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 24)).intoArray(arr[end++], ind);\n+        return end;\n+    }\n+\n+    static void shift(byte arrBytes[][], boolean verify,\n+                      VectorSpecies<Byte> vSpecies, int vlen) {\n+        int start = vlen \/ 128 * NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < ARR_LEN; i += vlen \/ 8) {\n+            end = start;\n+            ByteVector vbb = ByteVector.fromArray(vSpecies, bytesB, i);\n+            end = shift_with_op(VectorOperators.LSHL, vbb, arrBytes, end, i);\n+            end = shift_with_op(VectorOperators.ASHR, vbb, arrBytes, end, i);\n+            end = shift_with_op(VectorOperators.LSHR, vbb, arrBytes, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, vlen);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate(byte arrBytes[][], boolean verify,\n+                                           VectorSpecies<Byte> vSpecies, int vlen) {\n+        int start = (ACCUMULATE_OP_S + vlen \/ 128 * NUM_OPS) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < ARR_LEN; i += vlen \/ 8) {\n+            end = start;\n+            ByteVector vba = ByteVector.fromArray(vSpecies, bytesA, i);\n+            ByteVector vbb = ByteVector.fromArray(vSpecies, bytesB, i);\n+            end = shift_with_op_and_add(VectorOperators.ASHR, vba, vbb, arrBytes, end, i);\n+            end = shift_with_op_and_add(VectorOperators.LSHR, vba, vbb, arrBytes, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"BYTE\", Arrays.equals(tBytes[i], gBytes[i]), i, vlen);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests for type short.\n+     *\/\n+\n+    static int shift_with_op(VectorOperators.Binary op, ShortVector vbb,\n+                             short arr[][], int end, int ind) {\n+        vbb.lanewise(op, 9).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 16).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 27).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 32).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 43).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 48).intoArray(arr[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_with_op_and_add(VectorOperators.Binary op,\n+                                     ShortVector vba, ShortVector vbb,\n+                                     short arr[][], int end, int ind) {\n+        vba.add(vbb.lanewise(op, 9)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 16)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 27)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 32)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 43)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 48)).intoArray(arr[end++], ind);\n+        return end;\n+    }\n+\n+    static void shift(short arrShorts[][], boolean verify,\n+                      VectorSpecies<Short> vSpecies, int vlen) {\n+        int start = vlen \/ 128 * NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < ARR_LEN; i += vlen \/ 16) {\n+            end = start;\n+            ShortVector vbb = ShortVector.fromArray(vSpecies, shortsB, i);\n+            end = shift_with_op(VectorOperators.LSHL, vbb, arrShorts, end, i);\n+            end = shift_with_op(VectorOperators.ASHR, vbb, arrShorts, end, i);\n+            end = shift_with_op(VectorOperators.LSHR, vbb, arrShorts, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, vlen);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate(short arrShorts[][], boolean verify,\n+                                     VectorSpecies<Short> vSpecies, int vlen) {\n+        int start = (ACCUMULATE_OP_S + vlen \/ 128 * NUM_OPS) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < ARR_LEN; i += vlen \/ 16) {\n+            end = start;\n+            ShortVector vba = ShortVector.fromArray(vSpecies, shortsA, i);\n+            ShortVector vbb = ShortVector.fromArray(vSpecies, shortsB, i);\n+            end = shift_with_op_and_add(VectorOperators.ASHR, vba, vbb, arrShorts, end, i);\n+            end = shift_with_op_and_add(VectorOperators.LSHR, vba, vbb, arrShorts, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"SHORT\", Arrays.equals(tShorts[i], gShorts[i]), i, vlen);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests for type int.\n+     *\/\n+\n+    static int shift_with_op(VectorOperators.Binary op, IntVector vbb,\n+                             int arr[][], int end, int ind) {\n+        vbb.lanewise(op, 17).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 32).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 53).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 64).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 76).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 96).intoArray(arr[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_with_op_and_add(VectorOperators.Binary op,\n+                                     IntVector vba, IntVector vbb,\n+                                     int arr[][], int end, int ind) {\n+        vba.add(vbb.lanewise(op, 17)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 32)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 53)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 64)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 76)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 96)).intoArray(arr[end++], ind);\n+        return end;\n+    }\n+\n+    static void shift(int arrIntegers[][], boolean verify,\n+                      VectorSpecies<Integer> vSpecies, int vlen) {\n+        int start = vlen \/ 128 * NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < ARR_LEN; i += vlen \/ 32) {\n+            end = start;\n+            IntVector vbb = IntVector.fromArray(vSpecies, integersB, i);\n+            end = shift_with_op(VectorOperators.LSHL, vbb, arrIntegers, end, i);\n+            end = shift_with_op(VectorOperators.ASHR, vbb, arrIntegers, end, i);\n+            end = shift_with_op(VectorOperators.LSHR, vbb, arrIntegers, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, vlen);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate(int arrIntegers[][], boolean verify,\n+                                     VectorSpecies<Integer> vSpecies, int vlen) {\n+        int start = (ACCUMULATE_OP_S + vlen \/ 128 * NUM_OPS) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < ARR_LEN; i += vlen \/ 32) {\n+            end = start;\n+            IntVector vba = IntVector.fromArray(vSpecies, integersA, i);\n+            IntVector vbb = IntVector.fromArray(vSpecies, integersB, i);\n+            end = shift_with_op_and_add(VectorOperators.ASHR, vba, vbb, arrIntegers, end, i);\n+            end = shift_with_op_and_add(VectorOperators.LSHR, vba, vbb, arrIntegers, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"INTEGER\", Arrays.equals(tIntegers[i], gIntegers[i]), i, vlen);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests for type long.\n+     *\/\n+\n+    static int shift_with_op(VectorOperators.Binary op, LongVector vbb,\n+                             long arr[][], int end, int ind) {\n+        vbb.lanewise(op, 37).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 64).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 99).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 128).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 157).intoArray(arr[end++], ind);\n+        vbb.lanewise(op, 192).intoArray(arr[end++], ind);\n+        return end;\n+    }\n+\n+    static int shift_with_op_and_add(VectorOperators.Binary op,\n+                                     LongVector vba, LongVector vbb,\n+                                     long arr[][], int end, int ind) {\n+        vba.add(vbb.lanewise(op, 37)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 64)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 99)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 128)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 157)).intoArray(arr[end++], ind);\n+        vba.add(vbb.lanewise(op, 192)).intoArray(arr[end++], ind);\n+        return end;\n+    }\n+\n+    static void shift(long arrLongs[][], boolean verify,\n+                      VectorSpecies<Long> vSpecies, int vlen) {\n+        int start = vlen \/ 128 * NUM_OPS * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < ARR_LEN; i += vlen \/ 64) {\n+            end = start;\n+            LongVector vbb = LongVector.fromArray(vSpecies, longsB, i);\n+            end = shift_with_op(VectorOperators.LSHL, vbb, arrLongs, end, i);\n+            end = shift_with_op(VectorOperators.ASHR, vbb, arrLongs, end, i);\n+            end = shift_with_op(VectorOperators.LSHR, vbb, arrLongs, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"LONG\", Arrays.equals(tLongs[i], gLongs[i]), i, vlen);\n+            }\n+        }\n+    }\n+\n+    static void shift_and_accumulate(long arrLongs[][], boolean verify,\n+                                     VectorSpecies<Long> vSpecies, int vlen) {\n+        int start = (ACCUMULATE_OP_S + vlen \/ 128 * NUM_OPS) * MAX_TESTS_PER_OP, end = 0;\n+\n+        for (int i = 0; i < ARR_LEN; i += vlen \/ 64) {\n+            end = start;\n+            LongVector vba = LongVector.fromArray(vSpecies, longsA, i);\n+            LongVector vbb = LongVector.fromArray(vSpecies, longsB, i);\n+            end = shift_with_op_and_add(VectorOperators.ASHR, vba, vbb, arrLongs, end, i);\n+            end = shift_with_op_and_add(VectorOperators.LSHR, vba, vbb, arrLongs, end, i);\n+        }\n+\n+        if (verify) {\n+            for (int i = start; i < end; i++) {\n+                assertTrue(\"LONG\", Arrays.equals(tLongs[i], gLongs[i]), i, vlen);\n+            }\n+        }\n+    }\n+\n+    static void test_init() {\n+        int count = ARR_LEN;\n+\n+        bytesA    = new byte[count];\n+        shortsA   = new short[count];\n+        integersA = new int[count];\n+        longsA    = new long[count];\n+\n+        bytesB    = new byte[count];\n+        shortsB   = new short[count];\n+        integersB = new int[count];\n+        longsB    = new long[count];\n+\n+        tBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        tLongs    = new long[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+\n+        gBytes    = new byte[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gShorts   = new short[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gIntegers = new int[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+        gLongs    = new long[VLENS * MAX_TESTS_PER_OP * NUM_OPS][count];\n+\n+        for (int i = 0; i < count; i++) {\n+            bytesA[i]    = (byte) r.nextInt();\n+            shortsA[i]   = (short) r.nextInt();\n+            integersA[i] = r.nextInt();\n+            longsA[i]    = r.nextLong();\n+\n+            bytesB[i]    = (byte) r.nextInt();\n+            shortsB[i]   = (short) r.nextInt();\n+            integersB[i] = r.nextInt();\n+            longsB[i]    = r.nextLong();\n+        }\n+\n+        shift(gBytes, false, byte64SPECIES,  64);\n+        shift(gBytes, false, byte128SPECIES, 128);\n+        shift_and_accumulate(gBytes, false, byte64SPECIES,  64);\n+        shift_and_accumulate(gBytes, false, byte128SPECIES, 128);\n+\n+        shift(gShorts, false, short64SPECIES,  64);\n+        shift(gShorts, false, short128SPECIES, 128);\n+        shift_and_accumulate(gShorts, false, short64SPECIES,  64);\n+        shift_and_accumulate(gShorts, false, short128SPECIES, 128);\n+\n+        shift(gIntegers, false, integer64SPECIES,  64);\n+        shift(gIntegers, false, integer128SPECIES, 128);\n+        shift_and_accumulate(gIntegers, false, integer64SPECIES,  64);\n+        shift_and_accumulate(gIntegers, false, integer128SPECIES, 128);\n+\n+        shift(gLongs, false, long128SPECIES, 128);\n+        shift_and_accumulate(gLongs, false, long128SPECIES, 128);\n+    }\n+\n+    static void assertTrue(String type, boolean okay, int i, int vlen) {\n+        int op = i % (MAX_TESTS_PER_OP * NUM_OPS) \/ MAX_TESTS_PER_OP;\n+        if (!okay) {\n+            allTestsPassed = false;\n+            if (!errMsg.toString().contains(\"type \" + type + \" index \" + i)) {\n+                errMsg.append(\"type \" + type + \" index \" + i + \", operation \" + opNames[op] + \", vector length \"+ vlen + \".\\n\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShiftImm.java","additions":450,"deletions":0,"binary":false,"changes":450,"status":"added"}]}