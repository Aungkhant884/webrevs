{"files":[{"patch":"@@ -303,5 +303,5 @@\n-static const juint starttime_offset = sizeof(jlong);\n-static const juint duration_offset = starttime_offset + sizeof(jlong);\n-static const juint checkpoint_type_offset = duration_offset + sizeof(jlong);\n-static const juint types_offset = checkpoint_type_offset + sizeof(juint);\n-static const juint payload_offset = types_offset + sizeof(juint);\n+static const size_t starttime_offset = sizeof(int64_t);\n+static const size_t duration_offset = starttime_offset + sizeof(int64_t);\n+static const size_t checkpoint_type_offset = duration_offset + sizeof(int64_t);\n+static const size_t types_offset = checkpoint_type_offset + sizeof(uint32_t);\n+static const size_t payload_offset = types_offset + sizeof(uint32_t);\n@@ -314,2 +314,4 @@\n-static jlong total_size(const u1* data) {\n-  return read_data<jlong>(data);\n+static size_t total_size(const u1* data) {\n+  const int64_t size = read_data<int64_t>(data);\n+  assert(size > 0, \"invariant\");\n+  return static_cast<size_t>(size);\n@@ -318,2 +320,2 @@\n-static jlong starttime(const u1* data) {\n-  return read_data<jlong>(data + starttime_offset);\n+static int64_t starttime(const u1* data) {\n+  return read_data<int64_t>(data + starttime_offset);\n@@ -322,2 +324,2 @@\n-static jlong duration(const u1* data) {\n-  return read_data<jlong>(data + duration_offset);\n+static int64_t duration(const u1* data) {\n+  return read_data<int64_t>(data + duration_offset);\n@@ -326,2 +328,2 @@\n-static juint checkpoint_type(const u1* data) {\n-  return read_data<juint>(data + checkpoint_type_offset);\n+static int32_t checkpoint_type(const u1* data) {\n+  return read_data<int32_t>(data + checkpoint_type_offset);\n@@ -330,2 +332,2 @@\n-static juint number_of_types(const u1* data) {\n-  return read_data<juint>(data + types_offset);\n+static uint32_t number_of_types(const u1* data) {\n+  return read_data<uint32_t>(data + types_offset);\n@@ -334,8 +336,2 @@\n-static void write_checkpoint_header(JfrChunkWriter& cw, int64_t delta_to_last_checkpoint, const u1* data) {\n-  cw.reserve(sizeof(u4));\n-  cw.write<u8>(EVENT_CHECKPOINT);\n-  cw.write(starttime(data));\n-  cw.write(duration(data));\n-  cw.write(delta_to_last_checkpoint);\n-  cw.write(checkpoint_type(data));\n-  cw.write(number_of_types(data));\n+static size_t payload_size(const u1* data) {\n+  return total_size(data) - sizeof(JfrCheckpointEntry);\n@@ -344,14 +340,10 @@\n-static void write_checkpoint_content(JfrChunkWriter& cw, const u1* data, size_t size) {\n-  assert(data != NULL, \"invariant\");\n-  cw.write_unbuffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));\n-}\n-\n-static size_t write_thread_checkpoint_content(JfrChunkWriter& cw, const u1* data) {\n-  assert(data != NULL, \"invariant\");\n-  const size_t size = total_size(data);\n-  assert(size > sizeof(JfrCheckpointEntry), \"invariant\");\n-  assert(checkpoint_type(data) == THREADS, \"invariant\");\n-  assert(number_of_types(data) == 1, \"invariant\");\n-  \/\/ Thread checkpoints are small so write them buffered to cache as much as possible before flush.\n-  cw.write_buffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));\n-  return size;\n+static uint64_t calculate_event_size_bytes(JfrChunkWriter& cw, const u1* data, int64_t event_begin, int64_t delta_to_last_checkpoint) {\n+  assert(data != nullptr, \"invariant\");\n+  size_t bytes = cw.size_in_bytes(EVENT_CHECKPOINT);\n+  bytes += cw.size_in_bytes(starttime(data));\n+  bytes += cw.size_in_bytes(duration(data));\n+  bytes += cw.size_in_bytes(delta_to_last_checkpoint);\n+  bytes += cw.size_in_bytes(checkpoint_type(data));\n+  bytes += cw.size_in_bytes(number_of_types(data));\n+  bytes += payload_size(data); \/\/ in bytes already.\n+  return bytes + cw.size_in_bytes(bytes + cw.size_in_bytes(bytes));\n@@ -364,6 +356,0 @@\n-  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n-  const int64_t checkpoint_size = total_size(data);\n-  write_checkpoint_header(cw, delta_to_last_checkpoint, data);\n-  write_checkpoint_content(cw, data, checkpoint_size);\n-  const int64_t event_size = cw.current_offset() - event_begin;\n-  cw.write_padded_at_offset<u4>(event_size, event_begin);\n@@ -371,1 +357,12 @@\n-  return (size_t)checkpoint_size;\n+  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n+  const uint64_t event_size = calculate_event_size_bytes(cw, data, event_begin, delta_to_last_checkpoint);\n+  cw.write(event_size);\n+  cw.write(EVENT_CHECKPOINT);\n+  cw.write(starttime(data));\n+  cw.write(duration(data));\n+  cw.write(delta_to_last_checkpoint);\n+  cw.write(checkpoint_type(data));\n+  cw.write(number_of_types(data));\n+  cw.write_unbuffered(data + payload_offset, payload_size(data));\n+  assert(static_cast<uint64_t>(cw.current_offset() - event_begin) == event_size, \"invariant\");\n+  return total_size(data);\n@@ -390,0 +387,11 @@\n+static size_t write_thread_checkpoint_content(JfrChunkWriter& cw, const u1* data) {\n+  assert(data != NULL, \"invariant\");\n+  const size_t size = total_size(data);\n+  assert(size > 0, \"invariant\");\n+  assert(checkpoint_type(data) == THREADS, \"invariant\");\n+  assert(number_of_types(data) == 1, \"invariant\");\n+  \/\/ Thread checkpoints are small so write them buffered to cache as much as possible before flush.\n+  cw.write_buffered(data + payload_offset, payload_size(data));\n+  return size;\n+}\n+\n@@ -422,1 +430,0 @@\n-\n@@ -431,1 +438,1 @@\n-  u4 _elements;\n+  uint32_t _elements;\n@@ -437,2 +444,2 @@\n-    cw.reserve(sizeof(u4));\n-    cw.write<u8>(EVENT_CHECKPOINT);\n+    cw.reserve(sizeof(uint64_t));\n+    cw.write(EVENT_CHECKPOINT);\n@@ -446,1 +453,1 @@\n-    cw.reserve(sizeof(u4));\n+    cw.reserve(sizeof(uint32_t));\n@@ -456,2 +463,2 @@\n-    _cw.write_padded_at_offset<u4>(_elements, _elements_offset);\n-    _cw.write_padded_at_offset<u4>(event_size, _begin_offset);\n+    _cw.write_padded_at_offset(_elements, _elements_offset);\n+    _cw.write_padded_at_offset(event_size, _begin_offset);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":58,"deletions":51,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -132,0 +135,11 @@\n+template <typename T>\n+inline size_t BigEndianEncoderImpl::size_in_bytes(T value) {\n+  switch (sizeof(T)) {\n+    case 1: return 1;\n+    case 2: return 2;\n+    case 4: return 4;\n+    case 8:return 8;\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n@@ -163,0 +177,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -298,0 +315,30 @@\n+template <typename T>\n+inline size_t Varint128EncoderImpl::size_in_bytes(T value) {\n+  const u8 v = to_u8(value);\n+  if (LESS_THAN_128(v)) {\n+    return 1;\n+  }\n+  if (LESS_THAN_128(v >> 7)) {\n+    return 2;\n+  }\n+  if (LESS_THAN_128(v >> 14)) {\n+    return 3;\n+  }\n+  if (LESS_THAN_128(v >> 21)) {\n+    return 4;\n+  }\n+  if (LESS_THAN_128(v >> 28)) {\n+    return 5;\n+  }\n+  if (LESS_THAN_128(v >> 35)) {\n+    return 6;\n+  }\n+  if (LESS_THAN_128(v >> 42)) {\n+    return 7;\n+  }\n+  if (LESS_THAN_128(v >> 49)) {\n+    return 8;\n+  }\n+  return 9;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoders.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -72,0 +72,5 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value) {\n+    return IntegerEncoder::size_in_bytes(value);\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoding.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  template <typename T>\n+  size_t size_in_bytes(T value);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,0 +366,6 @@\n+template <typename BE, typename IE, typename WriterPolicyImpl>\n+template <typename T>\n+inline size_t WriterHost<BE, IE, WriterPolicyImpl>::size_in_bytes(T value) {\n+  return IE::size_in_bytes(value);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-            int size = input.readInt();\n+            long size = input.readLong();\n@@ -246,1 +246,1 @@\n-                            input.readInt(); \/\/ size\n+                            input.readLong(); \/\/ size\n@@ -313,1 +313,1 @@\n-            int size = input.readInt(); \/\/ size\n+            long size = input.readLong(); \/\/ size\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}