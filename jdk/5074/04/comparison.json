{"files":[{"patch":"@@ -1124,1 +1124,1 @@\n-                                        MetaspaceShared::max_closed_heap_region);\n+                                        MetaspaceShared::max_num_closed_heap_regions);\n@@ -1129,1 +1129,1 @@\n-                                        MetaspaceShared::max_open_heap_region);\n+                                        MetaspaceShared::max_num_open_heap_regions);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -265,2 +265,1 @@\n-    assert(HeapShared::is_heap_object_archiving_allowed(),\n-           \"Archiving heap object is not allowed\");\n+    assert(HeapShared::can_write(), \"sanity\");\n@@ -311,1 +310,1 @@\n-  if (CompressedOops::is_null(o) || !HeapShared::open_regions_mapped()) {\n+  if (CompressedOops::is_null(o) || !HeapShared::is_fully_available()) {\n@@ -314,4 +313,2 @@\n-    assert(HeapShared::is_heap_object_archiving_allowed(),\n-           \"Archived heap object is not allowed\");\n-    assert(HeapShared::open_regions_mapped(),\n-           \"Open archive heap region is not mapped\");\n+    assert(HeapShared::can_use(), \"sanity\");\n+    assert(HeapShared::is_fully_available(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-  if (HeapShared::is_heap_object_archiving_allowed()) {\n+  if (DumpSharedSpaces && HeapShared::can_write()) {\n@@ -1601,1 +1601,0 @@\n-  assert(MetaspaceShared::use_windows_memory_mapping(), \"used by windows only\");\n@@ -1615,0 +1614,5 @@\n+\n+  if (VerifySharedSpaces && !region_crc_check(base, si->used(), si->crc())) {\n+    return false;\n+  }\n+\n@@ -1807,19 +1811,15 @@\n-\/\/\n-\/\/ Map the closed and open archive heap objects to the runtime java heap.\n-\/\/\n-\/\/ The shared objects are mapped at (or close to ) the java heap top in\n-\/\/ closed archive regions. The mapped objects contain no out-going\n-\/\/ references to any other java heap regions. GC does not write into the\n-\/\/ mapped closed archive heap region.\n-\/\/\n-\/\/ The open archive heap objects are mapped below the shared objects in\n-\/\/ the runtime java heap. The mapped open archive heap data only contains\n-\/\/ references to the shared objects and open archive objects initially.\n-\/\/ During runtime execution, out-going references to any other java heap\n-\/\/ regions may be added. GC may mark and update references in the mapped\n-\/\/ open archive objects.\n-void FileMapInfo::map_heap_regions_impl() {\n-  if (!HeapShared::is_heap_object_archiving_allowed()) {\n-    log_info(cds)(\"CDS heap data is being ignored. UseG1GC, \"\n-                  \"UseCompressedOops and UseCompressedClassPointers are required.\");\n-    return;\n+void FileMapInfo::map_or_load_heap_regions() {\n+  bool success = false;\n+\n+  if (can_use_heap_regions()) {\n+    if (HeapShared::can_map()) {\n+      success = map_heap_regions();\n+    } else if (HeapShared::can_load()) {\n+      success = HeapShared::load_heap_regions(this);\n+    } else {\n+      log_info(cds)(\"Cannot use CDS heap data. UseG1GC or UseEpsilonGC are required.\");\n+    }\n+  }\n+\n+  if (!success) {\n+    MetaspaceShared::disable_full_module_graph();\n@@ -1827,0 +1827,1 @@\n+}\n@@ -1828,0 +1829,4 @@\n+bool FileMapInfo::can_use_heap_regions() {\n+  if (!has_heap_regions()) {\n+    return false;\n+  }\n@@ -1862,1 +1867,1 @@\n-    return;\n+    return false;\n@@ -1864,0 +1869,3 @@\n+  return true;\n+}\n+\n@@ -1865,0 +1873,15 @@\n+\/\/\n+\/\/ Map the closed and open archive heap objects to the runtime java heap.\n+\/\/\n+\/\/ The shared objects are mapped at (or close to ) the java heap top in\n+\/\/ closed archive regions. The mapped objects contain no out-going\n+\/\/ references to any other java heap regions. GC does not write into the\n+\/\/ mapped closed archive heap region.\n+\/\/\n+\/\/ The open archive heap objects are mapped below the shared objects in\n+\/\/ the runtime java heap. The mapped open archive heap data only contains\n+\/\/ references to the shared objects and open archive objects initially.\n+\/\/ During runtime execution, out-going references to any other java heap\n+\/\/ regions may be added. GC may mark and update references in the mapped\n+\/\/ open archive objects.\n+void FileMapInfo::map_heap_regions_impl() {\n@@ -1923,1 +1946,1 @@\n-                       MetaspaceShared::max_closed_heap_region,\n+                       MetaspaceShared::max_num_closed_heap_regions,\n@@ -1930,1 +1953,1 @@\n-                         MetaspaceShared::max_open_heap_region,\n+                         MetaspaceShared::max_num_open_heap_regions,\n@@ -1939,4 +1962,2 @@\n-void FileMapInfo::map_heap_regions() {\n-  if (has_heap_regions()) {\n-    map_heap_regions_impl();\n-  }\n+bool FileMapInfo::map_heap_regions() {\n+  map_heap_regions_impl();\n@@ -1951,1 +1972,3 @@\n-    MetaspaceShared::disable_full_module_graph();\n+    return false;\n+  } else {\n+    return true;\n@@ -2356,1 +2379,1 @@\n-    for (int i = 0; i < MetaspaceShared::num_non_heap_spaces; i++) {\n+    for (int i = 0; i < MetaspaceShared::num_non_heap_regions; i++) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":53,"deletions":30,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+public:\n@@ -147,1 +148,0 @@\n-public:\n@@ -424,0 +424,2 @@\n+  narrowOop heap_obj_roots()               const    { return header()->heap_obj_roots(); }\n+\n@@ -471,1 +473,1 @@\n-  void  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;\n+  void  map_or_load_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -478,0 +480,2 @@\n+  bool  read_region(int i, char* base, size_t size);\n+  char* map_bitmap_region();\n@@ -577,0 +581,3 @@\n+  bool  can_use_heap_regions();\n+  bool  load_heap_regions() NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  bool  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN_(false);\n@@ -578,1 +585,0 @@\n-  char* map_bitmap_region();\n@@ -580,1 +586,0 @@\n-  bool  read_region(int i, char* base, size_t size);\n@@ -590,0 +595,1 @@\n+public:\n@@ -595,0 +601,1 @@\n+private:\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -72,0 +73,1 @@\n+bool HeapShared::_is_loaded = false;\n@@ -76,0 +78,12 @@\n+uintptr_t HeapShared::_loaded_heap_bottom = 0;\n+uintptr_t HeapShared::_loaded_heap_top = 0;\n+uintptr_t HeapShared::_dumptime_base_0 = UINTPTR_MAX;\n+uintptr_t HeapShared::_dumptime_base_1 = UINTPTR_MAX;\n+uintptr_t HeapShared::_dumptime_base_2 = UINTPTR_MAX;\n+uintptr_t HeapShared::_dumptime_base_3 = UINTPTR_MAX;\n+uintptr_t HeapShared::_dumptime_top    = 0;\n+intx HeapShared::_runtime_offset_0 = 0;\n+intx HeapShared::_runtime_offset_1 = 0;\n+intx HeapShared::_runtime_offset_2 = 0;\n+intx HeapShared::_runtime_offset_3 = 0;\n+bool HeapShared::_loading_failed = false;\n@@ -121,1 +135,1 @@\n-  assert(HeapShared::is_heap_object_archiving_allowed(), \"must be\");\n+  assert(HeapShared::can_write(), \"must be\");\n@@ -132,3 +146,2 @@\n-void HeapShared::fixup_mapped_regions() {\n-  FileMapInfo *mapinfo = FileMapInfo::current_info();\n-  mapinfo->fixup_mapped_heap_regions();\n+void HeapShared::fixup_regions() {\n+  FileMapInfo* mapinfo = FileMapInfo::current_info();\n@@ -136,0 +149,5 @@\n+    mapinfo->fixup_mapped_heap_regions();\n+  } else if (_loading_failed) {\n+    fill_failed_loaded_region();\n+  }\n+  if (is_fully_available()) {\n@@ -208,1 +226,1 @@\n-    if (!is_heap_object_archiving_allowed()) {\n+    if (!HeapShared::can_write()) {\n@@ -222,1 +240,1 @@\n-  assert(open_regions_mapped(), \"must be\");\n+  assert(is_fully_available(), \"must be\");\n@@ -247,1 +265,1 @@\n-  if (open_regions_mapped()) {\n+  if (is_fully_available()) {\n@@ -324,1 +342,1 @@\n-  if (is_heap_object_archiving_allowed()) {\n+  if (HeapShared::can_write()) {\n@@ -368,1 +386,1 @@\n-  assert(is_heap_object_archiving_allowed(), \"Cannot archive java heap objects\");\n+  assert(HeapShared::can_write(), \"must be\");\n@@ -385,1 +403,1 @@\n-  assert(is_heap_object_archiving_allowed(), \"Cannot archive java heap objects\");\n+  assert(HeapShared::can_write(), \"must be\");\n@@ -687,1 +705,1 @@\n-  if (!is_mapped()) {\n+  if (!is_fully_available()) {\n@@ -725,1 +743,1 @@\n-  if (!is_mapped()) {\n+  if (!is_fully_available()) {\n@@ -1280,1 +1298,1 @@\n-  assert(is_heap_object_archiving_allowed(), \"Sanity check\");\n+  assert(HeapShared::can_write(), \"must be\");\n@@ -1296,1 +1314,1 @@\n-  if (is_heap_object_archiving_allowed()) {\n+  if (HeapShared::can_write()) {\n@@ -1456,0 +1474,266 @@\n+\/\/ The CDS archive remembers each heap object by its address at dump time, but\n+\/\/ the heap object may be loaded at a different address at run time. This structure is used\n+\/\/ to translate the dump time addresses for all objects in FileMapInfo::space_at(region_index)\n+\/\/ to their runtime addresses.\n+struct LoadedArchiveHeapRegion {\n+  int       _region_index;   \/\/ index for FileMapInfo::space_at(index)\n+  size_t    _region_size;    \/\/ number of bytes in this region\n+  uintptr_t _dumptime_base;  \/\/ The dump-time (decoded) address of the first object in this region\n+  intx      _runtime_offset; \/\/ If an object's dump time address P is within in this region, its\n+                             \/\/ runtime address is P + _runtime_offset\n+\n+  static int comparator(const void* a, const void* b) {\n+    LoadedArchiveHeapRegion* reg_a = (LoadedArchiveHeapRegion*)a;\n+    LoadedArchiveHeapRegion* reg_b = (LoadedArchiveHeapRegion*)b;\n+    if (reg_a->_dumptime_base < reg_b->_dumptime_base) {\n+      return -1;\n+    } else if (reg_a->_dumptime_base == reg_b->_dumptime_base) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  }\n+\n+  uintptr_t top() {\n+    return _dumptime_base + _region_size;\n+  }\n+};\n+\n+void HeapShared::init_loaded_heap_relocation(LoadedArchiveHeapRegion* loaded_regions,\n+                                             int num_loaded_regions) {\n+  _dumptime_base_0 = loaded_regions[0]._dumptime_base;\n+  _dumptime_base_1 = loaded_regions[1]._dumptime_base;\n+  _dumptime_base_2 = loaded_regions[2]._dumptime_base;\n+  _dumptime_base_3 = loaded_regions[3]._dumptime_base;\n+  _dumptime_top = loaded_regions[num_loaded_regions-1].top();\n+\n+  _runtime_offset_0 = loaded_regions[0]._runtime_offset;\n+  _runtime_offset_1 = loaded_regions[1]._runtime_offset;\n+  _runtime_offset_2 = loaded_regions[2]._runtime_offset;\n+  _runtime_offset_3 = loaded_regions[3]._runtime_offset;\n+\n+  assert(2 <= num_loaded_regions && num_loaded_regions <= 4, \"must be\");\n+  if (num_loaded_regions < 4) {\n+    _dumptime_base_3 = UINTPTR_MAX;\n+  }\n+  if (num_loaded_regions < 3) {\n+    _dumptime_base_2 = UINTPTR_MAX;\n+  }\n+}\n+\n+bool HeapShared::can_load() {\n+  return Universe::heap()->can_load_archived_objects();\n+}\n+\n+template <int NUM_LOADED_REGIONS>\n+class PatchLoadedRegionPointers: public BitMapClosure {\n+  narrowOop* _start;\n+  intx _offset_0;\n+  intx _offset_1;\n+  intx _offset_2;\n+  intx _offset_3;\n+  uintptr_t _base_0;\n+  uintptr_t _base_1;\n+  uintptr_t _base_2;\n+  uintptr_t _base_3;\n+  uintptr_t _top;\n+\n+  static_assert(MetaspaceShared::max_num_heap_regions == 4, \"can't handle more than 4 regions\");\n+  static_assert(NUM_LOADED_REGIONS >= 2, \"we have at least 2 loaded regions\");\n+  static_assert(NUM_LOADED_REGIONS <= 4, \"we have at most 4 loaded regions\");\n+\n+ public:\n+  PatchLoadedRegionPointers(narrowOop* start, LoadedArchiveHeapRegion* loaded_regions)\n+    : _start(start),\n+      _offset_0(loaded_regions[0]._runtime_offset),\n+      _offset_1(loaded_regions[1]._runtime_offset),\n+      _offset_2(loaded_regions[2]._runtime_offset),\n+      _offset_3(loaded_regions[3]._runtime_offset),\n+      _base_0(loaded_regions[0]._dumptime_base),\n+      _base_1(loaded_regions[1]._dumptime_base),\n+      _base_2(loaded_regions[2]._dumptime_base),\n+      _base_3(loaded_regions[3]._dumptime_base) {\n+    _top = loaded_regions[NUM_LOADED_REGIONS-1].top();\n+  }\n+\n+  bool do_bit(size_t offset) {\n+    narrowOop* p = _start + offset;\n+    narrowOop v = *p;\n+    assert(!CompressedOops::is_null(v), \"null oops should have been filtered out at dump time\");\n+    uintptr_t o = cast_from_oop<uintptr_t>(HeapShared::decode_from_archive(v));\n+    assert(_base_0 <= o && o < _top, \"must be\");\n+\n+\n+    \/\/ We usually have only 2 regions for the default archive. Use template to avoid unnecessary comparisons.\n+    if (NUM_LOADED_REGIONS > 3 && o >= _base_3) {\n+      o += _offset_3;\n+    } else if (NUM_LOADED_REGIONS > 2 && o >= _base_2) {\n+      o += _offset_2;\n+    } else if (o >= _base_1) {\n+      o += _offset_1;\n+    } else {\n+      o += _offset_0;\n+    }\n+    HeapShared::assert_in_loaded_heap(o);\n+    RawAccess<IS_NOT_NULL>::oop_store(p, cast_to_oop(o));\n+    return true;\n+  }\n+};\n+\n+int HeapShared::init_loaded_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+                                    uintptr_t* buffer_ret) {\n+  size_t total_bytes = 0;\n+  int num_loaded_regions = 0;\n+  for (int i = MetaspaceShared::first_archive_heap_region;\n+       i <= MetaspaceShared::last_archive_heap_region; i++) {\n+    FileMapRegion* r = mapinfo->space_at(i);\n+    r->assert_is_heap_region();\n+    if (r->used() > 0) {\n+      assert(is_aligned(r->used(), HeapWordSize), \"must be\");\n+      total_bytes += r->used();\n+      LoadedArchiveHeapRegion* ri = &loaded_regions[num_loaded_regions++];\n+      ri->_region_index = i;\n+      ri->_region_size = r->used();\n+      ri->_dumptime_base = (uintptr_t)mapinfo->start_address_as_decoded_from_archive(r);\n+    }\n+  }\n+\n+  assert(is_aligned(total_bytes, HeapWordSize), \"must be\");\n+  uintptr_t buffer = (uintptr_t)\n+    Universe::heap()->allocate_loaded_archive_space(total_bytes \/ HeapWordSize);\n+  _loaded_heap_bottom = buffer;\n+  _loaded_heap_top    = buffer + total_bytes;\n+\n+  *buffer_ret = buffer;\n+  return num_loaded_regions;\n+}\n+\n+void HeapShared::sort_loaded_regions(LoadedArchiveHeapRegion* loaded_regions, int num_loaded_regions,\n+                                     uintptr_t buffer) {\n+  \/\/ Find the relocation offset of the pointers in each region\n+  qsort(loaded_regions, num_loaded_regions, sizeof(LoadedArchiveHeapRegion),\n+        LoadedArchiveHeapRegion::comparator);\n+\n+  uintptr_t p = buffer;\n+  for (int i = 0; i < num_loaded_regions; i++) {\n+    \/\/ This region will be loaded at p, so all objects inside this\n+    \/\/ region will be shifted by ri->offset\n+    LoadedArchiveHeapRegion* ri = &loaded_regions[i];\n+    ri->_runtime_offset = p - ri->_dumptime_base;\n+    p += ri->_region_size;\n+  }\n+  assert(p == _loaded_heap_top, \"must be\");\n+}\n+\n+bool HeapShared::load_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+                              int num_loaded_regions, uintptr_t buffer) {\n+  uintptr_t bitmap_base = (uintptr_t)mapinfo->map_bitmap_region();\n+  uintptr_t load_address = buffer;\n+  for (int i = 0; i < num_loaded_regions; i++) {\n+    LoadedArchiveHeapRegion* ri = &loaded_regions[i];\n+    FileMapRegion* r = mapinfo->space_at(ri->_region_index);\n+\n+    if (!mapinfo->read_region(ri->_region_index, (char*)load_address, r->used())) {\n+      \/\/ There's no easy way to free the buffer, so we will fill it with zero later\n+      \/\/ in fill_failed_loaded_region(), and it will eventually be GC'ed.\n+      log_warning(cds)(\"Loading of heap region %d has failed. Archived objects are disabled\", i);\n+      _loading_failed = true;\n+      return false;\n+    }\n+    log_info(cds)(\"Loaded heap    region #%d at base \" INTPTR_FORMAT \" size = \" SIZE_FORMAT_W(8) \" bytes, delta = \" INTX_FORMAT,\n+                  ri->_region_index, load_address, ri->_region_size, ri->_runtime_offset);\n+\n+    uintptr_t oopmap = bitmap_base + r->oopmap_offset();\n+    BitMapView bm((BitMap::bm_word_t*)oopmap, r->oopmap_size_in_bits());\n+\n+    if (num_loaded_regions == 4) {\n+      PatchLoadedRegionPointers<4> patcher((narrowOop*)load_address, loaded_regions);\n+      bm.iterate(&patcher);\n+    } else if (num_loaded_regions == 3) {\n+      PatchLoadedRegionPointers<3> patcher((narrowOop*)load_address, loaded_regions);\n+      bm.iterate(&patcher);\n+    } else {\n+      assert(num_loaded_regions == 2, \"must be\");\n+      PatchLoadedRegionPointers<2> patcher((narrowOop*)load_address, loaded_regions);\n+      bm.iterate(&patcher);\n+    }\n+\n+    load_address += r->used();\n+  }\n+\n+  return true;\n+}\n+\n+bool HeapShared::load_heap_regions(FileMapInfo* mapinfo) {\n+  init_narrow_oop_decoding(mapinfo->narrow_oop_base(), mapinfo->narrow_oop_shift());\n+\n+  LoadedArchiveHeapRegion loaded_regions[MetaspaceShared::max_num_heap_regions];\n+  memset(loaded_regions, 0, sizeof(loaded_regions));\n+\n+  uintptr_t buffer;\n+  int num_loaded_regions = init_loaded_regions(mapinfo, loaded_regions, &buffer);\n+  sort_loaded_regions(loaded_regions, num_loaded_regions, buffer);\n+  if (!load_regions(mapinfo, loaded_regions, num_loaded_regions, buffer)) {\n+    return false;\n+  }\n+\n+  init_loaded_heap_relocation(loaded_regions, num_loaded_regions);\n+  _is_loaded = true;\n+  set_roots(mapinfo->heap_obj_roots());\n+\n+  return true;\n+}\n+\n+class VerifyLoadedHeapEmbeddedPointers: public BasicOopIterateClosure {\n+  ResourceHashtable<uintptr_t, bool>* _table;\n+\n+ public:\n+  VerifyLoadedHeapEmbeddedPointers(ResourceHashtable<uintptr_t, bool>* table) : _table(table) {}\n+\n+  virtual void do_oop(narrowOop* p) {\n+    \/\/ This should be called before the loaded regions are modified, so all the embedded pointers\n+    \/\/ must be NULL, or must point to a valid object in the loaded regions.\n+    narrowOop v = *p;\n+    if (!CompressedOops::is_null(v)) {\n+      oop o = CompressedOops::decode_not_null(v);\n+      uintptr_t u = cast_from_oop<uintptr_t>(o);\n+      HeapShared::assert_in_loaded_heap(u);\n+      guarantee(_table->contains(u), \"must point to beginning of object in loaded archived regions\");\n+    }\n+  }\n+  virtual void do_oop(oop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n+void HeapShared::verify_loaded_heap() {\n+  if (!VerifyArchivedFields || !is_loaded()) {\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+  ResourceHashtable<uintptr_t, bool> table;\n+  VerifyLoadedHeapEmbeddedPointers verifier(&table);\n+  HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n+  HeapWord* top    = (HeapWord*)_loaded_heap_top;\n+\n+  for (HeapWord* p = bottom; p < top; ) {\n+    oop o = cast_to_oop(p);\n+    table.put(cast_from_oop<uintptr_t>(o), true);\n+    p += o->size();\n+  }\n+\n+  for (HeapWord* p = bottom; p < top; ) {\n+    oop o = cast_to_oop(p);\n+    o->oop_iterate(&verifier);\n+    p += o->size();\n+  }\n+}\n+\n+void HeapShared::fill_failed_loaded_region() {\n+  assert(_loading_failed, \"must be\");\n+  HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n+  HeapWord* top = (HeapWord*)_loaded_heap_top;\n+  Universe::heap()->fill_with_objects(bottom, top - bottom);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":298,"deletions":14,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class FileMapInfo;\n@@ -141,0 +142,2 @@\n+struct LoadedArchiveHeapRegion;\n+\n@@ -143,1 +146,0 @@\n- private:\n@@ -145,0 +147,44 @@\n+public:\n+  \/\/ At runtime, heap regions in the CDS archive can be used in two different ways,\n+  \/\/ depending on the GC type:\n+  \/\/ - Mapped: (G1 only) the regions are directly mapped into the Java heap\n+  \/\/ - Loaded: At VM start-up, the objects in the heap regions are copied into the\n+  \/\/           Java heap. This is easier to implement than mapping but\n+  \/\/           slightly less efficient, as the embedded pointers need to be relocated.\n+  static bool can_use() { return can_map() || can_load(); }\n+\n+  \/\/ Can this VM write heap regions into the CDS archive? Currently only G1+compressed{oops,cp}\n+  static bool can_write() {\n+    assert(DumpSharedSpaces, \"only when writing static archive\");\n+    CDS_JAVA_HEAP_ONLY(return (UseG1GC && UseCompressedOops && UseCompressedClassPointers);)\n+    NOT_CDS_JAVA_HEAP(return false;)\n+  }\n+\n+  \/\/ Can this VM map archived heap regions? Currently only G1+compressed{oops,cp}\n+  static bool can_map() {\n+    CDS_JAVA_HEAP_ONLY(return (UseG1GC && UseCompressedOops && UseCompressedClassPointers);)\n+    NOT_CDS_JAVA_HEAP(return false;)\n+  }\n+  static bool is_mapped() {\n+    return closed_regions_mapped() && open_regions_mapped();\n+  }\n+\n+  \/\/ Can this VM load the objects from archived heap regions into the heap at start-up?\n+  static bool can_load()  NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void verify_loaded_heap() NOT_CDS_JAVA_HEAP_RETURN;\n+  static bool is_loaded() {\n+    CDS_JAVA_HEAP_ONLY(return _is_loaded;)\n+    NOT_CDS_JAVA_HEAP(return false;)\n+  }\n+\n+  static bool are_archived_strings_available() {\n+    return is_loaded() || closed_regions_mapped();\n+  }\n+  static bool are_archived_mirrors_available() {\n+    return is_fully_available();\n+  }\n+  static bool is_fully_available() {\n+    return is_loaded() || is_mapped();\n+  }\n+\n+private:\n@@ -148,0 +194,1 @@\n+  static bool _is_loaded;\n@@ -150,0 +197,15 @@\n+  \/\/ Support for loaded archived heap. These are cached values from\n+  \/\/ LoadedArchiveHeapRegion's.\n+  static uintptr_t _dumptime_base_0;\n+  static uintptr_t _dumptime_base_1;\n+  static uintptr_t _dumptime_base_2;\n+  static uintptr_t _dumptime_base_3;\n+  static uintptr_t _dumptime_top;\n+  static intx _runtime_offset_0;\n+  static intx _runtime_offset_1;\n+  static intx _runtime_offset_2;\n+  static intx _runtime_offset_3;\n+  static uintptr_t _loaded_heap_bottom;\n+  static uintptr_t _loaded_heap_top;\n+  static bool _loading_failed;\n+\n@@ -156,0 +218,8 @@\n+  static bool load_heap_regions(FileMapInfo* mapinfo);\n+  static bool is_in_loaded_heap(uintptr_t o) {\n+    return (_loaded_heap_bottom <= o && o < _loaded_heap_top);\n+  }\n+  static void assert_in_loaded_heap(uintptr_t o) {\n+    assert(is_in_loaded_heap(o), \"must be\");\n+  }\n+\n@@ -277,0 +347,10 @@\n+\n+  static int init_loaded_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+                                 uintptr_t* buffer_ret);\n+  static void sort_loaded_regions(LoadedArchiveHeapRegion* loaded_regions, int num_loaded_regions,\n+                                  uintptr_t buffer);\n+  static bool load_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+                           int num_loaded_regions, uintptr_t buffer);\n+  static void init_loaded_heap_relocation(LoadedArchiveHeapRegion* reloc_info,\n+                                          int num_loaded_regions);\n+  static void fill_failed_loaded_region();\n@@ -339,5 +419,0 @@\n-  static bool is_heap_object_archiving_allowed() {\n-    CDS_JAVA_HEAP_ONLY(return (UseG1GC && UseCompressedOops && UseCompressedClassPointers);)\n-    NOT_CDS_JAVA_HEAP(return false;)\n-  }\n-\n@@ -366,3 +441,0 @@\n-  static bool is_mapped() {\n-    return closed_regions_mapped() && open_regions_mapped();\n-  }\n@@ -370,1 +442,1 @@\n-  static void fixup_mapped_regions() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void fixup_regions() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":82,"deletions":10,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -36,1 +36,15 @@\n-  oop result = cast_to_oop((uintptr_t)_narrow_oop_base + ((uintptr_t)v << _narrow_oop_shift));\n+  uintptr_t p = ((uintptr_t)_narrow_oop_base) + ((uintptr_t)v << _narrow_oop_shift);\n+  if (p >= _dumptime_base_0) {\n+    assert(p < _dumptime_top, \"must be\");\n+    if (p >= _dumptime_base_3) {\n+      p += _runtime_offset_3;\n+    } else if (p >= _dumptime_base_2) {\n+      p += _runtime_offset_2;\n+    } else if (p >= _dumptime_base_1) {\n+      p += _runtime_offset_1;\n+    } else {\n+      p += _runtime_offset_0;\n+    }\n+  }\n+\n+  oop result = cast_to_oop((uintptr_t)p);\n","filename":"src\/hotspot\/share\/cds\/heapShared.inline.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -370,0 +370,5 @@\n+  \/\/ Need to do this first, as subsequent steps may call virtual functions\n+  \/\/ in archived Metadata objects.\n+  CppVtables::serialize(soc);\n+  soc->do_tag(--tag);\n+\n@@ -391,3 +396,0 @@\n-  CppVtables::serialize(soc);\n-  soc->do_tag(--tag);\n-\n@@ -830,1 +832,1 @@\n-  if(!HeapShared::is_heap_object_archiving_allowed()) {\n+  if(!HeapShared::can_write()) {\n@@ -867,1 +869,1 @@\n-  if (HeapShared::is_heap_object_archiving_allowed()) {\n+  if (HeapShared::can_write()) {\n@@ -1139,1 +1141,1 @@\n-          static_mapinfo->map_heap_regions();\n+          static_mapinfo->map_or_load_heap_regions();\n@@ -1423,1 +1425,1 @@\n-  \/\/ shared string\/symbol tables\n+  \/\/ shared string\/symbol tables.\n@@ -1432,0 +1434,2 @@\n+  \/\/ Finish up archived heap initialization. These must be\n+  \/\/ done after ReadClosure.\n@@ -1433,0 +1437,1 @@\n+  HeapShared::verify_loaded_heap();\n@@ -1515,2 +1520,9 @@\n-  bool result = _use_optimized_module_handling && _use_full_module_graph &&\n-    (UseSharedSpaces || DumpSharedSpaces) && HeapShared::is_heap_object_archiving_allowed();\n+  bool result = _use_optimized_module_handling && _use_full_module_graph;\n+  if (DumpSharedSpaces) {\n+    result &= HeapShared::can_write();\n+  } else if (UseSharedSpaces) {\n+    result &= HeapShared::can_use();\n+  } else {\n+    result = false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    num_non_heap_spaces = 3,   \/\/ rw and ro and bm\n+    num_non_heap_regions = 3,  \/\/ rw and ro and bm\n@@ -67,1 +67,1 @@\n-    \/\/ mapped java heap regions\n+    \/\/ java heap regions\n@@ -69,2 +69,2 @@\n-    max_closed_heap_region = 2,\n-    last_closed_heap_region = first_closed_heap_region + max_closed_heap_region - 1,\n+    max_num_closed_heap_regions = 2,\n+    last_closed_heap_region = first_closed_heap_region + max_num_closed_heap_regions - 1,\n@@ -72,2 +72,6 @@\n-    max_open_heap_region = 2,\n-    last_open_heap_region = first_open_heap_region + max_open_heap_region - 1,\n+    max_num_open_heap_regions = 2,\n+    last_open_heap_region = first_open_heap_region + max_num_open_heap_regions - 1,\n+    max_num_heap_regions = max_num_closed_heap_regions + max_num_open_heap_regions,\n+\n+    first_archive_heap_region = first_closed_heap_region,\n+    last_archive_heap_region = last_open_heap_region,\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -906,1 +906,1 @@\n-    if (HeapShared::open_regions_mapped()) {\n+    if (HeapShared::are_archived_mirrors_available()) {\n@@ -1149,2 +1149,1 @@\n-  assert(HeapShared::is_heap_object_archiving_allowed(),\n-         \"HeapShared::is_heap_object_archiving_allowed() must be true\");\n+  assert(HeapShared::can_write(), \"must be\");\n@@ -1188,2 +1187,1 @@\n-  assert(HeapShared::is_heap_object_archiving_allowed(),\n-         \"HeapShared::is_heap_object_archiving_allowed() must be true\");\n+  assert(HeapShared::can_write(), \"must be\");\n@@ -1343,1 +1341,3 @@\n-  assert(Universe::heap()->is_archived_object(m), \"must be archived mirror object\");\n+  if (HeapShared::is_mapped()) {\n+    assert(Universe::heap()->is_archived_object(m), \"must be archived mirror object\");\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-static CompactHashtable<\n+typedef CompactHashtable<\n@@ -78,2 +78,3 @@\n-  java_lang_String::equals\n-> _shared_table;\n+  java_lang_String::equals> SharedStringTable;\n+\n+static SharedStringTable _shared_table;\n@@ -764,1 +765,1 @@\n-  assert(HeapShared::is_heap_object_archiving_allowed(), \"must be\");\n+  assert(HeapShared::can_write(), \"must be\");\n@@ -782,1 +783,1 @@\n-  } else if (!HeapShared::closed_regions_mapped()) {\n+  } else if (!HeapShared::are_archived_strings_available()) {\n@@ -785,0 +786,38 @@\n+\n+}\n+\n+class SharedStringTransfer {\n+  JavaThread* _current;\n+public:\n+  SharedStringTransfer(JavaThread* current) : _current(current) {}\n+\n+  void do_value(oop string) {\n+    JavaThread* THREAD = _current;\n+    ExceptionMark rm(THREAD);\n+    HandleMark hm(THREAD);\n+    StringTable::intern(string, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ The archived constant pools contains strings that must be in the interned string table.\n+      \/\/ If we fail here, it means the VM runs out of memory during bootstrap, so there's no point\n+      \/\/ of trying to recover from here.\n+      vm_exit_during_initialization(\"Failed to transfer shared strings to interned string table\");\n+    }\n+  }\n+};\n+\n+\/\/ If the CDS archive heap is loaded (not mapped) into the old generation,\n+\/\/ it's possible for the shared strings to move due to full GC, making the\n+\/\/ _shared_table invalid. Therefore, we proactively copy all the shared\n+\/\/ strings into the _local_table, which can deal with oop relocation.\n+void StringTable::transfer_shared_strings_to_local_table() {\n+  assert(HeapShared::is_loaded(), \"must be\");\n+  EXCEPTION_MARK;\n+\n+  \/\/ Reset _shared_table so that during the transfer, StringTable::intern()\n+  \/\/ will not look up from there. Instead, it will create a new entry in\n+  \/\/ _local_table for each element in shared_table_copy.\n+  SharedStringTable shared_table_copy = _shared_table;\n+  _shared_table.reset();\n+\n+  SharedStringTransfer transfer(THREAD);\n+  shared_table_copy.iterate(&transfer);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+  static void transfer_shared_strings_to_local_table() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1663,1 +1663,1 @@\n-  if (!HeapShared::open_regions_mapped()) {\n+  if (!HeapShared::are_archived_mirrors_available()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    \/\/ HeapShared::fixup_mapped_regions() fills the empty\n+    \/\/ HeapShared::fixup_regions() fills the empty\n@@ -142,1 +142,1 @@\n-    HeapShared::fixup_mapped_regions();\n+    HeapShared::fixup_regions();\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n@@ -107,1 +107,1 @@\n-HeapWord* EpsilonHeap::allocate_work(size_t size) {\n+HeapWord* EpsilonHeap::allocate_work(size_t size, bool verbose) {\n@@ -153,1 +153,1 @@\n-  {\n+  if (verbose) {\n@@ -161,1 +161,1 @@\n-  {\n+  if (verbose) {\n@@ -266,0 +266,5 @@\n+HeapWord* EpsilonHeap::allocate_loaded_archive_space(size_t size) {\n+  \/\/ Cannot use verbose=true because Metaspace is not initialized\n+  return allocate_work(size, \/* verbose = *\/false);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n@@ -91,1 +91,1 @@\n-  HeapWord* allocate_work(size_t size);\n+  HeapWord* allocate_work(size_t size, bool verbose = true);\n@@ -134,0 +134,4 @@\n+  \/\/ Support for loading objects from CDS archive into the heap\n+  virtual bool can_load_archived_objects() const { return true; }\n+  virtual HeapWord* allocate_loaded_archive_space(size_t size);\n+\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -484,0 +484,5 @@\n+  \/\/ Support for loading objects from CDS archive into the heap\n+  \/\/ (usually as a snapshot of the old generation).\n+  virtual bool can_load_archived_objects() const { return false; }\n+  virtual HeapWord* allocate_loaded_archive_space(size_t size) { return NULL; }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-        if (HeapShared::is_heap_object_archiving_allowed()) {\n+        if (HeapShared::can_write()) {\n@@ -436,1 +436,1 @@\n-        HeapShared::open_regions_mapped() &&\n+        HeapShared::are_archived_mirrors_available() &&\n@@ -438,1 +438,1 @@\n-      assert(HeapShared::is_heap_object_archiving_allowed(), \"Sanity\");\n+      assert(HeapShared::can_use(), \"Sanity\");\n@@ -772,0 +772,3 @@\n+    if (HeapShared::is_loaded()) {\n+      StringTable::transfer_shared_strings_to_local_table();\n+    }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-    if (HeapShared::open_regions_mapped() &&\n+    if (HeapShared::is_fully_available() &&\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-    if (HeapShared::open_regions_mapped()) {\n+    if (HeapShared::are_archived_mirrors_available()) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2005,1 +2005,1 @@\n-  return HeapShared::is_heap_object_archiving_allowed();\n+  return HeapShared::can_use();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,0 +363,1 @@\n+ -runtime\/cds\/appcds\/TestEpsilonGCWithCDS.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -401,4 +401,1 @@\n-        ArrayList<String> cmd = new ArrayList<String>();\n-\n-        for (String p : opts.prefix) cmd.add(p);\n-\n+        ArrayList<String> cmd = opts.getRuntimePrefix();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test Loading CDS archived heap objects into EpsilonGC\n+ * @bug 8234679\n+ * @requires vm.cds\n+ * @requires vm.gc.Epsilon\n+ * @requires vm.gc.G1\n+ *\n+ * @comment don't run this test if any -XX::+Use???GC options are specified, since they will\n+ *          interfere with the the test.\n+ * @requires vm.gc == null\n+ *\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/Hello.java\n+ * @run driver TestEpsilonGCWithCDS\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestEpsilonGCWithCDS {\n+    public final static String HELLO = \"Hello World\";\n+    static String helloJar;\n+\n+    public static void main(String... args) throws Exception {\n+        helloJar = JarBuilder.build(\"hello\", \"Hello\");\n+\n+        \/\/ Check if we can use EpsilonGC during dump time, or run time, or both.\n+        test(false, true);\n+        test(true,  false);\n+        test(true,  true);\n+\n+        \/\/ We usually have 2 heap regions. To increase test coverage, we can have 3 heap regions\n+        \/\/ by using \"-Xmx256m -XX:ObjectAlignmentInBytes=64\"\n+        test(false, true, true);\n+    }\n+\n+    static String G1 = \"-XX:+UseG1GC\";\n+    static String Epsilon = \"-XX:+UseEpsilonGC\";\n+    static String experiment = \"-XX:+UnlockExperimentalVMOptions\";\n+\n+    static void test(boolean dumpWithEpsilon, boolean execWithEpsilon) throws Exception {\n+        test(dumpWithEpsilon, execWithEpsilon, false);\n+    }\n+\n+    static void test(boolean dumpWithEpsilon, boolean execWithEpsilon, boolean useSmallRegions) throws Exception {\n+        String dumpGC = dumpWithEpsilon ? Epsilon : G1;\n+        String execGC = execWithEpsilon ? Epsilon : G1;\n+        String small1 = useSmallRegions ? \"-Xmx256m\" : \"-showversion\";\n+        String small2 = useSmallRegions ? \"-XX:ObjectAlignmentInBytes=64\" : \"-showversion\";\n+        OutputAnalyzer out;\n+\n+        System.out.println(\"0. Dump with \" + dumpGC);\n+        out = TestCommon.dump(helloJar,\n+                              new String[] {\"Hello\"},\n+                              experiment,\n+                              dumpGC,\n+                              small1,\n+                              small2,\n+                              \"-Xlog:cds\");\n+        out.shouldContain(\"Dumping shared data to file:\");\n+        out.shouldHaveExitValue(0);\n+\n+        System.out.println(\"1. Exec with \" + execGC);\n+        out = TestCommon.exec(helloJar,\n+                              experiment,\n+                              execGC,\n+                              small1,\n+                              small2,\n+                              \"-Xlog:cds\",\n+                              \"Hello\");\n+        out.shouldContain(HELLO);\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestEpsilonGCWithCDS.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.test.lib.cds.CDSOptions;\n@@ -47,0 +48,4 @@\n+    static {\n+        \/\/ EpsilonGC does not support class unloading.\n+        CDSOptions.disableRuntimePrefixForEpsilonGC();\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/HelloCustom.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.test.lib.cds.CDSOptions;\n@@ -46,0 +47,4 @@\n+    static {\n+        \/\/ EpsilonGC does not support class unloading.\n+        CDSOptions.disableRuntimePrefixForEpsilonGC();\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/UnloadUnregisteredLoaderTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+    static {\n+        \/\/ EpsilonGC will run out of memory.\n+        CDSOptions.disableRuntimePrefixForEpsilonGC();\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/GCSharedStringsDuringDump.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.cds.CDSOptions;\n@@ -42,0 +43,4 @@\n+    static {\n+        \/\/ EpsilonGC will run out of memory.\n+        CDSOptions.disableRuntimePrefixForEpsilonGC();\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsStress.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+        vmGCforCDS(map); \/\/ may set vm.gc\n@@ -294,0 +295,28 @@\n+    \/**\n+     * \"jtreg -vmoptions:-Dtest.cds.runtime.options=...\" can be used to specify\n+     * the GC type to be used when running with a CDS archive. Set \"vm.gc\" accordingly,\n+     * so that tests that need to explicitly choose the GC type can be excluded\n+     * with \"@requires vm.gc == null\".\n+     *\n+     * @param map - property-value pairs\n+     *\/\n+    protected void vmGCforCDS(SafeMap map) {\n+        if (!GC.isSelectedErgonomically()) {\n+            \/\/ The GC has been explicitly specified on the command line, so\n+            \/\/ jtreg will set the \"vm.gc\" property. Let's not interfere with it.\n+            return;\n+        }\n+\n+        String GC_PREFIX  = \"-XX:+Use\";\n+        String GC_SUFFIX  = \"GC\";\n+        String jtropts = System.getProperty(\"test.cds.runtime.options\");\n+        if (jtropts != null) {\n+            for (String opt : jtropts.split(\",\")) {\n+                if (opt.startsWith(GC_PREFIX) && opt.endsWith(GC_SUFFIX)) {\n+                    String gc = opt.substring(GC_PREFIX.length(), opt.length() - GC_SUFFIX.length());\n+                    map.put(\"vm.gc\", () -> gc);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -103,0 +103,38 @@\n+    \/\/ Call by CDSTestUtils.runWithArchive() and TestCommon.runWithArchive().\n+    \/\/\n+    \/\/ Example:\n+    \/\/  - The dumping will be done with the default G1GC so we can generate\n+    \/\/    the archived heap.\n+    \/\/  - The runtime execution will be done with the EpsilonGC, to test its\n+    \/\/    ability to load the the archived heap.\n+    \/\/\n+    \/\/ jtreg -vmoptions:-Dtest.cds.runtime.options=-XX:+UnlockExperimentalVMOptions,-XX:+UseEpsilonGC \\\n+    \/\/       test\/hotspot\/jtreg\/runtime\/cds\n+    public ArrayList<String> getRuntimePrefix() {\n+        ArrayList<String> cmdline = new ArrayList<>();\n+\n+        String jtropts = System.getProperty(\"test.cds.runtime.options\");\n+        if (jtropts != null) {\n+            for (String s : jtropts.split(\",\")) {\n+                if (!disabledRuntimePrefixes.contains(s)) {\n+                    cmdline.add(s);\n+                }\n+            }\n+        }\n+\n+        for (String p : prefix) {\n+            cmdline.add(p);\n+        }\n+\n+        return cmdline;\n+    }\n+\n+    static ArrayList<String> disabledRuntimePrefixes = new ArrayList<>();\n+\n+    public static void disableRuntimePrefix(String s) {\n+        disabledRuntimePrefixes.add(s);\n+    }\n+\n+    public static void disableRuntimePrefixForEpsilonGC() {\n+        disableRuntimePrefix(\"-XX:+UseEpsilonGC\");\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSOptions.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -407,4 +407,1 @@\n-        ArrayList<String> cmd = new ArrayList<String>();\n-\n-        for (String p : opts.prefix) cmd.add(p);\n-\n+        ArrayList<String> cmd = opts.getRuntimePrefix();\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}