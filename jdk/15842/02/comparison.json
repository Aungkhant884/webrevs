{"files":[{"patch":"@@ -1270,4 +1270,7 @@\n-  if (s1->Opcode() != s2->Opcode()) return false;\n-  if (s1->req() != s2->req()) return false;\n-  if (!same_velt_type(s1, s2)) return false;\n-  if (s1->is_Bool() && s1->as_Bool()->_test._test != s2->as_Bool()->_test._test) return false;\n+  if (s1->Opcode() != s2->Opcode() ||\n+      s1->req() != s2->req() ||\n+      !same_velt_type(s1, s2) ||\n+      (s1->is_Bool() && s1->as_Bool()->_test._test != s2->as_Bool()->_test._test)) {\n+    return false;\n+  }\n+\n@@ -1280,2 +1283,0 @@\n-    bool s1_ctrl_inv = ((s1_ctrl == nullptr) ? true : lpt()->is_invariant(s1_ctrl));\n-    bool s2_ctrl_inv = ((s2_ctrl == nullptr) ? true : lpt()->is_invariant(s2_ctrl));\n@@ -1283,29 +1284,3 @@\n-    if (!s1_ctrl_inv || !s2_ctrl_inv) {\n-      return false;\n-    }\n-    if(s1_ctrl != nullptr && s2_ctrl != nullptr) {\n-      if (s1_ctrl->is_Proj()) {\n-        s1_ctrl = s1_ctrl->in(0);\n-        assert(lpt()->is_invariant(s1_ctrl), \"must be invariant\");\n-      }\n-      if (s2_ctrl->is_Proj()) {\n-        s2_ctrl = s2_ctrl->in(0);\n-        assert(lpt()->is_invariant(s2_ctrl), \"must be invariant\");\n-      }\n-      if (!s1_ctrl->is_RangeCheck() || !s2_ctrl->is_RangeCheck()) {\n-        return false;\n-      }\n-    }\n-    \/\/ Control nodes are invariant. However, we have no way of checking whether they resolve\n-    \/\/ in an equivalent manner. But, we know that invariant range checks are guaranteed to\n-    \/\/ throw before the loop (if they would have thrown). Thus, the loop would not have been reached.\n-    \/\/ Therefore, if the control nodes for both are range checks, we accept them to be isomorphic.\n-    for (DUIterator_Fast imax, i = s1->fast_outs(imax); i < imax; i++) {\n-      Node* t1 = s1->fast_out(i);\n-      for (DUIterator_Fast jmax, j = s2->fast_outs(jmax); j < jmax; j++) {\n-        Node* t2 = s2->fast_out(j);\n-        if (VectorNode::is_muladds2i(t1) && VectorNode::is_muladds2i(t2)) {\n-          return true;\n-        }\n-      }\n-    }\n+    const bool s1_ctrl_inv = (s1_ctrl == nullptr) || lpt()->is_invariant(s1_ctrl);\n+    const bool s2_ctrl_inv = (s2_ctrl == nullptr) || lpt()->is_invariant(s2_ctrl);\n+    return s1_ctrl_inv && s2_ctrl_inv;\n@@ -1313,1 +1288,0 @@\n-  return false;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":10,"deletions":36,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -910,0 +910,16 @@\n+    public static final String MUL_ADD_S2I = PREFIX + \"MUL_ADD_S2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_ADD_S2I, \"MulAddS2I\");\n+    }\n+\n+    public static final String MUL_ADD_VS2VI = PREFIX + \"MUL_ADD_VS2VI\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_ADD_VS2VI, \"MulAddVS2VI\");\n+    }\n+\n+    \/\/ Can only be used if avx512_vnni is available.\n+    public static final String MUL_ADD_VS2VI_VNNI = PREFIX + \"MUL_ADD_VS2VI_VNNI\" + POSTFIX;\n+    static {\n+        machOnly(MUL_ADD_VS2VI_VNNI, \"vmuladdaddS2I_reg\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+        \"avx512_vnni\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8310886\n+ * @requires vm.bits == \"64\"\n+ * @summary Test MulAddS2I vectorization.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMulAddS2I\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+\n+public class TestMulAddS2I {\n+    static final int RANGE = 1024;\n+    static final int ITER  = RANGE\/2 - 1;\n+\n+    static short[] sArr1 = new short[RANGE];\n+    static short[] sArr2 = new short[RANGE];\n+    static final int[] GOLDEN;\n+\n+    static {\n+        for (int i = 0; i < RANGE; i++) {\n+            sArr1[i] = (short)(i + (1000 * AbstractInfo.getRandom().nextDouble()));\n+            sArr2[i] = (short)(RANGE - i + (2000 * AbstractInfo.getRandom().nextDouble()));\n+        }\n+        GOLDEN = test();\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        if (Platform.isX64() || Platform.isX86()) {\n+            TestFramework.runWithFlags(\"-XX:+UseUnalignedLoadStores\");\n+            TestFramework.runWithFlags(\"-XX:-UseUnalignedLoadStores\");\n+        } else {\n+            TestFramework.run();\n+        }\n+    }\n+\n+    @Run(test = \"test\")\n+    @Warmup(0)\n+    public static void run() {\n+        compare(test());\n+    }\n+\n+    public static void compare(int[] out) {\n+        for (int i = 0; i < ITER; i++) {\n+            Asserts.assertEQ(out[i], GOLDEN[i], \"wrong result for out[\" + i + \"]\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"false\"},\n+        failOn = {IRNode.MUL_ADD_VS2VI}, \/\/ Can only pack LoadS if UseUnalignedLoadStores is true (default if sse4.2)\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"},\n+            counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"true\"},\n+            counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] test() {\n+        int[] out = new int[ITER];\n+        int[] out2 = new int[ITER];\n+        for (int i = 0; i < ITER; i++) {\n+            out[i] += ((sArr1[2*i] * sArr1[2*i]) + (sArr1[2*i+1] * sArr1[2*i+1]));\n+            out2[i] += out[i];\n+        }\n+        return out;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}