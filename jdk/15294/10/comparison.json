{"files":[{"patch":"@@ -28,0 +28,12 @@\n+import javax.naming.CommunicationException;\n+import javax.naming.InterruptedNamingException;\n+import javax.naming.NamingException;\n+import javax.naming.ServiceUnavailableException;\n+import javax.naming.ldap.Control;\n+import javax.net.SocketFactory;\n+import javax.net.ssl.HandshakeCompletedEvent;\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSocket;\n+import javax.security.sasl.SaslException;\n@@ -30,1 +42,0 @@\n-import java.io.InterruptedIOException;\n@@ -32,1 +43,0 @@\n-import java.io.OutputStream;\n@@ -34,0 +44,4 @@\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -36,11 +50,0 @@\n-import javax.net.ssl.SSLSocket;\n-\n-import javax.naming.CommunicationException;\n-import javax.naming.ServiceUnavailableException;\n-import javax.naming.NamingException;\n-import javax.naming.InterruptedNamingException;\n-\n-import javax.naming.ldap.Control;\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.InvocationTargetException;\n@@ -54,6 +57,0 @@\n-import javax.net.SocketFactory;\n-import javax.net.ssl.SSLParameters;\n-import javax.net.ssl.HandshakeCompletedEvent;\n-import javax.net.ssl.HandshakeCompletedListener;\n-import javax.net.ssl.SSLPeerUnverifiedException;\n-import javax.security.sasl.SaslException;\n@@ -62,58 +59,58 @@\n-  * A thread that creates a connection to an LDAP server.\n-  * After the connection, the thread reads from the connection.\n-  * A caller can invoke methods on the instance to read LDAP responses\n-  * and to send LDAP requests.\n-  * <p>\n-  * There is a one-to-one correspondence between an LdapClient and\n-  * a Connection. Access to Connection and its methods is only via\n-  * LdapClient with two exceptions: SASL authentication and StartTLS.\n-  * SASL needs to access Connection's socket IO streams (in order to do encryption\n-  * of the security layer). StartTLS needs to do replace IO streams\n-  * and close the IO  streams on nonfatal close. The code for SASL\n-  * authentication can be treated as being the same as from LdapClient\n-  * because the SASL code is only ever called from LdapClient, from\n-  * inside LdapClient's synchronized authenticate() method. StartTLS is called\n-  * directly by the application but should only occur when the underlying\n-  * connection is quiet.\n-  * <p>\n-  * In terms of synchronization, worry about data structures\n-  * used by the Connection thread because that usage might contend\n-  * with calls by the main threads (i.e., those that call LdapClient).\n-  * Main threads need to worry about contention with each other.\n-  * Fields that Connection thread uses:\n-  *     inStream - synced access and update; initialized in constructor;\n-  *           referenced outside class unsync'ed (by LdapSasl) only\n-  *           when connection is quiet\n-  *     traceFile, traceTagIn, traceTagOut - no sync; debugging only\n-  *     parent - no sync; initialized in constructor; no updates\n-  *     pendingRequests - sync\n-  *     pauseLock - per-instance lock;\n-  *     paused - sync via pauseLock (pauseReader())\n-  * Members used by main threads (LdapClient):\n-  *     host, port - unsync; read-only access for StartTLS and debug messages\n-  *     setBound(), setV3() - no sync; called only by LdapClient.authenticate(),\n-  *             which is a sync method called only when connection is \"quiet\"\n-  *     getMsgId() - sync\n-  *     writeRequest(), removeRequest(),findRequest(), abandonOutstandingReqs() -\n-  *             access to shared pendingRequests is sync\n-  *     writeRequest(),  abandonRequest(), ldapUnbind() - access to outStream sync\n-  *     cleanup() - sync\n-  *     readReply() - access to sock sync\n-  *     unpauseReader() - (indirectly via writeRequest) sync on pauseLock\n-  * Members used by SASL auth (main thread):\n-  *     inStream, outStream - no sync; used to construct new stream; accessed\n-  *             only when conn is \"quiet\" and not shared\n-  *     replaceStreams() - sync method\n-  * Members used by StartTLS:\n-  *     inStream, outStream - no sync; used to record the existing streams;\n-  *             accessed only when conn is \"quiet\" and not shared\n-  *     replaceStreams() - sync method\n-  * <p>\n-  * Handles anonymous, simple, and SASL bind for v3; anonymous and simple\n-  * for v2.\n-  * %%% made public for access by LdapSasl %%%\n-  *\n-  * @author Vincent Ryan\n-  * @author Rosanna Lee\n-  * @author Jagane Sundar\n-  *\/\n+ * A thread that creates a connection to an LDAP server.\n+ * After the connection, the thread reads from the connection.\n+ * A caller can invoke methods on the instance to read LDAP responses\n+ * and to send LDAP requests.\n+ * <p>\n+ * There is a one-to-one correspondence between an LdapClient and\n+ * a Connection. Access to Connection and its methods is only via\n+ * LdapClient with two exceptions: SASL authentication and StartTLS.\n+ * SASL needs to access Connection's socket IO streams (in order to do encryption\n+ * of the security layer). StartTLS needs to do replace IO streams\n+ * and close the IO  streams on nonfatal close. The code for SASL\n+ * authentication can be treated as being the same as from LdapClient\n+ * because the SASL code is only ever called from LdapClient, from\n+ * inside LdapClient's synchronized authenticate() method. StartTLS is called\n+ * directly by the application but should only occur when the underlying\n+ * connection is quiet.\n+ * <p>\n+ * In terms of synchronization, worry about data structures\n+ * used by the Connection thread because that usage might contend\n+ * with calls by the main threads (i.e., those that call LdapClient).\n+ * Main threads need to worry about contention with each other.\n+ * Fields that Connection thread uses:\n+ * inStream - synced access and update; initialized in constructor;\n+ * referenced outside class unsync'ed (by LdapSasl) only\n+ * when connection is quiet\n+ * traceFile, traceTagIn, traceTagOut - no sync; debugging only\n+ * parent - no sync; initialized in constructor; no updates\n+ * pendingRequests - sync\n+ * pauseLock - per-instance lock;\n+ * paused - sync via pauseLock (pauseReader())\n+ * Members used by main threads (LdapClient):\n+ * host, port - unsync; read-only access for StartTLS and debug messages\n+ * setBound(), setV3() - no sync; called only by LdapClient.authenticate(),\n+ * which is a sync method called only when connection is \"quiet\"\n+ * getMsgId() - sync\n+ * writeRequest(), removeRequest(),findRequest(), abandonOutstandingReqs() -\n+ * access to shared pendingRequests is sync\n+ * writeRequest(),  abandonRequest(), ldapUnbind() - access to outStream sync\n+ * cleanup() - sync\n+ * readReply() - access to sock sync\n+ * unpauseReader() - (indirectly via writeRequest) sync on pauseLock\n+ * Members used by SASL auth (main thread):\n+ * inStream, outStream - no sync; used to construct new stream; accessed\n+ * only when conn is \"quiet\" and not shared\n+ * replaceStreams() - sync method\n+ * Members used by StartTLS:\n+ * inStream, outStream - no sync; used to record the existing streams;\n+ * accessed only when conn is \"quiet\" and not shared\n+ * replaceStreams() - sync method\n+ * <p>\n+ * Handles anonymous, simple, and SASL bind for v3; anonymous and simple\n+ * for v2.\n+ * %%% made public for access by LdapSasl %%%\n+ *\n+ * @author Vincent Ryan\n+ * @author Rosanna Lee\n+ * @author Jagane Sundar\n+ *\/\n@@ -131,1 +128,1 @@\n-                         \/\/ used by StartTlsResponse when creating an SSL socket\n+    \/\/ used by StartTlsResponse when creating an SSL socket\n@@ -133,1 +130,1 @@\n-                         \/\/ used by StartTlsResponse when creating an SSL socket\n+    \/\/ used by StartTlsResponse when creating an SSL socket\n@@ -192,0 +189,1 @@\n+\n@@ -214,1 +212,1 @@\n-        int connectTimeout, int readTimeout, OutputStream trace) throws NamingException {\n+               int connectTimeout, int readTimeout, OutputStream trace) throws NamingException {\n@@ -246,1 +244,1 @@\n-                new CommunicationException(host + \":\" + port);\n+                    new CommunicationException(host + \":\" + port);\n@@ -254,1 +252,1 @@\n-                new CommunicationException(host + \":\" + port);\n+                    new CommunicationException(host + \":\" + port);\n@@ -268,1 +266,1 @@\n-            return new InetSocketAddress(host, port);\n+        return new InetSocketAddress(host, port);\n@@ -281,1 +279,1 @@\n-            int connectTimeout) throws Exception {\n+                                int connectTimeout) throws Exception {\n@@ -283,3 +281,4 @@\n-        Socket socket = null;\n-\n-        if (socketFactory != null) {\n+        SocketFactory factory = getSocketFactory(socketFactory);\n+        assert factory != null;\n+        \/\/create the socket with default socket factory or custom factory\n+        Socket socket = createConnectionSocket(host, port, factory, connectTimeout);\n@@ -287,1 +286,11 @@\n-            \/\/ create the factory\n+        \/\/ the handshake for SSL connection with server and reset timeout for the socket\n+        try {\n+            initialSSLHandshake(socket, connectTimeout);\n+        } catch (Exception e) {\n+            \/\/ 8314063 the socket is not closed after the failure of handshake\n+            \/\/ close the socket while the error happened\n+            closeOpenedSocket(socket);\n+            throw e;\n+        }\n+        return socket;\n+    }\n@@ -289,0 +298,11 @@\n+    \/\/ get the socket factory, either default or custom\n+    private SocketFactory getSocketFactory(String socketFactoryName) throws Exception {\n+        if (socketFactoryName == null) {\n+            if (debug) {\n+                System.err.println(\"Connection: using default SocketFactory\");\n+            }\n+            return SocketFactory.getDefault();\n+        } else {\n+            if (debug) {\n+                System.err.println(\"Connection: loading supplied SocketFactory: \" + socketFactoryName);\n+            }\n@@ -291,1 +311,1 @@\n-                (Class<? extends SocketFactory>)Obj.helper.loadClass(socketFactory);\n+                    (Class<? extends SocketFactory>) Obj.helper.loadClass(socketFactoryName);\n@@ -293,1 +313,1 @@\n-                socketFactoryClass.getMethod(\"getDefault\", new Class<?>[]{});\n+                    socketFactoryClass.getMethod(\"getDefault\");\n@@ -295,0 +315,3 @@\n+            return factory;\n+        }\n+    }\n@@ -296,35 +319,3 @@\n-            \/\/ create the socket\n-\n-            if (connectTimeout > 0) {\n-\n-                InetSocketAddress endpoint =\n-                        createInetSocketAddress(host, port);\n-\n-                \/\/ unconnected socket\n-                socket = factory.createSocket();\n-\n-                if (debug) {\n-                    System.err.println(\"Connection: creating socket with \" +\n-                            \"a timeout using supplied socket factory\");\n-                }\n-\n-                \/\/ connected socket\n-                socket.connect(endpoint, connectTimeout);\n-            }\n-\n-            \/\/ continue (but ignore connectTimeout)\n-            if (socket == null) {\n-                if (debug) {\n-                    System.err.println(\"Connection: creating socket using \" +\n-                        \"supplied socket factory\");\n-                }\n-                \/\/ connected socket\n-                socket = factory.createSocket(host, port);\n-            }\n-        } else {\n-\n-            if (connectTimeout > 0) {\n-\n-                    InetSocketAddress endpoint = createInetSocketAddress(host, port);\n-\n-                    socket = new Socket();\n+    private Socket createConnectionSocket(String host, int port, SocketFactory factory,\n+                                          int connectTimeout) throws Exception {\n+        Socket socket = null;\n@@ -332,5 +323,12 @@\n-                    if (debug) {\n-                        System.err.println(\"Connection: creating socket with \" +\n-                            \"a timeout\");\n-                    }\n-                    socket.connect(endpoint, connectTimeout);\n+        if (connectTimeout > 0) {\n+            \/\/ create unconnected socket and then connect it if timeout\n+            \/\/ is supplied\n+            InetSocketAddress endpoint =\n+                    createInetSocketAddress(host, port);\n+            \/\/ unconnected socket\n+            socket = factory.createSocket();\n+            \/\/ connect socket with a timeout\n+            socket.connect(endpoint, connectTimeout);\n+            if (debug) {\n+                System.err.println(\"Connection: creating socket with \" +\n+                        \"a connect timeout\");\n@@ -338,9 +336,7 @@\n-\n-            \/\/ continue (but ignore connectTimeout)\n-\n-            if (socket == null) {\n-                if (debug) {\n-                    System.err.println(\"Connection: creating socket\");\n-                }\n-                \/\/ connected socket\n-                socket = new Socket(host, port);\n+        }\n+        if (socket == null) {\n+            \/\/ create connected socket\n+            socket = factory.createSocket(host, port);\n+            if (debug) {\n+                System.err.println(\"Connection: creating connected socket with\" +\n+                        \" no connect timeout\");\n@@ -349,0 +345,8 @@\n+        return socket;\n+    }\n+\n+    \/\/ For LDAP connect timeouts on LDAP over SSL connections must treat\n+    \/\/ the SSL handshake following socket connection as part of the timeout.\n+    \/\/ So explicitly set a socket read timeout, trigger the SSL handshake,\n+    \/\/ then reset the timeout.\n+    private void initialSSLHandshake(Socket socket, int connectTimeout) throws Exception {\n@@ -350,4 +354,0 @@\n-        \/\/ For LDAP connect timeouts on LDAP over SSL connections must treat\n-        \/\/ the SSL handshake following socket connection as part of the timeout.\n-        \/\/ So explicitly set a socket read timeout, trigger the SSL handshake,\n-        \/\/ then reset the timeout.\n@@ -369,1 +369,0 @@\n-        return socket;\n@@ -387,1 +386,1 @@\n-        boolean pauseAfterReceipt) throws IOException {\n+                             boolean pauseAfterReceipt) throws IOException {\n@@ -392,1 +391,1 @@\n-        boolean pauseAfterReceipt, int replyQueueCapacity) throws IOException {\n+                             boolean pauseAfterReceipt, int replyQueueCapacity) throws IOException {\n@@ -395,1 +394,1 @@\n-            new LdapRequest(msgId, pauseAfterReceipt, replyQueueCapacity);\n+                new LdapRequest(msgId, pauseAfterReceipt, replyQueueCapacity);\n@@ -435,1 +434,1 @@\n-                    \"; socket closed\");\n+                        \"; socket closed\");\n@@ -447,1 +446,1 @@\n-                \"Interrupted during LDAP operation\");\n+                    \"Interrupted during LDAP operation\");\n@@ -538,2 +537,2 @@\n-                ber.encodeInt(abandonMsgId);\n-                ber.encodeInt(ldr.msgId, LdapClient.LDAP_REQ_ABANDON);\n+            ber.encodeInt(abandonMsgId);\n+            ber.encodeInt(ldr.msgId, LdapClient.LDAP_REQ_ABANDON);\n@@ -541,3 +540,3 @@\n-                if (v3) {\n-                    LdapClient.encodeControls(ber, reqCtls);\n-                }\n+            if (v3) {\n+                LdapClient.encodeControls(ber, reqCtls);\n+            }\n@@ -548,1 +547,1 @@\n-                    ber.getDataLen());\n+                        ber.getDataLen());\n@@ -591,4 +590,4 @@\n-                ber.encodeInt(unbindMsgId);\n-                \/\/ IMPLICIT TAGS\n-                ber.encodeByte(LdapClient.LDAP_REQ_UNBIND);\n-                ber.encodeByte(0);\n+            ber.encodeInt(unbindMsgId);\n+            \/\/ IMPLICIT TAGS\n+            ber.encodeByte(LdapClient.LDAP_REQ_UNBIND);\n+            ber.encodeByte(0);\n@@ -596,3 +595,3 @@\n-                if (v3) {\n-                    LdapClient.encodeControls(ber, reqCtls);\n-                }\n+            if (v3) {\n+                LdapClient.encodeControls(ber, reqCtls);\n+            }\n@@ -603,1 +602,1 @@\n-                    0, ber.getDataLen());\n+                        0, ber.getDataLen());\n@@ -619,2 +618,2 @@\n-     * @param reqCtls Possibly null request controls that accompanies the\n-     *    abandon and unbind LDAP request.\n+     * @param reqCtls      Possibly null request controls that accompanies the\n+     *                     abandon and unbind LDAP request.\n@@ -622,5 +621,5 @@\n-     *    it that the connection has been closed; false means not to notify\n-     *    parent. If LdapClient invokes cleanup(), notifyParent should be set to\n-     *    false because LdapClient already knows that it is closing\n-     *    the connection. If Connection invokes cleanup(), notifyParent should be\n-     *    set to true because LdapClient needs to know about the closure.\n+     *                     it that the connection has been closed; false means not to notify\n+     *                     parent. If LdapClient invokes cleanup(), notifyParent should be set to\n+     *                     false because LdapClient already knows that it is closing\n+     *                     the connection. If Connection invokes cleanup(), notifyParent should be\n+     *                     set to true because LdapClient needs to know about the closure.\n@@ -649,1 +648,1 @@\n-                    closeOpenedSocket();\n+                    closeOpenedSocket(sock);\n@@ -676,2 +675,1 @@\n-                        ldr = ldr.next;\n-                    }\n+                    ldr = ldr.next;\n@@ -680,0 +678,1 @@\n+        }\n@@ -702,1 +701,1 @@\n-    private void closeOpenedSocket() {\n+    private void closeOpenedSocket(Socket socket) {\n@@ -704,1 +703,2 @@\n-            sock.close();\n+            if (socket != null && !socket.isClosed())\n+                socket.close();\n@@ -832,1 +832,1 @@\n-                                        inStream);\n+                            inStream);\n@@ -840,1 +840,1 @@\n-     \/*\n+    \/*\n@@ -848,1 +848,1 @@\n-                                inStream);\n+                    inStream);\n@@ -929,2 +929,2 @@\n-                            br = in.read(inbuf, offset+bytesread,\n-                                seqlenlen-bytesread);\n+                            br = in.read(inbuf, offset + bytesread,\n+                                    seqlenlen - bytesread);\n@@ -944,2 +944,2 @@\n-                        for( int i = 0; i < seqlenlen; i++) {\n-                            seqlen = (seqlen << 8) + (inbuf[offset+i] & 0xff);\n+                        for (int i = 0; i < seqlenlen; i++) {\n+                            seqlen = (seqlen << 8) + (inbuf[offset + i] & 0xff);\n@@ -1029,1 +1029,1 @@\n-                    + in);\n+                        + in);\n@@ -1045,2 +1045,1 @@\n-        throws IOException\n-    {\n+            throws IOException {\n@@ -1090,1 +1089,1 @@\n-        throws SaslException {\n+            throws SaslException {\n@@ -1106,0 +1105,1 @@\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":186,"deletions":186,"binary":false,"changes":372,"status":"modified"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import javax.naming.Context;\n+import javax.naming.ldap.InitialLdapContext;\n+import javax.naming.ldap.LdapContext;\n+import javax.net.SocketFactory;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.util.Hashtable;\n+\n+\/*\n+ * @test\n+ * @bug 8314063\n+ * @library \/test\/lib\n+ * @summary For LDAPs connection, if the value of com.sun.jndi.ldap.connect.timeout is\n+ * set too small or not an optimal value for the system, after the socket is created and\n+ * connected to the server, but the handshake between the client and server fails due to\n+ * socket time out, the opened socket is not closed properly. In this test case, the server\n+ * is forced to sleep ten seconds and connection time out for client is one second. This\n+ * will allow the socket opened and connected, and give the chance for the handshake to be\n+ * timed out. Before this fix, the socket is kept opened. Right now the exception will be\n+ * caught and the socket will be closed.\n+ *\n+ * @run main\/othervm LdapSSLHandshakeFailureTest LdapSSLHandshakeFailureTest$CustomSocketFactory true\n+ * @run main\/othervm LdapSSLHandshakeFailureTest -1000 true\n+ * @run main\/othervm LdapSSLHandshakeFailureTest -1000 false\n+ * @run main\/othervm LdapSSLHandshakeFailureTest 2000 false\n+ * @run main\/othervm LdapSSLHandshakeFailureTest 0 true\n+ * @run main\/othervm LdapSSLHandshakeFailureTest 0 false\n+ * @run main\/othervm LdapSSLHandshakeFailureTest true\n+ * @run main\/othervm LdapSSLHandshakeFailureTest false\n+ *\/\n+\n+public class LdapSSLHandshakeFailureTest {\n+    private static String SOCKET_CLOSED_MSG = \"The socket has been closed.\";\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        \/\/ Set the keystores\n+        setKeyStore();\n+        boolean serverSlowDown = Boolean.valueOf(args[0]);\n+        if (args.length == 2) {\n+            serverSlowDown = Boolean.valueOf(args[1]);\n+        }\n+\n+        boolean hasCustomSocketFactory = args[0]\n+                .equals(\"LdapSSLHandshakeFailureTest$CustomSocketFactory\");\n+        \/\/ start the test server first.\n+        try (TestServer server = new TestServer(serverSlowDown)) {\n+            server.start();\n+            Hashtable<String, Object> env = new Hashtable<>();\n+            env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+            env.put(\"java.naming.ldap.version\", \"3\");\n+            env.put(Context.PROVIDER_URL, URIBuilder.newBuilder()\n+                    .scheme(\"ldaps\")\n+                    .loopback()\n+                    .port(server.getPortNumber())\n+                    .buildUnchecked().toString());\n+\n+            if (hasCustomSocketFactory) {\n+                env.put(\"java.naming.ldap.factory.socket\", args[0]);\n+                env.put(\"com.sun.jndi.ldap.connect.timeout\", \"1000\");\n+            }\n+\n+            if (args.length == 2 && !hasCustomSocketFactory) {\n+                env.put(\"com.sun.jndi.ldap.connect.timeout\", args[0]);\n+            }\n+\n+            env.put(Context.SECURITY_PROTOCOL, \"ssl\");\n+            env.put(Context.SECURITY_AUTHENTICATION, \"Simple\");\n+            env.put(Context.SECURITY_PRINCIPAL, \"cn=principal\");\n+            env.put(Context.SECURITY_CREDENTIALS, \"123456\");\n+            LdapContext ctx = null;\n+            try {\n+                ctx = new InitialLdapContext(env, null);\n+            } catch (Exception e) {\n+                if (CustomSocketFactory.customSocket.closeMethodCalledCount() > 0\n+                        && hasCustomSocketFactory\n+                        && Boolean.valueOf(args[1])) {\n+                    System.out.println(SOCKET_CLOSED_MSG);\n+                } else {\n+                    throw e;\n+                }\n+            } finally {\n+                if (ctx != null)\n+                    ctx.close();\n+            }\n+        }\n+    }\n+\n+    public static class CustomSocketFactory extends SocketFactory {\n+        private static CustomSocket customSocket;\n+\n+        public static CustomSocketFactory getDefault() {\n+            return new CustomSocketFactory();\n+        }\n+\n+        @Override\n+        public Socket createSocket() throws SocketException {\n+            customSocket = new CustomSocket();\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(String s, int timeout) {\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(String host, int port, InetAddress localHost,\n+                                   int localPort) {\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(InetAddress host, int port) {\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(InetAddress address, int port,\n+                                   InetAddress localAddress, int localPort) {\n+            return customSocket;\n+        }\n+    }\n+\n+    private static class CustomSocket extends Socket {\n+        private int closeMethodCalled = 0;\n+\n+        public CustomSocket() {\n+            closeMethodCalled = 0;\n+        }\n+\n+        public int closeMethodCalledCount() {\n+            return closeMethodCalled;\n+        }\n+\n+        @Override\n+        public void close() throws java.io.IOException {\n+            closeMethodCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    private static void setKeyStore() {\n+\n+        String fileName = \"ksWithSAN\", dir = System.getProperty(\"test.src\", \".\") + File.separator;\n+\n+        System.setProperty(\"javax.net.ssl.keyStore\", dir + fileName);\n+        System.setProperty(\"javax.net.ssl.keyStorePassword\", \"welcome1\");\n+        System.setProperty(\"javax.net.ssl.trustStore\", dir + fileName);\n+        System.setProperty(\"javax.net.ssl.trustStorePassword\", \"welcome1\");\n+    }\n+\n+    static class TestServer extends Thread implements AutoCloseable {\n+        private boolean isForceToSleep;\n+        private final ServerSocket serverSocket;\n+        private final int PORT;\n+\n+        TestServer(boolean isForceToSleep) {\n+            this.isForceToSleep = isForceToSleep;\n+            try {\n+                SSLServerSocketFactory socketFactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n+                serverSocket = socketFactory.createServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+                PORT = serverSocket.getLocalPort();\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            setDaemon(true);\n+        }\n+\n+        public int getPortNumber() {\n+            return PORT;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try (Socket socket = serverSocket.accept();\n+                 InputStream in = socket.getInputStream();\n+                 OutputStream out = socket.getOutputStream()) {\n+                if (isForceToSleep) {\n+                    Thread.sleep(5000);\n+                }\n+                byte[] bindResponse = {0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,\n+                        0x01, 0x00, 0x04, 0x00, 0x04, 0x00};\n+                \/\/ read the bindRequest\n+                while (in.read() != -1) {\n+                    in.skip(in.available());\n+                    break;\n+                }\n+                out.write(bindResponse);\n+                out.flush();\n+                \/\/ ignore the further requests\n+                while (in.read() != -1) {\n+                    in.skip(in.available());\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+            }\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapSSLHandshakeFailureTest.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"filename":"test\/jdk\/com\/sun\/jndi\/ldap\/ksWithSAN","binary":true,"status":"added"}]}