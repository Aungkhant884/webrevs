{"files":[{"patch":"@@ -28,0 +28,12 @@\n+import javax.naming.CommunicationException;\n+import javax.naming.InterruptedNamingException;\n+import javax.naming.NamingException;\n+import javax.naming.ServiceUnavailableException;\n+import javax.naming.ldap.Control;\n+import javax.net.SocketFactory;\n+import javax.net.ssl.HandshakeCompletedEvent;\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSocket;\n+import javax.security.sasl.SaslException;\n@@ -30,1 +42,0 @@\n-import java.io.InterruptedIOException;\n@@ -32,1 +43,0 @@\n-import java.io.OutputStream;\n@@ -34,0 +44,4 @@\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -36,11 +50,0 @@\n-import javax.net.ssl.SSLSocket;\n-\n-import javax.naming.CommunicationException;\n-import javax.naming.ServiceUnavailableException;\n-import javax.naming.NamingException;\n-import javax.naming.InterruptedNamingException;\n-\n-import javax.naming.ldap.Control;\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.InvocationTargetException;\n@@ -54,6 +57,0 @@\n-import javax.net.SocketFactory;\n-import javax.net.ssl.SSLParameters;\n-import javax.net.ssl.HandshakeCompletedEvent;\n-import javax.net.ssl.HandshakeCompletedListener;\n-import javax.net.ssl.SSLPeerUnverifiedException;\n-import javax.security.sasl.SaslException;\n@@ -62,58 +59,58 @@\n-  * A thread that creates a connection to an LDAP server.\n-  * After the connection, the thread reads from the connection.\n-  * A caller can invoke methods on the instance to read LDAP responses\n-  * and to send LDAP requests.\n-  * <p>\n-  * There is a one-to-one correspondence between an LdapClient and\n-  * a Connection. Access to Connection and its methods is only via\n-  * LdapClient with two exceptions: SASL authentication and StartTLS.\n-  * SASL needs to access Connection's socket IO streams (in order to do encryption\n-  * of the security layer). StartTLS needs to do replace IO streams\n-  * and close the IO  streams on nonfatal close. The code for SASL\n-  * authentication can be treated as being the same as from LdapClient\n-  * because the SASL code is only ever called from LdapClient, from\n-  * inside LdapClient's synchronized authenticate() method. StartTLS is called\n-  * directly by the application but should only occur when the underlying\n-  * connection is quiet.\n-  * <p>\n-  * In terms of synchronization, worry about data structures\n-  * used by the Connection thread because that usage might contend\n-  * with calls by the main threads (i.e., those that call LdapClient).\n-  * Main threads need to worry about contention with each other.\n-  * Fields that Connection thread uses:\n-  *     inStream - synced access and update; initialized in constructor;\n-  *           referenced outside class unsync'ed (by LdapSasl) only\n-  *           when connection is quiet\n-  *     traceFile, traceTagIn, traceTagOut - no sync; debugging only\n-  *     parent - no sync; initialized in constructor; no updates\n-  *     pendingRequests - sync\n-  *     pauseLock - per-instance lock;\n-  *     paused - sync via pauseLock (pauseReader())\n-  * Members used by main threads (LdapClient):\n-  *     host, port - unsync; read-only access for StartTLS and debug messages\n-  *     setBound(), setV3() - no sync; called only by LdapClient.authenticate(),\n-  *             which is a sync method called only when connection is \"quiet\"\n-  *     getMsgId() - sync\n-  *     writeRequest(), removeRequest(),findRequest(), abandonOutstandingReqs() -\n-  *             access to shared pendingRequests is sync\n-  *     writeRequest(),  abandonRequest(), ldapUnbind() - access to outStream sync\n-  *     cleanup() - sync\n-  *     readReply() - access to sock sync\n-  *     unpauseReader() - (indirectly via writeRequest) sync on pauseLock\n-  * Members used by SASL auth (main thread):\n-  *     inStream, outStream - no sync; used to construct new stream; accessed\n-  *             only when conn is \"quiet\" and not shared\n-  *     replaceStreams() - sync method\n-  * Members used by StartTLS:\n-  *     inStream, outStream - no sync; used to record the existing streams;\n-  *             accessed only when conn is \"quiet\" and not shared\n-  *     replaceStreams() - sync method\n-  * <p>\n-  * Handles anonymous, simple, and SASL bind for v3; anonymous and simple\n-  * for v2.\n-  * %%% made public for access by LdapSasl %%%\n-  *\n-  * @author Vincent Ryan\n-  * @author Rosanna Lee\n-  * @author Jagane Sundar\n-  *\/\n+ * A thread that creates a connection to an LDAP server.\n+ * After the connection, the thread reads from the connection.\n+ * A caller can invoke methods on the instance to read LDAP responses\n+ * and to send LDAP requests.\n+ * <p>\n+ * There is a one-to-one correspondence between an LdapClient and\n+ * a Connection. Access to Connection and its methods is only via\n+ * LdapClient with two exceptions: SASL authentication and StartTLS.\n+ * SASL needs to access Connection's socket IO streams (in order to do encryption\n+ * of the security layer). StartTLS needs to do replace IO streams\n+ * and close the IO  streams on nonfatal close. The code for SASL\n+ * authentication can be treated as being the same as from LdapClient\n+ * because the SASL code is only ever called from LdapClient, from\n+ * inside LdapClient's synchronized authenticate() method. StartTLS is called\n+ * directly by the application but should only occur when the underlying\n+ * connection is quiet.\n+ * <p>\n+ * In terms of synchronization, worry about data structures\n+ * used by the Connection thread because that usage might contend\n+ * with calls by the main threads (i.e., those that call LdapClient).\n+ * Main threads need to worry about contention with each other.\n+ * Fields that Connection thread uses:\n+ * inStream - synced access and update; initialized in constructor;\n+ * referenced outside class unsync'ed (by LdapSasl) only\n+ * when connection is quiet\n+ * traceFile, traceTagIn, traceTagOut - no sync; debugging only\n+ * parent - no sync; initialized in constructor; no updates\n+ * pendingRequests - sync\n+ * pauseLock - per-instance lock;\n+ * paused - sync via pauseLock (pauseReader())\n+ * Members used by main threads (LdapClient):\n+ * host, port - unsync; read-only access for StartTLS and debug messages\n+ * setBound(), setV3() - no sync; called only by LdapClient.authenticate(),\n+ * which is a sync method called only when connection is \"quiet\"\n+ * getMsgId() - sync\n+ * writeRequest(), removeRequest(),findRequest(), abandonOutstandingReqs() -\n+ * access to shared pendingRequests is sync\n+ * writeRequest(),  abandonRequest(), ldapUnbind() - access to outStream sync\n+ * cleanup() - sync\n+ * readReply() - access to sock sync\n+ * unpauseReader() - (indirectly via writeRequest) sync on pauseLock\n+ * Members used by SASL auth (main thread):\n+ * inStream, outStream - no sync; used to construct new stream; accessed\n+ * only when conn is \"quiet\" and not shared\n+ * replaceStreams() - sync method\n+ * Members used by StartTLS:\n+ * inStream, outStream - no sync; used to record the existing streams;\n+ * accessed only when conn is \"quiet\" and not shared\n+ * replaceStreams() - sync method\n+ * <p>\n+ * Handles anonymous, simple, and SASL bind for v3; anonymous and simple\n+ * for v2.\n+ * %%% made public for access by LdapSasl %%%\n+ *\n+ * @author Vincent Ryan\n+ * @author Rosanna Lee\n+ * @author Jagane Sundar\n+ *\/\n@@ -131,1 +128,1 @@\n-                         \/\/ used by StartTlsResponse when creating an SSL socket\n+    \/\/ used by StartTlsResponse when creating an SSL socket\n@@ -133,1 +130,1 @@\n-                         \/\/ used by StartTlsResponse when creating an SSL socket\n+    \/\/ used by StartTlsResponse when creating an SSL socket\n@@ -192,0 +189,1 @@\n+\n@@ -214,1 +212,1 @@\n-        int connectTimeout, int readTimeout, OutputStream trace) throws NamingException {\n+               int connectTimeout, int readTimeout, OutputStream trace) throws NamingException {\n@@ -246,1 +244,1 @@\n-                new CommunicationException(host + \":\" + port);\n+                    new CommunicationException(host + \":\" + port);\n@@ -254,1 +252,1 @@\n-                new CommunicationException(host + \":\" + port);\n+                    new CommunicationException(host + \":\" + port);\n@@ -268,1 +266,1 @@\n-            return new InetSocketAddress(host, port);\n+        return new InetSocketAddress(host, port);\n@@ -283,1 +281,6 @@\n-        Socket socket = null;\n+        SocketFactory factory = getSocketFactory(socketFactory);\n+        assert factory != null;\n+        \/\/create the socket with default socket factory or custom factory\n+        Socket socket = createConnectionSocket(host, port, factory, connectTimeout);\n+\n+        \/\/ the handshake for SSL connection with server and reset timeout for the socket\n@@ -285,8 +288,0 @@\n-            if (socketFactory != null) {\n-                \/\/ create a connected socket with factory\n-                socket = createConnectionSocket(host, port, socketFactory, connectTimeout);\n-            } else {\n-                \/\/ create a connected socket without factory\n-                socket = createConnectionSocket(host, port, connectTimeout);\n-            }\n-            \/\/the handshake for SSL connection with server and reset timeout for the socket\n@@ -303,10 +298,3 @@\n-    \/\/ create a connected socket without factory\n-    private Socket createConnectionSocket(String host, int port, int connectTimeout) throws Exception {\n-\n-        Socket socket = null;\n-        if (connectTimeout > 0) {\n-\n-            InetSocketAddress endpoint = createInetSocketAddress(host, port);\n-            socket = new Socket();\n-\n-            socket.connect(endpoint, connectTimeout);\n+    \/\/ get the socket factory, either default or custom\n+    private SocketFactory getSocketFactory(String socketFactoryName) throws Exception {\n+        if (socketFactoryName == null) {\n@@ -314,2 +302,1 @@\n-                System.err.println(\"Connection: creating socket with \" +\n-                        \"a timeout\");\n+                System.err.println(\"Connection: using default SocketFactory\");\n@@ -317,6 +304,2 @@\n-        }\n-\n-        \/\/ continue (but ignore connectTimeout)\n-        if (socket == null) {\n-            \/\/ connected socket\n-            socket = new Socket(host, port);\n+            return SocketFactory.getDefault();\n+        } else {\n@@ -324,1 +307,1 @@\n-                System.err.println(\"Connection: creating socket\");\n+                System.err.println(\"Connection: loading supplied SocketFactory: \" + socketFactoryName);\n@@ -326,0 +309,7 @@\n+            @SuppressWarnings(\"unchecked\")\n+            Class<? extends SocketFactory> socketFactoryClass =\n+                    (Class<? extends SocketFactory>) Obj.helper.loadClass(socketFactoryName);\n+            Method getDefault =\n+                    socketFactoryClass.getMethod(\"getDefault\");\n+            SocketFactory factory = (SocketFactory) getDefault.invoke(null, new Object[]{});\n+            return factory;\n@@ -327,1 +317,0 @@\n-        return socket;\n@@ -330,2 +319,1 @@\n-    \/\/ create a connected socket with factory\n-    private Socket createConnectionSocket(String host, int port, String socketFactory,\n+    private Socket createConnectionSocket(String host, int port, SocketFactory factory,\n@@ -333,6 +321,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        Class<? extends SocketFactory> socketFactoryClass =\n-                (Class<? extends SocketFactory>) Obj.helper.loadClass(socketFactory);\n-        Method getDefault =\n-                socketFactoryClass.getMethod(\"getDefault\", new Class<?>[]{});\n-        SocketFactory factory = (SocketFactory) getDefault.invoke(null, new Object[]{});\n@@ -341,1 +323,0 @@\n-        \/\/ create the socket\n@@ -343,0 +324,2 @@\n+            \/\/ create unconnected socket and then connect it if timeout\n+            \/\/ is supplied\n@@ -347,1 +330,1 @@\n-            \/\/ connected socket\n+            \/\/ connect socket with a timeout\n@@ -351,1 +334,1 @@\n-                        \"a timeout using supplied socket factory\");\n+                        \"a connect timeout\");\n@@ -353,9 +336,7 @@\n-        } else {\n-            \/\/ continue (but ignore connectTimeout)\n-            if (socket == null) {\n-                \/\/ connected socket\n-                socket = factory.createSocket(host, port);\n-                if (debug) {\n-                    System.err.println(\"Connection: creating socket using \" +\n-                            \"supplied socket factory\");\n-                }\n+        }\n+        if (socket == null) {\n+            \/\/ create connected socket\n+            socket = factory.createSocket(host, port);\n+            if (debug) {\n+                System.err.println(\"Connection: creating connected socket with\" +\n+                        \" no connect timeout\");\n@@ -371,1 +352,1 @@\n-    private void initialSSLHandshake(Socket socket , int connectTimeout) throws Exception {\n+    private void initialSSLHandshake(Socket socket, int connectTimeout) throws Exception {\n@@ -405,1 +386,1 @@\n-        boolean pauseAfterReceipt) throws IOException {\n+                             boolean pauseAfterReceipt) throws IOException {\n@@ -410,1 +391,1 @@\n-        boolean pauseAfterReceipt, int replyQueueCapacity) throws IOException {\n+                             boolean pauseAfterReceipt, int replyQueueCapacity) throws IOException {\n@@ -413,1 +394,1 @@\n-            new LdapRequest(msgId, pauseAfterReceipt, replyQueueCapacity);\n+                new LdapRequest(msgId, pauseAfterReceipt, replyQueueCapacity);\n@@ -453,1 +434,1 @@\n-                    \"; socket closed\");\n+                        \"; socket closed\");\n@@ -465,1 +446,1 @@\n-                \"Interrupted during LDAP operation\");\n+                    \"Interrupted during LDAP operation\");\n@@ -556,2 +537,2 @@\n-                ber.encodeInt(abandonMsgId);\n-                ber.encodeInt(ldr.msgId, LdapClient.LDAP_REQ_ABANDON);\n+            ber.encodeInt(abandonMsgId);\n+            ber.encodeInt(ldr.msgId, LdapClient.LDAP_REQ_ABANDON);\n@@ -559,3 +540,3 @@\n-                if (v3) {\n-                    LdapClient.encodeControls(ber, reqCtls);\n-                }\n+            if (v3) {\n+                LdapClient.encodeControls(ber, reqCtls);\n+            }\n@@ -566,1 +547,1 @@\n-                    ber.getDataLen());\n+                        ber.getDataLen());\n@@ -609,4 +590,4 @@\n-                ber.encodeInt(unbindMsgId);\n-                \/\/ IMPLICIT TAGS\n-                ber.encodeByte(LdapClient.LDAP_REQ_UNBIND);\n-                ber.encodeByte(0);\n+            ber.encodeInt(unbindMsgId);\n+            \/\/ IMPLICIT TAGS\n+            ber.encodeByte(LdapClient.LDAP_REQ_UNBIND);\n+            ber.encodeByte(0);\n@@ -614,3 +595,3 @@\n-                if (v3) {\n-                    LdapClient.encodeControls(ber, reqCtls);\n-                }\n+            if (v3) {\n+                LdapClient.encodeControls(ber, reqCtls);\n+            }\n@@ -621,1 +602,1 @@\n-                    0, ber.getDataLen());\n+                        0, ber.getDataLen());\n@@ -637,2 +618,2 @@\n-     * @param reqCtls Possibly null request controls that accompanies the\n-     *    abandon and unbind LDAP request.\n+     * @param reqCtls      Possibly null request controls that accompanies the\n+     *                     abandon and unbind LDAP request.\n@@ -640,5 +621,5 @@\n-     *    it that the connection has been closed; false means not to notify\n-     *    parent. If LdapClient invokes cleanup(), notifyParent should be set to\n-     *    false because LdapClient already knows that it is closing\n-     *    the connection. If Connection invokes cleanup(), notifyParent should be\n-     *    set to true because LdapClient needs to know about the closure.\n+     *                     it that the connection has been closed; false means not to notify\n+     *                     parent. If LdapClient invokes cleanup(), notifyParent should be set to\n+     *                     false because LdapClient already knows that it is closing\n+     *                     the connection. If Connection invokes cleanup(), notifyParent should be\n+     *                     set to true because LdapClient needs to know about the closure.\n@@ -694,2 +675,1 @@\n-                        ldr = ldr.next;\n-                    }\n+                    ldr = ldr.next;\n@@ -698,0 +678,1 @@\n+        }\n@@ -851,1 +832,1 @@\n-                                        inStream);\n+                            inStream);\n@@ -859,1 +840,1 @@\n-     \/*\n+    \/*\n@@ -867,1 +848,1 @@\n-                                inStream);\n+                    inStream);\n@@ -948,2 +929,2 @@\n-                            br = in.read(inbuf, offset+bytesread,\n-                                seqlenlen-bytesread);\n+                            br = in.read(inbuf, offset + bytesread,\n+                                    seqlenlen - bytesread);\n@@ -963,2 +944,2 @@\n-                        for( int i = 0; i < seqlenlen; i++) {\n-                            seqlen = (seqlen << 8) + (inbuf[offset+i] & 0xff);\n+                        for (int i = 0; i < seqlenlen; i++) {\n+                            seqlen = (seqlen << 8) + (inbuf[offset + i] & 0xff);\n@@ -1048,1 +1029,1 @@\n-                    + in);\n+                        + in);\n@@ -1064,2 +1045,1 @@\n-        throws IOException\n-    {\n+            throws IOException {\n@@ -1109,1 +1089,1 @@\n-        throws SaslException {\n+            throws SaslException {\n@@ -1125,0 +1105,1 @@\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":153,"deletions":172,"binary":false,"changes":325,"status":"modified"}]}