{"files":[{"patch":"@@ -281,1 +281,1 @@\n-            int connectTimeout) throws Exception {\n+                                int connectTimeout) throws Exception {\n@@ -284,0 +284,2 @@\n+        try {\n+            if (socketFactory != null) {\n@@ -285,1 +287,1 @@\n-        if (socketFactory != null) {\n+                \/\/ create the factory\n@@ -287,1 +289,6 @@\n-            \/\/ create the factory\n+                @SuppressWarnings(\"unchecked\")\n+                Class<? extends SocketFactory> socketFactoryClass =\n+                        (Class<? extends SocketFactory>) Obj.helper.loadClass(socketFactory);\n+                Method getDefault =\n+                        socketFactoryClass.getMethod(\"getDefault\", new Class<?>[]{});\n+                SocketFactory factory = (SocketFactory) getDefault.invoke(null, new Object[]{});\n@@ -289,6 +296,1 @@\n-            @SuppressWarnings(\"unchecked\")\n-            Class<? extends SocketFactory> socketFactoryClass =\n-                (Class<? extends SocketFactory>)Obj.helper.loadClass(socketFactory);\n-            Method getDefault =\n-                socketFactoryClass.getMethod(\"getDefault\", new Class<?>[]{});\n-            SocketFactory factory = (SocketFactory) getDefault.invoke(null, new Object[]{});\n+                \/\/ create the socket\n@@ -296,1 +298,1 @@\n-            \/\/ create the socket\n+                if (connectTimeout > 0) {\n@@ -298,1 +300,2 @@\n-            if (connectTimeout > 0) {\n+                    InetSocketAddress endpoint =\n+                            createInetSocketAddress(host, port);\n@@ -300,2 +303,2 @@\n-                InetSocketAddress endpoint =\n-                        createInetSocketAddress(host, port);\n+                    \/\/ unconnected socket\n+                    socket = factory.createSocket();\n@@ -303,2 +306,4 @@\n-                \/\/ unconnected socket\n-                socket = factory.createSocket();\n+                    if (debug) {\n+                        System.err.println(\"Connection: creating socket with \" +\n+                                \"a timeout using supplied socket factory\");\n+                    }\n@@ -306,3 +311,2 @@\n-                if (debug) {\n-                    System.err.println(\"Connection: creating socket with \" +\n-                            \"a timeout using supplied socket factory\");\n+                    \/\/ connected socket\n+                    socket.connect(endpoint, connectTimeout);\n@@ -311,9 +315,8 @@\n-                \/\/ connected socket\n-                socket.connect(endpoint, connectTimeout);\n-            }\n-\n-            \/\/ continue (but ignore connectTimeout)\n-            if (socket == null) {\n-                if (debug) {\n-                    System.err.println(\"Connection: creating socket using \" +\n-                        \"supplied socket factory\");\n+                \/\/ continue (but ignore connectTimeout)\n+                if (socket == null) {\n+                    if (debug) {\n+                        System.err.println(\"Connection: creating socket using \" +\n+                                \"supplied socket factory\");\n+                    }\n+                    \/\/ connected socket\n+                    socket = factory.createSocket(host, port);\n@@ -321,4 +324,1 @@\n-                \/\/ connected socket\n-                socket = factory.createSocket(host, port);\n-            }\n-        } else {\n+            } else {\n@@ -326,1 +326,1 @@\n-            if (connectTimeout > 0) {\n+                if (connectTimeout > 0) {\n@@ -334,1 +334,1 @@\n-                            \"a timeout\");\n+                                \"a timeout\");\n@@ -337,1 +337,1 @@\n-            }\n+                }\n@@ -339,1 +339,1 @@\n-            \/\/ continue (but ignore connectTimeout)\n+                \/\/ continue (but ignore connectTimeout)\n@@ -341,3 +341,6 @@\n-            if (socket == null) {\n-                if (debug) {\n-                    System.err.println(\"Connection: creating socket\");\n+                if (socket == null) {\n+                    if (debug) {\n+                        System.err.println(\"Connection: creating socket\");\n+                    }\n+                    \/\/ connected socket\n+                    socket = new Socket(host, port);\n@@ -345,2 +348,0 @@\n-                \/\/ connected socket\n-                socket = new Socket(host, port);\n@@ -348,1 +349,0 @@\n-        }\n@@ -350,10 +350,18 @@\n-        \/\/ For LDAP connect timeouts on LDAP over SSL connections must treat\n-        \/\/ the SSL handshake following socket connection as part of the timeout.\n-        \/\/ So explicitly set a socket read timeout, trigger the SSL handshake,\n-        \/\/ then reset the timeout.\n-        if (socket instanceof SSLSocket) {\n-            SSLSocket sslSocket = (SSLSocket) socket;\n-            if (!IS_HOSTNAME_VERIFICATION_DISABLED) {\n-                SSLParameters param = sslSocket.getSSLParameters();\n-                param.setEndpointIdentificationAlgorithm(\"LDAPS\");\n-                sslSocket.setSSLParameters(param);\n+            \/\/ For LDAP connect timeouts on LDAP over SSL connections must treat\n+            \/\/ the SSL handshake following socket connection as part of the timeout.\n+            \/\/ So explicitly set a socket read timeout, trigger the SSL handshake,\n+            \/\/ then reset the timeout.\n+            if (socket instanceof SSLSocket) {\n+                SSLSocket sslSocket = (SSLSocket) socket;\n+                if (!IS_HOSTNAME_VERIFICATION_DISABLED) {\n+                    SSLParameters param = sslSocket.getSSLParameters();\n+                    param.setEndpointIdentificationAlgorithm(\"LDAPS\");\n+                    sslSocket.setSSLParameters(param);\n+                }\n+                setHandshakeCompletedListener(sslSocket);\n+                if (connectTimeout > 0) {\n+                    int socketTimeout = sslSocket.getSoTimeout();\n+                    sslSocket.setSoTimeout(connectTimeout); \/\/ reuse full timeout value\n+                    sslSocket.startHandshake();\n+                    sslSocket.setSoTimeout(socketTimeout);\n+                }\n@@ -361,6 +369,4 @@\n-            setHandshakeCompletedListener(sslSocket);\n-            if (connectTimeout > 0) {\n-                int socketTimeout = sslSocket.getSoTimeout();\n-                sslSocket.setSoTimeout(connectTimeout); \/\/ reuse full timeout value\n-                sslSocket.startHandshake();\n-                sslSocket.setSoTimeout(socketTimeout);\n+        } catch (Exception e) {\n+            \/\/ 8314063 the socket is not closed after the failure of handshake\n+            if (socket != null && !socket.isClosed()) {\n+                socket.close();\n@@ -368,0 +374,1 @@\n+            throw e;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":64,"deletions":57,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import javax.net.SocketFactory;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.naming.ldap.InitialLdapContext;\n+import javax.naming.ldap.LdapContext;\n+import javax.naming.Context;\n+import java.util.Hashtable;\n+\n+\/*\n+ * @test\n+ * @bug 8314063\n+ * @library \/test\/lib\n+ * @summary For LDAPs connection, if the value of com.sun.jndi.ldap.connect.timeout is\n+ * set too small or not an optimal value for the system, after the socket is created and\n+ * connected to the server, but the handshake between the client and server fails due to\n+ * socket time out, the opened socket is not closed properly. In this test case, the server\n+ * is forced to sleep ten seconds and connection time out for client is one second. This\n+ * will allow the socket opened and connected, and give the chance for the handshake to be\n+ * timed out. Before this fix, the socket is kept opened. Right now the exception will be\n+ * caught and the socket will be closed.\n+ *\n+ * @run main\/othervm LdapSSLHandshakeFailureTest\n+ *\/\n+\n+public class LdapSSLHandshakeFailureTest {\n+    private static String url;\n+    private static String SOCKET_CLOSED_MSG = \"The socket has been closed.\";\n+    private static String SOCKET_NOT_CLOSED_MSG = \"The socket was not closed.\";\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ Set the keystores\n+        setKeyStore();\n+        \/\/ start the test server first.\n+        TestServer server = new TestServer();\n+        server.start();\n+        url = \"ldaps:\/\/localhost:\" + server.getPortNumber();\n+        Hashtable<String, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(Context.PROVIDER_URL, url);\n+        env.put(\"java.naming.ldap.factory.socket\", CustomSocketFactory.class.getName());\n+        env.put(\"java.naming.ldap.version\", \"3\");\n+        env.put(\"com.sun.jndi.ldap.connect.timeout\", \"1000\");\n+        env.put(Context.SECURITY_AUTHENTICATION, \"Simple\");\n+        env.put(Context.SECURITY_PRINCIPAL, \"cn=principal\");\n+        env.put(Context.SECURITY_CREDENTIALS, \"justpassword\");\n+        try {\n+            LdapContext ctx = new InitialLdapContext(env, null);\n+            ctx.close();\n+        } catch (Exception e) {\n+            if (CustomSocketFactory.customSocket.closeMethodCalledCount() > 0) {\n+                System.out.println(SOCKET_CLOSED_MSG);\n+            } else {\n+                System.out.println(SOCKET_NOT_CLOSED_MSG);\n+                throw e;\n+            }\n+        }\n+    }\n+    public static class CustomSocketFactory extends SocketFactory {\n+        public static CustomSocket customSocket = new CustomSocket();\n+\n+        public static CustomSocketFactory getDefault() {\n+            return new CustomSocketFactory();\n+        }\n+\n+        @Override\n+        public Socket createSocket() {\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(String s, int timeout) {\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(String host, int port, InetAddress localHost,\n+                                   int localPort) {\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(InetAddress host, int port) {\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(InetAddress address, int port,\n+                                   InetAddress localAddress, int localPort) {\n+            return customSocket;\n+        }\n+    }\n+\n+    private static class CustomSocket extends Socket {\n+        private int closeMethodCalled = 0;\n+\n+        public int closeMethodCalledCount() {\n+            return closeMethodCalled;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            closeMethodCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    private static void setKeyStore() {\n+        String dir = System.getProperty(\"test.src\", \".\") + File.separator;\n+        System.setProperty(\"javax.net.ssl.keyStore\", dir + \"ksWithSAN\");\n+        System.setProperty(\"javax.net.ssl.keyStorePassword\", \"welcome1\");\n+        System.setProperty(\"javax.net.ssl.trustStore\", dir + \"ksWithSAN\");\n+        System.setProperty(\"javax.net.ssl.trustStorePassword\", \"welcome1\");\n+    }\n+\n+    static class TestServer extends Thread implements AutoCloseable {\n+\n+        private final ServerSocket serverSocket;\n+        private final int PORT;\n+        private volatile boolean exceptionThrown;\n+\n+        TestServer() throws IOException {\n+            try {\n+                SSLServerSocketFactory socketFactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n+                serverSocket = socketFactory.createServerSocket(0);\n+                PORT = serverSocket.getLocalPort();\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            setDaemon(true);\n+        }\n+\n+        public int getPortNumber() {\n+            return PORT;\n+        }\n+\n+        public boolean isExceptionThrown() {\n+            return exceptionThrown;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try (Socket socket = serverSocket.accept()) {\n+                Thread.sleep(10000);\n+                try (InputStream in = socket.getInputStream()) {\n+                    try (OutputStream out = socket.getOutputStream()) {\n+\n+                        byte[] bindResponse = {0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A, 0x01, 0x00, 0x04, 0x00, 0x04, 0x00};\n+                        \/\/ read the bindRequest\n+                        while (in.read() != -1) {\n+                            in.skip(in.available());\n+                            break;\n+                        }\n+                        out.write(bindResponse);\n+                        out.flush();\n+                        \/\/ ignore the further requests\n+                        while (in.read() != -1) {\n+                            in.skip(in.available());\n+                        }\n+                    }\n+                }\n+            } catch (Exception expectedException) {\n+                if (expectedException instanceof SSLHandshakeException) {\n+                    exceptionThrown = Boolean.TRUE;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+            }\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapSSLHandshakeFailureTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"filename":"test\/jdk\/com\/sun\/jndi\/ldap\/ksWithSAN","binary":true,"status":"added"}]}