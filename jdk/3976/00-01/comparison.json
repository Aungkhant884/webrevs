{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -187,1 +188,2 @@\n-        synchronized (getNativeLibraryLock(name)) {\n+        acquireNativeLibraryLock(name);\n+        try {\n@@ -199,0 +201,3 @@\n+        } finally {\n+            releaseNativeLibraryLock(name);\n+        }\n@@ -200,22 +205,18 @@\n-            \/*\n-             * When a library is being loaded, JNI_OnLoad function can cause\n-             * another loadLibrary invocation that should succeed.\n-             *\n-             * We use a static thread-local stack to hold the list of libraries we are\n-             * loading, so that {@code getFromClass()} method would report\n-             * the correct {@code fromClass} to the calling JNI_OnLoad\/JNI_OnUnload.\n-             * Since the stack is thread-local, each thread maintains its own stack.\n-             *\n-             * If there is a pending load operation for the library, we\n-             * immediately return success to avoid infinite recursion;\n-             * if the pending load is from a different class loader,\n-             * we raise UnsatisfiedLinkError.\n-             *\/\n-            for (NativeLibraryImpl lib : nativeLibraryContext()) {\n-                if (name.equals(lib.name())) {\n-                    if (loader == lib.fromClass.getClassLoader()) {\n-                        return lib;\n-                    } else {\n-                        throw new UnsatisfiedLinkError(\"Native Library \" +\n-                                name + \" is being loaded in another classloader\");\n-                    }\n+        \/*\n+         * When a library is being loaded, JNI_OnLoad function can cause\n+         * another loadLibrary invocation that should succeed.\n+         *\n+         * We use a static stack to hold the list of libraries we are\n+         * loading, so that each thread maintains its own stack.\n+         *\n+         * If there is a pending load operation for the library, we\n+         * immediately return success; if the pending load is from\n+         * a different class loader, we raise UnsatisfiedLinkError.\n+         *\/\n+        for (NativeLibraryImpl lib : NativeLibraryContext.get()) {\n+            if (name.equals(lib.name())) {\n+                if (loader == lib.fromClass.getClassLoader()) {\n+                    return lib;\n+                } else {\n+                    throw new UnsatisfiedLinkError(\"Native Library \" +\n+                            name + \" is being loaded in another classloader\");\n@@ -224,0 +225,1 @@\n+        }\n@@ -225,22 +227,9 @@\n-            NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, isJNI);\n-            \/\/ load the native library\n-            nativeLibraryContext().push(lib);\n-            try {\n-                if (!lib.open()) {\n-                    return null;    \/\/ fail to open the native library\n-                }\n-                \/\/ auto unloading is only supported for JNI native libraries\n-                \/\/ loaded by custom class loaders that can be unloaded.\n-                \/\/ built-in class loaders are never unloaded.\n-                boolean autoUnload = isJNI && !VM.isSystemDomainLoader(loader)\n-                        && loader != ClassLoaders.appClassLoader();\n-                if (autoUnload) {\n-                    \/\/ register the loaded native library for auto unloading\n-                    \/\/ when the class loader is reclaimed, all native libraries\n-                    \/\/ loaded that class loader will be unloaded.\n-                    \/\/ The entries in the libraries map are not removed since\n-                    \/\/ the entire map will be reclaimed altogether.\n-                    CleanerFactory.cleaner().register(loader, lib.unloader());\n-                }\n-            } finally {\n-                nativeLibraryContext().pop();\n+        NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, isJNI);\n+        \/\/ load the native library\n+        NativeLibraryContext.push(lib);\n+        try {\n+            \/\/ this code can be executed in multiple threads,\n+            \/\/ every initialized NativeLibrary object will be registered\n+            \/\/ for auto unloading\n+            if (!lib.open()) {\n+                return null;    \/\/ fail to open the native library\n@@ -248,0 +237,19 @@\n+            \/\/ auto unloading is only supported for JNI native libraries\n+            \/\/ loaded by custom class loaders that can be unloaded.\n+            \/\/ built-in class loaders are never unloaded.\n+            boolean autoUnload = isJNI && !VM.isSystemDomainLoader(loader)\n+                    && loader != ClassLoaders.appClassLoader();\n+            if (autoUnload) {\n+                \/\/ register the loaded native library for auto unloading\n+                \/\/ when the class loader is reclaimed, all native libraries\n+                \/\/ loaded that class loader will be unloaded.\n+                \/\/ The entries in the libraries map are not removed since\n+                \/\/ the entire map will be reclaimed altogether.\n+                CleanerFactory.cleaner().register(loader, lib.unloader());\n+            }\n+        } finally {\n+            NativeLibraryContext.pop();\n+        }\n+\n+        acquireNativeLibraryLock(name);\n+        try {\n@@ -250,1 +258,1 @@\n-            libraries.put(name, lib);\n+            libraries.putIfAbsent(name, lib);\n@@ -252,0 +260,2 @@\n+        } finally {\n+            releaseNativeLibraryLock(name);\n@@ -299,2 +309,4 @@\n-        synchronized (getNativeLibraryLock(lib.name())) {\n-            NativeLibraryImpl nl = libraries.remove(lib.name());\n+        acquireNativeLibraryLock(lib.name());\n+        NativeLibraryImpl nl = null;\n+        try {\n+            nl = libraries.remove(lib.name());\n@@ -305,0 +317,7 @@\n+            if (!loadedLibraryNames.remove(lib.name())) {\n+                throw new IllegalStateException(lib.name() + \" has already been unloaded\");\n+            }\n+        } finally {\n+            releaseNativeLibraryLock(lib.name());\n+        }\n+        if (nl != null) {\n@@ -433,11 +452,7 @@\n-            synchronized (getNativeLibraryLock(name)) {\n-                \/* remove the native library name *\/\n-                if (!loadedLibraryNames.remove(name)) {\n-                    throw new IllegalStateException(name + \" has already been unloaded\");\n-                }\n-                nativeLibraryContext().push(UNLOADER);\n-                try {\n-                    unload(name, isBuiltin, isJNI, handle);\n-                } finally {\n-                    nativeLibraryContext().pop();\n-                }\n+            \/* remove the native library name *\/\n+            loadedLibraryNames.remove(name);\n+            NativeLibraryContext.push(UNLOADER);\n+            try {\n+                unload(name, isBuiltin, isJNI, handle);\n+            } finally {\n+                NativeLibraryContext.pop();\n@@ -464,0 +479,21 @@\n+    \/\/ reentrant lock class that allows exact counting (with external synchronization)\n+    @SuppressWarnings(\"serial\")\n+    private static final class CountedLock extends ReentrantLock {\n+\n+        private int counter = 0;\n+\n+        public void increment() {\n+            if (++counter < 0) \/\/ overflow\n+                throw new Error(\"Maximum lock count exceeded\");\n+        }\n+\n+        public void decrement() {\n+            if (--counter < 0) \/\/ underflow\n+                throw new Error(\"Lock count is below zero\");\n+        }\n+\n+        public int getCounter() {\n+            return counter;\n+        }\n+    }\n+\n@@ -465,1 +501,1 @@\n-    private static final Map<String, Object> nativeLibraryLockMap =\n+    private static final Map<String, CountedLock> nativeLibraryLockMap =\n@@ -468,7 +504,9 @@\n-    private static Object getNativeLibraryLock(String libraryName) {\n-        Object newLock = new Object();\n-        Object lock = nativeLibraryLockMap.putIfAbsent(libraryName, newLock);\n-        if (lock == null) {\n-            lock = newLock;\n-        }\n-        return lock;\n+    private static void acquireNativeLibraryLock(String libraryName) {\n+        nativeLibraryLockMap.compute(libraryName, (name, lock) -> {\n+            if (lock == null) {\n+                lock = new CountedLock();\n+            }\n+            \/\/ safe as compute lambda is executed atomically\n+            lock.increment();\n+            return lock;\n+        }).lock();\n@@ -477,8 +515,16 @@\n-    \/\/ thread local native libraries stack\n-    private static final ThreadLocal<Deque<NativeLibraryImpl>> nativeLibraryThreadContext =\n-            new ThreadLocal<Deque<NativeLibraryImpl>>() {\n-                @Override\n-                protected Deque<NativeLibraryImpl> initialValue() {\n-                    return new ArrayDeque<>(8);\n-                }\n-            };\n+    private static void releaseNativeLibraryLock(String libraryName) {\n+        CountedLock lock = nativeLibraryLockMap.computeIfPresent(libraryName, (name, currentLock) -> {\n+            if (currentLock.getCounter() == 1) {\n+                \/\/ unlock and release the object if no other threads are queued\n+                currentLock.unlock();\n+                \/\/ remove the element\n+                return null;\n+            } else {\n+                currentLock.decrement();\n+                return currentLock;\n+            }\n+        });\n+        if (lock != null) {\n+            lock.unlock();\n+        }\n+    }\n@@ -487,2 +533,37 @@\n-    private static Deque<NativeLibraryImpl> nativeLibraryContext() {\n-        return nativeLibraryThreadContext.get();\n+    private static final class NativeLibraryContext {\n+\n+        \/\/ Maps thread object to the native library context stack, maintained by each thread\n+        private static Map<Thread, Deque<NativeLibraryImpl>> nativeLibraryThreadContext =\n+                new ConcurrentHashMap<>();\n+\n+        \/\/ returns a context associated with the current thread\n+        private static Deque<NativeLibraryImpl> get() {\n+            return nativeLibraryThreadContext.computeIfAbsent(\n+                    Thread.currentThread(),\n+                    t -> new ArrayDeque<>(8));\n+        }\n+\n+        private static NativeLibraryImpl peek() {\n+            return get().peek();\n+        }\n+\n+        private static void push(NativeLibraryImpl lib) {\n+            get().push(lib);\n+        }\n+\n+        private static void pop() {\n+            \/\/ this does not require synchronization since each\n+            \/\/ thread has its own context\n+            Deque<NativeLibraryImpl> libs = get();\n+            libs.pop();\n+            if (libs.isEmpty()) {\n+                \/\/ context can be safely removed once empty\n+                nativeLibraryThreadContext.remove(Thread.currentThread());\n+            }\n+        }\n+\n+        private static boolean isEmpty() {\n+            Deque<NativeLibraryImpl> context =\n+                    nativeLibraryThreadContext.get(Thread.currentThread());\n+            return (context == null || context.isEmpty());\n+        }\n@@ -494,1 +575,1 @@\n-        if (nativeLibraryContext().isEmpty()) { \/\/ only default library\n+        if (NativeLibraryContext.isEmpty()) { \/\/ only default library\n@@ -497,1 +578,1 @@\n-        return nativeLibraryContext().peek().fromClass;\n+        return NativeLibraryContext.peek().fromClass;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":160,"deletions":79,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.io.File;\n-\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/Class1.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.security.*;\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/LoadLibraryDeadlock.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -86,1 +85,1 @@\n-        List<String> commands = new ArrayList<String>();\n+        List<String> commands = new ArrayList<>();\n@@ -103,1 +102,1 @@\n-        List<String> commands = new ArrayList<String>();\n+        List<String> commands = new ArrayList<>();\n@@ -148,0 +147,13 @@\n+    private final static long countLines(OutputAnalyzer output, String string) {\n+        return output.asLines()\n+                     .stream()\n+                     .filter(s -> s.contains(string))\n+                     .count();\n+    }\n+\n+    private final static void dump(OutputAnalyzer output) {\n+        output.asLines()\n+              .stream()\n+              .forEach(s -> System.out.println(s));\n+    }\n+\n@@ -186,3 +198,1 @@\n-        outputAnalyzer\n-                .asLines().stream()\n-                .forEach(s -> System.out.println(s));\n+        dump(outputAnalyzer);\n@@ -192,8 +202,4 @@\n-        outputAnalyzerJcmd\n-                .asLines().stream()\n-                .forEach(s -> System.out.println(s));\n-\n-        Asserts.assertTrue(outputAnalyzerJcmd\n-                .asLines().stream()\n-                .filter(s -> s.contains(\"Java-level deadlock\"))\n-                .count() == 0,\n+        dump(outputAnalyzerJcmd);\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Java-level deadlock\") == 0,\n@@ -203,4 +209,2 @@\n-        Asserts.assertTrue(outputAnalyzer\n-                .asLines().stream()\n-                .filter(s -> s.contains(\"Class Class1 not found.\"))\n-                .count() == 0,\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Class Class1 not found.\") == 0,\n@@ -209,4 +213,2 @@\n-        Asserts.assertTrue(outputAnalyzer\n-                .asLines().stream()\n-                .filter(s -> s.contains(\"Class Class2 not found.\"))\n-                .count() == 0,\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Class Class2 not found.\") == 0,\n@@ -215,4 +217,2 @@\n-        Asserts.assertTrue(outputAnalyzer\n-                .asLines().stream()\n-                .filter(s -> s.contains(\"Native library loaded.\"))\n-                .count() > 0,\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library loaded.\") > 0,\n@@ -221,4 +221,2 @@\n-        Asserts.assertTrue(outputAnalyzer\n-                .asLines().stream()\n-                .filter(s -> s.contains(\"Signed jar loaded.\"))\n-                .count() > 0,\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Signed jar loaded.\") > 0,\n@@ -227,4 +225,2 @@\n-        Asserts.assertTrue(outputAnalyzer\n-                .asLines().stream()\n-                .filter(s -> s.contains(\"Signed jar loaded from native library.\"))\n-                .count() > 0,\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Signed jar loaded from native library.\") > 0,\n@@ -234,1 +230,1 @@\n-            \/\/ if process is still frozen, fail the test even though\n+            \/\/ if the process is still frozen, fail the test even though\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/TestLoadLibraryDeadlock.java","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * JNI library that loads an arbitrary class from a (signed) jar.\n- * This triggers the search in jars, and the lock in ZipFile is being acquired\n+ * Native library that loads an arbitrary class from a (signed) jar.\n+ * This triggers the search in jars, and the lock in ZipFile is acquired\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/libloadLibraryDeadlock.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * LoadLibraryUnload class calls ClassLoader.loadedLibrary from multiple threads\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8266310\n+ * @summary deadlock while loading the JNI code\n+ * @library \/test\/lib\n+ * @build LoadLibraryUnload p.Class1\n+ * @run main\/othervm\/native -Xcheck:jni LoadLibraryUnload\n+ *\/\n+import jdk.test.lib.Asserts;\n+import java.lang.*;\n+import java.lang.reflect.*;\n+import java.lang.ref.WeakReference;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import p.Class1;\n+\n+public class LoadLibraryUnload {\n+\n+    private static class TestLoader extends URLClassLoader {\n+        public TestLoader() throws Exception {\n+            super(new URL[] { Path.of(System.getProperty(\"test.classes\")).toUri().toURL() });\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            synchronized (getClassLoadingLock(name)) {\n+                Class clazz = findLoadedClass(name);\n+                if (clazz == null) {\n+                    try {\n+                        clazz = findClass(name);\n+                    } catch (ClassNotFoundException ignore) {\n+                    }\n+                    if (clazz == null) {\n+                        clazz = super.loadClass(name);\n+                    }\n+                }\n+                return clazz;\n+            }\n+        }\n+    }\n+    \n+    private static class LoadLibraryFromClass implements Runnable {\n+        Object object;\n+        Method method;\n+\n+        public LoadLibraryFromClass(Class<?> fromClass) {\n+            try {\n+                this.object = fromClass.newInstance();\n+                this.method = fromClass.getDeclaredMethod(\"loadLibrary\");\n+            } catch (Exception error) {\n+                throw new Error(error);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                method.invoke(object);\n+            } catch (Exception error) {\n+                throw new Error(error);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        URLClassLoader loader = new TestLoader();\n+        Class<?> class1 = loader.loadClass(\"p.Class1\");\n+        List<Thread> threads = new ArrayList<>();\n+\n+        for (int i = 0 ; i < 10 ; i++) {\n+            threads.add(new Thread(new LoadLibraryFromClass(class1)));\n+        }\n+        threads.forEach( t -> {\n+            t.start();\n+        });\n+\n+        \/\/ wait for all threads to finish\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+        WeakReference<Class> wClass = new WeakReference<>(class1);\n+\n+        \/\/ release strong refs\n+        class1 = null;\n+        loader = null;\n+        threads = null;\n+        waitForUnload(wClass);\n+        Asserts.assertTrue(wClass.get() == null, \"Class1 hasn't been GC'ed\");\n+    }\n+\n+    private static void waitForUnload(WeakReference<Class> wClass)\n+            throws InterruptedException {\n+        for (int i = 0; i < 100 && wClass.get() != null; ++i) {\n+            System.gc();\n+            Thread.sleep(1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnload.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * LoadLibraryUnloadTest ensures all objects (NativeLibrary) are deallocated\n+ * when loaded in concurrent mode.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8266310\n+ * @summary deadlock while loading the JNI code\n+ * @library \/test\/lib\n+ * @build LoadLibraryUnload p.Class1\n+ * @run main\/othervm\/native -Xcheck:jni LoadLibraryUnloadTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.*;\n+\n+import java.lang.ProcessBuilder;\n+import java.lang.Process;\n+import java.io.File;\n+import java.util.*;\n+\n+public class LoadLibraryUnloadTest {\n+\n+    private static String testClassPath = System.getProperty(\"test.classes\");\n+    private static String testLibraryPath = System.getProperty(\"test.nativepath\");\n+    private static String classPathSeparator = System.getProperty(\"path.separator\");\n+\n+    private static Process runJavaCommand(String... command) throws Throwable {\n+        String java = JDKToolFinder.getJDKTool(\"java\");\n+        List<String> commands = new ArrayList<>();\n+        Collections.addAll(commands, java);\n+        Collections.addAll(commands, command);\n+        System.out.println(\"COMMAND: \" + String.join(\" \", commands));\n+        return new ProcessBuilder(commands.toArray(new String[0]))\n+                .redirectErrorStream(true)\n+                .directory(new File(testClassPath))\n+                .start();\n+    }\n+\n+    private final static long countLines(OutputAnalyzer output, String string) {\n+        return output.asLines()\n+                     .stream()\n+                     .filter(s -> s.contains(string))\n+                     .count();\n+    }\n+\n+    private final static void dump(OutputAnalyzer output) {\n+        output.asLines()\n+              .stream()\n+              .forEach(s -> System.out.println(s));\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        Process process = runJavaCommand(\n+                \"-Dtest.classes=\" + testClassPath,\n+                \"-Djava.library.path=\" + testLibraryPath,\n+                \"LoadLibraryUnload\");\n+\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+        dump(outputAnalyzer);\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library loaded from Class1.\") > 1,\n+                \"Unable to load Class1.\");\n+\n+        long refCount = countLines(outputAnalyzer, \"Native library loaded.\");\n+\n+        Asserts.assertTrue(\n+                refCount > 0,\n+                \"Failed to load native library.\");\n+\n+        System.out.println(\"Native library loaded in \" + refCount + \" threads\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library unloaded.\") == refCount,\n+                \"Failed to unload native library\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnloadTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved)\n+{\n+    JNIEnv *env;\n+\n+    printf(\"Native library loaded.\\n\");\n+    fflush(stdout);\n+\n+    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK) {\n+        return JNI_EVERSION; \/* JNI version not supported *\/\n+    }\n+\n+    return JNI_VERSION_1_2;\n+}\n+\n+JNIEXPORT void JNICALL\n+JNI_OnUnload(JavaVM *vm, void *reserved) {\n+\n+    printf(\"Native library unloaded.\\n\");\n+    fflush(stdout);\n+}\n+\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/libloadLibraryUnload.c","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Class1 loads a native library.\n+ *\/\n+package p;\n+\n+public class Class1 {\n+\n+    public Class1() {\n+    }\n+\n+    \/\/ method called from java threads\n+    public void loadLibrary() throws Exception {\n+        try {\n+            System.loadLibrary(\"loadLibraryUnload\");\n+            System.out.println(\"Native library loaded from Class1.\");\n+        } catch (Exception ignore) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/p\/Class1.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}