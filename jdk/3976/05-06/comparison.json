{"files":[{"patch":"@@ -206,2 +206,2 @@\n-             * We use a static stack to hold the list of libraries we are\n-             * loading, so that each thread maintains its own stack.\n+             * Each thread maintains its own stack to hold the list of\n+             * libraries it is loading.\n@@ -213,1 +213,1 @@\n-            for (NativeLibraryImpl lib : NativeLibraryContext.get()) {\n+            for (NativeLibraryImpl lib : NativeLibraryContext.current()) {\n@@ -534,1 +534,1 @@\n-        private static Deque<NativeLibraryImpl> get() {\n+        private static Deque<NativeLibraryImpl> current() {\n@@ -541,1 +541,1 @@\n-            return get().peek();\n+            return current().peek();\n@@ -545,1 +545,1 @@\n-            get().push(lib);\n+            current().push(lib);\n@@ -551,1 +551,1 @@\n-            Deque<NativeLibraryImpl> libs = get();\n+            Deque<NativeLibraryImpl> libs = current();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                         IllegalAccessException ignore) {\n+                         IllegalAccessException e) {\n@@ -50,0 +50,1 @@\n+                    throw new RuntimeException(e);\n@@ -59,1 +60,1 @@\n-                } catch (ClassNotFoundException ignore) {\n+                } catch (ClassNotFoundException e) {\n@@ -61,0 +62,1 @@\n+                    throw new RuntimeException(e);\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/LoadLibraryDeadlock.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n- * @summary deadlock while loading the JNI code\n+ * @summary Checks if there's no deadlock between the two lock objects -\n+ *          class loading lock and ClassLoader.loadedLibraryNames hashmap.\n@@ -37,0 +38,1 @@\n+import jdk.test.lib.util.FileUtils;\n@@ -40,0 +42,1 @@\n+import java.nio.file.Paths;\n@@ -69,1 +72,2 @@\n-        runCommandInTestClassPath(\"rm\", \"-f\", KEYSTORE);\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, KEYSTORE));\n@@ -164,2 +168,6 @@\n-        runCommandInTestClassPath(\"rm\", \"-f\", \"*.jar\")\n-                .shouldHaveExitValue(0);\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"a.jar\"));\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"b.jar\"));\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"c.jar\"));\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/TestLoadLibraryDeadlock.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,1 +31,7 @@\n- * @summary deadlock while loading the JNI code\n+ * @summary Loads a native library from multiple class loaders and multiple\n+ *          threads. This creates a race for loading the library. The winner\n+ *          loads the library in two threads. All threads except two would fail\n+ *          with UnsatisfiedLinkError when the class being loaded is already\n+ *          loaded in a different class loader that won the race. The test\n+ *          checks that the loaded class is GC'ed, that means the class loader\n+ *          is GC'ed and the native library is unloaded.\n@@ -37,0 +43,1 @@\n+import jdk.test.lib.util.ForceGC;\n@@ -83,2 +90,2 @@\n-            } catch (Exception error) {\n-                throw new Error(error);\n+            } catch (ReflectiveOperationException roe) {\n+                throw new RuntimeException(roe);\n@@ -92,2 +99,2 @@\n-            } catch (Exception error) {\n-                throw new Error(error);\n+            } catch (ReflectiveOperationException roe) {\n+                throw new RuntimeException(roe);\n@@ -148,9 +155,3 @@\n-        waitForUnload(wClass);\n-        Asserts.assertTrue(wClass.get() == null, \"Class1 hasn't been GC'ed\");\n-    }\n-\n-    private static void waitForUnload(WeakReference<Class> wClass)\n-            throws InterruptedException {\n-        for (int i = 0; i < 100 && wClass.get() != null; ++i) {\n-            System.gc();\n-            Thread.sleep(1);\n+        ForceGC gc = new ForceGC();\n+        if (!gc.await(() -> wClass.refersTo(null))) {\n+            throw new RuntimeException(\"Class1 hasn't been GC'ed\");\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnload.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @summary deadlock while loading the JNI code\n+ * @summary Checks that JNI_OnLoad is invoked only once when multiple threads\n+ *          call System.loadLibrary concurrently, and JNI_OnUnload is invoked\n+ *          when the native library is loaded from a custom class loader.\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnloadTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}