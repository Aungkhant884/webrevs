{"files":[{"patch":"@@ -201,3 +201,0 @@\n-        } finally {\n-            releaseNativeLibraryLock(name);\n-        }\n@@ -205,18 +202,19 @@\n-        \/*\n-         * When a library is being loaded, JNI_OnLoad function can cause\n-         * another loadLibrary invocation that should succeed.\n-         *\n-         * We use a static stack to hold the list of libraries we are\n-         * loading, so that each thread maintains its own stack.\n-         *\n-         * If there is a pending load operation for the library, we\n-         * immediately return success; if the pending load is from\n-         * a different class loader, we raise UnsatisfiedLinkError.\n-         *\/\n-        for (NativeLibraryImpl lib : NativeLibraryContext.get()) {\n-            if (name.equals(lib.name())) {\n-                if (loader == lib.fromClass.getClassLoader()) {\n-                    return lib;\n-                } else {\n-                    throw new UnsatisfiedLinkError(\"Native Library \" +\n-                            name + \" is being loaded in another classloader\");\n+            \/*\n+             * When a library is being loaded, JNI_OnLoad function can cause\n+             * another loadLibrary invocation that should succeed.\n+             *\n+             * We use a static stack to hold the list of libraries we are\n+             * loading, so that each thread maintains its own stack.\n+             *\n+             * If there is a pending load operation for the library, we\n+             * immediately return success; if the pending load is from\n+             * a different class loader, we raise UnsatisfiedLinkError.\n+             *\/\n+            for (NativeLibraryImpl lib : NativeLibraryContext.get()) {\n+                if (name.equals(lib.name())) {\n+                    if (loader == lib.fromClass.getClassLoader()) {\n+                        return lib;\n+                    } else {\n+                        throw new UnsatisfiedLinkError(\"Native Library \" +\n+                                name + \" is being loaded in another classloader\");\n+                    }\n@@ -225,1 +223,0 @@\n-        }\n@@ -227,22 +224,22 @@\n-        NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, isJNI);\n-        \/\/ load the native library\n-        NativeLibraryContext.push(lib);\n-        try {\n-            \/\/ this code can be executed in multiple threads,\n-            \/\/ every initialized NativeLibrary object will be registered\n-            \/\/ for auto unloading\n-            if (!lib.open()) {\n-                return null;    \/\/ fail to open the native library\n-            }\n-            \/\/ auto unloading is only supported for JNI native libraries\n-            \/\/ loaded by custom class loaders that can be unloaded.\n-            \/\/ built-in class loaders are never unloaded.\n-            boolean autoUnload = isJNI && !VM.isSystemDomainLoader(loader)\n-                    && loader != ClassLoaders.appClassLoader();\n-            if (autoUnload) {\n-                \/\/ register the loaded native library for auto unloading\n-                \/\/ when the class loader is reclaimed, all native libraries\n-                \/\/ loaded that class loader will be unloaded.\n-                \/\/ The entries in the libraries map are not removed since\n-                \/\/ the entire map will be reclaimed altogether.\n-                CleanerFactory.cleaner().register(loader, lib.unloader());\n+            NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, isJNI);\n+            \/\/ load the native library\n+            NativeLibraryContext.push(lib);\n+            try {\n+                if (!lib.open()) {\n+                    return null;    \/\/ fail to open the native library\n+                }\n+                \/\/ auto unloading is only supported for JNI native libraries\n+                \/\/ loaded by custom class loaders that can be unloaded.\n+                \/\/ built-in class loaders are never unloaded.\n+                boolean autoUnload = isJNI && !VM.isSystemDomainLoader(loader)\n+                        && loader != ClassLoaders.appClassLoader();\n+                if (autoUnload) {\n+                    \/\/ register the loaded native library for auto unloading\n+                    \/\/ when the class loader is reclaimed, all native libraries\n+                    \/\/ loaded that class loader will be unloaded.\n+                    \/\/ The entries in the libraries map are not removed since\n+                    \/\/ the entire map will be reclaimed altogether.\n+                    CleanerFactory.cleaner().register(loader, lib.unloader());\n+                }\n+            } finally {\n+                NativeLibraryContext.pop();\n@@ -250,6 +247,0 @@\n-        } finally {\n-            NativeLibraryContext.pop();\n-        }\n-\n-        acquireNativeLibraryLock(name);\n-        try {\n@@ -258,1 +249,1 @@\n-            libraries.putIfAbsent(name, lib);\n+            libraries.put(name, lib);\n@@ -310,1 +301,0 @@\n-        NativeLibraryImpl nl = null;\n@@ -312,1 +302,1 @@\n-            nl = libraries.remove(lib.name());\n+            NativeLibraryImpl nl = libraries.remove(lib.name());\n@@ -317,3 +307,1 @@\n-            if (!loadedLibraryNames.remove(lib.name())) {\n-                throw new IllegalStateException(lib.name() + \" has already been unloaded\");\n-            }\n+            nl.unloader().run();\n@@ -323,3 +311,0 @@\n-        if (nl != null) {\n-            nl.unloader().run();\n-        }\n@@ -452,3 +437,1 @@\n-            \/* remove the native library name *\/\n-            loadedLibraryNames.remove(name);\n-            NativeLibraryContext.push(UNLOADER);\n+            acquireNativeLibraryLock(name);\n@@ -456,1 +439,10 @@\n-                unload(name, isBuiltin, isJNI, handle);\n+                \/* remove the native library name *\/\n+                if (!loadedLibraryNames.remove(name)) {\n+                    throw new IllegalStateException(name + \" has already been unloaded\");\n+                }\n+                NativeLibraryContext.push(UNLOADER);\n+                try {\n+                    unload(name, isBuiltin, isJNI, handle);\n+                } finally {\n+                    NativeLibraryContext.pop();\n+                }\n@@ -458,1 +450,1 @@\n-                NativeLibraryContext.pop();\n+                releaseNativeLibraryLock(name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":56,"deletions":64,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -98,2 +100,1 @@\n-        URLClassLoader loader = new TestLoader();\n-        Class<?> class1 = loader.loadClass(\"p.Class1\");\n+        Class<?> clazz = null;\n@@ -102,2 +103,6 @@\n-        for (int i = 0 ; i < 10 ; i++) {\n-            threads.add(new Thread(new LoadLibraryFromClass(class1)));\n+        for (int i = 0 ; i < 5 ; i++) {\n+            \/\/ 5 loaders and 10 threads in total.\n+            \/\/ winner loads the library in 2 threads\n+            clazz = new TestLoader().loadClass(\"p.Class1\");\n+            threads.add(new Thread(new LoadLibraryFromClass(clazz)));\n+            threads.add(new Thread(new LoadLibraryFromClass(clazz)));\n@@ -105,0 +110,2 @@\n+\n+        final Set<Throwable> exceptions = ConcurrentHashMap.newKeySet();\n@@ -106,0 +113,8 @@\n+            t.setUncaughtExceptionHandler((th, ex) -> {\n+                \/\/ collect the root cause of each failure\n+                Throwable rootCause = ex;\n+                while((ex = ex.getCause()) != null) {\n+                    rootCause = ex;\n+                }\n+                exceptions.add(rootCause);\n+            });\n@@ -113,1 +128,15 @@\n-        WeakReference<Class> wClass = new WeakReference<>(class1);\n+\n+        \/\/ expect all errors to be UnsatisfiedLinkError \n+        boolean allAreUnsatisfiedLinkError = exceptions\n+                .stream()\n+                .map(e -> e instanceof UnsatisfiedLinkError)\n+                .reduce(true, (i, a) -> i && a);\n+\n+        \/\/ expect exactly 8 errors\n+        Asserts.assertTrue(exceptions.size() == 8,\n+                \"Expected to see 8 failing threads\");\n+\n+        Asserts.assertTrue(allAreUnsatisfiedLinkError,\n+                \"All errors have to be UnsatisfiedLinkError\");\n+\n+        WeakReference<Class> wClass = new WeakReference<>(clazz);\n@@ -116,2 +145,1 @@\n-        class1 = null;\n-        loader = null;\n+        clazz = null;\n@@ -119,0 +147,1 @@\n+        exceptions.clear();\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnload.java","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-                countLines(outputAnalyzer, \"Native library loaded from Class1.\") > 1,\n-                \"Unable to load Class1.\");\n+                countLines(outputAnalyzer, \"Native library loaded from Class1.\") == 2,\n+                \"Native library expected to be loaded in 2 threads.\");\n@@ -94,3 +94,1 @@\n-        Asserts.assertTrue(\n-                refCount > 0,\n-                \"Failed to load native library.\");\n+        Asserts.assertTrue(refCount > 0, \"Failed to load native library.\");\n@@ -100,0 +98,2 @@\n+        Asserts.assertTrue(refCount == 1, \"Native library is loaded more than once.\");\n+\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnloadTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}