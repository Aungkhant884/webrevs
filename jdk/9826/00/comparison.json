{"files":[{"patch":"@@ -2050,1 +2050,1 @@\n-  int slots_of_int_registers = RegisterImpl::max_slots_per_register * RegisterImpl::number_of_registers;\n+  int slots_of_int_registers = Register::number_of_registers * Register::max_slots_per_register;\n@@ -2057,1 +2057,1 @@\n-  int slots_of_float_registers = FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers;\n+  int slots_of_float_registers = FloatRegister::number_of_registers * FloatRegister::max_slots_per_register;\n@@ -2062,1 +2062,1 @@\n-  int slots_of_predicate_registers = PRegisterImpl::max_slots_per_register * PRegisterImpl::number_of_registers;\n+  int slots_of_predicate_registers = PRegister::number_of_registers * PRegister::max_slots_per_register;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,17 +65,17 @@\n-REGISTER_DECLARATION(Register, c_rarg0, r0);\n-REGISTER_DECLARATION(Register, c_rarg1, r1);\n-REGISTER_DECLARATION(Register, c_rarg2, r2);\n-REGISTER_DECLARATION(Register, c_rarg3, r3);\n-REGISTER_DECLARATION(Register, c_rarg4, r4);\n-REGISTER_DECLARATION(Register, c_rarg5, r5);\n-REGISTER_DECLARATION(Register, c_rarg6, r6);\n-REGISTER_DECLARATION(Register, c_rarg7, r7);\n-\n-REGISTER_DECLARATION(FloatRegister, c_farg0, v0);\n-REGISTER_DECLARATION(FloatRegister, c_farg1, v1);\n-REGISTER_DECLARATION(FloatRegister, c_farg2, v2);\n-REGISTER_DECLARATION(FloatRegister, c_farg3, v3);\n-REGISTER_DECLARATION(FloatRegister, c_farg4, v4);\n-REGISTER_DECLARATION(FloatRegister, c_farg5, v5);\n-REGISTER_DECLARATION(FloatRegister, c_farg6, v6);\n-REGISTER_DECLARATION(FloatRegister, c_farg7, v7);\n+constexpr Register c_rarg0 = r0;\n+constexpr Register c_rarg1 = r1;\n+constexpr Register c_rarg2 = r2;\n+constexpr Register c_rarg3 = r3;\n+constexpr Register c_rarg4 = r4;\n+constexpr Register c_rarg5 = r5;\n+constexpr Register c_rarg6 = r6;\n+constexpr Register c_rarg7 = r7;\n+\n+constexpr FloatRegister c_farg0 = v0;\n+constexpr FloatRegister c_farg1 = v1;\n+constexpr FloatRegister c_farg2 = v2;\n+constexpr FloatRegister c_farg3 = v3;\n+constexpr FloatRegister c_farg4 = v4;\n+constexpr FloatRegister c_farg5 = v5;\n+constexpr FloatRegister c_farg6 = v6;\n+constexpr FloatRegister c_farg7 = v7;\n@@ -99,8 +99,8 @@\n-REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);\n-REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);\n-REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);\n-REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);\n-REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);\n-REGISTER_DECLARATION(Register, j_rarg5, c_rarg6);\n-REGISTER_DECLARATION(Register, j_rarg6, c_rarg7);\n-REGISTER_DECLARATION(Register, j_rarg7, c_rarg0);\n+constexpr Register j_rarg0 = c_rarg1;\n+constexpr Register j_rarg1 = c_rarg2;\n+constexpr Register j_rarg2 = c_rarg3;\n+constexpr Register j_rarg3 = c_rarg4;\n+constexpr Register j_rarg4 = c_rarg5;\n+constexpr Register j_rarg5 = c_rarg6;\n+constexpr Register j_rarg6 = c_rarg7;\n+constexpr Register j_rarg7 = c_rarg0;\n@@ -110,8 +110,8 @@\n-REGISTER_DECLARATION(FloatRegister, j_farg0, v0);\n-REGISTER_DECLARATION(FloatRegister, j_farg1, v1);\n-REGISTER_DECLARATION(FloatRegister, j_farg2, v2);\n-REGISTER_DECLARATION(FloatRegister, j_farg3, v3);\n-REGISTER_DECLARATION(FloatRegister, j_farg4, v4);\n-REGISTER_DECLARATION(FloatRegister, j_farg5, v5);\n-REGISTER_DECLARATION(FloatRegister, j_farg6, v6);\n-REGISTER_DECLARATION(FloatRegister, j_farg7, v7);\n+constexpr FloatRegister j_farg0 = v0;\n+constexpr FloatRegister j_farg1 = v1;\n+constexpr FloatRegister j_farg2 = v2;\n+constexpr FloatRegister j_farg3 = v3;\n+constexpr FloatRegister j_farg4 = v4;\n+constexpr FloatRegister j_farg5 = v5;\n+constexpr FloatRegister j_farg6 = v6;\n+constexpr FloatRegister j_farg7 = v7;\n@@ -126,2 +126,2 @@\n-REGISTER_DECLARATION(Register, rscratch1, r8);\n-REGISTER_DECLARATION(Register, rscratch2, r9);\n+constexpr Register rscratch1 = r8;\n+constexpr Register rscratch2 = r9;\n@@ -130,1 +130,1 @@\n-REGISTER_DECLARATION(Register, rmethod,   r12);\n+constexpr Register rmethod = r12;\n@@ -135,22 +135,10 @@\n-\/\/ link register\n-REGISTER_DECLARATION(Register, lr,        r30);\n-\/\/ frame pointer\n-REGISTER_DECLARATION(Register, rfp,       r29);\n-\/\/ current thread\n-REGISTER_DECLARATION(Register, rthread,   r28);\n-\/\/ base of heap\n-REGISTER_DECLARATION(Register, rheapbase, r27);\n-\/\/ constant pool cache\n-REGISTER_DECLARATION(Register, rcpool,    r26);\n-\/\/ r25 is a callee-saved temp\n-\/\/ REGISTER_DECLARATION(Register, unused, r25);\n-\/\/ locals on stack\n-REGISTER_DECLARATION(Register, rlocals,   r24);\n-\/\/ bytecode pointer\n-REGISTER_DECLARATION(Register, rbcp,      r22);\n-\/\/ Dispatch table base\n-REGISTER_DECLARATION(Register, rdispatch, r21);\n-\/\/ Java expression stack pointer\n-REGISTER_DECLARATION(Register, esp,      r20);\n-\/\/ Sender's SP while in interpreter\n-REGISTER_DECLARATION(Register, r19_sender_sp, r19);\n+constexpr Register lr            = r30; \/\/ link register\n+constexpr Register rfp           = r29; \/\/ frame pointer\n+constexpr Register rthread       = r28; \/\/ current thread\n+constexpr Register rheapbase     = r27; \/\/ base of heap\n+constexpr Register rcpool        = r26; \/\/ constant pool cache\n+constexpr Register rlocals       = r24; \/\/ locals on stack\n+constexpr Register rbcp          = r22; \/\/ bytecode pointer\n+constexpr Register rdispatch     = r21; \/\/ dispatch table base\n+constexpr Register esp           = r20; \/\/ Java expression stack pointer\n+constexpr Register r19_sender_sp = r19; \/\/ sender's SP while in interpreter\n@@ -159,1 +147,1 @@\n-REGISTER_DECLARATION(PRegister, ptrue, p7);\n+constexpr PRegister ptrue = p7;\n@@ -280,1 +268,1 @@\n-    f(r->encoding_nocheck(), lsb + 4, lsb);\n+    f(r->raw_encoding(), lsb + 4, lsb);\n@@ -285,1 +273,1 @@\n-    f(r->encoding_nocheck() - (r == zr), lsb + 4, lsb);\n+    f(r->raw_encoding() - (r == zr), lsb + 4, lsb);\n@@ -290,1 +278,1 @@\n-    f(r == sp ? 31 : r->encoding_nocheck(), lsb + 4, lsb);\n+    f(r == sp ? 31 : r->raw_encoding(), lsb + 4, lsb);\n@@ -294,1 +282,1 @@\n-    f(r->encoding_nocheck(), lsb + 4, lsb);\n+    f(r->raw_encoding(), lsb + 4, lsb);\n@@ -298,1 +286,1 @@\n-    f(r->encoding_nocheck(), lsb + 3, lsb);\n+    f(r->raw_encoding(), lsb + 3, lsb);\n@@ -302,1 +290,1 @@\n-    f(r->encoding_nocheck(), lsb + 2, lsb);\n+    f(r->raw_encoding(), lsb + 2, lsb);\n@@ -332,1 +320,1 @@\n-  Post(Register reg, int o) : PrePost(reg, o) { _idx = NULL; _is_postreg = false; }\n+  Post(Register reg, int o) : PrePost(reg, o) { _idx = noreg; _is_postreg = false; }\n@@ -630,2 +618,1 @@\n-const int FPUStateSizeInWords = FloatRegisterImpl::number_of_registers *\n-                                FloatRegisterImpl::save_slots_per_register;\n+const int FPUStateSizeInWords = FloatRegister::number_of_registers * FloatRegister::save_slots_per_register;\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":55,"deletions":68,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-  pd_nof_cpu_regs_frame_map = RegisterImpl::number_of_registers,       \/\/ number of registers used during code emission\n-  pd_nof_fpu_regs_frame_map = FloatRegisterImpl::number_of_registers,  \/\/ number of registers used during code emission\n+  pd_nof_cpu_regs_frame_map = Register::number_of_registers,       \/\/ number of GP registers used during code emission\n+  pd_nof_fpu_regs_frame_map = FloatRegister::number_of_registers,  \/\/ number of FP registers used during code emission\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Defs_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  if (jvmci_reg < RegisterImpl::number_of_registers) {\n+  if (jvmci_reg < Register::number_of_registers) {\n@@ -181,2 +181,2 @@\n-    jint floatRegisterNumber = jvmci_reg - RegisterImpl::number_of_declared_registers;\n-    if (floatRegisterNumber >= 0 && floatRegisterNumber < FloatRegisterImpl::number_of_registers) {\n+    jint floatRegisterNumber = jvmci_reg - Register::number_of_declared_registers;\n+    if (floatRegisterNumber >= 0 && floatRegisterNumber < FloatRegister::number_of_registers) {\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2207,1 +2207,1 @@\n-  regs[count++] = zr->encoding_nocheck();\n+  regs[count++] = zr->raw_encoding();\n@@ -2237,1 +2237,1 @@\n-  regs[count++] = zr->encoding_nocheck();\n+  regs[count++] = zr->raw_encoding();\n@@ -2392,1 +2392,1 @@\n-  unsigned char regs[PRegisterImpl::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_saved_registers];\n@@ -2394,1 +2394,1 @@\n-  for (int reg = 0; reg < PRegisterImpl::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n@@ -2429,1 +2429,1 @@\n-  unsigned char regs[PRegisterImpl::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_saved_registers];\n@@ -2431,1 +2431,1 @@\n-  for (int reg = 0; reg < PRegisterImpl::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n@@ -2919,2 +2919,2 @@\n-    sub(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n-    for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+    sub(sp, sp, sve_vector_size_in_bytes * FloatRegister::number_of_registers);\n+    for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n@@ -2935,1 +2935,1 @@\n-    for (int i = 0; i < PRegisterImpl::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n@@ -2944,1 +2944,1 @@\n-    for (int i = PRegisterImpl::number_of_saved_registers - 1; i >= 0; i--) {\n+    for (int i = PRegister::number_of_saved_registers - 1; i >= 0; i--) {\n@@ -2950,1 +2950,1 @@\n-    for (int i = FloatRegisterImpl::number_of_registers - 1; i >= 0; i--) {\n+    for (int i = FloatRegister::number_of_registers - 1; i >= 0; i--) {\n@@ -2953,1 +2953,1 @@\n-    add(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n+    add(sp, sp, sve_vector_size_in_bytes * FloatRegister::number_of_registers);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    case  2:  aes_round(_data, _subkeys +  0);  break;\n-    case  3:  aes_round(_data, _subkeys +  1);  break;\n+    case  2:  aes_round(_data, as_FloatRegister(_subkeys->encoding() + 0));  break;\n+    case  3:  aes_round(_data, as_FloatRegister(_subkeys->encoding() + 1));  break;\n@@ -239,2 +239,2 @@\n-    case  5:  aes_round(_data, _subkeys +  2);  break;\n-    case  6:  aes_round(_data, _subkeys +  3);  break;\n+    case  5:  aes_round(_data, as_FloatRegister(_subkeys->encoding() + 2));  break;\n+    case  6:  aes_round(_data, as_FloatRegister(_subkeys->encoding() + 3));  break;\n@@ -244,11 +244,11 @@\n-    case  8:  aes_round(_data, _subkeys +  4);  break;\n-    case  9:  aes_round(_data, _subkeys +  5);  break;\n-    case 10:  aes_round(_data, _subkeys +  6);  break;\n-    case 11:  aes_round(_data, _subkeys +  7);  break;\n-    case 12:  aes_round(_data, _subkeys +  8);  break;\n-    case 13:  aes_round(_data, _subkeys +  9);  break;\n-    case 14:  aes_round(_data, _subkeys + 10);  break;\n-    case 15:  aes_round(_data, _subkeys + 11);  break;\n-    case 16:  aes_round(_data, _subkeys + 12);  break;\n-    case 17:  aese(_data, _subkeys + 13);  break;\n-    case 18:  eor(_data, T16B, _data, _subkeys + 14);  break;\n+    case  8:  aes_round(_data, as_FloatRegister(_subkeys->encoding() +  4));  break;\n+    case  9:  aes_round(_data, as_FloatRegister(_subkeys->encoding() +  5));  break;\n+    case 10:  aes_round(_data, as_FloatRegister(_subkeys->encoding() +  6));  break;\n+    case 11:  aes_round(_data, as_FloatRegister(_subkeys->encoding() +  7));  break;\n+    case 12:  aes_round(_data, as_FloatRegister(_subkeys->encoding() +  8));  break;\n+    case 13:  aes_round(_data, as_FloatRegister(_subkeys->encoding() +  9));  break;\n+    case 14:  aes_round(_data, as_FloatRegister(_subkeys->encoding() + 10));  break;\n+    case 15:  aes_round(_data, as_FloatRegister(_subkeys->encoding() + 11));  break;\n+    case 16:  aes_round(_data, as_FloatRegister(_subkeys->encoding() + 12));  break;\n+    case 17:  aese(_data, as_FloatRegister(_subkeys->encoding() + 13));  break;\n+    case 18:  eor(_data, T16B, _data, as_FloatRegister(_subkeys->encoding() + 14));  break;\n@@ -267,1 +267,1 @@\n-                                  _data + 1, _subkeys, \/*once*\/false);\n+                                  _data->successor(), _subkeys, \/*once*\/false);\n@@ -412,8 +412,8 @@\n-  virtual KernelGenerator *next() {\n-    GHASHMultiplyGenerator *result = new GHASHMultiplyGenerator(*this);\n-    result->_result_lo += register_stride;\n-    result->_result_hi += register_stride;\n-    result->_b += register_stride;\n-    result->_tmp1 += register_stride;\n-    result->_tmp2 += register_stride;\n-    result->_tmp3 += register_stride;\n+  virtual KernelGenerator* next() {\n+    GHASHMultiplyGenerator* result = new GHASHMultiplyGenerator(*this);\n+    result->_result_lo = as_FloatRegister(result->_result_lo->encoding() + register_stride);\n+    result->_result_hi = as_FloatRegister(result->_result_hi->encoding() + register_stride);\n+    result->_b         = as_FloatRegister(result->_b        ->encoding() + register_stride);\n+    result->_tmp1      = as_FloatRegister(result->_tmp1     ->encoding() + register_stride);\n+    result->_tmp2      = as_FloatRegister(result->_tmp2     ->encoding() + register_stride);\n+    result->_tmp3      = as_FloatRegister(result->_tmp3     ->encoding() + register_stride);\n@@ -480,1 +480,1 @@\n-        ld1((_data + index*register_stride), T16B, post(r2, 0x10));\n+        ld1(as_FloatRegister(_data->encoding() + index*register_stride), T16B, post(r2, 0x10));\n@@ -487,4 +487,4 @@\n-    result->_result += register_stride;\n-    result->_hi += register_stride;\n-    result->_lo += register_stride;\n-    result->_t1 += register_stride;\n+    result->_result = as_FloatRegister(result->_result->encoding() + register_stride);\n+    result->_hi     = as_FloatRegister(result->_hi    ->encoding() + register_stride);\n+    result->_lo     = as_FloatRegister(result->_lo    ->encoding() + register_stride);\n+    result->_t1     = as_FloatRegister(result->_t1    ->encoding() + register_stride);\n@@ -585,1 +585,2 @@\n-    eor(ofs+v0, T16B, ofs+v0, ofs+v0); \/\/ zero each state register\n+    FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + ofs);\n+    eor(v0_ofs, T16B, v0_ofs, v0_ofs); \/\/ zero each state register\n@@ -593,1 +594,2 @@\n-    ld1(v2+ofs, T16B, post(data, 0x10));\n+    FloatRegister v2_ofs = as_FloatRegister(v2->encoding() + ofs);\n+    ld1(v2_ofs, T16B, post(data, 0x10));\n@@ -626,2 +628,4 @@\n-      rbit((v2+ofs), T16B, (v2+ofs));\n-      eor((v2+ofs), T16B, v0+ofs, (v2+ofs));   \/\/ bit-swapped data ^ bit-swapped state\n+      FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + ofs);\n+      FloatRegister v2_ofs = as_FloatRegister(v2->encoding() + ofs);\n+      rbit(v2_ofs, T16B, v2_ofs);\n+      eor(v2_ofs, T16B, v0_ofs, v2_ofs);   \/\/ bit-swapped data ^ bit-swapped state\n@@ -654,0 +658,7 @@\n+    FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + ofs);\n+    FloatRegister v1_ofs = as_FloatRegister(v1->encoding() + ofs);\n+    FloatRegister v2_ofs = as_FloatRegister(v2->encoding() + ofs);\n+    FloatRegister v3_ofs = as_FloatRegister(v3->encoding() + ofs);\n+    FloatRegister v4_ofs = as_FloatRegister(v4->encoding() + ofs);\n+    FloatRegister v5_ofs = as_FloatRegister(v5->encoding() + ofs);\n+\n@@ -656,2 +667,2 @@\n-    rbit(v2+ofs, T16B, v2+ofs);\n-    eor(v2+ofs, T16B, ofs+v0, v2+ofs);   \/\/ bit-swapped data ^ bit-swapped state\n+    rbit(v2_ofs, T16B, v2_ofs);\n+    eor(v2_ofs, T16B, v0_ofs, v2_ofs);   \/\/ bit-swapped data ^ bit-swapped state\n@@ -663,1 +674,1 @@\n-    ghash_modmul(\/*result*\/v0+ofs, \/*result_lo*\/v5+ofs, \/*result_hi*\/v4+ofs, \/*b*\/v2+ofs,\n+    ghash_modmul(\/*result*\/v0_ofs, \/*result_lo*\/v5_ofs, \/*result_hi*\/v4_ofs, \/*b*\/v2_ofs,\n@@ -665,1 +676,1 @@\n-                 \/*temps*\/v1+ofs, v3+ofs, \/* reuse b*\/v2+ofs);\n+                 \/*temps*\/v1_ofs, v3_ofs, \/* reuse b*\/v2_ofs);\n@@ -669,3 +680,3 @@\n-  for (int i = 0; i < unrolls - 1; i++) {\n-    int ofs = register_stride * i;\n-    eor(v0, T16B, v0, v0 + register_stride + ofs);\n+  for (int i = 1; i < unrolls; i++) {\n+    FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + register_stride * i);\n+    eor(v0, T16B, v0, v0_ofs);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_aes.cpp","additions":51,"deletions":40,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-                       FloatRegisterImpl::max_slots_per_register;\n+                       FloatRegister::max_slots_per_register;\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n-REGISTER_IMPL_DEFINITION(Register, RegisterImpl, RegisterImpl::number_of_declared_registers);\n-REGISTER_IMPL_DEFINITION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(PRegister, PRegisterImpl, PRegisterImpl::number_of_registers);\n+Register::RegisterImpl           all_RegisterImpls     [Register::number_of_declared_registers + 1];\n+FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers     + 1];\n+PRegister::PRegisterImpl         all_PRegisterImpls    [PRegister::number_of_registers         + 1];\n@@ -33,13 +33,3 @@\n-const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers *\n-                                          RegisterImpl::max_slots_per_register;\n-\n-const int ConcreteRegisterImpl::max_fpr\n-  = ConcreteRegisterImpl::max_gpr +\n-    FloatRegisterImpl::number_of_registers * FloatRegisterImpl::max_slots_per_register;\n-\n-const int ConcreteRegisterImpl::max_pr\n-  = ConcreteRegisterImpl::max_fpr +\n-    PRegisterImpl::number_of_registers * PRegisterImpl::max_slots_per_register;\n-\n-const char* RegisterImpl::name() const {\n-  static const char *const names[number_of_registers] = {\n+const char* Register::RegisterImpl::name() const {\n+  static const char *const names[number_of_declared_registers + 1] = {\n+    \"noreg\",\n@@ -49,1 +39,2 @@\n-    \"rlocals\", \"r25\", \"rcpool\", \"rheapbase\", \"rthread\", \"rfp\", \"lr\", \"sp\"\n+    \"rlocals\", \"r25\", \"rcpool\", \"rheapbase\", \"rthread\", \"rfp\", \"lr\", \"r31_sp\",\n+    \"zp\", \"sp\"\n@@ -51,1 +42,1 @@\n-  return is_valid() ? names[encoding()] : \"noreg\";\n+  return names[raw_encoding() + 1];\n@@ -54,1 +45,1 @@\n-const char* FloatRegisterImpl::name() const {\n+const char* FloatRegister::FloatRegisterImpl::name() const {\n@@ -61,1 +52,1 @@\n-  return is_valid() ? names[encoding()] : \"noreg\";\n+  return is_valid() ? names[encoding()] : \"fnoreg\";\n@@ -64,1 +55,1 @@\n-const char* PRegisterImpl::name() const {\n+const char* PRegister::PRegisterImpl::name() const {\n@@ -69,1 +60,1 @@\n-  return is_valid() ? names[encoding()] : \"noreg\";\n+  return is_valid() ? names[encoding()] : \"pnoreg\";\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.cpp","additions":13,"deletions":22,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -35,3 +35,3 @@\n-\/\/ Use Register as shortcut\n-class RegisterImpl;\n-typedef const RegisterImpl* Register;\n+class Register {\n+ private:\n+  int _encoding;\n@@ -39,1 +39,1 @@\n-inline constexpr Register as_Register(int encoding);\n+  constexpr Register(int encoding, bool unused) : _encoding(encoding) {}\n@@ -41,4 +41,1 @@\n-class RegisterImpl: public AbstractRegisterImpl {\n-  static constexpr Register first();\n-\n-public:\n+ public:\n@@ -46,3 +43,3 @@\n-    number_of_registers         =   32,\n-    number_of_declared_registers  = 34,  \/\/ Including SP and ZR.\n-    max_slots_per_register = 2\n+    number_of_registers          = 32,\n+    number_of_declared_registers = 34,  \/\/ Including SP and ZR.\n+    max_slots_per_register       =  2\n@@ -51,2 +48,18 @@\n-  \/\/ derived registers, offsets, and addresses\n-  const Register successor() const { return this + 1; }\n+  class RegisterImpl: public AbstractRegisterImpl {\n+    friend class Register;\n+\n+    static constexpr const RegisterImpl* first();\n+\n+   public:\n+    \/\/ accessors\n+    int raw_encoding() const { return this - first(); }\n+    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+\n+    \/\/ derived registers, offsets, and addresses\n+    inline Register successor() const;\n+\n+    VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n@@ -54,1 +67,0 @@\n-  \/\/ construction\n@@ -57,1 +69,4 @@\n-  VMReg as_VMReg() const;\n+  constexpr Register() : _encoding(-1) {} \/\/ noreg\n+\n+  int operator==(const Register r) const { return _encoding == r._encoding; }\n+  int operator!=(const Register r) const { return _encoding != r._encoding; }\n@@ -59,5 +74,1 @@\n-  \/\/ accessors\n-  int encoding() const             { assert(is_valid(), \"invalid register\"); return encoding_nocheck(); }\n-  bool is_valid() const            { return (unsigned)encoding_nocheck() < number_of_registers; }\n-  const char* name() const;\n-  int encoding_nocheck() const     { return this - first(); }\n+  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -66,0 +77,1 @@\n+extern Register::RegisterImpl all_RegisterImpls[Register::number_of_declared_registers + 1] INTERNAL_VISIBILITY;\n@@ -67,1 +79,3 @@\n-REGISTER_IMPL_DECLARATION(Register, RegisterImpl, RegisterImpl::number_of_declared_registers);\n+inline constexpr const Register::RegisterImpl* Register::RegisterImpl::first() {\n+  return all_RegisterImpls + 1;\n+}\n@@ -69,1 +83,1 @@\n-\/\/ The integer registers of the aarch64 architecture\n+constexpr Register noreg = Register();\n@@ -71,1 +85,11 @@\n-CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));\n+inline constexpr Register as_Register(int encoding) {\n+  if (0 <= encoding && encoding < Register::number_of_declared_registers) {\n+    return Register(encoding, false);\n+  }\n+  return noreg;\n+}\n+\n+inline Register Register::RegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_Register(encoding() + 1);\n+}\n@@ -73,18 +97,19 @@\n-CONSTANT_REGISTER_DECLARATION(Register, r0,    (0));\n-CONSTANT_REGISTER_DECLARATION(Register, r1,    (1));\n-CONSTANT_REGISTER_DECLARATION(Register, r2,    (2));\n-CONSTANT_REGISTER_DECLARATION(Register, r3,    (3));\n-CONSTANT_REGISTER_DECLARATION(Register, r4,    (4));\n-CONSTANT_REGISTER_DECLARATION(Register, r5,    (5));\n-CONSTANT_REGISTER_DECLARATION(Register, r6,    (6));\n-CONSTANT_REGISTER_DECLARATION(Register, r7,    (7));\n-CONSTANT_REGISTER_DECLARATION(Register, r8,    (8));\n-CONSTANT_REGISTER_DECLARATION(Register, r9,    (9));\n-CONSTANT_REGISTER_DECLARATION(Register, r10,  (10));\n-CONSTANT_REGISTER_DECLARATION(Register, r11,  (11));\n-CONSTANT_REGISTER_DECLARATION(Register, r12,  (12));\n-CONSTANT_REGISTER_DECLARATION(Register, r13,  (13));\n-CONSTANT_REGISTER_DECLARATION(Register, r14,  (14));\n-CONSTANT_REGISTER_DECLARATION(Register, r15,  (15));\n-CONSTANT_REGISTER_DECLARATION(Register, r16,  (16));\n-CONSTANT_REGISTER_DECLARATION(Register, r17,  (17));\n+\/\/ The integer registers of the AArch64 architecture\n+constexpr Register r0  = as_Register( 0);\n+constexpr Register r1  = as_Register( 1);\n+constexpr Register r2  = as_Register( 2);\n+constexpr Register r3  = as_Register( 3);\n+constexpr Register r4  = as_Register( 4);\n+constexpr Register r5  = as_Register( 5);\n+constexpr Register r6  = as_Register( 6);\n+constexpr Register r7  = as_Register( 7);\n+constexpr Register r8  = as_Register( 8);\n+constexpr Register r9  = as_Register( 9);\n+constexpr Register r10 = as_Register(10);\n+constexpr Register r11 = as_Register(11);\n+constexpr Register r12 = as_Register(12);\n+constexpr Register r13 = as_Register(13);\n+constexpr Register r14 = as_Register(14);\n+constexpr Register r15 = as_Register(15);\n+constexpr Register r16 = as_Register(16);\n+constexpr Register r17 = as_Register(17);\n@@ -102,13 +127,13 @@\n-CONSTANT_REGISTER_DECLARATION(Register, r18_tls,  (18));\n-CONSTANT_REGISTER_DECLARATION(Register, r19,  (19));\n-CONSTANT_REGISTER_DECLARATION(Register, r20,  (20));\n-CONSTANT_REGISTER_DECLARATION(Register, r21,  (21));\n-CONSTANT_REGISTER_DECLARATION(Register, r22,  (22));\n-CONSTANT_REGISTER_DECLARATION(Register, r23,  (23));\n-CONSTANT_REGISTER_DECLARATION(Register, r24,  (24));\n-CONSTANT_REGISTER_DECLARATION(Register, r25,  (25));\n-CONSTANT_REGISTER_DECLARATION(Register, r26,  (26));\n-CONSTANT_REGISTER_DECLARATION(Register, r27,  (27));\n-CONSTANT_REGISTER_DECLARATION(Register, r28,  (28));\n-CONSTANT_REGISTER_DECLARATION(Register, r29,  (29));\n-CONSTANT_REGISTER_DECLARATION(Register, r30,  (30));\n+constexpr Register r18_tls = as_Register(18);\n+constexpr Register r19     = as_Register(19);\n+constexpr Register r20     = as_Register(20);\n+constexpr Register r21     = as_Register(21);\n+constexpr Register r22     = as_Register(22);\n+constexpr Register r23     = as_Register(23);\n+constexpr Register r24     = as_Register(24);\n+constexpr Register r25     = as_Register(25);\n+constexpr Register r26     = as_Register(26);\n+constexpr Register r27     = as_Register(27);\n+constexpr Register r28     = as_Register(28);\n+constexpr Register r29     = as_Register(29);\n+constexpr Register r30     = as_Register(30);\n@@ -120,3 +145,3 @@\n-CONSTANT_REGISTER_DECLARATION(Register, r31_sp, (31));\n-CONSTANT_REGISTER_DECLARATION(Register, zr,  (32));\n-CONSTANT_REGISTER_DECLARATION(Register, sp,  (33));\n+constexpr Register r31_sp = as_Register(31);\n+constexpr Register zr     = as_Register(32);\n+constexpr Register sp     = as_Register(33);\n@@ -125,1 +150,1 @@\n-const Register dummy_reg = r31_sp;\n+constexpr Register dummy_reg = r31_sp;\n@@ -127,5 +152,0 @@\n-\/\/ Use FloatRegister as shortcut\n-class FloatRegisterImpl;\n-typedef const FloatRegisterImpl* FloatRegister;\n-\n-inline constexpr FloatRegister as_FloatRegister(int encoding);\n@@ -134,2 +154,8 @@\n-class FloatRegisterImpl: public AbstractRegisterImpl {\n-  static constexpr FloatRegister first();\n+class FloatRegister {\n+ private:\n+  int _encoding;\n+\n+  constexpr FloatRegister(int encoding, bool unused) : _encoding(encoding) {}\n+\n+ public:\n+  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n@@ -137,1 +163,0 @@\n-public:\n@@ -139,4 +164,4 @@\n-    number_of_registers = 32,\n-    max_slots_per_register = 8,\n-    save_slots_per_register = 2,\n-    slots_per_neon_register = 4,\n+    number_of_registers     = 32,\n+    max_slots_per_register  =  8,\n+    save_slots_per_register =  2,\n+    slots_per_neon_register =  4,\n@@ -146,2 +171,2 @@\n-  \/\/ construction\n-  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n+  class FloatRegisterImpl: public AbstractRegisterImpl {\n+    friend class FloatRegister;\n@@ -149,1 +174,1 @@\n-  VMReg as_VMReg() const;\n+    static constexpr const FloatRegisterImpl* first();\n@@ -151,4 +176,5 @@\n-  \/\/ derived registers, offsets, and addresses\n-  FloatRegister successor() const {\n-    return as_FloatRegister((encoding() + 1) % (unsigned)number_of_registers);\n-  }\n+   public:\n+    \/\/ accessors\n+    int raw_encoding() const { return this - first(); }\n+    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -156,5 +182,14 @@\n-  \/\/ accessors\n-  int encoding() const             { assert(is_valid(), \"invalid register\"); return encoding_nocheck(); }\n-  bool is_valid() const            { return (unsigned)encoding_nocheck() < number_of_registers; }\n-  const char* name() const;\n-  int encoding_nocheck() const     { return this - first(); }\n+    \/\/ derived registers, offsets, and addresses\n+    inline FloatRegister successor() const;\n+\n+    VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+  constexpr FloatRegister() : _encoding(-1) {} \/\/ fnoreg\n+\n+  int operator==(const FloatRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const FloatRegister r) const { return _encoding != r._encoding; }\n+\n+  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n@@ -163,39 +198,53 @@\n-REGISTER_IMPL_DECLARATION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n-\n-\n-\/\/ The float registers of the AARCH64 architecture\n-\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg , (-1));\n-\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v0     , ( 0));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v1     , ( 1));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v2     , ( 2));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v3     , ( 3));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v4     , ( 4));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v5     , ( 5));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v6     , ( 6));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v7     , ( 7));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v8     , ( 8));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v9     , ( 9));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v10    , (10));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v11    , (11));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v12    , (12));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v13    , (13));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v14    , (14));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v15    , (15));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v16    , (16));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v17    , (17));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v18    , (18));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v19    , (19));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v20    , (20));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v21    , (21));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v22    , (22));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v23    , (23));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v24    , (24));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v25    , (25));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v26    , (26));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v27    , (27));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v28    , (28));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v29    , (29));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v30    , (30));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, v31    , (31));\n+extern FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr const FloatRegister::FloatRegisterImpl* FloatRegister::FloatRegisterImpl::first() {\n+  return all_FloatRegisterImpls + 1;\n+}\n+\n+constexpr FloatRegister fnoreg = FloatRegister();\n+\n+inline constexpr FloatRegister as_FloatRegister(int encoding) {\n+  if (0 <= encoding && encoding < FloatRegister::number_of_registers) {\n+    return FloatRegister(encoding, false);\n+  }\n+  return fnoreg;\n+}\n+\n+inline FloatRegister FloatRegister::FloatRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_FloatRegister((encoding() + 1) % number_of_registers);\n+}\n+\n+\/\/ The float registers of the AArch64 architecture\n+constexpr FloatRegister v0  = as_FloatRegister( 0);\n+constexpr FloatRegister v1  = as_FloatRegister( 1);\n+constexpr FloatRegister v2  = as_FloatRegister( 2);\n+constexpr FloatRegister v3  = as_FloatRegister( 3);\n+constexpr FloatRegister v4  = as_FloatRegister( 4);\n+constexpr FloatRegister v5  = as_FloatRegister( 5);\n+constexpr FloatRegister v6  = as_FloatRegister( 6);\n+constexpr FloatRegister v7  = as_FloatRegister( 7);\n+constexpr FloatRegister v8  = as_FloatRegister( 8);\n+constexpr FloatRegister v9  = as_FloatRegister( 9);\n+constexpr FloatRegister v10 = as_FloatRegister(10);\n+constexpr FloatRegister v11 = as_FloatRegister(11);\n+constexpr FloatRegister v12 = as_FloatRegister(12);\n+constexpr FloatRegister v13 = as_FloatRegister(13);\n+constexpr FloatRegister v14 = as_FloatRegister(14);\n+constexpr FloatRegister v15 = as_FloatRegister(15);\n+constexpr FloatRegister v16 = as_FloatRegister(16);\n+constexpr FloatRegister v17 = as_FloatRegister(17);\n+constexpr FloatRegister v18 = as_FloatRegister(18);\n+constexpr FloatRegister v19 = as_FloatRegister(19);\n+constexpr FloatRegister v20 = as_FloatRegister(20);\n+constexpr FloatRegister v21 = as_FloatRegister(21);\n+constexpr FloatRegister v22 = as_FloatRegister(22);\n+constexpr FloatRegister v23 = as_FloatRegister(23);\n+constexpr FloatRegister v24 = as_FloatRegister(24);\n+constexpr FloatRegister v25 = as_FloatRegister(25);\n+constexpr FloatRegister v26 = as_FloatRegister(26);\n+constexpr FloatRegister v27 = as_FloatRegister(27);\n+constexpr FloatRegister v28 = as_FloatRegister(28);\n+constexpr FloatRegister v29 = as_FloatRegister(29);\n+constexpr FloatRegister v30 = as_FloatRegister(30);\n+constexpr FloatRegister v31 = as_FloatRegister(31);\n@@ -204,37 +253,33 @@\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z0     , ( 0));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z1     , ( 1));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z2     , ( 2));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z3     , ( 3));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z4     , ( 4));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z5     , ( 5));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z6     , ( 6));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z7     , ( 7));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z8     , ( 8));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z9     , ( 9));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z10    , (10));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z11    , (11));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z12    , (12));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z13    , (13));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z14    , (14));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z15    , (15));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z16    , (16));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z17    , (17));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z18    , (18));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z19    , (19));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z20    , (20));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z21    , (21));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z22    , (22));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z23    , (23));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z24    , (24));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z25    , (25));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z26    , (26));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z27    , (27));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z28    , (28));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z29    , (29));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z30    , (30));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, z31    , (31));\n-\n-\n-class PRegisterImpl;\n-typedef const PRegisterImpl* PRegister;\n-inline constexpr PRegister as_PRegister(int encoding);\n+constexpr FloatRegister z0  = v0;\n+constexpr FloatRegister z1  = v1;\n+constexpr FloatRegister z2  = v2;\n+constexpr FloatRegister z3  = v3;\n+constexpr FloatRegister z4  = v4;\n+constexpr FloatRegister z5  = v5;\n+constexpr FloatRegister z6  = v6;\n+constexpr FloatRegister z7  = v7;\n+constexpr FloatRegister z8  = v8;\n+constexpr FloatRegister z9  = v9;\n+constexpr FloatRegister z10 = v10;\n+constexpr FloatRegister z11 = v11;\n+constexpr FloatRegister z12 = v12;\n+constexpr FloatRegister z13 = v13;\n+constexpr FloatRegister z14 = v14;\n+constexpr FloatRegister z15 = v15;\n+constexpr FloatRegister z16 = v16;\n+constexpr FloatRegister z17 = v17;\n+constexpr FloatRegister z18 = v18;\n+constexpr FloatRegister z19 = v19;\n+constexpr FloatRegister z20 = v20;\n+constexpr FloatRegister z21 = v21;\n+constexpr FloatRegister z22 = v22;\n+constexpr FloatRegister z23 = v23;\n+constexpr FloatRegister z24 = v24;\n+constexpr FloatRegister z25 = v25;\n+constexpr FloatRegister z26 = v26;\n+constexpr FloatRegister z27 = v27;\n+constexpr FloatRegister z28 = v28;\n+constexpr FloatRegister z29 = v29;\n+constexpr FloatRegister z30 = v30;\n+constexpr FloatRegister z31 = v31;\n+\n@@ -243,2 +288,7 @@\n-class PRegisterImpl: public AbstractRegisterImpl {\n-  static constexpr PRegister first();\n+class PRegister {\n+  int _encoding;\n+\n+  constexpr PRegister(int encoding, bool unused) : _encoding(encoding) {}\n+\n+public:\n+  inline friend constexpr PRegister as_PRegister(int encoding);\n@@ -246,1 +296,0 @@\n- public:\n@@ -258,2 +307,1 @@\n-  \/\/ construction\n-  inline friend constexpr PRegister as_PRegister(int encoding);\n+  constexpr PRegister() : _encoding(-1) {} \/\/ pnoreg\n@@ -261,1 +309,2 @@\n-  VMReg as_VMReg() const;\n+  class PRegisterImpl: public AbstractRegisterImpl {\n+    friend class PRegister;\n@@ -263,2 +312,1 @@\n-  \/\/ derived registers, offsets, and addresses\n-  PRegister successor() const     { return this + 1; }\n+    static constexpr const PRegisterImpl* first();\n@@ -266,6 +314,19 @@\n-  \/\/ accessors\n-  int encoding() const            { assert(is_valid(), \"invalid register\"); return encoding_nocheck(); }\n-  int encoding_nocheck() const    { return this - first(); }\n-  bool is_valid() const           { return (unsigned)encoding_nocheck() < number_of_registers; }\n-  bool is_governing() const       { return first() <= this && this - first() < number_of_governing_registers; }\n-  const char* name() const;\n+   public:\n+    \/\/ accessors\n+    int raw_encoding() const  { return this - first(); }\n+    int encoding() const      { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool is_valid() const     { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    bool is_governing() const { return 0 <= raw_encoding() && raw_encoding() < number_of_governing_registers; }\n+\n+    \/\/ derived registers, offsets, and addresses\n+    inline PRegister successor() const;\n+\n+    VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+  int operator==(const PRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const PRegister r) const { return _encoding != r._encoding; }\n+\n+  const PRegisterImpl* operator->() const { return PRegisterImpl::first() + _encoding; }\n@@ -274,0 +335,5 @@\n+extern PRegister::PRegisterImpl all_PRegisterImpls[PRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr const PRegister::PRegisterImpl* PRegister::PRegisterImpl::first() {\n+  return all_PRegisterImpls + 1;\n+}\n@@ -275,1 +341,13 @@\n-REGISTER_IMPL_DECLARATION(PRegister, PRegisterImpl, PRegisterImpl::number_of_registers);\n+constexpr PRegister pnoreg = PRegister();\n+\n+inline constexpr PRegister as_PRegister(int encoding) {\n+  if (0 <= encoding && encoding < PRegister::number_of_registers) {\n+    return PRegister(encoding, false);\n+  }\n+  return pnoreg;\n+}\n+\n+inline PRegister PRegister::PRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_PRegister(encoding() + 1);\n+}\n@@ -278,19 +356,16 @@\n-\/\/\n-CONSTANT_REGISTER_DECLARATION(PRegister, pnoreg, (-1));\n-\n-CONSTANT_REGISTER_DECLARATION(PRegister, p0,  ( 0));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p1,  ( 1));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p2,  ( 2));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p3,  ( 3));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p4,  ( 4));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p5,  ( 5));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p6,  ( 6));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p7,  ( 7));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p8,  ( 8));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p9,  ( 9));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p10, (10));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p11, (11));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p12, (12));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p13, (13));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p14, (14));\n-CONSTANT_REGISTER_DECLARATION(PRegister, p15, (15));\n+constexpr PRegister p0  = as_PRegister( 0);\n+constexpr PRegister p1  = as_PRegister( 1);\n+constexpr PRegister p2  = as_PRegister( 2);\n+constexpr PRegister p3  = as_PRegister( 3);\n+constexpr PRegister p4  = as_PRegister( 4);\n+constexpr PRegister p5  = as_PRegister( 5);\n+constexpr PRegister p6  = as_PRegister( 6);\n+constexpr PRegister p7  = as_PRegister( 7);\n+constexpr PRegister p8  = as_PRegister( 8);\n+constexpr PRegister p9  = as_PRegister( 9);\n+constexpr PRegister p10 = as_PRegister(10);\n+constexpr PRegister p11 = as_PRegister(11);\n+constexpr PRegister p12 = as_PRegister(12);\n+constexpr PRegister p13 = as_PRegister(13);\n+constexpr PRegister p14 = as_PRegister(14);\n+constexpr PRegister p15 = as_PRegister(15);\n@@ -303,9 +378,9 @@\n-  \/\/ A big enough number for C2: all the registers plus flags\n-  \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n-  \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n-  \/\/ it's optoregs.\n-\n-    number_of_registers = (RegisterImpl::max_slots_per_register * RegisterImpl::number_of_registers +\n-                           FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers +\n-                           PRegisterImpl::max_slots_per_register * PRegisterImpl::number_of_registers +\n-                           1) \/\/ flags\n+    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n+    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n+    max_pr  = max_fpr + PRegister::number_of_registers * PRegister::max_slots_per_register,\n+\n+    \/\/ A big enough number for C2: all the registers plus flags\n+    \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n+    \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n+    \/\/ it's optoregs.\n+    number_of_registers = max_pr + 1 \/\/ gpr\/fpr\/pr + flags\n@@ -313,5 +388,0 @@\n-\n-  \/\/ added to make it compile\n-  static const int max_gpr;\n-  static const int max_fpr;\n-  static const int max_pr;\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":276,"deletions":206,"binary":false,"changes":482,"status":"modified"},{"patch":"@@ -122,3 +122,3 @@\n-                rfp_off = r0_off + (RegisterImpl::number_of_registers - 2) * RegisterImpl::max_slots_per_register,\n-                return_off = rfp_off + RegisterImpl::max_slots_per_register,      \/\/ slot for return address\n-                reg_save_size = return_off + RegisterImpl::max_slots_per_register};\n+                rfp_off = r0_off + (Register::number_of_registers - 2) * Register::max_slots_per_register,\n+                return_off = rfp_off + Register::max_slots_per_register,      \/\/ slot for return address\n+                reg_save_size = return_off + Register::max_slots_per_register};\n@@ -134,1 +134,1 @@\n-  int slots_per_vect = FloatRegisterImpl::save_slots_per_register;\n+  int slots_per_vect = FloatRegister::save_slots_per_register;\n@@ -138,1 +138,1 @@\n-    slots_per_vect = FloatRegisterImpl::slots_per_neon_register;\n+    slots_per_vect = FloatRegister::slots_per_neon_register;\n@@ -148,1 +148,1 @@\n-  int r0_offset = v0_offset_in_bytes() + (slots_per_vect * FloatRegisterImpl::number_of_registers) * BytesPerInt;\n+  int r0_offset = v0_offset_in_bytes() + (slots_per_vect * FloatRegister::number_of_registers) * BytesPerInt;\n@@ -166,1 +166,1 @@\n-                    PRegisterImpl::number_of_saved_registers, 16);\n+                    PRegister::number_of_saved_registers, 16);\n@@ -194,1 +194,1 @@\n-      extra_save_slots_per_register = sve_vector_size_in_slots - FloatRegisterImpl::save_slots_per_register;\n+      extra_save_slots_per_register = sve_vector_size_in_slots - FloatRegister::save_slots_per_register;\n@@ -196,1 +196,1 @@\n-      extra_save_slots_per_register = FloatRegisterImpl::extra_save_slots_per_neon_register;\n+      extra_save_slots_per_register = FloatRegister::extra_save_slots_per_neon_register;\n@@ -200,1 +200,1 @@\n-                             FloatRegisterImpl::number_of_registers;\n+                             FloatRegister::number_of_registers;\n@@ -229,1 +229,1 @@\n-  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < Register::number_of_registers; i++) {\n@@ -231,1 +231,1 @@\n-    if (r <= rfp && r != rscratch1 && r != rscratch2) {\n+    if (i <= rfp->encoding() && r != rscratch1 && r != rscratch2) {\n@@ -234,2 +234,2 @@\n-      int sp_offset = RegisterImpl::max_slots_per_register * i +\n-                      FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;\n+      int sp_offset = Register::max_slots_per_register * i +\n+                      FloatRegister::save_slots_per_register * FloatRegister::number_of_registers;\n@@ -240,1 +240,1 @@\n-  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n@@ -245,1 +245,1 @@\n-                            (FloatRegisterImpl::slots_per_neon_register * i);\n+                            (FloatRegister::slots_per_neon_register * i);\n@@ -247,1 +247,1 @@\n-      sp_offset = FloatRegisterImpl::save_slots_per_register * i;\n+      sp_offset = FloatRegister::save_slots_per_register * i;\n@@ -253,1 +253,1 @@\n-    for (int i = 0; i < PRegisterImpl::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n@@ -292,2 +292,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 64-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 64-bit\n@@ -1473,3 +1473,3 @@\n-  bool reg_destroyed[RegisterImpl::number_of_registers];\n-  bool freg_destroyed[FloatRegisterImpl::number_of_registers];\n-  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+  bool reg_destroyed[Register::number_of_registers];\n+  bool freg_destroyed[FloatRegister::number_of_registers];\n+  for ( int r = 0 ; r < Register::number_of_registers ; r++ ) {\n@@ -1478,1 +1478,1 @@\n-  for ( int f = 0 ; f < FloatRegisterImpl::number_of_registers ; f++ ) {\n+  for ( int f = 0 ; f < FloatRegister::number_of_registers ; f++ ) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -3048,2 +3048,3 @@\n-      for (FloatRegister f = v0; f < v0 + bulk_width; f++) {\n-        __ rev32(f, __ T16B, v16);\n+      for (int i = 0; i < bulk_width; i++) {\n+        FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + i);\n+        __ rev32(v0_ofs, __ T16B, v16);\n@@ -3064,1 +3065,3 @@\n-        __ eor(v0 + i, __ T16B, v0 + i, v8 + i);\n+        FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + i);\n+        FloatRegister v8_ofs = as_FloatRegister(v8->encoding() + i);\n+        __ eor(v0_ofs, __ T16B, v0_ofs, v8_ofs);\n@@ -3165,1 +3168,4 @@\n-      for (FloatRegister f = v0; f < v8; f++) {\n+\n+      assert(v0->encoding() < v8->encoding(), \"\");\n+      for (int i = v0->encoding(); i < v8->encoding(); i++) {\n+        FloatRegister f = as_FloatRegister(i);\n@@ -3179,1 +3185,3 @@\n-        __ eor(v0 + i, __ T16B, v0 + i, v8 + i);\n+        FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + i);\n+        FloatRegister v8_ofs = as_FloatRegister(v8->encoding() + i);\n+        __ eor(v0_ofs, __ T16B, v0_ofs, v8_ofs);\n@@ -7249,1 +7257,2 @@\n-      assert(tmp1 < r19 && tmp2 < r19, \"register corruption\");\n+      assert(tmp1->encoding() < r19->encoding(), \"register corruption\");\n+      assert(tmp2->encoding() < r19->encoding(), \"register corruption\");\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < Register::number_of_registers; i++) {\n@@ -51,1 +51,1 @@\n-  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n@@ -70,1 +70,1 @@\n-  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < Register::number_of_registers; i++) {\n@@ -79,1 +79,1 @@\n-  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n@@ -98,1 +98,1 @@\n-  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < Register::number_of_registers; i++) {\n@@ -107,1 +107,1 @@\n-  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    for (int j = 0 ; j < RegisterImpl::max_slots_per_register ; j++) {\n+    for (int j = 0 ; j < Register::max_slots_per_register ; j++) {\n@@ -44,1 +44,1 @@\n-    for (int j = 0 ; j < FloatRegisterImpl::max_slots_per_register ; j++) {\n+    for (int j = 0 ; j < FloatRegister::max_slots_per_register ; j++) {\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  return ::as_Register(value() \/ RegisterImpl::max_slots_per_register);\n+  return ::as_Register(value() \/ Register::max_slots_per_register);\n@@ -51,1 +51,1 @@\n-                            FloatRegisterImpl::max_slots_per_register);\n+                            FloatRegister::max_slots_per_register);\n@@ -57,1 +57,1 @@\n-                        PRegisterImpl::max_slots_per_register);\n+                        PRegister::max_slots_per_register);\n@@ -64,1 +64,1 @@\n-    return base % FloatRegisterImpl::max_slots_per_register == 0;\n+    return (base % FloatRegister::max_slots_per_register) == 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,3 +29,2 @@\n-inline VMReg RegisterImpl::as_VMReg() const {\n-  if( this==noreg ) return VMRegImpl::Bad();\n-  return VMRegImpl::as_VMReg(encoding() * RegisterImpl::max_slots_per_register);\n+inline VMReg Register::RegisterImpl::as_VMReg() const {\n+  return VMRegImpl::as_VMReg(encoding() * Register::max_slots_per_register);\n@@ -34,2 +33,2 @@\n-inline VMReg FloatRegisterImpl::as_VMReg() const {\n-  return VMRegImpl::as_VMReg((encoding() * FloatRegisterImpl::max_slots_per_register) +\n+inline VMReg FloatRegister::FloatRegisterImpl::as_VMReg() const {\n+  return VMRegImpl::as_VMReg((encoding() * FloatRegister::max_slots_per_register) +\n@@ -39,2 +38,3 @@\n-inline VMReg PRegisterImpl::as_VMReg() const {\n-  return VMRegImpl::as_VMReg(encoding() + ConcreteRegisterImpl::max_fpr);\n+inline VMReg PRegister::PRegisterImpl::as_VMReg() const {\n+  return VMRegImpl::as_VMReg((encoding() * PRegister::max_slots_per_register) +\n+                             ConcreteRegisterImpl::max_fpr);\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -66,4 +66,4 @@\n-REGISTER_DECLARATION(Register, c_rarg0, rcx);\n-REGISTER_DECLARATION(Register, c_rarg1, rdx);\n-REGISTER_DECLARATION(Register, c_rarg2, r8);\n-REGISTER_DECLARATION(Register, c_rarg3, r9);\n+constexpr Register c_rarg0 = rcx;\n+constexpr Register c_rarg1 = rdx;\n+constexpr Register c_rarg2 =  r8;\n+constexpr Register c_rarg3 =  r9;\n@@ -71,4 +71,4 @@\n-REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);\n+constexpr XMMRegister c_farg0 = xmm0;\n+constexpr XMMRegister c_farg1 = xmm1;\n+constexpr XMMRegister c_farg2 = xmm2;\n+constexpr XMMRegister c_farg3 = xmm3;\n@@ -78,15 +78,15 @@\n-REGISTER_DECLARATION(Register, c_rarg0, rdi);\n-REGISTER_DECLARATION(Register, c_rarg1, rsi);\n-REGISTER_DECLARATION(Register, c_rarg2, rdx);\n-REGISTER_DECLARATION(Register, c_rarg3, rcx);\n-REGISTER_DECLARATION(Register, c_rarg4, r8);\n-REGISTER_DECLARATION(Register, c_rarg5, r9);\n-\n-REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);\n-REGISTER_DECLARATION(XMMRegister, c_farg4, xmm4);\n-REGISTER_DECLARATION(XMMRegister, c_farg5, xmm5);\n-REGISTER_DECLARATION(XMMRegister, c_farg6, xmm6);\n-REGISTER_DECLARATION(XMMRegister, c_farg7, xmm7);\n+constexpr Register c_rarg0 = rdi;\n+constexpr Register c_rarg1 = rsi;\n+constexpr Register c_rarg2 = rdx;\n+constexpr Register c_rarg3 = rcx;\n+constexpr Register c_rarg4 =  r8;\n+constexpr Register c_rarg5 =  r9;\n+\n+constexpr XMMRegister c_farg0 = xmm0;\n+constexpr XMMRegister c_farg1 = xmm1;\n+constexpr XMMRegister c_farg2 = xmm2;\n+constexpr XMMRegister c_farg3 = xmm3;\n+constexpr XMMRegister c_farg4 = xmm4;\n+constexpr XMMRegister c_farg5 = xmm5;\n+constexpr XMMRegister c_farg6 = xmm6;\n+constexpr XMMRegister c_farg7 = xmm7;\n@@ -112,3 +112,3 @@\n-REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);\n-REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);\n-REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);\n+constexpr Register j_rarg0 = c_rarg1;\n+constexpr Register j_rarg1 = c_rarg2;\n+constexpr Register j_rarg2 = c_rarg3;\n@@ -117,2 +117,2 @@\n-REGISTER_DECLARATION(Register, j_rarg3, rdi);\n-REGISTER_DECLARATION(Register, j_rarg4, rsi);\n+constexpr Register j_rarg3 = rdi;\n+constexpr Register j_rarg4 = rsi;\n@@ -120,2 +120,2 @@\n-REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);\n-REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);\n+constexpr Register j_rarg3 = c_rarg4;\n+constexpr Register j_rarg4 = c_rarg5;\n@@ -123,1 +123,1 @@\n-REGISTER_DECLARATION(Register, j_rarg5, c_rarg0);\n+constexpr Register j_rarg5 = c_rarg0;\n@@ -125,8 +125,8 @@\n-REGISTER_DECLARATION(XMMRegister, j_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, j_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, j_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, j_farg3, xmm3);\n-REGISTER_DECLARATION(XMMRegister, j_farg4, xmm4);\n-REGISTER_DECLARATION(XMMRegister, j_farg5, xmm5);\n-REGISTER_DECLARATION(XMMRegister, j_farg6, xmm6);\n-REGISTER_DECLARATION(XMMRegister, j_farg7, xmm7);\n+constexpr XMMRegister j_farg0 = xmm0;\n+constexpr XMMRegister j_farg1 = xmm1;\n+constexpr XMMRegister j_farg2 = xmm2;\n+constexpr XMMRegister j_farg3 = xmm3;\n+constexpr XMMRegister j_farg4 = xmm4;\n+constexpr XMMRegister j_farg5 = xmm5;\n+constexpr XMMRegister j_farg6 = xmm6;\n+constexpr XMMRegister j_farg7 = xmm7;\n@@ -134,2 +134,2 @@\n-REGISTER_DECLARATION(Register, rscratch1, r10);  \/\/ volatile\n-REGISTER_DECLARATION(Register, rscratch2, r11);  \/\/ volatile\n+constexpr Register rscratch1 = r10;  \/\/ volatile\n+constexpr Register rscratch2 = r11;  \/\/ volatile\n@@ -137,2 +137,2 @@\n-REGISTER_DECLARATION(Register, r12_heapbase, r12); \/\/ callee-saved\n-REGISTER_DECLARATION(Register, r15_thread, r15); \/\/ callee-saved\n+constexpr Register r12_heapbase = r12; \/\/ callee-saved\n+constexpr Register r15_thread   = r15; \/\/ callee-saved\n@@ -152,1 +152,1 @@\n-REGISTER_DECLARATION(Register, rbp_mh_SP_save, noreg);\n+constexpr Register rbp_mh_SP_save = noreg;\n@@ -2935,1 +2935,1 @@\n-    _embedded_opmask_register_specifier = (*mask).encoding() & 0x7;\n+    _embedded_opmask_register_specifier = mask->encoding() & 0x7;\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":45,"deletions":45,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n-  pd_nof_cpu_regs_frame_map = RegisterImpl::number_of_registers,       \/\/ number of registers used during code emission\n-  pd_nof_fpu_regs_frame_map = FloatRegisterImpl::number_of_registers,  \/\/ number of registers used during code emission\n-  pd_nof_xmm_regs_frame_map = XMMRegisterImpl::number_of_registers,    \/\/ number of registers used during code emission\n+  pd_nof_cpu_regs_frame_map = Register::number_of_registers,       \/\/ number of registers used during code emission\n+  pd_nof_fpu_regs_frame_map = FloatRegister::number_of_registers,  \/\/ number of registers used during code emission\n+  pd_nof_xmm_regs_frame_map = XMMRegister::number_of_registers,    \/\/ number of registers used during code emission\n","filename":"src\/hotspot\/cpu\/x86\/c1_Defs_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-XMMRegister FrameMap::_xmm_regs [] = { 0, };\n+XMMRegister FrameMap::_xmm_regs[] = {};\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-    return XMMRegisterImpl::available_xmm_registers();\n+    return XMMRegister::available_xmm_registers();\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1956,1 +1956,1 @@\n-    assert(newval != NULL, \"new val must be register\");\n+    assert(newval != noreg, \"new val must be register\");\n@@ -1987,1 +1987,1 @@\n-    assert(newval != NULL, \"new val must be register\");\n+    assert(newval != noreg, \"new val must be register\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  int last_xmm_reg = pd_first_xmm_reg + XMMRegisterImpl::available_xmm_registers() - 1;\n+  int last_xmm_reg = pd_first_xmm_reg + XMMRegister::available_xmm_registers() - 1;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    int delta = XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers;\n+    int delta = XMMRegister::max_slots_per_register * XMMRegister::number_of_registers;\n@@ -50,1 +50,1 @@\n-    int xmm_slots = XMMRegisterImpl::max_slots_per_register;\n+    int xmm_slots = XMMRegister::max_slots_per_register;\n","filename":"src\/hotspot\/cpu\/x86\/c2_init_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  assert(newval != NULL, \"new val must be register\");\n+  assert(newval != noreg, \"new val must be register\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-    assert(res != NULL, \"need result register\");\n+    assert(res != noreg, \"need result register\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_32.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n@@ -107,1 +107,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-  if (jvmci_reg < RegisterImpl::number_of_registers) {\n+  if (jvmci_reg < Register::number_of_registers) {\n@@ -216,2 +216,2 @@\n-    jint floatRegisterNumber = jvmci_reg - RegisterImpl::number_of_registers;\n-    if (floatRegisterNumber < XMMRegisterImpl::number_of_registers) {\n+    jint floatRegisterNumber = jvmci_reg - Register::number_of_registers;\n+    if (floatRegisterNumber < XMMRegister::number_of_registers) {\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3775,1 +3775,1 @@\n-  int num_xmm_registers = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_registers = XMMRegister::available_xmm_registers();\n@@ -3816,1 +3816,1 @@\n-  gp_area_size = align_up(gp_registers.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size,\n+  gp_area_size = align_up(gp_registers.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size,\n@@ -3909,1 +3909,1 @@\n-    int register_push_size = set.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    int register_push_size = set.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -3919,1 +3919,1 @@\n-    spill_offset += RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    spill_offset += Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -3925,1 +3925,1 @@\n-  int gp_reg_size = RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+  int gp_reg_size = Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-void MacroAssembler::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+void MacroAssembler::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n@@ -61,1 +61,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_aes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-    const int saved_regs_count = RegisterImpl::number_of_registers;\n+    const int saved_regs_count = Register::number_of_registers;\n@@ -539,1 +539,1 @@\n-      assert(RegisterImpl::number_of_registers == 16, \"sanity\");\n+      assert(Register::number_of_registers == 16, \"sanity\");\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    int base_reg_enc = (reg_base \/ XMMRegisterImpl::max_slots_per_register);\n-    assert(base_reg_enc >= 0 && base_reg_enc < XMMRegisterImpl::number_of_registers, \"invalid XMMRegister: %d\", base_reg_enc);\n+    int base_reg_enc = (reg_base \/ XMMRegister::max_slots_per_register);\n+    assert(base_reg_enc >= 0 && base_reg_enc < XMMRegister::number_of_registers, \"invalid XMMRegister: %d\", base_reg_enc);\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,4 +29,4 @@\n-REGISTER_IMPL_DEFINITION(Register, RegisterImpl, RegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(XMMRegister, XMMRegisterImpl, XMMRegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(KRegister, KRegisterImpl, KRegisterImpl::number_of_registers);\n+Register::RegisterImpl           all_RegisterImpls     [Register::number_of_registers      + 1];\n+FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers + 1];\n+XMMRegister::XMMRegisterImpl     all_XMMRegisterImpls  [XMMRegister::number_of_registers   + 1];\n+KRegister::KRegisterImpl         all_KRegisterImpls    [KRegister::number_of_registers     + 1];\n@@ -34,14 +34,1 @@\n-#ifndef AMD64\n-const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers;\n-#else\n-const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers << 1;\n-#endif \/\/ AMD64\n-\n-const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::max_gpr +\n-    2 * FloatRegisterImpl::number_of_registers;\n-const int ConcreteRegisterImpl::max_xmm = ConcreteRegisterImpl::max_fpr +\n-    XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers;\n-const int ConcreteRegisterImpl::max_kpr = ConcreteRegisterImpl::max_xmm +\n-    KRegisterImpl::max_slots_per_register * KRegisterImpl::number_of_registers;\n-\n-const char* RegisterImpl::name() const {\n+const char * Register::RegisterImpl::name() const {\n@@ -49,3 +36,1 @@\n-#ifndef AMD64\n-    \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"\n-#else\n+#ifdef _LP64\n@@ -54,1 +39,3 @@\n-#endif \/\/ AMD64\n+#else\n+    \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"\n+#endif \/\/ _LP64\n@@ -59,1 +46,1 @@\n-const char* FloatRegisterImpl::name() const {\n+const char* FloatRegister::FloatRegisterImpl::name() const {\n@@ -63,1 +50,1 @@\n-  return is_valid() ? names[encoding()] : \"noreg\";\n+  return is_valid() ? names[encoding()] : \"fnoreg\";\n@@ -66,1 +53,1 @@\n-const char* XMMRegisterImpl::name() const {\n+const char* XMMRegister::XMMRegisterImpl::name() const {\n@@ -68,2 +55,2 @@\n-    \"xmm0\",\"xmm1\",\"xmm2\",\"xmm3\",\"xmm4\",\"xmm5\",\"xmm6\",\"xmm7\"\n-#ifdef AMD64\n+    \"xmm0\",    \"xmm1\",  \"xmm2\",  \"xmm3\",  \"xmm4\",  \"xmm5\",  \"xmm6\",  \"xmm7\"\n+#ifdef _LP64\n@@ -73,1 +60,1 @@\n-#endif \/\/ AMD64\n+#endif \/\/ _LP64\n@@ -78,26 +65,1 @@\n-const char* XMMRegisterImpl::sub_word_name(int i) const {\n-  const char* names[number_of_registers * 8] = {\n-      \"xmm0:0\", \"xmm0:1\", \"xmm0:2\", \"xmm0:3\", \"xmm0:4\", \"xmm0:5\", \"xmm0:6\", \"xmm0:7\",\n-      \"xmm1:0\", \"xmm1:1\", \"xmm1:2\", \"xmm1:3\", \"xmm1:4\", \"xmm1:5\", \"xmm1:6\", \"xmm1:7\",\n-      \"xmm2:0\", \"xmm2:1\", \"xmm2:2\", \"xmm2:3\", \"xmm2:4\", \"xmm2:5\", \"xmm2:6\", \"xmm2:7\",\n-      \"xmm3:0\", \"xmm3:1\", \"xmm3:2\", \"xmm3:3\", \"xmm3:4\", \"xmm3:5\", \"xmm3:6\", \"xmm3:7\",\n-      \"xmm4:0\", \"xmm4:1\", \"xmm4:2\", \"xmm4:3\", \"xmm4:4\", \"xmm4:5\", \"xmm4:6\", \"xmm4:7\",\n-      \"xmm5:0\", \"xmm5:1\", \"xmm5:2\", \"xmm5:3\", \"xmm5:4\", \"xmm5:5\", \"xmm5:6\", \"xmm5:7\",\n-      \"xmm6:0\", \"xmm6:1\", \"xmm6:2\", \"xmm6:3\", \"xmm6:4\", \"xmm6:5\", \"xmm6:6\", \"xmm6:7\",\n-      \"xmm7:0\", \"xmm7:1\", \"xmm7:2\", \"xmm7:3\", \"xmm7:4\", \"xmm7:5\", \"xmm7:6\", \"xmm7:7\",\n-#ifdef AMD64\n-      \"xmm8:0\", \"xmm8:1\", \"xmm8:2\", \"xmm8:3\", \"xmm8:4\", \"xmm8:5\", \"xmm8:6\", \"xmm8:7\",\n-      \"xmm9:0\", \"xmm9:1\", \"xmm9:2\", \"xmm9:3\", \"xmm9:4\", \"xmm9:5\", \"xmm9:6\", \"xmm9:7\",\n-      \"xmm10:0\", \"xmm10:1\", \"xmm10:2\", \"xmm10:3\", \"xmm10:4\", \"xmm10:5\", \"xmm10:6\", \"xmm10:7\",\n-      \"xmm11:0\", \"xmm11:1\", \"xmm11:2\", \"xmm11:3\", \"xmm11:4\", \"xmm11:5\", \"xmm11:6\", \"xmm11:7\",\n-      \"xmm12:0\", \"xmm12:1\", \"xmm12:2\", \"xmm12:3\", \"xmm12:4\", \"xmm12:5\", \"xmm12:6\", \"xmm12:7\",\n-      \"xmm13:0\", \"xmm13:1\", \"xmm13:2\", \"xmm13:3\", \"xmm13:4\", \"xmm13:5\", \"xmm13:6\", \"xmm13:7\",\n-      \"xmm14:0\", \"xmm14:1\", \"xmm14:2\", \"xmm14:3\", \"xmm14:4\", \"xmm14:5\", \"xmm14:6\", \"xmm14:7\",\n-      \"xmm15:0\", \"xmm15:1\", \"xmm15:2\", \"xmm15:3\", \"xmm15:4\", \"xmm15:5\", \"xmm15:6\", \"xmm15:7\",\n-#endif \/\/ AMD64\n-  };\n-  assert(i >= 0 && i < 8, \"offset too large\");\n-  return is_valid() ? names[encoding() * 8 + i] : \"xnoreg\";\n-}\n-\n-const char* KRegisterImpl::name() const {\n+const char* KRegister::KRegisterImpl::name() const {\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.cpp","additions":16,"deletions":54,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -36,3 +36,4 @@\n-\/\/ Use Register as shortcut\n-class RegisterImpl;\n-typedef RegisterImpl* Register;\n+\/\/ The implementation of integer registers for the x86\/x64 architectures.\n+class Register {\n+private:\n+  int _encoding;\n@@ -40,6 +41,1 @@\n-\/\/ The implementation of integer registers for the ia32 architecture\n-\n-inline constexpr Register as_Register(int encoding);\n-\n-class RegisterImpl: public AbstractRegisterImpl {\n-  static constexpr Register first();\n+  constexpr Register(int encoding, bool unused) : _encoding(encoding) {}\n@@ -48,0 +44,2 @@\n+  inline friend constexpr Register as_Register(int encoding);\n+\n@@ -49,9 +47,3 @@\n-#ifndef AMD64\n-    number_of_registers      = 8,\n-    number_of_byte_registers = 4,\n-    max_slots_per_register   = 1\n-#else\n-    number_of_registers      = 16,\n-    number_of_byte_registers = 16,\n-    max_slots_per_register   = 2\n-#endif \/\/ AMD64\n+    number_of_registers      = LP64_ONLY( 16 ) NOT_LP64( 8 ),\n+    number_of_byte_registers = LP64_ONLY( 16 ) NOT_LP64( 4 ),\n+    max_slots_per_register   = LP64_ONLY(  2 ) NOT_LP64( 1 )\n@@ -60,2 +52,19 @@\n-  \/\/ derived registers, offsets, and addresses\n-  Register successor() const                          { return as_Register(encoding() + 1); }\n+  class RegisterImpl: public AbstractRegisterImpl {\n+    friend class Register;\n+\n+    static constexpr RegisterImpl* first();\n+\n+  public:\n+    \/\/ accessors\n+    int   raw_encoding() const      { return this - first(); }\n+    int   encoding() const          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    bool  has_byte_register() const { return 0 <= raw_encoding() && raw_encoding() < number_of_byte_registers; }\n+\n+    \/\/ derived registers, offsets, and addresses\n+    inline Register successor() const;\n+\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n@@ -63,2 +72,1 @@\n-  \/\/ construction\n-  inline constexpr friend Register as_Register(int encoding);\n+  constexpr Register() : _encoding(-1) {} \/\/ noreg\n@@ -66,1 +74,2 @@\n-  inline VMReg as_VMReg() const;\n+  int operator==(const Register r) const { return _encoding == r._encoding; }\n+  int operator!=(const Register r) const { return _encoding != r._encoding; }\n@@ -68,6 +77,1 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                     { return this - first(); }\n-  int   encoding() const                         { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                         { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  bool  has_byte_register() const                { return 0 <= raw_encoding() && raw_encoding() < number_of_byte_registers; }\n-  const char *name() const;\n+  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -76,1 +80,1 @@\n-REGISTER_IMPL_DECLARATION(Register, RegisterImpl, RegisterImpl::number_of_registers);\n+extern Register::RegisterImpl all_RegisterImpls[Register::number_of_registers + 1] INTERNAL_VISIBILITY;\n@@ -78,1 +82,5 @@\n-\/\/ The integer registers of the ia32\/amd64 architecture\n+inline constexpr Register::RegisterImpl* Register::RegisterImpl::first() {\n+  return all_RegisterImpls + 1;\n+}\n+\n+constexpr Register noreg = Register();\n@@ -80,1 +88,6 @@\n-CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));\n+inline constexpr Register as_Register(int encoding) {\n+  if (0 <= encoding && encoding < Register::number_of_registers) {\n+    return Register(encoding, false);\n+  }\n+  return noreg;\n+}\n@@ -82,0 +95,4 @@\n+inline Register Register::RegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_Register(encoding() + 1);\n+}\n@@ -83,18 +100,18 @@\n-CONSTANT_REGISTER_DECLARATION(Register, rax,    (0));\n-CONSTANT_REGISTER_DECLARATION(Register, rcx,    (1));\n-CONSTANT_REGISTER_DECLARATION(Register, rdx,    (2));\n-CONSTANT_REGISTER_DECLARATION(Register, rbx,    (3));\n-CONSTANT_REGISTER_DECLARATION(Register, rsp,    (4));\n-CONSTANT_REGISTER_DECLARATION(Register, rbp,    (5));\n-CONSTANT_REGISTER_DECLARATION(Register, rsi,    (6));\n-CONSTANT_REGISTER_DECLARATION(Register, rdi,    (7));\n-#ifdef AMD64\n-CONSTANT_REGISTER_DECLARATION(Register, r8,     (8));\n-CONSTANT_REGISTER_DECLARATION(Register, r9,     (9));\n-CONSTANT_REGISTER_DECLARATION(Register, r10,   (10));\n-CONSTANT_REGISTER_DECLARATION(Register, r11,   (11));\n-CONSTANT_REGISTER_DECLARATION(Register, r12,   (12));\n-CONSTANT_REGISTER_DECLARATION(Register, r13,   (13));\n-CONSTANT_REGISTER_DECLARATION(Register, r14,   (14));\n-CONSTANT_REGISTER_DECLARATION(Register, r15,   (15));\n-#endif \/\/ AMD64\n+constexpr Register rax = as_Register(0);\n+constexpr Register rcx = as_Register(1);\n+constexpr Register rdx = as_Register(2);\n+constexpr Register rbx = as_Register(3);\n+constexpr Register rsp = as_Register(4);\n+constexpr Register rbp = as_Register(5);\n+constexpr Register rsi = as_Register(6);\n+constexpr Register rdi = as_Register(7);\n+#ifdef _LP64\n+constexpr Register r8  = as_Register( 8);\n+constexpr Register r9  = as_Register( 9);\n+constexpr Register r10 = as_Register(10);\n+constexpr Register r11 = as_Register(11);\n+constexpr Register r12 = as_Register(12);\n+constexpr Register r13 = as_Register(13);\n+constexpr Register r14 = as_Register(14);\n+constexpr Register r15 = as_Register(15);\n+#endif \/\/ _LP64\n@@ -102,3 +119,0 @@\n-\/\/ Use FloatRegister as shortcut\n-class FloatRegisterImpl;\n-typedef const FloatRegisterImpl* FloatRegister;\n@@ -106,1 +120,4 @@\n-inline constexpr FloatRegister as_FloatRegister(int encoding);\n+\/\/ The implementation of x87 floating point registers for the ia32 architecture.\n+class FloatRegister {\n+private:\n+  int _encoding;\n@@ -108,3 +125,1 @@\n-\/\/ The implementation of floating point registers for the ia32 architecture\n-class FloatRegisterImpl: public AbstractRegisterImpl {\n-  static constexpr FloatRegister first();\n+  constexpr FloatRegister(int encoding, bool unused) : _encoding(encoding) {}\n@@ -113,0 +128,2 @@\n+  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n+\n@@ -114,1 +131,2 @@\n-    number_of_registers = 8\n+    number_of_registers    = 8,\n+    max_slots_per_register = 2\n@@ -117,2 +135,4 @@\n-  \/\/ construction\n-  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n+  class FloatRegisterImpl: public AbstractRegisterImpl {\n+    friend class FloatRegister;\n+\n+    static constexpr FloatRegisterImpl* first();\n@@ -120,1 +140,5 @@\n-  inline VMReg as_VMReg() const;\n+  public:\n+    \/\/ accessors\n+    int   raw_encoding() const { return this - first(); }\n+    int   encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const     { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -122,1 +146,2 @@\n-  \/\/ derived registers, offsets, and addresses\n+    \/\/ derived registers, offsets, and addresses\n+    inline FloatRegister successor() const;\n@@ -124,1 +149,4 @@\n-  FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n@@ -126,5 +154,1 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                      { return this - first(); }\n-  int   encoding() const                          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n+  constexpr FloatRegister() : _encoding(-1) {} \/\/ fnoreg\n@@ -132,0 +156,4 @@\n+  int operator==(const FloatRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const FloatRegister r) const { return _encoding != r._encoding; }\n+\n+  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n@@ -134,1 +162,1 @@\n-REGISTER_IMPL_DECLARATION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n+extern FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n@@ -136,1 +164,3 @@\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));\n+inline constexpr FloatRegister::FloatRegisterImpl* FloatRegister::FloatRegisterImpl::first() {\n+  return all_FloatRegisterImpls + 1;\n+}\n@@ -138,3 +168,13 @@\n-\/\/ Use XMMRegister as shortcut\n-class XMMRegisterImpl;\n-typedef XMMRegisterImpl* XMMRegister;\n+constexpr FloatRegister fnoreg = FloatRegister();\n+\n+inline constexpr FloatRegister as_FloatRegister(int encoding) {\n+  if (0 <= encoding && encoding < FloatRegister::number_of_registers) {\n+    return FloatRegister(encoding, false);\n+  }\n+  return fnoreg;\n+}\n+\n+inline FloatRegister FloatRegister::FloatRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_FloatRegister(encoding() + 1);\n+}\n@@ -142,1 +182,0 @@\n-inline constexpr XMMRegister as_XMMRegister(int encoding);\n@@ -145,2 +184,8 @@\n-class XMMRegisterImpl: public AbstractRegisterImpl {\n-  static constexpr XMMRegister first();\n+class XMMRegister {\n+private:\n+  int _encoding;\n+\n+  constexpr XMMRegister(int encoding, bool unused) : _encoding(encoding) {}\n+\n+public:\n+  inline friend constexpr XMMRegister as_XMMRegister(int encoding);\n@@ -148,1 +193,0 @@\n- public:\n@@ -150,7 +194,2 @@\n-#ifndef AMD64\n-    number_of_registers = 8,\n-    max_slots_per_register = 16   \/\/ 512-bit\n-#else\n-    number_of_registers = 32,\n-    max_slots_per_register = 16   \/\/ 512-bit\n-#endif \/\/ AMD64\n+    number_of_registers    = LP64_ONLY( 32 ) NOT_LP64(  8 ),\n+    max_slots_per_register = LP64_ONLY( 16 ) NOT_LP64( 16 )   \/\/ 512-bit\n@@ -159,2 +198,2 @@\n-  \/\/ construction\n-  friend constexpr XMMRegister as_XMMRegister(int encoding);\n+  class XMMRegisterImpl: public AbstractRegisterImpl {\n+    friend class XMMRegister;\n@@ -162,1 +201,1 @@\n-  inline VMReg as_VMReg() const;\n+    static constexpr XMMRegisterImpl* first();\n@@ -164,2 +203,5 @@\n-  \/\/ derived registers, offsets, and addresses\n-  XMMRegister successor() const                          { return as_XMMRegister(encoding() + 1); }\n+  public:\n+    \/\/ accessors\n+    int raw_encoding() const  { return this - first(); }\n+    int   encoding() const    { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -167,6 +209,2 @@\n-  \/\/ accessors\n-  int raw_encoding() const                       { return this - first(); }\n-  int   encoding() const                         { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                         { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n-  const char* sub_word_name(int offset) const;\n+    \/\/ derived registers, offsets, and addresses\n+    inline XMMRegister successor() const;\n@@ -174,2 +212,13 @@\n-  \/\/ Actually available XMM registers for use, depending on actual CPU capabilities\n-  \/\/ and flags.\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+  constexpr XMMRegister() : _encoding(-1) {} \/\/ xnoreg\n+\n+  int operator==(const XMMRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const XMMRegister r) const { return _encoding != r._encoding; }\n+\n+  const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n+\n+  \/\/ Actually available XMM registers for use, depending on actual CPU capabilities and flags.\n@@ -177,1 +226,0 @@\n-    int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n@@ -180,1 +228,1 @@\n-      num_xmm_regs \/= 2;\n+      return number_of_registers \/ 2;\n@@ -182,2 +230,2 @@\n-#endif\n-    return num_xmm_regs;\n+#endif \/\/ _LP64\n+    return number_of_registers;\n@@ -187,0 +235,5 @@\n+extern XMMRegister::XMMRegisterImpl all_XMMRegisterImpls[XMMRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr XMMRegister::XMMRegisterImpl* XMMRegister::XMMRegisterImpl::first() {\n+  return all_XMMRegisterImpls + 1;\n+}\n@@ -188,48 +241,56 @@\n-REGISTER_IMPL_DECLARATION(XMMRegister, XMMRegisterImpl, XMMRegisterImpl::number_of_registers);\n-\n-\/\/ The XMM registers, for P3 and up chips\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xnoreg , (-1));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm0 , ( 0));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm1 , ( 1));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm2 , ( 2));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm3 , ( 3));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm4 , ( 4));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm5 , ( 5));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm6 , ( 6));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm7 , ( 7));\n-#ifdef AMD64\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm8,      (8));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm9,      (9));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm10,    (10));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm11,    (11));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm12,    (12));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm13,    (13));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm14,    (14));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm15,    (15));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm16,    (16));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm17,    (17));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm18,    (18));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm19,    (19));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm20,    (20));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm21,    (21));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm22,    (22));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm23,    (23));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm24,    (24));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm25,    (25));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm26,    (26));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm27,    (27));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm28,    (28));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm29,    (29));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm30,    (30));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm31,    (31));\n-#endif \/\/ AMD64\n-\n-\/\/ Use KRegister as shortcut\n-class KRegisterImpl;\n-typedef KRegisterImpl* KRegister;\n-\n-inline constexpr KRegister as_KRegister(int encoding);\n-\n-\/\/ The implementation of AVX-3 (AVX-512) opmask registers.\n-class KRegisterImpl : public AbstractRegisterImpl {\n-  static constexpr KRegister first();\n+constexpr XMMRegister xnoreg = XMMRegister();\n+\n+inline constexpr XMMRegister as_XMMRegister(int encoding) {\n+  if (0 <= encoding && encoding < XMMRegister::number_of_registers) {\n+    return XMMRegister(encoding, false);\n+  }\n+  return xnoreg;\n+}\n+\n+inline XMMRegister XMMRegister::XMMRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_XMMRegister(encoding() + 1);\n+}\n+\n+constexpr XMMRegister xmm0  = as_XMMRegister( 0);\n+constexpr XMMRegister xmm1  = as_XMMRegister( 1);\n+constexpr XMMRegister xmm2  = as_XMMRegister( 2);\n+constexpr XMMRegister xmm3  = as_XMMRegister( 3);\n+constexpr XMMRegister xmm4  = as_XMMRegister( 4);\n+constexpr XMMRegister xmm5  = as_XMMRegister( 5);\n+constexpr XMMRegister xmm6  = as_XMMRegister( 6);\n+constexpr XMMRegister xmm7  = as_XMMRegister( 7);\n+#ifdef _LP64\n+constexpr XMMRegister xmm8  = as_XMMRegister( 8);\n+constexpr XMMRegister xmm9  = as_XMMRegister( 9);\n+constexpr XMMRegister xmm10 = as_XMMRegister(10);\n+constexpr XMMRegister xmm11 = as_XMMRegister(11);\n+constexpr XMMRegister xmm12 = as_XMMRegister(12);\n+constexpr XMMRegister xmm13 = as_XMMRegister(13);\n+constexpr XMMRegister xmm14 = as_XMMRegister(14);\n+constexpr XMMRegister xmm15 = as_XMMRegister(15);\n+constexpr XMMRegister xmm16 = as_XMMRegister(16);\n+constexpr XMMRegister xmm17 = as_XMMRegister(17);\n+constexpr XMMRegister xmm18 = as_XMMRegister(18);\n+constexpr XMMRegister xmm19 = as_XMMRegister(19);\n+constexpr XMMRegister xmm20 = as_XMMRegister(20);\n+constexpr XMMRegister xmm21 = as_XMMRegister(21);\n+constexpr XMMRegister xmm22 = as_XMMRegister(22);\n+constexpr XMMRegister xmm23 = as_XMMRegister(23);\n+constexpr XMMRegister xmm24 = as_XMMRegister(24);\n+constexpr XMMRegister xmm25 = as_XMMRegister(25);\n+constexpr XMMRegister xmm26 = as_XMMRegister(26);\n+constexpr XMMRegister xmm27 = as_XMMRegister(27);\n+constexpr XMMRegister xmm28 = as_XMMRegister(28);\n+constexpr XMMRegister xmm29 = as_XMMRegister(29);\n+constexpr XMMRegister xmm30 = as_XMMRegister(30);\n+constexpr XMMRegister xmm31 = as_XMMRegister(31);\n+#endif \/\/ _LP64\n+\n+\n+\/\/ The implementation of AVX-512 opmask registers.\n+class KRegister {\n+private:\n+  int _encoding;\n+\n+  constexpr KRegister(int encoding, bool unused) : _encoding(encoding) {}\n@@ -238,0 +299,2 @@\n+  inline friend constexpr KRegister as_KRegister(int encoding);\n+\n@@ -245,2 +308,4 @@\n-  \/\/ construction\n-  friend constexpr KRegister as_KRegister(int encoding);\n+  class KRegisterImpl: public AbstractRegisterImpl {\n+    friend class KRegister;\n+\n+    static constexpr KRegisterImpl* first();\n@@ -248,1 +313,1 @@\n-  inline VMReg as_VMReg() const;\n+  public:\n@@ -250,2 +315,4 @@\n-  \/\/ derived registers, offsets, and addresses\n-  KRegister successor() const                          { return as_KRegister(encoding() + 1); }\n+    \/\/ accessors\n+    int   raw_encoding() const { return this - first(); }\n+    int   encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const     { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -253,5 +320,14 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                      { return this - first(); }\n-  int   encoding() const                          { assert(is_valid(), \"invalid register (%d)\", (int)raw_encoding()); return raw_encoding(); }\n-  bool  is_valid() const                          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n+    \/\/ derived registers, offsets, and addresses\n+    inline KRegister successor() const;\n+\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+  constexpr KRegister() : _encoding(-1) {} \/\/ knoreg\n+\n+  int operator==(const KRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const KRegister r) const { return _encoding != r._encoding; }\n+\n+  const KRegisterImpl* operator->() const { return KRegisterImpl::first() + _encoding; }\n@@ -260,1 +336,28 @@\n-REGISTER_IMPL_DECLARATION(KRegister, KRegisterImpl, KRegisterImpl::number_of_registers);\n+extern KRegister::KRegisterImpl all_KRegisterImpls[KRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr KRegister::KRegisterImpl* KRegister::KRegisterImpl::first() {\n+  return all_KRegisterImpls + 1;\n+}\n+\n+constexpr KRegister knoreg = KRegister();\n+\n+inline constexpr KRegister as_KRegister(int encoding) {\n+  if (0 <= encoding && encoding < KRegister::number_of_registers) {\n+    return KRegister(encoding, false);\n+  }\n+  return knoreg;\n+}\n+\n+inline KRegister KRegister::KRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_KRegister(encoding() + 1);\n+}\n+\n+constexpr KRegister k0 = as_KRegister(0);\n+constexpr KRegister k1 = as_KRegister(1);\n+constexpr KRegister k2 = as_KRegister(2);\n+constexpr KRegister k3 = as_KRegister(3);\n+constexpr KRegister k4 = as_KRegister(4);\n+constexpr KRegister k5 = as_KRegister(5);\n+constexpr KRegister k6 = as_KRegister(6);\n+constexpr KRegister k7 = as_KRegister(7);\n@@ -262,10 +365,0 @@\n-\/\/ The Mask registers, for AVX3 enabled and up chips\n-CONSTANT_REGISTER_DECLARATION(KRegister, knoreg, (-1));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k0, (0));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k1, (1));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k2, (2));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k3, (3));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k4, (4));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k5, (5));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k6, (6));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k7, (7));\n@@ -278,14 +371,17 @@\n-  \/\/ A big enough number for C2: all the registers plus flags\n-  \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n-  \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n-  \/\/ it's optoregs.\n-\n-  \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n-  \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n-  \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n-  \/\/ added for 32 bit jvm.\n-    number_of_registers = RegisterImpl::number_of_registers * RegisterImpl::max_slots_per_register +\n-      2 * FloatRegisterImpl::number_of_registers + NOT_LP64(8) LP64_ONLY(0) +\n-      XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers +\n-      KRegisterImpl::number_of_registers * KRegisterImpl::max_slots_per_register + \/\/ mask registers\n-      1 \/\/ eflags\n+    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n+    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n+    max_xmm = max_fpr + XMMRegister::number_of_registers * XMMRegister::max_slots_per_register,\n+    max_kpr = max_xmm + KRegister::number_of_registers * KRegister::max_slots_per_register,\n+\n+    \/\/ A big enough number for C2: all the registers plus flags\n+    \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n+    \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n+    \/\/ it's optoregs.\n+\n+    \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n+    \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n+    \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n+    \/\/ added for 32 bit jvm.\n+    number_of_registers = max_kpr +       \/\/ gpr\/fpr\/xmm\/kpr\n+                          NOT_LP64( 8 + ) \/\/ FILL0-FILL7 in x86_32.ad\n+                          1               \/\/ eflags\n@@ -293,6 +389,0 @@\n-\n-  static const int max_gpr;\n-  static const int max_fpr;\n-  static const int max_xmm;\n-  static const int max_kpr;\n-\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":280,"deletions":190,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n+  int num_xmm_regs = XMMRegister::number_of_registers;\n@@ -135,1 +135,1 @@\n-  int opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+  int opmask_state_bytes = KRegister::number_of_registers * 8;\n@@ -202,1 +202,1 @@\n-  for (int n = 0; n < FloatRegisterImpl::number_of_registers; n++) {\n+  for (int n = 0; n < FloatRegister::number_of_registers; n++) {\n@@ -238,1 +238,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -271,1 +271,1 @@\n-  for (int n = 0; n < FloatRegisterImpl::number_of_registers; n++) {\n+  for (int n = 0; n < FloatRegister::number_of_registers; n++) {\n@@ -294,1 +294,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n+  int num_xmm_regs = XMMRegister::number_of_registers;\n@@ -307,1 +307,1 @@\n-      opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+      opmask_state_bytes = KRegister::number_of_registers * 8;\n@@ -348,1 +348,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -415,2 +415,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 32-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 32-bit\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_regs = XMMRegister::available_xmm_registers();\n@@ -226,1 +226,1 @@\n-      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for(int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -243,1 +243,1 @@\n-      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for(int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -366,1 +366,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_regs = XMMRegister::available_xmm_registers();\n@@ -406,1 +406,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -423,1 +423,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -467,2 +467,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 64-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 64-bit\n@@ -1809,3 +1809,3 @@\n-  bool reg_destroyed[RegisterImpl::number_of_registers];\n-  bool freg_destroyed[XMMRegisterImpl::number_of_registers];\n-  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+  bool reg_destroyed[Register::number_of_registers];\n+  bool freg_destroyed[XMMRegister::number_of_registers];\n+  for ( int r = 0 ; r < Register::number_of_registers ; r++ ) {\n@@ -1814,1 +1814,1 @@\n-  for ( int f = 0 ; f < XMMRegisterImpl::number_of_registers ; f++ ) {\n+  for ( int f = 0 ; f < XMMRegister::number_of_registers ; f++ ) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2207,1 +2207,1 @@\n-  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -2209,1 +2209,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n@@ -2218,1 +2218,1 @@\n-  void aes_enc_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void aes_enc_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -2225,1 +2225,1 @@\n-  void aes_dec_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void aes_dec_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -3509,3 +3509,3 @@\n-    const Register empty = 0; \/\/ will never be used, in order not\n-                              \/\/ to change a signature for crc32c_IPL_Alg2_Alt2\n-                              \/\/ between 64\/32 I'm just keeping it here\n+    const Register empty = noreg; \/\/ will never be used, in order not\n+                                  \/\/ to change a signature for crc32c_IPL_Alg2_Alt2\n+                                  \/\/ between 64\/32 I'm just keeping it here\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3569,1 +3569,1 @@\n-  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -3571,1 +3571,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n@@ -4977,9 +4977,6 @@\n-  void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = NULL) {\n-    __ movdqu(xmmdst, Address(key, offset));\n-    if (xmm_shuf_mask != NULL) {\n-      __ pshufb(xmmdst, xmm_shuf_mask);\n-    } else {\n-      __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n-    }\n-    __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n-\n+void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n+  __ movdqu(xmmdst, Address(key, offset));\n+  if (xmm_shuf_mask != xnoreg) {\n+    __ pshufb(xmmdst, xmm_shuf_mask);\n+  } else {\n+    __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n@@ -4987,0 +4984,3 @@\n+  __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n+\n+}\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    for (int j = 0 ; j < XMMRegisterImpl::max_slots_per_register ; j++) {\n+    for (int j = 0 ; j < XMMRegister::max_slots_per_register ; j++) {\n@@ -59,1 +59,1 @@\n-    for (int j = 0; j < KRegisterImpl::max_slots_per_register; j++) {\n+    for (int j = 0; j < KRegister::max_slots_per_register; j++) {\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    (XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::available_xmm_registers());\n+    (XMMRegister::max_slots_per_register * XMMRegister::available_xmm_registers());\n@@ -90,1 +90,1 @@\n-    return base % XMMRegisterImpl::max_slots_per_register == 0;\n+    return (base % XMMRegister::max_slots_per_register) == 0;\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,7 +28,2 @@\n-inline VMReg RegisterImpl::as_VMReg() const {\n-  if( this==noreg ) return VMRegImpl::Bad();\n-#ifdef AMD64\n-  return VMRegImpl::as_VMReg(encoding() << 1 );\n-#else\n-  return VMRegImpl::as_VMReg(encoding() );\n-#endif \/\/ AMD64\n+inline VMReg Register::RegisterImpl::as_VMReg() const {\n+  return VMRegImpl::as_VMReg(encoding() LP64_ONLY( << 1 ));\n@@ -37,1 +32,1 @@\n-inline VMReg FloatRegisterImpl::as_VMReg() const {\n+inline VMReg FloatRegister::FloatRegisterImpl::as_VMReg() const {\n@@ -41,1 +36,1 @@\n-inline VMReg XMMRegisterImpl::as_VMReg() const {\n+inline VMReg XMMRegister::XMMRegisterImpl::as_VMReg() const {\n@@ -45,1 +40,1 @@\n-inline VMReg KRegisterImpl::as_VMReg() const {\n+inline VMReg KRegister::KRegisterImpl::as_VMReg() const {\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.inline.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -258,1 +258,2 @@\n-#define   HIGH_FROM_LOW(x) ((x)+2)\n+#define   HIGH_FROM_LOW(x) (as_Register((x)->encoding()+2))\n+#define   HIGH_FROM_LOW_ENC(x) ((x)+2)\n@@ -1653,1 +1654,1 @@\n-    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -1664,1 +1665,1 @@\n-    int desthi = HIGH_FROM_LOW(destlo);\n+    int desthi = HIGH_FROM_LOW_ENC(destlo);\n@@ -1949,1 +1950,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1957,1 +1958,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1961,1 +1962,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2086,1 +2087,1 @@\n-    int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  \/\/ Hi register of pair, computed from lo\n+    int reg_encoding = HIGH_FROM_LOW_ENC($ereg$$reg);  \/\/ Hi register of pair, computed from lo\n@@ -2097,2 +2098,2 @@\n-    if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }\n-    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }\n+    if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW_ENC($dst$$reg); }\n+    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW_ENC($dst$$reg); }\n@@ -2110,1 +2111,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2117,1 +2118,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2123,2 +2124,2 @@\n-    if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }\n-    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }\n+    if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW_ENC($dst$$reg); }\n+    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW_ENC($dst$$reg); }\n@@ -2268,1 +2269,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2276,1 +2277,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2292,1 +2293,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2295,1 +2296,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2300,1 +2301,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2303,1 +2304,1 @@\n-    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2316,1 +2317,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2319,1 +2320,1 @@\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2325,1 +2326,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2328,1 +2329,1 @@\n-    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2658,1 +2659,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2674,1 +2675,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );\n+    encode_Copy( cbuf, HIGH_FROM_LOW_ENC(dst_encoding), src_encoding );\n@@ -2677,1 +2678,1 @@\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );\n+    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC(dst_encoding) );\n@@ -2683,1 +2684,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));\n+    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2713,1 +2714,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));\n+    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2745,1 +2746,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2747,1 +2748,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );\n+    encode_Copy( cbuf, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2751,1 +2752,1 @@\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );\n+    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2754,1 +2755,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2760,1 +2761,1 @@\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );\n+    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $tmp$$reg );\n@@ -2768,1 +2769,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2783,1 +2784,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2787,1 +2788,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2804,1 +2805,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2808,1 +2809,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2829,1 +2830,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2841,1 +2842,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2850,1 +2851,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src1$$reg) );\n@@ -2853,1 +2854,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2865,1 +2866,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2871,1 +2872,1 @@\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2875,1 +2876,1 @@\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":46,"deletions":45,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -143,1 +143,3 @@\n-    assert(start <= end, \"must be\");\n+    int start_enc = start->encoding();\n+    int   end_enc = end->encoding();\n+    assert(start_enc <= end_enc, \"must be\");\n@@ -145,3 +147,3 @@\n-    bits <<= start->encoding();\n-    bits <<= 31 - end->encoding();\n-    bits >>= 31 - end->encoding();\n+    bits <<= start_enc;\n+    bits <<= 31 - end_enc;\n+    bits >>= 31 - end_enc;\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2555,1 +2555,0 @@\n-  declare_constant(RegisterImpl::number_of_registers)                     \\\n@@ -2557,1 +2556,1 @@\n-  declare_preprocessor_constant(\"REG_COUNT\", REG_COUNT)                \\\n+  declare_preprocessor_constant(\"REG_COUNT\", REG_COUNT)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}