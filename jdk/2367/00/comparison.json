{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import java.util.Set;\n@@ -318,1 +319,1 @@\n-        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className(), classFile)\n+        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className(), classFile, Set.of())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -52,0 +53,1 @@\n+import java.util.Set;\n@@ -57,0 +59,1 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n@@ -1133,1 +1136,1 @@\n-\n+        private static final String INVOKER_SUFFIX = \"$$InjectedInvoker\";\n@@ -1136,1 +1139,1 @@\n-            \/\/ functional interface instances created from method references to @CallerSensitive  methods,\n+            \/\/ functional interface instances created from method references to @CallerSensitive methods,\n@@ -1145,0 +1148,34 @@\n+\n+            MemberName member = mh.internalMemberName();\n+            if (member != null) {\n+                \/\/ Look up the alternate non-CSM method named \"reflected$<method-name>\"\n+                \/\/ with an additional trailing caller class parameter.  If present,\n+                \/\/ bind the alternate method handle with the lookup class as\n+                \/\/ the caller class argument\n+                MemberName alt = IMPL_LOOKUP.resolveOrNull(member.getReferenceKind(),\n+                            new MemberName(member.getDeclaringClass(),\n+                                           \"reflected$\" + member.getName(),\n+                                           member.getMethodType().appendParameterTypes(Class.class),\n+                                           member.getReferenceKind()));\n+                if (alt != null) {\n+                    assert !alt.isCallerSensitive();\n+                    MethodHandle dmh = DirectMethodHandle.make(alt);\n+                    dmh = MethodHandles.insertArguments(dmh, dmh.type().parameterCount() - 1, hostClass);\n+                    dmh = new WrappedMember(dmh, mh.type(), member, mh.isInvokeSpecial(), hostClass);\n+                    return dmh;\n+                }\n+            }\n+\n+            \/\/ If no alternate method for CSM with an additional trailing Class\n+            \/\/ parameter is present, then inject an invoker class that is the caller\n+            \/\/ invoking the method handle of the CSM\n+            try {\n+                return bindCallerWithInjectedInvoker(mh, hostClass);\n+            } catch (ReflectiveOperationException ex) {\n+                throw uncaughtException(ex);\n+            }\n+        }\n+\n+        private static MethodHandle bindCallerWithInjectedInvoker(MethodHandle mh, Class<?> hostClass)\n+                throws ReflectiveOperationException\n+        {\n@@ -1148,1 +1185,2 @@\n-            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);\n+            Class<?> invokerClass = CV_makeInjectedInvoker.get(hostClass);\n+            MethodHandle bccInvoker = IMPL_LOOKUP.findStatic(invokerClass, \"invoke_V\", INVOKER_MT);\n@@ -1152,13 +1190,46 @@\n-        private static MethodHandle makeInjectedInvoker(Class<?> targetClass) {\n-            try {\n-                \/*\n-                 * The invoker class defined to the same class loader as the lookup class\n-                 * but in an unnamed package so that the class bytes can be cached and\n-                 * reused for any @CSM.\n-                 *\n-                 * @CSM must be public and exported if called by any module.\n-                 *\/\n-                String name = targetClass.getName() + \"$$InjectedInvoker\";\n-                if (targetClass.isHidden()) {\n-                    \/\/ use the original class name\n-                    name = name.replace('\/', '_');\n+        private static Class<?> makeInjectedInvoker(Class<?> targetClass) {\n+            \/*\n+             * The invoker class defined to the same class loader as the lookup class\n+             * but in an unnamed package so that the class bytes can be cached and\n+             * reused for any @CSM.\n+             *\n+             * @CSM must be public and exported if called by any module.\n+             *\/\n+            String name = targetClass.getName() + INVOKER_SUFFIX;\n+            if (targetClass.isHidden()) {\n+                \/\/ use the original class name\n+                name = name.replace('\/', '_');\n+            }\n+            Class<?> invokerClass = new Lookup(targetClass)\n+                    .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, Set.of(NESTMATE))\n+                    .defineClass(true, targetClass);\n+            assert checkInjectedInvoker(targetClass, invokerClass);\n+            return invokerClass;\n+        }\n+\n+        \/*\n+         * If the given invoker class is a hidden InjectedInvoker class,\n+         * this method returns the class that is stored as the class data of\n+         * the injected invoker class which is the lookup class bound to\n+         * the method handle for a caller-sensitive method at lookup time.\n+         * Otherwise, this method returns null.\n+         *\n+         * An injected invoker class has the same defining class loader,\n+         * runtime package, and protection domain as the lookup class that\n+         * looks up the caller-sensitive method.\n+         *\/\n+        private static Class<?> callerForInvoker(Class<?> invoker) {\n+            if (invoker.isHidden() && invoker.getName().contains(INVOKER_SUFFIX)) {\n+                Lookup lookup = new Lookup(invoker);\n+                try {\n+                    Object cd = MethodHandles.classData(lookup, ConstantDescs.DEFAULT_NAME, Object.class);\n+                    if (cd instanceof Class c) {\n+                        \/\/ If a hidden class matching the injected invoker name but not injected\n+                        \/\/ by BindCaller calls MethodHandles.lookup(), then an invoker class\n+                        \/\/ will be defined but unused. This should be rare case.\n+                        if (invoker.isNestmateOf(c) && BindCaller.CV_makeInjectedInvoker.get(c) == invoker) {\n+                            return c;\n+                        }\n+                    }\n+                } catch (IllegalAccessException e) {\n+                    throw new InternalError(e);\n@@ -1166,7 +1237,0 @@\n-                Class<?> invokerClass = new Lookup(targetClass)\n-                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE)\n-                        .defineClass(true);\n-                assert checkInjectedInvoker(targetClass, invokerClass);\n-                return IMPL_LOOKUP.findStatic(invokerClass, \"invoke_V\", INVOKER_MT);\n-            } catch (ReflectiveOperationException ex) {\n-                throw uncaughtException(ex);\n@@ -1174,0 +1238,1 @@\n+            return null;\n@@ -1176,2 +1241,2 @@\n-        private static ClassValue<MethodHandle> CV_makeInjectedInvoker = new ClassValue<MethodHandle>() {\n-            @Override protected MethodHandle computeValue(Class<?> hostClass) {\n+        private static ClassValue<Class<?>> CV_makeInjectedInvoker = new ClassValue<Class<?>>() {\n+            @Override protected Class<?> computeValue(Class<?> hostClass) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":90,"deletions":25,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-        return new Lookup(Reflection.getCallerClass());\n+        Class<?> caller = Reflection.getCallerClass();\n+        return new Lookup(caller);\n@@ -134,0 +135,9 @@\n+    \/**\n+     * This reflected$lookup method is the alternate implementation of\n+     * the lookup method with a trailing caller class argument which is\n+     * non-caller-sensitive.\n+     *\/\n+    private static Lookup reflected$lookup(Class<?> caller) {\n+        return new Lookup(caller);\n+    }\n+\n@@ -2372,1 +2382,1 @@\n-         * from the given bytes.  No package name check on the given name.\n+         * from the given bytes and the given options.  No package name check on the given name.\n@@ -2376,1 +2386,2 @@\n-         * @return ClassDefiner that defines a hidden class of the given bytes.\n+         * @param options class options\n+         * @return ClassDefiner that defines a hidden class of the given bytes and options.\n@@ -2378,1 +2389,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {\n+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, Set<ClassOption> options) {\n@@ -2380,1 +2391,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), Set.of(), false);\n+            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8196830 8235351\n+ * @bug 8196830 8235351 8257874\n@@ -358,0 +358,34 @@\n+    \/**\n+     * Field::getInt and Field::setInt are caller-sensitive methods.\n+     * Test access to private field.\n+     *\/\n+    private static int privateField = 0;\n+    @Test\n+    public void testPrivateField() throws Throwable {\n+        Field f = CallerSensitiveAccess.class.getDeclaredField(\"privateField\");\n+        \/\/ Field::setInt\n+        MethodType mtype = MethodType.methodType(void.class, Object.class, int.class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(Field.class, \"setInt\", mtype);\n+        mh.invokeExact(f, (Object)null, 5);\n+        \/\/ Field::getInt\n+        mh = MethodHandles.lookup().findVirtual(Field.class, \"getInt\", MethodType.methodType(int.class, Object.class));\n+        int value = (int)mh.invokeExact(f, (Object)null);\n+        assertTrue(value == 5);\n+    }\n+\n+    private static class Inner {\n+        private static boolean privateField = false;\n+    }\n+\n+    @Test\n+    public void testInnerPrivateField() throws Throwable {\n+        Field f = Inner.class.getDeclaredField(\"privateField\");\n+        \/\/ Field::setInt\n+        MethodType mtype = MethodType.methodType(void.class, Object.class, boolean.class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(Field.class, \"setBoolean\", mtype);\n+        mh.invokeExact(f, (Object)null, true);\n+        \/\/ Field::getInt\n+        mh = MethodHandles.lookup().findVirtual(Field.class, \"getBoolean\", MethodType.methodType(boolean.class, Object.class));\n+        boolean value = (boolean)mh.invokeExact(f, (Object)null);\n+        assertTrue(value);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/CallerSensitiveAccess.java","additions":35,"deletions":1,"binary":false,"changes":36,"previous_filename":"test\/jdk\/java\/lang\/invoke\/CallerSensitiveAccess.java","status":"renamed"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8013527\n+ * @library src\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build java.base\/java.util.CSM csm\/*\n+ * @run main\/othervm csm\/jdk.test.MethodInvokeTest\n+ * @run main\/othervm csm\/jdk.test.MethodInvokeTest sm\n+ * @summary Test proper caller class is bound to method handle for caller-sensitive method\n+ *\/\n+public class Main {\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/Main.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test;\n+\n+import java.lang.StackWalker.StackFrame;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.util.CSM;\n+import java.security.Permission;\n+import java.security.PermissionCollection;\n+import java.security.Permissions;\n+import java.security.Policy;\n+import java.security.ProtectionDomain;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * This test invokes caller-sensitive methods via static reference,\n+ * reflection, MethodHandle, lambda.  If there is no alternate implementation\n+ * of a CSM with a trailing caller class parameter, when a CSM is invoked\n+ * via method handle, an invoker class is injected as the caller class\n+ * which is defined by the same defining class loader, in the same runtime\n+ * package, and protection domain as the lookup class.\n+ *\/\n+public class MethodInvokeTest {\n+    static final Policy DEFAULT_POLICY = Policy.getPolicy();\n+    private static final String CALLER_METHOD = \"caller\";\n+    private static final String CALLER_NO_ALT_METHOD = \"callerNoAlternateImpl\";\n+\n+    public static void main(String... args) throws Throwable {\n+        boolean sm = args.length > 0 && args[0].equals(\"sm\");\n+        System.err.format(\"Test %s security manager.%n\",\n+                          sm ? \"with\" : \"without\");\n+        if (sm) {\n+            setupSecurityManager();\n+        }\n+\n+        MethodInvokeTest test = new MethodInvokeTest();\n+        \/\/ test static call to java.util.CSM::caller\n+        test.staticMethodCall();\n+        \/\/ test java.lang.reflect.Method call\n+        test.reflectMethodCall();\n+        \/\/ test java.lang.invoke.MethodHandle\n+        test.invokeMethodHandle();\n+        \/\/ test method ref\n+        test.lambda();\n+    }\n+\n+    static void setupSecurityManager() {\n+        PermissionCollection perms = new Permissions();\n+        perms.add(new RuntimePermission(\"getStackWalkerWithClassReference\"));\n+        Policy.setPolicy(new Policy() {\n+            @Override\n+            public boolean implies(ProtectionDomain domain, Permission p) {\n+                return perms.implies(p) || DEFAULT_POLICY.implies(domain, p);\n+            }\n+        });\n+        System.setSecurityManager(new SecurityManager());\n+    }\n+\n+    void staticMethodCall() {\n+        checkCaller(java.util.CSM.caller(), MethodInvokeTest.class);\n+        checkCaller(java.util.CSM.callerNoAlternateImpl(), MethodInvokeTest.class);\n+    }\n+\n+    void reflectMethodCall() throws Throwable {\n+        checkCaller(Caller1.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller1.class);\n+        checkCaller(Caller2.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller2.class);\n+        checkCaller(Caller1.invoke(CSM.class.getMethod(CALLER_NO_ALT_METHOD)), Caller1.class);\n+        checkCaller(Caller2.invoke(CSM.class.getMethod(CALLER_NO_ALT_METHOD)), Caller2.class);\n+    }\n+\n+    void invokeMethodHandle() throws Throwable {\n+        checkCaller(Caller1.invokeExact(CALLER_METHOD), Caller1.class);\n+        checkCaller(Caller2.invokeExact(CALLER_METHOD), Caller2.class);\n+\n+        checkInjectedInvoker(Caller1.invokeExact(CALLER_NO_ALT_METHOD), Caller1.class);\n+        checkInjectedInvoker(Caller2.invokeExact(CALLER_NO_ALT_METHOD), Caller2.class);\n+    }\n+\n+    void lambda() {\n+        CSM caller = LambdaTest.caller.get();\n+        LambdaTest.checkLambdaProxyClass(caller);\n+\n+        caller = LambdaTest.caller();\n+        LambdaTest.checkLambdaProxyClass(caller);\n+    }\n+\n+    static class Caller1 {\n+        static CSM invoke(Method csm) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null);\n+        }\n+        static CSM invokeExact(String methodName) throws Throwable {\n+            MethodHandle mh = MethodHandles.lookup().findStatic(java.util.CSM.class,\n+                    methodName, MethodType.methodType(CSM.class));\n+            return (CSM)mh.invokeExact();\n+        }\n+    }\n+\n+    static class Caller2 {\n+        static CSM invoke(Method csm) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null);\n+        }\n+        static CSM invokeExact(String methodName) throws Throwable {\n+            MethodHandle mh = MethodHandles.lookup().findStatic(java.util.CSM.class,\n+                    methodName, MethodType.methodType(CSM.class));\n+            return (CSM)mh.invokeExact();\n+        }\n+    }\n+\n+    static class LambdaTest {\n+        static Supplier<CSM> caller = java.util.CSM::caller;\n+\n+        static CSM caller() {\n+            return caller.get();\n+        }\n+\n+        \/*\n+         * The class calling the caller-sensitive method is the lambda proxy class\n+         * generated for LambdaTest.\n+         *\/\n+        static void checkLambdaProxyClass(CSM csm) {\n+            Class<?> caller = csm.caller;\n+            assertTrue(caller.isHidden(), caller + \" should be a hidden class\");\n+            assertEquals(caller.getModule(), LambdaTest.class.getModule());\n+\n+            int index = caller.getName().indexOf('\/');\n+            String cn = caller.getName().substring(0, index);\n+            assertTrue(cn.startsWith(LambdaTest.class.getName() + \"$$Lambda$\"), caller + \" should be a lambda proxy class\");\n+        }\n+    }\n+    static void checkCaller(CSM csm, Class<?> expected) {\n+        assertEquals(csm.caller, expected);\n+        \/\/ verify no invoker class injected\n+        for (StackFrame frame : csm.stackFrames) {\n+            Class<?> c = frame.getDeclaringClass();\n+            if (c == expected) break;\n+\n+            if (c.getName().startsWith(expected.getName() + \"$$InjectedInvoker\"))\n+                throw new RuntimeException(\"should not have any invoker class injected\");\n+        }\n+    }\n+\n+    \/*\n+     * The class calling the direct method handle of the caller-sensitive class\n+     * is the InjectedInvoker class generated for the given caller.\n+     *\/\n+    static void checkInjectedInvoker(CSM csm, Class<?> expected) {\n+        Class<?> invoker = csm.caller;\n+        assertTrue(invoker.isHidden(), invoker + \" should be a hidden class\");\n+        assertEquals(invoker.getModule(), expected.getModule());\n+\n+        int index = invoker.getName().indexOf('\/');\n+        String cn = invoker.getName().substring(0, index);\n+        assertEquals(cn, expected.getName() + \"$$InjectedInvoker\");\n+\n+        \/\/ check the invoker class on the stack\n+        for (StackFrame frame : csm.stackFrames) {\n+            Class<?> c = frame.getDeclaringClass();\n+            if (c.getName().startsWith(expected.getName() + \"$$InjectedInvoker\"))\n+                break;\n+\n+            if (c == expected)\n+                throw new RuntimeException(\"no invoker class found before the expected caller class\");\n+        }\n+    }\n+\n+    static void assertTrue(boolean value, String msg) {\n+        if (!value) {\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+    static void assertEquals(Object o1, Object o2) {\n+        if (!o1.equals(o2)) {\n+            throw new RuntimeException(o1 + \" != \" + o2);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/csm\/jdk\/test\/MethodInvokeTest.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module csm {\n+    exports jdk.test;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/csm\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.StackWalker.StackFrame;\n+import java.util.stream.Stream;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import static java.lang.StackWalker.Option.*;\n+\n+public class CSM {\n+    public final Class<?> caller;\n+    public final List<StackFrame> stackFrames;\n+    CSM(Class<?> caller) {\n+        this.caller = caller;\n+        StackWalker sw = StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE, SHOW_HIDDEN_FRAMES));\n+        this.stackFrames = sw.walk(Stream::toList);\n+    }\n+\n+    \/**\n+     * Returns the caller of this caller-sensitive method returned by\n+     * by Reflection::getCallerClass except if this method is called\n+     * via method handle.\n+     *\/\n+    @CallerSensitive\n+    public static CSM caller() {\n+        return new CSM(Reflection.getCallerClass());\n+    }\n+\n+    \/**\n+     * If caller() is invoked via method handle, this alternate method is\n+     * called instead.  The caller class would be the lookup class.\n+     *\/\n+    private static CSM reflected$caller(Class<?> caller) {\n+        return new CSM(caller);\n+    }\n+\n+    \/**\n+     * Returns the caller of this caller-sensitive method returned by\n+     * by Reflection::getCallerClass.\n+     *\/\n+    @CallerSensitive\n+    public static CSM callerNoAlternateImpl() {\n+        return new CSM(Reflection.getCallerClass());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/src\/java.base\/java\/util\/CSM.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8013527\n+ * @run testng\/othervm ChainedLookupTest\n+ * @summary Test MethodHandles.lookup method to produce the Lookup object with\n+ *          proper lookup class if invoked through reflection and method handle.\n+ *\/\n+\n+import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Method;\n+\n+import org.testng.annotations.Test;\n+\n+import static java.lang.invoke.MethodHandles.*;\n+import static java.lang.invoke.MethodType.*;\n+import static org.testng.Assert.*;\n+\n+public class ChainedLookupTest {\n+    \/**\n+     * Direct call to MethodHandles::lookup\n+     *\/\n+    @Test()\n+    void staticLookup() throws Throwable {\n+        Lookup lookup =  lookup();\n+        test(lookup, \"Lookup produced via direct call to MethodHandles.lookup()\");\n+    }\n+\n+    \/**\n+     * Reflective Method::invoke on MethodHandles::lookup\n+     *\/\n+    @Test()\n+    void methodInvoke() throws Throwable {\n+        Method m =  MethodHandles.class.getMethod(\"lookup\");\n+        Lookup lookup = (Lookup) m.invoke(null);\n+\n+        test(lookup, \"Lookup produced via reflective call\");\n+    }\n+\n+    \/**\n+     * MethodHandle::invokeExaxt on MethodHandles::lookup\n+     *\/\n+    @Test()\n+    void methodHandle() throws Throwable {\n+        MethodHandle MH_lookup2 = publicLookup().findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup = (Lookup) MH_lookup2.invokeExact();\n+\n+        test(lookup, \"Lookup produced via MethodHandle\");\n+    }\n+\n+    \/**\n+     * MethodHandles::unreflect the reflective Method representing MethodHandles::lookup\n+     *\/\n+    @Test()\n+    void unreflect() throws Throwable {\n+        MethodHandle MH_lookup = lookup().unreflect(MethodHandles.class.getMethod(\"lookup\"));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+\n+        test(lookup, \"Lookup produced via unreflect MethodHandle\");\n+    }\n+\n+    \/**\n+     * Use the Lookup object returned from MethodHandle::invokeExact on MethodHandles::lookup\n+     * to look up MethodHandle representing MethodHandles::lookup and then invoking it.\n+     *\/\n+    @Test()\n+    void chainedMethodHandle() throws Throwable {\n+        MethodHandle MH_lookup = lookup().findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+        MethodHandle MH_lookup2 = lookup.unreflect(MethodHandles.class.getMethod(\"lookup\"));\n+        Lookup lookup2 = (Lookup) MH_lookup2.invokeExact();\n+\n+        test(lookup2, \"Lookup produced via a chained call to MethodHandle\");\n+    }\n+\n+    void test(Lookup lookup, String msg) throws Throwable {\n+        assertTrue(lookup.lookupClass() == ChainedLookupTest.class);\n+        assertTrue(lookup.hasFullPrivilegeAccess());\n+\n+        MethodHandle mh = lookup.findStatic(lookup.lookupClass(), \"say\", methodType(void.class, String.class));\n+        mh.invokeExact(msg);\n+    }\n+\n+    private static void say(String msg) {\n+        System.out.println(msg);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/ChainedLookupTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -38,0 +39,1 @@\n+import java.util.Map;\n@@ -40,0 +42,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -65,7 +68,16 @@\n-      Set.of(\"java\/io\/ObjectStreamField#getType ()Ljava\/lang\/Class;\",\n-             \"java\/io\/ObjectStreamClass#forClass ()Ljava\/lang\/Class;\",\n-             \"java\/lang\/Runtime#load (Ljava\/lang\/String;)V\",\n-             \"java\/lang\/Runtime#loadLibrary (Ljava\/lang\/String;)V\",\n-             \"java\/lang\/Thread#getContextClassLoader ()Ljava\/lang\/ClassLoader;\",\n-             \"javax\/sql\/rowset\/serial\/SerialJavaObject#getFields ()[Ljava\/lang\/reflect\/Field;\"\n-      );\n+        Set.of(\"java\/io\/ObjectStreamField#getType ()Ljava\/lang\/Class;\",\n+               \"java\/io\/ObjectStreamClass#forClass ()Ljava\/lang\/Class;\",\n+               \"java\/lang\/Runtime#load (Ljava\/lang\/String;)V\",\n+               \"java\/lang\/Runtime#loadLibrary (Ljava\/lang\/String;)V\",\n+               \"java\/lang\/Thread#getContextClassLoader ()Ljava\/lang\/ClassLoader;\",\n+               \"javax\/sql\/rowset\/serial\/SerialJavaObject#getFields ()[Ljava\/lang\/reflect\/Field;\"\n+        );\n+\n+    \/\/ These non-static non-final methods must not have alternate implementation\n+    \/\/ that takes a trailing caller class parameter.  It's currently invoked\n+    \/\/ by method handle if present.\n+    private static Set<String> UNSUPPORTED_VIRTUAL_METHODS =\n+        Set.of(\"java\/io\/ObjectStreamField#reflected$getType (Ljava\/lang\/Class;)Ljava\/lang\/Class;\",\n+               \"java\/lang\/Thread#reflected$getContextClassLoader (Ljava\/lang\/Class;)Ljava\/lang\/ClassLoader;\",\n+               \"javax\/sql\/rowset\/serial\/SerialJavaObject#reflected$getFields (Ljava\/lang\/Class;)[Ljava\/lang\/reflect\/Field;\"\n+        );\n@@ -87,0 +99,8 @@\n+\n+        \/\/ check if all reflected$xxx methods with a trailing Class parameter are supported\n+        checkCSMs.reflectedMethods.values().stream()\n+                 .flatMap(Set::stream)\n+                 .forEach(m -> {\n+                     if (UNSUPPORTED_VIRTUAL_METHODS.contains(m))\n+                         throw new RuntimeException(\"Unsupported alternate impl method: \" + m);\n+                 });\n@@ -90,0 +110,2 @@\n+    private final Map<String, Set<String>> reflectedMethods = new ConcurrentHashMap<>();\n+\n@@ -132,3 +154,1 @@\n-                    String name = String.format(\"%s#%s %s\", cf.getName(),\n-                                                m.getName(cf.constant_pool),\n-                                                m.descriptor.getValue(cf.constant_pool));\n+                    String name = methodSignature(cf, m);\n@@ -143,0 +163,12 @@\n+\n+                    \/\/ find the alternate implementation for CSM with a trailing\n+                    \/\/ Class parameter\n+                    if (!reflectedMethods.containsKey(cf.getName())) {\n+                        reflectedMethods.put(cf.getName(),\n+                                Arrays.stream(cf.methods)\n+                                      .filter(m0 -> reflectedImpl(cf, m0))\n+                                      .map(m0 -> methodSignature(cf, m0))\n+                                      .collect(Collectors.toSet()));\n+                        reflectedMethods.get(cf.getName()).stream().sorted().forEach(System.out::println);\n+\n+                    }\n@@ -150,0 +182,25 @@\n+    private static String methodSignature(ClassFile cf, Method m) {\n+        try {\n+            return String.format(\"%s#%s %s\", cf.getName(),\n+                                 m.getName(cf.constant_pool),\n+                                 m.descriptor.getValue(cf.constant_pool));\n+        } catch (ConstantPoolException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static boolean reflectedImpl(ClassFile cf, Method m) {\n+        ConstantPool cp = cf.constant_pool;\n+        try {\n+            int paramCount = m.descriptor.getParameterCount(cp);\n+            String desc = m.descriptor.getParameterTypes(cp);\n+            if (m.getName(cp).startsWith(\"reflected$\")\n+                    && paramCount > 0 && desc.endsWith(\"java.lang.Class)\")) {\n+                return true;\n+            }\n+        } catch (ConstantPoolException|Descriptor.InvalidDescriptor e) {\n+            throw new RuntimeException(e);\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CheckCSMs.java","additions":67,"deletions":10,"binary":false,"changes":77,"status":"modified"}]}