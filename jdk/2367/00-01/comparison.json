{"files":[{"patch":"@@ -1132,0 +1132,30 @@\n+\n+    \/*\n+     * Returns the original caller class bound to a caller-sensitive\n+     * method if the given class is an injected invoker; otherwise\n+     * this method returns null.\n+     *\n+     * An injected invoker class is a hidden class which has the same\n+     * defining class loader, runtime package, and protection domain\n+     * as the lookup class that looks up the caller-sensitive method.\n+     *\/\n+    static Class<?> originalCallerBoundToInvoker(Class<?> invoker) {\n+        if (invoker.isHidden() && invoker.getName().contains(BindCaller.INVOKER_SUFFIX)) {\n+            Lookup lookup = new Lookup(invoker);\n+            try {\n+                Object cd = MethodHandles.classData(lookup, ConstantDescs.DEFAULT_NAME, Object.class);\n+                if (cd instanceof Class c) {\n+                    \/\/ If a hidden class matching the injected invoker name but not injected\n+                    \/\/ by BindCaller calls MethodHandles.lookup(), then an invoker class\n+                    \/\/ will be defined but unused. This should be rare case.\n+                    if (invoker.isNestmateOf(c) && BindCaller.CV_makeInjectedInvoker.get(c) == invoker) {\n+                        return c;\n+                    }\n+                }\n+            } catch (IllegalAccessException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -1210,31 +1240,0 @@\n-        \/*\n-         * If the given invoker class is a hidden InjectedInvoker class,\n-         * this method returns the class that is stored as the class data of\n-         * the injected invoker class which is the lookup class bound to\n-         * the method handle for a caller-sensitive method at lookup time.\n-         * Otherwise, this method returns null.\n-         *\n-         * An injected invoker class has the same defining class loader,\n-         * runtime package, and protection domain as the lookup class that\n-         * looks up the caller-sensitive method.\n-         *\/\n-        private static Class<?> callerForInvoker(Class<?> invoker) {\n-            if (invoker.isHidden() && invoker.getName().contains(INVOKER_SUFFIX)) {\n-                Lookup lookup = new Lookup(invoker);\n-                try {\n-                    Object cd = MethodHandles.classData(lookup, ConstantDescs.DEFAULT_NAME, Object.class);\n-                    if (cd instanceof Class c) {\n-                        \/\/ If a hidden class matching the injected invoker name but not injected\n-                        \/\/ by BindCaller calls MethodHandles.lookup(), then an invoker class\n-                        \/\/ will be defined but unused. This should be rare case.\n-                        if (invoker.isNestmateOf(c) && BindCaller.CV_makeInjectedInvoker.get(c) == invoker) {\n-                            return c;\n-                        }\n-                    }\n-                } catch (IllegalAccessException e) {\n-                    throw new InternalError(e);\n-                }\n-            }\n-            return null;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":30,"deletions":31,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -132,1 +132,5 @@\n-        return new Lookup(caller);\n+        \/\/ find the original caller if the caller is an injected invoker\n+        \/\/ i.e. MethodHandles::lookup is called via Method::invoke which is\n+        \/\/ invoked via MethodHandle\n+        Class<?> originalCaller = MethodHandleImpl.originalCallerBoundToInvoker(caller);\n+        return originalCaller != null ? new Lookup(originalCaller) : new Lookup(caller);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,15 @@\n-     * MethodHandle::invokeExaxt on MethodHandles::lookup\n+     * Invoke Method::invoke on MethodHandles::lookup via MethodHandle\n+     *\/\n+    @Test()\n+    void methodInvokeViaMethodHandle() throws Throwable {\n+        Method m =  MethodHandles.class.getMethod(\"lookup\");\n+\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(Method.class, \"invoke\",\n+                methodType(Object.class, Object.class, Object[].class));\n+\n+        Lookup lookup = (Lookup) mh.invokeExact(m, null);\n+        test(lookup, \"Lookup produced via Method::invoke via MethodHandle\");\n+    }\n+\n+    \/**\n+     * MethodHandle::invokeExact on MethodHandles::lookup\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/ChainedLookupTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}