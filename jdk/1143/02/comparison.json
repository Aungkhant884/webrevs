{"files":[{"patch":"@@ -3329,0 +3329,3 @@\n+\n+void os::print_memory_mappings(char* addr, size_t bytes, outputStream* st) {}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2821,0 +2821,3 @@\n+\n+void os::print_memory_mappings(char* addr, size_t bytes, outputStream* st) {}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5525,0 +5525,29 @@\n+void os::print_memory_mappings(char* addr, size_t bytes, outputStream* st) {\n+  unsigned long long start = (unsigned long long)addr;\n+  unsigned long long end = start + bytes;\n+  FILE* f = ::fopen(\"\/proc\/self\/maps\", \"r\");\n+  int num_found = 0;\n+  if (f != NULL) {\n+    st->print(\"Range [%llx-%llx) contains: \", start, end);\n+    char line[512];\n+    while(fgets(line, sizeof(line), f) == line) {\n+      unsigned long long a1 = 0;\n+      unsigned long long a2 = 0;\n+      if (::sscanf(line, \"%llx-%llx\", &a1, &a2) == 2) {\n+        \/\/ Lets print out every range which touches ours.\n+        if ((a1 >= start && a1 < end) || \/\/ left leg in\n+            (a2 >= start && a2 < end) || \/\/ right leg in\n+            (a1 < start && a2 >= end)) { \/\/ superimposition\n+          num_found ++;\n+          st->print(\"%s\", line); \/\/ line includes \\n\n+        }\n+      }\n+    }\n+    ::fclose(f);\n+    if (num_found == 0) {\n+      st->print(\"nothing.\");\n+    }\n+    st->cr();\n+  }\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3490,1 +3490,51 @@\n-  return virtualFree(addr, 0, MEM_RELEASE) != 0;\n+  \/\/ Given a range we are to release, we require a mapping to start at the beginning of that range;\n+  \/\/  if NUMA or LP we allow the range to contain multiple mappings, which have to cover the range\n+  \/\/  completely; otherwise the range must match an OS mapping exactly.\n+  address start = (address)addr;\n+  address end = start + bytes;\n+  os::win32::mapping_info_t mi;\n+  const bool multiple_mappings_allowed = UseLargePagesIndividualAllocation || UseNUMAInterleaving;\n+  address p = start;\n+  bool first_mapping = true;\n+\n+  do {\n+    \/\/ Find mapping and check it\n+    const char* err = NULL;\n+    if (!os::win32::find_mapping(p, &mi)) {\n+      err = \"no mapping found\";\n+    } else {\n+      if (first_mapping) {\n+        if (mi.base != start) {\n+          err = \"base address mismatch\";\n+        }\n+        if (multiple_mappings_allowed ? (mi.size > bytes) : (mi.size != bytes)) {\n+          err = \"size mismatch\";\n+        }\n+      } else {\n+        assert(p == mi.base && mi.size > 0, \"Sanity\");\n+        if (mi.base + mi.size > end) {\n+          err = \"mapping overlaps end\";\n+        }\n+        if (mi.size == 0) {\n+          err = \"zero length mapping?\"; \/\/ Should never happen; just to prevent endlessly looping in release.\n+        }\n+      }\n+    }\n+    \/\/ Handle mapping error. We assert in debug, unconditionally print a warning in release.\n+    if (err != NULL) {\n+      log_warning(os)(\"bad release: [\" PTR_FORMAT \"-\" PTR_FORMAT \"): %s\", p2i(start), p2i(end), err);\n+#ifdef ASSERT\n+      os::print_memory_mappings((char*)start, bytes, tty);\n+      assert(false, \"bad release: [\" PTR_FORMAT \"-\" PTR_FORMAT \"): %s\", p2i(start), p2i(end), err);\n+#endif\n+      return false;\n+    }\n+    \/\/ Free this range\n+    if (virtualFree(p, 0, MEM_RELEASE) == FALSE) {\n+      return false;\n+    }\n+    first_mapping = false;\n+    p = mi.base + mi.size;\n+  } while (p < end);\n+\n+  return true;\n@@ -5876,0 +5926,148 @@\n+\n+#ifdef ASSERT\n+static void check_meminfo(MEMORY_BASIC_INFORMATION* minfo) {\n+  assert(minfo->State == MEM_FREE || minfo->State == MEM_COMMIT || minfo->State == MEM_RESERVE, \"Invalid state\");\n+  if (minfo->State != MEM_FREE) {\n+    assert(minfo->AllocationBase != NULL && minfo->BaseAddress >= minfo->AllocationBase, \"Invalid pointers\");\n+    assert(minfo->RegionSize > 0, \"Invalid region size\");\n+  }\n+}\n+#endif\n+\n+\n+static bool checkedVirtualQuery(address addr, MEMORY_BASIC_INFORMATION* minfo) {\n+  ZeroMemory(minfo, sizeof(MEMORY_BASIC_INFORMATION));\n+  if (::VirtualQuery(addr, minfo, sizeof(MEMORY_BASIC_INFORMATION)) == sizeof(MEMORY_BASIC_INFORMATION)) {\n+    DEBUG_ONLY(check_meminfo(minfo);)\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ Given a pointer pointing into an allocation (an area allocated with VirtualAlloc),\n+\/\/  return information about that allocation.\n+bool os::win32::find_mapping(address addr, mapping_info_t* mi) {\n+  \/\/ Query at addr to find allocation base; then, starting at allocation base,\n+  \/\/  query all regions, until we either find the next allocation or a free area.\n+  ZeroMemory(mi, sizeof(mapping_info_t));\n+  MEMORY_BASIC_INFORMATION minfo;\n+  address allocation_base = NULL;\n+  address allocation_end = NULL;\n+  bool rc = false;\n+  if (checkedVirtualQuery(addr, &minfo)) {\n+    if (minfo.State != MEM_FREE) {\n+      allocation_base = (address)minfo.AllocationBase;\n+      allocation_end = allocation_base;\n+      \/\/ Iterate through all regions in this allocation to find its end. While we are here, also count things.\n+      for (;;) {\n+        bool rc = checkedVirtualQuery(allocation_end, &minfo);\n+        if (rc == false ||                                       \/\/ VirtualQuery error, end of allocation?\n+           minfo.State == MEM_FREE ||                            \/\/ end of allocation, free memory follows\n+           (address)minfo.AllocationBase != allocation_base)     \/\/ end of allocation, a new one starts\n+        {\n+          break;\n+        }\n+        const size_t region_size = minfo.RegionSize;\n+        mi->regions ++;\n+        if (minfo.State == MEM_COMMIT) {\n+          mi->committed_size += minfo.RegionSize;\n+        }\n+        allocation_end += region_size;\n+      }\n+      if (allocation_base != NULL && allocation_end > allocation_base) {\n+        mi->base = allocation_base;\n+        mi->size = allocation_end - allocation_base;\n+        rc = true;\n+      }\n+    }\n+  }\n+#ifdef ASSERT\n+  if (rc) {\n+    assert(mi->size > 0 && mi->size >= mi->committed_size, \"Sanity\");\n+    assert(addr >= mi->base && addr < mi->base + mi->size, \"Sanity\");\n+    assert(mi->regions > 0, \"Sanity\");\n+  }\n+#endif\n+  return rc;\n+}\n+\n+\/\/ Helper function for print_memory_mappings:\n+\/\/  Given a MEMORY_BASIC_INFORMATION, containing information about a non-free region:\n+\/\/  print out all regions in that allocation. If any of those regions\n+\/\/  fall outside the given range [start, end), indicate that in the output.\n+\/\/ Return the pointer to the end of the allocation.\n+static address print_one_mapping(MEMORY_BASIC_INFORMATION* minfo, address start, address end, outputStream* st) {\n+  assert(start != NULL && end != NULL && end > start, \"Sanity\");\n+  assert(minfo->State != MEM_FREE, \"Not inside an allocation.\");\n+  address allocation_base = (address)minfo->AllocationBase;\n+  address last_region_end = NULL;\n+  st->print_cr(\"AllocationBase: \" PTR_FORMAT \":\", allocation_base);\n+  #define IS_IN(p) (p >= start && p < end)\n+  for(;;) {\n+    address region_start = (address)minfo->BaseAddress;\n+    address region_end = region_start + minfo->RegionSize;\n+    assert(region_end > region_start, \"Sanity\");\n+    if (region_end <= start) {\n+      st->print(\"<outside range> \");\n+    } else if (region_start >= end) {\n+      st->print(\"<outside range> \");\n+    } else if (!IS_IN(region_start) || !IS_IN(region_end - 1)) {\n+      st->print(\"<partly outside range> \");\n+    }\n+    st->print(\"[\" PTR_FORMAT \"-\" PTR_FORMAT \"), state=\", p2i(region_start), p2i(region_end));\n+    switch (minfo->State) {\n+      case MEM_COMMIT: st->print(\"MEM_COMMIT\"); break;\n+      case MEM_FREE: st->print(\"MEM_FREE\"); break;\n+      case MEM_RESERVE: st->print(\"MEM_RESERVE\"); break;\n+      default: st->print(\"%x?\", (unsigned)minfo->State);\n+    }\n+    st->print(\", prot=%x, type=\", (unsigned)minfo->AllocationProtect);\n+    switch (minfo->Type) {\n+      case MEM_IMAGE: st->print(\"MEM_IMAGE\"); break;\n+      case MEM_MAPPED: st->print(\"MEM_MAPPED\"); break;\n+      case MEM_PRIVATE: st->print(\"MEM_PRIVATE\"); break;\n+      default: st->print(\"%x?\", (unsigned)minfo->State);\n+    }\n+    st->cr();\n+    bool rc = checkedVirtualQuery(region_end, minfo);\n+    if (rc == false ||                                         \/\/ VirtualQuery error, end of allocation?\n+       (minfo->State == MEM_FREE) ||                           \/\/ end of allocation, free memory follows\n+       ((address)minfo->AllocationBase != allocation_base) ||  \/\/ end of allocation, a new one starts\n+       (region_end > end))                                     \/\/ end of range to print.\n+    {\n+      return region_end;\n+    }\n+  }\n+  #undef IS_IN\n+  ShouldNotReachHere();\n+  return NULL;\n+}\n+\n+void os::print_memory_mappings(char* addr, size_t bytes, outputStream* st) {\n+  MEMORY_BASIC_INFORMATION minfo;\n+  address start = (address)addr;\n+  address end = start + bytes;\n+  address p = start;\n+  while (p < end) {\n+    \/\/ Probe for the next mapping.\n+    if (checkedVirtualQuery(p, &minfo)) {\n+      if (minfo.State != MEM_FREE) {\n+        \/\/ Found one. Print it out.\n+        address p2 = print_one_mapping(&minfo, start, end, st);\n+        assert(p2 > p, \"Sanity\");\n+        p = p2;\n+      } else {\n+        \/\/ Note: for free regions, most of MEMORY_BASIC_INFORMATION is undefined.\n+        \/\/  Only region dimensions are not: use those to jump to the end of\n+        \/\/  the free range.\n+        address region_start = (address)minfo.BaseAddress;\n+        address region_end = region_start + minfo.RegionSize;\n+        assert(p >= region_start && p < region_end, \"Sanity\");\n+        p = region_end;\n+      }\n+    } else {\n+      \/\/ advance probe pointer.\n+      p += os::vm_allocation_granularity();\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":199,"deletions":1,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -113,0 +113,14 @@\n+  struct mapping_info_t {\n+    \/\/ Start of allocation (AllocationBase)\n+    address base;\n+    \/\/ Total size of allocation over all regions\n+    size_t size;\n+    \/\/ Total committed size\n+    size_t committed_size;\n+    \/\/ Number of regions\n+    int regions;\n+  };\n+  \/\/ Given an address p which points into an area allocated with VirtualAlloc(),\n+  \/\/ return information about that area.\n+  static bool find_mapping(address p, mapping_info_t* mapping_info);\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -350,0 +350,3 @@\n+  \/\/ A diagnostic function to print memory mappings in the given range.\n+  static void print_memory_mappings(char* addr, size_t bytes, outputStream* st);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -347,0 +350,237 @@\n+\n+\/\/ Test that os::release_memory() can deal with areas containing multiple mappings.\n+#define PRINT_MAPPINGS(s) { tty->print_cr(\"%s\", s); os::print_memory_mappings((char*)p, total_range_len, tty); }\n+\/\/#define PRINT_MAPPINGS\n+\n+\/\/ Reserve an area consisting of multiple mappings\n+\/\/  (from multiple calls to os::reserve_memory)\n+static address reserve_multiple(int num_stripes, size_t stripe_len) {\n+  assert(is_aligned(stripe_len, os::vm_allocation_granularity()), \"Sanity\");\n+  size_t total_range_len = num_stripes * stripe_len;\n+  \/\/ Reserve a large contiguous area to get the address space...\n+  address p = (address)os::reserve_memory(total_range_len);\n+  EXPECT_NE(p, (address)NULL);\n+  \/\/ .. release it...\n+  EXPECT_TRUE(os::release_memory((char*)p, total_range_len));\n+  \/\/ ... re-reserve in the same spot multiple areas...\n+  for (int stripe = 0; stripe < num_stripes; stripe ++) {\n+    address q = p + (stripe * stripe_len);\n+    q = (address)os::attempt_reserve_memory_at((char*)q, stripe_len);\n+    EXPECT_NE(q, (address)NULL);\n+    \/\/ Commit, alternatingly with or without exec permission,\n+    \/\/  to prevent kernel from folding these mappings.\n+    const bool executable = stripe % 2 == 0;\n+    EXPECT_TRUE(os::commit_memory((char*)q, stripe_len, executable));\n+  }\n+  return p;\n+}\n+\n+\/\/ Reserve an area with a single call to os::reserve_memory,\n+\/\/  with multiple committed and uncommitted regions\n+static address reserve_one_commit_multiple(int num_stripes, size_t stripe_len) {\n+  assert(is_aligned(stripe_len, os::vm_allocation_granularity()), \"Sanity\");\n+  size_t total_range_len = num_stripes * stripe_len;\n+  address p = (address)os::reserve_memory(total_range_len);\n+  EXPECT_NE(p, (address)NULL);\n+  for (int stripe = 0; stripe < num_stripes; stripe ++) {\n+    address q = p + (stripe * stripe_len);\n+    if (stripe % 2 == 0) {\n+      EXPECT_TRUE(os::commit_memory((char*)q, stripe_len, false));\n+    }\n+  }\n+  return p;\n+}\n+\n+#ifdef _WIN32\n+\/\/ Release a range allocated with reserve_multiple carefully, to not trip mapping\n+\/\/ asserts on Windows in os::release_memory()\n+static void carefully_release_multiple(address start, int num_stripes, size_t stripe_len) {\n+  for (int stripe = 0; stripe < num_stripes; stripe ++) {\n+    address q = start + (stripe * stripe_len);\n+    EXPECT_TRUE(os::release_memory((char*)q, stripe_len));\n+  }\n+}\n+struct NUMASwitcher {\n+  const bool _b;\n+  NUMASwitcher(bool v): _b(UseNUMAInterleaving) { UseNUMAInterleaving = v; }\n+  ~NUMASwitcher() { UseNUMAInterleaving = _b; }\n+};\n+#endif\n+\n+TEST_VM(os, release_multi_mappings) {\n+  \/\/ Test that we can release an area created with multiple reservation calls\n+  const size_t stripe_len = 4 * M;\n+  const int num_stripes = 4;\n+  const size_t total_range_len = stripe_len * num_stripes;\n+\n+  \/\/ reserve address space...\n+  address p = reserve_multiple(num_stripes, stripe_len);\n+  ASSERT_NE(p, (address)NULL);\n+  PRINT_MAPPINGS(\"A\");\n+\n+  \/\/ .. release it...\n+  {\n+    \/\/ On Windows, use UseNUMAInterleaving=1 which makes\n+    \/\/  os::release_memory accept multi-map-ranges.\n+    \/\/  Otherwise we would assert (see below for death test).\n+    WINDOWS_ONLY(NUMASwitcher b(true);)\n+    ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  }\n+  PRINT_MAPPINGS(\"B\");\n+\n+  \/\/ re-reserve it. This should work unless release failed.\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)p, total_range_len);\n+  ASSERT_EQ(p2, p);\n+  PRINT_MAPPINGS(\"C\");\n+\n+  ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+}\n+\n+#ifdef _WIN32\n+\/\/ On Windows, test that we recognize bad ranges.\n+\/\/  On debug this would assert. Test that too.\n+\/\/  On other platforms, we are unable to recognize bad ranges.\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(os, release_bad_ranges, \"bad release\") {\n+#else\n+TEST_VM(os, release_bad_ranges) {\n+#endif\n+  char* p = os::reserve_memory(4 * M);\n+  ASSERT_NE(p, (char*)NULL);\n+  \/\/ Release part of range\n+  ASSERT_FALSE(os::release_memory(p, M));\n+  \/\/ Release part of range\n+  ASSERT_FALSE(os::release_memory(p + M, M));\n+  \/\/ Release more than the range (explicitly switch off NUMA here\n+  \/\/  to make os::release_memory() test more strictly and to not\n+  \/\/  accidentally release neighbors)\n+  {\n+    NUMASwitcher b(false);\n+    ASSERT_FALSE(os::release_memory(p, M * 5));\n+    ASSERT_FALSE(os::release_memory(p - M, M * 5));\n+    ASSERT_FALSE(os::release_memory(p - M, M * 6));\n+  }\n+\n+  ASSERT_TRUE(os::release_memory(p, 4 * M)); \/\/ Release for real\n+  ASSERT_FALSE(os::release_memory(p, 4 * M)); \/\/ Again, should fail\n+}\n+#endif \/\/ _WIN32\n+\n+TEST_VM(os, release_one_mapping_multi_commits) {\n+  \/\/ Test that we can release an area consisting of interleaved\n+  \/\/  committed and uncommitted regions:\n+  const size_t stripe_len = 4 * M;\n+  const int num_stripes = 4;\n+  const size_t total_range_len = stripe_len * num_stripes;\n+\n+  \/\/ reserve address space...\n+  address p = reserve_one_commit_multiple(num_stripes, stripe_len);\n+  ASSERT_NE(p, (address)NULL);\n+  PRINT_MAPPINGS(\"A\");\n+\n+  \/\/ .. release it...\n+  ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  PRINT_MAPPINGS(\"B\");\n+\n+  \/\/ re-reserve it. This should work unless release failed.\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)p, total_range_len);\n+  ASSERT_EQ(p2, p);\n+  PRINT_MAPPINGS(\"C\");\n+\n+  ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  PRINT_MAPPINGS(\"D\");\n+}\n+\n+TEST_VM(os, show_mappings_1) {\n+  \/\/ Display an arbitrary large address range. Make this works, does not hang, etc.\n+  char dummy[16 * K]; \/\/ silent truncation is fine, we don't care.\n+  stringStream ss(dummy, sizeof(dummy));\n+  os::print_memory_mappings((char*)0x1000, LP64_ONLY(1024) NOT_LP64(3) * G, &ss);\n+}\n+\n+#ifdef _WIN32\n+\/\/ Test os::win32::find_mapping\n+TEST_VM(os, find_mapping_simple) {\n+  const size_t total_range_len = 4 * M;\n+  os::win32::mapping_info_t mapping_info;\n+\n+  \/\/ Some obvious negatives\n+  ASSERT_FALSE(os::win32::find_mapping((address)NULL, &mapping_info));\n+  ASSERT_FALSE(os::win32::find_mapping((address)4711, &mapping_info));\n+\n+  \/\/ A simple allocation\n+  {\n+    address p = (address)os::reserve_memory(total_range_len);\n+    ASSERT_NE(p, (address)NULL);\n+    PRINT_MAPPINGS(\"A\");\n+    for (size_t offset = 0; offset < total_range_len; offset += 4711) {\n+      ASSERT_TRUE(os::win32::find_mapping(p + offset, &mapping_info));\n+      ASSERT_EQ(mapping_info.base, p);\n+      ASSERT_EQ(mapping_info.regions, 1);\n+      ASSERT_EQ(mapping_info.size, total_range_len);\n+      ASSERT_EQ(mapping_info.committed_size, 0);\n+    }\n+    \/\/ Test just outside the allocation\n+    if (os::win32::find_mapping(p - 1, &mapping_info)) {\n+      ASSERT_NE(mapping_info.base, p);\n+    }\n+    if (os::win32::find_mapping(p + total_range_len, &mapping_info)) {\n+      ASSERT_NE(mapping_info.base, p);\n+    }\n+    ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+    PRINT_MAPPINGS(\"B\");\n+    ASSERT_FALSE(os::win32::find_mapping(p, &mapping_info));\n+  }\n+}\n+\n+TEST_VM(os, find_mapping_2) {\n+  \/\/ A more complex allocation, consisting of multiple regions.\n+  const size_t total_range_len = 4 * M;\n+  os::win32::mapping_info_t mapping_info;\n+\n+  const size_t stripe_len = total_range_len \/ 4;\n+  address p = reserve_one_commit_multiple(4, stripe_len);\n+  ASSERT_NE(p, (address)NULL);\n+  PRINT_MAPPINGS(\"A\");\n+  for (size_t offset = 0; offset < total_range_len; offset += 4711) {\n+    ASSERT_TRUE(os::win32::find_mapping(p + offset, &mapping_info));\n+    ASSERT_EQ(mapping_info.base, p);\n+    ASSERT_EQ(mapping_info.regions, 4);\n+    ASSERT_EQ(mapping_info.size, total_range_len);\n+    ASSERT_EQ(mapping_info.committed_size, total_range_len \/ 2);\n+  }\n+  \/\/ Test just outside the allocation\n+  if (os::win32::find_mapping(p - 1, &mapping_info)) {\n+    ASSERT_NE(mapping_info.base, p);\n+  }\n+  if (os::win32::find_mapping(p + total_range_len, &mapping_info)) {\n+    ASSERT_NE(mapping_info.base, p);\n+  }\n+  ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  PRINT_MAPPINGS(\"B\");\n+  ASSERT_FALSE(os::win32::find_mapping(p, &mapping_info));\n+}\n+\n+TEST_VM(os, find_mapping_3) {\n+  const size_t total_range_len = 4 * M;\n+  os::win32::mapping_info_t mapping_info;\n+\n+  \/\/ A more complex case, consisting of multiple allocations.\n+  {\n+    const size_t stripe_len = total_range_len \/ 4;\n+    address p = reserve_multiple(4, stripe_len);\n+    ASSERT_NE(p, (address)NULL);\n+    PRINT_MAPPINGS(\"E\");\n+    for (int stripe = 0; stripe < 4; stripe ++) {\n+      ASSERT_TRUE(os::win32::find_mapping(p + (stripe * stripe_len), &mapping_info));\n+      ASSERT_EQ(mapping_info.base, p + (stripe * stripe_len));\n+      ASSERT_EQ(mapping_info.regions, 1);\n+      ASSERT_EQ(mapping_info.size, stripe_len);\n+      ASSERT_EQ(mapping_info.committed_size, stripe_len);\n+    }\n+    carefully_release_multiple(p, 4, stripe_len);\n+    PRINT_MAPPINGS(\"F\");\n+    ASSERT_FALSE(os::win32::find_mapping(p, &mapping_info));\n+  }\n+}\n+#endif \/\/ _WIN32\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":240,"deletions":0,"binary":false,"changes":240,"status":"modified"}]}