{"files":[{"patch":"@@ -655,5 +655,0 @@\n-uint32_t CollectedHeap::hash_oop(oop obj) const {\n-  const uintptr_t addr = cast_from_oop<uintptr_t>(obj);\n-  return static_cast<uint32_t>(addr >> LogMinObjAlignment);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -283,2 +283,0 @@\n-  virtual uint32_t hash_oop(oop obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,7 +51,0 @@\n-\n-  \/\/ Notify JVMTI tagmaps that a STW collection may have moved objects, so\n-  \/\/ the tagmaps need rehashing.  This isn't the right place for this, but\n-  \/\/ is convenient because all the STW collectors use WeakProcessor.  One\n-  \/\/ problem is that the end of a G1 concurrent collection also comes here,\n-  \/\/ possibly triggering unnecessary rehashes.\n-  JvmtiTagMap::set_needs_rehashing();\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -609,3 +609,0 @@\n-      \/\/ Notify JVMTI that oops are changed.\n-      JvmtiTagMap::set_needs_rehashing();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -148,4 +148,0 @@\n-uint32_t ZCollectedHeap::hash_oop(oop obj) const {\n-  return _heap.hash_oop(ZOop::to_address(obj));\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,2 +77,0 @@\n-  virtual uint32_t hash_oop(oop obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -439,3 +439,0 @@\n-\n-  \/\/ Notify JVMTI\n-  JvmtiTagMap::set_needs_rehashing();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-  uint32_t hash_oop(uintptr_t addr) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"gc\/z\/zHash.inline.hpp\"\n@@ -46,5 +45,0 @@\n-inline uint32_t ZHeap::hash_oop(uintptr_t addr) const {\n-  const uintptr_t offset = ZAddress::offset(addr);\n-  return ZHash::address_to_uint32(offset);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,4 +102,1 @@\n-  ResetNoHandleMark rnm; \/\/ Might be called from LEAF\/QUICK ENTRY\n-  HandleMark hm(current);\n-  Handle object(current, this);\n-  return ObjectSynchronizer::identity_hash_value_for(object);\n+  return ObjectSynchronizer::FastHashCode(current, this);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -294,0 +294,1 @@\n+  inline bool fast_no_hash_check();\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -359,0 +359,8 @@\n+\/\/ This checks fast simple case of whether the oop has_no_hash,\n+\/\/ to optimize JVMTI table lookup.\n+bool oopDesc::fast_no_hash_check() {\n+  markWord mrk = mark_acquire();\n+  assert(!mrk.is_marked(), \"should never be marked\");\n+  return mrk.is_unlocked() && mrk.has_no_hash();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-  _needs_rehashing(false),\n@@ -139,1 +138,1 @@\n-\/\/ This checks for posting and rehashing before operations that\n+\/\/ This checks for posting before operations that use\n@@ -151,5 +150,0 @@\n-  if (_needs_rehashing) {\n-    log_info(jvmti, table)(\"TagMap table needs rehashing\");\n-    hashmap()->rehash();\n-    _needs_rehashing = false;\n-  }\n@@ -158,1 +152,1 @@\n-\/\/ This checks for posting and rehashing and is called from the heap walks.\n+\/\/ This checks for posting and is called from the heap walks.\n@@ -2935,15 +2929,0 @@\n-\/\/ Concurrent GC needs to call this in relocation pause, so after the objects are moved\n-\/\/ and have their new addresses, the table can be rehashed.\n-void JvmtiTagMap::set_needs_rehashing() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"called in gc pause\");\n-  assert(Thread::current()->is_VM_thread(), \"should be the VM thread\");\n-\n-  JvmtiEnvIterator it;\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n-    JvmtiTagMap* tag_map = env->tag_map_acquire();\n-    if (tag_map != NULL) {\n-      tag_map->_needs_rehashing = true;\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-  bool                  _needs_rehashing;\n@@ -118,1 +117,0 @@\n-  static void set_needs_rehashing() NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  return Universe::heap()->hash_oop(obj);\n+  return obj->identity_hash();\n@@ -116,0 +116,4 @@\n+  if (obj->fast_no_hash_check()) {\n+    \/\/ Objects in the table all have a hashcode.\n+    return NULL;\n+  }\n@@ -223,45 +227,0 @@\n-\n-\/\/ Rehash oops in the table\n-void JvmtiTagMapTable::rehash() {\n-  ResourceMark rm;\n-  GrowableArray<JvmtiTagMapEntry*> moved_entries;\n-\n-  int oops_counted = 0;\n-  for (int i = 0; i < table_size(); ++i) {\n-    JvmtiTagMapEntry** p = bucket_addr(i);\n-    JvmtiTagMapEntry* entry = bucket(i);\n-    while (entry != NULL) {\n-      oops_counted++;\n-      oop l = entry->object_no_keepalive();\n-      if (l != NULL) {\n-        \/\/ Check if oop has moved, ie its hashcode is different\n-        \/\/ than the one entered in the table.\n-        unsigned int new_hash = compute_hash(l);\n-        if (entry->hash() != new_hash) {\n-          *p = entry->next();\n-          entry->set_hash(new_hash);\n-          unlink_entry(entry);\n-          moved_entries.push(entry);\n-        } else {\n-          p = entry->next_addr();\n-        }\n-      } else {\n-        \/\/ Skip removed oops. They may still have to be posted.\n-        p = entry->next_addr();\n-      }\n-      \/\/ get next entry\n-      entry = *p;\n-    }\n-  }\n-\n-  int rehash_len = moved_entries.length();\n-  \/\/ Now add back in the entries that were removed.\n-  for (int i = 0; i < rehash_len; i++) {\n-    JvmtiTagMapEntry* moved_entry = moved_entries.at(i);\n-    int index = hash_to_index(moved_entry->hash());\n-    Hashtable<WeakHandle, mtServiceability>::add_entry(index, moved_entry);\n-  }\n-\n-  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d rehashed %d\",\n-                          oops_counted, rehash_len);\n-}\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":5,"deletions":46,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  void rehash();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -981,7 +981,0 @@\n-\/\/ Deprecated -- use FastHashCode() instead.\n-\n-intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {\n-  return FastHashCode(Thread::current(), obj());\n-}\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  static intptr_t identity_hash_value_for(Handle obj);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}