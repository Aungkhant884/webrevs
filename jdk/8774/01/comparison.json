{"files":[{"patch":"@@ -2800,4 +2800,0 @@\n-bool Parse::do_one_bytecode_targeted() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1162,4 +1162,0 @@\n-bool Parse::do_one_bytecode_targeted() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef COMPILER2\n-\n-#include \"opto\/parse.hpp\"\n-#include \"interpreter\/bytecodes.hpp\"\n-\n-bool Parse::do_one_bytecode_targeted() {\n-  switch (bc()) {\n-    case Bytecodes::_idiv: \/\/ fallthrough\n-    case Bytecodes::_irem: \/\/ fallthrough\n-#ifdef _LP64\n-    case Bytecodes::_ldiv: \/\/ fallthrough\n-    case Bytecodes::_lrem:\n-#endif\n-      do_divmod_fixup();\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/ppc\/parse_ppc.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -8856,4 +8856,20 @@\n-\/\/ Integer Division, but not min_jint \/ -1\n-instruct noOvfDivI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (NoOvfDivI src1 src2));\n-  ins_cost(3*DEFAULT_COST);\n+\/\/ Integer Division with Immediate -1: Negate.\n+instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{\n+  match(Set dst (DivI src1 src2));\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"NEG     $dst, $src1 \\t\/\/ \/-1\" %}\n+  size(4);\n+  ins_encode %{\n+    __ neg($dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Integer Division with constant, but not -1.\n+\/\/ We should be able to improve this by checking the type of src2.\n+\/\/ It might well be that src2 is known to be positive.\n+instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n+  match(Set dst (DivI src1 src2));\n+  predicate(n->in(2)->find_int_con(-1) != -1); \/\/ src2 is a constant, but not -1\n+  ins_cost(2*DEFAULT_COST);\n@@ -8869,4 +8885,50 @@\n-\/\/ Long Division, but not min_jlong \/ -1\n-instruct noOvfDivL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{\n-  match(Set dst (NoOvfDivL src1 src2));\n-  ins_cost(3*DEFAULT_COST);\n+instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{\n+  effect(USE_DEF dst, USE src1, USE crx);\n+  predicate(false);\n+\n+  ins_variable_size_depending_on_alignment(true);\n+\n+  format %{ \"CMOVE   $dst, neg($src1), $crx\" %}\n+  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n+  size(8);\n+  ins_encode %{\n+    Label done;\n+    __ bne($crx$$CondRegister, done);\n+    __ neg($dst$$Register, $src1$$Register);\n+    __ bind(done);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Integer Division with Registers not containing constants.\n+instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n+  match(Set dst (DivI src1 src2));\n+  ins_cost(10*DEFAULT_COST);\n+\n+  expand %{\n+    immI16 imm %{ (int)-1 %}\n+    flagsReg tmp1;\n+    cmpI_reg_imm16(tmp1, src2, imm);          \/\/ check src2 == -1\n+    divI_reg_regnotMinus1(dst, src1, src2);   \/\/ dst = src1 \/ src2\n+    cmovI_bne_negI_reg(dst, tmp1, src1);      \/\/ cmove dst = neg(src1) if src2 == -1\n+  %}\n+%}\n+\n+\/\/ Long Division with Immediate -1: Negate.\n+instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{\n+  match(Set dst (DivL src1 src2));\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"NEG     $dst, $src1 \\t\/\/ \/-1, long\" %}\n+  size(4);\n+  ins_encode %{\n+    __ neg($dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Long Division with constant, but not -1.\n+instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{\n+  match(Set dst (DivL src1 src2));\n+  predicate(n->in(2)->find_long_con(-1L) != -1L); \/\/ Src2 is a constant, but not -1.\n+  ins_cost(2*DEFAULT_COST);\n@@ -8882,0 +8944,32 @@\n+instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{\n+  effect(USE_DEF dst, USE src1, USE crx);\n+  predicate(false);\n+\n+  ins_variable_size_depending_on_alignment(true);\n+\n+  format %{ \"CMOVE   $dst, neg($src1), $crx\" %}\n+  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n+  size(8);\n+  ins_encode %{\n+    Label done;\n+    __ bne($crx$$CondRegister, done);\n+    __ neg($dst$$Register, $src1$$Register);\n+    __ bind(done);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Long Division with Registers not containing constants.\n+instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{\n+  match(Set dst (DivL src1 src2));\n+  ins_cost(10*DEFAULT_COST);\n+\n+  expand %{\n+    immL16 imm %{ (int)-1 %}\n+    flagsReg tmp1;\n+    cmpL_reg_imm16(tmp1, src2, imm);          \/\/ check src2 == -1\n+    divL_reg_regnotMinus1(dst, src1, src2);   \/\/ dst = src1 \/ src2\n+    cmovL_bne_negL_reg(dst, tmp1, src1);      \/\/ cmove dst = neg(src1) if src2 == -1\n+  %}\n+%}\n+\n@@ -8884,2 +8978,2 @@\n-  match(Set dst (NoOvfModI src1 src2));\n-  ins_cost(5*DEFAULT_COST);\n+  match(Set dst (ModI src1 src2));\n+  ins_cost(10*DEFAULT_COST);\n@@ -8888,1 +8982,2 @@\n-    iRegIdst tmp1;\n+    immI16 imm %{ (int)-1 %}\n+    flagsReg tmp1;\n@@ -8890,3 +8985,6 @@\n-    noOvfDivI_reg_reg(tmp1, src1, src2);\n-    mulI_reg_reg(tmp2, src2, tmp1);\n-    subI_reg_reg(dst, src1, tmp2);\n+    iRegIdst tmp3;\n+    cmpI_reg_imm16(tmp1, src2, imm);           \/\/ check src2 == -1\n+    divI_reg_regnotMinus1(tmp2, src1, src2);   \/\/ tmp2 = src1 \/ src2\n+    cmovI_bne_negI_reg(tmp2, tmp1, src1);      \/\/ cmove tmp2 = neg(src1) if src2 == -1\n+    mulI_reg_reg(tmp3, src2, tmp2);            \/\/ tmp3 = src2 * tmp2\n+    subI_reg_reg(dst, src1, tmp3);             \/\/ dst = src1 - tmp3\n@@ -8898,2 +8996,2 @@\n-  match(Set dst (NoOvfModL src1 src2));\n-  ins_cost(5*DEFAULT_COST);\n+  match(Set dst (ModL src1 src2));\n+  ins_cost(10*DEFAULT_COST);\n@@ -8902,1 +9000,2 @@\n-    iRegLdst tmp1;\n+    immL16 imm %{ (int)-1 %}\n+    flagsReg tmp1;\n@@ -8904,3 +9003,6 @@\n-    noOvfDivL_reg_reg(tmp1, src1, src2);\n-    mulL_reg_reg(tmp2, src2, tmp1);\n-    subL_reg_reg(dst, src1, tmp2);\n+    iRegLdst tmp3;\n+    cmpL_reg_imm16(tmp1, src2, imm);             \/\/ check src2 == -1\n+    divL_reg_regnotMinus1(tmp2, src1, src2);     \/\/ tmp2 = src1 \/ src2\n+    cmovL_bne_negL_reg(tmp2, tmp1, src1);        \/\/ cmove tmp2 = neg(src1) if src2 == -1\n+    mulL_reg_reg(tmp3, src2, tmp2);              \/\/ tmp3 = src2 * tmp2\n+    subL_reg_reg(dst, src1, tmp3);               \/\/ dst = src1 - tmp3\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":122,"deletions":20,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2047,4 +2047,0 @@\n-bool Parse::do_one_bytecode_targeted() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1701,4 +1701,0 @@\n-bool Parse::do_one_bytecode_targeted() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2238,7 +2238,0 @@\n-void Assembler::idivl(Address src) {\n-  InstructionMark im(this);\n-  prefix(src);\n-  emit_int8((unsigned char)0xF7);\n-  emit_operand(as_Register(7), src);\n-}\n-\n@@ -12334,7 +12327,0 @@\n-void Assembler::idivq(Address src) {\n-  InstructionMark im(this);\n-  prefixq(src);\n-  emit_int8((unsigned char)0xF7);\n-  emit_operand(as_Register(7), src);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1201,3 +1201,0 @@\n-  void divl(Register src);\n-  void divq(Register src);\n-\n@@ -1372,1 +1369,3 @@\n-  void idivl(Address src);\n+  void divl(Register src); \/\/ Unsigned division\n+\n+#ifdef _LP64\n@@ -1374,1 +1373,2 @@\n-  void idivq(Address src);\n+  void divq(Register src); \/\/ Unsigned division\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef COMPILER2\n-\n-#include \"opto\/parse.hpp\"\n-#include \"interpreter\/bytecodes.hpp\"\n-\n-bool Parse::do_one_bytecode_targeted() {\n-  switch (bc()) {\n-    case Bytecodes::_idiv: \/\/ fallthrough\n-    case Bytecodes::_irem: \/\/ fallthrough\n-#ifdef _LP64\n-    case Bytecodes::_ldiv: \/\/ fallthrough\n-    case Bytecodes::_lrem:\n-#endif\n-      do_divmod_fixup();\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/parse_x86.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1559,0 +1559,41 @@\n+  enc_class cdq_enc %{\n+    \/\/ Full implementation of Java idiv and irem; checks for\n+    \/\/ special case as described in JVM spec., p.243 & p.271.\n+    \/\/\n+    \/\/         normal case                           special case\n+    \/\/\n+    \/\/ input : rax,: dividend                         min_int\n+    \/\/         reg: divisor                          -1\n+    \/\/\n+    \/\/ output: rax,: quotient  (= rax, idiv reg)       min_int\n+    \/\/         rdx: remainder (= rax, irem reg)       0\n+    \/\/\n+    \/\/  Code sequnce:\n+    \/\/\n+    \/\/  81 F8 00 00 00 80    cmp         rax,80000000h\n+    \/\/  0F 85 0B 00 00 00    jne         normal_case\n+    \/\/  33 D2                xor         rdx,edx\n+    \/\/  83 F9 FF             cmp         rcx,0FFh\n+    \/\/  0F 84 03 00 00 00    je          done\n+    \/\/                  normal_case:\n+    \/\/  99                   cdq\n+    \/\/  F7 F9                idiv        rax,ecx\n+    \/\/                  done:\n+    \/\/\n+    emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);\n+    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);\n+    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     \/\/ cmp rax,80000000h\n+    emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);\n+    emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);\n+    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     \/\/ jne normal_case\n+    emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     \/\/ xor rdx,edx\n+    emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); \/\/ cmp rcx,0FFh\n+    emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);\n+    emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);\n+    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     \/\/ je done\n+    \/\/ normal_case:\n+    emit_opcode(cbuf,0x99);                                         \/\/ cdq\n+    \/\/ idiv (note: must be emitted by the user of this rule)\n+    \/\/ normal:\n+  %}\n+\n@@ -7776,1 +7817,1 @@\n-  match(Set rax (NoOvfDivI rax div));\n+  match(Set rax (DivI rax div));\n@@ -7778,9 +7819,13 @@\n-  size(3);\n-  ins_cost(500);\n-  format %{ \"CDQ\\n\\t\"\n-            \"IDIV   $div\" %}\n-  ins_encode %{\n-    __ cdql();\n-    __ idivl($div$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n+  size(26);\n+  ins_cost(30*100+10*100);\n+  format %{ \"CMP    EAX,0x80000000\\n\\t\"\n+            \"JNE,s  normal\\n\\t\"\n+            \"XOR    EDX,EDX\\n\\t\"\n+            \"CMP    ECX,-1\\n\\t\"\n+            \"JE,s   done\\n\"\n+    \"normal: CDQ\\n\\t\"\n+            \"IDIV   $div\\n\\t\"\n+    \"done:\"        %}\n+  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n+  ins_encode( cdq_enc, OpcP, RegOpc(div) );\n+  ins_pipe( ialu_reg_reg_alu0 );\n@@ -7806,1 +7851,1 @@\n-  match(NoOvfDivModI rax div);\n+  match(DivModI rax div);\n@@ -7808,8 +7853,12 @@\n-  size(3);\n-  ins_cost(500);\n-  format %{ \"CDQ\\n\\t\"\n-            \"IDIV   $div\" %}\n-  ins_encode %{\n-    __ cdql();\n-    __ idivl($div$$Register);\n-  %}\n+  size(26);\n+  ins_cost(30*100+10*100);\n+  format %{ \"CMP    EAX,0x80000000\\n\\t\"\n+            \"JNE,s  normal\\n\\t\"\n+            \"XOR    EDX,EDX\\n\\t\"\n+            \"CMP    ECX,-1\\n\\t\"\n+            \"JE,s   done\\n\"\n+    \"normal: CDQ\\n\\t\"\n+            \"IDIV   $div\\n\\t\"\n+    \"done:\"        %}\n+  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n+  ins_encode( cdq_enc, OpcP, RegOpc(div) );\n@@ -7821,1 +7870,1 @@\n-  match(Set rdx (NoOvfModI rax div));\n+  match(Set rdx (ModI rax div));\n@@ -7824,2 +7873,2 @@\n-  size(3);\n-  ins_cost(500);\n+  size(26);\n+  ins_cost(300);\n@@ -7828,5 +7877,3 @@\n-  ins_encode %{\n-    __ cdql();\n-    __ idivl($div$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n+  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n+  ins_encode( cdq_enc, OpcP, RegOpc(div) );\n+  ins_pipe( ialu_reg_reg_alu0 );\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":74,"deletions":27,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -341,1 +341,0 @@\n-extern RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n@@ -343,1 +342,0 @@\n-extern RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n@@ -347,3 +345,0 @@\n-inline const RegMask& STACK_OR_LONG_NO_RAX_RDX_REG_mask() {\n-  return _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n-}\n@@ -351,3 +346,0 @@\n-inline const RegMask& STACK_OR_INT_NO_RAX_RDX_REG_mask() {\n-  return _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n-}\n@@ -379,1 +371,0 @@\n-RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n@@ -381,1 +372,0 @@\n-RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n@@ -442,3 +432,0 @@\n-  _STACK_OR_LONG_NO_RAX_RDX_REG_mask = _LONG_NO_RAX_RDX_REG_mask;\n-  _STACK_OR_LONG_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n-\n@@ -467,3 +454,0 @@\n-  _STACK_OR_INT_NO_RAX_RDX_REG_mask = _INT_NO_RAX_RDX_REG_mask;\n-  _STACK_OR_INT_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n-\n@@ -1926,0 +1910,117 @@\n+  enc_class cdql_enc(no_rax_rdx_RegI div)\n+  %{\n+    \/\/ Full implementation of Java idiv and irem; checks for\n+    \/\/ special case as described in JVM spec., p.243 & p.271.\n+    \/\/\n+    \/\/         normal case                           special case\n+    \/\/\n+    \/\/ input : rax: dividend                         min_int\n+    \/\/         reg: divisor                          -1\n+    \/\/\n+    \/\/ output: rax: quotient  (= rax idiv reg)       min_int\n+    \/\/         rdx: remainder (= rax irem reg)       0\n+    \/\/\n+    \/\/  Code sequnce:\n+    \/\/\n+    \/\/    0:   3d 00 00 00 80          cmp    $0x80000000,%eax\n+    \/\/    5:   75 07\/08                jne    e <normal>\n+    \/\/    7:   33 d2                   xor    %edx,%edx\n+    \/\/  [div >= 8 -> offset + 1]\n+    \/\/  [REX_B]\n+    \/\/    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div\n+    \/\/    c:   74 03\/04                je     11 <done>\n+    \/\/ 000000000000000e <normal>:\n+    \/\/    e:   99                      cltd\n+    \/\/  [div >= 8 -> offset + 1]\n+    \/\/  [REX_B]\n+    \/\/    f:   f7 f9                   idiv   $div\n+    \/\/ 0000000000000011 <done>:\n+    MacroAssembler _masm(&cbuf);\n+    Label normal;\n+    Label done;\n+\n+    \/\/ cmp    $0x80000000,%eax\n+    __ cmpl(as_Register(RAX_enc), 0x80000000);\n+\n+    \/\/ jne    e <normal>\n+    __ jccb(Assembler::notEqual, normal);\n+\n+    \/\/ xor    %edx,%edx\n+    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n+\n+    \/\/ cmp    $0xffffffffffffffff,%ecx\n+    __ cmpl($div$$Register, -1);\n+\n+    \/\/ je     11 <done>\n+    __ jccb(Assembler::equal, done);\n+\n+    \/\/ <normal>\n+    \/\/ cltd\n+    __ bind(normal);\n+    __ cdql();\n+\n+    \/\/ idivl\n+    \/\/ <done>\n+    __ idivl($div$$Register);\n+    __ bind(done);\n+  %}\n+\n+  enc_class cdqq_enc(no_rax_rdx_RegL div)\n+  %{\n+    \/\/ Full implementation of Java ldiv and lrem; checks for\n+    \/\/ special case as described in JVM spec., p.243 & p.271.\n+    \/\/\n+    \/\/         normal case                           special case\n+    \/\/\n+    \/\/ input : rax: dividend                         min_long\n+    \/\/         reg: divisor                          -1\n+    \/\/\n+    \/\/ output: rax: quotient  (= rax idiv reg)       min_long\n+    \/\/         rdx: remainder (= rax irem reg)       0\n+    \/\/\n+    \/\/  Code sequnce:\n+    \/\/\n+    \/\/    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx\n+    \/\/    7:   00 00 80\n+    \/\/    a:   48 39 d0                cmp    %rdx,%rax\n+    \/\/    d:   75 08                   jne    17 <normal>\n+    \/\/    f:   33 d2                   xor    %edx,%edx\n+    \/\/   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div\n+    \/\/   15:   74 05                   je     1c <done>\n+    \/\/ 0000000000000017 <normal>:\n+    \/\/   17:   48 99                   cqto\n+    \/\/   19:   48 f7 f9                idiv   $div\n+    \/\/ 000000000000001c <done>:\n+    MacroAssembler _masm(&cbuf);\n+    Label normal;\n+    Label done;\n+\n+    \/\/ mov    $0x8000000000000000,%rdx\n+    __ mov64(as_Register(RDX_enc), 0x8000000000000000);\n+\n+    \/\/ cmp    %rdx,%rax\n+    __ cmpq(as_Register(RAX_enc), as_Register(RDX_enc));\n+\n+    \/\/ jne    17 <normal>\n+    __ jccb(Assembler::notEqual, normal);\n+\n+    \/\/ xor    %edx,%edx\n+    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n+\n+    \/\/ cmp    $0xffffffffffffffff,$div\n+    __ cmpq($div$$Register, -1);\n+\n+    \/\/ je     1e <done>\n+    __ jccb(Assembler::equal, done);\n+\n+    \/\/ <normal>\n+    \/\/ cqto\n+    __ bind(normal);\n+    __ cdqq();\n+\n+    \/\/ idivq (note: must be emitted by the user of this rule)\n+    \/\/ <done>\n+    __ idivq($div$$Register);\n+    __ bind(done);\n+  %}\n+\n@@ -8526,17 +8627,1 @@\n-  match(Set rax (NoOvfDivI rax div));\n-  effect(KILL rdx, KILL cr);\n-\n-  ins_cost(500);\n-  format %{ \"cdql\\n\\t\"\n-            \"idivl   $div\" %}\n-  ins_encode %{\n-    __ cdql();\n-    __ idivl($div$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct divI_mem(rax_RegI rax, rdx_RegI rdx, memory div,\n-                   rFlagsReg cr)\n-%{\n-  match(Set rax (NoOvfDivI rax (LoadI div)));\n+  match(Set rax (DivI rax div));\n@@ -8545,8 +8630,11 @@\n-  ins_cost(575);\n-  format %{ \"cdql\\n\\t\"\n-            \"idivl   $div\" %}\n-  ins_encode %{\n-    __ cdql();\n-    __ idivl($div$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n+  ins_cost(30*100+10*100); \/\/ XXX\n+  format %{ \"cmpl    rax, 0x80000000\\t# idiv\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpl    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdql\\n\\t\"\n+            \"idivl   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdql_enc(div));\n+  ins_pipe(ialu_reg_reg_alu0);\n@@ -8558,17 +8646,1 @@\n-  match(Set rax (NoOvfDivL rax div));\n-  effect(KILL rdx, KILL cr);\n-\n-  ins_cost(500);\n-  format %{ \"cdqq\\n\\t\"\n-            \"idivq   $div\" %}\n-  ins_encode %{\n-    __ cdqq();\n-    __ idivq($div$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct divL_mem(rax_RegL rax, rdx_RegL rdx, memory div,\n-                   rFlagsReg cr)\n-%{\n-  match(Set rax (NoOvfDivL rax (LoadL div)));\n+  match(Set rax (DivL rax div));\n@@ -8577,8 +8649,12 @@\n-  ins_cost(575);\n-  format %{ \"cdqq\\n\\t\"\n-            \"idivq   $div\" %}\n-  ins_encode %{\n-    __ cdqq();\n-    __ idivq($div$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n+  ins_cost(30*100+10*100); \/\/ XXX\n+  format %{ \"movq    rdx, 0x8000000000000000\\t# ldiv\\n\\t\"\n+            \"cmpq    rax, rdx\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpq    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdqq\\n\\t\"\n+            \"idivq   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdqq_enc(div));\n+  ins_pipe(ialu_reg_reg_alu0);\n@@ -8617,1 +8693,1 @@\n-  match(NoOvfDivModI rax div);\n+  match(DivModI rax div);\n@@ -8620,7 +8696,10 @@\n-  ins_cost(500);\n-  format %{ \"cdql\\n\\t\"\n-            \"idivl   $div\" %}\n-  ins_encode %{\n-    __ cdql();\n-    __ idivl($div$$Register);\n-  %}\n+  ins_cost(30*100+10*100); \/\/ XXX\n+  format %{ \"cmpl    rax, 0x80000000\\t# idiv\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpl    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdql\\n\\t\"\n+            \"idivl   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdql_enc(div));\n@@ -8634,1 +8713,1 @@\n-  match(NoOvfDivModL rax div);\n+  match(DivModL rax div);\n@@ -8637,7 +8716,11 @@\n-  ins_cost(500);\n-  format %{ \"cdqq\\n\\t\"\n-            \"idivq   $div\" %}\n-  ins_encode %{\n-    __ cdqq();\n-    __ idivq($div$$Register);\n-  %}\n+  ins_cost(30*100+10*100); \/\/ XXX\n+  format %{ \"movq    rdx, 0x8000000000000000\\t# ldiv\\n\\t\"\n+            \"cmpq    rax, rdx\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpq    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdqq\\n\\t\"\n+            \"idivq   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdqq_enc(div));\n@@ -8681,2 +8764,6 @@\n-instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,\n-                   rFlagsReg cr)\n+\n+\/\/----------- DivL-By-Constant-Expansions--------------------------------------\n+\/\/ DivI cases are handled by the compiler\n+\n+\/\/ Magic constant, reciprocal of 10\n+instruct loadConL_0x6666666666666667(rRegL dst)\n@@ -8684,2 +8771,10 @@\n-  match(Set rdx (NoOvfModI rax div));\n-  effect(KILL rax, KILL cr);\n+  effect(DEF dst);\n+\n+  format %{ \"movq    $dst, #0x666666666666667\\t# Used in div-by-10\" %}\n+  ins_encode(load_immL(dst, 0x6666666666666667));\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src, USE_KILL rax, KILL cr);\n@@ -8687,3 +8782,1 @@\n-  ins_cost(500);\n-  format %{ \"cdql\\n\\t\"\n-            \"idivl   $div\" %}\n+  format %{ \"imulq   rdx:rax, rax, $src\\t# Used in div-by-10\" %}\n@@ -8691,2 +8784,1 @@\n-    __ cdql();\n-    __ idivl($div$$Register);\n+    __ imulq($src$$Register);\n@@ -8694,1 +8786,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(ialu_reg_reg_alu0);\n@@ -8697,2 +8789,1 @@\n-instruct modI_mem(rdx_RegI rdx, rax_RegI rax, memory div,\n-                   rFlagsReg cr)\n+instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)\n@@ -8700,2 +8791,1 @@\n-  match(Set rdx (NoOvfModI rax (LoadI div)));\n-  effect(KILL rax, KILL cr);\n+  effect(USE_DEF dst, KILL cr);\n@@ -8703,3 +8793,1 @@\n-  ins_cost(575);\n-  format %{ \"cdql\\n\\t\"\n-            \"idivl   $div\" %}\n+  format %{ \"sarq    $dst, #63\\t# Used in div-by-10\" %}\n@@ -8707,2 +8795,1 @@\n-    __ cdql();\n-    __ idivl($div$$Address);\n+    __ sarq($dst$$Register, 63);\n@@ -8710,1 +8797,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(ialu_reg);\n@@ -8713,2 +8800,1 @@\n-instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,\n-                   rFlagsReg cr)\n+instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)\n@@ -8716,2 +8802,1 @@\n-  match(Set rdx (NoOvfModL rax div));\n-  effect(KILL rax, KILL cr);\n+  effect(USE_DEF dst, KILL cr);\n@@ -8719,3 +8804,1 @@\n-  ins_cost(500);\n-  format %{ \"cdqq\\n\\t\"\n-            \"idivq   $div\" %}\n+  format %{ \"sarq    $dst, #2\\t# Used in div-by-10\" %}\n@@ -8723,2 +8806,18 @@\n-    __ cdqq();\n-    __ idivq($div$$Register);\n+    __ sarq($dst$$Register, 2);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)\n+%{\n+  match(Set dst (DivL src div));\n+\n+  ins_cost((5+8)*100);\n+  expand %{\n+    rax_RegL rax;                     \/\/ Killed temp\n+    rFlagsReg cr;                     \/\/ Killed\n+    loadConL_0x6666666666666667(rax); \/\/ movq  rax, 0x6666666666666667\n+    mul_hi(dst, src, rax, cr);        \/\/ mulq  rdx:rax <= rax * $src\n+    sarL_rReg_63(src, cr);            \/\/ sarq  src, 63\n+    sarL_rReg_2(dst, cr);             \/\/ sarq  rdx, 2\n+    subL_rReg(dst, src, cr);          \/\/ subl  rdx, src\n@@ -8726,1 +8825,0 @@\n-  ins_pipe(pipe_slow);\n@@ -8729,1 +8827,3 @@\n-instruct modL_mem(rdx_RegL rdx, rax_RegL rax, memory div,\n+\/\/-----------------------------------------------------------------------------\n+\n+instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,\n@@ -8732,1 +8832,1 @@\n-  match(Set rdx (NoOvfModL rax (LoadL div)));\n+  match(Set rdx (ModI rax div));\n@@ -8735,8 +8835,31 @@\n-  ins_cost(575);\n-  format %{ \"cdqq\\n\\t\"\n-            \"idivq   $div\" %}\n-  ins_encode %{\n-    __ cdqq();\n-    __ idivq($div$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n+  ins_cost(300); \/\/ XXX\n+  format %{ \"cmpl    rax, 0x80000000\\t# irem\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpl    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdql\\n\\t\"\n+            \"idivl   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdql_enc(div));\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,\n+                   rFlagsReg cr)\n+%{\n+  match(Set rdx (ModL rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300); \/\/ XXX\n+  format %{ \"movq    rdx, 0x8000000000000000\\t# lrem\\n\\t\"\n+            \"cmpq    rax, rdx\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpq    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdqq\\n\\t\"\n+            \"idivq   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdqq_enc(div));\n+  ins_pipe(ialu_reg_reg_alu0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":245,"deletions":122,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-  AD.addInclude(AD._CPP_file, \"opto\/parse.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,2 +165,0 @@\n-macro(NoOvfDivI)\n-macro(NoOvfDivL)\n@@ -172,2 +170,0 @@\n-macro(NoOvfDivModI)\n-macro(NoOvfDivModL)\n@@ -242,2 +238,0 @@\n-macro(NoOvfModI)\n-macro(NoOvfModL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3571,40 +3571,0 @@\n-  case Op_NoOvfModI:\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_NoOvfDivI);\n-      if (d) {\n-        \/\/ Replace them with a fused divmod if supported\n-        if (Matcher::has_match_rule(Op_NoOvfDivModI)) {\n-          NoOvfDivModINode* divmod = NoOvfDivModINode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulINode(d, d->in(2));\n-          Node* sub  = new SubINode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n-    break;\n-\n-  case Op_NoOvfModL:\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_NoOvfDivL);\n-      if (d) {\n-        \/\/ Replace them with a fused divmod if supported\n-        if (Matcher::has_match_rule(Op_NoOvfDivModL)) {\n-          NoOvfDivModLNode* divmod = NoOvfDivModLNode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulLNode(d, d->in(2));\n-          Node* sub  = new SubLNode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n-    break;\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1469,24 +1469,0 @@\n-\n-\/\/------------------------------make------------------------------------------\n-NoOvfDivModINode* NoOvfDivModINode::make(Node* div_or_mod) {\n-  Node* n = div_or_mod;\n-  assert(n->Opcode() == Op_NoOvfDivI || n->Opcode() == Op_NoOvfModI,\n-         \"only div or mod input pattern accepted\");\n-\n-  NoOvfDivModINode* divmod = new NoOvfDivModINode(n->in(0), n->in(1), n->in(2));\n-  Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);\n-  Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);\n-  return divmod;\n-}\n-\n-\/\/------------------------------make------------------------------------------\n-NoOvfDivModLNode* NoOvfDivModLNode::make(Node* div_or_mod) {\n-  Node* n = div_or_mod;\n-  assert(n->Opcode() == Op_NoOvfDivL || n->Opcode() == Op_NoOvfModL,\n-         \"only div or mod input pattern accepted\");\n-\n-  NoOvfDivModLNode* divmod = new NoOvfDivModLNode(n->in(0), n->in(1), n->in(2));\n-  Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);\n-  Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);\n-  return divmod;\n-}\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-\/\/------------------------------UDivLNode--------------------------------------\n+\/\/------------------------------UDivLNode---------------------------------------\n@@ -119,18 +119,0 @@\n-\/\/---------------------------NoOvfDivINode-------------------------------------\n-\/\/ Non-overflow integer division, UB when dividend == min_jint and divisor == -1\n-\/\/ so user has to ensure this combination does not appear\n-class NoOvfDivINode : public DivINode {\n-public:\n-  NoOvfDivINode( Node *c, Node *dividend, Node *divisor ) : DivINode(c, dividend, divisor ) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/---------------------------NoOvfDivLNode-------------------------------------\n-\/\/ Non-overflow long division, UB when dividend == min_jlong and divisor == -1\n-\/\/ so user has to ensure this combination does not appear\n-class NoOvfDivLNode : public DivLNode {\n-public:\n-  NoOvfDivLNode( Node *c, Node *dividend, Node *divisor ) : DivLNode(c, dividend, divisor ) {}\n-  virtual int Opcode() const;\n-};\n-\n@@ -183,1 +165,1 @@\n-\/\/------------------------------UModINode--------------------------------------\n+\/\/------------------------------UModINode---------------------------------------\n@@ -194,1 +176,1 @@\n-\/\/------------------------------UModLNode--------------------------------------\n+\/\/------------------------------UModLNode---------------------------------------\n@@ -205,19 +187,1 @@\n-\/\/---------------------------NoOvfModINode-------------------------------------\n-\/\/ Non-overflow integer modulus, UB when dividend == min_jint and divisor == -1\n-\/\/ so user has to ensure this combination does not appear\n-class NoOvfModINode : public ModINode {\n-public:\n-  NoOvfModINode( Node *c, Node *dividend, Node *divisor ) : ModINode(c, dividend, divisor ) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/---------------------------NoOvfModLNode-------------------------------------\n-\/\/ Non-overflow long modulus, UB when dividend == min_jlong and divisor == -1\n-\/\/ so user has to ensure this combination does not appear\n-class NoOvfModLNode : public ModLNode {\n-public:\n-  NoOvfModLNode( Node *c, Node *dividend, Node *divisor ) : ModLNode(c, dividend, divisor ) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/-----------------------------DivModNode--------------------------------------\n+\/\/------------------------------DivModNode---------------------------------------\n@@ -245,1 +209,1 @@\n-\/\/-----------------------------DivModINode-------------------------------------\n+\/\/------------------------------DivModINode---------------------------------------\n@@ -258,1 +222,1 @@\n-\/\/-----------------------------DivModLNode-------------------------------------\n+\/\/------------------------------DivModLNode---------------------------------------\n@@ -272,1 +236,1 @@\n-\/\/----------------------------UDivModINode-------------------------------------\n+\/\/------------------------------UDivModINode---------------------------------------\n@@ -285,1 +249,1 @@\n-\/\/----------------------------UDivModLNode-------------------------------------\n+\/\/------------------------------UDivModLNode---------------------------------------\n@@ -298,24 +262,0 @@\n-\/\/---------------------------NoOvfDivModINode----------------------------------\n-\/\/ Non-overflow integer division with remainder result, UB when dividend == min_jint\n-\/\/ and divisor == -1 so user has to ensure this combination does not appear\n-class NoOvfDivModINode : public DivModINode {\n-public:\n-  NoOvfDivModINode( Node *c, Node *dividend, Node *divisor ) : DivModINode(c, dividend, divisor) {}\n-  virtual int Opcode() const;\n-\n-  \/\/ Make a divmod and associated projections from a div or mod.\n-  static NoOvfDivModINode* make(Node* div_or_mod);\n-};\n-\n-\/\/---------------------------NoOvfDivModLNode----------------------------------\n-\/\/ Non-overflow long division with remainder result, UB when dividend == min_jlong\n-\/\/ and divisor == -1 so user has to ensure this combination does not appear\n-class NoOvfDivModLNode : public DivModLNode {\n-public:\n-  NoOvfDivModLNode( Node *c, Node *dividend, Node *divisor ) : DivModLNode(c, dividend, divisor) {}\n-  virtual int Opcode() const;\n-\n-  \/\/ Make a divmod and associated projections from a div or mod.\n-  static NoOvfDivModLNode* make(Node* div_or_mod);\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":8,"deletions":68,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -465,2 +465,1 @@\n-  void do_one_bytecode_common();\n-  bool do_one_bytecode_targeted();\n+  void do_one_bytecode();\n@@ -538,4 +537,0 @@\n-  \/\/ implementation of div\/rem bytecodes for handling of special case\n-  \/\/ min_jint \/ -1\n-  void do_divmod_fixup();\n-\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -1560,16 +1559,1 @@\n-    \/\/ Try parsing machine-dependently, then if it is not needed then parse\n-    \/\/ the bytecode in a machine independent manner\n-    if (!do_one_bytecode_targeted()) {\n-      do_one_bytecode_common();\n-    }\n-#ifndef PRODUCT\n-    if (C->should_print_igv(1)) {\n-      IdealGraphPrinter* printer = C->igv_printer();\n-      char buffer[256];\n-      jio_snprintf(buffer, sizeof(buffer), \"Bytecode %d: %s\", bci(), Bytecodes::name(bc()));\n-      bool old = printer->traverse_outs();\n-      printer->set_traverse_outs(true);\n-      printer->print_method(buffer, 4);\n-      printer->set_traverse_outs(old);\n-    }\n-#endif\n+    do_one_bytecode();\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1806,1 +1806,1 @@\n-void Parse::do_one_bytecode_common() {\n+void Parse::do_one_bytecode() {\n@@ -2754,0 +2754,12 @@\n+\n+#ifndef PRODUCT\n+  if (C->should_print_igv(1)) {\n+    IdealGraphPrinter* printer = C->igv_printer();\n+    char buffer[256];\n+    jio_snprintf(buffer, sizeof(buffer), \"Bytecode %d: %s\", bci(), Bytecodes::name(bc()));\n+    bool old = printer->traverse_outs();\n+    printer->set_traverse_outs(true);\n+    printer->print_method(buffer, 4);\n+    printer->set_traverse_outs(old);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -436,74 +436,0 @@\n-\n-\/\/ On some architectures, a division cannot be done immediately due to\n-\/\/ the special case with min_jint \/ -1. As a result, we need to have\n-\/\/ special handling for this case\n-void Parse::do_divmod_fixup() {\n-  Bytecodes::Code bc = this->bc();\n-  BasicType bt = (bc == Bytecodes::_idiv || bc == Bytecodes::_irem) ? T_INT : T_LONG;\n-  \/\/ Operands need to stay in the stack during zero check\n-  if (bt == T_INT) {\n-    zero_check_int(peek(0));\n-  } else {\n-    zero_check_long(peek(1));\n-  }\n-  \/\/ Compile-time detection of arithmetic exception\n-  if (stopped()) {\n-    return;\n-  }\n-\n-  Node* in2 = (bt == T_INT) ? pop() : pop_pair();\n-  Node* in1 = (bt == T_INT) ? pop() : pop_pair();\n-\n-  auto generate_division = [](PhaseGVN& gvn, Node* control, Node* in1, Node* in2,\n-                              Bytecodes::Code bc) {\n-    switch (bc) {\n-      case Bytecodes::_idiv: return gvn.transform(new NoOvfDivINode(control, in1, in2));\n-      case Bytecodes::_ldiv: return gvn.transform(new NoOvfDivLNode(control, in1, in2));\n-      case Bytecodes::_irem: return gvn.transform(new NoOvfModINode(control, in1, in2));\n-      case Bytecodes::_lrem: return gvn.transform(new NoOvfModLNode(control, in1, in2));\n-      default:\n-        ShouldNotReachHere();\n-        return static_cast<Node*>(nullptr);\n-    }\n-  };\n-\n-  auto push_result = [](Parse& parser, Node* res, BasicType bt) {\n-    if (bt == T_INT) {\n-      parser.push(res);\n-    } else {\n-      parser.push_pair(res);\n-    }\n-  };\n-\n-  \/\/ No overflow possibility here\n-  if ((in1 == in2) ||\n-      (bt == T_INT  &&  !TypeInt::MIN->higher_equal(_gvn.type(in1))) ||\n-      (bt == T_LONG && !TypeLong::MIN->higher_equal(_gvn.type(in1)))) {\n-    Node* res = generate_division(_gvn, control(), in1, in2, bc);\n-    push_result(*this, res, bt);\n-    return;\n-  }\n-\n-  \/\/ The generated graph is equivalent to (in2 == -1) ? -in1 : (in1 \/ in2)\n-  \/\/ we need to have a separate branch for in2 == -1 due to the special\n-  \/\/ case of min_jint \/ -1\n-  Node* cmp = _gvn.transform(CmpNode::make(in2, _gvn.integercon(-1, bt), bt));\n-  Node* bol = Bool(cmp, BoolTest::eq);\n-  IfNode* iff = create_and_map_if(control(), bol, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);\n-  Node* iff_true = IfTrue(iff);\n-  Node* iff_false = IfFalse(iff);\n-  Node* res_fast = (bc == Bytecodes::_idiv || bc == Bytecodes::_ldiv)\n-                   ? _gvn.transform(SubNode::make(_gvn.zerocon(bt), in1, bt))\n-                   : _gvn.zerocon(bt);\n-  Node* res_slow = generate_division(_gvn, iff_false, in1, in2, bc);\n-  Node* merge = new RegionNode(3);\n-  merge->init_req(1, iff_true);\n-  merge->init_req(2, iff_false);\n-  record_for_igvn(merge);\n-  set_control(_gvn.transform(merge));\n-  Node* res = new PhiNode(merge, Type::get_const_basic_type(bt));\n-  res->init_req(1, res_fast);\n-  res->init_req(2, res_slow);\n-  res = _gvn.transform(res);\n-  push_result(*this, res, bt);\n-}\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":1,"deletions":75,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1591,2 +1591,0 @@\n-  declare_c2_type(NoOvfDivINode, DivINode)                                \\\n-  declare_c2_type(NoOvfDivLNode, DivLNode)                                \\\n@@ -1599,2 +1597,0 @@\n-  declare_c2_type(NoOvfModINode, ModINode)                                \\\n-  declare_c2_type(NoOvfModLNode, ModLNode)                                \\\n@@ -1606,2 +1602,0 @@\n-  declare_c2_type(NoOvfDivModINode, DivModINode)                          \\\n-  declare_c2_type(NoOvfDivModLNode, DivModLNode)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.integerArithmetic;\n-\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test TestDivision\n- * @bug 8284742\n- * @summary Tests to verify compiled code correctly handles integral divisions.\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation\n- *      -XX:CompileCommand=compileonly,*.TestDivision::divide\n- *      -XX:CompileCommand=compileonly,*.TestDivision::remainder\n- *      compiler.integerArithmetic.TestDivision\n- *\/\n-public class TestDivision {\n-    public static void main(String[] args) {\n-        Asserts.assertEquals(divide(19, 7), 19 \/ 7);\n-        Asserts.assertEquals(remainder(19, 7), 19 % 7);\n-        Asserts.assertEquals(divide(19L, 7L), 19L \/ 7L);\n-        Asserts.assertEquals(remainder(19L, 7L), 19L % 7L);\n-\n-        Asserts.assertEquals(divide(19, -7), 19 \/ -7);\n-        Asserts.assertEquals(remainder(19, -7), 19 % -7);\n-        Asserts.assertEquals(divide(19L, -7L), 19L \/ -7L);\n-        Asserts.assertEquals(remainder(19L, -7L), 19L % -7L);\n-\n-        Asserts.assertEquals(divide(-19, 7), -19 \/ 7);\n-        Asserts.assertEquals(remainder(-19, 7), -19 % 7);\n-        Asserts.assertEquals(divide(-19L, 7L), -19L \/ 7L);\n-        Asserts.assertEquals(remainder(-19L, 7L), -19L % 7L);\n-\n-        Asserts.assertEquals(divide(-19, -7), -19 \/ -7);\n-        Asserts.assertEquals(remainder(-19, -7), -19 % -7);\n-        Asserts.assertEquals(divide(-19L, -7L), -19L \/ -7L);\n-        Asserts.assertEquals(remainder(-19L, -7L), -19L % -7L);\n-\n-        Asserts.assertEquals(divide(Integer.MIN_VALUE, -1), Integer.MIN_VALUE \/ -1);\n-        Asserts.assertEquals(remainder(Integer.MIN_VALUE, -1), Integer.MIN_VALUE % -1);\n-        Asserts.assertEquals(divide(Long.MIN_VALUE, -1), Long.MIN_VALUE \/ -1L);\n-        Asserts.assertEquals(remainder(Long.MIN_VALUE, -1), Long.MIN_VALUE % -1L);\n-\n-        try {\n-            divide(19, 0);\n-            Asserts.fail();\n-        } catch (ArithmeticException e) {}\n-        try {\n-            remainder(19, 0);\n-            Asserts.fail();\n-        } catch (ArithmeticException e) {}\n-        try {\n-            divide(19L, 0L);\n-            Asserts.fail();\n-        } catch (ArithmeticException e) {}\n-        try {\n-            remainder(19L, 0L);\n-            Asserts.fail();\n-        } catch (ArithmeticException e) {}\n-    }\n-\n-    static int divide(int x, int y) {\n-        return x \/ y;\n-    }\n-\n-    static int remainder(int x, int y) {\n-        return x % y;\n-    }\n-\n-    static long divide(long x, long y) {\n-        return x \/ y;\n-    }\n-\n-    static long remainder(long x, long y) {\n-        return x % y;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/integerArithmetic\/TestDivision.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -175,2 +175,2 @@\n-    public static final String DIV = START + \"(NoOvf)?Div(I|L|F|D)\" + MID + END;\n-    public static final String DIV_L = START + \"(NoOvf)?DivL\" + MID + END;\n+    public static final String DIV = START + \"Div(I|L|F|D)\" + MID + END;\n+    public static final String DIV_L = START + \"DivL\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import org.openjdk.jmh.annotations.Fork;\n@@ -38,0 +37,3 @@\n+\/**\n+ * Tests unsigned division and modulus methods in java.lang.Integer\n+ *\/\n@@ -41,1 +43,0 @@\n-@Fork(1)\n@@ -62,5 +63,2 @@\n-            if (divisorType.equals(\"positive\")) {\n-                divisor = Math.abs(divisor);\n-            } else if (divisorType.equals(\"negative\")) {\n-                divisor = -Math.abs(divisor);\n-            }\n+            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n+            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n@@ -71,22 +69,0 @@\n-    @Benchmark\n-    public void testDivide() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            quotients[i] = dividends[i] \/ divisors[i];\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testDivideKnownPositive() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            quotients[i] = dividends[i] \/ Math.max(1, divisors[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testDivideHoistedDivisor() {\n-        int x = divisors[0];\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            quotients[i] = dividends[i] \/ x;\n-        }\n-    }\n-\n@@ -118,0 +94,1 @@\n+\n@@ -119,0 +96,3 @@\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import org.openjdk.jmh.annotations.Fork;\n@@ -38,0 +37,3 @@\n+\/**\n+ * Tests unsigned division and modulus methods in java.lang.Long\n+ *\/\n@@ -41,1 +43,0 @@\n-@Fork(1)\n@@ -62,5 +63,2 @@\n-            if (divisorType.equals(\"positive\")) {\n-                divisor = Math.abs(divisor);\n-            } else if (divisorType.equals(\"negative\")) {\n-                divisor = -Math.abs(divisor);\n-            }\n+            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n+            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n@@ -71,22 +69,0 @@\n-    @Benchmark\n-    public void testDivide() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            quotients[i] = dividends[i] \/ divisors[i];\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testDivideKnownPositive() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            quotients[i] = dividends[i] \/ Math.max(1, divisors[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void testDivideHoistedDivisor() {\n-        long x = divisors[0];\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            quotients[i] = dividends[i] \/ x;\n-        }\n-    }\n-\n@@ -118,0 +94,1 @@\n+\n@@ -119,0 +96,3 @@\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"}]}