{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.ByteBuffer;\n@@ -39,0 +40,3 @@\n+import sun.nio.ch.DirectBuffer;\n+import sun.nio.ch.IOStatus;\n+import sun.nio.ch.Util;\n@@ -47,0 +51,3 @@\n+    \/\/ minimum size of a temporary direct buffer\n+    private static final int MIN_BUFFER_SIZE = 16384;\n+\n@@ -220,0 +227,41 @@\n+    \/\/ calculate the least common multiple of two values;\n+    \/\/ the parameters in general will be powers of two likely in the\n+    \/\/ range [4096, 65536] so this algorithm is expected to converge\n+    \/\/ when it is rarely called\n+    private static long lcm(long x, long y) {\n+        assert x > 0 && y > 0 : \"Non-positive parameter\";\n+\n+        long u = x;\n+        long v = y;\n+\n+        while (u != v) {\n+            if (u < v)\n+                u += x;\n+            else \/\/ u > v\n+                v += y;\n+        }\n+\n+        return u;\n+    }\n+\n+    \/\/ calculate temporary direct buffer size\n+    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n+        int bufferSize = MIN_BUFFER_SIZE;\n+        try {\n+            long bss = UnixFileStoreAttributes.get(source).blockSize();\n+            long bst = UnixFileStoreAttributes.get(target).blockSize();\n+            if (bss > 0 && bst > 0) {\n+                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n+            }\n+            if (bufferSize < MIN_BUFFER_SIZE) {\n+                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n+                bufferSize *= factor;\n+            }\n+        } catch (UnixException ignored) {\n+        }\n+        return bufferSize;\n+    }\n+\n+    \/\/ whether direct copying is supported on this platform\n+    private static volatile boolean directCopyNotSupported;\n+\n@@ -251,2 +299,3 @@\n-                \/\/ transfer bytes to target file\n-                try {\n+                boolean copied = false;\n+                if (!directCopyNotSupported) {\n+                    \/\/ copy bytes to target using platform function\n@@ -255,1 +304,8 @@\n-                        transfer(fo, fi, addressToPollForCancel);\n+                        int res = directCopy0(fo, fi, addressToPollForCancel);\n+                        if (res == 0) {\n+                            copied = true;\n+                        } else if (res == IOStatus.UNSUPPORTED) {\n+                            directCopyNotSupported = true;\n+                        }\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(source, target);\n@@ -259,2 +315,0 @@\n-                } catch (UnixException x) {\n-                    x.rethrowAsIOException(source, target);\n@@ -262,0 +316,20 @@\n+\n+                if (!copied) {\n+                    \/\/ copy bytes to target via a temporary direct buffer\n+                    int bufferSize = temporaryBufferSize(source, target);\n+                    ByteBuffer buf = Util.getTemporaryDirectBuffer(bufferSize);\n+                    try {\n+                        long comp = Blocker.begin();\n+                        try {\n+                            bufferedCopy0(fo, fi, ((DirectBuffer)buf).address(),\n+                                          bufferSize, addressToPollForCancel);\n+                        } catch (UnixException x) {\n+                            x.rethrowAsIOException(source, target);\n+                        } finally {\n+                            Blocker.end(comp);\n+                        }\n+                    } finally {\n+                        Util.releaseTemporaryDirectBuffer(buf);\n+                    }\n+                }\n+\n@@ -631,1 +705,32 @@\n-    static native void transfer(int dst, int src, long addressToPollForCancel)\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, UNAVAILABLE if the platform function would block,\n+     *         UNSUPPORTED_CASE if the call does not work with the given\n+     *         parameters, or UNSUPPORTED if direct copying is not supported\n+     *         on this platform\n+     *\/\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * an intermediate temporary direct buffer.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param address the address of the temporary direct buffer's array\n+     * @param size the size of the temporary direct buffer's array\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\/\n+    private static native void bufferedCopy0(int dst, int src, long address,\n+                                             int size, long addressToPollForCancel)\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":111,"deletions":6,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n@@ -35,0 +38,1 @@\n+#include <fcntl.h>\n@@ -71,2 +75,5 @@\n-\/\/ Transfer via user-space buffers\n-void transfer(JNIEnv* env, jint dst, jint src, volatile jint* cancel)\n+\/\/ Copy via an intermediate temporary direct buffer\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixCopyFile_bufferCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong address,\n+    jint transferSize, jlong cancelAddress)\n@@ -74,1 +81,12 @@\n-    char buf[8192];\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    char* buf = (char*)address;\n+\n+#if defined(__linux__)\n+    int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                 POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                 POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+\n+    \/\/ ignore the return value hence any failure\n+    posix_fadvise(src, 0, 0, advice);\n+#endif\n@@ -78,1 +96,1 @@\n-        RESTARTABLE(read((int)src, &buf, sizeof(buf)), n);\n+        RESTARTABLE(read((int)src, buf, transferSize), n);\n@@ -104,6 +122,12 @@\n-\/**\n- * Transfer all bytes from src to dst within the kernel if possible (Linux),\n- * otherwise via user-space buffers\n- *\/\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_UnixCopyFile_transfer\n+\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_UnixCopyFile_directCopy0\n@@ -122,8 +146,7 @@\n-        if (bytes_sent == -1) {\n-            if (errno == EINVAL || errno == ENOSYS) {\n-                \/\/ Fall back to copying via user-space buffers\n-                transfer(env, dst, src, cancel);\n-            } else {\n-                throwUnixException(env, errno);\n-            }\n-            return;\n+        if (bytes_sent < 0) {\n+            if (errno == EAGAIN)\n+                return IOS_UNAVAILABLE;\n+            if (errno == EINVAL || errno == ENOSYS)\n+                return IOS_UNSUPPORTED_CASE;\n+            throwUnixException(env, errno);\n+            return IOS_THROWN;\n@@ -133,1 +156,1 @@\n-            return;\n+            return IOS_THROWN;\n@@ -136,0 +159,2 @@\n+\n+    return 0;\n@@ -150,1 +175,1 @@\n-        return;\n+        return IOS_THROWN;\n@@ -154,0 +179,2 @@\n+\n+    return 0;\n@@ -155,1 +182,1 @@\n-    transfer(env, dst, src, cancel);\n+    return IOS_UNSUPPORTED;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":49,"deletions":22,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,1 @@\n+    public static final int COPY_FILE_NO_BUFFERING         = 0x00001000;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.file.*;\n@@ -30,0 +29,7 @@\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.CopyOption;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.LinkPermission;\n+import java.nio.file.StandardCopyOption;\n@@ -40,0 +46,3 @@\n+    \/\/ file size above which copying uses unbuffered I\/O\n+    private static final long UNBUFFERED_IO_THRESHOLD = 314572800; \/\/ 300 MiB\n+\n@@ -177,1 +186,3 @@\n-            final int flags = (!followLinks) ? COPY_FILE_COPY_SYMLINK : 0;\n+            final int flags = ((!followLinks) ? COPY_FILE_COPY_SYMLINK : 0) |\n+                              ((sourceAttrs.size() > UNBUFFERED_IO_THRESHOLD) ?\n+                                  COPY_FILE_NO_BUFFERING : 0);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileCopy.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"}]}