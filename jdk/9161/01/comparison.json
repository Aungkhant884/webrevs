{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.annotation.Native;\n@@ -33,0 +34,1 @@\n+import java.nio.file.Files;\n@@ -47,0 +49,2 @@\n+    @Native private static final long TRANSFER_SIZE = 8192;\n+\n@@ -220,0 +224,21 @@\n+    \/\/ calculate the least common multiple of two values;\n+    \/\/ the parameters in general will be powers of two likely in the\n+    \/\/ range [4096, 65536] so this algorithm is expected to converge\n+    \/\/ when it is rarely called\n+    private static long lcm(long x, long y) {\n+        if (x <= 0 || y <= 0)\n+            throw new IllegalArgumentException(\"Non-positive parameter\");\n+\n+        long u = x;\n+        long v = y;\n+\n+        while (u != v) {\n+            if (u < v)\n+                u += x;\n+            else \/\/ u > v\n+                v += y;\n+        }\n+\n+        return u;\n+    }\n+\n@@ -251,0 +276,11 @@\n+                long transferSize = TRANSFER_SIZE;\n+                try {\n+                    long bss = UnixFileStoreAttributes.get(source).blockSize();\n+                    long bst = UnixFileStoreAttributes.get(target).blockSize();\n+                    if (bss > 0 && bst > 0) {\n+                        transferSize = bss == bst ? bss : lcm(bss, bst);\n+                    }\n+                } catch (IllegalArgumentException | SecurityException |\n+                         UnixException | UnsupportedOperationException ignored) {\n+                }\n+\n@@ -255,1 +291,1 @@\n-                        transfer(fo, fi, addressToPollForCancel);\n+                        transfer0(fo, fi, transferSize, addressToPollForCancel);\n@@ -631,1 +667,2 @@\n-    static native void transfer(int dst, int src, long addressToPollForCancel)\n+    static native void transfer0(int dst, int src, long transferSize,\n+                                 long addressToPollForCancel)\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include <stdlib.h>\n@@ -40,0 +41,2 @@\n+#define DEFAULT_TRANSFER_SIZE (sun_nio_fs_UnixCopyFile_TRANSFER_SIZE)\n+\n@@ -72,1 +75,2 @@\n-void transfer(JNIEnv* env, jint dst, jint src, volatile jint* cancel)\n+void transfer(JNIEnv* env, jint dst, jint src, jlong transferSize,\n+              volatile jint* cancel)\n@@ -74,1 +78,15 @@\n-    char buf[8192];\n+    char stackBuf[DEFAULT_TRANSFER_SIZE];\n+    char* buf = NULL;\n+\n+    if ((unsigned long)transferSize > sizeof(stackBuf)) {\n+        \/\/ stack-allocated buffer is too small so malloc\n+        buf = (char*)malloc(transferSize*sizeof(char));\n+        if (buf == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, NULL);\n+            return;\n+        }\n+    } else {\n+        \/\/ use stack-allocated buffer\n+        buf = stackBuf;\n+        transferSize = sizeof(stackBuf);\n+    }\n@@ -78,1 +96,1 @@\n-        RESTARTABLE(read((int)src, &buf, sizeof(buf)), n);\n+        RESTARTABLE(read((int)src, buf, transferSize), n);\n@@ -82,1 +100,1 @@\n-            return;\n+            goto cleanup;\n@@ -86,1 +104,1 @@\n-            return;\n+            goto cleanup;\n@@ -96,1 +114,1 @@\n-                return;\n+                goto cleanup;\n@@ -102,0 +120,4 @@\n+\n+cleanup:\n+    if (buf != stackBuf)\n+        free(buf);\n@@ -109,2 +131,3 @@\n-Java_sun_nio_fs_UnixCopyFile_transfer\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+Java_sun_nio_fs_UnixCopyFile_transfer0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong transferSize,\n+    jlong cancelAddress)\n@@ -125,1 +148,1 @@\n-                transfer(env, dst, src, cancel);\n+                transfer(env, dst, src, transferSize, cancel);\n@@ -155,1 +178,1 @@\n-    transfer(env, dst, src, cancel);\n+    transfer(env, dst, src, transferSize, cancel);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":34,"deletions":11,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+    public static final int COPY_FILE_NO_BUFFERING         = 0x00001000;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,3 @@\n+    \/\/ file size above which copying uses unbuffered I\/O\n+    private static final long UNBUFFERED_IO_THRESHOLD = 314572800; \/\/ 300 MiB\n+\n@@ -177,1 +180,7 @@\n-            final int flags = (!followLinks) ? COPY_FILE_COPY_SYMLINK : 0;\n+            long size = 0;\n+            try {\n+                size = Files.size(source);\n+            } catch (IOException ignored) {\n+            }\n+            final int flags = ((!followLinks) ? COPY_FILE_COPY_SYMLINK : 0) |\n+                ((size > UNBUFFERED_IO_THRESHOLD) ? COPY_FILE_NO_BUFFERING : 0);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileCopy.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}