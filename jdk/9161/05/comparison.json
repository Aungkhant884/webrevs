{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.ByteBuffer;\n@@ -33,0 +34,1 @@\n+import java.nio.file.Files;\n@@ -39,0 +41,3 @@\n+import sun.nio.ch.DirectBuffer;\n+import sun.nio.ch.IOStatus;\n+import sun.nio.ch.Util;\n@@ -47,0 +52,3 @@\n+    \/\/ minimum size of user-space copy buffer\n+    private static final int MIN_TRANSFER_SIZE = 16384;\n+\n@@ -220,0 +228,43 @@\n+    \/\/ calculate the least common multiple of two values;\n+    \/\/ the parameters in general will be powers of two likely in the\n+    \/\/ range [4096, 65536] so this algorithm is expected to converge\n+    \/\/ when it is rarely called\n+    private static long lcm(long x, long y) {\n+        if (x <= 0 || y <= 0)\n+            throw new IllegalArgumentException(\"Non-positive parameter\");\n+\n+        long u = x;\n+        long v = y;\n+\n+        while (u != v) {\n+            if (u < v)\n+                u += x;\n+            else \/\/ u > v\n+                v += y;\n+        }\n+\n+        return u;\n+    }\n+\n+    \/\/ calculate user-space copy buffer size\n+    private static int computeTransferSize(UnixPath source, UnixPath target) {\n+        int transferSize = MIN_TRANSFER_SIZE;\n+        try {\n+            long bss = UnixFileStoreAttributes.get(source).blockSize();\n+            long bst = UnixFileStoreAttributes.get(target).blockSize();\n+            if (bss > 0 && bst > 0) {\n+                transferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n+            }\n+            if (transferSize < MIN_TRANSFER_SIZE) {\n+                int factor = (MIN_TRANSFER_SIZE + transferSize - 1)\/transferSize;\n+                transferSize *= factor;\n+            }\n+        } catch (IllegalArgumentException | UnixException\n+                 ignored) {\n+        }\n+        return transferSize;\n+    }\n+\n+    \/\/ whether transferring instead of user-space copy is unsupported\n+    private static volatile boolean transferNotSupported;\n+\n@@ -251,3 +302,3 @@\n-                \/\/ transfer bytes to target file\n-                try {\n-                    long comp = Blocker.begin();\n+                boolean transferred = false;\n+                if (!transferNotSupported) {\n+                    \/\/ transfer bytes to target file\n@@ -255,3 +306,17 @@\n-                        transfer(fo, fi, addressToPollForCancel);\n-                    } finally {\n-                        Blocker.end(comp);\n+                        int res;\n+                        do {\n+                            long comp = Blocker.begin();\n+                            try {\n+                                res = transfer0(fo, fi, addressToPollForCancel);\n+                            } finally {\n+                                Blocker.end(comp);\n+                            }\n+                        } while (res == IOStatus.INTERRUPTED);\n+\n+                        if (res == IOStatus.UNSUPPORTED) {\n+                            transferNotSupported = true;\n+                        } else if (res == 0) {\n+                            transferred = true;\n+                        }\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(source, target);\n@@ -259,2 +324,0 @@\n-                } catch (UnixException x) {\n-                    x.rethrowAsIOException(source, target);\n@@ -262,0 +325,22 @@\n+\n+                if (!transferred) {\n+                    \/\/  determine copy buffer size\n+                    int transferSize = computeTransferSize(source, target);\n+\n+                    \/\/ copy bytes to target file\n+                    try {\n+                        long comp = Blocker.begin();\n+                        ByteBuffer buf =\n+                            Util.getTemporaryDirectBuffer(transferSize);\n+                        try {\n+                            copy0(fo, fi, ((DirectBuffer)buf).address(),\n+                                  transferSize, addressToPollForCancel);\n+                        } finally {\n+                            Util.releaseTemporaryDirectBuffer(buf);\n+                            Blocker.end(comp);\n+                        }\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(source, target);\n+                    }\n+                }\n+\n@@ -631,1 +716,8 @@\n-    static native void transfer(int dst, int src, long addressToPollForCancel)\n+    \/\/ returns 0 on success, INTERRUPTED if the system call was interrupted,\n+    \/\/ UNSUPPORTED_CASE if the call does not work with the supplied parameters,\n+    \/\/ or UNSUPPORTED if the operation is not supported on this platform\n+    static native int transfer0(int dst, int src, long addressToPollForCancel)\n+        throws UnixException;\n+\n+    static native void copy0(int dst, int src, long address, int transferSize,\n+                             long addressToPollForCancel)\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":101,"deletions":9,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n@@ -35,0 +38,1 @@\n+#include <fcntl.h>\n@@ -72,1 +76,4 @@\n-void transfer(JNIEnv* env, jint dst, jint src, volatile jint* cancel)\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixCopyFile_copy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong address,\n+    jint transferSize, jlong cancelAddress)\n@@ -74,1 +81,12 @@\n-    char buf[8192];\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    char* buf = (char*)address;\n+\n+#if defined(__linux__)\n+    int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                 POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                 POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+\n+    \/\/ ignore the return value hence any failure\n+    posix_fadvise(src, 0, 0, advice);\n+#endif\n@@ -78,1 +96,1 @@\n-        RESTARTABLE(read((int)src, &buf, sizeof(buf)), n);\n+        RESTARTABLE(read((int)src, buf, transferSize), n);\n@@ -108,2 +126,2 @@\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_UnixCopyFile_transfer\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_UnixCopyFile_transfer0\n@@ -122,4 +140,5 @@\n-        if (bytes_sent == -1) {\n-            if (errno == EINVAL || errno == ENOSYS) {\n-                \/\/ Fall back to copying via user-space buffers\n-                transfer(env, dst, src, cancel);\n+        if (bytes_sent < 0) {\n+            if (errno == EINTR) {\n+                return IOS_INTERRUPTED;\n+            } else if (errno == EINVAL || errno == ENOSYS) {\n+                return IOS_UNSUPPORTED_CASE;\n@@ -129,1 +148,1 @@\n-            return;\n+            return IOS_THROWN;\n@@ -133,1 +152,1 @@\n-            return;\n+            return IOS_THROWN;\n@@ -136,0 +155,2 @@\n+\n+    return 0;\n@@ -150,1 +171,1 @@\n-        return;\n+        return IOS_THROWN;\n@@ -154,0 +175,2 @@\n+\n+    return 0;\n@@ -155,1 +178,1 @@\n-    transfer(env, dst, src, cancel);\n+    return IOS_UNSUPPORTED;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+    public static final int COPY_FILE_NO_BUFFERING         = 0x00001000;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,3 @@\n+    \/\/ file size above which copying uses unbuffered I\/O\n+    private static final long UNBUFFERED_IO_THRESHOLD = 314572800; \/\/ 300 MiB\n+\n@@ -177,1 +180,8 @@\n-            final int flags = (!followLinks) ? COPY_FILE_COPY_SYMLINK : 0;\n+            long size = 0;\n+            try {\n+                size = Files.size(source);\n+            } catch (IOException ignored) {\n+            }\n+            final int flags = ((!followLinks) ? COPY_FILE_COPY_SYMLINK : 0) |\n+                              ((sourceAttrs.size() > UNBUFFERED_IO_THRESHOLD) ?\n+                                  COPY_FILE_NO_BUFFERING : 0);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileCopy.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}