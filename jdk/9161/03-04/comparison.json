{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.nio.ByteBuffer;\n@@ -41,0 +42,2 @@\n+import sun.nio.ch.DirectBuffer;\n+import sun.nio.ch.Util;\n@@ -49,1 +52,1 @@\n-    @Native private static final long MIN_TRANSFER_SIZE = 16384;\n+    @Native private static final int MIN_TRANSFER_SIZE = 16384;\n@@ -245,0 +248,3 @@\n+    \/\/ whether transfer0() requires a buffer address\n+    private static final boolean transferRequiresBuffer = transferRequiresBuffer0();\n+\n@@ -276,10 +282,14 @@\n-                long ts = MIN_TRANSFER_SIZE;\n-                try {\n-                    long bss = UnixFileStoreAttributes.get(source).blockSize();\n-                    long bst = UnixFileStoreAttributes.get(target).blockSize();\n-                    if (bss > 0 && bst > 0) {\n-                        ts = bss == bst ? bss : lcm(bss, bst);\n-                    }\n-                    if (ts < MIN_TRANSFER_SIZE) {\n-                        int factor = (int)((MIN_TRANSFER_SIZE + ts - 1)\/ts);\n-                        ts *= factor;\n+                int transferSize = MIN_TRANSFER_SIZE;\n+                if (transferRequiresBuffer) {\n+                    int ts = MIN_TRANSFER_SIZE;\n+                    try {\n+                        long bss = UnixFileStoreAttributes.get(source).blockSize();\n+                        long bst = UnixFileStoreAttributes.get(target).blockSize();\n+                        if (bss > 0 && bst > 0) {\n+                            ts = (int)(bss == bst ? bss : lcm(bss, bst));\n+                        }\n+                        if (ts < MIN_TRANSFER_SIZE) {\n+                            int factor = (MIN_TRANSFER_SIZE + ts - 1)\/ts;\n+                            ts *= factor;\n+                        }\n+                    } catch (IllegalArgumentException | UnixException ignored) {\n@@ -287,1 +297,1 @@\n-                } catch (IllegalArgumentException | UnixException ignored) {\n+                    transferSize = ts;\n@@ -292,0 +302,6 @@\n+                    ByteBuffer buf = null;\n+                    long address = 0L;\n+                    if (transferRequiresBuffer) {\n+                        buf = Util.getTemporaryDirectBuffer(transferSize);\n+                        address = ((DirectBuffer)buf).address();\n+                    }\n@@ -294,1 +310,2 @@\n-                        transfer0(fo, fi, ts, addressToPollForCancel);\n+                        transfer0(fo, fi, address, transferSize,\n+                                  addressToPollForCancel);\n@@ -296,0 +313,3 @@\n+                        if (buf != null) {\n+                            Util.releaseTemporaryDirectBuffer(buf);\n+                        }\n@@ -301,0 +321,1 @@\n+\n@@ -670,1 +691,3 @@\n-    static native void transfer0(int dst, int src, long transferSize,\n+    static native boolean transferRequiresBuffer0();\n+\n+    static native void transfer0(int dst, int src, long address, int size,\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -73,1 +73,2 @@\n-#endif\n+\n+#else\n@@ -76,1 +77,1 @@\n-void transfer(JNIEnv* env, jint dst, jint src, jlong transferSize,\n+void transfer(JNIEnv* env, jint dst, jint src, jlong address, jint transferSize,\n@@ -79,2 +80,6 @@\n-    char stackBuf[MIN_TRANSFER_SIZE];\n-    char* buf = NULL;\n+    char* buf = (char*)address;\n+\n+    if (buf == NULL) {\n+        JNU_ThrowNullPointerException(env, \"Buffer address is NULL\");\n+        return;\n+    }\n@@ -91,13 +96,0 @@\n-    if ((unsigned long)transferSize > sizeof(stackBuf)) {\n-        \/\/ stack-allocated buffer is too small so malloc\n-        buf = (char*)malloc(transferSize*sizeof(char));\n-        if (buf == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n-            return;\n-        }\n-    } else {\n-        \/\/ use stack-allocated buffer\n-        buf = stackBuf;\n-        transferSize = sizeof(stackBuf);\n-    }\n-\n@@ -110,1 +102,1 @@\n-            goto cleanup;\n+            return;\n@@ -114,1 +106,1 @@\n-            goto cleanup;\n+            return;\n@@ -124,1 +116,1 @@\n-                goto cleanup;\n+                return;\n@@ -130,0 +122,2 @@\n+}\n+#endif\n@@ -131,3 +125,9 @@\n-cleanup:\n-    if (buf != stackBuf)\n-        free(buf);\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_fs_UnixCopyFile_transferRequiresBuffer0\n+    (JNIEnv *env, jclass this)\n+{\n+#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n+    return JNI_FALSE;\n+#else\n+    return JNI_TRUE;\n+#endif\n@@ -142,2 +142,2 @@\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong transferSize,\n-    jlong cancelAddress)\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong address, jint size,\n+   jlong cancelAddress)\n@@ -158,1 +158,2 @@\n-                transfer(env, dst, src, transferSize, cancel);\n+                char buf[MIN_TRANSFER_SIZE];\n+                transfer(env, dst, src, (jlong)buf, sizeof(buf), cancel);\n@@ -188,1 +189,1 @@\n-    transfer(env, dst, src, transferSize, cancel);\n+    transfer(env, dst, src, address, size, cancel);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}