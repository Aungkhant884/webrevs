{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.annotation.Native;\n@@ -43,0 +42,1 @@\n+import sun.nio.ch.IOStatus;\n@@ -52,1 +52,2 @@\n-    @Native private static final int MIN_TRANSFER_SIZE = 16384;\n+    \/\/ minimum size of user-space copy buffer\n+    private static final int MIN_TRANSFER_SIZE = 16384;\n@@ -248,2 +249,21 @@\n-    \/\/ whether transfer0() requires a buffer address\n-    private static final boolean transferRequiresBuffer = transferRequiresBuffer0();\n+    \/\/ calculate user-space copy buffer size\n+    private static int computeTransferSize(UnixPath source, UnixPath target) {\n+        int transferSize = MIN_TRANSFER_SIZE;\n+        try {\n+            long bss = UnixFileStoreAttributes.get(source).blockSize();\n+            long bst = UnixFileStoreAttributes.get(target).blockSize();\n+            if (bss > 0 && bst > 0) {\n+                transferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n+            }\n+            if (transferSize < MIN_TRANSFER_SIZE) {\n+                int factor = (MIN_TRANSFER_SIZE + transferSize - 1)\/transferSize;\n+                transferSize *= factor;\n+            }\n+        } catch (IllegalArgumentException | UnixException\n+                 ignored) {\n+        }\n+        return transferSize;\n+    }\n+\n+    \/\/ whether transferring instead of user-space copy is unsupported\n+    private static volatile boolean transferNotSupported;\n@@ -282,3 +302,3 @@\n-                int transferSize = MIN_TRANSFER_SIZE;\n-                if (transferRequiresBuffer) {\n-                    int ts = MIN_TRANSFER_SIZE;\n+                boolean transferred = false;\n+                if (!transferNotSupported) {\n+                    \/\/ transfer bytes to target file\n@@ -286,4 +306,14 @@\n-                        long bss = UnixFileStoreAttributes.get(source).blockSize();\n-                        long bst = UnixFileStoreAttributes.get(target).blockSize();\n-                        if (bss > 0 && bst > 0) {\n-                            ts = (int)(bss == bst ? bss : lcm(bss, bst));\n+                        int res;\n+                        do {\n+                            long comp = Blocker.begin();\n+                            try {\n+                                res = transfer0(fo, fi, addressToPollForCancel);\n+                            } finally {\n+                                Blocker.end(comp);\n+                            }\n+                        } while (res == IOStatus.INTERRUPTED);\n+\n+                        if (res == IOStatus.UNSUPPORTED) {\n+                            transferNotSupported = true;\n+                        } else if (res == 0) {\n+                            transferred = true;\n@@ -291,5 +321,2 @@\n-                        if (ts < MIN_TRANSFER_SIZE) {\n-                            int factor = (MIN_TRANSFER_SIZE + ts - 1)\/ts;\n-                            ts *= factor;\n-                        }\n-                    } catch (IllegalArgumentException | UnixException ignored) {\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(source, target);\n@@ -297,1 +324,0 @@\n-                    transferSize = ts;\n@@ -300,9 +326,5 @@\n-                \/\/ transfer bytes to target file\n-                try {\n-                    ByteBuffer buf = null;\n-                    long address = 0L;\n-                    if (transferRequiresBuffer) {\n-                        buf = Util.getTemporaryDirectBuffer(transferSize);\n-                        address = ((DirectBuffer)buf).address();\n-                    }\n-                    long comp = Blocker.begin();\n+                if (!transferred) {\n+                    \/\/  determine copy buffer size\n+                    int transferSize = computeTransferSize(source, target);\n+\n+                    \/\/ copy bytes to target file\n@@ -310,4 +332,7 @@\n-                        transfer0(fo, fi, address, transferSize,\n-                                  addressToPollForCancel);\n-                    } finally {\n-                        if (buf != null) {\n+                        long comp = Blocker.begin();\n+                        ByteBuffer buf =\n+                            Util.getTemporaryDirectBuffer(transferSize);\n+                        try {\n+                            copy0(fo, fi, ((DirectBuffer)buf).address(),\n+                                  transferSize, addressToPollForCancel);\n+                        } finally {\n@@ -315,0 +340,1 @@\n+                            Blocker.end(comp);\n@@ -316,1 +342,2 @@\n-                        Blocker.end(comp);\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(source, target);\n@@ -318,2 +345,0 @@\n-                } catch (UnixException x) {\n-                    x.rethrowAsIOException(source, target);\n@@ -691,1 +716,5 @@\n-    static native boolean transferRequiresBuffer0();\n+    \/\/ returns 0 on success, INTERRUPTED if the system call was interrupted,\n+    \/\/ UNSUPPORTED_CASE if the call does not work with the supplied parameters,\n+    \/\/ or UNSUPPORTED if the operation is not supported on this platform\n+    static native int transfer0(int dst, int src, long addressToPollForCancel)\n+        throws UnixException;\n@@ -693,2 +722,2 @@\n-    static native void transfer0(int dst, int src, long address, int size,\n-                                 long addressToPollForCancel)\n+    static native void copy0(int dst, int src, long address, int transferSize,\n+                             long addressToPollForCancel)\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":65,"deletions":36,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"nio.h\"\n+\n@@ -42,2 +44,0 @@\n-#define MIN_TRANSFER_SIZE (sun_nio_fs_UnixCopyFile_MIN_TRANSFER_SIZE)\n-\n@@ -73,2 +73,1 @@\n-\n-#else\n+#endif\n@@ -77,2 +76,4 @@\n-void transfer(JNIEnv* env, jint dst, jint src, jlong address, jint transferSize,\n-              volatile jint* cancel)\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixCopyFile_copy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong address,\n+    jint transferSize, jlong cancelAddress)\n@@ -80,1 +81,1 @@\n-    char* buf = (char*)address;\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n@@ -82,4 +83,1 @@\n-    if (buf == NULL) {\n-        JNU_ThrowNullPointerException(env, \"Buffer address is NULL\");\n-        return;\n-    }\n+    char* buf = (char*)address;\n@@ -123,12 +121,0 @@\n-#endif\n-\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_fs_UnixCopyFile_transferRequiresBuffer0\n-    (JNIEnv *env, jclass this)\n-{\n-#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n-    return JNI_FALSE;\n-#else\n-    return JNI_TRUE;\n-#endif\n-}\n@@ -140,1 +126,1 @@\n-JNIEXPORT void JNICALL\n+JNIEXPORT jint JNICALL\n@@ -142,2 +128,1 @@\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong address, jint size,\n-   jlong cancelAddress)\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n@@ -155,5 +140,5 @@\n-        if (bytes_sent == -1) {\n-            if (errno == EINVAL || errno == ENOSYS) {\n-                \/\/ Fall back to copying via user-space buffers\n-                char buf[MIN_TRANSFER_SIZE];\n-                transfer(env, dst, src, (jlong)buf, sizeof(buf), cancel);\n+        if (bytes_sent < 0) {\n+            if (errno == EINTR) {\n+                return IOS_INTERRUPTED;\n+            } else if (errno == EINVAL || errno == ENOSYS) {\n+                return IOS_UNSUPPORTED_CASE;\n@@ -163,1 +148,1 @@\n-            return;\n+            return IOS_THROWN;\n@@ -167,1 +152,1 @@\n-            return;\n+            return IOS_THROWN;\n@@ -170,0 +155,2 @@\n+\n+    return 0;\n@@ -184,1 +171,1 @@\n-        return;\n+        return IOS_THROWN;\n@@ -188,0 +175,2 @@\n+\n+    return 0;\n@@ -189,1 +178,1 @@\n-    transfer(env, dst, src, address, size, cancel);\n+    return IOS_UNSUPPORTED;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":24,"deletions":35,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,2 @@\n-                ((size > UNBUFFERED_IO_THRESHOLD) ? COPY_FILE_NO_BUFFERING : 0);\n+                              ((sourceAttrs.size() > UNBUFFERED_IO_THRESHOLD) ?\n+                                  COPY_FILE_NO_BUFFERING : 0);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileCopy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}