{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.annotation.Native;\n+import java.nio.ByteBuffer;\n@@ -33,0 +35,1 @@\n+import java.nio.file.Files;\n@@ -39,0 +42,2 @@\n+import sun.nio.ch.DirectBuffer;\n+import sun.nio.ch.Util;\n@@ -47,0 +52,2 @@\n+    @Native private static final int MIN_TRANSFER_SIZE = 16384;\n+\n@@ -220,0 +227,24 @@\n+    \/\/ calculate the least common multiple of two values;\n+    \/\/ the parameters in general will be powers of two likely in the\n+    \/\/ range [4096, 65536] so this algorithm is expected to converge\n+    \/\/ when it is rarely called\n+    private static long lcm(long x, long y) {\n+        if (x <= 0 || y <= 0)\n+            throw new IllegalArgumentException(\"Non-positive parameter\");\n+\n+        long u = x;\n+        long v = y;\n+\n+        while (u != v) {\n+            if (u < v)\n+                u += x;\n+            else \/\/ u > v\n+                v += y;\n+        }\n+\n+        return u;\n+    }\n+\n+    \/\/ whether transfer0() requires a buffer address\n+    private static final boolean transferRequiresBuffer = transferRequiresBuffer0();\n+\n@@ -251,0 +282,18 @@\n+                int transferSize = MIN_TRANSFER_SIZE;\n+                if (transferRequiresBuffer) {\n+                    int ts = MIN_TRANSFER_SIZE;\n+                    try {\n+                        long bss = UnixFileStoreAttributes.get(source).blockSize();\n+                        long bst = UnixFileStoreAttributes.get(target).blockSize();\n+                        if (bss > 0 && bst > 0) {\n+                            ts = (int)(bss == bst ? bss : lcm(bss, bst));\n+                        }\n+                        if (ts < MIN_TRANSFER_SIZE) {\n+                            int factor = (MIN_TRANSFER_SIZE + ts - 1)\/ts;\n+                            ts *= factor;\n+                        }\n+                    } catch (IllegalArgumentException | UnixException ignored) {\n+                    }\n+                    transferSize = ts;\n+                }\n+\n@@ -253,0 +302,6 @@\n+                    ByteBuffer buf = null;\n+                    long address = 0L;\n+                    if (transferRequiresBuffer) {\n+                        buf = Util.getTemporaryDirectBuffer(transferSize);\n+                        address = ((DirectBuffer)buf).address();\n+                    }\n@@ -255,1 +310,2 @@\n-                        transfer(fo, fi, addressToPollForCancel);\n+                        transfer0(fo, fi, address, transferSize,\n+                                  addressToPollForCancel);\n@@ -257,0 +313,3 @@\n+                        if (buf != null) {\n+                            Util.releaseTemporaryDirectBuffer(buf);\n+                        }\n@@ -262,0 +321,1 @@\n+\n@@ -631,1 +691,4 @@\n-    static native void transfer(int dst, int src, long addressToPollForCancel)\n+    static native boolean transferRequiresBuffer0();\n+\n+    static native void transfer0(int dst, int src, long address, int size,\n+                                 long addressToPollForCancel)\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":65,"deletions":2,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include <stdlib.h>\n@@ -35,0 +36,1 @@\n+#include <fcntl.h>\n@@ -40,0 +42,2 @@\n+#define MIN_TRANSFER_SIZE (sun_nio_fs_UnixCopyFile_MIN_TRANSFER_SIZE)\n+\n@@ -69,1 +73,2 @@\n-#endif\n+\n+#else\n@@ -72,1 +77,2 @@\n-void transfer(JNIEnv* env, jint dst, jint src, volatile jint* cancel)\n+void transfer(JNIEnv* env, jint dst, jint src, jlong address, jint transferSize,\n+              volatile jint* cancel)\n@@ -74,1 +80,15 @@\n-    char buf[8192];\n+    char* buf = (char*)address;\n+\n+    if (buf == NULL) {\n+        JNU_ThrowNullPointerException(env, \"Buffer address is NULL\");\n+        return;\n+    }\n+\n+#if defined(__linux__)\n+    int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                 POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                 POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+\n+    \/\/ ignore the return value hence any failure\n+    posix_fadvise(src, 0, 0, advice);\n+#endif\n@@ -78,1 +98,1 @@\n-        RESTARTABLE(read((int)src, &buf, sizeof(buf)), n);\n+        RESTARTABLE(read((int)src, buf, transferSize), n);\n@@ -103,0 +123,12 @@\n+#endif\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_fs_UnixCopyFile_transferRequiresBuffer0\n+    (JNIEnv *env, jclass this)\n+{\n+#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n+    return JNI_FALSE;\n+#else\n+    return JNI_TRUE;\n+#endif\n+}\n@@ -109,2 +141,3 @@\n-Java_sun_nio_fs_UnixCopyFile_transfer\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+Java_sun_nio_fs_UnixCopyFile_transfer0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong address, jint size,\n+   jlong cancelAddress)\n@@ -125,1 +158,2 @@\n-                transfer(env, dst, src, cancel);\n+                char buf[MIN_TRANSFER_SIZE];\n+                transfer(env, dst, src, (jlong)buf, sizeof(buf), cancel);\n@@ -155,1 +189,1 @@\n-    transfer(env, dst, src, cancel);\n+    transfer(env, dst, src, address, size, cancel);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":43,"deletions":9,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,1 @@\n+    public static final int COPY_FILE_NO_BUFFERING         = 0x00001000;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,3 @@\n+    \/\/ file size above which copying uses unbuffered I\/O\n+    private static final long UNBUFFERED_IO_THRESHOLD = 314572800; \/\/ 300 MiB\n+\n@@ -177,1 +180,7 @@\n-            final int flags = (!followLinks) ? COPY_FILE_COPY_SYMLINK : 0;\n+            long size = 0;\n+            try {\n+                size = Files.size(source);\n+            } catch (IOException ignored) {\n+            }\n+            final int flags = ((!followLinks) ? COPY_FILE_COPY_SYMLINK : 0) |\n+                ((size > UNBUFFERED_IO_THRESHOLD) ? COPY_FILE_NO_BUFFERING : 0);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileCopy.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}