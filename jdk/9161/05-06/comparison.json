{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.file.Files;\n@@ -52,2 +51,2 @@\n-    \/\/ minimum size of user-space copy buffer\n-    private static final int MIN_TRANSFER_SIZE = 16384;\n+    \/\/ minimum size of a temporary direct buffer\n+    private static final int MIN_BUFFER_SIZE = 16384;\n@@ -249,3 +248,3 @@\n-    \/\/ calculate user-space copy buffer size\n-    private static int computeTransferSize(UnixPath source, UnixPath target) {\n-        int transferSize = MIN_TRANSFER_SIZE;\n+    \/\/ calculate temporary direct buffer size\n+    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n+        int bufferSize = MIN_BUFFER_SIZE;\n@@ -256,1 +255,1 @@\n-                transferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n+                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n@@ -258,3 +257,3 @@\n-            if (transferSize < MIN_TRANSFER_SIZE) {\n-                int factor = (MIN_TRANSFER_SIZE + transferSize - 1)\/transferSize;\n-                transferSize *= factor;\n+            if (bufferSize < MIN_BUFFER_SIZE) {\n+                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n+                bufferSize *= factor;\n@@ -262,2 +261,1 @@\n-        } catch (IllegalArgumentException | UnixException\n-                 ignored) {\n+        } catch (IllegalArgumentException | UnixException ignored) {\n@@ -265,1 +263,1 @@\n-        return transferSize;\n+        return bufferSize;\n@@ -268,2 +266,2 @@\n-    \/\/ whether transferring instead of user-space copy is unsupported\n-    private static volatile boolean transferNotSupported;\n+    \/\/ whether direct copying is supported on this platform\n+    private static volatile boolean directCopyNotSupported;\n@@ -302,3 +300,4 @@\n-                boolean transferred = false;\n-                if (!transferNotSupported) {\n-                    \/\/ transfer bytes to target file\n+                boolean copied = false;\n+                if (!directCopyNotSupported) {\n+                    \/\/ copy bytes to target using platform function\n+                    long comp = Blocker.begin();\n@@ -306,14 +305,5 @@\n-                        int res;\n-                        do {\n-                            long comp = Blocker.begin();\n-                            try {\n-                                res = transfer0(fo, fi, addressToPollForCancel);\n-                            } finally {\n-                                Blocker.end(comp);\n-                            }\n-                        } while (res == IOStatus.INTERRUPTED);\n-\n-                        if (res == IOStatus.UNSUPPORTED) {\n-                            transferNotSupported = true;\n-                        } else if (res == 0) {\n-                            transferred = true;\n+                        int res = directCopy0(fo, fi, addressToPollForCancel);\n+                        if (res == 0) {\n+                            copied = true;\n+                        } else if (res == IOStatus.UNSUPPORTED) {\n+                            directCopyNotSupported = true;\n@@ -323,0 +313,2 @@\n+                    } finally {\n+                        Blocker.end(comp);\n@@ -326,5 +318,5 @@\n-                if (!transferred) {\n-                    \/\/  determine copy buffer size\n-                    int transferSize = computeTransferSize(source, target);\n-\n-                    \/\/ copy bytes to target file\n+                if (!copied) {\n+                    \/\/ copy bytes to target via a temporary direct buffer\n+                    int bufferSize = temporaryBufferSize(source, target);\n+                    ByteBuffer buf = Util.getTemporaryDirectBuffer(bufferSize);\n+                    long comp = Blocker.begin();\n@@ -332,10 +324,2 @@\n-                        long comp = Blocker.begin();\n-                        ByteBuffer buf =\n-                            Util.getTemporaryDirectBuffer(transferSize);\n-                        try {\n-                            copy0(fo, fi, ((DirectBuffer)buf).address(),\n-                                  transferSize, addressToPollForCancel);\n-                        } finally {\n-                            Util.releaseTemporaryDirectBuffer(buf);\n-                            Blocker.end(comp);\n-                        }\n+                        bufferCopy0(fo, fi, ((DirectBuffer)buf).address(),\n+                                    bufferSize, addressToPollForCancel);\n@@ -344,0 +328,3 @@\n+                    } finally {\n+                        Util.releaseTemporaryDirectBuffer(buf);\n+                        Blocker.end(comp);\n@@ -716,4 +703,17 @@\n-    \/\/ returns 0 on success, INTERRUPTED if the system call was interrupted,\n-    \/\/ UNSUPPORTED_CASE if the call does not work with the supplied parameters,\n-    \/\/ or UNSUPPORTED if the operation is not supported on this platform\n-    static native int transfer0(int dst, int src, long addressToPollForCancel)\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, UNAVAILABLE if the platform function would block,\n+     *         UNSUPPORTED_CASE if the call does not work with the given\n+     *         parameters, or UNSUPPORTED if direct copying is not supported\n+     *         on this platform\n+     *\/\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n@@ -722,2 +722,13 @@\n-    static native void copy0(int dst, int src, long address, int transferSize,\n-                             long addressToPollForCancel)\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * an intermediate temporary direct buffer.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param address the address of the temporary direct buffer's array\n+     * @param size the size of the temporary direct buffer's array\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\/\n+    private static native void bufferCopy0(int dst, int src, long address,\n+                                           int size, long addressToPollForCancel)\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":64,"deletions":53,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-\/\/ Transfer via user-space buffers\n+\/\/ Copy via an intermediate temporary direct buffer\n@@ -77,1 +77,1 @@\n-Java_sun_nio_fs_UnixCopyFile_copy0\n+Java_sun_nio_fs_UnixCopyFile_bufferCopy0\n@@ -122,4 +122,10 @@\n-\/**\n- * Transfer all bytes from src to dst within the kernel if possible (Linux),\n- * otherwise via user-space buffers\n- *\/\n+\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n@@ -127,1 +133,1 @@\n-Java_sun_nio_fs_UnixCopyFile_transfer0\n+Java_sun_nio_fs_UnixCopyFile_directCopy0\n@@ -141,3 +147,3 @@\n-            if (errno == EINTR) {\n-                return IOS_INTERRUPTED;\n-            } else if (errno == EINVAL || errno == ENOSYS) {\n+            if (errno == EAGAIN)\n+                return IOS_UNAVAILABLE;\n+            if (errno == EINVAL || errno == ENOSYS)\n@@ -145,3 +151,1 @@\n-            } else {\n-                throwUnixException(env, errno);\n-            }\n+            throwUnixException(env, errno);\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}