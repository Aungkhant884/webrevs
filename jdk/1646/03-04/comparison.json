{"files":[{"patch":"@@ -1,213 +0,0 @@\n-\/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * This file is available under and governed by the GNU General Public\n- * License version 2 only, as published by the Free Software Foundation.\n- * However, the following notice accompanied the original version of this\n- * file:\n- *\n- * Written by Doug Lea and Martin Buchholz with assistance from\n- * members of JCP JSR-166 Expert Group and released to the public\n- * domain, as explained at\n- * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8004138 8205576\n- * @modules java.base\/java.util.concurrent:open\n- * @run testng FJExceptionTableLeak\n- * @summary Checks that ForkJoinTask thrown exceptions are not leaked.\n- * This whitebox test is sensitive to forkjoin implementation details.\n- *\/\n-\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n-\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ForkJoinPool;\n-import java.util.concurrent.ForkJoinTask;\n-import java.util.concurrent.RecursiveAction;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.function.BooleanSupplier;\n-\n-@Test\n-public class FJExceptionTableLeak {\n-    final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n-    VarHandle NEXT, EX;\n-    Object[] exceptionTable;\n-    ReentrantLock exceptionTableLock;\n-\n-    FJExceptionTableLeak() {\n-        \/\/ initialize separately to allow to pass with FJ versions without table\n-    }\n-\n-    void init() throws ReflectiveOperationException {\n-        MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(\n-            ForkJoinTask.class, MethodHandles.lookup());\n-        Class<?> nodeClass = Class.forName(\n-            ForkJoinTask.class.getName() + \"$ExceptionNode\");\n-        VarHandle exceptionTableHandle = lookup.findStaticVarHandle(\n-            ForkJoinTask.class, \"exceptionTable\", arrayClass(nodeClass));\n-        VarHandle exceptionTableLockHandle = lookup.findStaticVarHandle(\n-            ForkJoinTask.class, \"exceptionTableLock\", ReentrantLock.class);\n-        exceptionTable = (Object[]) exceptionTableHandle.get();\n-        exceptionTableLock = (ReentrantLock) exceptionTableLockHandle.get();\n-\n-        NEXT = lookup.findVarHandle(nodeClass, \"next\", nodeClass);\n-        EX = lookup.findVarHandle(nodeClass, \"ex\", Throwable.class);\n-    }\n-\n-    static <T> Class<T[]> arrayClass(Class<T> klazz) {\n-        try {\n-            return (Class<T[]>) Class.forName(\"[L\" + klazz.getName() + \";\");\n-        } catch (ReflectiveOperationException ex) {\n-            throw new Error(ex);\n-        }\n-    }\n-\n-    Object next(Object node) { return NEXT.get(node); }\n-    Throwable ex(Object node) { return (Throwable) EX.get(node); }\n-\n-    static class FailingTaskException extends RuntimeException {}\n-    static class FailingTask extends RecursiveAction {\n-        public void compute() { throw new FailingTaskException(); }\n-    }\n-\n-    \/** Counts all FailingTaskExceptions still recorded in exceptionTable. *\/\n-    int retainedExceptions() {\n-        exceptionTableLock.lock();\n-        try {\n-            int count = 0;\n-            for (Object node : exceptionTable)\n-                for (; node != null; node = next(node))\n-                    if (ex(node) instanceof FailingTaskException)\n-                        count++;\n-            return count;\n-        } finally {\n-            exceptionTableLock.unlock();\n-        }\n-    }\n-\n-    @Test\n-    public void exceptionTableCleanup() throws Exception {\n-        try {\n-            init();\n-        } catch (ReflectiveOperationException ex) {\n-            return; \/\/ using FJ Version without Exception table\n-        }\n-        ArrayList<FailingTask> failedTasks = failedTasks();\n-\n-        \/\/ Retain a strong ref to one last failing task\n-        FailingTask lastTask = failedTasks.get(rnd.nextInt(failedTasks.size()));\n-\n-        \/\/ Clear all other strong refs, making exception table cleanable\n-        failedTasks.clear();\n-\n-        BooleanSupplier exceptionTableIsClean = () -> {\n-            try {\n-                \/\/ Trigger exception table expunging as side effect\n-                lastTask.join();\n-                throw new AssertionError(\"should throw\");\n-            } catch (FailingTaskException expected) {}\n-            int count = retainedExceptions();\n-            if (count == 0)\n-                throw new AssertionError(\"expected to find last task\");\n-            return count == 1;\n-        };\n-        gcAwait(exceptionTableIsClean);\n-    }\n-\n-    \/** Sequestered into a separate method to inhibit GC retention. *\/\n-    ArrayList<FailingTask> failedTasks()\n-        throws Exception {\n-        final ForkJoinPool pool = new ForkJoinPool(rnd.nextInt(1, 4));\n-\n-        assertEquals(0, retainedExceptions());\n-\n-        final ArrayList<FailingTask> tasks = new ArrayList<>();\n-\n-        for (int i = exceptionTable.length; i--> 0; ) {\n-            FailingTask task = new FailingTask();\n-            pool.execute(task);\n-            tasks.add(task); \/\/ retain strong refs to all tasks, for now\n-            task = null;     \/\/ excessive GC retention paranoia\n-        }\n-        for (FailingTask task : tasks) {\n-            try {\n-                task.join();\n-                throw new AssertionError(\"should throw\");\n-            } catch (FailingTaskException success) {}\n-            task = null;     \/\/ excessive GC retention paranoia\n-        }\n-\n-        if (rnd.nextBoolean())\n-            gcAwait(() -> retainedExceptions() == tasks.size());\n-\n-        return tasks;\n-    }\n-\n-    \/\/ --------------- GC finalization infrastructure ---------------\n-\n-    \/** No guarantees, but effective in practice. *\/\n-    static void forceFullGc() {\n-        long timeoutMillis = 1000L;\n-        CountDownLatch finalized = new CountDownLatch(1);\n-        ReferenceQueue<Object> queue = new ReferenceQueue<>();\n-        WeakReference<Object> ref = new WeakReference<>(\n-            new Object() { protected void finalize() { finalized.countDown(); }},\n-            queue);\n-        try {\n-            for (int tries = 3; tries--> 0; ) {\n-                System.gc();\n-                if (finalized.await(timeoutMillis, MILLISECONDS)\n-                    && queue.remove(timeoutMillis) != null\n-                    && ref.get() == null) {\n-                    System.runFinalization(); \/\/ try to pick up stragglers\n-                    return;\n-                }\n-                timeoutMillis *= 4;\n-            }\n-        } catch (InterruptedException unexpected) {\n-            throw new AssertionError(\"unexpected InterruptedException\");\n-        }\n-        throw new AssertionError(\"failed to do a \\\"full\\\" gc\");\n-    }\n-\n-    static void gcAwait(BooleanSupplier s) {\n-        for (int i = 0; i < 10; i++) {\n-            if (s.getAsBoolean())\n-                return;\n-            forceFullGc();\n-        }\n-        throw new AssertionError(\"failed to satisfy condition\");\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/FJExceptionTableLeak.java","additions":0,"deletions":213,"binary":false,"changes":213,"status":"deleted"}]}