{"files":[{"patch":"@@ -360,1 +360,1 @@\n- * <p><b>Completion Traversals<\/b>. If using {@code onCompletion} to\n+ * <p><b>Completion Traversals.<\/b> If using {@code onCompletion} to\n@@ -556,0 +556,5 @@\n+    \/\/ internal-only weak version\n+    final boolean weakCompareAndSetPendingCount(int expected, int count) {\n+        return PENDING.weakCompareAndSet(this, expected, count);\n+    }\n+\n@@ -565,1 +570,1 @@\n-                     !PENDING.weakCompareAndSet(this, c, c - 1));\n+                     !weakCompareAndSetPendingCount(c, c - 1));\n@@ -598,1 +603,1 @@\n-            else if (PENDING.weakCompareAndSet(a, c, c - 1))\n+            else if (a.weakCompareAndSetPendingCount(c, c - 1))\n@@ -621,1 +626,1 @@\n-            else if (PENDING.weakCompareAndSet(a, c, c - 1))\n+            else if (a.weakCompareAndSetPendingCount(c, c - 1))\n@@ -666,1 +671,1 @@\n-            else if (PENDING.weakCompareAndSet(this, c, c - 1))\n+            else if (weakCompareAndSetPendingCount(c, c - 1))\n@@ -721,8 +726,7 @@\n-        Thread t; ForkJoinWorkerThread wt;\n-        if (maxTasks > 0 && status >= 0) {\n-            if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n-                (wt = (ForkJoinWorkerThread)t).pool.\n-                    helpComplete(wt.workQueue, this, maxTasks);\n-            else\n-                ForkJoinPool.common.externalHelpComplete(this, maxTasks);\n-        }\n+        ForkJoinPool.WorkQueue q; Thread t; boolean owned;\n+        if (owned = (t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n+            q = ((ForkJoinWorkerThread)t).workQueue;\n+        else\n+            q = ForkJoinPool.commonQueue();\n+        if (q != null && maxTasks > 0)\n+            q.helpComplete(this, owned, maxTasks);\n@@ -731,0 +735,2 @@\n+    \/\/ ForkJoinTask overrides\n+\n@@ -734,6 +740,7 @@\n-    void internalPropagateException(Throwable ex) {\n-        CountedCompleter<?> a = this, s = a;\n-        while (a.onExceptionalCompletion(ex, s) &&\n-               (a = (s = a).completer) != null && a.status >= 0 &&\n-               isExceptionalStatus(a.recordExceptionalCompletion(ex)))\n-            ;\n+    @Override\n+    final int trySetException(Throwable ex) {\n+        CountedCompleter<?> a = this, p = a;\n+        do {} while (isExceptionalStatus(a.trySetThrown(ex)) &&\n+                     a.onExceptionalCompletion(ex, p) &&\n+                     (a = (p = a).completer) != null && a.status >= 0);\n+        return status;\n@@ -745,0 +752,1 @@\n+    @Override\n@@ -759,0 +767,1 @@\n+    @Override\n@@ -768,0 +777,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CountedCompleter.java","additions":29,"deletions":19,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -53,0 +54,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.Condition;\n@@ -166,1 +169,1 @@\n- * <p><b>Implementation notes<\/b>: This implementation restricts the\n+ * <p><b>Implementation notes:<\/b> This implementation restricts the\n@@ -233,1 +236,1 @@\n-     * (The actual code needs to null-check and size-check the array,\n+     * The actual code needs to null-check and size-check the array,\n@@ -235,23 +238,25 @@\n-     * adds a release fence for publication, and possibly signals\n-     * waiting workers to start scanning -- see below.)  Both a\n-     * successful pop and poll mainly entail a CAS of a slot from\n-     * non-null to null.\n-     *\n-     * The pop operation (always performed by owner) is:\n-     *   if ((the task at top slot is not null) and\n-     *        (CAS slot to null))\n-     *           decrement top and return task;\n-     *\n-     * And the poll operation (usually by a stealer) is\n-     *    if ((the task at base slot is not null) and\n-     *        (CAS slot to null))\n-     *           increment base and return task;\n-     *\n-     * There are several variants of each of these. Most uses occur\n-     * within operations that also interleave contention or emptiness\n-     * tracking or inspection of elements before extracting them, so\n-     * must interleave these with the above code. When performed by\n-     * owner, getAndSet is used instead of CAS (see for example method\n-     * nextLocalTask) which is usually more efficient, and possible\n-     * because the top index cannot independently change during the\n-     * operation.\n+     * enforces memory ordering, supports resizing, and possibly\n+     * signals waiting workers to start scanning -- see below.\n+     *\n+     * The pop operation (always performed by owner) is of the form:\n+     *   if ((task = getAndSet(q.array, (q.top-1) % length, null)) != null)\n+     *        decrement top and return task;\n+     * If this fails, the queue is empty.\n+     *\n+     * The poll operation by another stealer thread is, basically:\n+     *   if (CAS nonnull task at q.array[q.base % length] to null)\n+     *       increment base and return task;\n+     *\n+     * This may fail due to contention, and may be retried.\n+     * Implementations must ensure a consistent snapshot of the base\n+     * index and the task (by looping or trying elsewhere) before\n+     * trying CAS.  There isn't actually a method of this form,\n+     * because failure due to inconsistency or contention is handled\n+     * in different ways in different contexts, normally by first\n+     * trying other queues. (For the most straightforward example, see\n+     * method pollScan.) There are further variants for cases\n+     * requiring inspection of elements before extracting them, so\n+     * must interleave these with variants of this code.  Also, a more\n+     * efficient version (nextLocalTask) is used for polls by owners.\n+     * It avoids some overhead because the queue cannot be growing\n+     * during call.\n@@ -263,16 +268,22 @@\n-     * algorithms similar to (but different than) the one used here.\n-     * Extracting tasks in array slots via (fully fenced) CAS provides\n-     * primary synchronization. The base and top indices imprecisely\n-     * guide where to extract from. We do not usually require strict\n-     * orderings of array and index updates. Many index accesses use\n-     * plain mode, with ordering constrained by surrounding context\n-     * (usually with respect to element CASes or the two WorkQueue\n-     * volatile fields source and phase). When not otherwise already\n-     * constrained, reads of \"base\" by queue owners use acquire-mode,\n-     * and some externally callable methods preface accesses with\n-     * acquire fences.  Additionally, to ensure that index update\n-     * writes are not coalesced or postponed in loops etc, \"opaque\"\n-     * mode is used in a few cases where timely writes are not\n-     * otherwise ensured. The \"locked\" versions of push- and pop-\n-     * based methods for shared queues differ from owned versions\n-     * because locking already forces some of the ordering.\n+     * algorithms similar to the one used here.  Inserting and\n+     * extracting tasks in array slots via volatile or atomic accesses\n+     * or explicit fences provides primary synchronization.\n+     *\n+     * Operations on deque elements require reads and writes of both\n+     * indices and slots. When possible, we allow these to occur in\n+     * any order.  Because the base and top indices (along with other\n+     * pool or array fields accessed in many methods) only imprecisely\n+     * guide where to extract from, we let accesses other than the\n+     * element getAndSet\/CAS\/setVolatile appear in any order, using\n+     * plain mode. But we must still preface some methods (mainly\n+     * those that may be accessed externally) with an acquireFence to\n+     * avoid unbounded staleness. This is equivalent to acting as if\n+     * callers use an acquiring read of the reference to the pool or\n+     * queue when invoking the method, even when they do not. We use\n+     * explicit acquiring reads (getSlot) rather than plain array\n+     * access when acquire mode is required but not otherwise ensured\n+     * by context. To reduce stalls by other stealers, we encourage\n+     * timely writes to the base index by immediately following\n+     * updates with a write of a volatile field that must be updated\n+     * anyway, or an Opaque-mode write if there is no such\n+     * opportunity.\n@@ -281,16 +292,23 @@\n-     * a check that base == top indicates (momentary) emptiness, but\n-     * otherwise may err on the side of possibly making the queue\n-     * appear nonempty when a push, pop, or poll have not fully\n-     * committed, or making it appear empty when an update of top has\n-     * not yet been visibly written.  (Method isEmpty() checks the\n-     * case of a partially completed removal of the last element.)\n-     * Because of this, the poll operation, considered individually,\n-     * is not wait-free. One thief cannot successfully continue until\n-     * another in-progress one (or, if previously empty, a push)\n-     * visibly completes.  This can stall threads when required to\n-     * consume from a given queue (see method poll()).  However, in\n-     * the aggregate, we ensure at least probabilistic\n-     * non-blockingness.  If an attempted steal fails, a scanning\n-     * thief chooses a different random victim target to try next. So,\n-     * in order for one thief to progress, it suffices for any\n-     * in-progress poll or new push on any empty queue to complete.\n+     * the emptiness check base == top is only quiescently accurate\n+     * (and so used where this suffices). Otherwise, it may err on the\n+     * side of possibly making the queue appear nonempty when a push,\n+     * pop, or poll have not fully committed, or making it appear\n+     * empty when an update of top or base has not yet been seen.\n+     * Similarly, the check in push for the queue array being full may\n+     * trigger when not completely full, causing a resize earlier than\n+     * required.\n+     *\n+     * Mainly because of these potential inconsistencies among slots\n+     * vs indices, the poll operation, considered individually, is not\n+     * wait-free. One thief cannot successfully continue until another\n+     * in-progress one (or, if previously empty, a push) visibly\n+     * completes.  This can stall threads when required to consume\n+     * from a given queue (which may spin).  However, in the\n+     * aggregate, we ensure probabilistic non-blockingness at least\n+     * until checking quiescence (which is intrinsically blocking):\n+     * If an attempted steal fails, a scanning thief chooses a\n+     * different victim target to try next. So, in order for one thief\n+     * to progress, it suffices for any in-progress poll or new push\n+     * on any empty queue to complete. The worst cases occur when many\n+     * threads are looking for tasks being produced by a stalled\n+     * producer.\n@@ -301,1 +319,3 @@\n-     * message-passing frameworks in which tasks are never joined.\n+     * message-passing frameworks in which tasks are never joined,\n+     * although with increased contention among task producers and\n+     * consumers.\n@@ -311,7 +331,6 @@\n-     * tasks that they submitted.  Insertion of tasks in shared mode\n-     * requires a lock but we use only a simple spinlock (using field\n-     * phase), because submitters encountering a busy queue move to a\n-     * different position to use or create other queues -- they block\n-     * only when creating and registering new queues. Because it is\n-     * used only as a spinlock, unlocking requires only a \"releasing\"\n-     * store (using setRelease) unless otherwise signalling.\n+     * tasks that they submitted (or when known, subtasks thereof).\n+     * Insertion of tasks in shared mode requires a lock. We use only\n+     * a simple spinlock (using field \"source\"), because submitters\n+     * encountering a busy queue move to a different position to use\n+     * or create other queues. They block only when registering new\n+     * queues.\n@@ -325,10 +344,11 @@\n-     * per second.  The pool itself creates, activates (enables\n-     * scanning for and running tasks), deactivates, blocks, and\n-     * terminates threads, all with minimal central information.\n-     * There are only a few properties that we can globally track or\n-     * maintain, so we pack them into a small number of variables,\n-     * often maintaining atomicity without blocking or locking.\n-     * Nearly all essentially atomic control state is held in a few\n-     * volatile variables that are by far most often read (not\n-     * written) as status and consistency checks. We pack as much\n-     * information into them as we can.\n+     * per second.  Most non-atomic control is performed by some form\n+     * of scanning across or within queues.  The pool itself creates,\n+     * activates (enables scanning for and running tasks),\n+     * deactivates, blocks, and terminates threads, all with minimal\n+     * central information.  There are only a few properties that we\n+     * can globally track or maintain, so we pack them into a small\n+     * number of variables, often maintaining atomicity without\n+     * blocking or locking.  Nearly all essentially atomic control\n+     * state is held in a few volatile variables that are by far most\n+     * often read (not written) as status and consistency checks. We\n+     * pack as much information into them as we can.\n@@ -346,15 +366,13 @@\n-     * and finally TERMINATED bits.\n-     *\n-     * Field \"workQueues\" holds references to WorkQueues.  It is\n-     * updated (only during worker creation and termination) under\n-     * lock (using field workerNamePrefix as lock), but is otherwise\n-     * concurrently readable, and accessed directly. We also ensure\n-     * that uses of the array reference itself never become too stale\n-     * in case of resizing, by arranging that (re-)reads are separated\n-     * by at least one acquiring read access.  To simplify index-based\n-     * operations, the array size is always a power of two, and all\n-     * readers must tolerate null slots. Worker queues are at odd\n-     * indices. Shared (submission) queues are at even indices, up to\n-     * a maximum of 64 slots, to limit growth even if the array needs\n-     * to expand to add more workers. Grouping them together in this\n-     * way simplifies and speeds up task scanning.\n+     * and finally TERMINATED bits. It is updated only via bitwise\n+     * atomics (getAndBitwiseOr).\n+     *\n+     * Array \"queues\" holds references to WorkQueues.  It is updated\n+     * (only during worker creation and termination) under the\n+     * registrationLock, but is otherwise concurrently readable, and\n+     * accessed directly (although always prefaced by acquireFences or\n+     * other acquiring reads). To simplify index-based operations, the\n+     * array size is always a power of two, and all readers must\n+     * tolerate null slots.  Worker queues are at odd indices. Worker\n+     * ids masked with SMASK match their index. Shared (submission)\n+     * queues are at even indices. Grouping them together in this way\n+     * simplifies and speeds up task scanning.\n@@ -366,4 +384,4 @@\n-     * do not hold on to worker references that would prevent GC, all\n-     * accesses to workQueues are via indices into the workQueues\n-     * array (which is one source of some of the messy code\n-     * constructions here). In essence, the workQueues array serves as\n+     * do not hold on to worker or task references that would prevent\n+     * GC, all accesses to workQueues are via indices into the\n+     * queues array (which is one source of some of the messy code\n+     * constructions here). In essence, the queues array serves as\n@@ -378,1 +396,3 @@\n-     * tasks are submitted or generated. In many usages, ramp-up time\n+     * tasks are submitted or generated. These latencies are mainly a\n+     * function of JVM park\/unpark (and underlying OS) performance,\n+     * which can be slow and variable.  In many usages, ramp-up time\n@@ -381,1 +401,2 @@\n-     * allocation. So we streamline this as much as possible.\n+     * allocation. On the other hand, throughput degrades when too\n+     * many threads poll for too few tasks.\n@@ -383,4 +404,4 @@\n-     * The \"ctl\" field atomically maintains total worker and\n-     * \"released\" worker counts, plus the head of the available worker\n-     * queue (actually stack, represented by the lower 32bit subfield\n-     * of ctl).  Released workers are those known to be scanning for\n+     * The \"ctl\" field atomically maintains total and \"released\"\n+     * worker counts, plus the head of the available worker queue\n+     * (actually stack, represented by the lower 32bit subfield of\n+     * ctl).  Released workers are those known to be scanning for\n@@ -389,1 +410,1 @@\n-     * signalling by enqueuing in ctl (see method runWorker).  The\n+     * signalling by enqueuing in ctl (see method awaitWork).  The\n@@ -394,9 +415,1 @@\n-     * unless it is topmost on stack.  To avoid missed signal problems\n-     * inherent in any wait\/signal design, available workers rescan\n-     * for (and if found run) tasks after enqueuing.  Normally their\n-     * release status will be updated while doing so, but the released\n-     * worker ctl count may underestimate the number of active\n-     * threads. (However, it is still possible to determine quiescence\n-     * via a validation traversal -- see isQuiescent).  After an\n-     * unsuccessful rescan, available workers are blocked until\n-     * signalled (see signalWork).  The top stack state holds the\n+     * unless it is topmost on stack. The top stack state holds the\n@@ -410,20 +423,9 @@\n-     * ForkJoinWorkerThread via its factory. Upon construction, the\n-     * new thread invokes registerWorker, where it constructs a\n-     * WorkQueue and is assigned an index in the workQueues array\n-     * (expanding the array if necessary). The thread is then started.\n-     * Upon any exception across these steps, or null return from\n-     * factory, deregisterWorker adjusts counts and records\n-     * accordingly.  If a null return, the pool continues running with\n-     * fewer than the target number workers. If exceptional, the\n-     * exception is propagated, generally to some external caller.\n-     * Worker index assignment avoids the bias in scanning that would\n-     * occur if entries were sequentially packed starting at the front\n-     * of the workQueues array. We treat the array as a simple\n-     * power-of-two hash table, expanding as needed. The seedIndex\n-     * increment ensures no collisions until a resize is needed or a\n-     * worker is deregistered and replaced, and thereafter keeps\n-     * probability of collision low. We cannot use\n-     * ThreadLocalRandom.getProbe() for similar purposes here because\n-     * the thread has not started yet, but do so for creating\n-     * submission queues for existing external threads (see\n-     * externalPush).\n+     * ForkJoinWorkerThread via its factory. On starting, the new\n+     * thread first invokes registerWorker, where it constructs a\n+     * WorkQueue and is assigned an index in the queues array\n+     * (expanding the array if necessary).  Upon any exception across\n+     * these steps, or null return from factory, deregisterWorker\n+     * adjusts counts and records accordingly.  If a null return, the\n+     * pool continues running with fewer than the target number\n+     * workers. If exceptional, the exception is propagated, generally\n+     * to some external caller.\n@@ -434,6 +436,5 @@\n-     * phase field is set. Note that phase field updates lag queue CAS\n-     * releases so usage requires care -- seeing a negative phase does\n-     * not guarantee that the worker is available. When queued, the\n-     * lower 16 bits of scanState must hold its pool index. So we\n-     * place the index there upon initialization and otherwise keep it\n-     * there or restore it when necessary.\n+     * phase field is set negative. Note that phase field updates lag\n+     * queue CAS releases; seeing a negative phase does not guarantee\n+     * that the worker is available. When queued, the lower 16 bits of\n+     * its phase must hold its pool index. So we place the index there\n+     * upon initialization and never modify these bits.\n@@ -445,20 +446,31 @@\n-     * if to its current value).  This would be extremely costly. So\n-     * we relax it in several ways: (1) Producers only signal when\n-     * their queue is possibly empty at some point during a push\n-     * operation. (2) Other workers propagate this signal\n-     * when they find tasks in a queue with size greater than one. (3)\n-     * Workers only enqueue after scanning (see below) and not finding\n-     * any tasks.  (4) Rather than CASing ctl to its current value in\n-     * the common case where no action is required, we reduce write\n-     * contention by equivalently prefacing signalWork when called by\n-     * an external task producer using a memory access with\n-     * full-volatile semantics or a \"fullFence\".\n-     *\n-     * Almost always, too many signals are issued, in part because a\n-     * task producer cannot tell if some existing worker is in the\n-     * midst of finishing one task (or already scanning) and ready to\n-     * take another without being signalled. So the producer might\n-     * instead activate a different worker that does not find any\n-     * work, and then inactivates. This scarcely matters in\n-     * steady-state computations involving all workers, but can create\n-     * contention and bookkeeping bottlenecks during ramp-up,\n+     * if to its current value).  However, rather than CASing ctl to\n+     * its current value in the common case where no action is\n+     * required, we reduce write contention by ensuring that\n+     * signalWork invocations are prefaced with a full-volatile memory\n+     * access (which is usually needed anyway).\n+     *\n+     * Signalling. Signals (in signalWork) cause new or reactivated\n+     * workers to scan for tasks.  Method signalWork and its callers\n+     * try to approximate the unattainable goal of having the right\n+     * number of workers activated for the tasks at hand, but must err\n+     * on the side of too many workers vs too few to avoid stalls.  If\n+     * computations are purely tree structured, it suffices for every\n+     * worker to activate another when it pushes a task into an empty\n+     * queue, resulting in O(log(#threads)) steps to full activation.\n+     * If instead, tasks come in serially from only a single producer,\n+     * each worker taking its first (since the last quiescence) task\n+     * from a queue should signal another if there are more tasks in\n+     * that queue. This is equivalent to, but generally faster than,\n+     * arranging the stealer take two tasks, re-pushing one on its own\n+     * queue, and signalling (because its queue is empty), also\n+     * resulting in logarithmic full activation time. Because we don't\n+     * know about usage patterns (or most commonly, mixtures), we use\n+     * both approaches.  We approximate the second rule by arranging\n+     * that workers in scan() do not repeat signals when repeatedly\n+     * taking tasks from any given queue, by remembering the previous\n+     * one. There are narrow windows in which both rules may apply,\n+     * leading to duplicate or unnecessary signals. Despite such\n+     * limitations, these rules usually avoid slowdowns that otherwise\n+     * occur when too many workers contend to take too few tasks, or\n+     * when producers waste most of their time resignalling.  However,\n+     * contention and overhead effects may still occur during ramp-up,\n@@ -467,16 +479,14 @@\n-     * Scanning. Method scan (from runWorker) performs top-level\n-     * scanning for tasks. (Similar scans appear in helpQuiesce and\n-     * pollScan.)  Each scan traverses and tries to poll from each\n-     * queue starting at a random index. Scans are not performed in\n-     * ideal random permutation order, to reduce cacheline\n-     * contention. The pseudorandom generator need not have\n-     * high-quality statistical properties in the long term, but just\n-     * within computations; We use Marsaglia XorShifts (often via\n-     * ThreadLocalRandom.nextSecondarySeed), which are cheap and\n-     * suffice. Scanning also includes contention reduction: When\n-     * scanning workers fail to extract an apparently existing task,\n-     * they soon restart at a different pseudorandom index.  This form\n-     * of backoff improves throughput when many threads are trying to\n-     * take tasks from few queues, which can be common in some usages.\n-     * Scans do not otherwise explicitly take into account core\n-     * affinities, loads, cache localities, etc, However, they do\n+     * Scanning. Method scan performs top-level scanning for (and\n+     * execution of) tasks.  Scans by different workers and\/or at\n+     * different times are unlikely to poll queues in the same\n+     * order. Each scan traverses and tries to poll from each queue in\n+     * a pseudorandom permutation order by starting at a random index,\n+     * and using a constant cyclically exhaustive stride; restarting\n+     * upon contention.  (Non-top-level scans; for example in\n+     * helpJoin, use simpler linear probes because they do not\n+     * systematically contend with top-level scans.)  The pseudorandom\n+     * generator need not have high-quality statistical properties in\n+     * the long term. We use Marsaglia XorShifts, seeded with the Weyl\n+     * sequence from ThreadLocalRandom probes, which are cheap and\n+     * suffice. Scans do not otherwise explicitly take into account\n+     * core affinities, loads, cache localities, etc, However, they do\n@@ -485,7 +495,17 @@\n-     * poll before trying others (see method topLevelExec). However\n-     * this preference is bounded (see TOP_BOUND_SHIFT) as a safeguard\n-     * against infinitely unfair looping under unbounded user task\n-     * recursion, and also to reduce long-term contention when many\n-     * threads poll few queues holding many small tasks. The bound is\n-     * high enough to avoid much impact on locality and scheduling\n-     * overhead.\n+     * poll before trying others (see method topLevelExec).  This\n+     * reduces fairness, which is partially counteracted by using a\n+     * one-shot form of poll (tryPoll) that may lose to other workers.\n+     *\n+     * Deactivation. Method scan returns a sentinel when no tasks are\n+     * found, leading to deactivation (see awaitWork). The count\n+     * fields in ctl allow accurate discovery of quiescent states\n+     * (i.e., when all workers are idle) after deactivation. However,\n+     * this may also race with new (external) submissions, so a\n+     * recheck is also needed to determine quiescence. Upon apparently\n+     * triggering quiescence, awaitWork re-scans and self-signals if\n+     * it may have missed a signal. In other cases, a missed signal\n+     * may transiently lower parallelism because deactivation does not\n+     * necessarily mean that there is no more work, only that that\n+     * there were no tasks not taken by other workers.  But more\n+     * signals are generated (see above) to eventually reactivate if\n+     * needed.\n@@ -495,2 +515,2 @@\n-     * time out and terminate (see method runWorker) if the pool has\n-     * remained quiescent for period given by field keepAlive.\n+     * time out and terminate if the pool has remained quiescent for\n+     * period given by field keepAlive.\n@@ -499,8 +519,5 @@\n-     * tryTerminate to atomically set a runState bit. The calling\n-     * thread, as well as every other worker thereafter terminating,\n-     * helps terminate others by cancelling their unprocessed tasks,\n-     * and waking them up, doing so repeatedly until stable. Calls to\n-     * non-abrupt shutdown() preface this by checking whether\n-     * termination should commence by sweeping through queues (until\n-     * stable) to ensure lack of in-flight submissions and workers\n-     * about to process them before triggering the \"STOP\" phase of\n+     * tryTerminate to atomically set a mode bit. The calling thread,\n+     * as well as every other worker thereafter terminating, helps\n+     * terminate others by cancelling their unprocessed tasks, and\n+     * waking them up. Calls to non-abrupt shutdown() preface this by\n+     * checking isQuiescent before triggering the \"STOP\" phase of\n@@ -512,1 +529,3 @@\n-     * Any of several actions may be taken when one worker is waiting\n+     * Normally, the first option when joining a task that is not done\n+     * is to try to unfork it from local queue and run it.  Otherwise,\n+     * any of several actions may be taken when one worker is waiting\n@@ -523,1 +542,1 @@\n-     *      would be running if the steal had not occurred.\n+     *      could be running if the steal had not occurred.\n@@ -529,3 +548,3 @@\n-     * A third form (implemented in tryRemoveAndExec) amounts to\n-     * helping a hypothetical compensator: If we can readily tell that\n-     * a possible action of a compensator is to steal and execute the\n+     * A third form (implemented via tryRemove) amounts to helping a\n+     * hypothetical compensator: If we can readily tell that a\n+     * possible action of a compensator is to steal and execute the\n@@ -533,1 +552,7 @@\n-     * without the need for a compensation thread.\n+     * without the need for a compensation thread; although with a\n+     * (rare) possibility of reduced parallelism because of a\n+     * transient gap in the queue array.\n+     *\n+     * Other intermediate forms available for specific task types (for\n+     * example helpAsyncBlocker) often avoid or postpone the need for\n+     * blocking or compensation.\n@@ -538,9 +563,9 @@\n-     * The algorithm in awaitJoin entails a form of \"linear helping\".\n-     * Each worker records (in field source) the id of the queue from\n-     * which it last stole a task.  The scan in method awaitJoin uses\n-     * these markers to try to find a worker to help (i.e., steal back\n-     * a task from and execute it) that could hasten completion of the\n-     * actively joined task.  Thus, the joiner executes a task that\n-     * would be on its own local deque if the to-be-joined task had\n-     * not been stolen. This is a conservative variant of the approach\n-     * described in Wagner & Calder \"Leapfrogging: a portable\n+     * The algorithm in helpJoin entails a form of \"linear helping\".\n+     * Each worker records (in field \"source\") the id of the queue\n+     * from which it last stole a task.  The scan in method helpJoin\n+     * uses these markers to try to find a worker to help (i.e., steal\n+     * back a task from and execute it) that could hasten completion\n+     * of the actively joined task.  Thus, the joiner executes a task\n+     * that would be on its own local deque if the to-be-joined task\n+     * had not been stolen. This is a conservative variant of the\n+     * approach described in Wagner & Calder \"Leapfrogging: a portable\n@@ -550,1 +575,1 @@\n-     * links.  This requires a linear scan of the workQueues array to\n+     * links.  This requires a linear scan of the queues array to\n@@ -552,5 +577,21 @@\n-     * than adding to per-task overhead. Searches can fail to locate\n-     * stealers GC stalls and the like delay recording sources.\n-     * Further, even when accurately identified, stealers might not\n-     * ever produce a task that the joiner can in turn help with. So,\n-     * compensation is tried upon failure to find tasks to run.\n+     * than adding to per-task overhead. Also, searches are limited to\n+     * direct and at most two levels of indirect stealers, after which\n+     * there are rapidly diminishing returns on increased overhead.\n+     * Searches can fail to locate stealers when stalls delay\n+     * recording sources.  Further, even when accurately identified,\n+     * stealers might not ever produce a task that the joiner can in\n+     * turn help with. So, compensation is tried upon failure to find\n+     * tasks to run.\n+     *\n+     * Joining CountedCompleters (see helpComplete) differs from (and\n+     * is generally more efficient than) other cases because task\n+     * eligibility is determined by checking completion chains rather\n+     * than tracking stealers.\n+     *\n+     * Joining under timeouts (ForkJoinTask timed get) uses a\n+     * constrained mixture of helping and compensating in part because\n+     * pools (actually, only the common pool) may not have any\n+     * available threads: If the pool is saturated (all available\n+     * workers are busy), the caller tries to remove and otherwise\n+     * help; else it blocks under compensation so that it may time out\n+     * independently of any tasks.\n@@ -581,2 +622,2 @@\n-     * perform subtask processing (see externalHelpComplete and\n-     * related methods) upon joins.  This caller-helps policy makes it\n+     * perform subtask processing (see helpComplete and related\n+     * methods) upon joins.  This caller-helps policy makes it\n@@ -598,4 +639,20 @@\n-     * after executing any top-level task (see\n-     * WorkQueue.afterTopLevelExec).  The associated mechanics (mainly\n-     * in ForkJoinWorkerThread) may be JVM-dependent and must access\n-     * particular Thread class fields to achieve this effect.\n+     * after executing any top-level task.  The associated mechanics\n+     * may be JVM-dependent and must access particular Thread class\n+     * fields to achieve this effect.\n+     *\n+     * Interrupt handling\n+     * ==================\n+     *\n+     * The framework is designed to manage task cancellation\n+     * (ForkJoinTask.cancel) independently from the interrupt status\n+     * of threads running tasks. (See the public ForkJoinTask\n+     * documentation for rationale.)  Interrupts are issued only in\n+     * tryTerminate, when workers should be terminating and tasks\n+     * should be cancelled anyway. Interrupts are cleared only when\n+     * necessary to ensure that calls to LockSupport.park do not loop\n+     * indefinitely (park returns immediately if the current thread is\n+     * interrupted). If so, interruption is reinstated after blocking\n+     * if status could be visible during the scope of any task.  For\n+     * cases in which task bodies are specified or desired to\n+     * interrupt upon cancellation, ForkJoinTask.cancel can be\n+     * overridden to do so (as is done for invoke{Any,All}).\n@@ -608,6 +665,11 @@\n-     * false-sharing impact, the @Contended annotation isolates\n-     * adjacent WorkQueue instances, as well as the ForkJoinPool.ctl\n-     * field. WorkQueue arrays are allocated (by their threads) with\n-     * larger initial sizes than most ever need, mostly to reduce\n-     * false sharing with current garbage collectors that use cardmark\n-     * tables.\n+     * false-sharing impact, the @Contended annotation isolates the\n+     * ForkJoinPool.ctl field as well as the most heavily written\n+     * WorkQueue fields. These mainly reduce cache traffic by scanners.\n+     * WorkQueue arrays are presized large enough to avoid resizing\n+     * (which transiently reduces throughput) in most tree-like\n+     * computations, although not in some streaming usages. Initial\n+     * sizes are not large enough to avoid secondary contention\n+     * effects (especially for GC cardmarks) when queues are placed\n+     * near each other in memory. This is common, but has different\n+     * impact in different collectors and remains incompletely\n+     * addressed.\n@@ -618,1 +680,2 @@\n-     * Memory ordering relies mainly on VarHandles.  This can be\n+     * Memory ordering relies mainly on atomic operations (CAS,\n+     * getAndSet, getAndAdd) along with explicit fences.  This can be\n@@ -622,9 +685,9 @@\n-     * before use, and null-checked if they are references.  Array\n-     * accesses using masked indices include checks (that are always\n-     * true) that the array length is non-zero to avoid compilers\n-     * inserting more expensive traps.  This is usually done in a\n-     * \"C\"-like style of listing declarations at the heads of methods\n-     * or blocks, and using inline assignments on first encounter.\n-     * Nearly all explicit checks lead to bypass\/return, not exception\n-     * throws, because they may legitimately arise due to\n-     * cancellation\/revocation during shutdown.\n+     * before use, and null-checked if they are references, even if\n+     * they can never be null under current usages.  Array accesses\n+     * using masked indices include checks (that are always true) that\n+     * the array length is non-zero to avoid compilers inserting more\n+     * expensive traps.  This is usually done in a \"C\"-like style of\n+     * listing declarations at the heads of methods or blocks, and\n+     * using inline assignments on first encounter.  Nearly all\n+     * explicit checks lead to bypass\/return, not exception throws,\n+     * because they may legitimately arise during shutdown.\n@@ -655,0 +718,16 @@\n+     *\n+     * Revision notes\n+     * ==============\n+     *\n+     * The main sources of differences of January 2020 ForkJoin\n+     * classes from previous version are:\n+     *\n+     * * ForkJoinTask now uses field \"aux\" to support blocking joins\n+     *   and\/or record exceptions, replacing reliance on builtin\n+     *   monitors and side tables.\n+     * * Scans probe slots (vs compare indices), along with related\n+     *   changes that reduce performance differences across most\n+     *   garbage collectors, and reduce contention.\n+     * * Refactoring for better integration of special task types and\n+     *   other capabilities that had been incrementally tacked on. Plus\n+     *   many minor reworkings to improve consistency.\n@@ -669,0 +748,8 @@\n+    static AccessControlContext contextWithPermissions(Permission ... perms) {\n+        Permissions permissions = new Permissions();\n+        for (Permission perm : perms)\n+            permissions.add(perm);\n+        return new AccessControlContext(\n+            new ProtectionDomain[] { new ProtectionDomain(null, permissions) });\n+    }\n+\n@@ -696,8 +783,0 @@\n-    static AccessControlContext contextWithPermissions(Permission ... perms) {\n-        Permissions permissions = new Permissions();\n-        for (Permission perm : perms)\n-            permissions.add(perm);\n-        return new AccessControlContext(\n-            new ProtectionDomain[] { new ProtectionDomain(null, permissions) });\n-    }\n-\n@@ -709,1 +788,1 @@\n-    private static final class DefaultForkJoinWorkerThreadFactory\n+    static final class DefaultForkJoinWorkerThreadFactory\n@@ -711,0 +790,1 @@\n+        \/\/ ACC for access to the factory\n@@ -714,1 +794,0 @@\n-\n@@ -719,2 +798,2 @@\n-                        return new ForkJoinWorkerThread(\n-                            pool, ClassLoader.getSystemClassLoader()); }},\n+                        return new ForkJoinWorkerThread(null, pool, true, false);\n+                    }},\n@@ -725,0 +804,28 @@\n+    \/**\n+     * Factory for CommonPool unless overridden by System property.\n+     * Creates InnocuousForkJoinWorkerThreads if a security manager is\n+     * present at time of invocation.  Support requires that we break\n+     * quite a lot of encapsulation (some via helper methods in\n+     * ThreadLocalRandom) to access and set Thread fields.\n+     *\/\n+    static final class DefaultCommonPoolForkJoinWorkerThreadFactory\n+        implements ForkJoinWorkerThreadFactory {\n+        private static final AccessControlContext ACC = contextWithPermissions(\n+            modifyThreadPermission,\n+            new RuntimePermission(\"enableContextClassLoaderOverride\"),\n+            new RuntimePermission(\"modifyThreadGroup\"),\n+            new RuntimePermission(\"getClassLoader\"),\n+            new RuntimePermission(\"setContextClassLoader\"));\n+\n+        public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {\n+            return AccessController.doPrivileged(\n+                 new PrivilegedAction<>() {\n+                     public ForkJoinWorkerThread run() {\n+                         return System.getSecurityManager() == null ?\n+                             new ForkJoinWorkerThread(null, pool, true, true):\n+                             new ForkJoinWorkerThread.\n+                             InnocuousForkJoinWorkerThread(pool); }},\n+                 ACC);\n+        }\n+    }\n+\n@@ -731,1 +838,0 @@\n-    static final int SQMASK       = 0x007e;        \/\/ max 64 (even) slots\n@@ -736,1 +842,0 @@\n-    static final int QLOCK        = 1;             \/\/ must be 1\n@@ -738,2 +843,1 @@\n-    \/\/ Mode bits and sentinels, some also used in WorkQueue id and.source fields\n-    static final int OWNED        = 1;             \/\/ queue has owner thread\n+    \/\/ Mode bits and sentinels, some also used in WorkQueue fields\n@@ -741,2 +845,5 @@\n-    static final int SHUTDOWN     = 1 << 18;\n-    static final int TERMINATED   = 1 << 19;\n+    static final int SRC          = 1 << 17;       \/\/ set for valid queue ids\n+    static final int INNOCUOUS    = 1 << 18;       \/\/ set for Innocuous workers\n+    static final int QUIET        = 1 << 19;       \/\/ quiescing phase or source\n+    static final int SHUTDOWN     = 1 << 24;\n+    static final int TERMINATED   = 1 << 25;\n@@ -744,8 +851,1 @@\n-    static final int QUIET        = 1 << 30;       \/\/ not scanning or working\n-    static final int DORMANT      = QUIET | UNSIGNALLED;\n-\n-    \/**\n-     * Initial capacity of work-stealing queue array.\n-     * Must be a power of two, at least 2.\n-     *\/\n-    static final int INITIAL_QUEUE_CAPACITY = 1 << 13;\n+    static final int UNCOMPENSATE = 1 << 16;       \/\/ tryCompensate return\n@@ -754,5 +854,2 @@\n-     * Maximum capacity for queue arrays. Must be a power of two less\n-     * than or equal to 1 << (31 - width of array entry) to ensure\n-     * lack of wraparound of index calculations, but defined to a\n-     * value a bit less than this to help users trap runaway programs\n-     * before saturating systems.\n+     * Initial capacity of work-stealing queue array.  Must be a power\n+     * of two, at least 2. See above.\n@@ -760,8 +857,1 @@\n-    static final int MAXIMUM_QUEUE_CAPACITY = 1 << 26; \/\/ 64M\n-\n-    \/**\n-     * The maximum number of top-level polls per worker before\n-     * checking other queues, expressed as a bit shift.  See above for\n-     * rationale.\n-     *\/\n-    static final int TOP_BOUND_SHIFT = 10;\n+    static final int INITIAL_QUEUE_CAPACITY = 1 << 8;\n@@ -773,1 +863,0 @@\n-    @jdk.internal.vm.annotation.Contended\n@@ -775,5 +864,1 @@\n-        volatile int source;       \/\/ source queue id, or sentinel\n-        int id;                    \/\/ pool index, mode, tag\n-        int base;                  \/\/ index of next slot for poll\n-        int top;                   \/\/ index of next slot for push\n-        volatile int phase;        \/\/ versioned, negative: queued, 1: locked\n+        volatile int phase;        \/\/ versioned, negative if inactive\n@@ -781,1 +866,2 @@\n-        int nsteals;               \/\/ number of steals\n+        int config;                \/\/ index, mode, ORed with SRC after init\n+        int base;                  \/\/ index of next slot for poll\n@@ -783,1 +869,0 @@\n-        final ForkJoinPool pool;   \/\/ the containing pool (may be null)\n@@ -786,5 +871,32 @@\n-        WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) {\n-            this.pool = pool;\n-            this.owner = owner;\n-            \/\/ Place indices in the center of array (that is not yet allocated)\n-            base = top = INITIAL_QUEUE_CAPACITY >>> 1;\n+        \/\/ segregate fields frequently updated but not read by scans or steals\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        int top;                   \/\/ index of next slot for push\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        volatile int source;       \/\/ source queue id, lock, or sentinel\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        int nsteals;               \/\/ number of steals from other queues\n+\n+        \/\/ Support for atomic operations\n+        private static final VarHandle QA; \/\/ for array slots\n+        private static final VarHandle SOURCE;\n+        private static final VarHandle BASE;\n+        static final ForkJoinTask<?> getSlot(ForkJoinTask<?>[] a, int i) {\n+            return (ForkJoinTask<?>)QA.getAcquire(a, i);\n+        }\n+        static final ForkJoinTask<?> getAndClearSlot(ForkJoinTask<?>[] a,\n+                                                     int i) {\n+            return (ForkJoinTask<?>)QA.getAndSet(a, i, null);\n+        }\n+        static final void setSlotVolatile(ForkJoinTask<?>[] a, int i,\n+                                          ForkJoinTask<?> v) {\n+            QA.setVolatile(a, i, v);\n+        }\n+        static final boolean casSlotToNull(ForkJoinTask<?>[] a, int i,\n+                                          ForkJoinTask<?> c) {\n+            return QA.weakCompareAndSet(a, i, c, null);\n+        }\n+        final boolean tryLock() {\n+            return SOURCE.compareAndSet(this, 0, 1);\n+        }\n+        final void setBaseOpaque(int b) {\n+            BASE.setOpaque(this, b);\n@@ -794,1 +906,2 @@\n-         * Tries to lock shared queue by CASing phase field.\n+         * Constructor used by ForkJoinWorkerThreads. Most fields\n+         * are initialized upon thread start, in pool.registerWorker.\n@@ -796,2 +909,3 @@\n-        final boolean tryLockPhase() {\n-            return PHASE.compareAndSet(this, 0, 1);\n+        WorkQueue(ForkJoinWorkerThread owner, boolean isInnocuous) {\n+            this.config = (isInnocuous) ? INNOCUOUS : 0;\n+            this.owner = owner;\n@@ -800,2 +914,8 @@\n-        final void releasePhaseLock() {\n-            PHASE.setRelease(this, 0);\n+        \/**\n+         * Constructor used for external queues.\n+         *\/\n+        WorkQueue(int config) {\n+            array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n+            this.config = config;\n+            owner = null;\n+            phase = -1;\n@@ -808,1 +928,1 @@\n-            return (id & 0xffff) >>> 1; \/\/ ignore odd\/even tag bit\n+            return (config & 0xffff) >>> 1; \/\/ ignore odd\/even tag bit\n@@ -815,2 +935,3 @@\n-            int n = (int)BASE.getAcquire(this) - top;\n-            return (n >= 0) ? 0 : -n; \/\/ ignore transient negative\n+            VarHandle.acquireFence(); \/\/ ensure fresh reads by external callers\n+            int n = top - base;\n+            return (n < 0) ? 0 : n;   \/\/ ignore transient negative\n@@ -820,3 +941,2 @@\n-         * Provides a more accurate estimate of whether this queue has\n-         * any tasks than does queueSize, by checking whether a\n-         * near-empty queue has at least one unclaimed task.\n+         * Provides a more conservative estimate of whether this queue\n+         * has any tasks than does queueSize.\n@@ -825,6 +945,1 @@\n-            ForkJoinTask<?>[] a; int n, cap, b;\n-            VarHandle.acquireFence(); \/\/ needed by external callers\n-            return ((n = (b = base) - top) >= 0 || \/\/ possibly one task\n-                    (n == -1 && ((a = array) == null ||\n-                                 (cap = a.length) == 0 ||\n-                                 a[(cap - 1) & b] == null)));\n+            return !((source != 0 && owner == null) || top - base > 0);\n@@ -837,0 +952,1 @@\n+         * @param pool (no-op if null)\n@@ -839,7 +955,5 @@\n-        final void push(ForkJoinTask<?> task) {\n-            ForkJoinTask<?>[] a;\n-            int s = top, d = s - base, cap, m;\n-            ForkJoinPool p = pool;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                QA.setRelease(a, (m = cap - 1) & s, task);\n-                top = s + 1;\n+        final void push(ForkJoinTask<?> task, ForkJoinPool pool) {\n+            ForkJoinTask<?>[] a = array;\n+            int s = top++, d = s - base, cap, m; \/\/ skip insert if disabled\n+            if (a != null && pool != null && (cap = a.length) > 0) {\n+                setSlotVolatile(a, (m = cap - 1) & s, task);\n@@ -847,5 +961,3 @@\n-                    growArray(false);\n-                else if (QA.getAcquire(a, m & (s - 1)) == null && p != null) {\n-                    VarHandle.fullFence();  \/\/ was empty\n-                    p.signalWork(null);\n-                }\n+                    growArray();\n+                if (d == m || a[m & (s - 1)] == null)\n+                    pool.signalWork(); \/\/ signal if was empty or resized\n@@ -856,2 +968,3 @@\n-         * Version of push for shared queues. Call only with phase lock held.\n-         * @return true if should signal work\n+         * Pushes task to a shared queue with lock already held, and unlocks.\n+         *\n+         * @return true if caller should signal work\n@@ -860,6 +973,4 @@\n-            ForkJoinTask<?>[] a;\n-            boolean signal = false;\n-            int s = top, d = s - base, cap, m;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                a[(m = (cap - 1)) & s] = task;\n-                top = s + 1;\n+            ForkJoinTask<?>[] a = array;\n+            int s = top++, d = s - base, cap, m;\n+            if (a != null && (cap = a.length) > 0) {\n+                a[(m = cap - 1) & s] = task;\n@@ -867,6 +978,4 @@\n-                    growArray(true);\n-                else {\n-                    phase = 0; \/\/ full volatile unlock\n-                    if (((s - base) & ~1) == 0) \/\/ size 0 or 1\n-                        signal = true;\n-                }\n+                    growArray();\n+                source = 0; \/\/ unlock\n+                if (d == m || a[m & (s - 1)] == null)\n+                    return true;\n@@ -874,1 +983,1 @@\n-            return signal;\n+            return false;\n@@ -878,3 +987,3 @@\n-         * Doubles the capacity of array. Call either by owner or with\n-         * lock held -- it is OK for base, but not top, to move while\n-         * resizings are in progress.\n+         * Doubles the capacity of array. Called by owner or with lock\n+         * held after pre-incrementing top, which is reverted on\n+         * allocation failure.\n@@ -882,24 +991,13 @@\n-        final void growArray(boolean locked) {\n-            ForkJoinTask<?>[] newA = null;\n-            try {\n-                ForkJoinTask<?>[] oldA; int oldSize, newSize;\n-                if ((oldA = array) != null && (oldSize = oldA.length) > 0 &&\n-                    (newSize = oldSize << 1) <= MAXIMUM_QUEUE_CAPACITY &&\n-                    newSize > 0) {\n-                    try {\n-                        newA = new ForkJoinTask<?>[newSize];\n-                    } catch (OutOfMemoryError ex) {\n-                    }\n-                    if (newA != null) { \/\/ poll from old array, push to new\n-                        int oldMask = oldSize - 1, newMask = newSize - 1;\n-                        for (int s = top - 1, k = oldMask; k >= 0; --k) {\n-                            ForkJoinTask<?> x = (ForkJoinTask<?>)\n-                                QA.getAndSet(oldA, s & oldMask, null);\n-                            if (x != null)\n-                                newA[s-- & newMask] = x;\n-                            else\n-                                break;\n-                        }\n-                        array = newA;\n-                        VarHandle.releaseFence();\n-                    }\n+        final void growArray() {\n+            ForkJoinTask<?>[] oldArray = array, newArray;\n+            int s = top - 1, oldCap, newCap;\n+            if (oldArray != null && (oldCap = oldArray.length) > 0 &&\n+                (newCap = oldCap << 1) > 0) { \/\/ skip if disabled\n+                try {\n+                    newArray = new ForkJoinTask<?>[newCap];\n+                } catch (Throwable ex) {\n+                    top = s;\n+                    if (owner == null)\n+                        source = 0; \/\/ unlock\n+                    throw new RejectedExecutionException(\n+                        \"Queue capacity exceeded\");\n@@ -907,24 +1005,6 @@\n-            } finally {\n-                if (locked)\n-                    phase = 0;\n-            }\n-            if (newA == null)\n-                throw new RejectedExecutionException(\"Queue capacity exceeded\");\n-        }\n-\n-        \/**\n-         * Takes next task, if one exists, in FIFO order.\n-         *\/\n-        final ForkJoinTask<?> poll() {\n-            int b, k, cap; ForkJoinTask<?>[] a;\n-            while ((a = array) != null && (cap = a.length) > 0 &&\n-                   top - (b = base) > 0) {\n-                ForkJoinTask<?> t = (ForkJoinTask<?>)\n-                    QA.getAcquire(a, k = (cap - 1) & b);\n-                if (base == b++) {\n-                    if (t == null)\n-                        Thread.yield(); \/\/ await index advance\n-                    else if (QA.compareAndSet(a, k, t, null)) {\n-                        BASE.setOpaque(this, b);\n-                        return t;\n-                    }\n+                int newMask = newCap - 1, oldMask = oldCap - 1;\n+                for (int k = oldCap; k > 0; --k, --s) {\n+                    ForkJoinTask<?> x;        \/\/ poll old, push to new\n+                    if ((x = getAndClearSlot(oldArray, s & oldMask)) == null)\n+                        break;                \/\/ others already taken\n+                    newArray[s & newMask] = x;\n@@ -932,0 +1012,2 @@\n+                VarHandle.releaseFence();     \/\/ fill before publish\n+                array = newArray;\n@@ -933,1 +1015,0 @@\n-            return null;\n@@ -936,0 +1017,2 @@\n+        \/\/ Variants of pop\n+\n@@ -937,1 +1020,1 @@\n-         * Takes next task, if one exists, in order specified by mode.\n+         * Pops and returns task, or null if empty. Called only by owner.\n@@ -939,1 +1022,1 @@\n-        final ForkJoinTask<?> nextLocalTask() {\n+        private ForkJoinTask<?> pop() {\n@@ -941,15 +1024,4 @@\n-            int md = id, b, s, d, cap; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                (d = (s = top) - (b = base)) > 0) {\n-                if ((md & FIFO) == 0 || d == 1) {\n-                    if ((t = (ForkJoinTask<?>)\n-                         QA.getAndSet(a, (cap - 1) & --s, null)) != null)\n-                        TOP.setOpaque(this, s);\n-                }\n-                else if ((t = (ForkJoinTask<?>)\n-                          QA.getAndSet(a, (cap - 1) & b++, null)) != null) {\n-                    BASE.setOpaque(this, b);\n-                }\n-                else \/\/ on contention in FIFO mode, use regular poll\n-                    t = poll();\n-            }\n+            int s = top, cap; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0 && base != s-- &&\n+                (t = getAndClearSlot(a, (cap - 1) & s)) != null)\n+                top = s;\n@@ -960,10 +1032,1 @@\n-         * Returns next task, if one exists, in order specified by mode.\n-         *\/\n-        final ForkJoinTask<?> peek() {\n-            int cap; ForkJoinTask<?>[] a;\n-            return ((a = array) != null && (cap = a.length) > 0) ?\n-                a[(cap - 1) & ((id & FIFO) != 0 ? base : top - 1)] : null;\n-        }\n-\n-        \/**\n-         * Pops the given task only if it is at the current top.\n+         * Pops the given task for owner only if it is at the current top.\n@@ -972,7 +1035,7 @@\n-            boolean popped = false;\n-            int s, cap; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                (s = top) != base &&\n-                (popped = QA.compareAndSet(a, (cap - 1) & --s, task, null)))\n-                TOP.setOpaque(this, s);\n-            return popped;\n+            int s = top, cap; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0 && base != s-- &&\n+                casSlotToNull(a, (cap - 1) & s, task)) {\n+                top = s;\n+                return true;\n+            }\n+            return false;\n@@ -982,1 +1045,1 @@\n-         * Shared version of tryUnpush.\n+         * Locking version of tryUnpush.\n@@ -984,3 +1047,3 @@\n-        final boolean tryLockedUnpush(ForkJoinTask<?> task) {\n-            boolean popped = false;\n-            int s = top - 1, k, cap; ForkJoinTask<?>[] a;\n+        final boolean externalTryUnpush(ForkJoinTask<?> task) {\n+            boolean taken = false;\n+            int s = top, cap, k; ForkJoinTask<?>[] a;\n@@ -988,5 +1051,5 @@\n-                a[k = (cap - 1) & s] == task && tryLockPhase()) {\n-                if (top == s + 1 && array == a &&\n-                    (popped = QA.compareAndSet(a, k, task, null)))\n-                    top = s;\n-                releasePhaseLock();\n+                a[k = (cap - 1) & (s - 1)] == task && tryLock()) {\n+                if (top == s && array == a &&\n+                    (taken = casSlotToNull(a, k, task)))\n+                    top = s - 1;\n+                source = 0; \/\/ release lock\n@@ -994,1 +1057,1 @@\n-            return popped;\n+            return taken;\n@@ -998,1 +1061,2 @@\n-         * Removes and cancels all known tasks, ignoring any exceptions.\n+         * Deep form of tryUnpush: Traverses from top and removes task if\n+         * present, shifting others to fill gap.\n@@ -1000,3 +1064,22 @@\n-        final void cancelAll() {\n-            for (ForkJoinTask<?> t; (t = poll()) != null; )\n-                ForkJoinTask.cancelIgnoringExceptions(t);\n+        final boolean tryRemove(ForkJoinTask<?> task, boolean owned) {\n+            boolean taken = false;\n+            int p = top, cap; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n+            if ((a = array) != null && task != null && (cap = a.length) > 0) {\n+                int m = cap - 1, s = p - 1, d = p - base;\n+                for (int i = s, k; d > 0; --i, --d) {\n+                    if ((t = a[k = i & m]) == task) {\n+                        if (owned || tryLock()) {\n+                            if ((owned || (array == a && top == p)) &&\n+                                (taken = casSlotToNull(a, k, t))) {\n+                                for (int j = i; j != s; ) \/\/ shift down\n+                                    a[j & m] = getAndClearSlot(a, ++j & m);\n+                                top = s;\n+                            }\n+                            if (!owned)\n+                                source = 0;\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            return taken;\n@@ -1005,1 +1088,1 @@\n-        \/\/ Specialized execution methods\n+        \/\/ variants of poll\n@@ -1008,3 +1091,2 @@\n-         * Runs the given (stolen) task if nonnull, as well as\n-         * remaining local tasks and others available from the given\n-         * queue, up to bound n (to avoid infinite unfairness).\n+         * Tries once to poll next task in FIFO order, failing on\n+         * inconsistency or contention.\n@@ -1012,18 +1094,7 @@\n-        final void topLevelExec(ForkJoinTask<?> t, WorkQueue q, int n) {\n-            int nstolen = 1;\n-            for (int j = 0;;) {\n-                if (t != null)\n-                    t.doExec();\n-                if (j++ <= n)\n-                    t = nextLocalTask();\n-                else {\n-                    j = 0;\n-                    t = null;\n-                }\n-                if (t == null) {\n-                    if (q != null && (t = q.poll()) != null) {\n-                        ++nstolen;\n-                        j = 0;\n-                    }\n-                    else if (j != 0)\n-                        break;\n+        final ForkJoinTask<?> tryPoll() {\n+            int cap, b, k; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0) {\n+                ForkJoinTask<?> t = getSlot(a, k = (cap - 1) & (b = base));\n+                if (base == b++ && t != null && casSlotToNull(a, k, t)) {\n+                    setBaseOpaque(b);\n+                    return t;\n@@ -1032,5 +1103,1 @@\n-            ForkJoinWorkerThread thread = owner;\n-            nsteals += nstolen;\n-            source = 0;\n-            if (thread != null)\n-                thread.afterTopLevelExec();\n+            return null;\n@@ -1040,1 +1107,1 @@\n-         * If present, removes task from queue and executes it.\n+         * Takes next task, if one exists, in order specified by mode.\n@@ -1042,8 +1109,6 @@\n-        final void tryRemoveAndExec(ForkJoinTask<?> task) {\n-            ForkJoinTask<?>[] a; int s, cap;\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                (s = top) - base > 0) { \/\/ traverse from top\n-                for (int m = cap - 1, ns = s - 1, i = ns; ; --i) {\n-                    int index = i & m;\n-                    ForkJoinTask<?> t = (ForkJoinTask<?>)QA.get(a, index);\n-                    if (t == null)\n+        final ForkJoinTask<?> nextLocalTask(int cfg) {\n+            ForkJoinTask<?> t = null;\n+            int s = top, cap; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0) {\n+                for (int b, d;;) {\n+                    if ((d = s - (b = base)) <= 0)\n@@ -1051,14 +1116,7 @@\n-                    else if (t == task) {\n-                        if (QA.compareAndSet(a, index, t, null)) {\n-                            top = ns;   \/\/ safely shift down\n-                            for (int j = i; j != ns; ++j) {\n-                                ForkJoinTask<?> f;\n-                                int pindex = (j + 1) & m;\n-                                f = (ForkJoinTask<?>)QA.get(a, pindex);\n-                                QA.setVolatile(a, pindex, null);\n-                                int jindex = j & m;\n-                                QA.setRelease(a, jindex, f);\n-                            }\n-                            VarHandle.releaseFence();\n-                            t.doExec();\n-                        }\n+                    if (d == 1 || (cfg & FIFO) == 0) {\n+                        if ((t = getAndClearSlot(a, --s & (cap - 1))) != null)\n+                            top = s;\n+                        break;\n+                    }\n+                    if ((t = getAndClearSlot(a, b++ & (cap - 1))) != null) {\n+                        setBaseOpaque(b);\n@@ -1069,0 +1127,39 @@\n+            return t;\n+        }\n+\n+        \/**\n+         * Takes next task, if one exists, using configured mode.\n+         *\/\n+        final ForkJoinTask<?> nextLocalTask() {\n+            return nextLocalTask(config);\n+        }\n+\n+        \/**\n+         * Returns next task, if one exists, in order specified by mode.\n+         *\/\n+        final ForkJoinTask<?> peek() {\n+            VarHandle.acquireFence();\n+            int cap; ForkJoinTask<?>[] a;\n+            return ((a = array) != null && (cap = a.length) > 0) ?\n+                a[(cap - 1) & ((config & FIFO) != 0 ? base : top - 1)] : null;\n+        }\n+\n+        \/\/ specialized execution methods\n+\n+        \/**\n+         * Runs the given (stolen) task if nonnull, as well as\n+         * remaining local tasks and\/or others available from the\n+         * given queue.\n+         *\/\n+        final void topLevelExec(ForkJoinTask<?> task, WorkQueue q) {\n+            int cfg = config, nstolen = 1;\n+            while (task != null) {\n+                task.doExec();\n+                if ((task = nextLocalTask(cfg)) == null &&\n+                    q != null && (task = q.tryPoll()) != null)\n+                    ++nstolen;\n+            }\n+            nsteals += nstolen;\n+            source = 0;\n+            if ((cfg & INNOCUOUS) != 0)\n+                ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n@@ -1076,0 +1173,1 @@\n+         * @param owned true if owned by a ForkJoinWorkerThread\n@@ -1077,1 +1175,0 @@\n-         * @param shared true if must lock to extract task\n@@ -1080,33 +1177,13 @@\n-        final int helpCC(CountedCompleter<?> task, int limit, boolean shared) {\n-            int status = 0;\n-            if (task != null && (status = task.status) >= 0) {\n-                int s, k, cap; ForkJoinTask<?>[] a;\n-                while ((a = array) != null && (cap = a.length) > 0 &&\n-                       (s = top) - base > 0) {\n-                    CountedCompleter<?> v = null;\n-                    ForkJoinTask<?> o = a[k = (cap - 1) & (s - 1)];\n-                    if (o instanceof CountedCompleter) {\n-                        CountedCompleter<?> t = (CountedCompleter<?>)o;\n-                        for (CountedCompleter<?> f = t;;) {\n-                            if (f != task) {\n-                                if ((f = f.completer) == null)\n-                                    break;\n-                            }\n-                            else if (shared) {\n-                                if (tryLockPhase()) {\n-                                    if (top == s && array == a &&\n-                                        QA.compareAndSet(a, k, t, null)) {\n-                                        top = s - 1;\n-                                        v = t;\n-                                    }\n-                                    releasePhaseLock();\n-                                }\n-                                break;\n-                            }\n-                            else {\n-                                if (QA.compareAndSet(a, k, t, null)) {\n-                                    top = s - 1;\n-                                    v = t;\n-                                }\n-                                break;\n-                            }\n+        final int helpComplete(ForkJoinTask<?> task, boolean owned, int limit) {\n+            int status = 0, cap, k, p, s; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n+            while (task != null && (status = task.status) >= 0 &&\n+                   (a = array) != null && (cap = a.length) > 0 &&\n+                   (t = a[k = (cap - 1) & (s = (p = top) - 1)])\n+                   instanceof CountedCompleter) {\n+                CountedCompleter<?> f = (CountedCompleter<?>)t;\n+                boolean taken = false;\n+                for (;;) {     \/\/ exec if root task is a completer of t\n+                    if (f == task) {\n+                        if (owned) {\n+                            if ((taken = casSlotToNull(a, k, t)))\n+                                top = s;\n@@ -1114,0 +1191,7 @@\n+                        else if (tryLock()) {\n+                            if (top == p && array == a &&\n+                                (taken = casSlotToNull(a, k, t)))\n+                                top = s;\n+                            source = 0;\n+                        }\n+                        break;\n@@ -1115,4 +1199,1 @@\n-                    if (v != null)\n-                        v.doExec();\n-                    if ((status = task.status) < 0 || v == null ||\n-                        (limit != 0 && --limit == 0))\n+                    else if ((f = f.completer) == null)\n@@ -1121,0 +1202,5 @@\n+                if (!taken)\n+                    break;\n+                t.doExec();\n+                if (limit != 0 && --limit == 0)\n+                    break;\n@@ -1127,1 +1213,1 @@\n-         * none found or blocker is released\n+         * none found or blocker is released.\n@@ -1132,16 +1218,10 @@\n-            if (blocker != null) {\n-                int b, k, cap; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n-                while ((a = array) != null && (cap = a.length) > 0 &&\n-                       top - (b = base) > 0) {\n-                    t = (ForkJoinTask<?>)QA.getAcquire(a, k = (cap - 1) & b);\n-                    if (blocker.isReleasable())\n-                        break;\n-                    else if (base == b++ && t != null) {\n-                        if (!(t instanceof CompletableFuture.\n-                              AsynchronousCompletionTask))\n-                            break;\n-                        else if (QA.compareAndSet(a, k, t, null)) {\n-                            BASE.setOpaque(this, b);\n-                            t.doExec();\n-                        }\n-                    }\n+            int cap, b, d, k; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n+            while (blocker != null && (d = top - (b = base)) > 0 &&\n+                   (a = array) != null && (cap = a.length) > 0 &&\n+                   (((t = getSlot(a, k = (cap - 1) & b)) == null && d > 1) ||\n+                    t instanceof\n+                    CompletableFuture.AsynchronousCompletionTask) &&\n+                   !blocker.isReleasable()) {\n+                if (t != null && base == b++ && casSlotToNull(a, k, t)) {\n+                    setBaseOpaque(b);\n+                    t.doExec();\n@@ -1152,0 +1232,5 @@\n+        \/\/ misc\n+\n+        \/** AccessControlContext for innocuous workers, created on 1st use. *\/\n+        private static AccessControlContext INNOCUOUS_ACC;\n+\n@@ -1153,1 +1238,14 @@\n-         * Returns true if owned and not known to be blocked.\n+         * Initializes (upon registration) InnocuousForkJoinWorkerThreads.\n+         *\/\n+        final void initializeInnocuousWorker() {\n+            AccessControlContext acc; \/\/ racy construction OK\n+            if ((acc = INNOCUOUS_ACC) == null)\n+                INNOCUOUS_ACC = acc = new AccessControlContext(\n+                    new ProtectionDomain[] { new ProtectionDomain(null, null) });\n+            Thread t = Thread.currentThread();\n+            ThreadLocalRandom.setInheritedAccessControlContext(t, acc);\n+            ThreadLocalRandom.eraseThreadLocals(t);\n+        }\n+\n+        \/**\n+         * Returns true if owned by a worker thread and not known to be blocked.\n@@ -1163,4 +1261,0 @@\n-        \/\/ VarHandle mechanics.\n-        static final VarHandle PHASE;\n-        static final VarHandle BASE;\n-        static final VarHandle TOP;\n@@ -1169,0 +1263,1 @@\n+                QA = MethodHandles.arrayElementVarHandle(ForkJoinTask[].class);\n@@ -1170,1 +1265,1 @@\n-                PHASE = l.findVarHandle(WorkQueue.class, \"phase\", int.class);\n+                SOURCE = l.findVarHandle(WorkQueue.class, \"source\", int.class);\n@@ -1172,1 +1267,0 @@\n-                TOP = l.findVarHandle(WorkQueue.class, \"top\", int.class);\n@@ -1216,7 +1310,1 @@\n-     * Sequence number for creating workerNamePrefix.\n-     *\/\n-    private static int poolNumberSequence;\n-\n-    \/**\n-     * Returns the next sequence number. We don't expect this to\n-     * ever contend, so use simple builtin sync.\n+     * Sequence number for creating worker names\n@@ -1224,3 +1312,1 @@\n-    private static final synchronized int nextPoolId() {\n-        return ++poolNumberSequence;\n-    }\n+    private static volatile int poolIds;\n@@ -1251,6 +1337,0 @@\n-    \/**\n-     * Increment for seed generators. See class ThreadLocal for\n-     * explanation.\n-     *\/\n-    private static final int SEED_INCREMENT = 0x9e3779b9;\n-\n@@ -1274,4 +1354,4 @@\n-     * Because it occupies uppermost bits, we can add one release count\n-     * using getAndAddLong of RC_UNIT, rather than CAS, when returning\n-     * from a blocked join.  Other updates entail multiple subfields\n-     * and masking, requiring CAS.\n+     * Because it occupies uppermost bits, we can add one release\n+     * count using getAndAdd of RC_UNIT, rather than CAS, when\n+     * returning from a blocked join.  Other updates entail multiple\n+     * subfields and masking, requiring CAS.\n@@ -1301,1 +1381,0 @@\n-    volatile long stealCount;            \/\/ collects worker nsteals\n@@ -1303,1 +1382,3 @@\n-    int indexSeed;                       \/\/ next worker index\n+    volatile long stealCount;            \/\/ collects worker nsteals\n+    int scanRover;                       \/\/ advances across pollScan calls\n+    volatile int threadIds;              \/\/ for worker thread names\n@@ -1306,2 +1387,4 @@\n-    WorkQueue[] workQueues;              \/\/ main registry\n-    final String workerNamePrefix;       \/\/ for worker thread string; sync lock\n+    WorkQueue[] queues;                  \/\/ main registry\n+    final ReentrantLock registrationLock;\n+    Condition termination;               \/\/ lazily constructed\n+    final String workerNamePrefix;       \/\/ null for common pool\n@@ -1315,0 +1398,24 @@\n+    \/\/ Support for atomic operations\n+    private static final VarHandle CTL;\n+    private static final VarHandle MODE;\n+    private static final VarHandle THREADIDS;\n+    private static final VarHandle POOLIDS;\n+    private boolean compareAndSetCtl(long c, long v) {\n+        return CTL.compareAndSet(this, c, v);\n+    }\n+    private long compareAndExchangeCtl(long c, long v) {\n+        return (long)CTL.compareAndExchange(this, c, v);\n+    }\n+    private long getAndAddCtl(long v) {\n+        return (long)CTL.getAndAdd(this, v);\n+    }\n+    private int getAndBitwiseOrMode(int v) {\n+        return (int)MODE.getAndBitwiseOr(this, v);\n+    }\n+    private int getAndAddThreadIds(int x) {\n+        return (int)THREADIDS.getAndAdd(this, x);\n+    }\n+    private static int getAndAddPoolIds(int x) {\n+        return (int)POOLIDS.getAndAdd(x);\n+    }\n+\n@@ -1341,6 +1448,1 @@\n-     * Tries to add one worker, incrementing ctl counts before doing\n-     * so, relying on createWorker to back out on failure.\n-     *\n-     * @param c incoming ctl value, with total count negative and no\n-     * idle workers.  On CAS failure, c is refreshed and retried if\n-     * this holds (otherwise, a new worker is not needed).\n+     * Provides a name for ForkJoinWorkerThread constructor.\n@@ -1348,9 +1450,6 @@\n-    private void tryAddWorker(long c) {\n-        do {\n-            long nc = ((RC_MASK & (c + RC_UNIT)) |\n-                       (TC_MASK & (c + TC_UNIT)));\n-            if (ctl == c && CTL.compareAndSet(this, c, nc)) {\n-                createWorker();\n-                break;\n-            }\n-        } while (((c = ctl) & ADD_WORKER) != 0L && (int)c == 0);\n+    final String nextWorkerThreadName() {\n+        String prefix = workerNamePrefix;\n+        int tid = getAndAddThreadIds(1) + 1;\n+        if (prefix == null) \/\/ commonPool has no prefix\n+            prefix = \"ForkJoinPool.commonPool-worker-\";\n+        return prefix.concat(Integer.toString(tid));\n@@ -1360,2 +1459,1 @@\n-     * Callback from ForkJoinWorkerThread constructor to establish and\n-     * record its WorkQueue.\n+     * Finishes initializing and records owned queue.\n@@ -1363,2 +1461,1 @@\n-     * @param wt the worker thread\n-     * @return the worker's queue\n+     * @param w caller's WorkQueue\n@@ -1366,32 +1463,23 @@\n-    final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n-        UncaughtExceptionHandler handler;\n-        wt.setDaemon(true);                             \/\/ configure thread\n-        if ((handler = ueh) != null)\n-            wt.setUncaughtExceptionHandler(handler);\n-        int tid = 0;                                    \/\/ for thread name\n-        int idbits = mode & FIFO;\n-        String prefix = workerNamePrefix;\n-        WorkQueue w = new WorkQueue(this, wt);\n-        if (prefix != null) {\n-            synchronized (prefix) {\n-                WorkQueue[] ws = workQueues; int n;\n-                int s = indexSeed += SEED_INCREMENT;\n-                idbits |= (s & ~(SMASK | FIFO | DORMANT));\n-                if (ws != null && (n = ws.length) > 1) {\n-                    int m = n - 1;\n-                    tid = m & ((s << 1) | 1);           \/\/ odd-numbered indices\n-                    for (int probes = n >>> 1;;) {      \/\/ find empty slot\n-                        WorkQueue q;\n-                        if ((q = ws[tid]) == null || q.phase == QUIET)\n-                            break;\n-                        else if (--probes == 0) {\n-                            tid = n | 1;                \/\/ resize below\n-                            break;\n-                        }\n-                        else\n-                            tid = (tid + 2) & m;\n-                    }\n-                    w.phase = w.id = tid | idbits;      \/\/ now publishable\n-\n-                    if (tid < n)\n-                        ws[tid] = w;\n+    final void registerWorker(WorkQueue w) {\n+        ReentrantLock lock = registrationLock;\n+        ThreadLocalRandom.localInit();\n+        int seed = ThreadLocalRandom.getProbe();\n+        if (w != null && lock != null) {\n+            int modebits = (mode & FIFO) | w.config;\n+            w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n+            w.stackPred = seed;                         \/\/ stash for runWorker\n+            if ((modebits & INNOCUOUS) != 0)\n+                w.initializeInnocuousWorker();\n+            int id = (seed << 1) | 1;                   \/\/ initial index guess\n+            lock.lock();\n+            try {\n+                WorkQueue[] qs; int n;                  \/\/ find queue index\n+                if ((qs = queues) != null && (n = qs.length) > 0) {\n+                    int k = n, m = n - 1;\n+                    for (; qs[id &= m] != null && k > 0; id -= 2, k -= 2);\n+                    if (k == 0)\n+                        id = n | 1;                     \/\/ resize below\n+                    w.phase = w.config = id | modebits; \/\/ now publishable\n+\n+                    if (id < n)\n+                        qs[id] = w;\n@@ -1399,1 +1487,1 @@\n-                        int an = n << 1;\n+                        int an = n << 1, am = an - 1;\n@@ -1401,9 +1489,7 @@\n-                        as[tid] = w;\n-                        int am = an - 1;\n-                        for (int j = 0; j < n; ++j) {\n-                            WorkQueue v;                \/\/ copy external queue\n-                            if ((v = ws[j]) != null)    \/\/ position may change\n-                                as[v.id & am & SQMASK] = v;\n-                            if (++j >= n)\n-                                break;\n-                            as[j] = ws[j];              \/\/ copy worker\n+                        as[id & am] = w;\n+                        for (int j = 1; j < n; j += 2)\n+                            as[j] = qs[j];\n+                        for (int j = 0; j < n; j += 2) {\n+                            WorkQueue q;\n+                            if ((q = qs[j]) != null)    \/\/ shared queues may move\n+                                as[q.config & am] = q;\n@@ -1411,1 +1497,2 @@\n-                        workQueues = as;\n+                        VarHandle.releaseFence();       \/\/ fill before publish\n+                        queues = as;\n@@ -1414,0 +1501,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -1415,1 +1504,0 @@\n-            wt.setName(prefix.concat(Integer.toString(tid)));\n@@ -1417,1 +1505,0 @@\n-        return w;\n@@ -1430,0 +1517,1 @@\n+        ReentrantLock lock = registrationLock;\n@@ -1431,22 +1519,21 @@\n-        int phase = 0;\n-        if (wt != null && (w = wt.workQueue) != null) {\n-            Object lock = workerNamePrefix;\n-            int wid = w.id;\n-            long ns = (long)w.nsteals & 0xffffffffL;\n-            if (lock != null) {\n-                synchronized (lock) {\n-                    WorkQueue[] ws; int n, i;         \/\/ remove index from array\n-                    if ((ws = workQueues) != null && (n = ws.length) > 0 &&\n-                        ws[i = wid & (n - 1)] == w)\n-                        ws[i] = null;\n-                    stealCount += ns;\n-                }\n-            }\n-            phase = w.phase;\n-        }\n-        if (phase != QUIET) {                         \/\/ else pre-adjusted\n-            long c;                                   \/\/ decrement counts\n-            do {} while (!CTL.weakCompareAndSet\n-                         (this, c = ctl, ((RC_MASK & (c - RC_UNIT)) |\n-                                          (TC_MASK & (c - TC_UNIT)) |\n-                                          (SP_MASK & c))));\n+        int cfg = 0;\n+        if (wt != null && (w = wt.workQueue) != null && lock != null) {\n+            WorkQueue[] qs; int n, i;\n+            cfg = w.config;\n+            long ns = w.nsteals & 0xffffffffL;\n+            lock.lock();                             \/\/ remove index from array\n+            if ((qs = queues) != null && (n = qs.length) > 0 &&\n+                qs[i = cfg & (n - 1)] == w)\n+                qs[i] = null;\n+            stealCount += ns;                        \/\/ accumulate steals\n+            lock.unlock();\n+            long c = ctl;\n+            if ((cfg & QUIET) == 0) \/\/ unless self-signalled, decrement counts\n+                do {} while (c != (c = compareAndExchangeCtl(\n+                                       c, ((RC_MASK & (c - RC_UNIT)) |\n+                                           (TC_MASK & (c - TC_UNIT)) |\n+                                           (SP_MASK & c)))));\n+            else if ((int)c == 0)                    \/\/ was dropped on timeout\n+                cfg = 0;                             \/\/ suppress signal if last\n+            for (ForkJoinTask<?> t; (t = w.pop()) != null; )\n+                ForkJoinTask.cancelIgnoringExceptions(t); \/\/ cancel tasks\n@@ -1454,2 +1541,0 @@\n-        if (w != null)\n-            w.cancelAll();                            \/\/ cancel remaining tasks\n@@ -1457,7 +1542,3 @@\n-        if (!tryTerminate(false, false) &&            \/\/ possibly replace worker\n-            w != null && w.array != null)             \/\/ avoid repeated failures\n-            signalWork(null);\n-\n-        if (ex == null)                               \/\/ help clean on way out\n-            ForkJoinTask.helpExpungeStaleExceptions();\n-        else                                          \/\/ rethrow\n+        if (!tryTerminate(false, false) && w != null && (cfg & SRC) != 0)\n+            signalWork();                            \/\/ possibly replace worker\n+        if (ex != null)\n@@ -1467,1 +1548,1 @@\n-    \/**\n+    \/*\n@@ -1469,1 +1550,0 @@\n-     * @param q if non-null recheck if empty on CAS failure\n@@ -1471,9 +1551,12 @@\n-    final void signalWork(WorkQueue q) {\n-        for (;;) {\n-            long c; int sp; WorkQueue[] ws; int i; WorkQueue v;\n-            if ((c = ctl) >= 0L)                      \/\/ enough workers\n-                break;\n-            else if ((sp = (int)c) == 0) {            \/\/ no idle workers\n-                if ((c & ADD_WORKER) != 0L)           \/\/ too few workers\n-                    tryAddWorker(c);\n-                break;\n+    final void signalWork() {\n+        for (long c = ctl; c < 0L;) {\n+            int sp, i; WorkQueue[] qs; WorkQueue v;\n+            if ((sp = (int)c & ~UNSIGNALLED) == 0) {  \/\/ no idle workers\n+                if ((c & ADD_WORKER) == 0L)           \/\/ enough total workers\n+                    break;\n+                if (c == (c = compareAndExchangeCtl(\n+                              c, ((RC_MASK & (c + RC_UNIT)) |\n+                                  (TC_MASK & (c + TC_UNIT)))))) {\n+                    createWorker();\n+                    break;\n+                }\n@@ -1481,1 +1564,1 @@\n-            else if ((ws = workQueues) == null)\n+            else if ((qs = queues) == null)\n@@ -1483,1 +1566,1 @@\n-            else if (ws.length <= (i = sp & SMASK))\n+            else if (qs.length <= (i = sp & SMASK))\n@@ -1485,1 +1568,1 @@\n-            else if ((v = ws[i]) == null)\n+            else if ((v = qs[i]) == null)\n@@ -1488,2 +1571,0 @@\n-                int np = sp & ~UNSIGNALLED;\n-                int vp = v.phase;\n@@ -1492,4 +1573,97 @@\n-                if (sp == vp && CTL.compareAndSet(this, c, nc)) {\n-                    v.phase = np;\n-                    if (vt != null && v.source < 0)\n-                        LockSupport.unpark(vt);\n+                if (c == (c = compareAndExchangeCtl(c, nc))) {\n+                    v.phase = sp;\n+                    LockSupport.unpark(vt);           \/\/ release idle worker\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Top-level runloop for workers, called by ForkJoinWorkerThread.run.\n+     * See above for explanation.\n+     *\n+     * @param w caller's WorkQueue (may be null on failed initialization)\n+     *\/\n+    final void runWorker(WorkQueue w) {\n+        if (w != null) {                        \/\/ skip on failed init\n+            w.config |= SRC;                    \/\/ mark as valid source\n+            int r = w.stackPred, src = 0;       \/\/ use seed from registerWorker\n+            do {\n+                r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n+            } while ((src = scan(w, src, r)) >= 0 ||\n+                     (src = awaitWork(w)) == 0);\n+        }\n+    }\n+\n+    \/**\n+     * Scans for and if found executes top-level tasks: Tries to poll\n+     * each queue starting at a random index with random stride,\n+     * returning source id or retry indicator if contended or\n+     * inconsistent.\n+     *\n+     * @param w caller's WorkQueue\n+     * @param prevSrc the previous queue stolen from in current phase, or 0\n+     * @param r random seed\n+     * @return id of queue if taken, negative if none found, prevSrc for retry\n+     *\/\n+    private int scan(WorkQueue w, int prevSrc, int r) {\n+        WorkQueue[] qs = queues;\n+        int n = (w == null || qs == null) ? 0 : qs.length;\n+        for (int step = (r >>> 16) | 1, i = n; i > 0; --i, r += step) {\n+            int j, cap, b; WorkQueue q; ForkJoinTask<?>[] a;\n+            if ((q = qs[j = r & (n - 1)]) != null && \/\/ poll at qs[j].array[k]\n+                (a = q.array) != null && (cap = a.length) > 0) {\n+                int k = (cap - 1) & (b = q.base), nextBase = b + 1;\n+                int nextIndex = (cap - 1) & nextBase, src = j | SRC;\n+                ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n+                if (q.base != b)                \/\/ inconsistent\n+                    return prevSrc;\n+                else if (t != null && WorkQueue.casSlotToNull(a, k, t)) {\n+                    q.base = nextBase;\n+                    ForkJoinTask<?> next = a[nextIndex];\n+                    if ((w.source = src) != prevSrc && next != null)\n+                        signalWork();           \/\/ propagate\n+                    w.topLevelExec(t, q);\n+                    return src;\n+                }\n+                else if (a[nextIndex] != null)  \/\/ revisit\n+                    return prevSrc;\n+            }\n+        }\n+        return (queues != qs) ? prevSrc: -1;    \/\/ possibly resized\n+    }\n+\n+    \/**\n+     * Advances worker phase, pushes onto ctl stack, and awaits signal\n+     * or reports termination.\n+     *\n+     * @return negative if terminated, else 0\n+     *\/\n+    private int awaitWork(WorkQueue w) {\n+        if (w == null)\n+            return -1;                       \/\/ already terminated\n+        int phase = (w.phase + SS_SEQ) & ~UNSIGNALLED;\n+        w.phase = phase | UNSIGNALLED;       \/\/ advance phase\n+        long prevCtl = ctl, c;               \/\/ enqueue\n+        do {\n+            w.stackPred = (int)prevCtl;\n+            c = ((prevCtl - RC_UNIT) & UC_MASK) | (phase & SP_MASK);\n+        } while (prevCtl != (prevCtl = compareAndExchangeCtl(prevCtl, c)));\n+\n+        Thread.interrupted();                \/\/ clear status\n+        LockSupport.setCurrentBlocker(this); \/\/ prepare to block (exit also OK)\n+        long deadline = 0L;                  \/\/ nonzero if possibly quiescent\n+        int ac = (int)(c >> RC_SHIFT), md;\n+        if ((md = mode) < 0)                 \/\/ pool is terminating\n+            return -1;\n+        else if ((md & SMASK) + ac <= 0) {\n+            boolean checkTermination = (md & SHUTDOWN) != 0;\n+            if ((deadline = System.currentTimeMillis() + keepAlive) == 0L)\n+                deadline = 1L;               \/\/ avoid zero\n+            WorkQueue[] qs = queues;         \/\/ check for racing submission\n+            int n = (qs == null) ? 0 : qs.length;\n+            for (int i = 0; i < n; i += 2) {\n+                WorkQueue q; ForkJoinTask<?>[] a; int cap, b;\n+                if (ctl != c) {              \/\/ already signalled\n+                    checkTermination = false;\n@@ -1498,1 +1672,7 @@\n-                else if (q != null && q.isEmpty())     \/\/ no need to retry\n+                else if ((q = qs[i]) != null &&\n+                         (a = q.array) != null && (cap = a.length) > 0 &&\n+                         ((b = q.base) != q.top || a[(cap - 1) & b] != null ||\n+                          q.source != 0)) {\n+                    if (compareAndSetCtl(c, prevCtl))\n+                        w.phase = phase;     \/\/ self-signal\n+                    checkTermination = false;\n@@ -1500,0 +1680,68 @@\n+                }\n+            }\n+            if (checkTermination && tryTerminate(false, false))\n+                return -1;                   \/\/ trigger quiescent termination\n+        }\n+\n+        for (boolean alt = false;;) {        \/\/ await activation or termination\n+            if (w.phase >= 0)\n+                break;\n+            else if (mode < 0)\n+                return -1;\n+            else if ((c = ctl) == prevCtl)\n+                Thread.onSpinWait();         \/\/ signal in progress\n+            else if (!(alt = !alt))          \/\/ check between park calls\n+                Thread.interrupted();\n+            else if (deadline == 0L)\n+                LockSupport.park();\n+            else if (deadline - System.currentTimeMillis() > TIMEOUT_SLOP)\n+                LockSupport.parkUntil(deadline);\n+            else if (((int)c & SMASK) == (w.config & SMASK) &&\n+                     compareAndSetCtl(c, ((UC_MASK & (c - TC_UNIT)) |\n+                                          (prevCtl & SP_MASK)))) {\n+                w.config |= QUIET;           \/\/ sentinel for deregisterWorker\n+                return -1;                   \/\/ drop on timeout\n+            }\n+            else if ((deadline += keepAlive) == 0L)\n+                deadline = 1L;               \/\/ not at head; restart timer\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Utilities used by ForkJoinTask\n+\n+    \/**\n+     * Returns true if all workers are busy, possibly creating one if allowed\n+     *\/\n+    final boolean isSaturated() {\n+        int maxTotal = bounds >>> SWIDTH;\n+        for (long c;;) {\n+            if (((int)(c = ctl) & ~UNSIGNALLED) != 0)\n+                return false;\n+            if ((short)(c >>> TC_SHIFT) >= maxTotal)\n+                return true;\n+            long nc = ((c + TC_UNIT) & TC_MASK) | (c & ~TC_MASK);\n+            if (compareAndSetCtl(c, nc))\n+                return !createWorker();\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if can start terminating if enabled, or already terminated\n+     *\/\n+    final boolean canStop() {\n+        outer: for (long oldSum = 0L;;) { \/\/ repeat until stable\n+            int md; WorkQueue[] qs;  long c;\n+            if ((qs = queues) == null || ((md = mode) & STOP) != 0)\n+                return true;\n+            if ((md & SMASK) + (int)((c = ctl) >> RC_SHIFT) > 0)\n+                break;\n+            long checkSum = c;\n+            for (int i = 1; i < qs.length; i += 2) { \/\/ scan submitters\n+                WorkQueue q; ForkJoinTask<?>[] a; int s = 0, cap;\n+                if ((q = qs[i]) != null && (a = q.array) != null &&\n+                    (cap = a.length) > 0 &&\n+                    ((s = q.top) != q.base || a[(cap - 1) & s] != null ||\n+                     q.source != 0))\n+                    break outer;\n+                checkSum += (((long)i) << 32) ^ s;\n@@ -1501,0 +1749,2 @@\n+            if (oldSum == (oldSum = checkSum) && queues == qs)\n+                return true;\n@@ -1502,0 +1752,1 @@\n+        return (mode & STOP) != 0; \/\/ recheck mode on false return\n@@ -1506,27 +1757,22 @@\n-     * arrange for a compensating worker in preparation for blocking:\n-     * If not all core workers yet exist, creates one, else if any are\n-     * unreleased (possibly including caller) releases one, else if\n-     * fewer than the minimum allowed number of workers running,\n-     * checks to see that they are all active, and if so creates an\n-     * extra worker unless over maximum limit and policy is to\n-     * saturate.  Most of these steps can fail due to interference, in\n-     * which case 0 is returned so caller will retry. A negative\n-     * return value indicates that the caller doesn't need to\n-     * re-adjust counts when later unblocked.\n-     *\n-     * @return 1: block then adjust, -1: block without adjust, 0 : retry\n-     *\/\n-    private int tryCompensate(WorkQueue w) {\n-        int t, n, sp;\n-        long c = ctl;\n-        WorkQueue[] ws = workQueues;\n-        if ((t = (short)(c >>> TC_SHIFT)) >= 0) {\n-            if (ws == null || (n = ws.length) <= 0 || w == null)\n-                return 0;                        \/\/ disabled\n-            else if ((sp = (int)c) != 0) {       \/\/ replace or release\n-                WorkQueue v = ws[sp & (n - 1)];\n-                int wp = w.phase;\n-                long uc = UC_MASK & ((wp < 0) ? c + RC_UNIT : c);\n-                int np = sp & ~UNSIGNALLED;\n-                if (v != null) {\n-                    int vp = v.phase;\n+     * arrange for a compensating worker in preparation for\n+     * blocking. May fail due to interference, in which case -1 is\n+     * returned so caller may retry. A zero return value indicates\n+     * that the caller doesn't need to re-adjust counts when later\n+     * unblocked.\n+     *\n+     * @param c incoming ctl value\n+     * @return UNCOMPENSATE: block then adjust, 0: block, -1 : retry\n+     *\/\n+    private int tryCompensate(long c) {\n+        Predicate<? super ForkJoinPool> sat;\n+        int b = bounds; \/\/ counts are signed; centered at parallelism level == 0\n+        int minActive = (short)(b & SMASK),\n+            maxTotal  = b >>> SWIDTH,\n+            active    = (int)(c >> RC_SHIFT),\n+            total     = (short)(c >>> TC_SHIFT),\n+            sp        = (int)c & ~UNSIGNALLED;\n+        if (total >= 0) {\n+            if (sp != 0) {                        \/\/ activate idle worker\n+                WorkQueue[] qs; int n; WorkQueue v;\n+                if ((qs = queues) != null && (n = qs.length) > 0 &&\n+                    (v = qs[sp & (n - 1)]) != null) {\n@@ -1534,6 +1780,5 @@\n-                    long nc = ((long)v.stackPred & SP_MASK) | uc;\n-                    if (vp == sp && CTL.compareAndSet(this, c, nc)) {\n-                        v.phase = np;\n-                        if (vt != null && v.source < 0)\n-                            LockSupport.unpark(vt);\n-                        return (wp < 0) ? -1 : 1;\n+                    long nc = ((long)v.stackPred & SP_MASK) | (UC_MASK & c);\n+                    if (compareAndSetCtl(c, nc)) {\n+                        v.phase = sp;\n+                        LockSupport.unpark(vt);\n+                        return UNCOMPENSATE;\n@@ -1542,1 +1787,1 @@\n-                return 0;\n+                return -1;                        \/\/ retry\n@@ -1544,2 +1789,1 @@\n-            else if ((int)(c >> RC_SHIFT) -      \/\/ reduce parallelism\n-                     (short)(bounds & SMASK) > 0) {\n+            else if (active > minActive) {        \/\/ reduce parallelism\n@@ -1547,35 +1791,1 @@\n-                return CTL.compareAndSet(this, c, nc) ? 1 : 0;\n-            }\n-            else {                               \/\/ validate\n-                int md = mode, pc = md & SMASK, tc = pc + t, bc = 0;\n-                boolean unstable = false;\n-                for (int i = 1; i < n; i += 2) {\n-                    WorkQueue q; Thread wt; Thread.State ts;\n-                    if ((q = ws[i]) != null) {\n-                        if (q.source == 0) {\n-                            unstable = true;\n-                            break;\n-                        }\n-                        else {\n-                            --tc;\n-                            if ((wt = q.owner) != null &&\n-                                ((ts = wt.getState()) == Thread.State.BLOCKED ||\n-                                 ts == Thread.State.WAITING))\n-                                ++bc;            \/\/ worker is blocking\n-                        }\n-                    }\n-                }\n-                if (unstable || tc != 0 || ctl != c)\n-                    return 0;                    \/\/ inconsistent\n-                else if (t + pc >= MAX_CAP || t >= (bounds >>> SWIDTH)) {\n-                    Predicate<? super ForkJoinPool> sat;\n-                    if ((sat = saturate) != null && sat.test(this))\n-                        return -1;\n-                    else if (bc < pc) {          \/\/ lagging\n-                        Thread.yield();          \/\/ for retry spins\n-                        return 0;\n-                    }\n-                    else\n-                        throw new RejectedExecutionException(\n-                            \"Thread limit exceeded replacing blocked worker\");\n-                }\n+                return compareAndSetCtl(c, nc) ? UNCOMPENSATE : -1;\n@@ -1584,0 +1794,13 @@\n+        if (total < maxTotal) {                   \/\/ expand pool\n+            long nc = ((c + TC_UNIT) & TC_MASK) | (c & ~TC_MASK);\n+            return (!compareAndSetCtl(c, nc) ? -1 :\n+                    !createWorker() ? 0 : UNCOMPENSATE);\n+        }\n+        else if (!compareAndSetCtl(c, c))         \/\/ validate\n+            return -1;\n+        else if ((sat = saturate) != null && sat.test(this))\n+            return 0;\n+        else\n+            throw new RejectedExecutionException(\n+                \"Thread limit exceeded replacing blocked worker\");\n+    }\n@@ -1585,2 +1808,5 @@\n-        long nc = ((c + TC_UNIT) & TC_MASK) | (c & ~TC_MASK); \/\/ expand pool\n-        return CTL.compareAndSet(this, c, nc) && createWorker() ? 1 : 0;\n+    \/**\n+     * Readjusts RC count; called from ForkJoinTask after blocking.\n+     *\/\n+    final void uncompensate() {\n+        getAndAddCtl(RC_UNIT);\n@@ -1590,2 +1816,7 @@\n-     * Top-level runloop for workers, called by ForkJoinWorkerThread.run.\n-     * See above for explanation.\n+     * Helps if possible until the given task is done.  Scans other\n+     * queues for a task produced by one of w's stealers; returning\n+     * compensated blocking sentinel if none are found.\n+     *\n+     * @param task the task\n+     * @param w caller's WorkQueue\n+     * @return task status on exit, or UNCOMPENSATE for compensated blocking\n@@ -1593,23 +1824,8 @@\n-    final void runWorker(WorkQueue w) {\n-        int r = (w.id ^ ThreadLocalRandom.nextSecondarySeed()) | FIFO; \/\/ rng\n-        w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY]; \/\/ initialize\n-        for (;;) {\n-            int phase;\n-            if (scan(w, r)) {                     \/\/ scan until apparently empty\n-                r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ move (xorshift)\n-            }\n-            else if ((phase = w.phase) >= 0) {    \/\/ enqueue, then rescan\n-                long np = (w.phase = (phase + SS_SEQ) | UNSIGNALLED) & SP_MASK;\n-                long c, nc;\n-                do {\n-                    w.stackPred = (int)(c = ctl);\n-                    nc = ((c - RC_UNIT) & UC_MASK) | np;\n-                } while (!CTL.weakCompareAndSet(this, c, nc));\n-            }\n-            else {                                \/\/ already queued\n-                int pred = w.stackPred;\n-                Thread.interrupted();             \/\/ clear before park\n-                w.source = DORMANT;               \/\/ enable signal\n-                long c = ctl;\n-                int md = mode, rc = (md & SMASK) + (int)(c >> RC_SHIFT);\n-                if (md < 0)                       \/\/ terminating\n+    final int helpJoin(ForkJoinTask<?> task, WorkQueue w) {\n+        int s = 0;\n+        if (task != null && w != null) {\n+            int wsrc = w.source, wid = w.config & SMASK, r = wid + 2;\n+            boolean scan = true;\n+            long c = 0L;                          \/\/ track ctl stability\n+            outer: for (;;) {\n+                if ((s = task.status) < 0)\n@@ -1617,13 +1833,41 @@\n-                else if (rc <= 0 && (md & SHUTDOWN) != 0 &&\n-                         tryTerminate(false, false))\n-                    break;                        \/\/ quiescent shutdown\n-                else if (w.phase < 0) {\n-                    if (rc <= 0 && pred != 0 && phase == (int)c) {\n-                        long nc = (UC_MASK & (c - TC_UNIT)) | (SP_MASK & pred);\n-                        long d = keepAlive + System.currentTimeMillis();\n-                        LockSupport.parkUntil(this, d);\n-                        if (ctl == c &&           \/\/ drop on timeout if all idle\n-                            d - System.currentTimeMillis() <= TIMEOUT_SLOP &&\n-                            CTL.compareAndSet(this, c, nc)) {\n-                            w.phase = QUIET;\n-                            break;\n+                else if (scan = !scan) {          \/\/ previous scan was empty\n+                    if (mode < 0)\n+                        ForkJoinTask.cancelIgnoringExceptions(task);\n+                    else if (c == (c = ctl) && (s = tryCompensate(c)) >= 0)\n+                        break;                    \/\/ block\n+                }\n+                else {                            \/\/ scan for subtasks\n+                    WorkQueue[] qs = queues;\n+                    int n = (qs == null) ? 0 : qs.length, m = n - 1;\n+                    for (int i = n; i > 0; i -= 2, r += 2) {\n+                        int j; WorkQueue q, x, y; ForkJoinTask<?>[] a;\n+                        if ((q = qs[j = r & m]) != null) {\n+                            int sq = q.source & SMASK, cap, b;\n+                            if ((a = q.array) != null && (cap = a.length) > 0) {\n+                                int k = (cap - 1) & (b = q.base);\n+                                int nextBase = b + 1, src = j | SRC, sx;\n+                                ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n+                                boolean eligible = sq == wid ||\n+                                    ((x = qs[sq & m]) != null &&   \/\/ indirect\n+                                     ((sx = (x.source & SMASK)) == wid ||\n+                                      ((y = qs[sx & m]) != null && \/\/ 2-indirect\n+                                       (y.source & SMASK) == wid)));\n+                                if ((s = task.status) < 0)\n+                                    break outer;\n+                                else if ((q.source & SMASK) != sq ||\n+                                         q.base != b)\n+                                    scan = true;          \/\/ inconsistent\n+                                else if (t == null)\n+                                    scan |= (a[nextBase & (cap - 1)] != null ||\n+                                             q.top != b); \/\/ lagging\n+                                else if (eligible) {\n+                                    if (WorkQueue.casSlotToNull(a, k, t)) {\n+                                        q.base = nextBase;\n+                                        w.source = src;\n+                                        t.doExec();\n+                                        w.source = wsrc;\n+                                    }\n+                                    scan = true;\n+                                    break;\n+                                }\n+                            }\n@@ -1632,5 +1876,0 @@\n-                    else {\n-                        LockSupport.park(this);\n-                        if (w.phase < 0)          \/\/ one spurious wakeup check\n-                            LockSupport.park(this);\n-                    }\n@@ -1638,1 +1877,0 @@\n-                w.source = 0;                     \/\/ disable signal\n@@ -1641,0 +1879,1 @@\n+        return s;\n@@ -1644,1 +1883,2 @@\n-     * Scans for and if found executes one or more top-level tasks from a queue.\n+     * Extra helpJoin steps for CountedCompleters.  Scans for and runs\n+     * subtasks of the given root task, returning if none are found.\n@@ -1646,2 +1886,4 @@\n-     * @return true if found an apparently non-empty queue, and\n-     * possibly ran task(s).\n+     * @param task root of CountedCompleter computation\n+     * @param w caller's WorkQueue\n+     * @param owned true if owned by a ForkJoinWorkerThread\n+     * @return task status on exit\n@@ -1649,18 +1891,49 @@\n-    private boolean scan(WorkQueue w, int r) {\n-        WorkQueue[] ws; int n;\n-        if ((ws = workQueues) != null && (n = ws.length) > 0 && w != null) {\n-            for (int m = n - 1, j = r & m;;) {\n-                WorkQueue q; int b;\n-                if ((q = ws[j]) != null && q.top != (b = q.base)) {\n-                    int qid = q.id;\n-                    ForkJoinTask<?>[] a; int cap, k; ForkJoinTask<?> t;\n-                    if ((a = q.array) != null && (cap = a.length) > 0) {\n-                        t = (ForkJoinTask<?>)QA.getAcquire(a, k = (cap - 1) & b);\n-                        if (q.base == b++ && t != null &&\n-                            QA.compareAndSet(a, k, t, null)) {\n-                            q.base = b;\n-                            w.source = qid;\n-                            if (a[(cap - 1) & b] != null)\n-                                signalWork(q);    \/\/ help signal if more tasks\n-                            w.topLevelExec(t, q,  \/\/ random fairness bound\n-                                           (r | (1 << TOP_BOUND_SHIFT)) & SMASK);\n+    final int helpComplete(ForkJoinTask<?> task, WorkQueue w, boolean owned) {\n+        int s = 0;\n+        if (task != null && w != null) {\n+            int r = w.config;\n+            boolean scan = true, locals = true;\n+            long c = 0L;\n+            outer: for (;;) {\n+                if (locals) {                     \/\/ try locals before scanning\n+                    if ((s = w.helpComplete(task, owned, 0)) < 0)\n+                        break;\n+                    locals = false;\n+                }\n+                else if ((s = task.status) < 0)\n+                    break;\n+                else if (scan = !scan) {\n+                    if (c == (c = ctl))\n+                        break;\n+                }\n+                else {                            \/\/ scan for subtasks\n+                    WorkQueue[] qs = queues;\n+                    int n = (qs == null) ? 0 : qs.length;\n+                    for (int i = n; i > 0; --i, ++r) {\n+                        int j, cap, b; WorkQueue q; ForkJoinTask<?>[] a;\n+                        boolean eligible = false;\n+                        if ((q = qs[j = r & (n - 1)]) != null &&\n+                            (a = q.array) != null && (cap = a.length) > 0) {\n+                            int k = (cap - 1) & (b = q.base), nextBase = b + 1;\n+                            ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n+                            if (t instanceof CountedCompleter) {\n+                                CountedCompleter<?> f = (CountedCompleter<?>)t;\n+                                do {} while (!(eligible = (f == task)) &&\n+                                             (f = f.completer) != null);\n+                            }\n+                            if ((s = task.status) < 0)\n+                                break outer;\n+                            else if (q.base != b)\n+                                scan = true;       \/\/ inconsistent\n+                            else if (t == null)\n+                                scan |= (a[nextBase & (cap - 1)] != null ||\n+                                         q.top != b);\n+                            else if (eligible) {\n+                                if (WorkQueue.casSlotToNull(a, k, t)) {\n+                                    q.setBaseOpaque(nextBase);\n+                                    t.doExec();\n+                                    locals = true;\n+                                }\n+                                scan = true;\n+                                break;\n+                            }\n@@ -1669,1 +1942,0 @@\n-                    return true;\n@@ -1671,4 +1943,0 @@\n-                else if (--n > 0)\n-                    j = (j + 1) & m;\n-                else\n-                    break;\n@@ -1677,1 +1945,1 @@\n-        return false;\n+        return s;\n@@ -1681,4 +1949,3 @@\n-     * Helps and\/or blocks until the given task is done or timeout.\n-     * First tries locally helping, then scans other queues for a task\n-     * produced by one of w's stealers; compensating and blocking if\n-     * none are found (rescanning if tryCompensate fails).\n+     * Scans for and returns a polled task, if available.  Used only\n+     * for untracked polls. Begins scan at an index (scanRover)\n+     * advanced on each call, to avoid systematic unfairness.\n@@ -1686,4 +1953,1 @@\n-     * @param w caller\n-     * @param task the task\n-     * @param deadline for timed waits, if nonzero\n-     * @return task status on exit\n+     * @param submissionsOnly if true, only scan submission queues\n@@ -1691,32 +1955,21 @@\n-    final int awaitJoin(WorkQueue w, ForkJoinTask<?> task, long deadline) {\n-        int s = 0;\n-        int seed = ThreadLocalRandom.nextSecondarySeed();\n-        if (w != null && task != null &&\n-            (!(task instanceof CountedCompleter) ||\n-             (s = w.helpCC((CountedCompleter<?>)task, 0, false)) >= 0)) {\n-            w.tryRemoveAndExec(task);\n-            int src = w.source, id = w.id;\n-            int r = (seed >>> 16) | 1, step = (seed & ~1) | 2;\n-            s = task.status;\n-            while (s >= 0) {\n-                WorkQueue[] ws;\n-                int n = (ws = workQueues) == null ? 0 : ws.length, m = n - 1;\n-                while (n > 0) {\n-                    WorkQueue q; int b;\n-                    if ((q = ws[r & m]) != null && q.source == id &&\n-                        q.top != (b = q.base)) {\n-                        ForkJoinTask<?>[] a; int cap, k;\n-                        int qid = q.id;\n-                        if ((a = q.array) != null && (cap = a.length) > 0) {\n-                            ForkJoinTask<?> t = (ForkJoinTask<?>)\n-                                QA.getAcquire(a, k = (cap - 1) & b);\n-                            if (q.source == id && q.base == b++ &&\n-                                t != null && QA.compareAndSet(a, k, t, null)) {\n-                                q.base = b;\n-                                w.source = qid;\n-                                t.doExec();\n-                                w.source = src;\n-                            }\n-                        }\n-                        break;\n-                    }\n+    private ForkJoinTask<?> pollScan(boolean submissionsOnly) {\n+        VarHandle.acquireFence();\n+        int r = scanRover += 0x61c88647; \/\/ Weyl increment; raciness OK\n+        if (submissionsOnly)             \/\/ even indices only\n+            r &= ~1;\n+        int step = (submissionsOnly) ? 2 : 1;\n+        WorkQueue[] qs; int n;\n+        while ((qs = queues) != null && (n = qs.length) > 0) {\n+            boolean scan = false;\n+            for (int i = 0; i < n; i += step) {\n+                int j, cap, b; WorkQueue q; ForkJoinTask<?>[] a;\n+                if ((q = qs[j = (n - 1) & (r + i)]) != null &&\n+                    (a = q.array) != null && (cap = a.length) > 0) {\n+                    int k = (cap - 1) & (b = q.base), nextBase = b + 1;\n+                    ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n+                    if (q.base != b)\n+                        scan = true;\n+                    else if (t == null)\n+                        scan |= (q.top != b || a[nextBase & (cap - 1)] != null);\n+                    else if (!WorkQueue.casSlotToNull(a, k, t))\n+                        scan = true;\n@@ -1724,17 +1977,2 @@\n-                        r += step;\n-                        --n;\n-                    }\n-                }\n-                if ((s = task.status) < 0)\n-                    break;\n-                else if (n == 0) { \/\/ empty scan\n-                    long ms, ns; int block;\n-                    if (deadline == 0L)\n-                        ms = 0L;                       \/\/ untimed\n-                    else if ((ns = deadline - System.nanoTime()) <= 0L)\n-                        break;                         \/\/ timeout\n-                    else if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) <= 0L)\n-                        ms = 1L;                       \/\/ avoid 0 for timed wait\n-                    if ((block = tryCompensate(w)) != 0) {\n-                        task.internalWait(ms);\n-                        CTL.getAndAdd(this, (block > 0) ? RC_UNIT : 0L);\n+                        q.setBaseOpaque(nextBase);\n+                        return t;\n@@ -1742,1 +1980,0 @@\n-                    s = task.status;\n@@ -1745,0 +1982,2 @@\n+            if (!scan && queues == qs)\n+                break;\n@@ -1746,1 +1985,1 @@\n-        return s;\n+        return null;\n@@ -1753,35 +1992,40 @@\n-     *\/\n-    final void helpQuiescePool(WorkQueue w) {\n-        int prevSrc = w.source;\n-        int seed = ThreadLocalRandom.nextSecondarySeed();\n-        int r = seed >>> 16, step = r | 1;\n-        for (int source = prevSrc, released = -1;;) { \/\/ -1 until known\n-            ForkJoinTask<?> localTask; WorkQueue[] ws;\n-            while ((localTask = w.nextLocalTask()) != null)\n-                localTask.doExec();\n-            if (w.phase >= 0 && released == -1)\n-                released = 1;\n-            boolean quiet = true, empty = true;\n-            int n = (ws = workQueues) == null ? 0 : ws.length;\n-            for (int m = n - 1; n > 0; r += step, --n) {\n-                WorkQueue q; int b;\n-                if ((q = ws[r & m]) != null) {\n-                    int qs = q.source;\n-                    if (q.top != (b = q.base)) {\n-                        quiet = empty = false;\n-                        ForkJoinTask<?>[] a; int cap, k;\n-                        int qid = q.id;\n-                        if ((a = q.array) != null && (cap = a.length) > 0) {\n-                            if (released == 0) {    \/\/ increment\n-                                released = 1;\n-                                CTL.getAndAdd(this, RC_UNIT);\n-                            }\n-                            ForkJoinTask<?> t = (ForkJoinTask<?>)\n-                                QA.getAcquire(a, k = (cap - 1) & b);\n-                            if (q.base == b++ && t != null &&\n-                                QA.compareAndSet(a, k, t, null)) {\n-                                q.base = b;\n-                                w.source = qid;\n-                                t.doExec();\n-                                w.source = source = prevSrc;\n-                            }\n+     *\n+     * @param nanos max wait time (Long.MAX_VALUE if effectively untimed)\n+     * @param interruptible true if return on interrupt\n+     * @return positive if quiescent, negative if interrupted, else 0\n+     *\/\n+    final int helpQuiescePool(WorkQueue w, long nanos, boolean interruptible) {\n+        if (w == null)\n+            return 0;\n+        long startTime = System.nanoTime(), parkTime = 0L;\n+        int prevSrc = w.source, wsrc = prevSrc, cfg = w.config, r = cfg + 1;\n+        for (boolean active = true, locals = true;;) {\n+            boolean busy = false, scan = false;\n+            if (locals) {  \/\/ run local tasks before (re)polling\n+                locals = false;\n+                for (ForkJoinTask<?> u; (u = w.nextLocalTask(cfg)) != null;)\n+                    u.doExec();\n+            }\n+            WorkQueue[] qs = queues;\n+            int n = (qs == null) ? 0 : qs.length;\n+            for (int i = n; i > 0; --i, ++r) {\n+                int j, b, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                if ((q = qs[j = (n - 1) & r]) != null && q != w &&\n+                    (a = q.array) != null && (cap = a.length) > 0) {\n+                    int k = (cap - 1) & (b = q.base);\n+                    int nextBase = b + 1, src = j | SRC;\n+                    ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n+                    if (q.base != b)\n+                        busy = scan = true;\n+                    else if (t != null) {\n+                        busy = scan = true;\n+                        if (!active) {    \/\/ increment before taking\n+                            active = true;\n+                            getAndAddCtl(RC_UNIT);\n+                        }\n+                        if (WorkQueue.casSlotToNull(a, k, t)) {\n+                            q.base = nextBase;\n+                            w.source = src;\n+                            t.doExec();\n+                            w.source = wsrc = prevSrc;\n+                            locals = true;\n@@ -1791,2 +2035,6 @@\n-                    else if ((qs & QUIET) == 0)\n-                        quiet = false;\n+                    else if (!busy) {\n+                        if (q.top != b || a[nextBase & (cap - 1)] != null)\n+                            busy = scan = true;\n+                        else if (q.source != QUIET && q.phase >= 0)\n+                            busy = true;\n+                    }\n@@ -1795,12 +2043,29 @@\n-            if (quiet) {\n-                if (released == 0)\n-                    CTL.getAndAdd(this, RC_UNIT);\n-                w.source = prevSrc;\n-                break;\n-            }\n-            else if (empty) {\n-                if (source != QUIET)\n-                    w.source = source = QUIET;\n-                if (released == 1) {                 \/\/ decrement\n-                    released = 0;\n-                    CTL.getAndAdd(this, RC_MASK & -RC_UNIT);\n+            VarHandle.acquireFence();\n+            if (!scan && queues == qs) {\n+                boolean interrupted;\n+                if (!busy) {\n+                    w.source = prevSrc;\n+                    if (!active)\n+                        getAndAddCtl(RC_UNIT);\n+                    return 1;\n+                }\n+                if (wsrc != QUIET)\n+                    w.source = wsrc = QUIET;\n+                if (active) {                 \/\/ decrement\n+                    active = false;\n+                    parkTime = 0L;\n+                    getAndAddCtl(RC_MASK & -RC_UNIT);\n+                }\n+                else if (parkTime == 0L) {\n+                    parkTime = 1L << 10; \/\/ initially about 1 usec\n+                    Thread.yield();\n+                }\n+                else if ((interrupted = interruptible && Thread.interrupted()) ||\n+                         System.nanoTime() - startTime > nanos) {\n+                    getAndAddCtl(RC_UNIT);\n+                    return interrupted ? -1 : 0;\n+                }\n+                else {\n+                    LockSupport.parkNanos(this, parkTime);\n+                    if (parkTime < nanos >>> 8 && parkTime < 1L << 20)\n+                        parkTime <<= 1;  \/\/ max sleep approx 1 sec or 1% nanos\n@@ -1813,2 +2078,1 @@\n-     * Scans for and returns a polled task, if available.\n-     * Used only for untracked polls.\n+     * Helps quiesce from external caller until done, interrupted, or timeout\n@@ -1816,1 +2080,3 @@\n-     * @param submissionsOnly if true, only scan submission queues\n+     * @param nanos max wait time (Long.MAX_VALUE if effectively untimed)\n+     * @param interruptible true if return on interrupt\n+     * @return positive if quiescent, negative if interrupted, else 0\n@@ -1818,11 +2084,6 @@\n-    private ForkJoinTask<?> pollScan(boolean submissionsOnly) {\n-        WorkQueue[] ws; int n;\n-        rescan: while ((mode & STOP) == 0 && (ws = workQueues) != null &&\n-                      (n = ws.length) > 0) {\n-            int m = n - 1;\n-            int r = ThreadLocalRandom.nextSecondarySeed();\n-            int h = r >>> 16;\n-            int origin, step;\n-            if (submissionsOnly) {\n-                origin = (r & ~1) & m;         \/\/ even indices and steps\n-                step = (h & ~1) | 2;\n+    final int externalHelpQuiescePool(long nanos, boolean interruptible) {\n+        for (long startTime = System.nanoTime(), parkTime = 0L;;) {\n+            ForkJoinTask<?> t;\n+            if ((t = pollScan(false)) != null) {\n+                t.doExec();\n+                parkTime = 0L;\n@@ -1830,3 +2091,5 @@\n-            else {\n-                origin = r & m;\n-                step = h | 1;\n+            else if (canStop())\n+                return 1;\n+            else if (parkTime == 0L) {\n+                parkTime = 1L << 10;\n+                Thread.yield();\n@@ -1834,19 +2097,8 @@\n-            boolean nonempty = false;\n-            for (int i = origin, oldSum = 0, checkSum = 0;;) {\n-                WorkQueue q;\n-                if ((q = ws[i]) != null) {\n-                    int b; ForkJoinTask<?> t;\n-                    if (q.top - (b = q.base) > 0) {\n-                        nonempty = true;\n-                        if ((t = q.poll()) != null)\n-                            return t;\n-                    }\n-                    else\n-                        checkSum += b + q.id;\n-                }\n-                if ((i = (i + step) & m) == origin) {\n-                    if (!nonempty && oldSum == (oldSum = checkSum))\n-                        break rescan;\n-                    checkSum = 0;\n-                    nonempty = false;\n-                }\n+            else if ((System.nanoTime() - startTime) > nanos)\n+                return 0;\n+            else if (interruptible && Thread.interrupted())\n+                return -1;\n+            else {\n+                LockSupport.parkNanos(this, parkTime);\n+                if (parkTime < nanos >>> 8 && parkTime < 1L << 20)\n+                    parkTime <<= 1;\n@@ -1855,1 +2107,0 @@\n-        return null;\n@@ -1865,1 +2116,1 @@\n-        if (w == null || (t = w.nextLocalTask()) == null)\n+        if (w == null || (t = w.nextLocalTask(w.config)) == null)\n@@ -1873,4 +2124,2 @@\n-     * Adds the given task to a submission queue at submitter's\n-     * current queue, creating one if null or contended.\n-     *\n-     * @param task the task. Caller must ensure non-null.\n+     * Finds and locks a WorkQueue for an external submitter, or\n+     * returns null if shutdown or terminating.\n@@ -1878,2 +2127,2 @@\n-    final void externalPush(ForkJoinTask<?> task) {\n-        int r;                                \/\/ initialize caller's probe\n+    final WorkQueue submissionQueue() {\n+        int r;\n@@ -1881,1 +2130,1 @@\n-            ThreadLocalRandom.localInit();\n+            ThreadLocalRandom.localInit();           \/\/ initialize caller's probe\n@@ -1884,22 +2133,12 @@\n-        for (;;) {\n-            WorkQueue q;\n-            int md = mode, n;\n-            WorkQueue[] ws = workQueues;\n-            if ((md & SHUTDOWN) != 0 || ws == null || (n = ws.length) <= 0)\n-                throw new RejectedExecutionException();\n-            else if ((q = ws[(n - 1) & r & SQMASK]) == null) { \/\/ add queue\n-                int qid = (r | QUIET) & ~(FIFO | OWNED);\n-                Object lock = workerNamePrefix;\n-                ForkJoinTask<?>[] qa =\n-                    new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n-                q = new WorkQueue(this, null);\n-                q.array = qa;\n-                q.id = qid;\n-                q.source = QUIET;\n-                if (lock != null) {     \/\/ unless disabled, lock pool to install\n-                    synchronized (lock) {\n-                        WorkQueue[] vs; int i, vn;\n-                        if ((vs = workQueues) != null && (vn = vs.length) > 0 &&\n-                            vs[i = qid & (vn - 1) & SQMASK] == null)\n-                            vs[i] = q;  \/\/ else another thread already installed\n-                    }\n+        for (int id = r << 1;;) {                    \/\/ even indices only\n+            int md = mode, n, i; WorkQueue q; ReentrantLock lock;\n+            WorkQueue[] qs = queues;\n+            if ((md & SHUTDOWN) != 0 || qs == null || (n = qs.length) <= 0)\n+                return null;\n+            else if ((q = qs[i = (n - 1) & id]) == null) {\n+                if ((lock = registrationLock) != null) {\n+                    WorkQueue w = new WorkQueue(id | SRC);\n+                    lock.lock();                    \/\/ install under lock\n+                    if (qs[i] == null)\n+                        qs[i] = w;                  \/\/ else lost race; discard\n+                    lock.unlock();\n@@ -1908,7 +2147,4 @@\n-            else if (!q.tryLockPhase()) \/\/ move if busy\n-                r = ThreadLocalRandom.advanceProbe(r);\n-            else {\n-                if (q.lockedPush(task))\n-                    signalWork(null);\n-                return;\n-            }\n+            else if (!q.tryLock())                  \/\/ move and restart\n+                id = (r = ThreadLocalRandom.advanceProbe(r)) << 1;\n+            else\n+                return q;\n@@ -1918,0 +2154,14 @@\n+    \/**\n+     * Adds the given task to an external submission queue, or throws\n+     * exception if shutdown or terminating.\n+     *\n+     * @param task the task. Caller must ensure non-null.\n+     *\/\n+    final void externalPush(ForkJoinTask<?> task) {\n+        WorkQueue q;\n+        if ((q = submissionQueue()) == null)\n+            throw new RejectedExecutionException(); \/\/ shutdown or disabled\n+        else if (q.lockedPush(task))\n+            signalWork();\n+    }\n+\n@@ -1922,1 +2172,1 @@\n-        Thread t; ForkJoinWorkerThread w; WorkQueue q;\n+        Thread t; ForkJoinWorkerThread wt; WorkQueue q;\n@@ -1926,3 +2176,3 @@\n-            (w = (ForkJoinWorkerThread)t).pool == this &&\n-            (q = w.workQueue) != null)\n-            q.push(task);\n+            (q = (wt = (ForkJoinWorkerThread)t).workQueue) != null &&\n+            wt.pool == this)\n+            q.push(task, this);\n@@ -1935,1 +2185,3 @@\n-     * Returns common pool queue for an external thread.\n+     * Returns common pool queue for an external thread that has\n+     * possibly ever submitted a common pool task (nonzero probe), or\n+     * null if none.\n@@ -1937,7 +2189,6 @@\n-    static WorkQueue commonSubmitterQueue() {\n-        ForkJoinPool p = common;\n-        int r = ThreadLocalRandom.getProbe();\n-        WorkQueue[] ws; int n;\n-        return (p != null && (ws = p.workQueues) != null &&\n-                (n = ws.length) > 0) ?\n-            ws[(n - 1) & r & SQMASK] : null;\n+    static WorkQueue commonQueue() {\n+        ForkJoinPool p; WorkQueue[] qs;\n+        int r = ThreadLocalRandom.getProbe(), n;\n+        return ((p = common) != null && (qs = p.queues) != null &&\n+                (n = qs.length) > 0 && r != 0) ?\n+            qs[(n - 1) & (r << 1)] : null;\n@@ -1947,31 +2198,3 @@\n-     * Performs tryUnpush for an external submitter.\n-     *\/\n-    final boolean tryExternalUnpush(ForkJoinTask<?> task) {\n-        int r = ThreadLocalRandom.getProbe();\n-        WorkQueue[] ws; WorkQueue w; int n;\n-        return ((ws = workQueues) != null &&\n-                (n = ws.length) > 0 &&\n-                (w = ws[(n - 1) & r & SQMASK]) != null &&\n-                w.tryLockedUnpush(task));\n-    }\n-\n-    \/**\n-     * Performs helpComplete for an external submitter.\n-     *\/\n-    final int externalHelpComplete(CountedCompleter<?> task, int maxTasks) {\n-        int r = ThreadLocalRandom.getProbe();\n-        WorkQueue[] ws; WorkQueue w; int n;\n-        return ((ws = workQueues) != null && (n = ws.length) > 0 &&\n-                (w = ws[(n - 1) & r & SQMASK]) != null) ?\n-            w.helpCC(task, maxTasks, true) : 0;\n-    }\n-\n-    \/**\n-     * Tries to steal and run tasks within the target's computation.\n-     * The maxTasks argument supports external usages; internal calls\n-     * use zero, allowing unbounded steps (external calls trap\n-     * non-positive values).\n-     *\n-     * @param w caller\n-     * @param maxTasks if non-zero, the maximum number of other tasks to run\n-     * @return task status on exit\n+     * If the given executor is a ForkJoinPool, poll and execute\n+     * AsynchronousCompletionTasks from worker's queue until none are\n+     * available or blocker is released.\n@@ -1979,3 +2202,10 @@\n-    final int helpComplete(WorkQueue w, CountedCompleter<?> task,\n-                           int maxTasks) {\n-        return (w == null) ? 0 : w.helpCC(task, maxTasks, false);\n+    static void helpAsyncBlocker(Executor e, ManagedBlocker blocker) {\n+        WorkQueue w = null; Thread t; ForkJoinWorkerThread wt;\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n+            if ((wt = (ForkJoinWorkerThread)t).pool == e)\n+                w = wt.workQueue;\n+        }\n+        else if (e == common)\n+            w = commonQueue();\n+        if (w != null)\n+            w.helpAsyncBlocker(blocker);\n@@ -2054,4 +2284,3 @@\n-        int md; \/\/ 3 phases: try to set SHUTDOWN, then STOP, then TERMINATED\n-\n-        while (((md = mode) & SHUTDOWN) == 0) {\n-            if (!enable || this == common)        \/\/ cannot shutdown\n+        int md; \/\/ try to set SHUTDOWN, then STOP, then help terminate\n+        if (((md = mode) & SHUTDOWN) == 0) {\n+            if (!enable)\n@@ -2059,56 +2288,18 @@\n-            else\n-                MODE.compareAndSet(this, md, md | SHUTDOWN);\n-        }\n-\n-        while (((md = mode) & STOP) == 0) {       \/\/ try to initiate termination\n-            if (!now) {                           \/\/ check if quiescent & empty\n-                for (long oldSum = 0L;;) {        \/\/ repeat until stable\n-                    boolean running = false;\n-                    long checkSum = ctl;\n-                    WorkQueue[] ws = workQueues;\n-                    if ((md & SMASK) + (int)(checkSum >> RC_SHIFT) > 0)\n-                        running = true;\n-                    else if (ws != null) {\n-                        WorkQueue w;\n-                        for (int i = 0; i < ws.length; ++i) {\n-                            if ((w = ws[i]) != null) {\n-                                int s = w.source, p = w.phase;\n-                                int d = w.id, b = w.base;\n-                                if (b != w.top ||\n-                                    ((d & 1) == 1 && (s >= 0 || p >= 0))) {\n-                                    running = true;\n-                                    break;     \/\/ working, scanning, or have work\n-                                }\n-                                checkSum += (((long)s << 48) + ((long)p << 32) +\n-                                             ((long)b << 16) + (long)d);\n-                            }\n-                        }\n-                    }\n-                    if (((md = mode) & STOP) != 0)\n-                        break;                 \/\/ already triggered\n-                    else if (running)\n-                        return false;\n-                    else if (workQueues == ws && oldSum == (oldSum = checkSum))\n-                        break;\n-                }\n-            }\n-            if ((md & STOP) == 0)\n-                MODE.compareAndSet(this, md, md | STOP);\n-        }\n-\n-        while (((md = mode) & TERMINATED) == 0) { \/\/ help terminate others\n-            for (long oldSum = 0L;;) {            \/\/ repeat until stable\n-                WorkQueue[] ws; WorkQueue w;\n-                long checkSum = ctl;\n-                if ((ws = workQueues) != null) {\n-                    for (int i = 0; i < ws.length; ++i) {\n-                        if ((w = ws[i]) != null) {\n-                            ForkJoinWorkerThread wt = w.owner;\n-                            w.cancelAll();        \/\/ clear queues\n-                            if (wt != null) {\n-                                try {             \/\/ unblock join or park\n-                                    wt.interrupt();\n-                                } catch (Throwable ignore) {\n-                                }\n-                            }\n-                            checkSum += ((long)w.phase << 32) + w.base;\n+            md = getAndBitwiseOrMode(SHUTDOWN);\n+        }\n+        if ((md & STOP) == 0) {\n+            if (!now && !canStop())\n+                return false;\n+            md = getAndBitwiseOrMode(STOP);\n+        }\n+        for (int k = 0; k < 2; ++k) { \/\/ twice in case of lagging qs updates\n+            for (ForkJoinTask<?> t; (t = pollScan(false)) != null; )\n+                ForkJoinTask.cancelIgnoringExceptions(t); \/\/ help cancel\n+            WorkQueue[] qs; int n; WorkQueue q; Thread thread;\n+            if ((qs = queues) != null && (n = qs.length) > 0) {\n+                for (int j = 1; j < n; j += 2) { \/\/ unblock other workers\n+                    if ((q = qs[j]) != null && (thread = q.owner) != null &&\n+                        !thread.isInterrupted()) {\n+                        try {\n+                            thread.interrupt();\n+                        } catch (Throwable ignore) {\n@@ -2118,3 +2309,0 @@\n-                if (((md = mode) & TERMINATED) != 0 ||\n-                    (workQueues == ws && oldSum == (oldSum = checkSum)))\n-                    break;\n@@ -2122,9 +2310,9 @@\n-            if ((md & TERMINATED) != 0)\n-                break;\n-            else if ((md & SMASK) + (short)(ctl >>> TC_SHIFT) > 0)\n-                break;\n-            else if (MODE.compareAndSet(this, md, md | TERMINATED)) {\n-                synchronized (this) {\n-                    notifyAll();                  \/\/ for awaitTermination\n-                }\n-                break;\n+            ReentrantLock lock; Condition cond; \/\/ signal when no workers\n+            if (((md = mode) & TERMINATED) == 0 &&\n+                (md & SMASK) + (short)(ctl >>> TC_SHIFT) <= 0 &&\n+                (getAndBitwiseOrMode(TERMINATED) & TERMINATED) == 0 &&\n+                (lock = registrationLock) != null) {\n+                lock.lock();\n+                if ((cond = termination) != null)\n+                    cond.signalAll();\n+                lock.unlock();\n@@ -2301,3 +2489,3 @@\n-        \/\/ check, encode, pack parameters\n-        if (parallelism <= 0 || parallelism > MAX_CAP ||\n-            maximumPoolSize < parallelism || keepAliveTime <= 0L)\n+        checkPermission();\n+        int p = parallelism;\n+        if (p <= 0 || p > MAX_CAP || p > maximumPoolSize || keepAliveTime <= 0L)\n@@ -2305,1 +2493,1 @@\n-        if (factory == null)\n+        if (factory == null || unit == null)\n@@ -2307,15 +2495,0 @@\n-        long ms = Math.max(unit.toMillis(keepAliveTime), TIMEOUT_SLOP);\n-\n-        int corep = Math.min(Math.max(corePoolSize, parallelism), MAX_CAP);\n-        long c = ((((long)(-corep)       << TC_SHIFT) & TC_MASK) |\n-                  (((long)(-parallelism) << RC_SHIFT) & RC_MASK));\n-        int m = parallelism | (asyncMode ? FIFO : 0);\n-        int maxSpares = Math.min(maximumPoolSize, MAX_CAP) - parallelism;\n-        int minAvail = Math.min(Math.max(minimumRunnable, 0), MAX_CAP);\n-        int b = ((minAvail - parallelism) & SMASK) | (maxSpares << SWIDTH);\n-        int n = (parallelism > 1) ? parallelism - 1 : 1; \/\/ at least 2 slots\n-        n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16;\n-        n = (n + 1) << 1; \/\/ power of two, including space for submission queues\n-\n-        this.workerNamePrefix = \"ForkJoinPool-\" + nextPoolId() + \"-worker-\";\n-        this.workQueues = new WorkQueue[n];\n@@ -2325,5 +2498,13 @@\n-        this.keepAlive = ms;\n-        this.bounds = b;\n-        this.mode = m;\n-        this.ctl = c;\n-        checkPermission();\n+        this.keepAlive = Math.max(unit.toMillis(keepAliveTime), TIMEOUT_SLOP);\n+        int size = 1 << (33 - Integer.numberOfLeadingZeros(p - 1));\n+        int corep = Math.min(Math.max(corePoolSize, p), MAX_CAP);\n+        int maxSpares = Math.min(maximumPoolSize, MAX_CAP) - p;\n+        int minAvail = Math.min(Math.max(minimumRunnable, 0), MAX_CAP);\n+        this.bounds = ((minAvail - p) & SMASK) | (maxSpares << SWIDTH);\n+        this.mode = p | (asyncMode ? FIFO : 0);\n+        this.ctl = ((((long)(-corep) << TC_SHIFT) & TC_MASK) |\n+                    (((long)(-p)     << RC_SHIFT) & RC_MASK));\n+        this.registrationLock = new ReentrantLock();\n+        this.queues = new WorkQueue[size];\n+        String pid = Integer.toString(getAndAddPoolIds(1) + 1);\n+        this.workerNamePrefix = \"ForkJoinPool-\" + pid + \"-worker-\";\n@@ -2332,0 +2513,1 @@\n+    \/\/ helper method for commonPool constructor\n@@ -2346,1 +2528,1 @@\n-        int parallelism = -1;\n+        int parallelism = Runtime.getRuntime().availableProcessors() - 1;\n@@ -2350,4 +2532,0 @@\n-            String pp = System.getProperty\n-                (\"java.util.concurrent.ForkJoinPool.common.parallelism\");\n-            if (pp != null)\n-                parallelism = Integer.parseInt(pp);\n@@ -2358,0 +2536,4 @@\n+            String pp = System.getProperty\n+                (\"java.util.concurrent.ForkJoinPool.common.parallelism\");\n+            if (pp != null)\n+                parallelism = Integer.parseInt(pp);\n@@ -2360,23 +2542,4 @@\n-\n-        if (fac == null) {\n-            if (System.getSecurityManager() == null)\n-                fac = defaultForkJoinWorkerThreadFactory;\n-            else \/\/ use security-managed default\n-                fac = new InnocuousForkJoinWorkerThreadFactory();\n-        }\n-        if (parallelism < 0 && \/\/ default 1 less than #cores\n-            (parallelism = Runtime.getRuntime().availableProcessors() - 1) <= 0)\n-            parallelism = 1;\n-        if (parallelism > MAX_CAP)\n-            parallelism = MAX_CAP;\n-\n-        long c = ((((long)(-parallelism) << TC_SHIFT) & TC_MASK) |\n-                  (((long)(-parallelism) << RC_SHIFT) & RC_MASK));\n-        int b = ((1 - parallelism) & SMASK) | (COMMON_MAX_SPARES << SWIDTH);\n-        int n = (parallelism > 1) ? parallelism - 1 : 1;\n-        n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16;\n-        n = (n + 1) << 1;\n-\n-        this.workerNamePrefix = \"ForkJoinPool.commonPool-worker-\";\n-        this.workQueues = new WorkQueue[n];\n-        this.factory = fac;\n+        int p = this.mode = Math.min(Math.max(parallelism, 0), MAX_CAP);\n+        int size = 1 << (33 - Integer.numberOfLeadingZeros(p > 0 ? p - 1 : 1));\n+        this.factory = (fac != null) ? fac :\n+            new DefaultCommonPoolForkJoinWorkerThreadFactory();\n@@ -2384,1 +2547,0 @@\n-        this.saturate = null;\n@@ -2386,3 +2548,7 @@\n-        this.bounds = b;\n-        this.mode = parallelism;\n-        this.ctl = c;\n+        this.saturate = null;\n+        this.workerNamePrefix = null;\n+        this.bounds = ((1 - p) & SMASK) | (COMMON_MAX_SPARES << SWIDTH);\n+        this.ctl = ((((long)(-p) << TC_SHIFT) & TC_MASK) |\n+                    (((long)(-p) << RC_SHIFT) & RC_MASK));\n+        this.queues = new WorkQueue[size];\n+        this.registrationLock = new ReentrantLock();\n@@ -2429,2 +2595,0 @@\n-        if (task == null)\n-            throw new NullPointerException();\n@@ -2454,0 +2618,2 @@\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n@@ -2455,8 +2621,3 @@\n-        if (task == null)\n-            throw new NullPointerException();\n-        ForkJoinTask<?> job;\n-        if (task instanceof ForkJoinTask<?>) \/\/ avoid re-wrap\n-            job = (ForkJoinTask<?>) task;\n-        else\n-            job = new ForkJoinTask.RunnableExecuteAction(task);\n-        externalSubmit(job);\n+        externalSubmit((task instanceof ForkJoinTask<?>)\n+                       ? (ForkJoinTask<Void>) task \/\/ avoid re-wrap\n+                       : new ForkJoinTask.RunnableExecuteAction(task));\n@@ -2484,0 +2645,1 @@\n+    @Override\n@@ -2493,0 +2655,1 @@\n+    @Override\n@@ -2502,0 +2665,1 @@\n+    @Override\n@@ -2504,2 +2668,0 @@\n-        if (task == null)\n-            throw new NullPointerException();\n@@ -2515,0 +2677,1 @@\n+    @Override\n@@ -2516,3 +2679,0 @@\n-        \/\/ In previous versions of this class, this method constructed\n-        \/\/ a task to run ForkJoinTask.invokeAll, but now external\n-        \/\/ invocation of multiple tasks is at least as efficient.\n@@ -2520,1 +2680,0 @@\n-\n@@ -2523,1 +2682,2 @@\n-                ForkJoinTask<T> f = new ForkJoinTask.AdaptedCallable<T>(t);\n+                ForkJoinTask<T> f =\n+                    new ForkJoinTask.AdaptedInterruptibleCallable<T>(t);\n@@ -2527,1 +2687,1 @@\n-            for (int i = 0, size = futures.size(); i < size; i++)\n+            for (int i = futures.size() - 1; i >= 0; --i)\n@@ -2531,2 +2691,41 @@\n-            for (int i = 0, size = futures.size(); i < size; i++)\n-                futures.get(i).cancel(false);\n+            for (Future<T> e : futures)\n+                ForkJoinTask.cancelIgnoringExceptions(e);\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n+                                         long timeout, TimeUnit unit)\n+        throws InterruptedException {\n+        long nanos = unit.toNanos(timeout);\n+        ArrayList<Future<T>> futures = new ArrayList<>(tasks.size());\n+        try {\n+            for (Callable<T> t : tasks) {\n+                ForkJoinTask<T> f =\n+                    new ForkJoinTask.AdaptedInterruptibleCallable<T>(t);\n+                futures.add(f);\n+                externalSubmit(f);\n+            }\n+            long startTime = System.nanoTime(), ns = nanos;\n+            boolean timedOut = (ns < 0L);\n+            for (int i = futures.size() - 1; i >= 0; --i) {\n+                Future<T> f = futures.get(i);\n+                if (!f.isDone()) {\n+                    if (timedOut)\n+                        ForkJoinTask.cancelIgnoringExceptions(f);\n+                    else {\n+                        try {\n+                            f.get(ns, TimeUnit.NANOSECONDS);\n+                        } catch (CancellationException | TimeoutException |\n+                                 ExecutionException ok) {\n+                        }\n+                        if ((ns = nanos - (System.nanoTime() - startTime)) < 0L)\n+                            timedOut = true;\n+                    }\n+                }\n+            }\n+            return futures;\n+        } catch (Throwable t) {\n+            for (Future<T> e : futures)\n+                ForkJoinTask.cancelIgnoringExceptions(e);\n@@ -2537,0 +2736,118 @@\n+    \/\/ Task to hold results from InvokeAnyTasks\n+    static final class InvokeAnyRoot<E> extends ForkJoinTask<E> {\n+        private static final long serialVersionUID = 2838392045355241008L;\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        volatile E result;\n+        final AtomicInteger count;  \/\/ in case all throw\n+        final ForkJoinPool pool;    \/\/ to check shutdown while collecting\n+        InvokeAnyRoot(int n, ForkJoinPool p) {\n+            pool = p;\n+            count = new AtomicInteger(n);\n+        }\n+        final void tryComplete(Callable<E> c) { \/\/ called by InvokeAnyTasks\n+            Throwable ex = null;\n+            boolean failed = (c == null || isCancelled() ||\n+                              (pool != null && pool.mode < 0));\n+            if (!failed && !isDone()) {\n+                try {\n+                    complete(c.call());\n+                } catch (Throwable tx) {\n+                    ex = tx;\n+                    failed = true;\n+                }\n+            }\n+            if ((pool != null && pool.mode < 0) ||\n+                (failed && count.getAndDecrement() <= 1))\n+                trySetThrown(ex != null ? ex : new CancellationException());\n+        }\n+        public final boolean exec()         { return false; } \/\/ never forked\n+        public final E getRawResult()       { return result; }\n+        public final void setRawResult(E v) { result = v; }\n+    }\n+\n+    \/\/ Variant of AdaptedInterruptibleCallable with results in InvokeAnyRoot\n+    static final class InvokeAnyTask<E> extends ForkJoinTask<E> {\n+        private static final long serialVersionUID = 2838392045355241008L;\n+        final InvokeAnyRoot<E> root;\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        final Callable<E> callable;\n+        transient volatile Thread runner;\n+        InvokeAnyTask(InvokeAnyRoot<E> root, Callable<E> callable) {\n+            this.root = root;\n+            this.callable = callable;\n+        }\n+        public final boolean exec() {\n+            Thread.interrupted();\n+            runner = Thread.currentThread();\n+            root.tryComplete(callable);\n+            runner = null;\n+            Thread.interrupted();\n+            return true;\n+        }\n+        public final boolean cancel(boolean mayInterruptIfRunning) {\n+            Thread t;\n+            boolean stat = super.cancel(false);\n+            if (mayInterruptIfRunning && (t = runner) != null) {\n+                try {\n+                    t.interrupt();\n+                } catch (Throwable ignore) {\n+                }\n+            }\n+            return stat;\n+        }\n+        public final void setRawResult(E v) {} \/\/ unused\n+        public final E getRawResult()       { return null; }\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+        int n = tasks.size();\n+        if (n <= 0)\n+            throw new IllegalArgumentException();\n+        InvokeAnyRoot<T> root = new InvokeAnyRoot<T>(n, this);\n+        ArrayList<InvokeAnyTask<T>> fs = new ArrayList<>(n);\n+        try {\n+            for (Callable<T> c : tasks) {\n+                if (c == null)\n+                    throw new NullPointerException();\n+                InvokeAnyTask<T> f = new InvokeAnyTask<T>(root, c);\n+                fs.add(f);\n+                externalSubmit(f);\n+                if (root.isDone())\n+                    break;\n+            }\n+            return root.get();\n+        } finally {\n+            for (InvokeAnyTask<T> f : fs)\n+                ForkJoinTask.cancelIgnoringExceptions(f);\n+        }\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks,\n+                           long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+        long nanos = unit.toNanos(timeout);\n+        int n = tasks.size();\n+        if (n <= 0)\n+            throw new IllegalArgumentException();\n+        InvokeAnyRoot<T> root = new InvokeAnyRoot<T>(n, this);\n+        ArrayList<InvokeAnyTask<T>> fs = new ArrayList<>(n);\n+        try {\n+            for (Callable<T> c : tasks) {\n+                if (c == null)\n+                    throw new NullPointerException();\n+                InvokeAnyTask<T> f = new InvokeAnyTask<T>(root, c);\n+                fs.add(f);\n+                externalSubmit(f);\n+                if (root.isDone())\n+                    break;\n+            }\n+            return root.get(nanos, TimeUnit.NANOSECONDS);\n+        } finally {\n+            for (InvokeAnyTask<T> f : fs)\n+                ForkJoinTask.cancelIgnoringExceptions(f);\n+        }\n+    }\n+\n@@ -2607,1 +2924,0 @@\n-        WorkQueue[] ws; WorkQueue w;\n@@ -2609,0 +2925,1 @@\n+        WorkQueue[] qs; WorkQueue q;\n@@ -2610,3 +2927,3 @@\n-        if ((ws = workQueues) != null) {\n-            for (int i = 1; i < ws.length; i += 2) {\n-                if ((w = ws[i]) != null && w.isApparentlyUnblocked())\n+        if ((qs = queues) != null) {\n+            for (int i = 1; i < qs.length; i += 2) {\n+                if ((q = qs[i]) != null && q.isApparentlyUnblocked())\n@@ -2643,24 +2960,1 @@\n-        for (;;) {\n-            long c = ctl;\n-            int md = mode, pc = md & SMASK;\n-            int tc = pc + (short)(c >>> TC_SHIFT);\n-            int rc = pc + (int)(c >> RC_SHIFT);\n-            if ((md & (STOP | TERMINATED)) != 0)\n-                return true;\n-            else if (rc > 0)\n-                return false;\n-            else {\n-                WorkQueue[] ws; WorkQueue v;\n-                if ((ws = workQueues) != null) {\n-                    for (int i = 1; i < ws.length; i += 2) {\n-                        if ((v = ws[i]) != null) {\n-                            if (v.source > 0)\n-                                return false;\n-                            --tc;\n-                        }\n-                    }\n-                }\n-                if (tc == 0 && ctl == c)\n-                    return true;\n-            }\n-        }\n+        return canStop();\n@@ -2682,5 +2976,5 @@\n-        WorkQueue[] ws; WorkQueue w;\n-        if ((ws = workQueues) != null) {\n-            for (int i = 1; i < ws.length; i += 2) {\n-                if ((w = ws[i]) != null)\n-                    count += (long)w.nsteals & 0xffffffffL;\n+        WorkQueue[] qs; WorkQueue q;\n+        if ((qs = queues) != null) {\n+            for (int i = 1; i < qs.length; i += 2) {\n+                if ((q = qs[i]) != null)\n+                    count += (long)q.nsteals & 0xffffffffL;\n@@ -2703,1 +2997,0 @@\n-        WorkQueue[] ws; WorkQueue w;\n@@ -2705,0 +2998,1 @@\n+        WorkQueue[] qs; WorkQueue q;\n@@ -2706,4 +3000,4 @@\n-        if ((ws = workQueues) != null) {\n-            for (int i = 1; i < ws.length; i += 2) {\n-                if ((w = ws[i]) != null)\n-                    count += w.queueSize();\n+        if ((qs = queues) != null) {\n+            for (int i = 1; i < qs.length; i += 2) {\n+                if ((q = qs[i]) != null)\n+                    count += q.queueSize();\n@@ -2723,1 +3017,0 @@\n-        WorkQueue[] ws; WorkQueue w;\n@@ -2725,0 +3018,1 @@\n+        WorkQueue[] qs; WorkQueue q;\n@@ -2726,4 +3020,4 @@\n-        if ((ws = workQueues) != null) {\n-            for (int i = 0; i < ws.length; i += 2) {\n-                if ((w = ws[i]) != null)\n-                    count += w.queueSize();\n+        if ((qs = queues) != null) {\n+            for (int i = 0; i < qs.length; i += 2) {\n+                if ((q = qs[i]) != null)\n+                    count += q.queueSize();\n@@ -2742,1 +3036,0 @@\n-        WorkQueue[] ws; WorkQueue w;\n@@ -2744,3 +3037,4 @@\n-        if ((ws = workQueues) != null) {\n-            for (int i = 0; i < ws.length; i += 2) {\n-                if ((w = ws[i]) != null && !w.isEmpty())\n+        WorkQueue[] qs; WorkQueue q;\n+        if ((qs = queues) != null) {\n+            for (int i = 0; i < qs.length; i += 2) {\n+                if ((q = qs[i]) != null && !q.isEmpty())\n@@ -2782,2 +3076,0 @@\n-        WorkQueue[] ws; WorkQueue w; ForkJoinTask<?> t;\n-        VarHandle.acquireFence();\n@@ -2785,9 +3077,3 @@\n-        if ((ws = workQueues) != null) {\n-            for (int i = 0; i < ws.length; ++i) {\n-                if ((w = ws[i]) != null) {\n-                    while ((t = w.poll()) != null) {\n-                        c.add(t);\n-                        ++count;\n-                    }\n-                }\n-            }\n+        for (ForkJoinTask<?> t; (t = pollScan(false)) != null; ) {\n+            c.add(t);\n+            ++count;\n@@ -2806,1 +3092,1 @@\n-        \/\/ Use a single pass through workQueues to collect counts\n+        \/\/ Use a single pass through queues to collect counts\n@@ -2810,6 +3096,6 @@\n-        long qt = 0L, qs = 0L; int rc = 0;\n-        WorkQueue[] ws; WorkQueue w;\n-        if ((ws = workQueues) != null) {\n-            for (int i = 0; i < ws.length; ++i) {\n-                if ((w = ws[i]) != null) {\n-                    int size = w.queueSize();\n+        long qt = 0L, ss = 0L; int rc = 0;\n+        WorkQueue[] qs; WorkQueue q;\n+        if ((qs = queues) != null) {\n+            for (int i = 0; i < qs.length; ++i) {\n+                if ((q = qs[i]) != null) {\n+                    int size = q.queueSize();\n@@ -2817,1 +3103,1 @@\n-                        qs += size;\n+                        ss += size;\n@@ -2820,2 +3106,2 @@\n-                        st += (long)w.nsteals & 0xffffffffL;\n-                        if (w.isApparentlyUnblocked())\n+                        st += (long)q.nsteals & 0xffffffffL;\n+                        if (q.isApparentlyUnblocked())\n@@ -2845,1 +3131,1 @@\n-            \", submissions = \" + qs +\n+            \", submissions = \" + ss +\n@@ -2865,1 +3151,2 @@\n-        tryTerminate(false, true);\n+        if (this != common)\n+            tryTerminate(false, true);\n@@ -2888,1 +3175,2 @@\n-        tryTerminate(true, true);\n+        if (this != common)\n+            tryTerminate(true, true);\n@@ -2915,2 +3203,1 @@\n-        int md = mode;\n-        return (md & STOP) != 0 && (md & TERMINATED) == 0;\n+        return (mode & (STOP | TERMINATED)) == STOP;\n@@ -2944,2 +3231,3 @@\n-        if (Thread.interrupted())\n-            throw new InterruptedException();\n+        ReentrantLock lock; Condition cond;\n+        long nanos = unit.toNanos(timeout);\n+        boolean terminated = false;\n@@ -2947,2 +3235,8 @@\n-            awaitQuiescence(timeout, unit);\n-            return false;\n+            Thread t; ForkJoinWorkerThread wt; int q;\n+            if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread &&\n+                (wt = (ForkJoinWorkerThread)t).pool == this)\n+                q = helpQuiescePool(wt.workQueue, nanos, true);\n+            else\n+                q = externalHelpQuiescePool(nanos, true);\n+            if (q < 0)\n+                throw new InterruptedException();\n@@ -2950,15 +3244,10 @@\n-        long nanos = unit.toNanos(timeout);\n-        if (isTerminated())\n-            return true;\n-        if (nanos <= 0L)\n-            return false;\n-        long deadline = System.nanoTime() + nanos;\n-        synchronized (this) {\n-            for (;;) {\n-                if (isTerminated())\n-                    return true;\n-                if (nanos <= 0L)\n-                    return false;\n-                long millis = TimeUnit.NANOSECONDS.toMillis(nanos);\n-                wait(millis > 0L ? millis : 1L);\n-                nanos = deadline - System.nanoTime();\n+        else if (!(terminated = ((mode & TERMINATED) != 0)) &&\n+                 (lock = registrationLock) != null) {\n+            lock.lock();\n+            try {\n+                if ((cond = termination) == null)\n+                    termination = cond = lock.newCondition();\n+                while (!(terminated = ((mode & TERMINATED) != 0)) && nanos > 0L)\n+                    nanos = cond.awaitNanos(nanos);\n+            } finally {\n+                lock.unlock();\n@@ -2967,0 +3256,1 @@\n+        return terminated;\n@@ -2981,0 +3271,1 @@\n+        Thread t; ForkJoinWorkerThread wt; int q;\n@@ -2982,28 +3273,6 @@\n-        ForkJoinWorkerThread wt;\n-        Thread thread = Thread.currentThread();\n-        if ((thread instanceof ForkJoinWorkerThread) &&\n-            (wt = (ForkJoinWorkerThread)thread).pool == this) {\n-            helpQuiescePool(wt.workQueue);\n-            return true;\n-        }\n-        else {\n-            for (long startTime = System.nanoTime();;) {\n-                ForkJoinTask<?> t;\n-                if ((t = pollScan(false)) != null)\n-                    t.doExec();\n-                else if (isQuiescent())\n-                    return true;\n-                else if ((System.nanoTime() - startTime) > nanos)\n-                    return false;\n-                else\n-                    Thread.yield(); \/\/ cannot block\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Waits and\/or attempts to assist performing tasks indefinitely\n-     * until the {@link #commonPool()} {@link #isQuiescent}.\n-     *\/\n-    static void quiesceCommonPool() {\n-        common.awaitQuiescence(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread &&\n+            (wt = (ForkJoinWorkerThread)t).pool == this)\n+            q = helpQuiescePool(wt.workQueue, nanos, false);\n+        else\n+            q = externalHelpQuiescePool(nanos, false);\n+        return (q > 0);\n@@ -3021,8 +3290,10 @@\n-     * thread invoking {@link ForkJoinPool#managedBlock(ManagedBlocker)}.\n-     * The unusual methods in this API accommodate synchronizers that\n-     * may, but don't usually, block for long periods. Similarly, they\n-     * allow more efficient internal handling of cases in which\n-     * additional workers may be, but usually are not, needed to\n-     * ensure sufficient parallelism.  Toward this end,\n-     * implementations of method {@code isReleasable} must be amenable\n-     * to repeated invocation.\n+     * thread invoking {@link\n+     * ForkJoinPool#managedBlock(ManagedBlocker)}.  The unusual\n+     * methods in this API accommodate synchronizers that may, but\n+     * don't usually, block for long periods. Similarly, they allow\n+     * more efficient internal handling of cases in which additional\n+     * workers may be, but usually are not, needed to ensure\n+     * sufficient parallelism.  Toward this end, implementations of\n+     * method {@code isReleasable} must be amenable to repeated\n+     * invocation. Neither method is invoked after a prior invocation\n+     * of {@code isReleasable} or {@code block} returns {@code true}.\n@@ -3113,0 +3384,11 @@\n+        throws InterruptedException {\n+        Thread t; ForkJoinPool p;\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread &&\n+            (p = ((ForkJoinWorkerThread)t).pool) != null)\n+            p.compensatedBlock(blocker);\n+        else\n+            unmanagedBlock(blocker);\n+    }\n+\n+    \/** ManagedBlock for ForkJoinWorkerThreads *\/\n+    private void compensatedBlock(ManagedBlocker blocker)\n@@ -3115,17 +3397,11 @@\n-        ForkJoinPool p;\n-        ForkJoinWorkerThread wt;\n-        WorkQueue w;\n-        Thread t = Thread.currentThread();\n-        if ((t instanceof ForkJoinWorkerThread) &&\n-            (p = (wt = (ForkJoinWorkerThread)t).pool) != null &&\n-            (w = wt.workQueue) != null) {\n-            int block;\n-            while (!blocker.isReleasable()) {\n-                if ((block = p.tryCompensate(w)) != 0) {\n-                    try {\n-                        do {} while (!blocker.isReleasable() &&\n-                                     !blocker.block());\n-                    } finally {\n-                        CTL.getAndAdd(p, (block > 0) ? RC_UNIT : 0L);\n-                    }\n-                    break;\n+        for (;;) {\n+            int comp; boolean done;\n+            long c = ctl;\n+            if (blocker.isReleasable())\n+                break;\n+            if ((comp = tryCompensate(c)) >= 0) {\n+                long post = (comp == 0) ? 0L : RC_UNIT;\n+                try {\n+                    done = blocker.block();\n+                } finally {\n+                    getAndAddCtl(post);\n@@ -3133,0 +3409,2 @@\n+                if (done)\n+                    break;\n@@ -3135,4 +3413,0 @@\n-        else {\n-            do {} while (!blocker.isReleasable() &&\n-                         !blocker.block());\n-        }\n@@ -3141,21 +3415,5 @@\n-    \/**\n-     * If the given executor is a ForkJoinPool, poll and execute\n-     * AsynchronousCompletionTasks from worker's queue until none are\n-     * available or blocker is released.\n-     *\/\n-    static void helpAsyncBlocker(Executor e, ManagedBlocker blocker) {\n-        if (e instanceof ForkJoinPool) {\n-            WorkQueue w; ForkJoinWorkerThread wt; WorkQueue[] ws; int r, n;\n-            ForkJoinPool p = (ForkJoinPool)e;\n-            Thread thread = Thread.currentThread();\n-            if (thread instanceof ForkJoinWorkerThread &&\n-                (wt = (ForkJoinWorkerThread)thread).pool == p)\n-                w = wt.workQueue;\n-            else if ((r = ThreadLocalRandom.getProbe()) != 0 &&\n-                     (ws = p.workQueues) != null && (n = ws.length) > 0)\n-                w = ws[(n - 1) & r & SQMASK];\n-            else\n-                w = null;\n-            if (w != null)\n-                w.helpAsyncBlocker(blocker);\n-        }\n+    \/** ManagedBlock for external threads *\/\n+    private static void unmanagedBlock(ManagedBlocker blocker)\n+        throws InterruptedException {\n+        if (blocker == null) throw new NullPointerException();\n+        do {} while (!blocker.isReleasable() && !blocker.block());\n@@ -3164,3 +3422,3 @@\n-    \/\/ AbstractExecutorService overrides.  These rely on undocumented\n-    \/\/ fact that ForkJoinTask.adapt returns ForkJoinTasks that also\n-    \/\/ implement RunnableFuture.\n+    \/\/ AbstractExecutorService.newTaskFor overrides rely on\n+    \/\/ undocumented fact that ForkJoinTask.adapt returns ForkJoinTasks\n+    \/\/ that also implement RunnableFuture.\n@@ -3168,0 +3426,1 @@\n+    @Override\n@@ -3172,0 +3431,1 @@\n+    @Override\n@@ -3176,5 +3436,0 @@\n-    \/\/ VarHandle mechanics\n-    private static final VarHandle CTL;\n-    private static final VarHandle MODE;\n-    static final VarHandle QA;\n-\n@@ -3186,1 +3441,2 @@\n-            QA = MethodHandles.arrayElementVarHandle(ForkJoinTask[].class);\n+            THREADIDS = l.findVarHandle(ForkJoinPool.class, \"threadIds\", int.class);\n+            POOLIDS = l.findStaticVarHandle(ForkJoinPool.class, \"poolIds\", int.class);\n@@ -3207,1 +3463,0 @@\n-\n@@ -3214,27 +3469,0 @@\n-\n-    \/**\n-     * Factory for innocuous worker threads.\n-     *\/\n-    private static final class InnocuousForkJoinWorkerThreadFactory\n-        implements ForkJoinWorkerThreadFactory {\n-\n-        \/**\n-         * An ACC to restrict permissions for the factory itself.\n-         * The constructed workers have no permissions set.\n-         *\/\n-        private static final AccessControlContext ACC = contextWithPermissions(\n-            modifyThreadPermission,\n-            new RuntimePermission(\"enableContextClassLoaderOverride\"),\n-            new RuntimePermission(\"modifyThreadGroup\"),\n-            new RuntimePermission(\"getClassLoader\"),\n-            new RuntimePermission(\"setContextClassLoader\"));\n-\n-        public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {\n-            return AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    public ForkJoinWorkerThread run() {\n-                        return new ForkJoinWorkerThread.\n-                            InnocuousForkJoinWorkerThread(pool); }},\n-                ACC);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":1635,"deletions":1407,"binary":false,"changes":3042,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n@@ -47,1 +45,1 @@\n-import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.LockSupport;\n@@ -220,12 +218,0 @@\n-     *\/\n-\n-    \/**\n-     * The status field holds run control status bits packed into a\n-     * single int to ensure atomicity.  Status is initially zero, and\n-     * takes on nonnegative values until completed, upon which it\n-     * holds (sign bit) DONE, possibly with ABNORMAL (cancelled or\n-     * exceptional) and THROWN (in which case an exception has been\n-     * stored). Tasks with dependent blocked waiting joiners have the\n-     * SIGNAL bit set.  Completion of a task with SIGNAL set awakens\n-     * any waiters via notifyAll. (Waiters also help signal others\n-     * upon completion.)\n@@ -233,3 +219,3 @@\n-     * These control bits occupy only (some of) the upper half (16\n-     * bits) of status field. The lower bits are used for user-defined\n-     * tags.\n+     * Revision notes: The use of \"Aux\" field replaces previous\n+     * reliance on a table to hold exceptions and synchronized blocks\n+     * and monitors to wait for completion.\n@@ -237,7 +223,0 @@\n-    volatile int status; \/\/ accessed directly by pool and workers\n-\n-    private static final int DONE     = 1 << 31; \/\/ must be negative\n-    private static final int ABNORMAL = 1 << 18; \/\/ set atomically with DONE\n-    private static final int THROWN   = 1 << 17; \/\/ set atomically with ABNORMAL\n-    private static final int SIGNAL   = 1 << 16; \/\/ true if joiner waiting\n-    private static final int SMASK    = 0xffff;  \/\/ short bits for tags\n@@ -246,1 +225,4 @@\n-     * Constructor for subclasses to call.\n+     * Nodes for threads waiting for completion, or holding a thrown\n+     * exception (never both). Waiting threads prepend nodes\n+     * Treiber-stack-style.  Signallers detach and unpark\n+     * waiters. Cancelled waiters try to unsplice.\n@@ -248,4 +230,20 @@\n-    public ForkJoinTask() {}\n-\n-    static boolean isExceptionalStatus(int s) {  \/\/ needed by subclasses\n-        return (s & THROWN) != 0;\n+    static final class Aux {\n+        final Thread thread;\n+        final Throwable ex;  \/\/ null if a waiter\n+        Aux next;            \/\/ accessed only via memory-acquire chains\n+        Aux(Thread thread, Throwable ex) {\n+            this.thread = thread;\n+            this.ex = ex;\n+        }\n+        final boolean casNext(Aux c, Aux v) { \/\/ used only in cancellation\n+            return NEXT.compareAndSet(this, c, v);\n+        }\n+        private static final VarHandle NEXT;\n+        static {\n+            try {\n+                NEXT = MethodHandles.lookup()\n+                    .findVarHandle(Aux.class, \"next\", Aux.class);\n+            } catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n@@ -254,10 +252,25 @@\n-    \/**\n-     * Sets DONE status and wakes up threads waiting to join this task.\n-     *\n-     * @return status on exit\n-     *\/\n-    private int setDone() {\n-        int s;\n-        if (((s = (int)STATUS.getAndBitwiseOr(this, DONE)) & SIGNAL) != 0)\n-            synchronized (this) { notifyAll(); }\n-        return s | DONE;\n+    \/*\n+     * The status field holds bits packed into a single int to ensure\n+     * atomicity.  Status is initially zero, and takes on nonnegative\n+     * values until completed, upon which it holds (sign bit) DONE,\n+     * possibly with ABNORMAL (cancelled or exceptional) and THROWN\n+     * (in which case an exception has been stored). A value of\n+     * ABNORMAL without DONE signifies an interrupted wait.  These\n+     * control bits occupy only (some of) the upper half (16 bits) of\n+     * status field. The lower bits are used for user-defined tags.\n+     *\/\n+    private static final int DONE         = 1 << 31; \/\/ must be negative\n+    private static final int ABNORMAL     = 1 << 16;\n+    private static final int THROWN       = 1 << 17;\n+    private static final int SMASK        = 0xffff;  \/\/ short bits for tags\n+    private static final int UNCOMPENSATE = 1 << 16; \/\/ helpJoin return sentinel\n+\n+    \/\/ Fields\n+    volatile int status;                \/\/ accessed directly by pool and workers\n+    private transient volatile Aux aux; \/\/ either waiters or thrown Exception\n+\n+    \/\/ Support for atomic operations\n+    private static final VarHandle STATUS;\n+    private static final VarHandle AUX;\n+    private int getAndBitwiseOrStatus(int v) {\n+        return (int)STATUS.getAndBitwiseOr(this, v);\n@@ -265,17 +278,5 @@\n-\n-    \/**\n-     * Marks cancelled or exceptional completion unless already done.\n-     *\n-     * @param completion must be DONE | ABNORMAL, ORed with THROWN if exceptional\n-     * @return status on exit\n-     *\/\n-    private int abnormalCompletion(int completion) {\n-        for (int s, ns;;) {\n-            if ((s = status) < 0)\n-                return s;\n-            else if (STATUS.weakCompareAndSet(this, s, ns = s | completion)) {\n-                if ((s & SIGNAL) != 0)\n-                    synchronized (this) { notifyAll(); }\n-                return ns;\n-            }\n-        }\n+    private boolean casStatus(int c, int v) {\n+        return STATUS.weakCompareAndSet(this, c, v);\n+    }\n+    private boolean casAux(Aux c, Aux v) {\n+        return AUX.compareAndSet(this, c, v);\n@@ -284,15 +285,9 @@\n-    \/**\n-     * Primary execution method for stolen tasks. Unless done, calls\n-     * exec and records status if completed, but doesn't wait for\n-     * completion otherwise.\n-     *\n-     * @return status on exit from this method\n-     *\/\n-    final int doExec() {\n-        int s; boolean completed;\n-        if ((s = status) >= 0) {\n-            try {\n-                completed = exec();\n-            } catch (Throwable rex) {\n-                completed = false;\n-                s = setExceptionalCompletion(rex);\n+    \/** Removes and unparks waiters *\/\n+    private void signalWaiters() {\n+        for (Aux a; (a = aux) != null && a.ex == null; ) {\n+            if (casAux(a, null)) {             \/\/ detach entire list\n+                for (Thread t; a != null; a = a.next) {\n+                    if ((t = a.thread) != Thread.currentThread() && t != null)\n+                        LockSupport.unpark(t); \/\/ don't self-signal\n+                }\n+                break;\n@@ -300,2 +295,0 @@\n-            if (completed)\n-                s = setDone();\n@@ -303,1 +296,0 @@\n-        return s;\n@@ -307,2 +299,1 @@\n-     * If not done, sets SIGNAL status and performs Object.wait(timeout).\n-     * This task may or may not be done on exit. Ignores interrupts.\n+     * Possibly blocks until task is done or interrupted or timed out.\n@@ -310,1 +301,4 @@\n-     * @param timeout using Object.wait conventions.\n+     * @param interruptible true if wait can be cancelled by interrupt\n+     * @param deadline if non-zero use timed waits and possibly timeout\n+     * @param pool if nonnull pool to uncompensate after unblocking\n+     * @return status on exit, or ABNORMAL if interrupted while waiting\n@@ -312,5 +306,20 @@\n-    final void internalWait(long timeout) {\n-        if ((int)STATUS.getAndBitwiseOr(this, SIGNAL) >= 0) {\n-            synchronized (this) {\n-                if (status >= 0)\n-                    try { wait(timeout); } catch (InterruptedException ie) { }\n+    private int awaitDone(boolean interruptible, long deadline,\n+                          ForkJoinPool pool) {\n+        int s;\n+        boolean interrupted = false, queued = false, parked = false;\n+        Aux node = null;\n+        while ((s = status) >= 0) {\n+            Aux a; long ns;\n+            if (parked && Thread.interrupted()) {\n+                if (interruptible) {\n+                    s = ABNORMAL;\n+                    break;\n+                }\n+                interrupted = true;\n+            }\n+            else if (queued) {\n+                if (deadline != 0L) {\n+                    if ((ns = deadline - System.nanoTime()) <= 0L)\n+                        break;\n+                    LockSupport.parkNanos(ns);\n+                }\n@@ -318,1 +327,15 @@\n-                    notifyAll();\n+                    LockSupport.park();\n+                parked = true;\n+            }\n+            else if (node != null) {\n+                if ((a = aux) != null && a.ex != null)\n+                    Thread.onSpinWait();     \/\/ exception in progress\n+                else if (queued = casAux(node.next = a, node))\n+                    LockSupport.setCurrentBlocker(this);\n+            }\n+            else {\n+                try {\n+                    node = new Aux(Thread.currentThread(), null);\n+                } catch (Throwable ex) {     \/\/ try to cancel if cannot create\n+                    casStatus(s, s | (DONE | ABNORMAL));\n+                }\n@@ -321,17 +344,19 @@\n-    }\n-\n-    \/**\n-     * Blocks a non-worker-thread until completion.\n-     * @return status upon completion\n-     *\/\n-    private int externalAwaitDone() {\n-        int s = tryExternalHelp();\n-        if (s >= 0 && (s = (int)STATUS.getAndBitwiseOr(this, SIGNAL)) >= 0) {\n-            boolean interrupted = false;\n-            synchronized (this) {\n-                for (;;) {\n-                    if ((s = status) >= 0) {\n-                        try {\n-                            wait(0L);\n-                        } catch (InterruptedException ie) {\n-                            interrupted = true;\n+        if (pool != null)\n+            pool.uncompensate();\n+\n+        if (queued) {\n+            LockSupport.setCurrentBlocker(null);\n+            if (s >= 0) { \/\/ cancellation similar to AbstractQueuedSynchronizer\n+                outer: for (Aux a; (a = aux) != null && a.ex == null; ) {\n+                    for (Aux trail = null;;) {\n+                        Aux next = a.next;\n+                        if (a == node) {\n+                            if (trail != null)\n+                                trail.casNext(trail, next);\n+                            else if (casAux(a, next))\n+                                break outer; \/\/ cannot be re-encountered\n+                            break;           \/\/ restart\n+                        } else {\n+                            trail = a;\n+                            if ((a = next) == null)\n+                                break outer;\n@@ -340,4 +365,0 @@\n-                    else {\n-                        notifyAll();\n-                        break;\n-                    }\n@@ -346,2 +367,5 @@\n-            if (interrupted)\n-                Thread.currentThread().interrupt();\n+            else {\n+                signalWaiters();             \/\/ help clean or signal\n+                if (interrupted)\n+                    Thread.currentThread().interrupt();\n+            }\n@@ -353,1 +377,2 @@\n-     * Blocks a non-worker-thread until completion or interruption.\n+     * Sets DONE status and wakes up threads waiting to join this task.\n+     * @return status on exit\n@@ -355,16 +380,3 @@\n-    private int externalInterruptibleAwaitDone() throws InterruptedException {\n-        int s = tryExternalHelp();\n-        if (s >= 0 && (s = (int)STATUS.getAndBitwiseOr(this, SIGNAL)) >= 0) {\n-            synchronized (this) {\n-                for (;;) {\n-                    if ((s = status) >= 0)\n-                        wait(0L);\n-                    else {\n-                        notifyAll();\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        else if (Thread.interrupted())\n-            throw new InterruptedException();\n+    private int setDone() {\n+        int s = getAndBitwiseOrStatus(DONE) | DONE;\n+        signalWaiters();\n@@ -375,3 +387,3 @@\n-     * Tries to help with tasks allowed for external callers.\n-     *\n-     * @return current status\n+     * Sets ABNORMAL DONE status unless already done, and wakes up threads\n+     * waiting to join this task.\n+     * @return status on exit\n@@ -379,1 +391,1 @@\n-    private int tryExternalHelp() {\n+    private int trySetCancelled() {\n@@ -381,6 +393,3 @@\n-        return ((s = status) < 0 ? s:\n-                (this instanceof CountedCompleter) ?\n-                ForkJoinPool.common.externalHelpComplete(\n-                    (CountedCompleter<?>)this, 0) :\n-                ForkJoinPool.common.tryExternalUnpush(this) ?\n-                doExec() : 0);\n+        do {} while ((s = status) >= 0 && !casStatus(s, s |= (DONE | ABNORMAL)));\n+        signalWaiters();\n+        return s;\n@@ -390,3 +399,4 @@\n-     * Implementation for join, get, quietlyJoin. Directly handles\n-     * only cases of already-completed, external wait, and\n-     * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.\n+     * Records exception and sets ABNORMAL THROWN DONE status unless\n+     * already done, and wakes up threads waiting to join this task.\n+     * If losing a race with setDone or trySetCancelled, the exception\n+     * may be recorded but not reported.\n@@ -394,1 +404,1 @@\n-     * @return status upon completion\n+     * @return status on exit\n@@ -396,8 +406,15 @@\n-    private int doJoin() {\n-        int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;\n-        return (s = status) < 0 ? s :\n-            ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n-            (w = (wt = (ForkJoinWorkerThread)t).workQueue).\n-            tryUnpush(this) && (s = doExec()) < 0 ? s :\n-            wt.pool.awaitJoin(w, this, 0L) :\n-            externalAwaitDone();\n+    final int trySetThrown(Throwable ex) {\n+        Aux h = new Aux(Thread.currentThread(), ex), p = null;\n+        boolean installed = false;\n+        int s;\n+        while ((s = status) >= 0) {\n+            Aux a;\n+            if (!installed && ((a = aux) == null || a.ex == null) &&\n+                (installed = casAux(a, h)))\n+                p = a; \/\/ list of waiters replaced by h\n+            if (installed && casStatus(s, s |= (DONE | ABNORMAL | THROWN)))\n+                break;\n+        }\n+        for (; p != null; p = p.next)\n+            LockSupport.unpark(p.thread);\n+        return s;\n@@ -407,1 +424,1 @@\n-     * Implementation for invoke, quietlyInvoke.\n+     * Records exception unless already done. Overridable in subclasses.\n@@ -409,1 +426,1 @@\n-     * @return status upon completion\n+     * @return status on exit\n@@ -411,7 +428,2 @@\n-    private int doInvoke() {\n-        int s; Thread t; ForkJoinWorkerThread wt;\n-        return (s = doExec()) < 0 ? s :\n-            ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n-            (wt = (ForkJoinWorkerThread)t).pool.\n-            awaitJoin(wt.workQueue, this, 0L) :\n-            externalAwaitDone();\n+    int trySetException(Throwable ex) {\n+        return trySetThrown(ex);\n@@ -420,2 +432,0 @@\n-    \/\/ Exception table support\n-\n@@ -423,7 +433,1 @@\n-     * Hash table of exceptions thrown by tasks, to enable reporting\n-     * by callers. Because exceptions are rare, we don't directly keep\n-     * them with task objects, but instead use a weak ref table.  Note\n-     * that cancellation exceptions don't appear in the table, but are\n-     * instead recorded as status values.\n-     *\n-     * The exception table has a fixed capacity.\n+     * Constructor for subclasses to call.\n@@ -431,10 +435,1 @@\n-    private static final ExceptionNode[] exceptionTable\n-        = new ExceptionNode[32];\n-\n-    \/** Lock protecting access to exceptionTable. *\/\n-    private static final ReentrantLock exceptionTableLock\n-        = new ReentrantLock();\n-\n-    \/** Reference queue of stale exceptionally completed tasks. *\/\n-    private static final ReferenceQueue<ForkJoinTask<?>> exceptionTableRefQueue\n-        = new ReferenceQueue<>();\n+    public ForkJoinTask() {}\n@@ -442,25 +437,2 @@\n-    \/**\n-     * Key-value nodes for exception table.  The chained hash table\n-     * uses identity comparisons, full locking, and weak references\n-     * for keys. The table has a fixed capacity because it only\n-     * maintains task exceptions long enough for joiners to access\n-     * them, so should never become very large for sustained\n-     * periods. However, since we do not know when the last joiner\n-     * completes, we must use weak references and expunge them. We do\n-     * so on each operation (hence full locking). Also, some thread in\n-     * any ForkJoinPool will call helpExpungeStaleExceptions when its\n-     * pool becomes isQuiescent.\n-     *\/\n-    static final class ExceptionNode extends WeakReference<ForkJoinTask<?>> {\n-        final Throwable ex;\n-        ExceptionNode next;\n-        final long thrower;  \/\/ use id not ref to avoid weak cycles\n-        final int hashCode;  \/\/ store task hashCode before weak ref disappears\n-        ExceptionNode(ForkJoinTask<?> task, Throwable ex, ExceptionNode next,\n-                      ReferenceQueue<ForkJoinTask<?>> exceptionTableRefQueue) {\n-            super(task, exceptionTableRefQueue);\n-            this.ex = ex;\n-            this.next = next;\n-            this.thrower = Thread.currentThread().getId();\n-            this.hashCode = System.identityHashCode(task);\n-        }\n+    static boolean isExceptionalStatus(int s) {  \/\/ needed by subclasses\n+        return (s & THROWN) != 0;\n@@ -470,1 +442,2 @@\n-     * Records exception and sets status.\n+     * Unless done, calls exec and records status if completed, but\n+     * doesn't wait for completion otherwise.\n@@ -472,1 +445,1 @@\n-     * @return status on exit\n+     * @return status on exit from this method\n@@ -474,2 +447,2 @@\n-    final int recordExceptionalCompletion(Throwable ex) {\n-        int s;\n+    final int doExec() {\n+        int s; boolean completed;\n@@ -477,3 +450,0 @@\n-            int h = System.identityHashCode(this);\n-            final ReentrantLock lock = exceptionTableLock;\n-            lock.lock();\n@@ -481,14 +451,4 @@\n-                expungeStaleExceptions();\n-                ExceptionNode[] t = exceptionTable;\n-                int i = h & (t.length - 1);\n-                for (ExceptionNode e = t[i]; ; e = e.next) {\n-                    if (e == null) {\n-                        t[i] = new ExceptionNode(this, ex, t[i],\n-                                                 exceptionTableRefQueue);\n-                        break;\n-                    }\n-                    if (e.get() == this) \/\/ already present\n-                        break;\n-                }\n-            } finally {\n-                lock.unlock();\n+                completed = exec();\n+            } catch (Throwable rex) {\n+                s = trySetException(rex);\n+                completed = false;\n@@ -496,1 +456,2 @@\n-            s = abnormalCompletion(DONE | ABNORMAL | THROWN);\n+            if (completed)\n+                s = setDone();\n@@ -502,1 +463,2 @@\n-     * Records exception and possibly propagates.\n+     * Helps and\/or waits for completion from join, get, or invoke;\n+     * called from either internal or external threads.\n@@ -504,26 +466,43 @@\n-     * @return status on exit\n-     *\/\n-    private int setExceptionalCompletion(Throwable ex) {\n-        int s = recordExceptionalCompletion(ex);\n-        if ((s & THROWN) != 0)\n-            internalPropagateException(ex);\n-        return s;\n-    }\n-\n-    \/**\n-     * Hook for exception propagation support for tasks with completers.\n-     *\/\n-    void internalPropagateException(Throwable ex) {\n-    }\n-\n-    \/**\n-     * Cancels, ignoring any exceptions thrown by cancel. Used during\n-     * worker and pool shutdown. Cancel is spec'ed not to throw any\n-     * exceptions, but if it does anyway, we have no recourse during\n-     * shutdown, so guard against this case.\n-     *\/\n-    static final void cancelIgnoringExceptions(ForkJoinTask<?> t) {\n-        if (t != null && t.status >= 0) {\n-            try {\n-                t.cancel(false);\n-            } catch (Throwable ignore) {\n+     * @param ran true if task known to have been exec'd\n+     * @param interruptible true if park interruptibly when external\n+     * @param timed true if use timed wait\n+     * @param nanos if timed, timeout value\n+     * @return ABNORMAL if interrupted, else status on exit\n+     *\/\n+    private int awaitJoin(boolean ran, boolean interruptible, boolean timed,\n+                          long nanos) {\n+        boolean internal; ForkJoinPool p; ForkJoinPool.WorkQueue q; int s;\n+        Thread t; ForkJoinWorkerThread wt;\n+        if (internal = ((t = Thread.currentThread())\n+                        instanceof ForkJoinWorkerThread)) {\n+            p = (wt = (ForkJoinWorkerThread)t).pool;\n+            q = wt.workQueue;\n+        }\n+        else {\n+            p = ForkJoinPool.common;\n+            q = ForkJoinPool.commonQueue();\n+            if (interruptible && Thread.interrupted())\n+                return ABNORMAL;\n+        }\n+        if ((s = status) < 0)\n+            return s;\n+        long deadline = 0L;\n+        if (timed) {\n+            if (nanos <= 0L)\n+                return 0;\n+            else if ((deadline = nanos + System.nanoTime()) == 0L)\n+                deadline = 1L;\n+        }\n+        ForkJoinPool uncompensate = null;\n+        if (q != null && p != null) {            \/\/ try helping\n+            if ((!timed || p.isSaturated()) &&\n+                ((this instanceof CountedCompleter) ?\n+                 (s = p.helpComplete(this, q, internal)) < 0 :\n+                 (q.tryRemove(this, internal) && (s = doExec()) < 0)))\n+                return s;\n+            if (internal) {\n+                if ((s = p.helpJoin(this, q)) < 0)\n+                    return s;\n+                if (s == UNCOMPENSATE)\n+                    uncompensate = p;\n+                interruptible = false;\n@@ -532,0 +511,1 @@\n+        return awaitDone(interruptible, deadline, uncompensate);\n@@ -535,1 +515,3 @@\n-     * Removes exception node and clears status.\n+     * Cancels, ignoring any exceptions thrown by cancel.  Cancel is\n+     * spec'ed not to throw any exceptions, but if it does anyway, we\n+     * have no recourse, so guard against this case.\n@@ -537,20 +519,5 @@\n-    private void clearExceptionalCompletion() {\n-        int h = System.identityHashCode(this);\n-        final ReentrantLock lock = exceptionTableLock;\n-        lock.lock();\n-        try {\n-            ExceptionNode[] t = exceptionTable;\n-            int i = h & (t.length - 1);\n-            ExceptionNode e = t[i];\n-            ExceptionNode pred = null;\n-            while (e != null) {\n-                ExceptionNode next = e.next;\n-                if (e.get() == this) {\n-                    if (pred == null)\n-                        t[i] = next;\n-                    else\n-                        pred.next = next;\n-                    break;\n-                }\n-                pred = e;\n-                e = next;\n+    static final void cancelIgnoringExceptions(Future<?> t) {\n+        if (t != null) {\n+            try {\n+                t.cancel(true);\n+            } catch (Throwable ignore) {\n@@ -558,4 +525,0 @@\n-            expungeStaleExceptions();\n-            status = 0;\n-        } finally {\n-            lock.unlock();\n@@ -580,17 +543,4 @@\n-        int h = System.identityHashCode(this);\n-        ExceptionNode e;\n-        final ReentrantLock lock = exceptionTableLock;\n-        lock.lock();\n-        try {\n-            expungeStaleExceptions();\n-            ExceptionNode[] t = exceptionTable;\n-            e = t[h & (t.length - 1)];\n-            while (e != null && e.get() != this)\n-                e = e.next;\n-        } finally {\n-            lock.unlock();\n-        }\n-        Throwable ex;\n-        if (e == null || (ex = e.ex) == null)\n-            return null;\n-        if (e.thrower != Thread.currentThread().getId()) {\n+        Throwable ex; Aux a;\n+        if ((a = aux) == null)\n+            ex = null;\n+        else if ((ex = a.ex) != null && a.thread != Thread.currentThread()) {\n@@ -598,2 +548,1 @@\n-                Constructor<?> noArgCtor = null;\n-                \/\/ public ctors only\n+                Constructor<?> noArgCtor = null, oneArgCtor = null;\n@@ -604,2 +553,4 @@\n-                    else if (ps.length == 1 && ps[0] == Throwable.class)\n-                        return (Throwable)c.newInstance(ex);\n+                    else if (ps.length == 1 && ps[0] == Throwable.class) {\n+                        oneArgCtor = c;\n+                        break;\n+                    }\n@@ -607,4 +558,6 @@\n-                if (noArgCtor != null) {\n-                    Throwable wx = (Throwable)noArgCtor.newInstance();\n-                    wx.initCause(ex);\n-                    return wx;\n+                if (oneArgCtor != null)\n+                    ex = (Throwable)oneArgCtor.newInstance(ex);\n+                else if (noArgCtor != null) {\n+                    Throwable rx = (Throwable)noArgCtor.newInstance();\n+                    rx.initCause(ex);\n+                    ex = rx;\n@@ -619,1 +572,1 @@\n-     * Polls stale refs and removes them. Call only while holding lock.\n+     * Returns exception associated with the given status, or null if none.\n@@ -621,21 +574,6 @@\n-    private static void expungeStaleExceptions() {\n-        for (Object x; (x = exceptionTableRefQueue.poll()) != null;) {\n-            if (x instanceof ExceptionNode) {\n-                ExceptionNode[] t = exceptionTable;\n-                int i = ((ExceptionNode)x).hashCode & (t.length - 1);\n-                ExceptionNode e = t[i];\n-                ExceptionNode pred = null;\n-                while (e != null) {\n-                    ExceptionNode next = e.next;\n-                    if (e == x) {\n-                        if (pred == null)\n-                            t[i] = next;\n-                        else\n-                            pred.next = next;\n-                        break;\n-                    }\n-                    pred = e;\n-                    e = next;\n-                }\n-            }\n-        }\n+    private Throwable getException(int s) {\n+        Throwable ex = null;\n+        if ((s & ABNORMAL) != 0 &&\n+            ((s & THROWN) == 0 || (ex = getThrowableException()) == null))\n+            ex = new CancellationException();\n+        return ex;\n@@ -645,2 +583,2 @@\n-     * If lock is available, polls stale refs and removes them.\n-     * Called from ForkJoinPool when pools become quiescent.\n+     * Throws exception associated with the given status, or\n+     * CancellationException if none recorded.\n@@ -648,9 +586,18 @@\n-    static final void helpExpungeStaleExceptions() {\n-        final ReentrantLock lock = exceptionTableLock;\n-        if (lock.tryLock()) {\n-            try {\n-                expungeStaleExceptions();\n-            } finally {\n-                lock.unlock();\n-            }\n-        }\n+    private void reportException(int s) {\n+        ForkJoinTask.<RuntimeException>uncheckedThrow(\n+            (s & THROWN) != 0 ? getThrowableException() : null);\n+    }\n+\n+    \/**\n+     * Throws exception for (timed or untimed) get, wrapping if\n+     * necessary in an ExecutionException.\n+     *\/\n+    private void reportExecutionException(int s) {\n+        Throwable ex = null;\n+        if (s == ABNORMAL)\n+            ex = new InterruptedException();\n+        else if (s >= 0)\n+            ex = new TimeoutException();\n+        else if ((s & THROWN) != 0 && (ex = getThrowableException()) != null)\n+            ex = new ExecutionException(ex);\n+        ForkJoinTask.<RuntimeException>uncheckedThrow(ex);\n@@ -660,1 +607,2 @@\n-     * A version of \"sneaky throw\" to relay exceptions.\n+     * A version of \"sneaky throw\" to relay exceptions in other\n+     * contexts.\n@@ -669,1 +617,2 @@\n-     * unchecked exceptions.\n+     * unchecked exceptions. If argument null, throws\n+     * CancellationException.\n@@ -673,12 +622,3 @@\n-        if (t != null)\n-            throw (T)t; \/\/ rely on vacuous cast\n-        else\n-            throw new Error(\"Unknown Exception\");\n-    }\n-\n-    \/**\n-     * Throws exception, if any, associated with the given status.\n-     *\/\n-    private void reportException(int s) {\n-        rethrow((s & THROWN) != 0 ? getThrowableException() :\n-                new CancellationException());\n+        if (t == null)\n+            t = new CancellationException();\n+        throw (T)t; \/\/ rely on vacuous cast\n@@ -705,1 +645,1 @@\n-        Thread t;\n+        Thread t; ForkJoinWorkerThread w;\n@@ -707,1 +647,1 @@\n-            ((ForkJoinWorkerThread)t).workQueue.push(this);\n+            (w = (ForkJoinWorkerThread)t).workQueue.push(this, w.pool);\n@@ -726,1 +666,3 @@\n-        if (((s = doJoin()) & ABNORMAL) != 0)\n+        if ((s = status) >= 0)\n+            s = awaitJoin(false, false, false, 0L);\n+        if ((s & ABNORMAL) != 0)\n@@ -741,1 +683,3 @@\n-        if (((s = doInvoke()) & ABNORMAL) != 0)\n+        if ((s = doExec()) >= 0)\n+            s = awaitJoin(true, false, false, 0L);\n+        if ((s & ABNORMAL) != 0)\n@@ -765,0 +709,2 @@\n+        if (t1 == null || t2 == null)\n+            throw new NullPointerException();\n@@ -766,1 +712,4 @@\n-        if (((s1 = t1.doInvoke()) & ABNORMAL) != 0)\n+        if ((s1 = t1.doExec()) >= 0)\n+            s1 = t1.awaitJoin(true, false, false, 0L);\n+        if ((s1 & ABNORMAL) != 0) {\n+            cancelIgnoringExceptions(t2);\n@@ -768,1 +717,2 @@\n-        if (((s2 = t2.doJoin()) & ABNORMAL) != 0)\n+        }\n+        else if (((s2 = t2.awaitJoin(false, false, false, 0L)) & ABNORMAL) != 0)\n@@ -791,4 +741,12 @@\n-            ForkJoinTask<?> t = tasks[i];\n-            if (t == null) {\n-                if (ex == null)\n-                    ex = new NullPointerException();\n+            ForkJoinTask<?> t;\n+            if ((t = tasks[i]) == null) {\n+                ex = new NullPointerException();\n+                break;\n+            }\n+            if (i == 0) {\n+                int s;\n+                if ((s = t.doExec()) >= 0)\n+                    s = t.awaitJoin(true, false, false, 0L);\n+                if ((s & ABNORMAL) != 0)\n+                    ex = t.getException(s);\n+                break;\n@@ -796,4 +754,1 @@\n-            else if (i != 0)\n-                t.fork();\n-            else if ((t.doInvoke() & ABNORMAL) != 0 && ex == null)\n-                ex = t.getException();\n+            t.fork();\n@@ -801,7 +756,10 @@\n-        for (int i = 1; i <= last; ++i) {\n-            ForkJoinTask<?> t = tasks[i];\n-            if (t != null) {\n-                if (ex != null)\n-                    t.cancel(false);\n-                else if ((t.doJoin() & ABNORMAL) != 0)\n-                    ex = t.getException();\n+        if (ex == null) {\n+            for (int i = 1; i <= last; ++i) {\n+                ForkJoinTask<?> t;\n+                if ((t = tasks[i]) != null) {\n+                    int s;\n+                    if ((s = t.status) >= 0)\n+                        s = t.awaitJoin(false, false, false, 0L);\n+                    if ((s & ABNORMAL) != 0 && (ex = t.getException(s)) != null)\n+                        break;\n+                }\n@@ -810,1 +768,3 @@\n-        if (ex != null)\n+        if (ex != null) {\n+            for (int i = 1; i <= last; ++i)\n+                cancelIgnoringExceptions(tasks[i]);\n@@ -812,0 +772,1 @@\n+        }\n@@ -841,1 +802,1 @@\n-        int last = ts.size() - 1;\n+        int last = ts.size() - 1;  \/\/ nearly same as array version\n@@ -843,4 +804,12 @@\n-            ForkJoinTask<?> t = ts.get(i);\n-            if (t == null) {\n-                if (ex == null)\n-                    ex = new NullPointerException();\n+            ForkJoinTask<?> t;\n+            if ((t = ts.get(i)) == null) {\n+                ex = new NullPointerException();\n+                break;\n+            }\n+            if (i == 0) {\n+                int s;\n+                if ((s = t.doExec()) >= 0)\n+                    s = t.awaitJoin(true, false, false, 0L);\n+                if ((s & ABNORMAL) != 0)\n+                    ex = t.getException(s);\n+                break;\n@@ -848,4 +817,1 @@\n-            else if (i != 0)\n-                t.fork();\n-            else if ((t.doInvoke() & ABNORMAL) != 0 && ex == null)\n-                ex = t.getException();\n+            t.fork();\n@@ -853,7 +819,10 @@\n-        for (int i = 1; i <= last; ++i) {\n-            ForkJoinTask<?> t = ts.get(i);\n-            if (t != null) {\n-                if (ex != null)\n-                    t.cancel(false);\n-                else if ((t.doJoin() & ABNORMAL) != 0)\n-                    ex = t.getException();\n+        if (ex == null) {\n+            for (int i = 1; i <= last; ++i) {\n+                ForkJoinTask<?> t;\n+                if ((t = ts.get(i)) != null) {\n+                    int s;\n+                    if ((s = t.status) >= 0)\n+                        s = t.awaitJoin(false, false, false, 0L);\n+                    if ((s & ABNORMAL) != 0 && (ex = t.getException(s)) != null)\n+                        break;\n+                }\n@@ -862,1 +831,3 @@\n-        if (ex != null)\n+        if (ex != null) {\n+            for (int i = 1; i <= last; ++i)\n+                cancelIgnoringExceptions(ts.get(i));\n@@ -864,0 +835,1 @@\n+        }\n@@ -895,2 +867,1 @@\n-        int s = abnormalCompletion(DONE | ABNORMAL);\n-        return (s & (ABNORMAL | THROWN)) == ABNORMAL;\n+        return (trySetCancelled() & (ABNORMAL | THROWN)) == ABNORMAL;\n@@ -935,4 +906,1 @@\n-        int s = status;\n-        return ((s & ABNORMAL) == 0 ? null :\n-                (s & THROWN)   == 0 ? new CancellationException() :\n-                getThrowableException());\n+        return getException(status);\n@@ -956,3 +924,3 @@\n-        setExceptionalCompletion((ex instanceof RuntimeException) ||\n-                                 (ex instanceof Error) ? ex :\n-                                 new RuntimeException(ex));\n+        trySetException((ex instanceof RuntimeException) ||\n+                        (ex instanceof Error) ? ex :\n+                        new RuntimeException(ex));\n@@ -978,1 +946,1 @@\n-            setExceptionalCompletion(rex);\n+            trySetException(rex);\n@@ -1008,8 +976,4 @@\n-        int s = (Thread.currentThread() instanceof ForkJoinWorkerThread) ?\n-            doJoin() : externalInterruptibleAwaitDone();\n-        if ((s & THROWN) != 0)\n-            throw new ExecutionException(getThrowableException());\n-        else if ((s & ABNORMAL) != 0)\n-            throw new CancellationException();\n-        else\n-            return getRawResult();\n+        int s;\n+        if (((s = awaitJoin(false, true, false, 0L)) & ABNORMAL) != 0)\n+            reportExecutionException(s);\n+        return getRawResult();\n@@ -1035,39 +999,4 @@\n-        long nanos = unit.toNanos(timeout);\n-        if (Thread.interrupted())\n-            throw new InterruptedException();\n-        if ((s = status) >= 0 && nanos > 0L) {\n-            long d = System.nanoTime() + nanos;\n-            long deadline = (d == 0L) ? 1L : d; \/\/ avoid 0\n-            Thread t = Thread.currentThread();\n-            if (t instanceof ForkJoinWorkerThread) {\n-                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n-                s = wt.pool.awaitJoin(wt.workQueue, this, deadline);\n-            }\n-            else if ((s = ((this instanceof CountedCompleter) ?\n-                           ForkJoinPool.common.externalHelpComplete(\n-                               (CountedCompleter<?>)this, 0) :\n-                           ForkJoinPool.common.tryExternalUnpush(this) ?\n-                           doExec() : 0)) >= 0) {\n-                long ns, ms; \/\/ measure in nanosecs, but wait in millisecs\n-                while ((s = status) >= 0 &&\n-                       (ns = deadline - System.nanoTime()) > 0L) {\n-                    if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L &&\n-                        (s = (int)STATUS.getAndBitwiseOr(this, SIGNAL)) >= 0) {\n-                        synchronized (this) {\n-                            if (status >= 0)\n-                                wait(ms); \/\/ OK to throw InterruptedException\n-                            else\n-                                notifyAll();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if (s >= 0)\n-            throw new TimeoutException();\n-        else if ((s & THROWN) != 0)\n-            throw new ExecutionException(getThrowableException());\n-        else if ((s & ABNORMAL) != 0)\n-            throw new CancellationException();\n-        else\n-            return getRawResult();\n+        if ((s = awaitJoin(false, true, true, unit.toNanos(timeout))) >= 0 ||\n+            (s & ABNORMAL) != 0)\n+            reportExecutionException(s);\n+        return getRawResult();\n@@ -1083,1 +1012,2 @@\n-        doJoin();\n+        if (status >= 0)\n+            awaitJoin(false, false, false, 0L);\n@@ -1092,1 +1022,2 @@\n-        doInvoke();\n+        if (doExec() >= 0)\n+            awaitJoin(true, false, false, 0L);\n@@ -1103,5 +1034,4 @@\n-        Thread t;\n-        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n-            ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n-            wt.pool.helpQuiescePool(wt.workQueue);\n-        }\n+        Thread t; ForkJoinWorkerThread w; ForkJoinPool p;\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread &&\n+            (p = (w = (ForkJoinWorkerThread)t).pool) != null)\n+            p.helpQuiescePool(w.workQueue, Long.MAX_VALUE, false);\n@@ -1109,1 +1039,1 @@\n-            ForkJoinPool.quiesceCommonPool();\n+            ForkJoinPool.common.externalHelpQuiescePool(Long.MAX_VALUE, false);\n@@ -1129,4 +1059,2 @@\n-        if ((status & THROWN) != 0)\n-            clearExceptionalCompletion();\n-        else\n-            status = 0;\n+        aux = null;\n+        status = 0;\n@@ -1145,3 +1073,3 @@\n-        Thread t = Thread.currentThread();\n-        return (t instanceof ForkJoinWorkerThread) ?\n-            ((ForkJoinWorkerThread) t).pool : null;\n+        Thread t;\n+        return (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n+                ((ForkJoinWorkerThread) t).pool : null);\n@@ -1173,4 +1101,6 @@\n-        Thread t;\n-        return (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n-                ((ForkJoinWorkerThread)t).workQueue.tryUnpush(this) :\n-                ForkJoinPool.common.tryExternalUnpush(this));\n+        Thread t; ForkJoinPool.WorkQueue q;\n+        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n+            ? (q = ((ForkJoinWorkerThread)t).workQueue) != null\n+               && q.tryUnpush(this)\n+            : (q = ForkJoinPool.commonQueue()) != null\n+               && q.externalTryUnpush(this);\n@@ -1192,1 +1122,1 @@\n-            q = ForkJoinPool.commonSubmitterQueue();\n+            q = ForkJoinPool.commonQueue();\n@@ -1267,1 +1197,1 @@\n-            q = ForkJoinPool.commonSubmitterQueue();\n+            q = ForkJoinPool.commonQueue();\n@@ -1282,3 +1212,2 @@\n-        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n-            ((ForkJoinWorkerThread)t).workQueue.nextLocalTask() :\n-            null;\n+        return (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n+                ((ForkJoinWorkerThread)t).workQueue.nextLocalTask() : null);\n@@ -1301,4 +1230,4 @@\n-        Thread t; ForkJoinWorkerThread wt;\n-        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n-            (wt = (ForkJoinWorkerThread)t).pool.nextTaskFor(wt.workQueue) :\n-            null;\n+        Thread t; ForkJoinWorkerThread w;\n+        return (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n+                (w = (ForkJoinWorkerThread)t).pool.nextTaskFor(w.workQueue) :\n+                null);\n@@ -1320,2 +1249,2 @@\n-        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n-            ((ForkJoinWorkerThread)t).pool.pollSubmission() : null;\n+        return (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n+                ((ForkJoinWorkerThread)t).pool.pollSubmission() : null);\n@@ -1345,2 +1274,1 @@\n-            if (STATUS.weakCompareAndSet(this, s = status,\n-                                         (s & ~SMASK) | (newValue & SMASK)))\n+            if (casStatus(s = status, (s & ~SMASK) | (newValue & SMASK)))\n@@ -1369,2 +1297,1 @@\n-            if (STATUS.weakCompareAndSet(this, s,\n-                                         (s & ~SMASK) | (update & SMASK)))\n+            if (casStatus(s, (s & ~SMASK) | (update & SMASK)))\n@@ -1435,2 +1362,11 @@\n-        void internalPropagateException(Throwable ex) {\n-            rethrow(ex); \/\/ rethrow outside exec() catches.\n+        int trySetException(Throwable ex) { \/\/ if a handler, invoke it\n+            int s; Thread t; java.lang.Thread.UncaughtExceptionHandler h;\n+            if (isExceptionalStatus(s = trySetThrown(ex)) &&\n+                (h = ((t = Thread.currentThread()).\n+                      getUncaughtExceptionHandler())) != null) {\n+                try {\n+                    h.uncaughtException(t, ex);\n+                } catch (Throwable ignore) {\n+                }\n+            }\n+            return s;\n@@ -1473,0 +1409,47 @@\n+    static final class AdaptedInterruptibleCallable<T> extends ForkJoinTask<T>\n+        implements RunnableFuture<T> {\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        final Callable<? extends T> callable;\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        transient volatile Thread runner;\n+        T result;\n+        AdaptedInterruptibleCallable(Callable<? extends T> callable) {\n+            if (callable == null) throw new NullPointerException();\n+            this.callable = callable;\n+        }\n+        public final T getRawResult() { return result; }\n+        public final void setRawResult(T v) { result = v; }\n+        public final boolean exec() {\n+            Thread.interrupted();\n+            runner = Thread.currentThread();\n+            try {\n+                if (!isDone()) \/\/ recheck\n+                    result = callable.call();\n+                return true;\n+            } catch (RuntimeException rex) {\n+                throw rex;\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            } finally {\n+                runner = null;\n+                Thread.interrupted();\n+            }\n+        }\n+        public final void run() { invoke(); }\n+        public final boolean cancel(boolean mayInterruptIfRunning) {\n+            Thread t;\n+            boolean stat = super.cancel(false);\n+            if (mayInterruptIfRunning && (t = runner) != null) {\n+                try {\n+                    t.interrupt();\n+                } catch (Throwable ignore) {\n+                }\n+            }\n+            return stat;\n+        }\n+        public String toString() {\n+            return super.toString() + \"[Wrapped task = \" + callable + \"]\";\n+        }\n+        private static final long serialVersionUID = 2838392045355241008L;\n+    }\n+\n@@ -1513,0 +1496,20 @@\n+    \/**\n+     * Returns a new {@code ForkJoinTask} that performs the {@code call}\n+     * method of the given {@code Callable} as its action, and returns\n+     * its result upon {@link #join}, translating any checked exceptions\n+     * encountered into {@code RuntimeException}.  Additionally,\n+     * invocations of {@code cancel} with {@code mayInterruptIfRunning\n+     * true} will attempt to interrupt the thread performing the task.\n+     *\n+     * @param callable the callable action\n+     * @param <T> the type of the callable's result\n+     * @return the task\n+     *\n+     * @since 17\n+     *\/\n+    \/\/ adaptInterruptible deferred to its own independent change\n+    \/\/ https:\/\/bugs.openjdk.java.net\/browse\/JDK-8246587\n+    \/* TODO: public *\/ private static <T> ForkJoinTask<T> adaptInterruptible(Callable<? extends T> callable) {\n+        return new AdaptedInterruptibleCallable<T>(callable);\n+    }\n+\n@@ -1527,0 +1530,1 @@\n+        Aux a;\n@@ -1528,1 +1532,1 @@\n-        s.writeObject(getException());\n+        s.writeObject((a = aux) == null ? null : a.ex);\n@@ -1543,1 +1547,1 @@\n-            setExceptionalCompletion((Throwable)ex);\n+            trySetThrown((Throwable)ex);\n@@ -1546,2 +1550,0 @@\n-    \/\/ VarHandle mechanics\n-    private static final VarHandle STATUS;\n@@ -1552,0 +1554,1 @@\n+            AUX = l.findVarHandle(ForkJoinTask.class, \"aux\", Aux.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":484,"deletions":481,"binary":false,"changes":965,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.security.AccessControlContext;\n@@ -41,1 +40,0 @@\n-import java.security.ProtectionDomain;\n@@ -65,11 +63,1 @@\n-     * This class just maintains links to its pool and WorkQueue.  The\n-     * pool field is set immediately upon construction, but the\n-     * workQueue field is not set until a call to registerWorker\n-     * completes. This leads to a visibility race, that is tolerated\n-     * by requiring that the workQueue field is only accessed by the\n-     * owning thread.\n-     *\n-     * Support for (non-public) subclass InnocuousForkJoinWorkerThread\n-     * requires that we break quite a lot of encapsulation (via helper\n-     * methods in ThreadLocalRandom) both here and in the subclass to\n-     * access and set Thread fields.\n+     * This class just maintains links to its pool and WorkQueue.\n@@ -81,5 +69,0 @@\n-    \/** An AccessControlContext supporting no privileges *\/\n-    private static final AccessControlContext INNOCUOUS_ACC =\n-        new AccessControlContext(\n-            new ProtectionDomain[] { new ProtectionDomain(null, null) });\n-\n@@ -87,4 +70,1 @@\n-     * Creates a ForkJoinWorkerThread operating in the given pool.\n-     *\n-     * @param pool the pool this thread works in\n-     * @throws NullPointerException if pool is null\n+     * Full nonpublic constructor.\n@@ -92,5 +72,10 @@\n-    protected ForkJoinWorkerThread(ForkJoinPool pool) {\n-        \/\/ Use a placeholder until a useful name can be set in registerWorker\n-        super(\"aForkJoinWorkerThread\");\n-        this.pool = pool;\n-        this.workQueue = pool.registerWorker(this);\n+    ForkJoinWorkerThread(ThreadGroup group, ForkJoinPool pool,\n+                         boolean useSystemClassLoader, boolean isInnocuous) {\n+        super(group, null, pool.nextWorkerThreadName(), 0L);\n+        UncaughtExceptionHandler handler = (this.pool = pool).ueh;\n+        this.workQueue = new ForkJoinPool.WorkQueue(this, isInnocuous);\n+        super.setDaemon(true);\n+        if (handler != null)\n+            super.setUncaughtExceptionHandler(handler);\n+        if (useSystemClassLoader)\n+            super.setContextClassLoader(ClassLoader.getSystemClassLoader());\n@@ -100,3 +85,6 @@\n-     * Version for use by the default pool.  Supports setting the\n-     * context class loader.  This is a separate constructor to avoid\n-     * affecting the protected constructor.\n+     * Creates a ForkJoinWorkerThread operating in the given thread group and\n+     * pool.\n+     *\n+     * @param group if non-null, the thread group for this thread\n+     * @param pool the pool this thread works in\n+     * @throws NullPointerException if pool is null\n@@ -104,6 +92,2 @@\n-    ForkJoinWorkerThread(ForkJoinPool pool, ClassLoader ccl) {\n-        super(\"aForkJoinWorkerThread\");\n-        super.setContextClassLoader(ccl);\n-        ThreadLocalRandom.setInheritedAccessControlContext(this, INNOCUOUS_ACC);\n-        this.pool = pool;\n-        this.workQueue = pool.registerWorker(this);\n+    \/* TODO: protected *\/ ForkJoinWorkerThread(ThreadGroup group, ForkJoinPool pool) {\n+        this(group, pool, false, false);\n@@ -113,1 +97,4 @@\n-     * Version for InnocuousForkJoinWorkerThread.\n+     * Creates a ForkJoinWorkerThread operating in the given pool.\n+     *\n+     * @param pool the pool this thread works in\n+     * @throws NullPointerException if pool is null\n@@ -115,10 +102,2 @@\n-    ForkJoinWorkerThread(ForkJoinPool pool,\n-                         ClassLoader ccl,\n-                         ThreadGroup threadGroup,\n-                         AccessControlContext acc) {\n-        super(threadGroup, null, \"aForkJoinWorkerThread\");\n-        super.setContextClassLoader(ccl);\n-        ThreadLocalRandom.setInheritedAccessControlContext(this, acc);\n-        ThreadLocalRandom.eraseThreadLocals(this); \/\/ clear before registering\n-        this.pool = pool;\n-        this.workQueue = pool.registerWorker(this);\n+    protected ForkJoinWorkerThread(ForkJoinPool pool) {\n+        this(null, pool, false, false);\n@@ -179,2 +158,4 @@\n-        if (workQueue.array == null) { \/\/ only run once\n-            Throwable exception = null;\n+        Throwable exception = null;\n+        ForkJoinPool p = pool;\n+        ForkJoinPool.WorkQueue w = workQueue;\n+        if (p != null && w != null) {   \/\/ skip on failed initialization\n@@ -182,0 +163,1 @@\n+                p.registerWorker(w);\n@@ -183,1 +165,1 @@\n-                pool.runWorker(workQueue);\n+                p.runWorker(w);\n@@ -193,1 +175,1 @@\n-                    pool.deregisterWorker(this, exception);\n+                    p.deregisterWorker(this, exception);\n@@ -199,6 +181,0 @@\n-    \/**\n-     * Non-public hook method for InnocuousForkJoinWorkerThread.\n-     *\/\n-    void afterTopLevelExec() {\n-    }\n-\n@@ -224,9 +200,1 @@\n-            super(pool,\n-                  ClassLoader.getSystemClassLoader(),\n-                  innocuousThreadGroup,\n-                  INNOCUOUS_ACC);\n-        }\n-\n-        @Override \/\/ to erase ThreadLocals\n-        void afterTopLevelExec() {\n-            ThreadLocalRandom.eraseThreadLocals(this);\n+            super(innocuousThreadGroup, pool, true, true);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":34,"deletions":66,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng AsyncShutdownNow\n+ * @summary Test invoking shutdownNow with threads blocked in Future.get,\n+ *          invokeAll, and invokeAny\n+ *\/\n+\n+\/\/ TODO: this test is far too slow\n+\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class AsyncShutdownNow {\n+\n+    \/\/ long running interruptible task\n+    private static final Callable<Void> SLEEP_FOR_A_DAY = () -> {\n+        Thread.sleep(86400_000);\n+        return null;\n+    };\n+\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    @BeforeClass\n+    public void setup() {\n+        scheduledExecutor = Executors.newScheduledThreadPool(1);\n+    }\n+\n+    @AfterClass\n+    public void teardown() {\n+        scheduledExecutor.shutdown();\n+    }\n+\n+    \/**\n+     * Schedule the given executor service to be shutdown abruptly after the given\n+     * delay, in seconds.\n+     *\/\n+    private void scheduleShutdownNow(ExecutorService executor, int delayInSeconds) {\n+        scheduledExecutor.schedule(() -> {\n+            executor.shutdownNow();\n+            return null;\n+        }, delayInSeconds, TimeUnit.SECONDS);\n+    }\n+\n+    \/**\n+     * The executors to test.\n+     *\/\n+    @DataProvider(name = \"executors\")\n+    public Object[][] executors() {\n+        return new Object[][] {\n+                { new ForkJoinPool() },\n+                { new ForkJoinPool(1) },\n+        };\n+    }\n+\n+    \/**\n+     * Test shutdownNow with running task and thread blocked in Future::get.\n+     *\/\n+    @Test(dataProvider = \"executors\")\n+    public void testFutureGet(ExecutorService executor) throws Exception {\n+        System.out.format(\"testFutureGet: %s%n\", executor);\n+        scheduleShutdownNow(executor, 5);\n+        try {\n+            \/\/ submit long running task, the task should be cancelled\n+            Future<?> future = executor.submit(SLEEP_FOR_A_DAY);\n+            try {\n+                future.get();\n+                assertTrue(false);\n+            } catch (ExecutionException e) {\n+                \/\/ expected\n+            }\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdownNow with running task and thread blocked in a timed Future::get.\n+     *\/\n+    @Test(dataProvider = \"executors\")\n+    public void testTimedFutureGet(ExecutorService executor) throws Exception {\n+        System.out.format(\"testTimedFutureGet: %s%n\", executor);\n+        scheduleShutdownNow(executor, 5);\n+        try {\n+            \/\/ submit long running task, the task should be cancelled\n+            Future<?> future = executor.submit(SLEEP_FOR_A_DAY);\n+            try {\n+                future.get(1, TimeUnit.HOURS);\n+                assertTrue(false);\n+            } catch (ExecutionException e) {\n+                \/\/ expected\n+            }\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdownNow with thread blocked in invokeAll.\n+     *\/\n+    @Test(dataProvider = \"executors\")\n+    public void testInvokeAll(ExecutorService executor) throws Exception {\n+        System.out.format(\"testInvokeAll: %s%n\", executor);\n+        scheduleShutdownNow(executor, 5);\n+        try {\n+            \/\/ execute long running tasks\n+            List<Future<Void>> futures = executor.invokeAll(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n+            for (Future<Void> f : futures) {\n+                assertTrue(f.isDone());\n+                try {\n+                    Object result = f.get();\n+                    assertTrue(false);\n+                } catch (ExecutionException | CancellationException e) {\n+                    \/\/ expected\n+                }\n+            }\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdownNow with thread blocked in invokeAny.\n+     *\/\n+    @Test(dataProvider = \"executors\")\n+    public void testInvokeAny(ExecutorService executor) throws Exception {\n+        System.out.format(\"testInvokeAny: %s%n\", executor);\n+        scheduleShutdownNow(executor, 5);\n+        try {\n+            try {\n+                \/\/ execute long running tasks\n+                executor.invokeAny(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n+                assertTrue(false);\n+            } catch (ExecutionException e) {\n+                \/\/ expected\n+            }\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng AsyncShutdownNowInvokeAny\n+ * @summary A variant of AsyncShutdownNow useful for race bug hunting\n+ *\/\n+\n+\/\/ TODO: reorganize all of the AsyncShutdown tests\n+\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class AsyncShutdownNowInvokeAny {\n+\n+    \/\/ long running interruptible task\n+    private static final Callable<Void> SLEEP_FOR_A_DAY = () -> {\n+        Thread.sleep(86400_000);\n+        return null;\n+    };\n+\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    @BeforeClass\n+    public void setup() {\n+        scheduledExecutor = Executors.newScheduledThreadPool(1);\n+    }\n+\n+    @AfterClass\n+    public void teardown() {\n+        scheduledExecutor.shutdown();\n+    }\n+\n+    \/**\n+     * Schedule the given executor service to be shutdown abruptly after the given\n+     * delay, in seconds.\n+     *\/\n+    private void scheduleShutdownNow(ExecutorService executor, int delayInSeconds) {\n+        scheduledExecutor.schedule(() -> {\n+            executor.shutdownNow();\n+            return null;\n+        }, delayInSeconds, TimeUnit.SECONDS);\n+    }\n+\n+    \/**\n+     * Test shutdownNow with thread blocked in invokeAny.\n+     *\/\n+    @Test\n+    public void testInvokeAny() throws Exception {\n+        final int reps = 4;\n+        for (int rep = 1; rep < reps; rep++) {\n+            ExecutorService pool = new ForkJoinPool(1);\n+            scheduleShutdownNow(pool, 5);\n+            try {\n+                try {\n+                    \/\/ execute long running tasks\n+                    pool.invokeAny(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n+                    assertTrue(false);\n+                } catch (ExecutionException e) {\n+                    \/\/ expected\n+                }\n+            } finally {\n+                pool.shutdown();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/AsyncShutdownNowInvokeAny.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng AsyncShutdownNowInvokeAnyRace\n+ * @summary A variant of AsyncShutdownNow useful for race bug hunting\n+ *\/\n+\n+\/\/ TODO: reorganize all of the AsyncShutdown tests\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.LockInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class AsyncShutdownNowInvokeAnyRace {\n+\n+    \/\/ TODO: even more jitter-inducing parallelism?\n+\n+\/\/         int nThreads = ThreadLocalRandom.current().nextInt(1, 50);\n+\/\/         ExecutorService pool = Executors.newCachedThreadPool();\n+\/\/         Callable<Void> task = () -> { testInvokeAny_1(); return null; };\n+\/\/         List<Callable<Void>> tasks = Collections.nCopies(nThreads, task);\n+\/\/         try {\n+\/\/             for (Future<Void> future : pool.invokeAll(tasks)) {\n+\/\/                 future.get();\n+\/\/             }\n+\/\/         } finally {\n+\/\/             pool.shutdown();\n+\/\/         }\n+\/\/     }\n+\n+\/\/     public void testInvokeAny_1() throws Exception {\n+\n+    \/**\n+     * Test shutdownNow with thread blocked in invokeAny.\n+     *\/\n+    @Test\n+    public void testInvokeAny() throws Exception {\n+        final int reps = 30_000;\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+        int falseAlarms = 0;\n+        for (int rep = 1; rep < reps; rep++) {\n+            ForkJoinPool pool = new ForkJoinPool(1);\n+            CountDownLatch pleaseShutdownNow = new CountDownLatch(1);\n+            int nTasks = rnd.nextInt(2, 5);\n+            AtomicInteger threadsStarted = new AtomicInteger(0);\n+            AtomicReference<String> poolAtShutdownNow = new AtomicReference<>();\n+            Callable<Void> blockPool = () -> {\n+                threadsStarted.getAndIncrement();\n+                \/\/ await submission quiescence; may false-alarm\n+                \/\/ TODO: consider re-checking to reduce false alarms\n+                while (threadsStarted.get() + pool.getQueuedSubmissionCount() < nTasks)\n+                    Thread.yield();\n+                pleaseShutdownNow.countDown();\n+                Thread.sleep(86400_000);\n+                return null;\n+            };\n+            List<Callable<Void>> tasks = Collections.nCopies(nTasks, blockPool);\n+            Runnable shutdown = () -> {\n+                try {\n+                    pleaseShutdownNow.await();\n+                    poolAtShutdownNow.set(pool.toString());\n+                    pool.shutdownNow();\n+                } catch (Throwable t) { throw new AssertionError(t); }\n+            };\n+            Future<Void> shutdownResult = CompletableFuture.runAsync(shutdown);\n+            try {\n+                try {\n+                    if (rnd.nextBoolean())\n+                        pool.invokeAny(tasks, 10L, SECONDS);\n+                    else\n+                        pool.invokeAny(tasks);\n+                    throw new AssertionError(\"should throw\");\n+                } catch (RejectedExecutionException re) {\n+                    falseAlarms++;\n+                } catch (CancellationException re) {\n+                } catch (ExecutionException ex) {\n+                    Throwable cause = ex.getCause();\n+                    if (!(cause instanceof InterruptedException) &&\n+                        !(cause instanceof CancellationException))\n+                        throw ex;\n+                } catch (TimeoutException ex) {\n+                    dumpTestThreads();\n+                    int i = rep;\n+                    String detail = String.format(\n+                        \"invokeAny timed out, \"\n+                        + \"nTasks=%d rep=%d threadsStarted=%d%n\"\n+                        + \"poolAtShutdownNow=%s%n\"\n+                        + \"poolAtTimeout=%s%n\"\n+                        + \"queuedTaskCount=%d queuedSubmissionCount=%d\",\n+                        nTasks, i, threadsStarted.get(),\n+                        poolAtShutdownNow,\n+                        pool,\n+                        pool.getQueuedTaskCount(),\n+                        pool.getQueuedSubmissionCount());\n+                    throw new AssertionError(detail, ex);\n+                }\n+            } finally {\n+                pool.shutdown();\n+            }\n+            if (falseAlarms != 0)\n+                System.out.println(\"Premature shutdowns = \" + falseAlarms);\n+            shutdownResult.get();\n+        }\n+    }\n+\n+    \/\/--- thread stack dumping (from JSR166TestCase.java) ---\n+\n+    private static final ThreadMXBean THREAD_MXBEAN\n+        = ManagementFactory.getThreadMXBean();\n+\n+    \/** Returns true if thread info might be useful in a thread dump. *\/\n+    static boolean threadOfInterest(ThreadInfo info) {\n+        final String name = info.getThreadName();\n+        String lockName;\n+        if (name == null)\n+            return true;\n+        if (name.equals(\"Signal Dispatcher\")\n+            || name.equals(\"WedgedTestDetector\"))\n+            return false;\n+        if (name.equals(\"Reference Handler\")) {\n+            \/\/ Reference Handler stacktrace changed in JDK-8156500\n+            StackTraceElement[] stackTrace; String methodName;\n+            if ((stackTrace = info.getStackTrace()) != null\n+                && stackTrace.length > 0\n+                && (methodName = stackTrace[0].getMethodName()) != null\n+                && methodName.equals(\"waitForReferencePendingList\"))\n+                return false;\n+            \/\/ jdk8 Reference Handler stacktrace\n+            if ((lockName = info.getLockName()) != null\n+                && lockName.startsWith(\"java.lang.ref\"))\n+                return false;\n+        }\n+        if ((name.equals(\"Finalizer\") || name.equals(\"Common-Cleaner\"))\n+            && (lockName = info.getLockName()) != null\n+            && lockName.startsWith(\"java.lang.ref\"))\n+            return false;\n+        if (name.startsWith(\"ForkJoinPool.commonPool-worker\")\n+            && (lockName = info.getLockName()) != null\n+            && lockName.startsWith(\"java.util.concurrent.ForkJoinPool\"))\n+            return false;\n+        return true;\n+    }\n+\n+    \/**\n+     * A debugging tool to print stack traces of most threads, as jstack does.\n+     * Uninteresting threads are filtered out.\n+     *\/\n+    static void dumpTestThreads() {\n+        System.err.println(\"------ stacktrace dump start ------\");\n+        for (ThreadInfo info : THREAD_MXBEAN.dumpAllThreads(true, true))\n+            if (threadOfInterest(info))\n+                System.err.print(info);\n+        System.err.println(\"------ stacktrace dump end ------\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/AsyncShutdownNowInvokeAnyRace.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * This file is available under and governed by the GNU General Public\n- * License version 2 only, as published by the Free Software Foundation.\n- * However, the following notice accompanied the original version of this\n- * file:\n- *\n- * Written by Doug Lea and Martin Buchholz with assistance from\n- * members of JCP JSR-166 Expert Group and released to the public\n- * domain, as explained at\n- * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8004138 8205576\n- * @modules java.base\/java.util.concurrent:open\n- * @run testng FJExceptionTableLeak\n- * @summary Checks that ForkJoinTask thrown exceptions are not leaked.\n- * This whitebox test is sensitive to forkjoin implementation details.\n- *\/\n-\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n-\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ForkJoinPool;\n-import java.util.concurrent.ForkJoinTask;\n-import java.util.concurrent.RecursiveAction;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.function.BooleanSupplier;\n-\n-@Test\n-public class FJExceptionTableLeak {\n-    final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n-    final VarHandle NEXT, EX;\n-    final Object[] exceptionTable;\n-    final ReentrantLock exceptionTableLock;\n-\n-    FJExceptionTableLeak() throws ReflectiveOperationException {\n-        MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(\n-            ForkJoinTask.class, MethodHandles.lookup());\n-        Class<?> nodeClass = Class.forName(\n-            ForkJoinTask.class.getName() + \"$ExceptionNode\");\n-        VarHandle exceptionTableHandle = lookup.findStaticVarHandle(\n-            ForkJoinTask.class, \"exceptionTable\", arrayClass(nodeClass));\n-        VarHandle exceptionTableLockHandle = lookup.findStaticVarHandle(\n-            ForkJoinTask.class, \"exceptionTableLock\", ReentrantLock.class);\n-        exceptionTable = (Object[]) exceptionTableHandle.get();\n-        exceptionTableLock = (ReentrantLock) exceptionTableLockHandle.get();\n-\n-        NEXT = lookup.findVarHandle(nodeClass, \"next\", nodeClass);\n-        EX = lookup.findVarHandle(nodeClass, \"ex\", Throwable.class);\n-    }\n-\n-    static <T> Class<T[]> arrayClass(Class<T> klazz) {\n-        try {\n-            return (Class<T[]>) Class.forName(\"[L\" + klazz.getName() + \";\");\n-        } catch (ReflectiveOperationException ex) {\n-            throw new Error(ex);\n-        }\n-    }\n-\n-    Object next(Object node) { return NEXT.get(node); }\n-    Throwable ex(Object node) { return (Throwable) EX.get(node); }\n-\n-    static class FailingTaskException extends RuntimeException {}\n-    static class FailingTask extends RecursiveAction {\n-        public void compute() { throw new FailingTaskException(); }\n-    }\n-\n-    \/** Counts all FailingTaskExceptions still recorded in exceptionTable. *\/\n-    int retainedExceptions() {\n-        exceptionTableLock.lock();\n-        try {\n-            int count = 0;\n-            for (Object node : exceptionTable)\n-                for (; node != null; node = next(node))\n-                    if (ex(node) instanceof FailingTaskException)\n-                        count++;\n-            return count;\n-        } finally {\n-            exceptionTableLock.unlock();\n-        }\n-    }\n-\n-    @Test\n-    public void exceptionTableCleanup() throws Exception {\n-        ArrayList<FailingTask> failedTasks = failedTasks();\n-\n-        \/\/ Retain a strong ref to one last failing task\n-        FailingTask lastTask = failedTasks.get(rnd.nextInt(failedTasks.size()));\n-\n-        \/\/ Clear all other strong refs, making exception table cleanable\n-        failedTasks.clear();\n-\n-        BooleanSupplier exceptionTableIsClean = () -> {\n-            try {\n-                \/\/ Trigger exception table expunging as side effect\n-                lastTask.join();\n-                throw new AssertionError(\"should throw\");\n-            } catch (FailingTaskException expected) {}\n-            int count = retainedExceptions();\n-            if (count == 0)\n-                throw new AssertionError(\"expected to find last task\");\n-            return count == 1;\n-        };\n-        gcAwait(exceptionTableIsClean);\n-    }\n-\n-    \/** Sequestered into a separate method to inhibit GC retention. *\/\n-    ArrayList<FailingTask> failedTasks()\n-        throws Exception {\n-        final ForkJoinPool pool = new ForkJoinPool(rnd.nextInt(1, 4));\n-\n-        assertEquals(0, retainedExceptions());\n-\n-        final ArrayList<FailingTask> tasks = new ArrayList<>();\n-\n-        for (int i = exceptionTable.length; i--> 0; ) {\n-            FailingTask task = new FailingTask();\n-            pool.execute(task);\n-            tasks.add(task); \/\/ retain strong refs to all tasks, for now\n-            task = null;     \/\/ excessive GC retention paranoia\n-        }\n-        for (FailingTask task : tasks) {\n-            try {\n-                task.join();\n-                throw new AssertionError(\"should throw\");\n-            } catch (FailingTaskException success) {}\n-            task = null;     \/\/ excessive GC retention paranoia\n-        }\n-\n-        if (rnd.nextBoolean())\n-            gcAwait(() -> retainedExceptions() == tasks.size());\n-\n-        return tasks;\n-    }\n-\n-    \/\/ --------------- GC finalization infrastructure ---------------\n-\n-    \/** No guarantees, but effective in practice. *\/\n-    static void forceFullGc() {\n-        long timeoutMillis = 1000L;\n-        CountDownLatch finalized = new CountDownLatch(1);\n-        ReferenceQueue<Object> queue = new ReferenceQueue<>();\n-        WeakReference<Object> ref = new WeakReference<>(\n-            new Object() { protected void finalize() { finalized.countDown(); }},\n-            queue);\n-        try {\n-            for (int tries = 3; tries--> 0; ) {\n-                System.gc();\n-                if (finalized.await(timeoutMillis, MILLISECONDS)\n-                    && queue.remove(timeoutMillis) != null\n-                    && ref.get() == null) {\n-                    System.runFinalization(); \/\/ try to pick up stragglers\n-                    return;\n-                }\n-                timeoutMillis *= 4;\n-            }\n-        } catch (InterruptedException unexpected) {\n-            throw new AssertionError(\"unexpected InterruptedException\");\n-        }\n-        throw new AssertionError(\"failed to do a \\\"full\\\" gc\");\n-    }\n-\n-    static void gcAwait(BooleanSupplier s) {\n-        for (int i = 0; i < 10; i++) {\n-            if (s.getAsBoolean())\n-                return;\n-            forceFullGc();\n-        }\n-        throw new AssertionError(\"failed to satisfy condition\");\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/FJExceptionTableLeak.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -1723,0 +1723,16 @@\n+\n+    \/\/ adaptInterruptible deferred to its own independent change\n+    \/\/ https:\/\/bugs.openjdk.java.net\/browse\/JDK-8246587\n+\n+\/\/     \/**\n+\/\/      * adaptInterruptible(callable).toString() contains toString of wrapped task\n+\/\/      *\/\n+\/\/     public void testAdaptInterruptible_Callable_toString() {\n+\/\/         if (testImplementationDetails) {\n+\/\/             Callable<String> c = () -> \"\";\n+\/\/             ForkJoinTask<String> task = ForkJoinTask.adaptInterruptible(c);\n+\/\/             assertEquals(\n+\/\/                 identityString(task) + \"[Wrapped task = \" + c.toString() + \"]\",\n+\/\/                 task.toString());\n+\/\/         }\n+\/\/     }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinTaskTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}