{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+import java.time.chrono.ChronoZonedDateTime;\n@@ -376,1 +377,1 @@\n- * pattern letter is 'z' the output is the daylight savings aware zone name.\n+ * pattern letter is 'z' the output is the daylight saving aware zone name.\n@@ -378,1 +379,1 @@\n- * the name ignoring daylight savings time will be used.\n+ * the name ignoring daylight saving time will be used.\n@@ -384,1 +385,1 @@\n- * daylight savings time. If the count of letters is one, then the short name is output.\n+ * daylight saving time. If the count of letters is one, then the short name is output.\n@@ -505,1 +506,4 @@\n- * of {@link ChronoLocalDateTime#atZone(ZoneId)}.\n+ * of {@link ChronoLocalDateTime#atZone(ZoneId)}. If the {@code ZoneId} was\n+ * parsed from a zone name that indicates whether daylight saving time is in\n+ * operation or not, then that fact will be used to select the correct offset\n+ * at the local time-line overlap.\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4327,3 +4327,4 @@\n-        private static final int STD = 0;\n-        private static final int DST = 1;\n-        private static final int GENERIC = 2;\n+        static final int UNDEFINED = -1;\n+        static final int STD = 0;\n+        static final int DST = 1;\n+        static final int GENERIC = 2;\n@@ -4436,1 +4437,1 @@\n-                    tree.add(zid, zid);    \/\/ don't convert zid -> metazone\n+                    tree.add(zid, zid, UNDEFINED);    \/\/ don't convert zid -> metazone\n@@ -4440,1 +4441,1 @@\n-                        tree.add(names[i], zid);\n+                        tree.add(names[i], zid, (i - 1) \/ 2);\n@@ -4453,1 +4454,1 @@\n-                                t.add(cidNames[i], cid);\n+                                t.add(cidNames[i], cid, (i - 1) \/ 2);\n@@ -4468,1 +4469,1 @@\n-                            tree.add(names[i], zid);\n+                            tree.add(names[i], zid, (i - 1) \/ 2);\n@@ -4574,2 +4575,2 @@\n-            String parsedZoneId = tree.match(text, ppos);\n-            if (parsedZoneId == null) {\n+            PrefixTree parsedZoneId = tree.match(text, ppos);\n+            if (parsedZoneId.value == null) {\n@@ -4582,1 +4583,2 @@\n-            context.setParsed(ZoneId.of(parsedZoneId));\n+            context.setParsed(ZoneId.of(parsedZoneId.value));\n+            context.setParsedZoneNameType(parsedZoneId.type);\n@@ -4644,0 +4646,1 @@\n+        protected int type;\n@@ -4649,1 +4652,1 @@\n-        private PrefixTree(String k, String v, PrefixTree child) {\n+        private PrefixTree(String k, String v, int type, PrefixTree child) {\n@@ -4652,0 +4655,1 @@\n+            this.type = type;\n@@ -4667,3 +4671,0 @@\n-            \/\/if (!context.isStrict()) {\n-            \/\/    return new LENIENT(\"\", null, null);\n-            \/\/}\n@@ -4671,1 +4672,1 @@\n-                return new PrefixTree(\"\", null, null);\n+                return new PrefixTree(\"\", null, ZoneTextPrinterParser.UNDEFINED, null);\n@@ -4673,1 +4674,1 @@\n-            return new CI(\"\", null, null);\n+            return new CI(\"\", null, ZoneTextPrinterParser.UNDEFINED, null);\n@@ -4686,1 +4687,1 @@\n-                tree.add0(k, k);\n+                tree.add0(k, k, ZoneTextPrinterParser.UNDEFINED);\n@@ -4695,1 +4696,1 @@\n-            PrefixTree copy = new PrefixTree(key, value, null);\n+            PrefixTree copy = new PrefixTree(key, value, type, null);\n@@ -4713,2 +4714,2 @@\n-        public boolean add(String k, String v) {\n-            return add0(k, v);\n+        public boolean add(String k, String v, int t) {\n+            return add0(k, v, t);\n@@ -4717,1 +4718,1 @@\n-        private boolean add0(String k, String v) {\n+        private boolean add0(String k, String v, int t) {\n@@ -4726,1 +4727,1 @@\n-                            return c.add0(subKey, v);\n+                            return c.add0(subKey, v, t);\n@@ -4731,1 +4732,1 @@\n-                    c = newNode(subKey, v, null);\n+                    c = newNode(subKey, v, t, null);\n@@ -4741,0 +4742,1 @@\n+                type = t;\n@@ -4744,1 +4746,1 @@\n-            PrefixTree n1 = newNode(key.substring(prefixLen), value, child);\n+            PrefixTree n1 = newNode(key.substring(prefixLen), value, type, child);\n@@ -4748,1 +4750,1 @@\n-                PrefixTree n2 = newNode(k.substring(prefixLen), v, null);\n+                PrefixTree n2 = newNode(k.substring(prefixLen), v, t, null);\n@@ -4753,0 +4755,1 @@\n+                type = t;\n@@ -4763,1 +4766,1 @@\n-         * @return the resulting string, or null if no match found.\n+         * @return the resulting tree, or null if no match found.\n@@ -4765,1 +4768,1 @@\n-        public String match(CharSequence text, int off, int end) {\n+        public PrefixTree match(CharSequence text, int off, int end) {\n@@ -4773,1 +4776,1 @@\n-                        String found = c.match(text, off, end);\n+                        PrefixTree found = c.match(text, off, end);\n@@ -4777,1 +4780,1 @@\n-                        return value;\n+                        return this;\n@@ -4782,1 +4785,1 @@\n-            return value;\n+            return this;\n@@ -4792,1 +4795,1 @@\n-         * @return the resulting string, or null if no match found.\n+         * @return the resulting tree, or null if no match found.\n@@ -4794,1 +4797,1 @@\n-        public String match(CharSequence text, ParsePosition pos) {\n+        public PrefixTree match(CharSequence text, ParsePosition pos) {\n@@ -4806,1 +4809,1 @@\n-                        String found = c.match(text, pos);\n+                        PrefixTree found = c.match(text, pos);\n@@ -4816,1 +4819,1 @@\n-            return value;\n+            return this;\n@@ -4823,2 +4826,2 @@\n-        protected PrefixTree newNode(String k, String v, PrefixTree child) {\n-            return new PrefixTree(k, v, child);\n+        protected PrefixTree newNode(String k, String v, int t, PrefixTree child) {\n+            return new PrefixTree(k, v, t, child);\n@@ -4864,2 +4867,2 @@\n-            private CI(String k, String v, PrefixTree child) {\n-                super(k, v, child);\n+            private CI(String k, String v, int t, PrefixTree child) {\n+                super(k, v, t, child);\n@@ -4869,2 +4872,2 @@\n-            protected CI newNode(String k, String v, PrefixTree child) {\n-                return new CI(k, v, child);\n+            protected CI newNode(String k, String v, int t, PrefixTree child) {\n+                return new CI(k, v, t, child);\n@@ -4893,80 +4896,0 @@\n-\n-        \/**\n-         * Lenient prefix tree. Case insensitive and ignores characters\n-         * like space, underscore and slash.\n-         *\/\n-        private static class LENIENT extends CI {\n-\n-            private LENIENT(String k, String v, PrefixTree child) {\n-                super(k, v, child);\n-            }\n-\n-            @Override\n-            protected CI newNode(String k, String v, PrefixTree child) {\n-                return new LENIENT(k, v, child);\n-            }\n-\n-            private boolean isLenientChar(char c) {\n-                return c == ' ' || c == '_' || c == '\/';\n-            }\n-\n-            protected String toKey(String k) {\n-                for (int i = 0; i < k.length(); i++) {\n-                    if (isLenientChar(k.charAt(i))) {\n-                        StringBuilder sb = new StringBuilder(k.length());\n-                        sb.append(k, 0, i);\n-                        i++;\n-                        while (i < k.length()) {\n-                            if (!isLenientChar(k.charAt(i))) {\n-                                sb.append(k.charAt(i));\n-                            }\n-                            i++;\n-                        }\n-                        return sb.toString();\n-                    }\n-                }\n-                return k;\n-            }\n-\n-            @Override\n-            public String match(CharSequence text, ParsePosition pos) {\n-                int off = pos.getIndex();\n-                int end = text.length();\n-                int len = key.length();\n-                int koff = 0;\n-                while (koff < len && off < end) {\n-                    if (isLenientChar(text.charAt(off))) {\n-                        off++;\n-                        continue;\n-                    }\n-                    if (!isEqual(key.charAt(koff++), text.charAt(off++))) {\n-                        return null;\n-                    }\n-                }\n-                if (koff != len) {\n-                    return null;\n-                }\n-                if (child != null && off != end) {\n-                    int off0 = off;\n-                    while (off0 < end && isLenientChar(text.charAt(off0))) {\n-                        off0++;\n-                    }\n-                    if (off0 < end) {\n-                        PrefixTree c = child;\n-                        do {\n-                            if (isEqual(c.c0, text.charAt(off0))) {\n-                                pos.setIndex(off0);\n-                                String found = c.match(text, pos);\n-                                if (found != null) {\n-                                    return found;\n-                                }\n-                                break;\n-                            }\n-                            c = c.sibling;\n-                        } while (c != null);\n-                    }\n-                }\n-                pos.setIndex(off);\n-                return value;\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":43,"deletions":120,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,0 +420,18 @@\n+    \/**\n+     * Stores the parsed zone name type.\n+     * <p>\n+     * This stores the zone name type that has been parsed.\n+     * The parsed type should either be;\n+     * <ul>\n+     *     <li>{@link DateTimeFormatterBuilder.ZoneTextPrinterParser#UNDEFINED}<\/li>\n+     *     <li>{@link DateTimeFormatterBuilder.ZoneTextPrinterParser#STD}<\/li>\n+     *     <li>{@link DateTimeFormatterBuilder.ZoneTextPrinterParser#DST}<\/li>\n+     *     <li>{@link DateTimeFormatterBuilder.ZoneTextPrinterParser#GENERIC}<\/li>\n+     * <\/ul>\n+     *\n+     * @param type  the parsed zone name type\n+     *\/\n+    void setParsedZoneNameType(int type) {\n+        currentParsed().zoneNameType = type;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeParseContext.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+import java.time.ZonedDateTime;\n@@ -135,0 +136,4 @@\n+    \/**\n+     * The parsed zone name type.\n+     *\/\n+    int zoneNameType = DateTimeFormatterBuilder.ZoneTextPrinterParser.UNDEFINED;\n@@ -178,0 +183,1 @@\n+        cloned.zoneNameType = this.zoneNameType;\n@@ -655,2 +661,6 @@\n-                    long instant = date.atTime(time).atZone(zone).toEpochSecond();\n-                    fieldValues.put(INSTANT_SECONDS, instant);\n+                    var czdt = date.atTime(time).atZone(zone);\n+                    if (zoneNameType == DateTimeFormatterBuilder.ZoneTextPrinterParser.STD ||\n+                        zoneNameType == DateTimeFormatterBuilder.ZoneTextPrinterParser.GENERIC) {\n+                        czdt = czdt.withLaterOffsetAtOverlap();\n+                    }\n+                    fieldValues.put(INSTANT_SECONDS, czdt.toEpochSecond());\n@@ -721,0 +731,1 @@\n+            buf.append(',').append(zoneNameType);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/Parsed.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import static org.testng.Assert.fail;\n@@ -31,0 +32,1 @@\n+import java.time.format.DateTimeParseException;\n@@ -52,1 +54,1 @@\n- * @bug 8081022 8151876 8166875 8189784 8206980\n+ * @bug 8081022 8151876 8166875 8177819 8189784 8206980 8277049\n@@ -239,0 +241,33 @@\n+    @DataProvider(name=\"roundTripAtOverlap\")\n+    Object[][] data_roundTripAtOverlap() {\n+        return new Object[][] {\n+            {\"yyyy-MM-dd HH:mm:ss.SSS z\",       \"2021-10-31 02:30:00.000 CET\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS z\",       \"2021-10-31 02:30:00.000 CEST\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS z\",       \"2021-11-07 01:30:00.000 EST\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS z\",       \"2021-11-07 01:30:00.000 EDT\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS zzzz\",    \"2021-10-31 02:30:00.000 Central European Standard Time\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS zzzz\",    \"2021-10-31 02:30:00.000 Central European Summer Time\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS zzzz\",    \"2021-11-07 01:30:00.000 Eastern Standard Time\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS zzzz\",    \"2021-11-07 01:30:00.000 Eastern Daylight Time\"},\n+\n+            {\"yyyy-MM-dd HH:mm:ss.SSS v\",       \"2021-10-31 02:30:00.000 CET\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS v\",       \"2021-11-07 01:30:00.000 ET\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS vvvv\",    \"2021-10-31 02:30:00.000 Central European Time\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS vvvv\",    \"2021-11-07 01:30:00.000 Eastern Time\"},\n+        };\n+    }\n+\n+    @Test(dataProvider=\"roundTripAtOverlap\")\n+    public void test_roundTripAtOverlap(String pattern, String input) {\n+        var dtf = DateTimeFormatter.ofPattern(pattern);\n+        assertEquals(dtf.format(ZonedDateTime.parse(input, dtf)), input);\n+        var lc = input.toLowerCase(Locale.ROOT);\n+        try {\n+            ZonedDateTime.parse(lc, dtf);\n+            fail(\"Should throw DateTimeParseException\");\n+        } catch (DateTimeParseException ignore) {}\n+\n+        dtf = new DateTimeFormatterBuilder().parseCaseInsensitive().appendPattern(pattern).toFormatter();\n+        assertEquals(dtf.format(ZonedDateTime.parse(input, dtf)), input);\n+        assertEquals(dtf.format(ZonedDateTime.parse(lc, dtf)), input);\n+    }\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestZoneTextPrinterParser.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"}]}