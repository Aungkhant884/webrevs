{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+import java.time.chrono.ChronoZonedDateTime;\n@@ -376,1 +377,1 @@\n- * pattern letter is 'z' the output is the daylight savings aware zone name.\n+ * pattern letter is 'z' the output is the daylight saving aware zone name.\n@@ -378,1 +379,1 @@\n- * the name ignoring daylight savings time will be used.\n+ * the name ignoring daylight saving time will be used.\n@@ -384,1 +385,1 @@\n- * daylight savings time. If the count of letters is one, then the short name is output.\n+ * daylight saving time. If the count of letters is one, then the short name is output.\n@@ -505,1 +506,4 @@\n- * of {@link ChronoLocalDateTime#atZone(ZoneId)}.\n+ * of {@link ChronoLocalDateTime#atZone(ZoneId)}. If the {@code ZoneId} is\n+ * parsed from the zone name which is not daylight saving aware, then\n+ * {@link ChronoZonedDateTime#withLaterOffsetAtOverlap()} is issued\n+ * before forming the instant.\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4436,1 +4436,1 @@\n-                    tree.add(zid, zid);    \/\/ don't convert zid -> metazone\n+                    tree.add(zid, zid, -1);    \/\/ don't convert zid -> metazone\n@@ -4440,1 +4440,1 @@\n-                        tree.add(names[i], zid);\n+                        tree.add(names[i], zid, (i - 1) \/ 2);\n@@ -4453,1 +4453,1 @@\n-                                t.add(cidNames[i], cid);\n+                                t.add(cidNames[i], cid, (i - 1) \/ 2);\n@@ -4468,1 +4468,1 @@\n-                            tree.add(names[i], zid);\n+                            tree.add(names[i], zid, (i - 1) \/ 2);\n@@ -4574,2 +4574,2 @@\n-            String parsedZoneId = tree.match(text, ppos);\n-            if (parsedZoneId == null) {\n+            PrefixTree parsedZoneId = tree.match(text, ppos);\n+            if (parsedZoneId.value == null) {\n@@ -4582,1 +4582,2 @@\n-            context.setParsed(ZoneId.of(parsedZoneId));\n+            context.setParsed(ZoneId.of(parsedZoneId.value));\n+            context.setParsedZoneNameType(parsedZoneId.type);\n@@ -4644,0 +4645,1 @@\n+        protected int type;\n@@ -4649,1 +4651,1 @@\n-        private PrefixTree(String k, String v, PrefixTree child) {\n+        private PrefixTree(String k, String v, int type, PrefixTree child) {\n@@ -4652,0 +4654,1 @@\n+            this.type = type;\n@@ -4671,1 +4674,1 @@\n-                return new PrefixTree(\"\", null, null);\n+                return new PrefixTree(\"\", null, -1, null);\n@@ -4673,1 +4676,1 @@\n-            return new CI(\"\", null, null);\n+            return new CI(\"\", null, -1, null);\n@@ -4686,1 +4689,1 @@\n-                tree.add0(k, k);\n+                tree.add0(k, k, -1);\n@@ -4695,1 +4698,1 @@\n-            PrefixTree copy = new PrefixTree(key, value, null);\n+            PrefixTree copy = new PrefixTree(key, value, type, null);\n@@ -4713,2 +4716,2 @@\n-        public boolean add(String k, String v) {\n-            return add0(k, v);\n+        public boolean add(String k, String v, int t) {\n+            return add0(k, v, t);\n@@ -4717,1 +4720,1 @@\n-        private boolean add0(String k, String v) {\n+        private boolean add0(String k, String v, int t) {\n@@ -4726,1 +4729,1 @@\n-                            return c.add0(subKey, v);\n+                            return c.add0(subKey, v, t);\n@@ -4731,1 +4734,1 @@\n-                    c = newNode(subKey, v, null);\n+                    c = newNode(subKey, v, t, null);\n@@ -4741,0 +4744,1 @@\n+                type = t;\n@@ -4744,1 +4748,1 @@\n-            PrefixTree n1 = newNode(key.substring(prefixLen), value, child);\n+            PrefixTree n1 = newNode(key.substring(prefixLen), value, type, child);\n@@ -4748,1 +4752,1 @@\n-                PrefixTree n2 = newNode(k.substring(prefixLen), v, null);\n+                PrefixTree n2 = newNode(k.substring(prefixLen), v, t, null);\n@@ -4753,0 +4757,1 @@\n+                type = t;\n@@ -4763,1 +4768,1 @@\n-         * @return the resulting string, or null if no match found.\n+         * @return the resulting tree, or null if no match found.\n@@ -4765,1 +4770,1 @@\n-        public String match(CharSequence text, int off, int end) {\n+        public PrefixTree match(CharSequence text, int off, int end) {\n@@ -4773,1 +4778,1 @@\n-                        String found = c.match(text, off, end);\n+                        PrefixTree found = c.match(text, off, end);\n@@ -4777,1 +4782,1 @@\n-                        return value;\n+                        return this;\n@@ -4782,1 +4787,1 @@\n-            return value;\n+            return this;\n@@ -4792,1 +4797,1 @@\n-         * @return the resulting string, or null if no match found.\n+         * @return the resulting tree, or null if no match found.\n@@ -4794,1 +4799,1 @@\n-        public String match(CharSequence text, ParsePosition pos) {\n+        public PrefixTree match(CharSequence text, ParsePosition pos) {\n@@ -4806,1 +4811,1 @@\n-                        String found = c.match(text, pos);\n+                        PrefixTree found = c.match(text, pos);\n@@ -4816,1 +4821,1 @@\n-            return value;\n+            return this;\n@@ -4823,2 +4828,2 @@\n-        protected PrefixTree newNode(String k, String v, PrefixTree child) {\n-            return new PrefixTree(k, v, child);\n+        protected PrefixTree newNode(String k, String v, int t, PrefixTree child) {\n+            return new PrefixTree(k, v, t, child);\n@@ -4864,2 +4869,2 @@\n-            private CI(String k, String v, PrefixTree child) {\n-                super(k, v, child);\n+            private CI(String k, String v, int t, PrefixTree child) {\n+                super(k, v, t, child);\n@@ -4869,2 +4874,2 @@\n-            protected CI newNode(String k, String v, PrefixTree child) {\n-                return new CI(k, v, child);\n+            protected CI newNode(String k, String v, int t, PrefixTree child) {\n+                return new CI(k, v, t, child);\n@@ -4900,2 +4905,2 @@\n-            private LENIENT(String k, String v, PrefixTree child) {\n-                super(k, v, child);\n+            private LENIENT(String k, String v, int t, PrefixTree child) {\n+                super(k, v, t, child);\n@@ -4905,2 +4910,2 @@\n-            protected CI newNode(String k, String v, PrefixTree child) {\n-                return new LENIENT(k, v, child);\n+            protected CI newNode(String k, String v, int t, PrefixTree child) {\n+                return new LENIENT(k, v, t, child);\n@@ -4932,1 +4937,1 @@\n-            public String match(CharSequence text, ParsePosition pos) {\n+            public PrefixTree match(CharSequence text, ParsePosition pos) {\n@@ -4959,1 +4964,1 @@\n-                                String found = c.match(text, pos);\n+                                PrefixTree found = c.match(text, pos);\n@@ -4970,1 +4975,1 @@\n-                return value;\n+                return this;\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":46,"deletions":41,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,0 +420,18 @@\n+    \/**\n+     * Stores the parsed zone name type.\n+     * <p>\n+     * This stores the zone name type that has been parsed.\n+     * The parsed type should either be;\n+     * <ul>\n+     *     <li>Undefined: -1<\/li>\n+     *     <li>Standard: 0<\/li>\n+     *     <li>Daylight Saving: 1<\/li>\n+     *     <li>Generic: 2<\/li>\n+     * <\/ul>\n+     *\n+     * @param type  the parsed zone name type\n+     *\/\n+    void setParsedZoneNameType(int type) {\n+        currentParsed().zoneNameType = type;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeParseContext.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+import java.time.ZonedDateTime;\n@@ -135,0 +136,4 @@\n+    \/**\n+     * The parsed zone name type.\n+     *\/\n+    int zoneNameType = -1;\n@@ -178,0 +183,1 @@\n+        cloned.zoneNameType = this.zoneNameType;\n@@ -655,2 +661,5 @@\n-                    long instant = date.atTime(time).atZone(zone).toEpochSecond();\n-                    fieldValues.put(INSTANT_SECONDS, instant);\n+                    var czdt = date.atTime(time).atZone(zone);\n+                    if (zoneNameType == 0 || zoneNameType == 2) { \/\/ std or generic\n+                        czdt = czdt.withLaterOffsetAtOverlap();\n+                    }\n+                    fieldValues.put(INSTANT_SECONDS, czdt.toEpochSecond());\n@@ -721,0 +730,1 @@\n+            buf.append(',').append(zoneNameType);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/Parsed.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n- * @bug 8081022 8151876 8166875 8189784 8206980\n+ * @bug 8081022 8151876 8166875 8177819 8189784 8206980 8277049\n@@ -239,0 +239,24 @@\n+    @DataProvider(name=\"roundTripAtOverlap\")\n+    Object[][] data_roundTripAtOverlap() {\n+        return new Object[][] {\n+            {\"yyyy-MM-dd HH:mm:ss.SSS z\",       \"2021-10-31 02:30:00.000 CET\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS z\",       \"2021-10-31 02:30:00.000 CEST\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS z\",       \"2021-11-07 01:30:00.000 EST\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS z\",       \"2021-11-07 01:30:00.000 EDT\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS zzzz\",    \"2021-10-31 02:30:00.000 Central European Standard Time\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS zzzz\",    \"2021-10-31 02:30:00.000 Central European Summer Time\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS zzzz\",    \"2021-11-07 01:30:00.000 Eastern Standard Time\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS zzzz\",    \"2021-11-07 01:30:00.000 Eastern Daylight Time\"},\n+\n+            {\"yyyy-MM-dd HH:mm:ss.SSS v\",       \"2021-10-31 02:30:00.000 CET\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS v\",       \"2021-11-07 01:30:00.000 ET\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS vvvv\",    \"2021-10-31 02:30:00.000 Central European Time\"},\n+            {\"yyyy-MM-dd HH:mm:ss.SSS vvvv\",    \"2021-11-07 01:30:00.000 Eastern Time\"},\n+        };\n+    }\n+\n+    @Test(dataProvider=\"roundTripAtOverlap\")\n+    public void test_roundTripAtOverlap(String pattern, String input) {\n+        var dtf = DateTimeFormatter.ofPattern(pattern);\n+        assertEquals(dtf.format(ZonedDateTime.parse(input, dtf)), input);\n+    }\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestZoneTextPrinterParser.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"}]}