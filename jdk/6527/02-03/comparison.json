{"files":[{"patch":"@@ -507,2 +507,3 @@\n- * parsed from the zone name that does not indicate daylight saving time, then\n- * the standard offset will be used at the local time-line overlap.\n+ * parsed from a zone name that indicates whether daylight saving time is in\n+ * operation or not, then that fact will be used to select the correct offset\n+ * at the local time-line overlap.\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4671,3 +4671,0 @@\n-            \/\/if (!context.isStrict()) {\n-            \/\/    return new LENIENT(\"\", null, null);\n-            \/\/}\n@@ -4899,80 +4896,0 @@\n-\n-        \/**\n-         * Lenient prefix tree. Case insensitive and ignores characters\n-         * like space, underscore and slash.\n-         *\/\n-        private static class LENIENT extends CI {\n-\n-            private LENIENT(String k, String v, int t, PrefixTree child) {\n-                super(k, v, t, child);\n-            }\n-\n-            @Override\n-            protected CI newNode(String k, String v, int t, PrefixTree child) {\n-                return new LENIENT(k, v, t, child);\n-            }\n-\n-            private boolean isLenientChar(char c) {\n-                return c == ' ' || c == '_' || c == '\/';\n-            }\n-\n-            protected String toKey(String k) {\n-                for (int i = 0; i < k.length(); i++) {\n-                    if (isLenientChar(k.charAt(i))) {\n-                        StringBuilder sb = new StringBuilder(k.length());\n-                        sb.append(k, 0, i);\n-                        i++;\n-                        while (i < k.length()) {\n-                            if (!isLenientChar(k.charAt(i))) {\n-                                sb.append(k.charAt(i));\n-                            }\n-                            i++;\n-                        }\n-                        return sb.toString();\n-                    }\n-                }\n-                return k;\n-            }\n-\n-            @Override\n-            public PrefixTree match(CharSequence text, ParsePosition pos) {\n-                int off = pos.getIndex();\n-                int end = text.length();\n-                int len = key.length();\n-                int koff = 0;\n-                while (koff < len && off < end) {\n-                    if (isLenientChar(text.charAt(off))) {\n-                        off++;\n-                        continue;\n-                    }\n-                    if (!isEqual(key.charAt(koff++), text.charAt(off++))) {\n-                        return null;\n-                    }\n-                }\n-                if (koff != len) {\n-                    return null;\n-                }\n-                if (child != null && off != end) {\n-                    int off0 = off;\n-                    while (off0 < end && isLenientChar(text.charAt(off0))) {\n-                        off0++;\n-                    }\n-                    if (off0 < end) {\n-                        PrefixTree c = child;\n-                        do {\n-                            if (isEqual(c.c0, text.charAt(off0))) {\n-                                pos.setIndex(off0);\n-                                PrefixTree found = c.match(text, pos);\n-                                if (found != null) {\n-                                    return found;\n-                                }\n-                                break;\n-                            }\n-                            c = c.sibling;\n-                        } while (c != null);\n-                    }\n-                }\n-                pos.setIndex(off);\n-                return this;\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static org.testng.Assert.fail;\n@@ -31,0 +32,1 @@\n+import java.time.format.DateTimeParseException;\n@@ -262,0 +264,9 @@\n+        var lc = input.toLowerCase(Locale.ROOT);\n+        try {\n+            ZonedDateTime.parse(lc, dtf);\n+            fail(\"Should throw DateTimeParseException\");\n+        } catch (DateTimeParseException ignore) {}\n+\n+        dtf = new DateTimeFormatterBuilder().parseCaseInsensitive().appendPattern(pattern).toFormatter();\n+        assertEquals(dtf.format(ZonedDateTime.parse(input, dtf)), input);\n+        assertEquals(dtf.format(ZonedDateTime.parse(lc, dtf)), input);\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestZoneTextPrinterParser.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}