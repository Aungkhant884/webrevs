{"files":[{"patch":"@@ -500,2 +500,11 @@\n-  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-  return get_op_for_self(allow_suspend, check_async_exception) != nullptr;\n+  \/\/ We musn't block here as that could lead to deadlocks if we already hold an\n+  \/\/ \"external\" mutex. If the try_lock fails then we assume that there is an operation\n+  \/\/ and force the caller to check more carefully in a safer context. If we can't get\n+  \/\/ the lock it means another thread is trying to handshake with us, so it can't\n+  \/\/ happen during thread termination and destruction.\n+  bool ret = true;\n+  if (_lock.try_lock()) {\n+    ret = get_op_for_self(allow_suspend, check_async_exception) != nullptr;\n+    _lock.unlock();\n+  }\n+  return ret;\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}