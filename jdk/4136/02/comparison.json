{"files":[{"patch":"@@ -923,0 +923,14 @@\n+  \/\/ result of xor can only have bits sets where any of the\n+  \/\/ inputs have bits set. lo can always become 0.\n+  const TypeInt* t1i = t1->is_int();\n+  const TypeInt* t2i = t2->is_int();\n+  if ((t1i->_lo >= 0)        &&\n+      (t1i->_hi > 0)         &&\n+      (t1i->_hi < max_power_of_2<jint>()) &&\n+      (t2i->_lo >= 0)        &&\n+      (t2i->_hi > 0)         &&\n+      (t2i->_hi < max_power_of_2<jint>())) {\n+    const TypeInt* t1x = TypeInt::make(0, next_power_of_2(t1i->_hi) - 1, t1i->_widen);\n+    const TypeInt* t2x = TypeInt::make(0, next_power_of_2(t2i->_hi) - 1, t2i->_widen);\n+    return t1x->meet(t2x);\n+  }\n@@ -926,0 +940,1 @@\n+\n@@ -973,0 +988,14 @@\n+  \/\/ result of xor can only have bits sets where any of the\n+  \/\/ inputs have bits set. lo can always become 0.\n+  const TypeLong* t1l = t1->is_long();\n+  const TypeLong* t2l = t2->is_long();\n+  if ((t1l->_lo >= 0)        &&\n+      (t1l->_hi > 0)         &&\n+      (t1l->_hi < max_power_of_2<jlong>()) &&\n+      (t2l->_lo >= 0)        &&\n+      (t2l->_hi > 0)         &&\n+      (t2l->_hi < max_power_of_2<jlong>())) {\n+    const TypeLong* t1x = TypeLong::make(0, next_power_of_2(t1l->_hi) - 1, t1l->_widen);\n+    const TypeLong* t2x = TypeLong::make(0, next_power_of_2(t2l->_hi) - 1, t2l->_widen);\n+    return t1x->meet(t2x);\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267332\n+ * @summary Test meet on xor\n+ * @library \/test\/lib \/\n+ * @run main\/othervm compiler.types.TestMeetXor -XX::CompileCommand=dontinline,*::test*\n+ *\/\n+\n+package compiler.types;\n+\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+\n+public class TestMeetXor {\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 10000; i++) {\n+            testCase1E();\n+            testCase2E();\n+            testCase3E();\n+\n+            testCaseS();\n+        }\n+    }\n+\n+    static int[] count = new int[256];\n+    static Random r = new Random(5);\n+\n+    public static void testCase1E() {\n+        boolean aiobe = false;\n+        try {\n+            testBound1E(r.nextInt());\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            aiobe = true;\n+        }\n+        Asserts.assertTrue(aiobe);\n+    }\n+\n+    public static void testBound1E(int i1) throws ArrayIndexOutOfBoundsException {\n+        int index = (i1 >>> 24) ^ -1;\n+        count[index]++;\n+    }\n+\n+    public static void testCase2E() {\n+        boolean aiobe = false;\n+        try {\n+            testBound2E(r.nextInt());\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            aiobe = true;\n+        }\n+        Asserts.assertTrue(aiobe);\n+    }\n+\n+    public static void testBound2E(int i1) throws ArrayIndexOutOfBoundsException {\n+        int index = (i1 >>> 24) ^ 0x100;\n+        count[index]++;\n+    }\n+\n+    public static void testCase3E() {\n+        boolean aiobe = false;\n+        try {\n+            testBound3E(r.nextInt());\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            aiobe = true;\n+        }\n+        Asserts.assertTrue(aiobe);\n+    }\n+\n+    public static void testBound3E(int i1) throws ArrayIndexOutOfBoundsException {\n+        int index = (i1 >>> 24) ^ Integer.MIN_VALUE;\n+        count[index]++;\n+    }\n+\n+    public static void testCase4E() {\n+        boolean aiobe = false;\n+        try {\n+            testBound4E(r.nextInt(), 0xf0f0ff);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            aiobe = true;\n+        }\n+        Asserts.assertTrue(aiobe);\n+    }\n+\n+    public static void testBound4E(int i1, int i2) throws ArrayIndexOutOfBoundsException {\n+        int index = (i1 >>> 24) ^ i2;\n+        count[index]++;\n+    }\n+\n+    public static void testCaseS() {\n+        testBound1S(r.nextInt());\n+        testBound2S(r.nextInt());\n+        testBound3S(r.nextInt(), r.nextInt());\n+        testBound4S(r.nextInt());\n+    }\n+\n+    public static void testBound1S(int i1) throws ArrayIndexOutOfBoundsException {\n+        int index = (i1 >>> 24) ^ 0x80;\n+        count[index]++;\n+    }\n+\n+    public static void testBound2S(int i1) throws ArrayIndexOutOfBoundsException {\n+        int index = (i1 >>> 24) ^ 0xff;\n+        count[index]++;\n+    }\n+\n+    public static void testBound3S(int i1, int i2) throws ArrayIndexOutOfBoundsException {\n+        int index = (i1 >>> 24) ^ (i2 >>> 24);\n+        count[index]++;\n+    }\n+\n+    public static void testBound4S(int i1) throws ArrayIndexOutOfBoundsException {\n+        int index = (i1 >>> 24) ^ 0;\n+        count[index]++;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestMeetXor.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}