{"files":[{"patch":"@@ -764,1 +764,1 @@\n-        long sz = size();\n+        final long sz = size();\n@@ -768,9 +768,18 @@\n-        if ((sz - position) < count)\n-            count = sz - position;\n-\n-        \/\/ Attempt a direct transfer, if the kernel supports it, limiting\n-        \/\/ the number of bytes according to which platform\n-        int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n-        long n;\n-        if ((n = transferToDirectly(position, icount, target)) >= 0)\n-            return n;\n+        \/\/ Now position <= sz so remaining >= 0 and\n+        \/\/ remaining == 0 if and only if sz == 0\n+        long remaining = sz - position;\n+\n+        \/\/ Adjust count only if remaining > 0, i.e.,\n+        \/\/ sz > position which means sz > 0\n+        if (remaining > 0 && remaining < count)\n+            count = remaining;\n+\n+        \/\/ System calls supporting fast transfers might not work on files\n+        \/\/ which advertise zero size such as those in Linux \/proc\n+        if (sz > 0) {\n+            \/\/ Attempt a direct transfer, if the kernel supports it, limiting\n+            \/\/ the number of bytes according to which platform\n+            int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n+            long n;\n+            if ((n = transferToDirectly(position, icount, target)) >= 0)\n+                return n;\n@@ -778,3 +787,4 @@\n-        \/\/ Attempt a mapped transfer, but only to trusted channel types\n-        if ((n = transferToTrustedChannel(position, count, target)) >= 0)\n-            return n;\n+            \/\/ Attempt a mapped transfer, but only to trusted channel types\n+            if ((n = transferToTrustedChannel(position, count, target)) >= 0)\n+                return n;\n+        }\n@@ -928,0 +938,2 @@\n+        if (src instanceof FileChannelImpl fci && !fci.readable)\n+            throw new NonReadableChannelException();\n@@ -935,1 +947,3 @@\n-        if (src instanceof FileChannelImpl fci) {\n+        \/\/ System calls supporting fast transfers might not work on files\n+        \/\/ which advertise zero size such as those in Linux \/proc\n+        if (src instanceof FileChannelImpl fci && fci.size() > 0) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.ToLongBiFunction;\n+import static java.nio.file.StandardOpenOption.*;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8293502\n+ * @requires (os.family == \"linux\")\n+ * @summary Ensure that copying from a file in \/proc works\n+ * @run testng\/othervm CopyProcFile\n+ *\/\n+public class CopyProcFile {\n+    static final String SOURCE = \"\/proc\/cpuinfo\";\n+    static final String BUFFERED_COPY = \"bufferedCopy\";\n+    static final String TARGET = \"target\";\n+\n+    static final int BUF_SIZE = 8192;\n+\n+    static long theSize;\n+\n+    \/\/ copy src to dst via Java buffers\n+    static long bufferedCopy(String src, String dst) {\n+        try (InputStream in = new FileInputStream(src);\n+             OutputStream out = new FileOutputStream(dst)) {\n+            byte[] b = new byte[BUF_SIZE];\n+            long total = 0;\n+            int n;\n+            while ((n = in.read(b)) > 0) {\n+                out.write(b, 0, n);\n+                total += n;\n+            }\n+            return total;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/\/ copy src to dst using Files::copy\n+    static long copy(String src, String dst) {\n+        try {\n+            Path target = Files.copy(Path.of(src), Path.of(dst));\n+            return Files.size(target);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/\/ copy src to dst using InputStream::transferTo\n+    static long transferToIO(String src, String dst) {\n+        try (InputStream in = new FileInputStream(src);\n+             OutputStream out = new FileOutputStream(dst)) {\n+            return in.transferTo(out);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/\/ copy src to dst using FileChannel::transferTo\n+    static long transferToNIO(String src, String dst) {\n+        try (FileChannel fci = FileChannel.open(Path.of(src), READ);\n+             FileChannel fco = FileChannel.open(Path.of(dst), CREATE_NEW, WRITE);) {\n+            return fci.transferTo(0, Long.MAX_VALUE, fco);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/\/ copy src to dst using FileChannel::transferFrom\n+    static long transferFrom(String src, String dst) {\n+        try (FileChannel fci = FileChannel.open(Path.of(src), READ);\n+             FileChannel fco = FileChannel.open(Path.of(dst), CREATE_NEW, WRITE);) {\n+            return fco.transferFrom(fci, 0, Long.MAX_VALUE);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @BeforeTest(alwaysRun=true)\n+    public void createBufferedCopy() {\n+        System.out.printf(\"Using source file \\\"%s\\\"%n\", SOURCE);\n+        try {\n+            theSize = bufferedCopy(SOURCE, BUFFERED_COPY);\n+            System.out.printf(\"Copied %d bytes from %s%n\", theSize, SOURCE);\n+            if (Files.mismatch(Path.of(BUFFERED_COPY), Path.of(SOURCE)) != -1)\n+                throw new RuntimeException(\"Copy does not match source\");\n+        } catch (Exception e) {\n+            try {\n+                Files.delete(Path.of(BUFFERED_COPY));\n+            } catch (IOException ignore) {}\n+        }\n+    }\n+\n+    @AfterTest(alwaysRun=true)\n+    public void deleteBufferedCopy() {\n+        try {\n+            Files.delete(Path.of(BUFFERED_COPY));\n+        } catch (IOException ignore) {}\n+    }\n+\n+    static class FHolder {\n+        ToLongBiFunction<String,String> f;\n+\n+        FHolder(ToLongBiFunction<String,String> f) {\n+            this.f = f;\n+        }\n+\n+        long apply(String src, String dst) {\n+            return f.applyAsLong(src, dst);\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] functions() throws IOException {\n+        List<Object[]> funcs = new ArrayList<>();\n+        funcs.add(new Object[] {new FHolder((s, d) -> copy(s, d))});\n+        funcs.add(new Object[] {new FHolder((s, d) -> transferToIO(s, d))});\n+        funcs.add(new Object[] {new FHolder((s, d) -> transferToNIO(s, d))});\n+        funcs.add(new Object[] {new FHolder((s, d) -> transferFrom(s, d))});\n+        return funcs.toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"functions\")\n+    public static void testCopyAndTransfer(FHolder f) throws IOException {\n+        try {\n+            long size = f.apply(SOURCE, TARGET);\n+            if (size != theSize)\n+                throw new RuntimeException(\"Size: expected \" + theSize +\n+                                           \"; actual: \" + size);\n+            long mismatch = Files.mismatch(Path.of(BUFFERED_COPY),\n+                                           Path.of(TARGET));\n+            if (mismatch != -1)\n+                throw new RuntimeException(\"Target does not match copy\");\n+        } finally {\n+            try {\n+                Files.delete(Path.of(TARGET));\n+            } catch (IOException ignore) {}\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyProcFile.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}