{"files":[{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/readWriteLock.hpp\"\n+\n+inline void ReadWriteLock::await_write_unlock() {\n+  Locker locker(&_mon);\n+  while (Atomic::load_acquire(&_count) < 0) {\n+    _mon.wait(0);\n+  }\n+}\n+\n+inline void ReadWriteLock::await_write_lock() {\n+  Locker locker(&_mon);\n+  while (Atomic::load_acquire(&_count) != -1) {\n+    _mon.wait(0);\n+  }\n+}\n+\n+void ReadWriteLock::read_lock(Thread* current) {\n+  assert(current == nullptr || current == Thread::current(), \"invariant\");\n+\n+  for (;;) {\n+    const int32_t count = Atomic::load_acquire(&_count);\n+    if (count < 0) {\n+      \/\/ Wait until unlocked by writer\n+\n+      if (current != nullptr && current->is_Java_thread()) {\n+        ThreadBlockInVM tbivm(JavaThread::cast(current));\n+        await_write_unlock();\n+      } else {\n+        await_write_unlock();\n+      }\n+      continue;\n+    }\n+\n+    \/\/ Increment count\n+    if (Atomic::cmpxchg(&_count, count, count + 1) != count) {\n+      continue;\n+    }\n+\n+    \/\/ Entered critical region\n+    return;\n+  }\n+}\n+\n+void ReadWriteLock::read_unlock() {\n+  for (;;) {\n+    const int32_t count = Atomic::load_acquire(&_count);\n+    assert(count != 0 && count != -1, \"invariant\");\n+\n+    if (count > 0) {\n+      \/\/ No writer in progress, try to decrement reader count.\n+      if (Atomic::cmpxchg(&_count, count, count - 1) != count) {\n+        continue;\n+      }\n+    } else {\n+      \/\/ Writer in progress, try to increment reader count.\n+      if (Atomic::cmpxchg(&_count, count, count + 1) != count) {\n+        continue;\n+      }\n+      \/\/ If the previous count was -2, then we just incremented it to -1,\n+      \/\/ and we should signal that all readers have now exited their\n+      \/\/ critical region and the writer may now block readers.\n+      if (count == -2) {\n+        Locker locker(&_mon);\n+        _mon.notify_all();\n+      }\n+    }\n+    \/\/ Exited critical region\n+    return;\n+  }\n+}\n+\n+void ReadWriteLock::write_lock(Thread* current) {\n+  assert(current == nullptr || current == Thread::current(), \"invariant\");\n+\n+  for (;;) {\n+    const int32_t count = Atomic::load_acquire(&_count);\n+\n+    if (count < 0) {\n+      \/\/ Already has a writer, wait until unlocked\n+\n+      if (current != nullptr && current->is_Java_thread()) {\n+        ThreadBlockInVM tbivm(JavaThread::cast(current));\n+        await_write_unlock();\n+      } else {\n+        await_write_unlock();\n+      }\n+      continue;\n+    }\n+\n+    \/\/ Increment and invert count\n+    if (Atomic::cmpxchg(&_count, count, -(count + 1)) != count) {\n+      continue;\n+    }\n+\n+    \/\/ If the previous count was 0, then we just incremented and inverted\n+    \/\/ it to -1 and have now blocked readers. Otherwise we wait until all reader\n+    \/\/ threads have exited the critical region.\n+    if (count != 0) {\n+      \/\/ Wait until all readers exit.\n+      if (current != nullptr && current->is_Java_thread()) {\n+        ThreadBlockInVM tbivm(JavaThread::cast(current));\n+        await_write_lock();\n+      } else {\n+        await_write_lock();\n+      }\n+    }\n+\n+    \/\/ Locked.\n+    return;\n+  }\n+}\n+\n+void ReadWriteLock::write_unlock() {\n+  assert(Atomic::load_acquire(&_count) == -1, \"invariant\");\n+\n+  Locker locker(&_mon);\n+  Atomic::release_store(&_count, (int32_t)0);\n+  _mon.notify_all();\n+}\n","filename":"src\/hotspot\/share\/utilities\/readWriteLock.cpp","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_READWRITELOCK_HPP\n+#define SHARE_RUNTIME_READWRITELOCK_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+\/\/  This is a multiple-reader single-writer lock implementation.\n+\/\/\n+\/\/ * This lock is unfair, high contention of readers may starve some of them.\n+\/\/   This is because registering a reader requires CASing a counter.\n+\/\/\n+\/\/ * Writers take precedence, blocking new readers from entering and allowing\n+\/\/   current readers to proceed until none are left, at which point it will\n+\/\/   unblock itself and proceed to execute its critical region.\n+\/\/\n+\/\/ * A writer cannot downgrade to a read-lock.\n+\/\/\n+\/\/ * A reader cannot upgrade to a write-lock.\n+\/\/\n+\/\/ * This lock is not recursive. It is not even safe for readers to lock recursively,\n+\/\/   as this will deadlock if there is an interleaving writer.\n+\/\/\n+\/\/ * This lock allows safe points to take place when being blocked.\n+class ReadWriteLock : public CHeapObj<mtSynchronizer> {\n+private:\n+  NONCOPYABLE(ReadWriteLock);\n+\n+  class Locker : public StackObj {\n+  private:\n+    PlatformMonitor* const _lock;\n+\n+  public:\n+    Locker(PlatformMonitor* lock)\n+      : _lock(lock) {\n+      _lock->lock();\n+    }\n+    ~Locker() {\n+      _lock->unlock();\n+    }\n+  };\n+\n+  PlatformMonitor _mon;\n+\n+  \/\/ The count reflects the number of reader threads inside a critical region and whether or not a writer is waiting.\n+  \/\/\n+  \/\/ * Normal (count >= 0). Readers are allowed to enter and exit their critical region, no writer waiting.\n+  \/\/\n+  \/\/ * Blocked (count == -1). A writer is inside its critical region.\n+  \/\/\n+  \/\/ * Block in progress (count < -1). Readers are only allowed to exit their critical region.\n+  \/\/   Attempts by readers to enter their critical region is blocked.\n+  \/\/\n+  volatile int32_t _count;\n+\n+  void await_write_unlock();\n+  void await_write_lock();\n+public:\n+  ReadWriteLock()\n+    : _mon(),\n+      _count(0) {\n+  }\n+\n+  ~ReadWriteLock() = default;\n+\n+  void write_lock(Thread* current = Thread::current_or_null());\n+  void write_unlock();\n+\n+  void read_lock(Thread* current = Thread::current_or_null());\n+  void read_unlock();\n+};\n+#endif \/\/ SHARE_RUNTIME_READWRITELOCK_HPP\n","filename":"src\/hotspot\/share\/utilities\/readWriteLock.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/readWriteLock.hpp\"\n+\n+class ReadWriteLockTest : public ::testing::Test {};\n+\n+TEST_VM_F(ReadWriteLockTest, WriterLockPreventsReadersFromEnteringCriticalRegion) {\n+  const int max_iter = 1000;\n+  int iter = 0;\n+  ReadWriteLock* mut = new ReadWriteLock();\n+\n+  volatile bool reader_started = false;\n+  volatile bool reader_in_critical_region = false;\n+  volatile bool reader_exited_critical_region = false;\n+\n+  auto reader = [&](Thread* current, int _id) {\n+    Atomic::release_store(&reader_started, true);\n+    mut->read_lock(current);\n+    Atomic::release_store(&reader_in_critical_region, true);\n+    mut->read_unlock();\n+    Atomic::release_store(&reader_exited_critical_region, true);\n+  };\n+\n+  Semaphore rp{};\n+  BasicTestThread<decltype(reader)>* rt =\n+      new BasicTestThread<decltype(reader)>(reader, 0, &rp);\n+\n+  \/\/ 1. Hold write lock\n+  mut->write_lock(Thread::current());\n+\n+  \/\/ 2. Start reader\n+  rt->doit();\n+\n+  \/\/ 3. Wait for reader to attempt to lock\n+  iter = 0;\n+  while (!Atomic::load_acquire(&reader_started) && iter < max_iter) {\n+    \/\/ Spin, waiting for reader to start up\n+    iter++;\n+  }\n+\n+  \/\/ 4. Reader should block, waiting for its turn to enter critical region\n+  \/\/ Check repeatedly to (hopefully) avoid timing issue.\n+  for (int i = 0; i < max_iter; i++) {\n+    EXPECT_FALSE(Atomic::load_acquire(&reader_in_critical_region));\n+  }\n+\n+  \/\/ 5. Let reader enter its critical region\n+  mut->write_unlock();\n+  iter = 0;\n+  while (!Atomic::load_acquire(&reader_in_critical_region) && iter < max_iter) {\n+    iter++;\n+  }\n+  ASSERT_TRUE(Atomic::load_acquire(&reader_in_critical_region));\n+\n+  \/\/ 6. Reader succesfully exits its critical region\n+  iter = 0;\n+  while (!Atomic::load_acquire(&reader_exited_critical_region) && iter < max_iter) {\n+    iter++;\n+  }\n+  ASSERT_TRUE(Atomic::load_acquire(&reader_exited_critical_region));\n+}\n+\n+TEST_VM_F(ReadWriteLockTest, MultipleReadersAtSameTime) {\n+  ReadWriteLock* mut = new ReadWriteLock();\n+  constexpr const int num_readers = 5;\n+  volatile int concurrent_readers = 0;\n+\n+  auto r = [&](Thread* current, int _id) {\n+    mut->read_lock(current);\n+    \/\/ Increment counter\n+    Atomic::add(&concurrent_readers, 1);\n+    \/\/ Don't let go of the lock, exit thread\n+  };\n+  TestThreadGroup<decltype(r)> ttg(r, num_readers);\n+  ttg.doit();\n+  ttg.join();\n+  EXPECT_EQ(Atomic::load(&concurrent_readers), num_readers);\n+  \/\/ Unlock for all the threads.\n+  \/\/ Not strictly necessary, but locking looks weird\n+  \/\/ without the corresponding unlock\n+  for (int i = 0; i < num_readers; i++) {\n+    mut->read_unlock();\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_readWriteLock.cpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"}]}