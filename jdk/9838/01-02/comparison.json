{"files":[{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_RUNTIME_MRSWMUTEX_HPP\n-#define SHARE_RUNTIME_MRSWMUTEX_HPP\n+#ifndef SHARE_RUNTIME_READWRITELOCK_HPP\n+#define SHARE_RUNTIME_READWRITELOCK_HPP\n@@ -35,1 +35,2 @@\n-\/\/ Multi-reader single-writer lock implementation.\n+\/\/  This is a multiple-reader single-writer lock implementation.\n+\/\/\n@@ -37,0 +38,2 @@\n+\/\/   This is because registering a reader requires CASing a counter.\n+\/\/\n@@ -38,4 +41,11 @@\n-\/\/   current readers to proceed.\n-\/\/ * A writer cannot downgrade to a read-lock\n-\/\/ * A reader cannot upgrade to a write-lock\n-\n+\/\/   current readers to proceed until none are left, at which point it will\n+\/\/   unblock itself and proceed to execute its critical region.\n+\/\/\n+\/\/ * A writer cannot downgrade to a read-lock.\n+\/\/\n+\/\/ * A reader cannot upgrade to a write-lock.\n+\/\/\n+\/\/ * This lock is not recursive. It is not even safe for readers to lock recursively,\n+\/\/   as this will deadlock if there is an interleaving writer.\n+\/\/\n+\/\/ * This lock allows safe points to take place when being blocked.\n@@ -45,5 +55,0 @@\n-  class NoTransition : public StackObj {\n-  public:\n-    NoTransition(Thread* thread) {\n-    }\n-  };\n@@ -93,1 +98,1 @@\n-#endif \/\/ SHARE_RUNTIME_MRSWMUTEX_HPP\n+#endif \/\/ SHARE_RUNTIME_READWRITELOCK_HPP\n","filename":"src\/hotspot\/share\/utilities\/readWriteLock.hpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"}]}