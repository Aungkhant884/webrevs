{"files":[{"patch":"@@ -7358,1 +7358,1 @@\n-    assert($mem$$disp == oopDesc::klass_offset_in_bytes(), \"expect correct offset\");\n+    assert($mem$$disp == TypeOopPtr::klass_offset_in_bytes(), \"expect correct offset\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5336,1 +5336,1 @@\n-    assert($mem$$disp == oopDesc::klass_offset_in_bytes(), \"expect correct offset 4, but got: %d\", $mem$$disp);\n+    assert($mem$$disp == TypeOopPtr::klass_offset_in_bytes(), \"expect correct offset 4, but got: %d\", $mem$$disp);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -322,2 +322,4 @@\n-  assert(oopDesc::klass_offset_in_bytes() < static_cast<intptr_t>(os::vm_page_size()),\n-         \"Klass offset is expected to be less than the page size\");\n+  if (!UseCompactObjectHeaders) {\n+    assert(oopDesc::klass_offset_in_bytes() < static_cast<intptr_t>(os::vm_page_size()),\n+           \"Klass offset is expected to be less than the page size\");\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -338,10 +338,1 @@\n-#ifdef _LP64\n-    if (UseCompactObjectHeaders) {\n-      \/\/ With compact object headers, the klass-offset is only used by the\n-      \/\/ C2 compiler to differentiate LoadNKlass. It is never used to actually\n-      \/\/ load the narrowKlass from the header. Any offset that is not used by\n-      \/\/ anything else should suffice, here.\n-      STATIC_ASSERT(markWord::klass_shift % BitsPerByte == 0);\n-      return mark_offset_in_bytes() + markWord::klass_shift \/ BitsPerByte;\n-    }\n-#endif\n+    assert(!UseCompactObjectHeaders, \"don't use klass_offset_in_bytes() with compact headers\");\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1349,1 +1349,1 @@\n-      } else if( offset == oopDesc::klass_offset_in_bytes() ) {\n+      } else if( offset == TypeOopPtr::klass_offset_in_bytes() ) {\n@@ -1516,1 +1516,1 @@\n-          (offset == oopDesc::klass_offset_in_bytes() && tj->base() == Type::AryPtr) ||\n+          (offset == TypeOopPtr::klass_offset_in_bytes() && tj->base() == Type::AryPtr) ||\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -929,1 +929,1 @@\n-    Node* p = basic_plus_adr( ex_node, ex_node, oopDesc::klass_offset_in_bytes());\n+    Node* p = basic_plus_adr( ex_node, ex_node, TypeOopPtr::klass_offset_in_bytes());\n@@ -947,1 +947,1 @@\n-        Node* p = basic_plus_adr(ex_in, ex_in, oopDesc::klass_offset_in_bytes());\n+        Node* p = basic_plus_adr(ex_in, ex_in, TypeOopPtr::klass_offset_in_bytes());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2306,1 +2306,1 @@\n-  } else if (offset != oopDesc::klass_offset_in_bytes()) {\n+  } else if (offset != TypeOopPtr::klass_offset_in_bytes()) {\n@@ -3289,1 +3289,1 @@\n-      _compile->get_alias_index(tinst->add_offset(oopDesc::klass_offset_in_bytes()));\n+      _compile->get_alias_index(tinst->add_offset(TypeOopPtr::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1201,1 +1201,1 @@\n-  Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n+  Node* k_adr = basic_plus_adr(obj, TypeOopPtr::klass_offset_in_bytes());\n@@ -3601,1 +3601,1 @@\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes())));\n+    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(TypeOopPtr::klass_offset_in_bytes())));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1665,1 +1665,1 @@\n-    rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+    rawmem = make_store(control, rawmem, object, TypeOopPtr::klass_offset_in_bytes(), klass_node, T_METADATA);\n@@ -2285,1 +2285,1 @@\n-      Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());\n+      Node* k_adr = basic_plus_adr(obj_or_subklass, TypeOopPtr::klass_offset_in_bytes());\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-          adr_check->offset() == oopDesc::klass_offset_in_bytes() ||\n+          adr_check->offset() == TypeOopPtr::klass_offset_in_bytes() ||\n@@ -907,1 +907,1 @@\n-           adr_type->offset() == oopDesc::klass_offset_in_bytes()),\n+           adr_type->offset() == TypeOopPtr::klass_offset_in_bytes()),\n@@ -2356,1 +2356,1 @@\n-    if (offset == oopDesc::klass_offset_in_bytes()) {\n+    if (offset == TypeOopPtr::klass_offset_in_bytes()) {\n@@ -2364,1 +2364,1 @@\n-      tary->offset() == oopDesc::klass_offset_in_bytes()) {\n+      tary->offset() == TypeOopPtr::klass_offset_in_bytes()) {\n@@ -2424,1 +2424,1 @@\n-  if (offset == oopDesc::klass_offset_in_bytes()) {\n+  if (offset == TypeOopPtr::klass_offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2099,1 +2099,1 @@\n-  Node* klass_addr = basic_plus_adr( receiver, receiver, oopDesc::klass_offset_in_bytes() );\n+  Node* klass_addr = basic_plus_adr( receiver, receiver, TypeOopPtr::klass_offset_in_bytes() );\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1668,1 +1668,1 @@\n-  if (obj == nullptr || off != oopDesc::klass_offset_in_bytes()) \/\/ loading oopDesc::_klass?\n+  if (obj == nullptr || off != TypeOopPtr::klass_offset_in_bytes()) \/\/ loading oopDesc::_klass?\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  int klass_offset = oopDesc::klass_offset_in_bytes();\n+  int klass_offset = TypeOopPtr::klass_offset_in_bytes();\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1146,1 +1146,1 @@\n-  if (con2 == oopDesc::klass_offset_in_bytes()) {\n+  if (con2 == TypeOopPtr::klass_offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    if (con == oopDesc::klass_offset_in_bytes() && obj != nullptr) {\n+    if (con == TypeOopPtr::klass_offset_in_bytes() && obj != nullptr) {\n@@ -211,1 +211,1 @@\n-    Node* adr = phase->transform(new AddPNode(obj_or_subklass, obj_or_subklass, phase->MakeConX(oopDesc::klass_offset_in_bytes())));\n+    Node* adr = phase->transform(new AddPNode(obj_or_subklass, obj_or_subklass, phase->MakeConX(TypeOopPtr::klass_offset_in_bytes())));\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -551,1 +551,1 @@\n-                                           false, 0, oopDesc::klass_offset_in_bytes());\n+                                           false, 0, TypeOopPtr::klass_offset_in_bytes());\n@@ -3502,1 +3502,1 @@\n-    if (_offset == oopDesc::klass_offset_in_bytes()) {\n+    if (_offset == TypeOopPtr::klass_offset_in_bytes()) {\n@@ -3563,0 +3563,34 @@\n+int TypeOopPtr::klass_offset_in_bytes() {\n+  if (UseCompactObjectHeaders) {\n+    \/\/ With compact headers, we don't directly load the Klass* (or actually narrow Klass*)\n+    \/\/ from the offset that we return here. This offset only serves to distinguish\n+    \/\/ loads of the Klass* from other memory operations by effectively creating\n+    \/\/ a memory slice just for the Klass*.\n+    \/\/ What the implementation of LoadNKlass actually does is:\n+    \/\/ - Load the mark-word (from offset 0)\n+    \/\/ - Check if the monitor bit is set\n+    \/\/   - if it is, load the displaced mark-word from the monitor\n+    \/\/ - Extract the compressed Klass* from the mark-word bits\n+    \/\/\n+    \/\/ One could argue that therefore, loading of the Klass* should really be at\n+    \/\/ the same slice as offset 0 (other mark-word accesses), but because all of the\n+    \/\/ above is happening in the backend, the Klass* is effectively immutable\n+    \/\/ as far as C2 ideal graph is concerned.\n+    \/\/ It might be an interesting future improvement to not expand LoadNKlass in\n+    \/\/ the backend, but instead expand it as a macro node. If we did this, we'd\n+    \/\/ really have to wire it to the memory slice of offset 0 (the mark-word). This may\n+    \/\/ be faster because instructions could be scheduled better, or it may be\n+    \/\/ slower because the memory slice at offset 0 is quite busy (because of locking,\n+    \/\/ hash-code, allocations, etc).\n+    \/\/\n+    \/\/ The exact value of offset 4 has been chosen because it points into the middle\n+    \/\/ of the mark-word and that is an offset that is guaranteed to not be used\n+    \/\/ otherwise. (And also because the original implementation put the compressed\n+    \/\/ Klass* at offset 4, but this may no longer be the case, and is not actually\n+    \/\/ relevant. See above discussion.)\n+    return 4;\n+  } else {\n+    return oopDesc::klass_offset_in_bytes();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1152,0 +1152,1 @@\n+  static int klass_offset_in_bytes();\n@@ -1404,1 +1405,1 @@\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n+        _offset != TypeOopPtr::klass_offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}