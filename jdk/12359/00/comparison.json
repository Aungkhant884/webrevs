{"files":[{"patch":"@@ -66,8 +66,7 @@\n-\/\/\n-\/\/ DefNewGeneration functions.\n-\n-\/\/ Methods of protected closure types.\n-\n-DefNewGeneration::IsAliveClosure::IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {\n-  assert(_young_gen->kind() == Generation::DefNew, \"Expected the young generation here\");\n-}\n+class IsAliveClosure: public BoolObjectClosure {\n+  Generation* _young_gen;\n+public:\n+  IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {\n+    assert(_young_gen->kind() == Generation::DefNew,\n+        \"Expected the young generation here\");\n+  }\n@@ -75,3 +74,20 @@\n-bool DefNewGeneration::IsAliveClosure::do_object_b(oop p) {\n-  return cast_from_oop<HeapWord*>(p) >= _young_gen->reserved().end() || p->is_forwarded();\n-}\n+  bool do_object_b(oop p) {\n+    return cast_from_oop<HeapWord*>(p) >= _young_gen->reserved().end() || p->is_forwarded();\n+  }\n+};\n+\n+class KeepAliveClosure: public OopClosure {\n+  ScanWeakRefClosure* _cl;\n+  CardTableRS* _rs;\n+  HeapWord* _boundary;\n+\n+  template <class T>\n+  inline void do_oop_work(T* p) {\n+#ifdef ASSERT\n+    {\n+      \/\/ We never expect to see a null reference being processed\n+      \/\/ as a weak reference.\n+      oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n+      assert (oopDesc::is_oop(obj), \"expected an oop while scanning weak refs\");\n+    }\n+#endif \/\/ ASSERT\n@@ -79,6 +95,1 @@\n-DefNewGeneration::FastKeepAliveClosure::\n-FastKeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl) :\n-  _cl(cl) {\n-  _rs = GenCollectedHeap::heap()->rem_set();\n-  _boundary = g->reserved().end();\n-}\n+    Devirtualizer::do_oop(_cl, p);\n@@ -86,2 +97,8 @@\n-void DefNewGeneration::FastKeepAliveClosure::do_oop(oop* p)       { DefNewGeneration::FastKeepAliveClosure::do_oop_work(p); }\n-void DefNewGeneration::FastKeepAliveClosure::do_oop(narrowOop* p) { DefNewGeneration::FastKeepAliveClosure::do_oop_work(p); }\n+    \/\/ Optimized for Defnew generation if it's the youngest generation:\n+    \/\/ we set a younger_gen card if we have an older->youngest\n+    \/\/ generation pointer.\n+    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n+    if ((cast_from_oop<HeapWord*>(obj) < _boundary) && GenCollectedHeap::heap()->is_in_reserved(p)) {\n+      _rs->inline_write_ref_field_gc(p);\n+    }\n+  }\n@@ -89,7 +106,6 @@\n-DefNewGeneration::FastEvacuateFollowersClosure::\n-FastEvacuateFollowersClosure(SerialHeap* heap,\n-                             DefNewScanClosure* cur,\n-                             DefNewYoungerGenClosure* older) :\n-  _heap(heap), _scan_cur_or_nonheap(cur), _scan_older(older)\n-{\n-}\n+public:\n+  KeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl) :\n+    _cl(cl) {\n+    _rs = GenCollectedHeap::heap()->rem_set();\n+    _boundary = g->reserved().end();\n+  }\n@@ -97,6 +113,22 @@\n-void DefNewGeneration::FastEvacuateFollowersClosure::do_void() {\n-  do {\n-    _heap->oop_since_save_marks_iterate(_scan_cur_or_nonheap, _scan_older);\n-  } while (!_heap->no_allocs_since_save_marks());\n-  guarantee(_heap->young_gen()->promo_failure_scan_is_complete(), \"Failed to finish scan\");\n-}\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+};\n+\n+class FastEvacuateFollowersClosure: public VoidClosure {\n+  SerialHeap* _heap;\n+  DefNewScanClosure* _scan_cur_or_nonheap;\n+  DefNewYoungerGenClosure* _scan_older;\n+public:\n+  FastEvacuateFollowersClosure(SerialHeap* heap,\n+                               DefNewScanClosure* cur,\n+                               DefNewYoungerGenClosure* older) :\n+    _heap(heap), _scan_cur_or_nonheap(cur), _scan_older(older)\n+  {}\n+\n+  void do_void() {\n+    do {\n+      _heap->oop_since_save_marks_iterate(_scan_cur_or_nonheap, _scan_older);\n+    } while (!_heap->no_allocs_since_save_marks());\n+    guarantee(_heap->young_gen()->promo_failure_scan_is_complete(), \"Failed to finish scan\");\n+  }\n+};\n@@ -581,1 +613,1 @@\n-  FastKeepAliveClosure keep_alive(this, &scan_weak_ref);\n+  KeepAliveClosure keep_alive(this, &scan_weak_ref);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":65,"deletions":33,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -162,30 +162,0 @@\n- public:  \/\/ was \"protected\" but caused compile error on win32\n-  class IsAliveClosure: public BoolObjectClosure {\n-    Generation* _young_gen;\n-  public:\n-    IsAliveClosure(Generation* young_gen);\n-    bool do_object_b(oop p);\n-  };\n-\n-  class FastKeepAliveClosure: public OopClosure {\n-    ScanWeakRefClosure* _cl;\n-    CardTableRS* _rs;\n-    HeapWord* _boundary;\n-    template <class T> void do_oop_work(T* p);\n-  public:\n-    FastKeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl);\n-    virtual void do_oop(oop* p);\n-    virtual void do_oop(narrowOop* p);\n-  };\n-\n-  class FastEvacuateFollowersClosure: public VoidClosure {\n-    SerialHeap* _heap;\n-    DefNewScanClosure* _scan_cur_or_nonheap;\n-    DefNewYoungerGenClosure* _scan_older;\n-  public:\n-    FastEvacuateFollowersClosure(SerialHeap* heap,\n-                                 DefNewScanClosure* cur,\n-                                 DefNewYoungerGenClosure* older);\n-    void do_void();\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -39,22 +39,0 @@\n-template <class T>\n-inline void DefNewGeneration::FastKeepAliveClosure::do_oop_work(T* p) {\n-#ifdef ASSERT\n-  {\n-    \/\/ We never expect to see a null reference being processed\n-    \/\/ as a weak reference.\n-    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-    assert (oopDesc::is_oop(obj), \"expected an oop while scanning weak refs\");\n-  }\n-#endif \/\/ ASSERT\n-\n-  Devirtualizer::do_oop(_cl, p);\n-\n-  \/\/ Optimized for Defnew generation if it's the youngest generation:\n-  \/\/ we set a younger_gen card if we have an older->youngest\n-  \/\/ generation pointer.\n-  oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-  if ((cast_from_oop<HeapWord*>(obj) < _boundary) && GenCollectedHeap::heap()->is_in_reserved(p)) {\n-    _rs->inline_write_ref_field_gc(p);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"}]}