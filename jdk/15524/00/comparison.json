{"files":[{"patch":"@@ -790,0 +790,2 @@\n+\n+  \/\/ Try to retrieve the lambda proxy class from static archive.\n@@ -791,2 +793,20 @@\n-  if (info == nullptr) {\n-    info = _dynamic_archive.lookup_lambda_proxy_class(&key);\n+  InstanceKlass* proxy_klass = retrieve_lambda_proxy_class(info);\n+  if (proxy_klass == nullptr) {\n+    if (info != nullptr && log_is_enabled(Debug, cds)) {\n+      ResourceMark rm;\n+      log_debug(cds)(\"Used all static archived lambda proxy classes for: %s %s%s\",\n+                     caller_ik->external_name(), invoked_name->as_C_string(), invoked_type->as_C_string());\n+    }\n+  } else {\n+    return proxy_klass;\n+  }\n+\n+  \/\/ Retrieving from static archive is unsuccessful, try dynamic archive.\n+  info = _dynamic_archive.lookup_lambda_proxy_class(&key);\n+  proxy_klass = retrieve_lambda_proxy_class(info);\n+  if (proxy_klass == nullptr) {\n+    if (info != nullptr && log_is_enabled(Debug, cds)) {\n+      ResourceMark rm;\n+      log_debug(cds)(\"Used all dynamic archived lambda proxy classes for: %s %s%s\",\n+                     caller_ik->external_name(), invoked_name->as_C_string(), invoked_type->as_C_string());\n+    }\n@@ -794,0 +814,4 @@\n+  return proxy_klass;\n+}\n+\n+InstanceKlass* SystemDictionaryShared::retrieve_lambda_proxy_class(const RunTimeLambdaProxyClassInfo* info) {\n@@ -813,6 +837,0 @@\n-    } else {\n-      if (log_is_enabled(Debug, cds)) {\n-        ResourceMark rm;\n-        log_debug(cds)(\"Used all archived lambda proxy classes for: %s %s%s\",\n-                       caller_ik->external_name(), invoked_name->as_C_string(), invoked_type->as_C_string());\n-      }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+  static InstanceKlass* retrieve_lambda_proxy_class(const RunTimeLambdaProxyClassInfo* info) NOT_CDS_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3630,2 +3630,10 @@\n-  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n-                                                 interface_method_type, m, dynamic_method_type, THREAD);\n+  InstanceKlass* shared_lambda = nullptr;\n+  if (caller_ik->is_shared()) {\n+    shared_lambda = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n+                                                                          interface_method_type, m, dynamic_method_type);\n+  }\n+\n+  if (shared_lambda == nullptr) {\n+    SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n+                                                   interface_method_type, m, dynamic_method_type, THREAD);\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307468\n+ * @summary Test archiving of lambda proxy classes with the same LambdaProxyClassKey\n+ *          (see cds\/lambdaProxyClassDictionary.hpp). If some lambda proxy classes\n+ *          are already in the static archive, during dynamic dump with the static archive,\n+ *          the ones in the static archive should not be generated and archived\n+ *          in the dynamic archive.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build LambdasWithSameKey\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar lambdas_same_key.jar LambdasWithSameKey\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. LambdasInTwoArchives\n+ *\/\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LambdasInTwoArchives extends DynamicArchiveTestBase {\n+    static final String lambdaPattern =\n+        \".*cds.class.*klasses.*LambdasWithSameKey[$][$]Lambda.*\/0x.*hidden\";\n+    static final String loadFromStatic =\n+        \".*class.load.*LambdasWithSameKey[$][$]Lambda\/0x.*source:.*shared.*objects.*file\";\n+    static final String loadFromTop = loadFromStatic + \".*(top).*\";\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(LambdasInTwoArchives::test);\n+    }\n+\n+    static void checkLambdas(OutputAnalyzer output, String matchPattern, int numLambdas) throws Exception {\n+        List<String> lines = output.asLines();\n+        Pattern pattern = Pattern.compile(matchPattern);\n+        int count = 0;\n+        for (int i = 0; i < lines.size(); i++) {\n+            if (pattern.matcher(lines.get(i)).matches()) {\n+                count++;\n+            }\n+        }\n+        if (count != numLambdas) {\n+            throw new RuntimeException(\"Expecting \" + numLambdas + \" lambda proxy classes, but got \" + count);\n+        }\n+    }\n+\n+    static void test() throws Exception {\n+        String classListFileName = \"lambda-classes.list\";\n+        File fileList = new File(classListFileName);\n+        if (fileList.exists()) {\n+            fileList.delete();\n+        }\n+        String appJar = ClassFileInstaller.getJarPath(\"lambdas_same_key.jar\");\n+        String mainClass = \"LambdasWithSameKey\";\n+        \/\/ Generate a class list for static dump.\n+        \/\/ Note that the class list contains one less lambda proxy class comparing\n+        \/\/ with running the LambdasWithSameKey app with the \"run\" argument.\n+        String[] launchArgs  = {\n+                \"-Xshare:off\",\n+                \"-XX:DumpLoadedClassList=\" + classListFileName,\n+                \"-Xlog:cds\",\n+                \"-Xlog:cds+lambda\",\n+                \"-cp\", appJar, mainClass};\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer oa = TestCommon.executeAndLog(pb, \"lambda-classes\");\n+        oa.shouldHaveExitValue(0);\n+\n+        String logOptions = \"-Xlog:cds=debug,class+load,cds+class=debug\";\n+        String baseArchiveName = CDSTestUtils.getOutputFileName(\"lambda-base.jsa\");\n+        \/\/ Static dump based on the class list.\n+        dumpBaseArchive(baseArchiveName,\n+                        \"-XX:SharedClassListFile=\" + classListFileName,\n+                        logOptions,\n+                        \"-cp\", appJar, mainClass)\n+            \/\/ Expects 2 lambda proxy classes with LambdasWithSameKey as the\n+            \/\/ caller class in the static dump log.\n+            .assertNormalExit(output -> checkLambdas(output, lambdaPattern, 2));\n+\n+        String topArchiveName = getNewArchiveName(\"lambda-classes-top\");\n+\n+        \/\/ Dynamic dump with the static archive.\n+        dump2(baseArchiveName, topArchiveName,\n+                 logOptions,\n+                 \"-cp\", appJar, mainClass, \"run\")\n+            \/\/ Expects only 1 lambda proxy class with LambdasWithSameKey as the\n+            \/\/ caller class in the dynamic dump log.\n+            .assertNormalExit(output -> checkLambdas(output, lambdaPattern, 1));\n+\n+        \/\/ Run with both static and dynamic archives.\n+        run2(baseArchiveName, topArchiveName,\n+            logOptions,\n+            \"-cp\", appJar, mainClass, \"run\")\n+            \/\/ Two lambda proxy classes should be loaded from the static archive.\n+            .assertNormalExit(output -> checkLambdas(output, loadFromStatic, 2))\n+            \/\/ One lambda proxy class should be loaded from the dynamic archive.\n+            .assertNormalExit(output -> checkLambdas(output, loadFromTop, 1));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdasInTwoArchives.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -69,1 +69,1 @@\n-                output.shouldContain(\"Used all archived lambda proxy classes for: UsedAllArchivedLambdasApp run()Ljava\/lang\/Runnable;\")\n+                output.shouldContain(\"Used all dynamic archived lambda proxy classes for: UsedAllArchivedLambdasApp run()Ljava\/lang\/Runnable;\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/UsedAllArchivedLambdas.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This class is for generating lambda proxy classes with the same invoke dynamic\n+ * info such as: caller class, invoked name, invoked type, method type, etc.\n+ *\n+ *\/\n+\n+public class LambdasWithSameKey {\n+    public static void main(String args[]) {\n+        boolean isRun = (args.length == 1 && args[0].equals(\"run\")) ? true : false;\n+        {Runnable run1 = LambdasWithSameKey::myrun; run1.run();}\n+        {Runnable run1 = LambdasWithSameKey::myrun; run1.run();}\n+        if (isRun) {\n+            {Runnable run1 = LambdasWithSameKey::myrun; run1.run();}\n+        }\n+    }\n+\n+    static void myrun() {\n+        System.out.println(\"myrun\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/LambdasWithSameKey.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}