{"files":[{"patch":"@@ -193,10 +193,1 @@\n- * <h2><a id=unnamedClasses>Unnamed Classes<\/a><\/h2>\n- *\n- * A {@code class} file representing an {@linkplain #isUnnamedClass unnamed class}\n- * is generated by a Java compiler from a source file for an unnamed class.\n- * The {@code Class} object representing an unnamed class is top-level,\n- * {@linkplain #isSynthetic synthetic}, and {@code final}. While an\n- * unnamed class does <em>not<\/em> have a name in its Java source\n- * form, several of the name-related methods of {@code java.lang.Class}\n- * do return non-null and non-empty results for the {@code Class}\n- * object representing an unnamed class.\n+ * <h2><a id=implicitClasses>Implicit Classes<\/a><\/h2>\n@@ -205,1 +196,1 @@\n- * unnamed class, say {@code HelloWorld.java}, creates a\n+ * implicit class, say {@code HelloWorld.java}, creates a\n@@ -211,1 +202,1 @@\n- * For the {@code Class} object of an unnamed class {@code\n+ * For the {@code Class} object of an implicit class {@code\n@@ -215,2 +206,2 @@\n- * simple name} of such an unnamed class is the empty string and the\n- * {@linkplain #getCanonicalName canonical name} is {@code null}.\n+ * simple name} of such an implicit class is {@code \"HelloWorld\"} and the\n+ * {@linkplain #getCanonicalName canonical name} is {@code \"HelloWorld\"}.\n@@ -1812,1 +1803,1 @@\n-     * {@linkplain #isAnonymousClass() anonymous} or {@linkplain #isUnnamedClass() unnamed}.\n+     * {@linkplain #isAnonymousClass() anonymous}.\n@@ -1825,3 +1816,0 @@\n-        if (isUnnamedClass()) {\n-            return \"\";\n-        }\n@@ -1877,1 +1865,0 @@\n-     * <li>an {@linkplain #isUnnamedClass() unnamed class}\n@@ -1897,3 +1884,0 @@\n-        if (isUnnamedClass()) {\n-            return null;\n-        }\n@@ -1934,20 +1918,0 @@\n-    \/**\n-     * {@return {@code true} if and only if the underlying class\n-     * is an unnamed class}\n-     *\n-     * @apiNote\n-     * An unnamed class is not an {@linkplain #isAnonymousClass anonymous class}.\n-     *\n-     * @since 21\n-     *\n-     * @jls 7.3 Compilation Units\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n-                    reflective=true)\n-    public boolean isUnnamedClass() {\n-        return PreviewFeatures.isEnabled() && isSynthetic()\n-                                           && isTopLevelClass()\n-                                           && Modifier.isFinal(getModifiers());\n-    }\n-\n-\n@@ -1960,1 +1924,0 @@\n-     * An anonymous class is not an {@linkplain #isUnnamedClass() unnamed class}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":6,"deletions":43,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+        @JEP(number=999, title=\"Implicit Classes and Instance Main Methods\")\n+        IMPLICIT_CLASSES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java.orig","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","status":"copied"},{"patch":"@@ -30,2 +30,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -34,6 +32,0 @@\n-    private static boolean correctArgs(Method method) {\n-        int argc = method.getParameterCount();\n-\n-        return argc == 0 || argc == 1 && method.getParameterTypes()[0] == String[].class;\n-    }\n-\n@@ -41,1 +33,1 @@\n-     * Gather all the \"main\" methods in the class hierarchy.\n+     * {@return true if method mets the requirements of a main method}\n@@ -43,3 +35,2 @@\n-     * @param refc         the main class or super class\n-     * @param mains        accumulated main methods\n-     * @param isMainClass  the class is the main class and not a super class\n+     * @param method    method to test\n+     * @param argCount  number of expected arguments (0 or 1)\n@@ -47,65 +38,6 @@\n-    private static void gatherMains(Class<?> refc, List<Method> mains, boolean isMainClass) {\n-        if (refc != null && refc != Object.class) {\n-            for (Method method : refc.getDeclaredMethods()) {\n-                int mods = method.getModifiers();\n-                \/\/ Must be named \"main\", public|protected|package-private, not synthetic (bridge) and either\n-                \/\/ no arguments or one string array argument. Only statics in the Main class are acceptable.\n-                if (\"main\".equals(method.getName()) &&\n-                        !method.isSynthetic() &&\n-                        !Modifier.isPrivate(mods) &&\n-                        correctArgs(method) &&\n-                        (isMainClass || !Modifier.isStatic(mods)))\n-                {\n-                    mains.add(method);\n-                }\n-            }\n-\n-            gatherMains(refc.getSuperclass(), mains, false);\n-        }\n-    }\n-\n-    \/**\n-     * Comparator for two methods.\n-     * Priority order is;\n-     * sub-class < super-class.\n-     * static < non-static,\n-     * string arg < no arg and\n-     *\n-     * @param a  first method\n-     * @param b  second method\n-     *\n-     * @return -1, 0 or 1 to represent higher priority. equals priority or lesser priority.\n-     *\/\n-    private static int compareMethods(Method a, Method b) {\n-        Class<?> aClass = a.getDeclaringClass();\n-        Class<?> bClass = b.getDeclaringClass();\n-\n-        if (aClass != bClass) {\n-            if (bClass.isAssignableFrom(aClass)) {\n-                return -1;\n-            } else {\n-                return 1;\n-            }\n-        }\n-\n-        int aMods = a.getModifiers();\n-        int bMods = b.getModifiers();\n-        boolean aIsStatic = Modifier.isStatic(aMods);\n-        boolean bIsStatic = Modifier.isStatic(bMods);\n-\n-        if (aIsStatic && !bIsStatic) {\n-            return -1;\n-        } else if (!aIsStatic && bIsStatic) {\n-            return 1;\n-        }\n-\n-        int aCount = a.getParameterCount();\n-        int bCount = b.getParameterCount();\n-\n-        if (bCount < aCount) {\n-            return -1;\n-        } else if (aCount < bCount) {\n-            return 1;\n-        }\n-\n-        return 0;\n+    private static boolean isMainMethod(Method method, int argCount) {\n+        return !Modifier.isPrivate(method.getModifiers()) &&\n+                method.getParameterCount() == argCount &&\n+                (argCount == 0 || method.getParameterTypes()[0] == String[].class) &&\n+                method.getReturnType() == void.class &&\n+                \"main\".equals(method.getName());\n@@ -115,1 +47,1 @@\n-     * Return the traditional main method or null if not found.\n+     * Search up the superclass hierarchy for a qualified main method.\n@@ -117,1 +49,2 @@\n-     * @param mainClass main class\n+     * @param mainClass    Main class to start search from.\n+     * @param noArgs       true if no argument otherwise expects one String[] argument\n@@ -119,1 +52,1 @@\n-     * @return main method or null\n+     * @return main method meeting requirements\n@@ -121,7 +54,7 @@\n-    private static Method getTraditionalMain(Class<?> mainClass) {\n-        try {\n-            Method traditionalMain = mainClass.getMethod(\"main\", String[].class);\n-            int mods = traditionalMain.getModifiers();\n-\n-            if (Modifier.isStatic(mods) && Modifier.isPublic(mods) && traditionalMain.getReturnType() == void.class) {\n-                return traditionalMain;\n+    private static Method findMainMethod(Class<?> mainClass, boolean noArgs) {\n+        int argCount = noArgs ? 0 : 1;\n+        for ( ; mainClass != null && mainClass != Object.class; mainClass = mainClass.getSuperclass()) {\n+            for (Method method : mainClass.getDeclaredMethods()) {\n+                if (isMainMethod(method, argCount)) {\n+                    return method;\n+                }\n@@ -129,2 +62,0 @@\n-        } catch (NoSuchMethodException ex) {\n-            \/\/ not found\n@@ -137,1 +68,1 @@\n-     * {@return priority main method if none found}\n+     * {@return qualified main method}\n@@ -141,1 +72,1 @@\n-     * @throws NoSuchMethodException when not preview and no method found\n+     * @throws NoSuchMethodException when no main method found\n@@ -144,4 +75,2 @@\n-        boolean isTraditionMain = !PreviewFeatures.isEnabled();\n-        if (isTraditionMain) {\n-            return mainClass.getMethod(\"main\", String[].class);\n-        }\n+        boolean useTraditionMain = !PreviewFeatures.isEnabled();\n+        boolean isTraditionalMain = false;\n@@ -149,2 +78,1 @@\n-        List<Method> mains = new ArrayList<>();\n-        gatherMains(mainClass, mains, true);\n+        Method mainMethod = findMainMethod(mainClass, false);\n@@ -152,2 +80,5 @@\n-        if (mains.isEmpty()) {\n-            throw new NoSuchMethodException(\"No main method found\");\n+        if (mainMethod == null) {\n+            mainMethod = findMainMethod(mainClass, true);\n+        } else {\n+            int mods = mainMethod.getModifiers();\n+            isTraditionalMain = Modifier.isStatic(mods) && Modifier.isPublic(mods);\n@@ -156,9 +87,2 @@\n-        if (1 < mains.size()) {\n-            mains.sort(MainMethodFinder::compareMethods);\n-        }\n-\n-        Method mainMethod = mains.get(0);\n-        Method traditionalMain = getTraditionalMain(mainClass);\n-\n-        if (traditionalMain != null && !traditionalMain.equals(mainMethod)) {\n-            System.err.println(\"WARNING: \\\"\" + mains.get(0) + \"\\\" chosen over \\\"\" + traditionalMain + \"\\\"\");\n+        if (mainMethod == null || useTraditionMain && !isTraditionalMain) {\n+            throw new NoSuchMethodException(mainClass.getName() + \".main(String[])\");\n@@ -167,1 +91,1 @@\n-        return mains.get(0);\n+        return mainMethod;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":33,"deletions":109,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -862,1 +862,1 @@\n-            abort(le, \"java.launcher.cls.error6\", cn,\n+            abort(le, \"java.launcher.cls.error4\", cn,\n@@ -921,1 +921,1 @@\n-            abort(null, \"java.launcher.cls.error4\", mainClass.getName(),\n+            abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n@@ -925,1 +925,1 @@\n-                abort(e, \"java.launcher.module.error5\",\n+                abort(e, \"java.launcher.module.error3\",\n@@ -929,1 +929,1 @@\n-                abort(e, \"java.launcher.cls.error7\", mainClass.getName(),\n+                abort(e, \"java.launcher.cls.error5\", mainClass.getName(),\n@@ -936,18 +936,2 @@\n-        \/*\n-         * findMainMethod (above) will choose the correct method, based\n-         * on its name and parameter type, however, we still have to\n-         * ensure that the method is static (non-preview) and returns a void.\n-         *\/\n-        int mods = mainMethod.getModifiers();\n-        boolean isStatic = Modifier.isStatic(mods);\n-        boolean isPublic = Modifier.isPublic(mods);\n-        boolean noArgs = mainMethod.getParameterCount() == 0;\n-\n-        if (!PreviewFeatures.isEnabled()) {\n-            if (!isStatic || !isPublic || noArgs) {\n-                abort(null, \"java.launcher.cls.error2\", \"static\",\n-                      mainMethod.getDeclaringClass().getName());\n-            }\n-        }\n-\n-        if (!isStatic) {\n+        if (!Modifier.isStatic(mainMethod.getModifiers())) {\n+            String className = mainMethod.getDeclaringClass().getName();\n@@ -955,2 +939,1 @@\n-                abort(null, \"java.launcher.cls.error9\",\n-                        mainMethod.getDeclaringClass().getName());\n+                abort(null, \"java.launcher.cls.error7\", className);\n@@ -961,2 +944,1 @@\n-                    abort(null, \"java.launcher.cls.error8\",\n-                          mainMethod.getDeclaringClass().getName());\n+                    abort(null, \"java.launcher.cls.error6\", className);\n@@ -965,2 +947,1 @@\n-                abort(null, \"java.launcher.cls.error8\",\n-                      mainMethod.getDeclaringClass().getName());\n+                abort(null, \"java.launcher.cls.error6\", className);\n@@ -969,5 +950,0 @@\n-\n-        if (mainMethod.getReturnType() != java.lang.Void.TYPE) {\n-            abort(null, \"java.launcher.cls.error3\",\n-                  mainMethod.getDeclaringClass().getName());\n-        }\n@@ -1125,1 +1101,1 @@\n-                abort(null, \"java.launcher.cls.error5\");\n+                abort(null, \"java.launcher.cls.error3\");\n@@ -1131,1 +1107,1 @@\n-                abort(null, \"java.launcher.cls.error5\");\n+                abort(null, \"java.launcher.cls.error3\");\n@@ -1152,1 +1128,1 @@\n-                abort(ex, \"java.launcher.cls.error5\", ex);\n+                abort(ex, \"java.launcher.cls.error3\", ex);\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":12,"deletions":36,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -241,7 +241,0 @@\n-    Error: Main method is not {0} in class {1}, please define the main method as:\\n\\\n-\\   public static void main(String[] args)\n-java.launcher.cls.error3=\\\n-    Error: Main method must return a value of type void in class {0}, please \\n\\\n-    define the main method as:\\n\\\n-\\   public static void main(String[] args)\n-java.launcher.cls.error4=\\\n@@ -251,1 +244,1 @@\n-java.launcher.cls.error5=\\\n+java.launcher.cls.error3=\\\n@@ -253,1 +246,1 @@\n-java.launcher.cls.error6=\\\n+java.launcher.cls.error4=\\\n@@ -256,1 +249,1 @@\n-java.launcher.cls.error7=\\\n+java.launcher.cls.error5=\\\n@@ -259,1 +252,1 @@\n-java.launcher.cls.error8=\\\n+java.launcher.cls.error6=\\\n@@ -263,1 +256,1 @@\n-java.launcher.cls.error9=\\\n+java.launcher.cls.error7=\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -180,7 +180,0 @@\n-     * <p>If the environment is configured to support {@linkplain\n-     * TypeElement#isUnnamed unnamed classes}, the name argument is\n-     * used to provide the leading component of the name used for the\n-     * output file. For example {@code filer.createSourceFile(\"Foo\")}\n-     * to create an unnamed class hosted in {@code Foo.java}. All\n-     * unnamed classes must be in an unnamed package.\n-     *\n@@ -266,7 +259,0 @@\n-     * <p>If the environment is configured to support {@linkplain\n-     * TypeElement#isUnnamed unnamed classes}, the name argument is\n-     * used to provide the leading component of the name used for the\n-     * output file. For example {@code filer.createClassFile(\"Foo\")} to\n-     * create an unnamed class hosted in {@code Foo.class}. All unnamed\n-     * classes must be in an unnamed package.\n-     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-     * For local, anonymous, and {@linkplain #isUnnamed() unnamed} classes, which do not have canonical\n+     * For local, and anonymous classes, which do not have canonical\n@@ -174,1 +174,0 @@\n-     * @jls 7.3 Compilation Units\n@@ -184,4 +183,0 @@\n-     * For an {@linkplain #isUnnamed() unnamed} class, a name matching\n-     * the base name of the hosting file, minus any extension, is\n-     * returned.\n-     *\n@@ -195,16 +190,0 @@\n-    \/**\n-     * {@return {@code true} if this is an unnamed class and {@code\n-     * false} otherwise}\n-     *\n-     * @implSpec\n-     * The default implementation of this method returns {@code false}.\n-     *\n-     * @jls 7.3 Compilation Units\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n-                    reflective=true)\n-    default boolean isUnnamed() {\n-        return false;\n-    }\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -447,3 +447,0 @@\n-                if ((c.flags_field & UNNAMED_CLASS) != 0) {\n-                    syms.removeClass(ps.modle, flatname);\n-                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    \/** Class is a unnamed top level class.\n+    \/** Class is a implicit top level class.\n@@ -128,1 +128,1 @@\n-    public static final int UNNAMED_CLASS    = 1<<19;\n+    public static final int IMPLICIT_CLASS    = 1<<19;\n@@ -502,1 +502,1 @@\n-        UNNAMED_CLASS(Flags.UNNAMED_CLASS),\n+        IMPLICIT_CLASS(Flags.IMPLICIT_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-            case UNNAMED_CLASSES -> true;\n+            case IMPLICIT_CLASSES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java.orig","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","status":"copied"},{"patch":"@@ -249,0 +249,1 @@\n+        IMPLICIT_CLASSES(JDK21, Fragments.FeatureImplicitClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java.orig","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","status":"copied"},{"patch":"@@ -1259,1 +1259,0 @@\n-    @SuppressWarnings(\"preview\") \/\/ isUnnamed()\n@@ -1373,1 +1372,1 @@\n-             return isUnnamed() ? fullname.subName(0, 0) \/* empty name *\/ : fullname;\n+             return fullname;\n@@ -1554,1 +1553,1 @@\n-            if (owner.kind == PCK) \/\/ Handles unnamed classes as well\n+            if (owner.kind == PCK) \/\/ Handles implicit classes as well\n@@ -1645,5 +1644,0 @@\n-\n-        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-        public boolean isUnnamed() {\n-            return (flags_field & Flags.UNNAMED_CLASS) != 0 ;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5551,1 +5551,1 @@\n-                if ((c.flags_field & Flags.UNNAMED_CLASS) != 0) {\n+                if ((c.flags_field & Flags.IMPLICIT_CLASS) != 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2288,1 +2288,1 @@\n-            log.error(pos, Errors.UnnamedClassDoesNotHaveMainMethod);\n+            log.error(pos, Errors.ImplicitClassDoesNotHaveMainMethod);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-            if ((tree.mods.flags & UNNAMED_CLASS) != 0) {\n+            if ((tree.mods.flags & IMPLICIT_CLASS) != 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2739,8 +2739,0 @@\n-        if (previewClassFile) {\n-            if ((c.flags_field & SYNTHETIC) != 0 &&\n-                    c.owner.kind == PCK &&\n-                    (c.flags_field & AUXILIARY) == 0 &&\n-                    (c.flags_field & FINAL) != 0) {\n-                c.flags_field |= UNNAMED_CLASS;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -410,2 +410,2 @@\n-        String mainClassName = (mainClass.isUnnamed() ? mainClass.getSimpleName()\n-                                                      : mainClass.getQualifiedName()).toString();\n+        String mainClassName = mainClass.getQualifiedName().toString();\n+\n@@ -444,13 +444,1 @@\n-        int mods = mainMethod.getModifiers();\n-        boolean isStatic = Modifier.isStatic(mods);\n-        boolean isPublic = Modifier.isPublic(mods);\n-        boolean noArgs = mainMethod.getParameterCount() == 0;\n-\n-        if (!PreviewFeatures.isEnabled() && (!isStatic || !isPublic)) {\n-            throw new Fault(Errors.MainNotPublicStatic);\n-        }\n-\n-        if (!mainMethod.getReturnType().equals(void.class)) {\n-            throw new Fault(Errors.MainNotVoid);\n-        }\n-\n+        boolean isStatic = Modifier.isStatic(mainMethod.getModifiers());\n@@ -481,1 +469,1 @@\n-            if (noArgs) {\n+            if (mainMethod.getParameterCount() == 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3920,1 +3920,1 @@\n-        boolean isUnnamedClass = false;\n+        boolean isImplicitClass = false;\n@@ -3987,1 +3987,1 @@\n-                \/\/ unnamed classes did not exist and error reporting\n+                \/\/ implicit classes did not exist and error reporting\n@@ -3989,1 +3989,1 @@\n-                if (Feature.UNNAMED_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                if (Feature.IMPLICIT_CLASSES.allowedInSource(source) && !isDeclaration()) {\n@@ -4001,1 +4001,1 @@\n-                    checkSourceLevel(token.pos, Feature.UNNAMED_CLASSES);\n+                    checkSourceLevel(token.pos, Feature.IMPLICIT_CLASSES);\n@@ -4003,1 +4003,1 @@\n-                    isUnnamedClass = true;\n+                    isImplicitClass = true;\n@@ -4015,1 +4015,1 @@\n-        List<JCTree> topLevelDefs = isUnnamedClass ?  constructUnnamedClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ?  construcImplictClass(defs.toList()) : defs.toList();\n@@ -4030,2 +4030,2 @@\n-    \/\/ Restructure top level to be an unnamed class.\n-    private List<JCTree> constructUnnamedClass(List<JCTree> origDefs) {\n+    \/\/ Restructure top level to be an implicit class.\n+    private List<JCTree> construcImplictClass(List<JCTree> origDefs) {\n@@ -4037,1 +4037,1 @@\n-                log.error(def.pos(), Errors.UnnamedClassShouldNotHavePackageDeclaration);\n+                log.error(def.pos(), Errors.ImplicitClassShouldNotHavePackageDeclaration);\n@@ -4056,4 +4056,4 @@\n-        JCModifiers unnamedMods = F.at(Position.NOPOS)\n-                .Modifiers(Flags.FINAL|Flags.SYNTHETIC|Flags.UNNAMED_CLASS, List.nil());\n-        JCClassDecl unnamed = F.at(primaryPos).ClassDef(\n-                unnamedMods, name, List.nil(), null, List.nil(), List.nil(),\n+        JCModifiers implicitMods = F.at(Position.NOPOS)\n+                .Modifiers(Flags.FINAL|Flags.MANDATED|Flags.IMPLICIT_CLASS, List.nil());\n+        JCClassDecl implicit = F.at(primaryPos).ClassDef(\n+                implicitMods, name, List.nil(), null, List.nil(), List.nil(),\n@@ -4061,1 +4061,1 @@\n-        topDefs.append(unnamed);\n+        topDefs.append(implicit);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-                \/\/ Don't print out the constructor of an anonymous or unnamed class\n+                \/\/ Don't print out the constructor of an anonymous\n@@ -139,7 +139,0 @@\n-                    }).visit(enclosing)\n-                    || \/\/ Don't print the constructor of an unnamed class\n-                    (new SimpleElementVisitor14<Boolean, Void>(false) {\n-                        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-                        public Boolean visitType(TypeElement e, Void p) {\n-                            return e.isUnnamed();\n-                        }\n@@ -225,8 +218,0 @@\n-            } else if (e.isUnnamed()) {\n-                writer.println(\"\/\/ Unnamed class in file whose name starts with \" + e.getSimpleName());\n-\n-                for(Element element : e.getEnclosedElements()) {\n-                    this.visit(element);\n-                }\n-\n-                return this;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -519,2 +519,2 @@\n-compiler.err.unnamed.class.should.not.have.package.declaration=\\\n-    unnamed class should not have package declaration\n+compiler.err.implicit.class.should.not.have.package.declaration=\\\n+    implicit class should not have package declaration\n@@ -522,2 +522,2 @@\n-compiler.err.unnamed.class.does.not.have.main.method=\\\n-    unnamed class does not have main method in the form of void main() or void main(String[] args)\n+compiler.err.implicit.class.does.not.have.main.method=\\\n+    implicit class does not have main method in the form of void main() or void main(String[] args)\n@@ -3200,0 +3200,3 @@\n+compiler.misc.feature.implicit.classes=\\\n+    implicit classes\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1164,1 +1164,1 @@\n-        return sym.kind == TYP && (sym.flags_field & Flags.UNNAMED_CLASS) != 0;\n+        return sym.kind == TYP && (sym.flags_field & Flags.IMPLICIT_CLASS) != 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -989,1 +989,1 @@\n-        if (toolEnv.isSynthetic((Symbol) e) && !toolEnv.isUnnamed((Symbol) e)) {\n+        if (toolEnv.isSynthetic((Symbol) e)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ElementsTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,4 +177,0 @@\n-    boolean isUnnamed(Symbol sym) {\n-        return (sym.flags() & Flags.UNNAMED_CLASS) != 0;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolEnvironment.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+tools\/javac\/processing\/model\/element\/TestUnnamedClass.java                      8315458    generic-all    superceded by implicit classes\n","filename":"test\/langtools\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Allow javadoc to process unnamed classes\n+ * @summary Allow javadoc to process implicit classes\n@@ -31,1 +31,1 @@\n- * @run main TestUnnamed\n+ * @run main TestImplicit\n@@ -42,1 +42,1 @@\n-public class TestUnnamed extends JavadocTester {\n+public class TestImplicit extends JavadocTester {\n@@ -49,1 +49,1 @@\n-        new TestUnnamed().runTests();\n+        new TestImplicit().runTests();\n@@ -53,1 +53,1 @@\n-    public void testUnnamed(Path base) throws IOException {\n+    public void testImplicit(Path base) throws IOException {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamed\/TestImplicit.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamed\/TestUnnamed.java","status":"renamed"},{"patch":"@@ -70,0 +70,1 @@\n+compiler.misc.feature.unnamed.classes                   # obsolete feature\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.misc.feature.unnamed.classes\n+ \/\/ key: compiler.misc.feature.implicit.classes\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.err.unnamed.class.should.not.have.package.declaration\n+ \/\/ key: compiler.err.implicit.class.should.not.have.package.declaration\n@@ -29,1 +29,1 @@\n-package unnamed.classes;\n+package implicit.classes;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassHasPackage.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- \/\/ key: compiler.err.unnamed.class.does.not.have.main.method\n+ \/\/ key: compiler.err.implicit.class.does.not.have.main.method\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassNoMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-                \"error: 'main' method is not declared 'public static'\");\n+                \"error: can't find main(String[]) method in class: NotStatic\");\n@@ -575,1 +575,1 @@\n-                \"error: 'main' method is not declared with a return type of 'void'\");\n+                \"error: can't find main(String[]) method in class: NotVoid\");\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2475,1 +2475,1 @@\n-                     \/*synthetic*\/ final class Test {\n+                     final class Test {\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Ensure proper error position for the \"unnamed classes not supported\" error\n+ * @summary Ensure proper error position for the \"implicit classes not supported\" error\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/SourceLevelErrorPosition.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SourceLevelErrorPosition.java:8:1: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.classes)\n+SourceLevelErrorPosition.java:8:1: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.implicit.classes)\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/SourceLevelErrorPosition.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}