{"files":[{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8306112\n- * @enablePreview\n- * @build Unnamed TestUnnamedClass\n- * @run main TestUnnamedClass\n- * @summary Basic checks of java.lang.Class support for unnamed classes\n- *\/\n-\n-import java.lang.reflect.Modifier;\n-\n-public class TestUnnamedClass {\n-    public static void main(String... args) throws Exception {\n-        Class<?> unnamedClass = Class.forName(\"Unnamed\");\n-\n-        \/*\n-         * From JEP 445 JLS changes:\n-         *\n-         * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n-         * properties:\n-         * It is always a top level class.\n-         * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n-         * It is never abstract (8.1.1.1).\n-         * It is always final (8.1.1.2).\n-         * It is always a member of an unnamed package (7.4.2) and has package access.\n-         * Its direct superclass type is always Object (8.1.4).\n-         * It never has any direct superinterface types (8.1.5).\n-         *\/\n-\n-        check(unnamedClass.isUnnamedClass(), \"Unnamed class was isUnnamedClass() false\");\n-\n-        check(!(unnamedClass.isInterface() ||\n-                unnamedClass.isEnum()      ||\n-                unnamedClass.isRecord()    ||\n-                unnamedClass.isHidden()),\n-              \"Unnamed class was not a normal class\");\n-\n-        check(!(unnamedClass.isLocalClass()  ||\n-                unnamedClass.isMemberClass() ||\n-                unnamedClass.isPrimitive()   ||\n-                unnamedClass.isArray()),\n-              \"Unnamed class was not top-level\");\n-\n-        check(\"Unnamed\".equals(unnamedClass.getName()),     \"Unexpected Class.getName result\");\n-        check(\"Unnamed\".equals(unnamedClass.getTypeName()), \"Unexpected Class.getTypeName result\");\n-        check(\"\".equals(unnamedClass.getSimpleName()),      \"Unexpected Class.getSimpleName result\");\n-        check(unnamedClass.getCanonicalName() == null,      \"Unexpected non-null Class.getCanonicalName\");\n-\n-        int modifiers = unnamedClass.getModifiers();\n-        check((modifiers & Modifier.ABSTRACT) == 0,    \"Unnamed class was abstract\");\n-        check((modifiers & Modifier.FINAL) != 0,       \"Unnamed class was not final\");\n-        check((modifiers & (Modifier.PUBLIC  |\n-                            Modifier.PRIVATE |\n-                            Modifier.PROTECTED)) == 0, \"Unnamed class was not package access\");\n-\n-        check(unnamedClass.isSynthetic(), \"Unnamed class was not synthetic\");\n-\n-        check(\"\".equals(unnamedClass.getPackage().getName()), \"Unnamed class not in an unnamed package\");\n-\n-        check(unnamedClass.getSuperclass() == Object.class, \"Superclass was not java.lang.Object\");\n-\n-        check(unnamedClass.getInterfaces().length == 0, \"Unnamed class had super interfaces\");\n-    }\n-\n-    private static void check(boolean predicate, String message) {\n-        if (!predicate) {\n-            throw new RuntimeException(message);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Class\/UnnamedClass\/TestUnnamedClass.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -71,1 +71,0 @@\n-tools\/javac\/processing\/model\/element\/TestUnnamedClass.java                      8315458    generic-all    superceded by implicit classes\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8306112 8309568\n- * @summary Test basic processing of unnamed classes.\n- * @library \/tools\/javac\/lib\n- * @modules java.compiler\n- *          jdk.compiler\n- * @build   JavacTestingAbstractProcessor TestUnnamedClass\n- * @compile         -processor TestUnnamedClass            --enable-preview --release ${jdk.version}                            Anonymous.java\n- * @clean Nameless.java\n- * @compile\/process -processor TestUnnamedClass -proc:only --enable-preview --release ${jdk.version} -Xprefer:newer -AclassOnly Anonymous Nameless\n- *\/\n-\n-\/\/ The first @compile line processes Anonymous.java and a\n-\/\/ Nameless.java class generated using the Filer. Both of those\n-\/\/ unnamed classes are then compiled down to class files.  The second\n-\/\/ @compile line, as directed by -Xprefer:newer, builds and checks the\n-\/\/ language model objects constructed from those class files, ignoring\n-\/\/ any source files for those types.\n-\n-import java.lang.annotation.*;\n-import java.io.Writer;\n-import java.util.List;\n-import java.util.Set;\n-import javax.annotation.processing.*;\n-import javax.lang.model.element.*;\n-import javax.lang.model.util.Elements;\n-import static javax.lang.model.util.ElementFilter.*;\n-import javax.tools.JavaFileObject;\n-\n-\/**\n- * Test annotation processing representation of unnamed classes\n- * constructed from either a source file or a class file.\n- *\/\n-@SuppressWarnings(\"preview\")\n-@SupportedOptions(\"classOnly\")\n-public class TestUnnamedClass  extends JavacTestingAbstractProcessor {\n-\n-    private static int round  = 0;\n-    private static int checkedClassesCount = 0;\n-    private static boolean classOnly = false;\n-\n-    public boolean process(Set<? extends TypeElement> annotations,\n-                           RoundEnvironment roundEnv) {\n-        if (round == 0) {\n-            classOnly = options.containsKey(\"classOnly\");\n-\n-            checkRoots(roundEnv); \/\/ Check any files from the comamnd line\n-\n-            \/\/ Don't generate any files if testing pre-existing class files\n-            if (!classOnly) {\n-                generateUnnamed();\n-            }\n-        } else {\n-            if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\n-                checkRoots(roundEnv);\n-            } else { \/\/ Should have checked at least one class before processing is over\n-                if (checkedClassesCount == 0) {\n-                    messager.printError(\"No unnamed classes checked.\");\n-                }\n-            }\n-        }\n-\n-        round++;\n-        return true;\n-    }\n-\n-    private void checkRoots(RoundEnvironment roundEnv) {\n-        int checks = 0;\n-        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\n-            checks++;\n-            checkUnnamedClassProperties(type);\n-        }\n-        if (checks == 0) {\n-            messager.printError(\"No checking done of any candidate unnamed classes.\");\n-        }\n-    }\n-\n-    private void generateUnnamed() {\n-        try {\n-            String unnamedSource = \"\"\"\n-            void main() {\n-                System.out.println(\"Nameless, but not voiceless.\");\n-            }\n-            \"\"\";\n-\n-            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\n-            try(Writer w = outputFile.openWriter()) {\n-                w.append(unnamedSource);\n-            }\n-        } catch (java.io.IOException ioe) {\n-            throw new RuntimeException(ioe);\n-        }\n-    }\n-\n-    \/*\n-     * From JEP 445 JLS changes:\n-     *\n-     * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n-     * properties:\n-     * It is always a top level class.\n-     * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n-     * It is never abstract (8.1.1.1).\n-     * It is always final (8.1.1.2).\n-     * It is always a member of an unnamed package (7.4.2) and has package access.\n-     * Its direct superclass type is always Object (8.1.4).\n-     * It never has any direct superinterface types (8.1.5).\n-     *\n-     * The body of the class contains every ClassMemberDeclaration\n-     * from the unnamed class compilation unit. It is not possible for\n-     * an unnamed class compilation unit to declare an instance\n-     * initializer, static initializer, or constructor.\n-     *\n-     * It has an implicitly declared default constructor (8.8.9).\n-     * All members of this class, including any implicitly declared\n-     * members, are subject to the usual rules for member declarations\n-     * in a class.\n-     *\n-     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\n-     *\/\n-    void checkUnnamedClassProperties(TypeElement unnamedClass) {\n-        checkedClassesCount++;\n-        Name expectedName = unnamedClass.getSimpleName();\n-\n-        System.out.println(\"Checking \" + expectedName);\n-\n-        if (unnamedClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n-            messager.printError(\"Unnamed class is not top-level.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.isUnnamed()) {\n-            messager.printError(\"Unnamed class is _not_ indicated as such.\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getSimpleName().isEmpty()) {\n-            messager.printError(\"Unnamed class has an empty simple name.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getQualifiedName().isEmpty()) {\n-            messager.printError(\"Unnamed class does _not_ have an empty qualified name.\", unnamedClass);\n-        }\n-\n-        Name binaryName = elements.getBinaryName(unnamedClass);\n-        if (!expectedName.equals(binaryName)) {\n-            messager.printError(\"Unnamed has unexpected binary name\" + binaryName + \".\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getModifiers().contains(Modifier.ABSTRACT)) {\n-            messager.printError(\"Unnamed class is abstract.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getModifiers().contains(Modifier.FINAL)) {\n-            messager.printError(\"Unnamed class is _not_ final.\", unnamedClass);\n-        }\n-\n-        if (!elements.getPackageOf(unnamedClass).isUnnamed()) {\n-            messager.printError(\"Unnamed class is _not_ in an unnamed package.\", unnamedClass);\n-        }\n-\n-        if (unnamedClass.getModifiers().contains(Modifier.PUBLIC)  ||\n-            unnamedClass.getModifiers().contains(Modifier.PRIVATE) ||\n-            unnamedClass.getModifiers().contains(Modifier.PROTECTED)) {\n-            messager.printError(\"Unnamed class does _not_ have package access.\", unnamedClass);\n-        }\n-\n-        if ( !types.isSameType(unnamedClass.getSuperclass(),\n-                               elements.getTypeElement(\"java.lang.Object\").asType())) {\n-            messager.printError(\"Unnamed class does _not_ have java.lang.Object as a superclass.\", unnamedClass);\n-        }\n-\n-        if (!unnamedClass.getInterfaces().isEmpty()) {\n-            messager.printError(\"Unnamed class has superinterfaces.\", unnamedClass);\n-        }\n-\n-        List<ExecutableElement> ctors = constructorsIn(unnamedClass.getEnclosedElements());\n-        if (ctors.size() != 1 ) {\n-            messager.printError(\"Did not find exactly one constructor\", unnamedClass);\n-        }\n-\n-        if (!classOnly) {\n-            \/\/ Mandated-ness of default constructors not preserved in class files\n-            ExecutableElement ctor = ctors.getFirst();\n-            if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\n-                messager.printError(\"Constructor was not marked as mandated\", ctor);\n-            }\n-        }\n-\n-        List<ExecutableElement> methods = methodsIn(unnamedClass.getEnclosedElements());\n-        \/\/ Just look for a method named \"main\"; don't check the other details.\n-        boolean mainFound = false;\n-        Name mainName = elements.getName(\"main\");\n-        for (var method : methods) {\n-            if (method.getSimpleName().equals(mainName)) {\n-                mainFound = true;\n-                break;\n-            }\n-        }\n-\n-        if (!mainFound) {\n-            messager.printError(\"No main mehtod found\", unnamedClass);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedClass.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"}]}