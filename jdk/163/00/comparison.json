{"files":[{"patch":"@@ -282,1 +282,1 @@\n-    while (flag->_name != NULL) {                                 \\\n+    while (flag->name() != NULL) {                                \\\n@@ -286,1 +286,1 @@\n-          event.set_name(flag->_name);                            \\\n+          event.set_name(flag->name());                           \\\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    JVMCI_ERROR_NULL(\"VM flag %s has unsupported type %s\", flag->_name, flag->_type);\n+    JVMCI_ERROR_NULL(\"VM flag %s has unsupported type %s\", flag->name(), flag->type_string());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcConfig.hpp\"\n@@ -28,3 +29,0 @@\n-#include \"gc\/shared\/gcConfig.hpp\"\n-#include \"utilities\/defaultStream.hpp\"\n-#include \"utilities\/ostream.hpp\"\n@@ -32,0 +30,1 @@\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n@@ -33,0 +32,2 @@\n+#include \"utilities\/defaultStream.hpp\"\n+#include \"utilities\/ostream.hpp\"\n@@ -190,1 +191,1 @@\n-  if (JVMFlag::boolAtPut(jvmciEnableFlag, &value, origin) != JVMFlag::SUCCESS) {\n+  if (JVMFlagAccess::boolAtPut(jvmciEnableFlag, &value, origin) != JVMFlag::SUCCESS) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -756,1 +756,1 @@\n-  if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) {\n+  if (!JVMFlagLimit::check_all_constraints(JVMFlagConstraintPhase::AfterMemoryInit)) {\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n@@ -1208,2 +1209,2 @@\n-template <typename T>\n-static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {\n+template <typename T, int type_enum>\n+static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value) {\n@@ -1217,1 +1218,1 @@\n-  JVMFlag::Error result = (*TAt)(flag, value);\n+  JVMFlag::Error result = JVMFlagAccess::get<T, type_enum>(flag, value);\n@@ -1222,2 +1223,2 @@\n-template <typename T>\n-static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {\n+template <typename T, int type_enum>\n+static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value) {\n@@ -1231,1 +1232,1 @@\n-  JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);\n+  JVMFlag::Error result = JVMFlagAccess::set<T, type_enum>(flag, value, JVMFlag::INTERNAL);\n@@ -1287,1 +1288,1 @@\n-  if (GetVMFlag <bool> (thread, env, name, &result, &JVMFlag::boolAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(bool)> (thread, env, name, &result)) {\n@@ -1296,1 +1297,1 @@\n-  if (GetVMFlag <int> (thread, env, name, &result, &JVMFlag::intAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(int)> (thread, env, name, &result)) {\n@@ -1305,1 +1306,1 @@\n-  if (GetVMFlag <uint> (thread, env, name, &result, &JVMFlag::uintAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(uint)> (thread, env, name, &result)) {\n@@ -1314,1 +1315,1 @@\n-  if (GetVMFlag <intx> (thread, env, name, &result, &JVMFlag::intxAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(intx)> (thread, env, name, &result)) {\n@@ -1323,1 +1324,1 @@\n-  if (GetVMFlag <uintx> (thread, env, name, &result, &JVMFlag::uintxAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(uintx)> (thread, env, name, &result)) {\n@@ -1332,1 +1333,1 @@\n-  if (GetVMFlag <uint64_t> (thread, env, name, &result, &JVMFlag::uint64_tAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(uint64_t)> (thread, env, name, &result)) {\n@@ -1341,1 +1342,1 @@\n-  if (GetVMFlag <size_t> (thread, env, name, &result, &JVMFlag::size_tAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(size_t)> (thread, env, name, &result)) {\n@@ -1350,1 +1351,1 @@\n-  if (GetVMFlag <double> (thread, env, name, &result, &JVMFlag::doubleAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(double)> (thread, env, name, &result)) {\n@@ -1359,1 +1360,1 @@\n-  if (GetVMFlag <ccstr> (thread, env, name, &ccstrResult, &JVMFlag::ccstrAt)) {\n+  if (GetVMFlag <JVM_FLAG_TYPE(ccstr)> (thread, env, name, &ccstrResult)) {\n@@ -1370,1 +1371,1 @@\n-  SetVMFlag <bool> (thread, env, name, &result, &JVMFlag::boolAtPut);\n+  SetVMFlag <JVM_FLAG_TYPE(bool)> (thread, env, name, &result);\n@@ -1375,1 +1376,1 @@\n-  SetVMFlag <int> (thread, env, name, &result, &JVMFlag::intAtPut);\n+  SetVMFlag <JVM_FLAG_TYPE(int)> (thread, env, name, &result);\n@@ -1380,1 +1381,1 @@\n-  SetVMFlag <uint> (thread, env, name, &result, &JVMFlag::uintAtPut);\n+  SetVMFlag <JVM_FLAG_TYPE(uint)> (thread, env, name, &result);\n@@ -1385,1 +1386,1 @@\n-  SetVMFlag <intx> (thread, env, name, &result, &JVMFlag::intxAtPut);\n+  SetVMFlag <JVM_FLAG_TYPE(intx)> (thread, env, name, &result);\n@@ -1390,1 +1391,1 @@\n-  SetVMFlag <uintx> (thread, env, name, &result, &JVMFlag::uintxAtPut);\n+  SetVMFlag <JVM_FLAG_TYPE(uintx)> (thread, env, name, &result);\n@@ -1395,1 +1396,1 @@\n-  SetVMFlag <uint64_t> (thread, env, name, &result, &JVMFlag::uint64_tAtPut);\n+  SetVMFlag <JVM_FLAG_TYPE(uint64_t)> (thread, env, name, &result);\n@@ -1400,1 +1401,1 @@\n-  SetVMFlag <size_t> (thread, env, name, &result, &JVMFlag::size_tAtPut);\n+  SetVMFlag <JVM_FLAG_TYPE(size_t)> (thread, env, name, &result);\n@@ -1405,1 +1406,1 @@\n-  SetVMFlag <double> (thread, env, name, &result, &JVMFlag::doubleAtPut);\n+  SetVMFlag <JVM_FLAG_TYPE(double)> (thread, env, name, &result);\n@@ -1422,1 +1423,1 @@\n-    needFree = SetVMFlag <ccstr> (thread, env, name, &ccstrResult, &JVMFlag::ccstrAtPut);\n+    needFree = SetVMFlag <JVM_FLAG_TYPE(ccstr)> (thread, env, name, &ccstrResult);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n-#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n@@ -880,1 +879,1 @@\n-  if (JVMFlag::boolAtPut(flag, &value, origin) == JVMFlag::SUCCESS) {\n+  if (JVMFlagAccess::boolAtPut(flag, &value, origin) == JVMFlag::SUCCESS) {\n@@ -895,1 +894,1 @@\n-  if (JVMFlag::doubleAtPut(flag, &v, origin) == JVMFlag::SUCCESS) {\n+  if (JVMFlagAccess::doubleAtPut(flag, &v, origin) == JVMFlag::SUCCESS) {\n@@ -927,1 +926,1 @@\n-    return JVMFlag::intAtPut(flag, &int_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::intAtPut(flag, &int_v, origin) == JVMFlag::SUCCESS;\n@@ -930,1 +929,1 @@\n-    return JVMFlag::uintAtPut(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::uintAtPut(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n@@ -936,1 +935,1 @@\n-    return JVMFlag::intxAtPut(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::intxAtPut(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n@@ -939,1 +938,1 @@\n-    return JVMFlag::uintxAtPut(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::uintxAtPut(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n@@ -942,1 +941,1 @@\n-    return JVMFlag::uint64_tAtPut(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::uint64_tAtPut(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n@@ -945,1 +944,1 @@\n-    return JVMFlag::size_tAtPut(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::size_tAtPut(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n@@ -948,1 +947,1 @@\n-    return JVMFlag::doubleAtPut(flag, &double_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::doubleAtPut(flag, &double_v, origin) == JVMFlag::SUCCESS;\n@@ -955,1 +954,1 @@\n-  if (JVMFlag::ccstrAtPut(flag, &value, origin) != JVMFlag::SUCCESS) return false;\n+  if (JVMFlagAccess::ccstrAtPut(flag, &value, origin) != JVMFlag::SUCCESS) return false;\n@@ -963,1 +962,1 @@\n-  if (JVMFlag::ccstrAt(flag, &old_value) != JVMFlag::SUCCESS) return false;\n+  if (JVMFlagAccess::ccstrAt(flag, &old_value) != JVMFlag::SUCCESS) return false;\n@@ -980,1 +979,1 @@\n-  (void) JVMFlag::ccstrAtPut(flag, &value, origin);\n+  (void) JVMFlagAccess::ccstrAtPut(flag, &value, origin);\n@@ -1358,1 +1357,1 @@\n-                  fuzzy_matched->_name,\n+                  fuzzy_matched->name(),\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n@@ -32,1 +32,0 @@\n-#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n@@ -37,50 +36,0 @@\n-#define DEFAULT_RANGE_STR_CHUNK_SIZE 64\n-static char* create_range_str(const char *fmt, ...) {\n-  static size_t string_length = DEFAULT_RANGE_STR_CHUNK_SIZE;\n-  static char* range_string = NEW_C_HEAP_ARRAY(char, string_length, mtLogging);\n-\n-  int size_needed = 0;\n-  do {\n-    va_list args;\n-    va_start(args, fmt);\n-    size_needed = jio_vsnprintf(range_string, string_length, fmt, args);\n-    va_end(args);\n-\n-    if (size_needed < 0) {\n-      string_length += DEFAULT_RANGE_STR_CHUNK_SIZE;\n-      range_string = REALLOC_C_HEAP_ARRAY(char, range_string, string_length, mtLogging);\n-      guarantee(range_string != NULL, \"create_range_str string should not be NULL\");\n-    }\n-  } while (size_needed < 0);\n-\n-  return range_string;\n-}\n-\n-const char* JVMFlag::get_int_default_range_str() {\n-  return create_range_str(\"[ \" INT32_FORMAT_W(-25) \" ... \" INT32_FORMAT_W(25) \" ]\", INT_MIN, INT_MAX);\n-}\n-\n-const char* JVMFlag::get_uint_default_range_str() {\n-  return create_range_str(\"[ \" UINT32_FORMAT_W(-25) \" ... \" UINT32_FORMAT_W(25) \" ]\", 0, UINT_MAX);\n-}\n-\n-const char* JVMFlag::get_intx_default_range_str() {\n-  return create_range_str(\"[ \" INTX_FORMAT_W(-25) \" ... \" INTX_FORMAT_W(25) \" ]\", min_intx, max_intx);\n-}\n-\n-const char* JVMFlag::get_uintx_default_range_str() {\n-  return create_range_str(\"[ \" UINTX_FORMAT_W(-25) \" ... \" UINTX_FORMAT_W(25) \" ]\", 0, max_uintx);\n-}\n-\n-const char* JVMFlag::get_uint64_t_default_range_str() {\n-  return create_range_str(\"[ \" UINT64_FORMAT_W(-25) \" ... \" UINT64_FORMAT_W(25) \" ]\", 0, uint64_t(max_juint));\n-}\n-\n-const char* JVMFlag::get_size_t_default_range_str() {\n-  return create_range_str(\"[ \" SIZE_FORMAT_W(-25) \" ... \" SIZE_FORMAT_W(25) \" ]\", 0, SIZE_MAX);\n-}\n-\n-const char* JVMFlag::get_double_default_range_str() {\n-  return create_range_str(\"[ %-25.3f ... %25.3f ]\", DBL_MIN, DBL_MAX);\n-}\n-\n@@ -95,44 +44,0 @@\n-bool JVMFlag::is_bool() const {\n-  return strcmp(_type, \"bool\") == 0;\n-}\n-\n-bool JVMFlag::is_int() const {\n-  return strcmp(_type, \"int\")  == 0;\n-}\n-\n-bool JVMFlag::is_uint() const {\n-  return strcmp(_type, \"uint\")  == 0;\n-}\n-\n-bool JVMFlag::is_intx() const {\n-  return strcmp(_type, \"intx\")  == 0;\n-}\n-\n-bool JVMFlag::is_uintx() const {\n-  return strcmp(_type, \"uintx\") == 0;\n-}\n-\n-bool JVMFlag::is_uint64_t() const {\n-  return strcmp(_type, \"uint64_t\") == 0;\n-}\n-\n-bool JVMFlag::is_size_t() const {\n-  return strcmp(_type, \"size_t\") == 0;\n-}\n-\n-bool JVMFlag::is_double() const {\n-  return strcmp(_type, \"double\") == 0;\n-}\n-\n-bool JVMFlag::is_ccstr() const {\n-  return strcmp(_type, \"ccstr\") == 0 || strcmp(_type, \"ccstrlist\") == 0;\n-}\n-\n-bool JVMFlag::ccstr_accumulates() const {\n-  return strcmp(_type, \"ccstrlist\") == 0;\n-}\n-\n-JVMFlag::Flags JVMFlag::get_origin() const {\n-  return Flags(_flags & VALUE_ORIGIN_MASK);\n-}\n-\n@@ -145,44 +50,0 @@\n-bool JVMFlag::is_default() const {\n-  return (get_origin() == DEFAULT);\n-}\n-\n-bool JVMFlag::is_ergonomic() const {\n-  return (get_origin() == ERGONOMIC);\n-}\n-\n-bool JVMFlag::is_command_line() const {\n-  return (_flags & ORIG_COMMAND_LINE) != 0;\n-}\n-\n-bool JVMFlag::is_jimage_resource() const {\n-  return (get_origin() == JIMAGE_RESOURCE);\n-}\n-\n-void JVMFlag::set_command_line() {\n-  _flags = Flags(_flags | ORIG_COMMAND_LINE);\n-}\n-\n-bool JVMFlag::is_product() const {\n-  return (_flags & KIND_PRODUCT) != 0;\n-}\n-\n-bool JVMFlag::is_manageable() const {\n-  return (_flags & KIND_MANAGEABLE) != 0;\n-}\n-\n-bool JVMFlag::is_diagnostic() const {\n-  return (_flags & KIND_DIAGNOSTIC) != 0;\n-}\n-\n-bool JVMFlag::is_experimental() const {\n-  return (_flags & KIND_EXPERIMENTAL) != 0;\n-}\n-\n-bool JVMFlag::is_notproduct() const {\n-  return (_flags & KIND_NOT_PRODUCT) != 0;\n-}\n-\n-bool JVMFlag::is_develop() const {\n-  return (_flags & KIND_DEVELOP) != 0;\n-}\n-\n@@ -265,11 +126,0 @@\n-bool JVMFlag::is_writeable() const {\n-  return is_manageable();\n-}\n-\n-\/\/ All flags except \"manageable\" are assumed to be internal flags.\n-\/\/ Long term, we need to define a mechanism to specify which flags\n-\/\/ are external\/stable and change this function accordingly.\n-bool JVMFlag::is_external() const {\n-  return is_manageable();\n-}\n-\n@@ -344,1 +194,1 @@\n-    st->print(\"%*s\", col1_width, _type);  \/\/ right-justified, therefore width is required.\n+    st->print(\"%*s\", col1_width, type_string());  \/\/ right-justified, therefore width is required.\n@@ -388,1 +238,1 @@\n-      st->print(\"unhandled  type %s\", _type);\n+      st->print(\"unhandled  type %s\", type_string());\n@@ -452,1 +302,1 @@\n-    st->print(\"%*s\", col1_width, _type);  \/\/ right-justified, therefore width is required.\n+    st->print(\"%*s\", col1_width, type_string());  \/\/ right-justified, therefore width is required.\n@@ -458,21 +308,1 @@\n-    RangeStrFunc func = NULL;\n-    if (is_int()) {\n-      func = JVMFlag::get_int_default_range_str;\n-    } else if (is_uint()) {\n-      func = JVMFlag::get_uint_default_range_str;\n-    } else if (is_intx()) {\n-      func = JVMFlag::get_intx_default_range_str;\n-    } else if (is_uintx()) {\n-      func = JVMFlag::get_uintx_default_range_str;\n-    } else if (is_uint64_t()) {\n-      func = JVMFlag::get_uint64_t_default_range_str;\n-    } else if (is_size_t()) {\n-      func = JVMFlag::get_size_t_default_range_str;\n-    } else if (is_double()) {\n-      func = JVMFlag::get_double_default_range_str;\n-    } else {\n-      st->print(\"unhandled  type %s\", _type);\n-      st->cr();\n-      return;\n-    }\n-    JVMFlagRangeList::print(st, this, func);\n+    JVMFlagAccess::print_range(st, this);\n@@ -665,1 +495,1 @@\n-constexpr JVMFlag::JVMFlag(int flag_enum, const char* type, const char* name,\n+constexpr JVMFlag::JVMFlag(int flag_enum, FlagType type, const char* name,\n@@ -667,1 +497,1 @@\n-  _type(type), _name(name), _addr(addr), _flags() NOT_PRODUCT(COMMA _doc(doc)) {\n+  _addr(addr), _name(name), _flags(), _type(type) NOT_PRODUCT(COMMA _doc(doc)) {\n@@ -678,1 +508,1 @@\n-constexpr JVMFlag::JVMFlag(int flag_enum,  const char* type, const char* name,\n+constexpr JVMFlag::JVMFlag(int flag_enum,  FlagType type, const char* name,\n@@ -688,5 +518,6 @@\n-#define DEVELOP_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, DEVELOP_KIND,    __VA_ARGS__),\n-#define DEVELOP_FLAG_INIT_PD(type, name,        ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, DEVELOP_KIND_PD, __VA_ARGS__),\n-#define PRODUCT_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, PRODUCT_KIND,    __VA_ARGS__),\n-#define PRODUCT_FLAG_INIT_PD(type, name,        ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, PRODUCT_KIND_PD, __VA_ARGS__),\n-#define NOTPROD_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), #type, XSTR(name), (void*)&name, NOTPROD_KIND,    __VA_ARGS__),\n+#define FLAG_TYPE(type) (JVMFlag::TYPE_ ## type)\n+#define DEVELOP_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), FLAG_TYPE(type), XSTR(name), (void*)&name, DEVELOP_KIND,    __VA_ARGS__),\n+#define DEVELOP_FLAG_INIT_PD(type, name,        ...) JVMFlag(FLAG_MEMBER_ENUM(name), FLAG_TYPE(type), XSTR(name), (void*)&name, DEVELOP_KIND_PD, __VA_ARGS__),\n+#define PRODUCT_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), FLAG_TYPE(type), XSTR(name), (void*)&name, PRODUCT_KIND,    __VA_ARGS__),\n+#define PRODUCT_FLAG_INIT_PD(type, name,        ...) JVMFlag(FLAG_MEMBER_ENUM(name), FLAG_TYPE(type), XSTR(name), (void*)&name, PRODUCT_KIND_PD, __VA_ARGS__),\n+#define NOTPROD_FLAG_INIT(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), FLAG_TYPE(type), XSTR(name), (void*)&name, NOTPROD_KIND,    __VA_ARGS__),\n@@ -782,7 +613,1 @@\n-\/\/ Returns the address of the index'th element\n-JVMFlag* JVMFlagEx::flag_from_enum(JVMFlagsEnum flag) {\n-  assert((size_t)flag < JVMFlag::numFlags, \"bad command line flag index\");\n-  return &JVMFlag::flags[flag];\n-}\n-\n-bool JVMFlagEx::is_default(JVMFlagsEnum flag) {\n+bool JVMFlag::is_default(JVMFlagsEnum flag) {\n@@ -792,1 +617,1 @@\n-bool JVMFlagEx::is_ergo(JVMFlagsEnum flag) {\n+bool JVMFlag::is_ergo(JVMFlagsEnum flag) {\n@@ -796,1 +621,1 @@\n-bool JVMFlagEx::is_cmdline(JVMFlagsEnum flag) {\n+bool JVMFlag::is_cmdline(JVMFlagsEnum flag) {\n@@ -800,350 +625,2 @@\n-bool JVMFlagEx::is_jimage_resource(JVMFlagsEnum flag) {\n-  assert((size_t)flag < JVMFlag::numFlags, \"bad command line flag index\");\n-  JVMFlag* f = &JVMFlag::flags[flag];\n-  return f->is_jimage_resource();\n-}\n-\n-void JVMFlagEx::setOnCmdLine(JVMFlagsEnum flag) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  assert(faddr != NULL, \"Unknown flag\");\n-  faddr->set_command_line();\n-}\n-\n-template<class E, class T>\n-static void trace_flag_changed(JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {\n-  E e;\n-  e.set_name(flag->_name);\n-  e.set_oldValue(old_value);\n-  e.set_newValue(new_value);\n-  e.set_origin(origin);\n-  e.commit();\n-}\n-\n-static JVMFlag::Error apply_constraint_and_check_range_bool(JVMFlag* flag, bool new_value, bool verbose) {\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-  JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-  if (constraint.exists()) {\n-    status = constraint.apply_bool(new_value, verbose);\n-  }\n-  return status;\n-}\n-\n-JVMFlag::Error JVMFlag::boolAt(const JVMFlag* flag, bool* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_bool()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_bool();\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlag::boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_bool()) return JVMFlag::WRONG_FORMAT;\n-  JVMFlag::Error check = apply_constraint_and_check_range_bool(flag, *value, !JVMFlagConstraintList::validated_after_ergo());\n-  if (check != JVMFlag::SUCCESS) return check;\n-  bool old_value = flag->get_bool();\n-  trace_flag_changed<EventBooleanFlagChanged, bool>(flag, old_value, *value, origin);\n-  flag->set_bool(*value);\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::boolAtPut(JVMFlagsEnum flag, bool value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_bool(), \"wrong flag type\");\n-  return JVMFlag::boolAtPut(faddr, &value, origin);\n-}\n-\n-static JVMFlag::Error apply_constraint_and_check_range_int(JVMFlag* flag, int new_value, bool verbose) {\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n-    status = range.check_int(new_value, verbose);\n-  }\n-  if (status == JVMFlag::SUCCESS) {\n-    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint.exists()) {\n-      status = constraint.apply_int(new_value, verbose);\n-    }\n-  }\n-  return status;\n-}\n-\n-JVMFlag::Error JVMFlag::intAt(const JVMFlag* flag, int* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_int()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_int();\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlag::intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_int()) return JVMFlag::WRONG_FORMAT;\n-  JVMFlag::Error check = apply_constraint_and_check_range_int(flag, *value, !JVMFlagConstraintList::validated_after_ergo());\n-  if (check != JVMFlag::SUCCESS) return check;\n-  int old_value = flag->get_int();\n-  trace_flag_changed<EventIntFlagChanged, s4>(flag, old_value, *value, origin);\n-  flag->set_int(*value);\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::intAtPut(JVMFlagsEnum flag, int value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_int(), \"wrong flag type\");\n-  return JVMFlag::intAtPut(faddr, &value, origin);\n-}\n-\n-static JVMFlag::Error apply_constraint_and_check_range_uint(JVMFlag* flag, uint new_value, bool verbose) {\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n-    status = range.check_uint(new_value, verbose);\n-  }\n-  if (status == JVMFlag::SUCCESS) {\n-    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint.exists()) {\n-      status = constraint.apply_uint(new_value, verbose);\n-    }\n-  }\n-  return status;\n-}\n-\n-JVMFlag::Error JVMFlag::uintAt(const JVMFlag* flag, uint* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_uint()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_uint();\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlag::uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_uint()) return JVMFlag::WRONG_FORMAT;\n-  JVMFlag::Error check = apply_constraint_and_check_range_uint(flag, *value, !JVMFlagConstraintList::validated_after_ergo());\n-  if (check != JVMFlag::SUCCESS) return check;\n-  uint old_value = flag->get_uint();\n-  trace_flag_changed<EventUnsignedIntFlagChanged, u4>(flag, old_value, *value, origin);\n-  flag->set_uint(*value);\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::uintAtPut(JVMFlagsEnum flag, uint value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_uint(), \"wrong flag type\");\n-  return JVMFlag::uintAtPut(faddr, &value, origin);\n-}\n-\n-JVMFlag::Error JVMFlag::intxAt(const JVMFlag* flag, intx* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_intx()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_intx();\n-  return JVMFlag::SUCCESS;\n-}\n-\n-static JVMFlag::Error apply_constraint_and_check_range_intx(JVMFlag* flag, intx new_value, bool verbose) {\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n-    status = range.check_intx(new_value, verbose);\n-  }\n-  if (status == JVMFlag::SUCCESS) {\n-    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint.exists()) {\n-      status = constraint.apply_intx(new_value, verbose);\n-    }\n-  }\n-  return status;\n-}\n-\n-JVMFlag::Error JVMFlag::intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_intx()) return JVMFlag::WRONG_FORMAT;\n-  JVMFlag::Error check = apply_constraint_and_check_range_intx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());\n-  if (check != JVMFlag::SUCCESS) return check;\n-  intx old_value = flag->get_intx();\n-  trace_flag_changed<EventLongFlagChanged, intx>(flag, old_value, *value, origin);\n-  flag->set_intx(*value);\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::intxAtPut(JVMFlagsEnum flag, intx value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_intx(), \"wrong flag type\");\n-  return JVMFlag::intxAtPut(faddr, &value, origin);\n-}\n-\n-JVMFlag::Error JVMFlag::uintxAt(const JVMFlag* flag, uintx* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_uintx()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_uintx();\n-  return JVMFlag::SUCCESS;\n-}\n-\n-static JVMFlag::Error apply_constraint_and_check_range_uintx(JVMFlag* flag, uintx new_value, bool verbose) {\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n-    status = range.check_uintx(new_value, verbose);\n-  }\n-  if (status == JVMFlag::SUCCESS) {\n-    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint.exists()) {\n-      status = constraint.apply_uintx(new_value, verbose);\n-    }\n-  }\n-  return status;\n-}\n-\n-JVMFlag::Error JVMFlag::uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_uintx()) return JVMFlag::WRONG_FORMAT;\n-  JVMFlag::Error check = apply_constraint_and_check_range_uintx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());\n-  if (check != JVMFlag::SUCCESS) return check;\n-  uintx old_value = flag->get_uintx();\n-  trace_flag_changed<EventUnsignedLongFlagChanged, u8>(flag, old_value, *value, origin);\n-  flag->set_uintx(*value);\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::uintxAtPut(JVMFlagsEnum flag, uintx value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_uintx(), \"wrong flag type\");\n-  return JVMFlag::uintxAtPut(faddr, &value, origin);\n-}\n-\n-JVMFlag::Error JVMFlag::uint64_tAt(const JVMFlag* flag, uint64_t* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_uint64_t()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_uint64_t();\n-  return JVMFlag::SUCCESS;\n-}\n-\n-static JVMFlag::Error apply_constraint_and_check_range_uint64_t(JVMFlag* flag, uint64_t new_value, bool verbose) {\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n-    status = range.check_uint64_t(new_value, verbose);\n-  }\n-  if (status == JVMFlag::SUCCESS) {\n-    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint.exists()) {\n-      status = constraint.apply_uint64_t(new_value, verbose);\n-    }\n-  }\n-  return status;\n-}\n-\n-JVMFlag::Error JVMFlag::uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_uint64_t()) return JVMFlag::WRONG_FORMAT;\n-  JVMFlag::Error check = apply_constraint_and_check_range_uint64_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());\n-  if (check != JVMFlag::SUCCESS) return check;\n-  uint64_t old_value = flag->get_uint64_t();\n-  trace_flag_changed<EventUnsignedLongFlagChanged, u8>(flag, old_value, *value, origin);\n-  flag->set_uint64_t(*value);\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::uint64_tAtPut(JVMFlagsEnum flag, uint64_t value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_uint64_t(), \"wrong flag type\");\n-  return JVMFlag::uint64_tAtPut(faddr, &value, origin);\n-}\n-\n-JVMFlag::Error JVMFlag::size_tAt(const JVMFlag* flag, size_t* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_size_t()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_size_t();\n-  return JVMFlag::SUCCESS;\n-}\n-\n-static JVMFlag::Error apply_constraint_and_check_range_size_t(JVMFlag* flag, size_t new_value, bool verbose) {\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n-    status = range.check_size_t(new_value, verbose);\n-  }\n-  if (status == JVMFlag::SUCCESS) {\n-    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint.exists()) {\n-      status = constraint.apply_size_t(new_value, verbose);\n-    }\n-  }\n-  return status;\n-}\n-\n-\n-JVMFlag::Error JVMFlag::size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_size_t()) return JVMFlag::WRONG_FORMAT;\n-  JVMFlag::Error check = apply_constraint_and_check_range_size_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());\n-  if (check != JVMFlag::SUCCESS) return check;\n-  size_t old_value = flag->get_size_t();\n-  trace_flag_changed<EventUnsignedLongFlagChanged, u8>(flag, old_value, *value, origin);\n-  flag->set_size_t(*value);\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::size_tAtPut(JVMFlagsEnum flag, size_t value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_size_t(), \"wrong flag type\");\n-  return JVMFlag::size_tAtPut(faddr, &value, origin);\n-}\n-\n-JVMFlag::Error JVMFlag::doubleAt(const JVMFlag* flag, double* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_double()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_double();\n-  return JVMFlag::SUCCESS;\n-}\n-\n-static JVMFlag::Error apply_constraint_and_check_range_double(JVMFlag* flag, double new_value, bool verbose) {\n-  JVMFlag::Error status = JVMFlag::SUCCESS;\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n-    status = range.check_double(new_value, verbose);\n-  }\n-  if (status == JVMFlag::SUCCESS) {\n-    JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find_if_needs_check(flag);\n-    if (constraint.exists()) {\n-      status = constraint.apply_double(new_value, verbose);\n-    }\n-  }\n-  return status;\n-}\n-\n-JVMFlag::Error JVMFlag::doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_double()) return JVMFlag::WRONG_FORMAT;\n-  JVMFlag::Error check = apply_constraint_and_check_range_double(flag, *value, !JVMFlagConstraintList::validated_after_ergo());\n-  if (check != JVMFlag::SUCCESS) return check;\n-  double old_value = flag->get_double();\n-  trace_flag_changed<EventDoubleFlagChanged, double>(flag, old_value, *value, origin);\n-  flag->set_double(*value);\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::doubleAtPut(JVMFlagsEnum flag, double value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_double(), \"wrong flag type\");\n-  return JVMFlag::doubleAtPut(faddr, &value, origin);\n-}\n-\n-JVMFlag::Error JVMFlag::ccstrAt(const JVMFlag* flag, ccstr* value) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_ccstr()) return JVMFlag::WRONG_FORMAT;\n-  *value = flag->get_ccstr();\n-  return JVMFlag::SUCCESS;\n+bool JVMFlag::is_jimage_resource(JVMFlagsEnum flag) {\n+  return flag_from_enum(flag)->is_jimage_resource();\n@@ -1152,32 +629,2 @@\n-JVMFlag::Error JVMFlag::ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin) {\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n-  if (!flag->is_ccstr()) return JVMFlag::WRONG_FORMAT;\n-  ccstr old_value = flag->get_ccstr();\n-  trace_flag_changed<EventStringFlagChanged, const char*>(flag, old_value, *value, origin);\n-  char* new_value = NULL;\n-  if (*value != NULL) {\n-    new_value = os::strdup_check_oom(*value);\n-  }\n-  flag->set_ccstr(new_value);\n-  if (flag->is_default() && old_value != NULL) {\n-    \/\/ Prior value is NOT heap allocated, but was a literal constant.\n-    old_value = os::strdup_check_oom(old_value);\n-  }\n-  *value = old_value;\n-  flag->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n-}\n-\n-JVMFlag::Error JVMFlagEx::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin) {\n-  JVMFlag* faddr = flag_from_enum(flag);\n-  guarantee(faddr != NULL && faddr->is_ccstr(), \"wrong flag type\");\n-  ccstr old_value = faddr->get_ccstr();\n-  trace_flag_changed<EventStringFlagChanged, const char*>(faddr, old_value, value, origin);\n-  char* new_value = os::strdup_check_oom(value);\n-  faddr->set_ccstr(new_value);\n-  if (!faddr->is_default() && old_value != NULL) {\n-    \/\/ Prior value is heap allocated so free it.\n-    FREE_C_HEAP_ARRAY(char, old_value);\n-  }\n-  faddr->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n+void JVMFlag::setOnCmdLine(JVMFlagsEnum flag) {\n+  flag_from_enum(flag)->set_command_line();\n@@ -1188,1 +635,1 @@\n-    return strcmp((*((JVMFlag**) void_a))->_name, (*((JVMFlag**) void_b))->_name);\n+    return strcmp((*((JVMFlag**) void_a))->name(), (*((JVMFlag**) void_b))->name());\n@@ -1228,2 +675,2 @@\n-void JVMFlag::assert_valid_flag_enum(int i) {\n-  assert(0 <= i && i < NUM_JVMFlagsEnum, \"must be\");\n+void JVMFlag::assert_valid_flag_enum(JVMFlagsEnum i) {\n+  assert(0 <= int(i) && int(i) < NUM_JVMFlagsEnum, \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":24,"deletions":577,"binary":false,"changes":601,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-class outputStream;\n+enum JVMFlagsEnum : int;\n@@ -33,2 +33,1 @@\n-\/\/ function type that will construct default range string\n-typedef const char* (*RangeStrFunc)(void);\n+class outputStream;\n@@ -36,1 +35,3 @@\n-struct JVMFlag {\n+class JVMFlag {\n+  friend class VMStructs;\n+public:\n@@ -108,2 +109,22 @@\n-  const char* _type;\n-  const char* _name;\n+#define JVM_FLAG_NON_STRING_TYPES_DO(f) \\\n+    f(bool) \\\n+    f(int) \\\n+    f(uint) \\\n+    f(intx) \\\n+    f(uintx) \\\n+    f(uint64_t) \\\n+    f(size_t) \\\n+    f(double)\n+\n+#define JVM_FLAG_TYPE_DECLARE(t) \\\n+  TYPE_ ## t,\n+\n+  enum FlagType : int {\n+    JVM_FLAG_NON_STRING_TYPES_DO(JVM_FLAG_TYPE_DECLARE)\n+    \/\/ The two string types are a bit irregular: is_ccstr() returns true for both types.\n+    TYPE_ccstr,\n+    TYPE_ccstrlist,\n+    NUM_FLAG_TYPES\n+  };\n+\n+private:\n@@ -111,0 +132,1 @@\n+  const char* _name;\n@@ -112,0 +134,2 @@\n+  int   _type;\n+\n@@ -114,0 +138,1 @@\n+public:\n@@ -124,1 +149,1 @@\n-  constexpr JVMFlag() : _type(), _name(), _addr(), _flags() NOT_PRODUCT(COMMA _doc()) {}\n+  constexpr JVMFlag() : _addr(), _name(), _flags(), _type() NOT_PRODUCT(COMMA _doc()) {}\n@@ -126,1 +151,1 @@\n-  constexpr JVMFlag(int flag_enum, const char* type, const char* name,\n+  constexpr JVMFlag(int flag_enum, FlagType type, const char* name,\n@@ -129,1 +154,1 @@\n-  constexpr JVMFlag(int flag_enum,  const char* type, const char* name,\n+  constexpr JVMFlag(int flag_enum,  FlagType type, const char* name,\n@@ -144,9 +169,1 @@\n-  static const char* get_int_default_range_str();\n-  static const char* get_uint_default_range_str();\n-  static const char* get_intx_default_range_str();\n-  static const char* get_uintx_default_range_str();\n-  static const char* get_uint64_t_default_range_str();\n-  static const char* get_size_t_default_range_str();\n-  static const char* get_double_default_range_str();\n-\n-  static void assert_valid_flag_enum(int i) NOT_DEBUG_RETURN;\n+  static void assert_valid_flag_enum(JVMFlagsEnum i) NOT_DEBUG_RETURN;\n@@ -155,2 +172,2 @@\n-  inline int flag_enum() const {\n-    int i = this - JVMFlag::flags;\n+  inline JVMFlagsEnum flag_enum() const {\n+    JVMFlagsEnum i = static_cast<JVMFlagsEnum>(this - JVMFlag::flags);\n@@ -161,1 +178,1 @@\n-  static JVMFlag* flag_from_enum(int flag_enum) {\n+  static JVMFlag* flag_from_enum(JVMFlagsEnum flag_enum) {\n@@ -166,3 +183,4 @@\n-  bool is_bool() const;\n-  bool get_bool() const                       { return *((bool*) _addr); }\n-  void set_bool(bool value) const             { *((bool*) _addr) = value; }\n+#define JVM_FLAG_TYPE_ACCESSOR(t)                                                                 \\\n+  bool is_##t() const                      { return _type == TYPE_##t;}                           \\\n+  t get_##t() const                        { assert(is_##t(), \"sanity\"); return *((t*) _addr); }  \\\n+  void set_##t(t value)                    { assert(is_##t(), \"sanity\"); *((t*) _addr) = value; }\n@@ -170,3 +188,1 @@\n-  bool is_int() const;\n-  int get_int() const                         { return *((int*) _addr); }\n-  void set_int(int value) const               { *((int*) _addr) = value; }\n+  JVM_FLAG_NON_STRING_TYPES_DO(JVM_FLAG_TYPE_ACCESSOR)\n@@ -174,3 +190,4 @@\n-  bool is_uint() const;\n-  uint get_uint() const                       { return *((uint*) _addr); }\n-  void set_uint(uint value) const             { *((uint*) _addr) = value; }\n+  bool is_ccstr()                      const { return _type == TYPE_ccstr || _type == TYPE_ccstrlist; }\n+  bool ccstr_accumulates()             const { return _type == TYPE_ccstrlist; }\n+  ccstr get_ccstr()                    const { assert(is_ccstr(), \"sanity\"); return *((ccstr*) _addr); }\n+  void set_ccstr(ccstr value)                { assert(is_ccstr(), \"sanity\"); *((ccstr*) _addr) = value; }\n@@ -178,3 +195,2 @@\n-  bool is_intx() const;\n-  intx get_intx() const                       { return *((intx*) _addr); }\n-  void set_intx(intx value) const             { *((intx*) _addr) = value; }\n+#define JVM_FLAG_AS_STRING(t) \\\n+  case TYPE_##t: return STR(t);\n@@ -182,3 +198,3 @@\n-  bool is_uintx() const;\n-  uintx get_uintx() const                     { return *((uintx*) _addr); }\n-  void set_uintx(uintx value) const           { *((uintx*) _addr) = value; }\n+  const char* type_string() const {\n+    return type_string_for((FlagType)_type);\n+  }\n@@ -186,3 +202,13 @@\n-  bool is_uint64_t() const;\n-  uint64_t get_uint64_t() const               { return *((uint64_t*) _addr); }\n-  void set_uint64_t(uint64_t value) const     { *((uint64_t*) _addr) = value; }\n+  static const char* type_string_for(FlagType t) {\n+    switch(t) {\n+    JVM_FLAG_NON_STRING_TYPES_DO(JVM_FLAG_AS_STRING)\n+    case TYPE_ccstr:     return \"ccstr\";\n+    case TYPE_ccstrlist: return \"ccstrlist\";\n+    default:\n+        ShouldNotReachHere();\n+        return \"unknown\";\n+    }\n+  }\n+\n+  int type() const { return _type; }\n+  const char* name() const { return _name; }\n@@ -190,3 +216,7 @@\n-  bool is_size_t() const;\n-  size_t get_size_t() const                   { return *((size_t*) _addr); }\n-  void set_size_t(size_t value) const         { *((size_t*) _addr) = value; }\n+  void assert_type(int type_enum) const {\n+    if (type_enum == JVMFlag::TYPE_ccstr) {\n+      assert(is_ccstr(), \"type check\"); \/\/ ccstr or ccstrlist\n+    } else {\n+      assert(_type == type_enum, \"type check\");\n+    }\n+  }\n@@ -194,3 +224,6 @@\n-  bool is_double() const;\n-  double get_double() const                   { return *((double*) _addr); }\n-  void set_double(double value) const         { *((double*) _addr) = value; }\n+  \/\/ Do not use JVMFlag::read() or JVMFlag::write() directly unless you know\n+  \/\/ what you're doing. Use FLAG_SET_XXX macros or JVMFlagAccess instead.\n+  template <typename T, int type_enum> T read() const {\n+    assert_type(type_enum);\n+    return *static_cast<T*>(_addr);\n+  }\n@@ -198,4 +231,4 @@\n-  bool is_ccstr() const;\n-  bool ccstr_accumulates() const;\n-  ccstr get_ccstr() const                     { return *((ccstr*) _addr); }\n-  void set_ccstr(ccstr value) const           { *((ccstr*) _addr) = value; }\n+  template <typename T, int type_enum> void write(T value) {\n+    assert_type(type_enum);\n+    *static_cast<T*>(_addr) = value;\n+  }\n@@ -203,1 +236,1 @@\n-  Flags get_origin() const;\n+  Flags get_origin() const        {  return Flags(_flags & VALUE_ORIGIN_MASK);   }\n@@ -206,12 +239,11 @@\n-  bool is_default() const;\n-  bool is_ergonomic() const;\n-  bool is_jimage_resource() const;\n-  bool is_command_line() const;\n-  void set_command_line();\n-\n-  bool is_product() const;\n-  bool is_manageable() const;\n-  bool is_diagnostic() const;\n-  bool is_experimental() const;\n-  bool is_notproduct() const;\n-  bool is_develop() const;\n+  bool is_default() const         { return (get_origin() == DEFAULT);            }\n+  bool is_ergonomic() const       { return (get_origin() == ERGONOMIC);          }\n+  bool is_command_line() const    { return (_flags & ORIG_COMMAND_LINE) != 0;    }\n+  void set_command_line()         {  _flags = Flags(_flags | ORIG_COMMAND_LINE); }\n+  bool is_jimage_resource() const { return (get_origin() == JIMAGE_RESOURCE);    }\n+  bool is_product() const         { return (_flags & KIND_PRODUCT) != 0;         }\n+  bool is_manageable() const      { return (_flags & KIND_MANAGEABLE) != 0;      }\n+  bool is_diagnostic() const      { return (_flags & KIND_DIAGNOSTIC) != 0;      }\n+  bool is_experimental() const    { return (_flags & KIND_EXPERIMENTAL) != 0;    }\n+  bool is_notproduct() const      { return (_flags & KIND_NOT_PRODUCT) != 0;     }\n+  bool is_develop() const         { return (_flags & KIND_DEVELOP) != 0;         }\n@@ -223,2 +255,5 @@\n-  bool is_writeable() const;\n-  bool is_external() const;\n+\n+  \/\/ Only manageable flags can be accessed by writeableFlags.cpp\n+  bool is_writeable() const       { return is_manageable();                      }\n+  \/\/ All flags except \"manageable\" are assumed to be internal flags.\n+  bool is_external() const        { return is_manageable();                      }\n@@ -233,0 +268,7 @@\n+  static bool is_default(JVMFlagsEnum flag);\n+  static bool is_ergo(JVMFlagsEnum flag);\n+  static bool is_cmdline(JVMFlagsEnum flag);\n+  static bool is_jimage_resource(JVMFlagsEnum flag);\n+  static void setOnCmdLine(JVMFlagsEnum flag);\n+\n+\n@@ -242,29 +284,0 @@\n-  static JVMFlag::Error boolAt(const JVMFlag* flag, bool* value);\n-  static JVMFlag::Error boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin);\n-\n-  static JVMFlag::Error intAt(const JVMFlag* flag, int* value);\n-  static JVMFlag::Error intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin);\n-\n-  static JVMFlag::Error uintAt(const JVMFlag* flag, uint* value);\n-  static JVMFlag::Error uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin);\n-\n-  static JVMFlag::Error intxAt(const JVMFlag* flag, intx* value);\n-  static JVMFlag::Error intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin);\n-\n-  static JVMFlag::Error uintxAt(const JVMFlag* flag, uintx* value);\n-  static JVMFlag::Error uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin);\n-\n-  static JVMFlag::Error size_tAt(const JVMFlag* flag, size_t* value);\n-  static JVMFlag::Error size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin);\n-\n-  static JVMFlag::Error uint64_tAt(const JVMFlag* flag, uint64_t* value);\n-  static JVMFlag::Error uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin);\n-\n-  static JVMFlag::Error doubleAt(const JVMFlag* flag, double* value);\n-  static JVMFlag::Error doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin);\n-\n-  static JVMFlag::Error ccstrAt(const JVMFlag* flag, ccstr* value);\n-  \/\/ Contract:  JVMFlag will make private copy of the incoming value.\n-  \/\/ Outgoing value is always malloc-ed, and caller MUST call free.\n-  static JVMFlag::Error ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin);\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":106,"deletions":93,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -0,0 +1,397 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n+#include \"runtime\/flags\/jvmFlagConstraintsRuntime.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+template<typename T, typename EVENT>\n+static void trace_flag_changed(JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {\n+  EVENT e;\n+  e.set_name(flag->name());\n+  e.set_oldValue(old_value);\n+  e.set_newValue(new_value);\n+  e.set_origin(origin);\n+  e.commit();\n+}\n+\n+class FlagAccessImpl {\n+public:\n+  JVMFlag::Error set(JVMFlag* flag, void* value, JVMFlag::Flags origin) const {\n+    return set_impl(flag, value, origin);\n+  }\n+\n+  virtual JVMFlag::Error set_impl(JVMFlag* flag, void* value, JVMFlag::Flags origin) const = 0;\n+  virtual JVMFlag::Error check_range(const JVMFlag* flag, bool verbose) const { return JVMFlag::SUCCESS; }\n+  virtual void print_range(outputStream* st, const JVMFlagLimit* range) const { ShouldNotReachHere(); }\n+  virtual void print_default_range(outputStream* st) const { ShouldNotReachHere(); }\n+  virtual JVMFlag::Error check_constraint(const JVMFlag* flag, void * func, bool verbose) const  { return JVMFlag::SUCCESS; }\n+};\n+\n+template <typename T, int type_enum, typename EVENT>\n+class TypedFlagAccessImpl : public FlagAccessImpl {\n+\n+public:\n+  JVMFlag::Error check_constraint_and_set(JVMFlag* flag, void* value_addr, JVMFlag::Flags origin, bool verbose) const {\n+    T value = *((T*)value_addr);\n+    const JVMTypedFlagLimit<T>* constraint = (const JVMTypedFlagLimit<T>*)JVMFlagLimit::get_constraint(flag);\n+    if (constraint != NULL && constraint->phase() <= static_cast<int>(JVMFlagLimit::validating_phase())) {\n+      JVMFlag::Error err = typed_check_constraint(constraint->constraint_func(), value, verbose);\n+      if (err != JVMFlag::SUCCESS) {\n+        return err;\n+      }\n+    }\n+\n+    T old_value = flag->read<T, type_enum>();\n+    trace_flag_changed<T, EVENT>(flag, old_value, value, origin);\n+    flag->write<T, type_enum>(value);\n+    *((T*)value_addr) = old_value;\n+    flag->set_origin(origin);\n+\n+    return JVMFlag::SUCCESS;\n+  }\n+\n+  JVMFlag::Error check_constraint(const JVMFlag* flag, void * func, bool verbose) const  {\n+    return typed_check_constraint(func, flag->read<T, type_enum>(), verbose);\n+  }\n+\n+  virtual JVMFlag::Error typed_check_constraint(void * func, T value, bool verbose) const = 0;\n+};\n+\n+class FlagAccessImpl_bool : public TypedFlagAccessImpl<JVM_FLAG_TYPE(bool), EventBooleanFlagChanged> {\n+public:\n+  JVMFlag::Error set_impl(JVMFlag* flag, void* value_addr, JVMFlag::Flags origin) const {\n+    bool verbose = !JVMFlagLimit::validated_after_ergo();\n+    return TypedFlagAccessImpl<JVM_FLAG_TYPE(bool), EventBooleanFlagChanged>\n+               ::check_constraint_and_set(flag, value_addr, origin, verbose);\n+  }\n+\n+  JVMFlag::Error typed_check_constraint(void* func, bool value, bool verbose) const {\n+    return ((JVMFlagConstraintFunc_bool)func)(value, verbose);\n+  }\n+};\n+\n+template <typename T, int type_enum, typename EVENT>\n+class RangedFlagAccessImpl : public TypedFlagAccessImpl<T, type_enum, EVENT> {\n+public:\n+  virtual JVMFlag::Error set_impl(JVMFlag* flag, void* value_addr, JVMFlag::Flags origin) const {\n+    T value = *((T*)value_addr);\n+    bool verbose = !JVMFlagLimit::validated_after_ergo();\n+\n+    const JVMTypedFlagLimit<T>* range = (const JVMTypedFlagLimit<T>*)JVMFlagLimit::get_range(flag);\n+    if (range != NULL) {\n+      if ((value < range->min()) || (value > range->max())) {\n+        range_error(flag->name(), value, range->min(), range->max(), verbose);\n+        return JVMFlag::OUT_OF_BOUNDS;\n+      }\n+    }\n+\n+    return TypedFlagAccessImpl<T, type_enum, EVENT>::check_constraint_and_set(flag, value_addr, origin, verbose);\n+  }\n+\n+  virtual JVMFlag::Error check_range(const JVMFlag* flag, bool verbose) const {\n+    const JVMTypedFlagLimit<T>* range = (const JVMTypedFlagLimit<T>*)JVMFlagLimit::get_range(flag);\n+    if (range != NULL) {\n+      T value = flag->read<T, type_enum>();\n+      if ((value < range->min()) || (value > range->max())) {\n+        range_error(flag->name(), value, range->min(), range->max(), verbose);\n+        return JVMFlag::OUT_OF_BOUNDS;\n+      }\n+    }\n+    return JVMFlag::SUCCESS;\n+  }\n+\n+  virtual void print_range(outputStream* st, const JVMFlagLimit* range) const {\n+    const JVMTypedFlagLimit<T>* r = (const JVMTypedFlagLimit<T>*)range;\n+    print_range_impl(st, r->min(), r->max());\n+  }\n+\n+  virtual void range_error(const char* name, T value, T min, T max, bool verbose) const = 0;\n+  virtual void print_range_impl(outputStream* st, T min, T max) const = 0;\n+};\n+\n+class FlagAccessImpl_int : public RangedFlagAccessImpl<JVM_FLAG_TYPE(int), EventIntFlagChanged> {\n+public:\n+  void range_error(const char* name, int value, int min, int max, bool verbose) const {\n+    JVMFlag::printError(verbose,\n+                        \"int %s=%d is outside the allowed range \"\n+                        \"[ %d ... %d ]\\n\",\n+                        name, value, min, max);\n+  }\n+  JVMFlag::Error typed_check_constraint(void* func, int value, bool verbose) const {\n+    return ((JVMFlagConstraintFunc_int)func)(value, verbose);\n+  }\n+  void print_range_impl(outputStream* st, int min, int max) const {\n+    st->print(\"[ %-25d ... %25d ]\", min, max);\n+  }\n+  void print_default_range(outputStream* st) const {\n+    st->print(\"[ \" INT32_FORMAT_W(-25) \" ... \" INT32_FORMAT_W(25) \" ]\", INT_MIN, INT_MAX);\n+  }\n+};\n+\n+class FlagAccessImpl_uint : public RangedFlagAccessImpl<JVM_FLAG_TYPE(uint), EventUnsignedIntFlagChanged> {\n+public:\n+  void range_error(const char* name, uint value, uint min, uint max, bool verbose) const {\n+    JVMFlag::printError(verbose,\n+                        \"uint %s=%u is outside the allowed range \"\n+                        \"[ %u ... %u ]\\n\",\n+                        name, value, min, max);\n+  }\n+  JVMFlag::Error typed_check_constraint(void* func, uint value, bool verbose) const {\n+    return ((JVMFlagConstraintFunc_uint)func)(value, verbose);\n+  }\n+  void print_range_impl(outputStream* st, uint min, uint max) const {\n+    st->print(\"[ %-25u ... %25u ]\", min, max);\n+  }\n+  void print_default_range(outputStream* st) const {\n+    st->print(\"[ \" UINT32_FORMAT_W(-25) \" ... \" UINT32_FORMAT_W(25) \" ]\", 0, UINT_MAX);\n+  }\n+};\n+\n+class FlagAccessImpl_intx : public RangedFlagAccessImpl<JVM_FLAG_TYPE(intx), EventLongFlagChanged> {\n+public:\n+  void range_error(const char* name, intx value, intx min, intx max, bool verbose) const {\n+    JVMFlag::printError(verbose,\n+                        \"intx %s=\" INTX_FORMAT \" is outside the allowed range \"\n+                        \"[ \" INTX_FORMAT \" ... \" INTX_FORMAT \" ]\\n\",\n+                        name, value, min, max);\n+  }\n+  JVMFlag::Error typed_check_constraint(void* func, intx value, bool verbose) const {\n+    return ((JVMFlagConstraintFunc_intx)func)(value, verbose);\n+  }\n+  void print_range_impl(outputStream* st, intx min, intx max) const {\n+    st->print(\"[ \" INTX_FORMAT_W(-25) \" ... \" INTX_FORMAT_W(25) \" ]\", min, max);\n+  }\n+  void print_default_range(outputStream* st) const {\n+    st->print(\"[ \" INTX_FORMAT_W(-25) \" ... \" INTX_FORMAT_W(25) \" ]\", min_intx, max_intx);\n+  }\n+};\n+\n+class FlagAccessImpl_uintx : public RangedFlagAccessImpl<JVM_FLAG_TYPE(uintx), EventUnsignedLongFlagChanged> {\n+public:\n+  void range_error(const char* name, uintx value, uintx min, uintx max, bool verbose) const {\n+    JVMFlag::printError(verbose,\n+                        \"uintx %s=\" UINTX_FORMAT \" is outside the allowed range \"\n+                        \"[ \" UINTX_FORMAT \" ... \" UINTX_FORMAT \" ]\\n\",\n+                        name, value, min, max);\n+  }\n+  JVMFlag::Error typed_check_constraint(void* func, uintx value, bool verbose) const {\n+    return ((JVMFlagConstraintFunc_uintx)func)(value, verbose);\n+  }\n+  void print_range_impl(outputStream* st, uintx min, uintx max) const {\n+    st->print(\"[ \" UINTX_FORMAT_W(-25) \" ... \" UINTX_FORMAT_W(25) \" ]\", min, max);\n+  }\n+  void print_default_range(outputStream* st) const {\n+    st->print(\"[ \" UINTX_FORMAT_W(-25) \" ... \" UINTX_FORMAT_W(25) \" ]\", uintx(0), max_uintx);\n+  }\n+};\n+\n+class FlagAccessImpl_uint64_t : public RangedFlagAccessImpl<JVM_FLAG_TYPE(uint64_t), EventUnsignedLongFlagChanged> {\n+public:\n+  void range_error(const char* name, uint64_t value, uint64_t min, uint64_t max, bool verbose) const {\n+    JVMFlag::printError(verbose,\n+                        \"uint64_t %s=\" UINT64_FORMAT \" is outside the allowed range \"\n+                        \"[ \" UINT64_FORMAT \" ... \" UINT64_FORMAT \" ]\\n\",\n+                        name, value, min, max);\n+  }\n+  JVMFlag::Error typed_check_constraint(void* func, uint64_t value, bool verbose) const {\n+    return ((JVMFlagConstraintFunc_uint64_t)func)(value, verbose);\n+  }\n+  void print_range_impl(outputStream* st, uint64_t min, uint64_t max) const {\n+    st->print(\"[ \" UINT64_FORMAT_W(-25) \" ... \" UINT64_FORMAT_W(25) \" ]\", min, max);\n+  }\n+  void print_default_range(outputStream* st) const {\n+    st->print(\"[ \" UINT64_FORMAT_W(-25) \" ... \" UINT64_FORMAT_W(25) \" ]\", uint64_t(0), uint64_t(max_juint));\n+  }\n+};\n+\n+class FlagAccessImpl_size_t : public RangedFlagAccessImpl<JVM_FLAG_TYPE(size_t), EventUnsignedLongFlagChanged> {\n+public:\n+  void range_error(const char* name, size_t value, size_t min, size_t max, bool verbose) const {\n+    JVMFlag::printError(verbose,\n+                        \"size_t %s=\" SIZE_FORMAT \" is outside the allowed range \"\n+                        \"[ \" SIZE_FORMAT \" ... \" SIZE_FORMAT \" ]\\n\",\n+                        name, value, min, max);\n+  }\n+  JVMFlag::Error typed_check_constraint(void* func, size_t value, bool verbose) const {\n+    return ((JVMFlagConstraintFunc_size_t)func)(value, verbose);\n+  }\n+  void print_range_impl(outputStream* st, size_t min, size_t max) const {\n+    st->print(\"[ \" SIZE_FORMAT_W(-25) \" ... \" SIZE_FORMAT_W(25) \" ]\", min, max);\n+  }\n+  void print_default_range(outputStream* st) const {\n+    st->print(\"[ \" SIZE_FORMAT_W(-25) \" ... \" SIZE_FORMAT_W(25) \" ]\", size_t(0), SIZE_MAX);\n+  }\n+};\n+\n+class FlagAccessImpl_double : public RangedFlagAccessImpl<JVM_FLAG_TYPE(double), EventDoubleFlagChanged> {\n+public:\n+  void range_error(const char* name, double value, double min, double max, bool verbose) const {\n+    JVMFlag::printError(verbose,\n+                          \"double %s=%f is outside the allowed range \"\n+                          \"[ %f ... %f ]\\n\",\n+                        name, value, min, max);\n+  }\n+  JVMFlag::Error typed_check_constraint(void* func, double value, bool verbose) const {\n+    return ((JVMFlagConstraintFunc_double)func)(value, verbose);\n+  }\n+  void print_range_impl(outputStream* st, double min, double max) const {\n+    st->print(\"[ %-25.3f ... %25.3f ]\", min, max);\n+  }\n+  void print_default_range(outputStream* st) const {\n+    st->print(\"[ %-25.3f ... %25.3f ]\", DBL_MIN, DBL_MAX);\n+  }\n+};\n+\n+#define FLAG_ACCESS_IMPL_INIT(t) \\\n+  static FlagAccessImpl_ ## t   flag_access_ ## t;\n+\n+#define FLAG_ACCESS_IMPL_ADDR(t) \\\n+  &flag_access_ ## t,\n+\n+JVM_FLAG_NON_STRING_TYPES_DO(FLAG_ACCESS_IMPL_INIT)\n+\n+static const FlagAccessImpl* flag_accesss[JVMFlag::NUM_FLAG_TYPES] = {\n+  JVM_FLAG_NON_STRING_TYPES_DO(FLAG_ACCESS_IMPL_ADDR)\n+  \/\/ ccstr and ccstrlist have special setter\n+};\n+\n+inline const FlagAccessImpl* JVMFlagAccess::access_impl(const JVMFlag* flag) {\n+  int type = flag->type();\n+  int max = (int)(sizeof(flag_accesss)\/sizeof(flag_accesss[0]));\n+  assert(type >= 0 && type < max , \"sanity\");\n+\n+  return flag_accesss[type];\n+}\n+\n+\/\/ This is called by JVMFlagAccess::*AtPut() and JVMFlagAccess::set<...>(JVMFlag* flag, ...)\n+JVMFlag::Error JVMFlagAccess::set_impl(JVMFlag* flag, int type_enum, void* value, JVMFlag::Flags origin) {\n+  if (type_enum == JVMFlag::TYPE_ccstr || type_enum == JVMFlag::TYPE_ccstrlist) {\n+    return ccstrAtPut(flag, (ccstr*)value, origin);\n+  }\n+\n+  if (flag == NULL) {\n+    return JVMFlag::INVALID_FLAG;\n+  }\n+  if (flag->type() != type_enum) {\n+    return JVMFlag::WRONG_FORMAT;\n+  }\n+  return access_impl(flag)->set(flag, value, origin);\n+}\n+\n+JVMFlag::Error JVMFlagAccess::ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin) {\n+  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n+  if (!flag->is_ccstr()) return JVMFlag::WRONG_FORMAT;\n+  ccstr old_value = flag->get_ccstr();\n+  trace_flag_changed<ccstr, EventStringFlagChanged>(flag, old_value, *value, origin);\n+  char* new_value = NULL;\n+  if (*value != NULL) {\n+    new_value = os::strdup_check_oom(*value);\n+  }\n+  flag->set_ccstr(new_value);\n+  if (flag->is_default() && old_value != NULL) {\n+    \/\/ Prior value is NOT heap allocated, but was a literal constant.\n+    old_value = os::strdup_check_oom(old_value);\n+  }\n+  *value = old_value;\n+  flag->set_origin(origin);\n+  return JVMFlag::SUCCESS;\n+}\n+\n+\/\/ This is called by the SET_FLAG_XXX macros.\n+JVMFlag::Error JVMFlagAccess::set_impl(JVMFlagsEnum flag_enum, int type_enum, void* value, JVMFlag::Flags origin) {\n+  if (type_enum == JVMFlag::TYPE_ccstr || type_enum == JVMFlag::TYPE_ccstrlist) {\n+    return ccstrAtPut((JVMFlagsEnum)flag_enum, *((ccstr*)value), origin);\n+  }\n+\n+  JVMFlag* flag = JVMFlag::flag_from_enum(flag_enum);\n+  assert(flag->type() == type_enum, \"wrong flag type\");\n+  return set_impl(flag, type_enum, value, origin);\n+}\n+\n+\/\/ This is called by the FLAG_SET_XXX macros.\n+JVMFlag::Error JVMFlagAccess::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin) {\n+  JVMFlag* faddr = JVMFlag::flag_from_enum(flag);\n+  assert(faddr->is_ccstr(), \"wrong flag type\");\n+  ccstr old_value = faddr->get_ccstr();\n+  trace_flag_changed<ccstr, EventStringFlagChanged>(faddr, old_value, value, origin);\n+  char* new_value = os::strdup_check_oom(value);\n+  faddr->set_ccstr(new_value);\n+  if (!faddr->is_default() && old_value != NULL) {\n+    \/\/ Prior value is heap allocated so free it.\n+    FREE_C_HEAP_ARRAY(char, old_value);\n+  }\n+  faddr->set_origin(origin);\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error JVMFlagAccess::check_range(const JVMFlag* flag, bool verbose) {\n+  return access_impl(flag)->check_range(flag, verbose);\n+}\n+\n+JVMFlag::Error JVMFlagAccess::check_constraint(const JVMFlag* flag, void * func, bool verbose) {\n+  return access_impl(flag)->check_constraint(flag, func, verbose);\n+}\n+\n+void JVMFlagAccess::print_range(outputStream* st, const JVMFlag* flag, const JVMFlagLimit* range) {\n+  return access_impl(flag)->print_range(st, range);\n+}\n+\n+void JVMFlagAccess::print_range(outputStream* st, const JVMFlag* flag) {\n+  const JVMFlagLimit* range = JVMFlagLimit::get_range(flag);\n+  if (range != NULL) {\n+    print_range(st, flag, range);\n+  } else {\n+    const JVMFlagLimit* limit = JVMFlagLimit::get_constraint(flag);\n+    if (limit != NULL) {\n+      void* func = limit->constraint_func();\n+\n+      \/\/ Two special cases where the lower limit of the range is defined by an os:: function call\n+      \/\/ and cannot be initialized at compile time with constexpr.\n+      if (func == (void*)VMPageSizeConstraintFunc) {\n+        uintx min = (uintx)os::vm_page_size();\n+        uintx max = max_uintx;\n+\n+        JVMTypedFlagLimit<uintx> tmp(0, min, max);\n+        access_impl(flag)->print_range(st, &tmp);\n+      } else if (func == (void*)NUMAInterleaveGranularityConstraintFunc) {\n+        size_t min = os::vm_allocation_granularity();\n+        size_t max = NOT_LP64(2*G) LP64_ONLY(8192*G);\n+\n+        JVMTypedFlagLimit<size_t> tmp(0, min, max);\n+        access_impl(flag)->print_range(st, &tmp);\n+      } else {\n+        access_impl(flag)->print_default_range(st);\n+      }\n+    } else {\n+      st->print(\"[                           ...                           ]\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":397,"deletions":0,"binary":false,"changes":397,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_FLAGS_JVMFLAGACCESS_HPP\n+#define SHARE_RUNTIME_FLAGS_JVMFLAGACCESS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+\n+enum JVMFlagsEnum : int;\n+\n+class FlagAccessImpl;\n+class JVMFlagLimit;\n+class outputStream;\n+\n+\/\/ Use this macro in combination with JVMFlag::{read, write} and JVMFlagAccess::{get, set}\n+\/\/ to safely access the underlying variable of a JVMFlag:\n+\/\/\n+\/\/  JVMFlag* flag = JVMFlag::flag_from_enum(FLAG_MEMBER_ENUM(ObjectAlignmentInBytes));\n+\/\/\n+\/\/  \/* If you use a wrong type, a run-time assertion will happen *\/\n+\/\/  intx v = flag->read<JVM_FLAG_TYPE(intx)>();\n+\/\/\n+\/\/  \/* If you use a wrong type, or a NULL flag, an error code is returned *\/\n+\/\/  JVMFlag::Error err = JVMFlagAccess::get<JVM_FLAG_TYPE(intx)>(flag, &v);\n+\n+#define JVM_FLAG_TYPE(t) \\\n+  t, JVMFlag::TYPE_ ## t\n+\n+\/\/ This class provides a unified interface for getting\/setting the JVM flags, with support\n+\/\/ for (1) type correctness checks, (2) range checks, (3) constraint checks. Two main types\n+\/\/ of setters are provided. See notes below on which one to use.\n+class JVMFlagAccess : AllStatic {\n+  inline static const FlagAccessImpl* access_impl(const JVMFlag* flag);\n+  static JVMFlag::Error set_impl(JVMFlagsEnum flag_enum, int type_enum, void* value, JVMFlag::Flags origin);\n+  static JVMFlag::Error set_impl(JVMFlag* flag, int type_enum, void* value, JVMFlag::Flags origin);\n+  static JVMFlag::Error ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin);\n+\n+public:\n+  static JVMFlag::Error check_range(const JVMFlag* flag, bool verbose);\n+  static JVMFlag::Error check_constraint(const JVMFlag* flag, void * func, bool verbose);\n+  static void print_range(outputStream* st, const JVMFlag* flag, const JVMFlagLimit* range);\n+  static void print_range(outputStream* st, const JVMFlag* flag);\n+\n+  template <typename T, int type_enum>\n+  static JVMFlag::Error get(const JVMFlag* flag, T* value) {\n+    if (flag == NULL) {\n+      return JVMFlag::INVALID_FLAG;\n+    }\n+    if (type_enum == JVMFlag::TYPE_ccstr) {\n+      if (!flag->is_ccstr()) { \/\/ ccstr or ccstrlist\n+        return JVMFlag::WRONG_FORMAT;\n+      }\n+    } else {\n+      if (flag->type() != type_enum) {\n+        return JVMFlag::WRONG_FORMAT;\n+      }\n+    }\n+    *value = flag->read<T, type_enum>();\n+    return JVMFlag::SUCCESS;\n+  }\n+\n+  \/\/ This is a *flag specific* setter. It should be used only via by the\n+  \/\/ SET_FLAG_{DEFAULT, CMDLINE, ERGO, MGMT} macros.\n+  \/\/ It's used to set a specific flag whose type is statically known. A mismatched\n+  \/\/ type_enum will result in an assert.\n+  template <typename T, int type_enum>\n+  static JVMFlag::Error set(JVMFlagsEnum flag_enum, T value, JVMFlag::Flags origin) {\n+    return set_impl(flag_enum, type_enum, &value, origin);\n+  }\n+\n+  \/\/ This setter, and the xxxAtPut functions below, are *generic* setters. They should be used\n+  \/\/ by code that can set a number of different flags, often according to external input that\n+  \/\/ may contain errors.\n+  \/\/ Examples callers are arguments.cpp, writeableFlags.cpp, and WB_SetXxxVMFlag functions.\n+  \/\/ A mismatched type_enum would result in a JVMFlag::WRONG_FORMAT code.\n+  template <typename T, int type_enum>\n+  static JVMFlag::Error set(JVMFlag* flag, T* value, JVMFlag::Flags origin) {\n+    return set_impl(flag, type_enum, (void*)value, origin);\n+  }\n+\n+  static JVMFlag::Error boolAtPut    (JVMFlag* f, bool*     v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(bool)>    (f, v, origin); }\n+  static JVMFlag::Error intAtPut     (JVMFlag* f, int*      v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(int)>     (f, v, origin); }\n+  static JVMFlag::Error uintAtPut    (JVMFlag* f, uint*     v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(uint)>    (f, v, origin); }\n+  static JVMFlag::Error intxAtPut    (JVMFlag* f, intx*     v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(intx)>    (f, v, origin); }\n+  static JVMFlag::Error uintxAtPut   (JVMFlag* f, uintx*    v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(uintx)>   (f, v, origin); }\n+  static JVMFlag::Error uint64_tAtPut(JVMFlag* f, uint64_t* v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(uint64_t)>(f, v, origin); }\n+  static JVMFlag::Error size_tAtPut  (JVMFlag* f, size_t*   v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(size_t)>  (f, v, origin); }\n+  static JVMFlag::Error doubleAtPut  (JVMFlag* f, double*   v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(double)>  (f, v, origin); }\n+\n+  \/\/ Special handling needed for ccstr\n+  \/\/ Contract:  JVMFlag will make private copy of the incoming value.\n+  \/\/ Outgoing value is always malloc-ed, and caller MUST call free.\n+  static JVMFlag::Error ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin);\n+\n+  \/\/ Handy aliases\n+  static JVMFlag::Error ccstrAt(const JVMFlag* flag, ccstr* value) {\n+    return get<ccstr, JVMFlag::TYPE_ccstr>(flag, value);\n+  }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_FLAGS_JVMFLAGACCESS_HPP\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.hpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -1,227 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"gc\/shared\/jvmFlagConstraintsGC.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/flags\/jvmFlag.hpp\"\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n-#include \"runtime\/flags\/jvmFlagConstraintsCompiler.hpp\"\n-#include \"runtime\/flags\/jvmFlagConstraintsRuntime.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class JVMFlagConstraint_bool : public JVMFlagConstraint {\n-  JVMFlagConstraintFunc_bool _constraint;\n-\n-public:\n-  JVMFlagConstraint_bool(const JVMFlag* flag,\n-                         JVMFlagConstraintFunc_bool func,\n-                         ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}\n-\n-  JVMFlag::Error apply(bool verbose) {\n-    return _constraint(_flag->get_bool(), verbose);\n-  }\n-\n-  JVMFlag::Error apply_bool(bool value, bool verbose) {\n-    return _constraint(value, verbose);\n-  }\n-};\n-\n-class JVMFlagConstraint_int : public JVMFlagConstraint {\n-  JVMFlagConstraintFunc_int _constraint;\n-\n-public:\n-  JVMFlagConstraint_int(const JVMFlag* flag,\n-                        JVMFlagConstraintFunc_int func,\n-                        ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}\n-\n-  JVMFlag::Error apply(bool verbose) {\n-    return _constraint(_flag->get_int(), verbose);\n-  }\n-\n-  JVMFlag::Error apply_int(int value, bool verbose) {\n-    return _constraint(value, verbose);\n-  }\n-};\n-\n-class JVMFlagConstraint_intx : public JVMFlagConstraint {\n-  JVMFlagConstraintFunc_intx _constraint;\n-\n-public:\n-  JVMFlagConstraint_intx(const JVMFlag* flag,\n-                         JVMFlagConstraintFunc_intx func,\n-                         ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}\n-\n-  JVMFlag::Error apply(bool verbose) {\n-    return _constraint(_flag->get_intx(), verbose);\n-  }\n-\n-  JVMFlag::Error apply_intx(intx value, bool verbose) {\n-    return _constraint(value, verbose);\n-  }\n-};\n-\n-class JVMFlagConstraint_uint : public JVMFlagConstraint {\n-  JVMFlagConstraintFunc_uint _constraint;\n-\n-public:\n-  JVMFlagConstraint_uint(const JVMFlag* flag,\n-                         JVMFlagConstraintFunc_uint func,\n-                         ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}\n-\n-  JVMFlag::Error apply(bool verbose) {\n-    return _constraint(_flag->get_uint(), verbose);\n-  }\n-\n-  JVMFlag::Error apply_uint(uint value, bool verbose) {\n-    return _constraint(value, verbose);\n-  }\n-};\n-\n-class JVMFlagConstraint_uintx : public JVMFlagConstraint {\n-  JVMFlagConstraintFunc_uintx _constraint;\n-\n-public:\n-  JVMFlagConstraint_uintx(const JVMFlag* flag,\n-                          JVMFlagConstraintFunc_uintx func,\n-                          ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}\n-\n-  JVMFlag::Error apply(bool verbose) {\n-    return _constraint(_flag->get_uintx(), verbose);\n-  }\n-\n-  JVMFlag::Error apply_uintx(uintx value, bool verbose) {\n-    return _constraint(value, verbose);\n-  }\n-};\n-\n-class JVMFlagConstraint_uint64_t : public JVMFlagConstraint {\n-  JVMFlagConstraintFunc_uint64_t _constraint;\n-\n-public:\n-  JVMFlagConstraint_uint64_t(const JVMFlag* flag,\n-                             JVMFlagConstraintFunc_uint64_t func,\n-                             ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}\n-\n-  JVMFlag::Error apply(bool verbose) {\n-    return _constraint(_flag->get_uint64_t(), verbose);\n-  }\n-\n-  JVMFlag::Error apply_uint64_t(uint64_t value, bool verbose) {\n-    return _constraint(value, verbose);\n-  }\n-};\n-\n-class JVMFlagConstraint_size_t : public JVMFlagConstraint {\n-  JVMFlagConstraintFunc_size_t _constraint;\n-\n-public:\n-  JVMFlagConstraint_size_t(const JVMFlag* flag,\n-                           JVMFlagConstraintFunc_size_t func,\n-                           ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}\n-\n-  JVMFlag::Error apply(bool verbose) {\n-    return _constraint(_flag->get_size_t(), verbose);\n-  }\n-\n-  JVMFlag::Error apply_size_t(size_t value, bool verbose) {\n-    return _constraint(value, verbose);\n-  }\n-};\n-\n-class JVMFlagConstraint_double : public JVMFlagConstraint {\n-  JVMFlagConstraintFunc_double _constraint;\n-\n-public:\n-  JVMFlagConstraint_double(const JVMFlag* flag,\n-                           JVMFlagConstraintFunc_double func,\n-                           ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}\n-\n-  JVMFlag::Error apply(bool verbose) {\n-    return _constraint(_flag->get_double(), verbose);\n-  }\n-\n-  JVMFlag::Error apply_double(double value, bool verbose) {\n-    return _constraint(value, verbose);\n-  }\n-};\n-\n-#define DEFINE_CONSTRAINT_APPLY(T) \\\n-JVMFlag::Error JVMFlagConstraintChecker::apply_ ## T(T value, bool verbose) const {           \\\n-  assert(exists(), \"must be\");                                                                \\\n-  JVMFlagConstraint_ ## T constraint(_flag,                                                   \\\n-                                     (JVMFlagConstraintFunc_ ## T)_limit->constraint_func(),  \\\n-                                     (JVMFlagConstraint::ConstraintType)_limit->phase());     \\\n-  return constraint.apply_ ## T(value, verbose);                                              \\\n-}\n-\n-ALL_CONSTRAINT_TYPES(DEFINE_CONSTRAINT_APPLY)\n-\n-\n-JVMFlag::Error JVMFlagConstraintChecker::apply(bool verbose) const {\n-#define APPLY_CONSTRAINT(T)                                                                     \\\n-  if (_flag->is_ ## T()) {                                                                      \\\n-    JVMFlagConstraint_ ## T constraint(_flag,                                                   \\\n-                                       (JVMFlagConstraintFunc_ ## T)_limit->constraint_func(),  \\\n-                                       (JVMFlagConstraint::ConstraintType)_limit->phase());     \\\n-    return constraint.apply(verbose);                                                           \\\n-  }\n-\n-  ALL_CONSTRAINT_TYPES(APPLY_CONSTRAINT);\n-\n-  ShouldNotReachHere();\n-  return JVMFlag::INVALID_FLAG;\n-}\n-\n-\n-JVMFlagConstraint::ConstraintType JVMFlagConstraintList::_validating_type = JVMFlagConstraint::AtParse;\n-\n-\/\/ Find constraints and return only if found constraint's type is equal or lower than current validating type.\n-JVMFlagConstraintChecker JVMFlagConstraintList::find_if_needs_check(const JVMFlag* flag) {\n-  JVMFlagConstraintChecker constraint = JVMFlagConstraintList::find(flag);\n-  if (constraint.exists() && (constraint.type() <= _validating_type)) {\n-    return constraint;\n-  }\n-  return JVMFlagConstraintChecker(flag, NULL);\n-}\n-\n-\/\/ Check constraints for specific constraint type.\n-bool JVMFlagConstraintList::check_constraints(JVMFlagConstraint::ConstraintType type) {\n-  guarantee(type > _validating_type, \"Constraint check is out of order.\");\n-  _validating_type = type;\n-\n-  bool status = true;\n-  for (int i = 0; i < NUM_JVMFlagsEnum; i++) {\n-    JVMFlagConstraintChecker constraint(&JVMFlag::flags[i], JVMFlagLimit::get_constraint_at(i));\n-    if (!constraint.exists()) continue;\n-    if (type != constraint.type()) continue;\n-    if (constraint.apply(true) != JVMFlag::SUCCESS) status = false;\n-  }\n-  return status;\n-}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintList.cpp","additions":0,"deletions":227,"binary":false,"changes":227,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_FLAGS_JVMFLAGCONSTRAINTLIST_HPP\n-#define SHARE_RUNTIME_FLAGS_JVMFLAGCONSTRAINTLIST_HPP\n-\n-#include \"runtime\/flags\/jvmFlag.hpp\"\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n-\n-\/*\n- * Here we have a mechanism for extracting constraints (as custom functions) for flags,\n- * which otherwise can not be expressed via simple range check, specified in flag macro tables.\n- *\n- * An example of a constraint is \"flag1 < flag2\" where both flag1 and flag2 can change.\n- *\n- * See runtime \"runtime\/flags\/jvmFlagConstraintsCompiler.hpp\",\n- * \"runtime\/flags\/jvmFlagConstraintsGC.hpp\" and\n- * \"runtime\/flags\/jvmFlagConstraintsRuntime.hpp\" for the functions themselves.\n- *\/\n-\n-typedef JVMFlag::Error (*JVMFlagConstraintFunc_bool)(bool value, bool verbose);\n-typedef JVMFlag::Error (*JVMFlagConstraintFunc_int)(int value, bool verbose);\n-typedef JVMFlag::Error (*JVMFlagConstraintFunc_intx)(intx value, bool verbose);\n-typedef JVMFlag::Error (*JVMFlagConstraintFunc_uint)(uint value, bool verbose);\n-typedef JVMFlag::Error (*JVMFlagConstraintFunc_uintx)(uintx value, bool verbose);\n-typedef JVMFlag::Error (*JVMFlagConstraintFunc_uint64_t)(uint64_t value, bool verbose);\n-typedef JVMFlag::Error (*JVMFlagConstraintFunc_size_t)(size_t value, bool verbose);\n-typedef JVMFlag::Error (*JVMFlagConstraintFunc_double)(double value, bool verbose);\n-\n-class JVMFlagConstraint : public CHeapObj<mtArguments> {\n-public:\n-  \/\/ During VM initialization, constraint validation will be done order of ConstraintType.\n-  enum ConstraintType {\n-    \/\/ Will be validated during argument processing (Arguments::parse_argument).\n-    AtParse         = 0,\n-    \/\/ Will be validated inside Threads::create_vm(), right after Arguments::apply_ergo().\n-    AfterErgo       = 1,\n-    \/\/ Will be validated inside universe_init(), right after Metaspace::global_initialize().\n-    AfterMemoryInit = 2\n-  };\n-\n-protected:\n-  const JVMFlag* const _flag;\n-\n-private:\n-  ConstraintType _validate_type;\n-\n-public:\n-  \/\/ the \"name\" argument must be a string literal\n-  JVMFlagConstraint(const JVMFlag* flag, ConstraintType type) : _flag(flag), _validate_type(type) {}\n-  ~JVMFlagConstraint() {}\n-  const JVMFlag* flag() const { return _flag; }\n-  ConstraintType type() const { return _validate_type; }\n-  virtual JVMFlag::Error apply(bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-  virtual JVMFlag::Error apply_bool(bool value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-  virtual JVMFlag::Error apply_int(int value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-  virtual JVMFlag::Error apply_intx(intx value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-  virtual JVMFlag::Error apply_uint(uint value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-  virtual JVMFlag::Error apply_uintx(uintx value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-  virtual JVMFlag::Error apply_uint64_t(uint64_t value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-  virtual JVMFlag::Error apply_size_t(size_t value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-  virtual JVMFlag::Error apply_double(double value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; };\n-};\n-\n-class JVMFlagConstraintChecker {\n-  const JVMFlag* _flag;\n-  const JVMFlagLimit* _limit;\n-\n-public:\n-  JVMFlagConstraintChecker(const JVMFlag* flag, const JVMFlagLimit* limit) : _flag(flag), _limit(limit) {}\n-  bool exists() const { return _limit != NULL; }\n-  JVMFlag::Error apply(bool verbose = true) const;\n-\n-  JVMFlagConstraint::ConstraintType type() const { return (JVMFlagConstraint::ConstraintType)_limit->phase(); }\n-#define DECLARE_CONSTRAINT_APPLY(T) JVMFlag::Error apply_ ## T(T new_value, bool verbose = true) const;\n-  ALL_CONSTRAINT_TYPES(DECLARE_CONSTRAINT_APPLY)\n-};\n-\n-class JVMFlagConstraintList : public AllStatic {\n-private:\n-  \/\/ Latest constraint validation type.\n-  static JVMFlagConstraint::ConstraintType _validating_type;\n-public:\n-  static void init();\n-  static JVMFlagConstraintChecker find(const JVMFlag* flag) { return JVMFlagConstraintChecker(flag, JVMFlagLimit::get_constraint(flag)); }\n-  static JVMFlagConstraintChecker find_if_needs_check(const JVMFlag* flag);\n-  \/\/ True if 'AfterErgo' or later constraint functions are validated.\n-  static bool validated_after_ergo() { return _validating_type >= JVMFlagConstraint::AfterErgo; };\n-  static bool check_constraints(JVMFlagConstraint::ConstraintType type);\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_FLAGS_JVMFLAGCONSTRAINTLIST_HPP\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintList.hpp","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -142,2 +142,2 @@\n-                        JVMFlagLimit::last_checked_flag()->_type,\n-                        JVMFlagLimit::last_checked_flag()->_name,\n+                        JVMFlagLimit::last_checked_flag()->type_string(),\n+                        JVMFlagLimit::last_checked_flag()->name(),\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n@@ -101,1 +100,1 @@\n-#define APPLY_FLAG_CONSTRAINT(func, phase)             , next_two_args_are_constraint, (short)CONSTRAINT_ENUM(func), int(JVMFlagConstraint::phase)\n+#define APPLY_FLAG_CONSTRAINT(func, phase)             , next_two_args_are_constraint, (short)CONSTRAINT_ENUM(func), int(JVMFlagConstraintPhase::phase)\n@@ -148,1 +147,2 @@\n-int JVMFlagLimit::_last_checked = -1;\n+JVMFlagsEnum JVMFlagLimit::_last_checked = static_cast<JVMFlagsEnum>(-1);\n+JVMFlagConstraintPhase JVMFlagLimit::_validating_phase = JVMFlagConstraintPhase::AtParse;;\n@@ -151,0 +151,34 @@\n+\n+bool JVMFlagLimit::check_all_ranges() {\n+  bool status = true;\n+  for (int i = 0; i < NUM_JVMFlagsEnum; i++) {\n+    JVMFlagsEnum flag_enum = static_cast<JVMFlagsEnum>(i);\n+    if (get_range_at(flag_enum) != NULL &&\n+        JVMFlagAccess::check_range(JVMFlag::flag_from_enum(flag_enum), true) != JVMFlag::SUCCESS) {\n+      status = false;\n+    }\n+  }\n+  return status;\n+}\n+\n+\/\/ Check constraints for specific constraint phase.\n+bool JVMFlagLimit::check_all_constraints(JVMFlagConstraintPhase phase) {\n+  guarantee(phase > _validating_phase, \"Constraint check is out of order.\");\n+  _validating_phase = phase;\n+\n+  bool status = true;\n+  for (int i = 0; i < NUM_JVMFlagsEnum; i++) {\n+    JVMFlagsEnum flag_enum = static_cast<JVMFlagsEnum>(i);\n+    const JVMFlagLimit* constraint = get_constraint_at(flag_enum);\n+    if (constraint != NULL && constraint->phase() == static_cast<int>(phase) &&\n+        JVMFlagAccess::check_constraint(JVMFlag::flag_from_enum(flag_enum),\n+                                        constraint->constraint_func(), true) != JVMFlag::SUCCESS) {\n+      status = false;\n+    }\n+  }\n+  return status;\n+}\n+\n+void JVMFlagLimit::print_range(outputStream* st, const JVMFlag* flag) const {\n+  JVMFlagAccess::print_range(st, flag, this);\n+}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -30,12 +30,1 @@\n-#define ALL_LIMIT_TYPES(f)  \\\n-  f(int)                    \\\n-  f(intx)                   \\\n-  f(uint)                   \\\n-  f(uintx)                  \\\n-  f(uint64_t)               \\\n-  f(size_t)                 \\\n-  f(double)\n-\n-#define ALL_RANGE_TYPES(f) ALL_LIMIT_TYPES(f)\n-#define ALL_CONSTRAINT_TYPES(f) ALL_LIMIT_TYPES(f) f(bool)\n-\n+class outputStream;\n@@ -44,0 +33,18 @@\n+enum class JVMFlagConstraintPhase : int {\n+  \/\/ Will be validated during argument processing (Arguments::parse_argument).\n+  AtParse         = 0,\n+  \/\/ Will be validated inside Threads::create_vm(), right after Arguments::apply_ergo().\n+  AfterErgo       = 1,\n+  \/\/ Will be validated inside universe_init(), right after Metaspace::global_initialize().\n+  AfterMemoryInit = 2\n+};\n+\n+\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_bool)(bool value, bool verbose);\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_int)(int value, bool verbose);\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_intx)(intx value, bool verbose);\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_uint)(uint value, bool verbose);\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_uintx)(uintx value, bool verbose);\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_uint64_t)(uint64_t value, bool verbose);\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_size_t)(size_t value, bool verbose);\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_double)(double value, bool verbose);\n@@ -64,1 +71,2 @@\n-  static int _last_checked;\n+  static JVMFlagsEnum _last_checked;\n+  static JVMFlagConstraintPhase _validating_phase;\n@@ -71,1 +79,1 @@\n-  static const JVMFlagLimit* get_kind_at(int flag_enum, int required_kind) {\n+  static const JVMFlagLimit* get_kind_at(JVMFlagsEnum flag_enum, int required_kind) {\n@@ -81,1 +89,1 @@\n-  static const JVMFlagLimit* at(int flag_enum) {\n+  static const JVMFlagLimit* at(JVMFlagsEnum flag_enum) {\n@@ -83,1 +91,1 @@\n-    return flagLimits[flag_enum];\n+    return flagLimits[static_cast<int>(flag_enum)];\n@@ -96,1 +104,1 @@\n-  static const JVMFlagLimit* get_range_at(int flag_enum) {\n+  static const JVMFlagLimit* get_range_at(JVMFlagsEnum flag_enum) {\n@@ -103,1 +111,1 @@\n-  static const JVMFlagLimit* get_constraint_at(int flag_enum) {\n+  static const JVMFlagLimit* get_constraint_at(JVMFlagsEnum flag_enum) {\n@@ -108,1 +116,1 @@\n-    if (_last_checked >= 0) {\n+    if (static_cast<int>(_last_checked) >= 0) {\n@@ -115,2 +123,3 @@\n-#define AS_TYPED_LIMIT(type) inline JVMTypedFlagLimit<type>* as_ ## type() const { return (JVMTypedFlagLimit<type>*)this; }\n-  ALL_RANGE_TYPES(AS_TYPED_LIMIT)\n+  \/\/ Is the current value of each JVM flag within the allowed range (if specified)\n+  static bool check_all_ranges();\n+  void print_range(outputStream* st, const JVMFlag* flag) const;\n@@ -118,0 +127,4 @@\n+  \/\/ Does the current value of each JVM flag satisfy the specified constraint\n+  static bool check_all_constraints(JVMFlagConstraintPhase phase);\n+  static bool validated_after_ergo() { return _validating_phase >= JVMFlagConstraintPhase::AfterErgo; };\n+  static JVMFlagConstraintPhase validating_phase() { return _validating_phase; }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.hpp","additions":34,"deletions":21,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-      if (strncmp(name, flag->_name, length) == 0) {\n-        \/\/ We know flag->_name has at least <length> bytes.\n+      if (strncmp(name, flag->name(), length) == 0) {\n+        \/\/ We know flag->name() has at least <length> bytes.\n@@ -65,1 +65,1 @@\n-        if (flag->_name[length] == 0) {\n+        if (flag->name()[length] == 0) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,321 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"jvm.h\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/flags\/jvmFlag.hpp\"\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n-#include \"runtime\/flags\/jvmFlagConstraintsRuntime.hpp\"\n-#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/task.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class JVMFlagRange_int : public JVMFlagRange {\n-  int _min;\n-  int _max;\n-\n-public:\n-  JVMFlagRange_int(const JVMFlag* flag, int min, int max)\n-    : JVMFlagRange(flag), _min(min), _max(max) {}\n-\n-  JVMFlag::Error check(bool verbose = true) {\n-    return check_int(_flag->get_int(), verbose);\n-  }\n-\n-  JVMFlag::Error check_int(int value, bool verbose = true) {\n-    if ((value < _min) || (value > _max)) {\n-      JVMFlag::printError(verbose,\n-                          \"int %s=%d is outside the allowed range \"\n-                          \"[ %d ... %d ]\\n\",\n-                          name(), value, _min, _max);\n-      return JVMFlag::OUT_OF_BOUNDS;\n-    } else {\n-      return JVMFlag::SUCCESS;\n-    }\n-  }\n-\n-  void print(outputStream* st) {\n-    st->print(\"[ %-25d ... %25d ]\", _min, _max);\n-  }\n-};\n-\n-class JVMFlagRange_intx : public JVMFlagRange {\n-  intx _min;\n-  intx _max;\n-\n-public:\n-  JVMFlagRange_intx(const JVMFlag* flag, intx min, intx max)\n-    : JVMFlagRange(flag), _min(min), _max(max) {}\n-\n-  JVMFlag::Error check(bool verbose = true) {\n-    return check_intx(_flag->get_intx(), verbose);\n-  }\n-\n-  JVMFlag::Error check_intx(intx value, bool verbose = true) {\n-    if ((value < _min) || (value > _max)) {\n-      JVMFlag::printError(verbose,\n-                          \"intx %s=\" INTX_FORMAT \" is outside the allowed range \"\n-                          \"[ \" INTX_FORMAT \" ... \" INTX_FORMAT \" ]\\n\",\n-                          name(), value, _min, _max);\n-      return JVMFlag::OUT_OF_BOUNDS;\n-    } else {\n-      return JVMFlag::SUCCESS;\n-    }\n-  }\n-\n-  void print(outputStream* st) {\n-    st->print(\"[ \" INTX_FORMAT_W(-25) \" ... \" INTX_FORMAT_W(25) \" ]\", _min, _max);\n-  }\n-};\n-\n-class JVMFlagRange_uint : public JVMFlagRange {\n-  uint _min;\n-  uint _max;\n-\n-public:\n-  JVMFlagRange_uint(const JVMFlag* flag, uint min, uint max)\n-    : JVMFlagRange(flag), _min(min), _max(max) {}\n-\n-  JVMFlag::Error check(bool verbose = true) {\n-    return check_uint(_flag->get_uint(), verbose);\n-  }\n-\n-  JVMFlag::Error check_uint(uint value, bool verbose = true) {\n-    if ((value < _min) || (value > _max)) {\n-      JVMFlag::printError(verbose,\n-                          \"uint %s=%u is outside the allowed range \"\n-                          \"[ %u ... %u ]\\n\",\n-                          name(), value, _min, _max);\n-      return JVMFlag::OUT_OF_BOUNDS;\n-    } else {\n-      return JVMFlag::SUCCESS;\n-    }\n-  }\n-\n-  void print(outputStream* st) {\n-    st->print(\"[ %-25u ... %25u ]\", _min, _max);\n-  }\n-};\n-\n-class JVMFlagRange_uintx : public JVMFlagRange {\n-  uintx _min;\n-  uintx _max;\n-\n-public:\n-  JVMFlagRange_uintx(const JVMFlag* flag, uintx min, uintx max)\n-    : JVMFlagRange(flag), _min(min), _max(max) {}\n-\n-  JVMFlag::Error check(bool verbose = true) {\n-    return check_uintx(_flag->get_uintx(), verbose);\n-  }\n-\n-  JVMFlag::Error check_uintx(uintx value, bool verbose = true) {\n-    if ((value < _min) || (value > _max)) {\n-      JVMFlag::printError(verbose,\n-                          \"uintx %s=\" UINTX_FORMAT \" is outside the allowed range \"\n-                          \"[ \" UINTX_FORMAT \" ... \" UINTX_FORMAT \" ]\\n\",\n-                          name(), value, _min, _max);\n-      return JVMFlag::OUT_OF_BOUNDS;\n-    } else {\n-      return JVMFlag::SUCCESS;\n-    }\n-  }\n-\n-  void print(outputStream* st) {\n-    st->print(\"[ \" UINTX_FORMAT_W(-25) \" ... \" UINTX_FORMAT_W(25) \" ]\", _min, _max);\n-  }\n-};\n-\n-class JVMFlagRange_uint64_t : public JVMFlagRange {\n-  uint64_t _min;\n-  uint64_t _max;\n-\n-public:\n-  JVMFlagRange_uint64_t(const JVMFlag* flag, uint64_t min, uint64_t max)\n-    : JVMFlagRange(flag), _min(min), _max(max) {}\n-\n-  JVMFlag::Error check(bool verbose = true) {\n-    return check_uint64_t(_flag->get_uintx(), verbose);\n-  }\n-\n-  JVMFlag::Error check_uint64_t(uint64_t value, bool verbose = true) {\n-    if ((value < _min) || (value > _max)) {\n-      JVMFlag::printError(verbose,\n-                          \"uint64_t %s=\" UINT64_FORMAT \" is outside the allowed range \"\n-                          \"[ \" UINT64_FORMAT \" ... \" UINT64_FORMAT \" ]\\n\",\n-                          name(), value, _min, _max);\n-      return JVMFlag::OUT_OF_BOUNDS;\n-    } else {\n-      return JVMFlag::SUCCESS;\n-    }\n-  }\n-\n-  void print(outputStream* st) {\n-    st->print(\"[ \" UINT64_FORMAT_W(-25) \" ... \" UINT64_FORMAT_W(25) \" ]\", _min, _max);\n-  }\n-};\n-\n-class JVMFlagRange_size_t : public JVMFlagRange {\n-  size_t _min;\n-  size_t _max;\n-\n-public:\n-  JVMFlagRange_size_t(const JVMFlag* flag, size_t min, size_t max)\n-    : JVMFlagRange(flag), _min(min), _max(max) {}\n-\n-  JVMFlag::Error check(bool verbose = true) {\n-    return check_size_t(_flag->get_size_t(), verbose);\n-  }\n-\n-  JVMFlag::Error check_size_t(size_t value, bool verbose = true) {\n-    if ((value < _min) || (value > _max)) {\n-      JVMFlag::printError(verbose,\n-                          \"size_t %s=\" SIZE_FORMAT \" is outside the allowed range \"\n-                          \"[ \" SIZE_FORMAT \" ... \" SIZE_FORMAT \" ]\\n\",\n-                          name(), value, _min, _max);\n-      return JVMFlag::OUT_OF_BOUNDS;\n-    } else {\n-      return JVMFlag::SUCCESS;\n-    }\n-  }\n-\n-  void print(outputStream* st) {\n-    st->print(\"[ \" SIZE_FORMAT_W(-25) \" ... \" SIZE_FORMAT_W(25) \" ]\", _min, _max);\n-  }\n-};\n-\n-class JVMFlagRange_double : public JVMFlagRange {\n-  double _min;\n-  double _max;\n-\n-public:\n-  JVMFlagRange_double(const JVMFlag* flag, double min, double max)\n-    : JVMFlagRange(flag), _min(min), _max(max) {}\n-\n-  JVMFlag::Error check(bool verbose = true) {\n-    return check_double(_flag->get_double(), verbose);\n-  }\n-\n-  JVMFlag::Error check_double(double value, bool verbose = true) {\n-    if ((value < _min) || (value > _max)) {\n-      JVMFlag::printError(verbose,\n-                          \"double %s=%f is outside the allowed range \"\n-                          \"[ %f ... %f ]\\n\",\n-                          name(), value, _min, _max);\n-      return JVMFlag::OUT_OF_BOUNDS;\n-    } else {\n-      return JVMFlag::SUCCESS;\n-    }\n-  }\n-\n-  void print(outputStream* st) {\n-    st->print(\"[ %-25.3f ... %25.3f ]\", _min, _max);\n-  }\n-};\n-\n-#define DEFINE_RANGE_CHECK(T)                                                            \\\n-JVMFlag::Error JVMFlagRangeChecker::check_ ## T(T value, bool verbose) const {           \\\n-  assert(exists(), \"must be\");                                                           \\\n-  JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n-  return range.check_ ## T(value, verbose);                                              \\\n-}\n-\n-ALL_RANGE_TYPES(DEFINE_RANGE_CHECK)\n-\n-\n-JVMFlag::Error JVMFlagRangeChecker::check(bool verbose) const {\n-#define CHECK_RANGE(T)                                                                     \\\n-  if (_flag->is_ ## T()) {                                                                 \\\n-    JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n-    return range.check(verbose);                                                           \\\n-  }\n-\n-  ALL_RANGE_TYPES(CHECK_RANGE);\n-\n-  ShouldNotReachHere();\n-  return JVMFlag::INVALID_FLAG;\n-}\n-\n-void JVMFlagRangeChecker::print(outputStream* out) const {\n-#define PRINT_RANGE(T)                                                                     \\\n-  if (_flag->is_ ## T()) {                                                                 \\\n-    JVMFlagRange_ ## T range(_flag, _limit->as_ ## T()->min(), _limit->as_ ## T()->max()); \\\n-    range.print(out);                                                                      \\\n-    return;                                                                                \\\n-  }\n-\n-  ALL_RANGE_TYPES(PRINT_RANGE);\n-\n-  ShouldNotReachHere();\n-}\n-\n-void JVMFlagRangeList::print(outputStream* st, const JVMFlag* flag, RangeStrFunc default_range_str_func) {\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n-    range.print(st);\n-  } else {\n-    const JVMFlagLimit* limit = JVMFlagLimit::get_constraint(flag);\n-    if (limit != NULL) {\n-      void* func = limit->constraint_func();\n-\n-      \/\/ Two special cases where the lower limit of the range is defined by an os:: function call\n-      \/\/ and cannot be initialized at compile time with constexpr.\n-      if (func == (void*)VMPageSizeConstraintFunc) {\n-        uintx min = (uintx)os::vm_page_size();\n-        uintx max = max_uintx;\n-\n-        JVMFlagRange_uintx tmp(flag, min, max);\n-        tmp.print(st);\n-      } else if (func == (void*)NUMAInterleaveGranularityConstraintFunc) {\n-        size_t min = os::vm_allocation_granularity();\n-        size_t max = NOT_LP64(2*G) LP64_ONLY(8192*G);\n-\n-        JVMFlagRange_size_t tmp(flag, min, max);\n-        tmp.print(st);\n-      } else {\n-        assert(default_range_str_func!=NULL, \"default_range_str_func must be provided\");\n-        st->print(\"%s\", default_range_str_func());\n-      }\n-    } else {\n-      st->print(\"[                           ...                           ]\");\n-    }\n-  }\n-}\n-\n-bool JVMFlagRangeList::check_ranges() {\n-  bool status = true;\n-  for (int i = 0; i < NUM_JVMFlagsEnum; i++) {\n-    JVMFlagRangeChecker range(&JVMFlag::flags[i], JVMFlagLimit::get_range_at(i));\n-    if (range.exists() && range.check(true) != JVMFlag::SUCCESS) status = false;\n-  }\n-  return status;\n-}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagRangeList.cpp","additions":0,"deletions":321,"binary":false,"changes":321,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP\n-#define SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP\n-\n-#include \"runtime\/flags\/jvmFlag.hpp\"\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n-\n-\/*\n- * Here we have a mechanism for extracting ranges specified in flag macro tables.\n- *\n- * The specified ranges are used to verify that flags have valid values.\n- *\n- * An example of a range is \"min <= flag <= max\". Both \"min\" and \"max\" must be\n- * constant and can not change. If either \"min\" or \"max\" can change,\n- * then we need to use constraint instead.\n- *\/\n-\n-class JVMFlagRange : public CHeapObj<mtArguments> {\n-protected:\n-  const JVMFlag* const _flag;\n-public:\n-  \/\/ the \"name\" argument must be a string literal\n-  JVMFlagRange(const JVMFlag* flag) : _flag(flag) {}\n-  ~JVMFlagRange() {}\n-  const JVMFlag* flag() const { return _flag; }\n-  const char* name() const { return _flag->_name; }\n-  virtual JVMFlag::Error check(bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }\n-  virtual JVMFlag::Error check_int(int value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }\n-  virtual JVMFlag::Error check_intx(intx value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }\n-  virtual JVMFlag::Error check_uint(uint value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }\n-  virtual JVMFlag::Error check_uintx(uintx value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }\n-  virtual JVMFlag::Error check_uint64_t(uint64_t value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }\n-  virtual JVMFlag::Error check_size_t(size_t value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }\n-  virtual JVMFlag::Error check_double(double value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }\n-  virtual void print(outputStream* st) { ; }\n-};\n-\n-class JVMFlagRangeChecker {\n-  const JVMFlag* _flag;\n-  const JVMFlagLimit* _limit;\n-\n-public:\n-  JVMFlagRangeChecker(const JVMFlag* flag, const JVMFlagLimit* limit) : _flag(flag), _limit(limit) {}\n-  bool exists() const { return _limit != NULL; }\n-  JVMFlag::Error check(bool verbose = true) const;\n-  void print(outputStream* st) const;\n-\n-#define DECLARE_RANGE_CHECK(T) JVMFlag::Error check_ ## T(T new_value, bool verbose = true) const;\n-  ALL_RANGE_TYPES(DECLARE_RANGE_CHECK)\n-};\n-\n-class JVMFlagRangeList : public AllStatic {\n-public:\n-  static JVMFlagRangeChecker find(const JVMFlag* flag) { return JVMFlagRangeChecker(flag, JVMFlagLimit::get_range(flag)); }\n-  static void print(outputStream* st, const JVMFlag* flag, RangeStrFunc default_range_str_func);\n-  \/\/ Check the final values of all flags for ranges.\n-  static bool check_ranges();\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagRangeList.hpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/globals.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-\/\/    checking code if provided - see jvmFlagRangeList.hpp\n+\/\/    checking code if provided - see jvmFlagLimit.hpp\n@@ -107,1 +107,1 @@\n-\/\/    for constraint checking if provided - see jvmFlagConstraintList.hpp\n+\/\/    for constraint checking if provided - see jvmFlagLimit.hpp\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n@@ -37,5 +38,1 @@\n-#define FLAG_MEMBER_ENUM_PRODUCT(type, name, value, ...)      FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_PD_PRODUCT(type, name, ...)          FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_DEVELOP(type, name, value, ...)      FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_PD_DEVELOP(type, name, ...)          FLAG_MEMBER_ENUM_(name)\n-#define FLAG_MEMBER_ENUM_NOTPRODUCT(type, name, value, ...)   FLAG_MEMBER_ENUM_(name)\n+#define FLAG_MEMBER_ENUM_DECLARE(type, name, ...)  FLAG_MEMBER_ENUM_(name)\n@@ -43,6 +40,6 @@\n-typedef enum : int {\n-  ALL_FLAGS(FLAG_MEMBER_ENUM_DEVELOP,\n-            FLAG_MEMBER_ENUM_PD_DEVELOP,\n-            FLAG_MEMBER_ENUM_PRODUCT,\n-            FLAG_MEMBER_ENUM_PD_PRODUCT,\n-            FLAG_MEMBER_ENUM_NOTPRODUCT,\n+enum JVMFlagsEnum : int {\n+  ALL_FLAGS(FLAG_MEMBER_ENUM_DECLARE,\n+            FLAG_MEMBER_ENUM_DECLARE,\n+            FLAG_MEMBER_ENUM_DECLARE,\n+            FLAG_MEMBER_ENUM_DECLARE,\n+            FLAG_MEMBER_ENUM_DECLARE,\n@@ -52,28 +49,0 @@\n-} JVMFlagsEnum;\n-\n-\/\/ Can't put the following in JVMFlags because\n-\/\/ of a circular dependency on the enum definition.\n-class JVMFlagEx : JVMFlag {\n- public:\n-  static JVMFlag::Error boolAtPut(JVMFlagsEnum flag, bool value, JVMFlag::Flags origin);\n-  static JVMFlag::Error intAtPut(JVMFlagsEnum flag, int value, JVMFlag::Flags origin);\n-  static JVMFlag::Error uintAtPut(JVMFlagsEnum flag, uint value, JVMFlag::Flags origin);\n-  static JVMFlag::Error intxAtPut(JVMFlagsEnum flag, intx value, JVMFlag::Flags origin);\n-  static JVMFlag::Error uintxAtPut(JVMFlagsEnum flag, uintx value, JVMFlag::Flags origin);\n-  static JVMFlag::Error uint64_tAtPut(JVMFlagsEnum flag, uint64_t value, JVMFlag::Flags origin);\n-  static JVMFlag::Error size_tAtPut(JVMFlagsEnum flag, size_t value, JVMFlag::Flags origin);\n-  static JVMFlag::Error doubleAtPut(JVMFlagsEnum flag, double value, JVMFlag::Flags origin);\n-  \/\/ Contract:  Flag will make private copy of the incoming value\n-  static JVMFlag::Error ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin);\n-  static JVMFlag::Error ccstrlistAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin) {\n-    return ccstrAtPut(flag, value, origin);\n-  }\n-\n-  static bool is_default(JVMFlagsEnum flag);\n-  static bool is_ergo(JVMFlagsEnum flag);\n-  static bool is_cmdline(JVMFlagsEnum flag);\n-  static bool is_jimage_resource(JVMFlagsEnum flag);\n-\n-  static void setOnCmdLine(JVMFlagsEnum flag);\n-\n-  static JVMFlag* flag_from_enum(JVMFlagsEnum flag);\n@@ -85,1 +54,4 @@\n-#define FLAG_MEMBER_SET_(type, name) inline JVMFlag::Error FLAG_MEMBER_SET(name)(type value, JVMFlag::Flags origin) { return JVMFlagEx::type##AtPut(FLAG_MEMBER_ENUM(name), value, origin); }\n+#define FLAG_MEMBER_SET_(type, name) \\\n+  inline JVMFlag::Error FLAG_MEMBER_SET(name)(type value, JVMFlag::Flags origin) { \\\n+    return JVMFlagAccess::set<JVM_FLAG_TYPE(type)>(FLAG_MEMBER_ENUM(name), value, origin); \\\n+  }\n@@ -87,5 +59,1 @@\n-#define FLAG_MEMBER_SET_PRODUCT(type, name, value, ...)      FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_PD_PRODUCT(type, name, ...)          FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_DEVELOP(type, name, value, ...)      FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_PD_DEVELOP(type, name, ...)          FLAG_MEMBER_SET_(type, name)\n-#define FLAG_MEMBER_SET_NOTPRODUCT(type, name, value, ...)   FLAG_MEMBER_SET_(type, name)\n+#define FLAG_MEMBER_SET_DECLARE(type, name, ...) FLAG_MEMBER_SET_(type, name)\n@@ -93,5 +61,5 @@\n-ALL_FLAGS(FLAG_MEMBER_SET_DEVELOP,\n-          FLAG_MEMBER_SET_PD_DEVELOP,\n-          FLAG_MEMBER_SET_PRODUCT,\n-          FLAG_MEMBER_SET_PD_PRODUCT,\n-          FLAG_MEMBER_SET_NOTPRODUCT,\n+ALL_FLAGS(FLAG_MEMBER_SET_DECLARE,\n+          FLAG_MEMBER_SET_DECLARE,\n+          FLAG_MEMBER_SET_DECLARE,\n+          FLAG_MEMBER_SET_DECLARE,\n+          FLAG_MEMBER_SET_DECLARE,\n@@ -101,4 +69,4 @@\n-#define FLAG_IS_DEFAULT(name)         (JVMFlagEx::is_default(FLAG_MEMBER_ENUM(name)))\n-#define FLAG_IS_ERGO(name)            (JVMFlagEx::is_ergo(FLAG_MEMBER_ENUM(name)))\n-#define FLAG_IS_CMDLINE(name)         (JVMFlagEx::is_cmdline(FLAG_MEMBER_ENUM(name)))\n-#define FLAG_IS_JIMAGE_RESOURCE(name) (JVMFlagEx::is_jimage_resource(FLAG_MEMBER_ENUM(name)))\n+#define FLAG_IS_DEFAULT(name)         (JVMFlag::is_default(FLAG_MEMBER_ENUM(name)))\n+#define FLAG_IS_ERGO(name)            (JVMFlag::is_ergo(FLAG_MEMBER_ENUM(name)))\n+#define FLAG_IS_CMDLINE(name)         (JVMFlag::is_cmdline(FLAG_MEMBER_ENUM(name)))\n+#define FLAG_IS_JIMAGE_RESOURCE(name) (JVMFlag::is_jimage_resource(FLAG_MEMBER_ENUM(name)))\n@@ -108,1 +76,1 @@\n-#define FLAG_SET_CMDLINE(name, value) (JVMFlagEx::setOnCmdLine(FLAG_MEMBER_ENUM(name)), \\\n+#define FLAG_SET_CMDLINE(name, value) (JVMFlag::setOnCmdLine(FLAG_MEMBER_ENUM(name)), \\\n","filename":"src\/hotspot\/share\/runtime\/globals_extension.hpp","additions":23,"deletions":55,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -71,2 +71,1 @@\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n-#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -3839,1 +3838,1 @@\n-  if (!JVMFlagRangeList::check_ranges()) {\n+  if (!JVMFlagLimit::check_all_ranges()) {\n@@ -3844,1 +3843,1 @@\n-  bool constraint_result = JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterErgo);\n+  bool constraint_result = JVMFlagLimit::check_all_constraints(JVMFlagConstraintPhase::AfterErgo);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1011,1 +1011,1 @@\n-  nonstatic_field(JVMFlag,                     _type,                                         const char*)                           \\\n+  nonstatic_field(JVMFlag,                     _type,                                         int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1411,1 +1411,1 @@\n-      Handle s = java_lang_String::create_from_str(flag->_name, CHECK_NULL);\n+      Handle s = java_lang_String::create_from_str(flag->name(), CHECK_NULL);\n@@ -1435,1 +1435,1 @@\n-    flag_name = java_lang_String::create_from_str(flag->_name, CHECK_false);\n+    flag_name = java_lang_String::create_from_str(flag->name(), CHECK_false);\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -42,2 +43,1 @@\n-  JVMFlagRangeChecker range = JVMFlagRangeList::find(flag);\n-  if (range.exists()) {\n+  if (JVMFlagLimit::get_range(flag) != NULL) {\n@@ -47,1 +47,1 @@\n-    range.print(&stream);\n+    JVMFlagAccess::print_range(&stream, flag);\n@@ -67,1 +67,1 @@\n-  const char* name = flag->_name;\n+  const char* name = flag->name();\n@@ -112,1 +112,1 @@\n-  JVMFlag::Error err = JVMFlag::boolAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::boolAtPut(flag, &value, origin);\n@@ -130,1 +130,1 @@\n-  JVMFlag::Error err = JVMFlag::intAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::intAtPut(flag, &value, origin);\n@@ -148,1 +148,1 @@\n-  JVMFlag::Error err = JVMFlag::uintAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::uintAtPut(flag, &value, origin);\n@@ -166,1 +166,1 @@\n-  JVMFlag::Error err = JVMFlag::intxAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::intxAtPut(flag, &value, origin);\n@@ -184,1 +184,1 @@\n-  JVMFlag::Error err = JVMFlag::uintxAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::uintxAtPut(flag, &value, origin);\n@@ -202,1 +202,1 @@\n-  JVMFlag::Error err = JVMFlag::uint64_tAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::uint64_tAtPut(flag, &value, origin);\n@@ -220,1 +220,1 @@\n-  JVMFlag::Error err = JVMFlag::size_tAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::size_tAtPut(flag, &value, origin);\n@@ -238,1 +238,1 @@\n-  JVMFlag::Error err = JVMFlag::doubleAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::doubleAtPut(flag, &value, origin);\n@@ -246,1 +246,1 @@\n-  JVMFlag::Error err = JVMFlag::ccstrAtPut(flag, &value, origin);\n+  JVMFlag::Error err = JVMFlagAccess::ccstrAtPut(flag, &value, origin);\n@@ -303,1 +303,1 @@\n-    return set_bool_flag(f->_name, flag_value, origin, err_msg);\n+    return set_bool_flag(f->name(), flag_value, origin, err_msg);\n@@ -305,1 +305,1 @@\n-    return set_int_flag(f->_name, flag_value, origin, err_msg);\n+    return set_int_flag(f->name(), flag_value, origin, err_msg);\n@@ -307,1 +307,1 @@\n-    return set_uint_flag(f->_name, flag_value, origin, err_msg);\n+    return set_uint_flag(f->name(), flag_value, origin, err_msg);\n@@ -309,1 +309,1 @@\n-    return set_intx_flag(f->_name, flag_value, origin, err_msg);\n+    return set_intx_flag(f->name(), flag_value, origin, err_msg);\n@@ -311,1 +311,1 @@\n-    return set_uintx_flag(f->_name, flag_value, origin, err_msg);\n+    return set_uintx_flag(f->name(), flag_value, origin, err_msg);\n@@ -313,1 +313,1 @@\n-    return set_uint64_t_flag(f->_name, flag_value, origin, err_msg);\n+    return set_uint64_t_flag(f->name(), flag_value, origin, err_msg);\n@@ -315,1 +315,1 @@\n-    return set_size_t_flag(f->_name, flag_value, origin, err_msg);\n+    return set_size_t_flag(f->name(), flag_value, origin, err_msg);\n@@ -317,1 +317,1 @@\n-    return set_double_flag(f->_name, flag_value, origin, err_msg);\n+    return set_double_flag(f->name(), flag_value, origin, err_msg);\n@@ -319,1 +319,1 @@\n-    return set_ccstr_flag(f->_name, flag_value, origin, err_msg);\n+    return set_ccstr_flag(f->name(), flag_value, origin, err_msg);\n@@ -332,1 +332,1 @@\n-    return set_bool_flag(f->_name, bvalue, origin, err_msg);\n+    return set_bool_flag(f->name(), bvalue, origin, err_msg);\n@@ -335,1 +335,1 @@\n-    return set_int_flag(f->_name, ivalue, origin, err_msg);\n+    return set_int_flag(f->name(), ivalue, origin, err_msg);\n@@ -338,1 +338,1 @@\n-    return set_uint_flag(f->_name, uvalue, origin, err_msg);\n+    return set_uint_flag(f->name(), uvalue, origin, err_msg);\n@@ -341,1 +341,1 @@\n-    return set_intx_flag(f->_name, ivalue, origin, err_msg);\n+    return set_intx_flag(f->name(), ivalue, origin, err_msg);\n@@ -344,1 +344,1 @@\n-    return set_uintx_flag(f->_name, uvalue, origin, err_msg);\n+    return set_uintx_flag(f->name(), uvalue, origin, err_msg);\n@@ -347,1 +347,1 @@\n-    return set_uint64_t_flag(f->_name, uvalue, origin, err_msg);\n+    return set_uint64_t_flag(f->name(), uvalue, origin, err_msg);\n@@ -350,1 +350,1 @@\n-    return set_size_t_flag(f->_name, svalue, origin, err_msg);\n+    return set_size_t_flag(f->name(), svalue, origin, err_msg);\n@@ -353,1 +353,1 @@\n-    return set_double_flag(f->_name, dvalue, origin, err_msg);\n+    return set_double_flag(f->name(), dvalue, origin, err_msg);\n@@ -361,1 +361,1 @@\n-    JVMFlag::Error ret = WriteableFlags::set_ccstr_flag(f->_name, svalue, origin, err_msg);\n+    JVMFlag::Error ret = WriteableFlags::set_ccstr_flag(f->name(), svalue, origin, err_msg);\n","filename":"src\/hotspot\/share\/services\/writeableFlags.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1005,0 +1005,21 @@\n+  private static final String cmdFlagTypes[] = {\n+    \"bool\",\n+    \"int\",\n+    \"uint\",\n+    \"intx\",\n+    \"uintx\",\n+    \"uint64_t\",\n+    \"size_t\",\n+    \"double\",\n+    \"ccstr\",\n+    \"ccstrlist\"\n+  };\n+\n+  private String getFlagTypeAsString(int typeIndex) {\n+    if (0 <= typeIndex && typeIndex < cmdFlagTypes.length) {\n+      return cmdFlagTypes[typeIndex];\n+    } else {\n+      return \"unknown\";\n+    }\n+  }\n+\n@@ -1014,2 +1035,1 @@\n-\n-    AddressField typeFld = flagType.getAddressField(\"_type\");\n+    CIntField typeFld = new CIntField(flagType.getCIntegerField(\"_type\"), 0);\n@@ -1024,1 +1044,2 @@\n-      String type = CStringUtilities.getString(typeFld.getValue(flagAddr));\n+      int typeIndex = (int)typeFld.getValue(flagAddr);\n+      String type = getFlagTypeAsString(typeIndex);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"}]}