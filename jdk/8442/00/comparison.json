{"files":[{"patch":"@@ -391,2 +391,45 @@\n-  void _halt() {\n-    emit_int32(0);\n+  enum csr {\n+    cycle = 0xc00,\n+    time,\n+    instret,\n+    hpmcounter3,\n+    hpmcounter4,\n+    hpmcounter5,\n+    hpmcounter6,\n+    hpmcounter7,\n+    hpmcounter8,\n+    hpmcounter9,\n+    hpmcounter10,\n+    hpmcounter11,\n+    hpmcounter12,\n+    hpmcounter13,\n+    hpmcounter14,\n+    hpmcounter15,\n+    hpmcounter16,\n+    hpmcounter17,\n+    hpmcounter18,\n+    hpmcounter19,\n+    hpmcounter20,\n+    hpmcounter21,\n+    hpmcounter22,\n+    hpmcounter23,\n+    hpmcounter24,\n+    hpmcounter25,\n+    hpmcounter26,\n+    hpmcounter27,\n+    hpmcounter28,\n+    hpmcounter29,\n+    hpmcounter30,\n+    hpmcounter31 = 0xc1f\n+  };\n+\n+  \/\/ Emit an illegal instruction that's known to trap, with 32 read-only CSR\n+  \/\/ to choose as the input operand.\n+  \/\/ Acording RISC-V asembler manual, a de facto implementation of this instruction\n+  \/\/ is the UNIMP pseduo-instruction, 'CSRRW x0, cycle, x0', attempting to write\n+  \/\/ zero to a read-only CSR 'cycle' (0xC00).\n+  \/\/ RISC-V ISAs provide a set of up to 32 read-only CSR registers 0xC00-0xC1F,\n+  \/\/ and an attempt to write into any read-only CSR (whether it exists or not)\n+  \/\/ will generate an illegal instruction exception.\n+  void illegal_instruction(csr csr_reg) {\n+    csrrw(x0, (unsigned)csr_reg, x0);\n@@ -2857,14 +2900,0 @@\n-#define INSN(NAME)                                                      \\\n-  void NAME() {                                                         \\\n-    \/* The illegal instruction in RVC is presented by a 16-bit 0. *\/    \\\n-    if (do_compress()) {                                                \\\n-      emit_int16(0);                                                    \\\n-      return;                                                           \\\n-    }                                                                   \\\n-    _halt();                                                            \\\n-  }\n-\n-  INSN(halt);\n-\n-#undef INSN\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+\n@@ -113,0 +114,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-  \/\/ of the values of the local char buffer address so that the size of mach\n+  \/\/ of the value of the local char buffer address so that the size of mach\n@@ -421,1 +421,1 @@\n-  \/\/ of the values of the local char buffer address so that the size of mach\n+  \/\/ of the value of the local char buffer address so that the size of mach\n@@ -538,11 +538,3 @@\n-  address ip = pc();\n-  pusha();\n-  \/\/ The length of the instruction sequence emitted should be independent\n-  \/\/ of the values of msg and ip so that the size of mach nodes for scratch\n-  \/\/ emit and normal emit matches.\n-  mv(c_rarg0, (address)msg);\n-  mv(c_rarg1, (address)ip);\n-  mv(c_rarg2, sp);\n-  mv(c_rarg3, CAST_FROM_FN_PTR(address, MacroAssembler::debug64));\n-  jalr(c_rarg3);\n-  ebreak();\n+  BLOCK_COMMENT(msg);\n+  illegal_instruction(Assembler::csr::time);\n+  emit_int64((uintptr_t)msg);\n@@ -1122,12 +1114,0 @@\n-\/\/ Push all the integer registers, except zr(x0) & sp(x2) & gp(x3) & tp(x4).\n-void MacroAssembler::pusha() {\n-  CompressibleRegion cr(this);\n-  push_reg(0xffffffe2, sp);\n-}\n-\n-\/\/ Pop all the integer registers, except zr(x0) & sp(x2) & gp(x3) & tp(x4).\n-void MacroAssembler::popa() {\n-  CompressibleRegion cr(this);\n-  pop_reg(0xffffffe2, sp);\n-}\n-\n@@ -2939,3 +2919,1 @@\n-  \/\/ make sure 4 byte aligned here, so that the destination address would be\n-  \/\/ 8 byte aligned after 3 instructions\n-  \/\/ when we reach here we may get a 2-byte alignment so need to align it\n+  \/\/ Make sure the address of destination 8-byte aligned after 3 instructions.\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":6,"deletions":28,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -515,2 +515,0 @@\n-  void pusha();\n-  void popa();\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-  return uint_at(0) == 0xffffffff; \/\/ an illegal instruction\n+  return uint_at(0) == 0xc0101073; \/\/ an illegal instruction, 'csrrw x0, time, x0'\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10568,1 +10568,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -10570,1 +10569,1 @@\n-      __ halt();\n+      __ stop(_halt_reason);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -581,1 +581,1 @@\n-    __ pusha();\n+    __ push_reg(RegSet::range(x0, x31), sp);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1231,1 +1231,1 @@\n-    __ pusha(); \/\/ only save smashed registers\n+    __ push_call_clobbered_registers();\n@@ -1235,1 +1235,1 @@\n-    __ popa(); \/\/ only restore smashed registers\n+    __ pop_call_clobbered_registers();\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-  print_instructions(st, pc, sizeof(char));\n+  print_instructions(st, pc, UseRVC ? sizeof(char) : 4\/*non-compressed native instruction size*\/);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}