{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.awt.Component;\n@@ -62,2 +63,3 @@\n-    private volatile static int waitDelay = 500;\n-    private static final CountDownLatch butonFocusLatch = new CountDownLatch(1);\n+    private static final int waitDelay = 500;\n+    private static final CountDownLatch buttonFocusLatch =\n+        new CountDownLatch(1);\n@@ -70,1 +72,0 @@\n-\n@@ -84,1 +85,0 @@\n-\n@@ -98,1 +98,0 @@\n-\n@@ -107,1 +106,1 @@\n-            butonFocusLatch.countDown();\n+            buttonFocusLatch.countDown();\n@@ -113,1 +112,0 @@\n-\n@@ -173,1 +171,0 @@\n-                focusGained = false;\n@@ -180,1 +177,1 @@\n-                if (!butonFocusLatch.await(waitDelay, TimeUnit.MILLISECONDS)) {\n+                if (!buttonFocusLatch.await(waitDelay, TimeUnit.MILLISECONDS)) {\n@@ -187,1 +184,1 @@\n-                requestStatus = checkbox.requestFocusInWindow();\n+                checkbox.requestFocusInWindow();\n@@ -190,10 +187,1 @@\n-            if (!requestStatus) {\n-                throw new RuntimeException(\n-                    \"FAIL: Checkbox.requestFocusInWindow returned false\");\n-            }\n-\n-            if (!checkboxFocusLatch.await(waitDelay, TimeUnit.MILLISECONDS)) {\n-                throw new RuntimeException(\n-                    \"FAIL: Checkbox.requestFocusInWindow did not transfer \"\n-                        + \"the focus to Checkbox\");\n-            }\n+            checkComponentGainFocus(checkboxFocusLatch, checkbox);\n@@ -201,5 +189,0 @@\n-            if (!checkbox.isFocusOwner()) {\n-                throw new RuntimeException(\n-                    \"FAIL: CheckBox.isFocusOwner for Checkbox returns false \"\n-                        + \"after calling Checkbox.requestFocusInWindow\");\n-            }\n@@ -207,1 +190,1 @@\n-                requestStatus = choice.requestFocusInWindow();\n+                choice.requestFocusInWindow();\n@@ -210,17 +193,1 @@\n-            if (!requestStatus) {\n-                throw new RuntimeException(\n-                    \"FAIL: Choice.requestFocusInWindow for a disabled Choice\"\n-                        + \" returned false\");\n-            }\n-\n-            if (!choiceFocusLatch.await(waitDelay, TimeUnit.MILLISECONDS)) {\n-                throw new RuntimeException(\n-                    \"FAIL: Choice.requestFocusInWindow did not transfer the\"\n-                        + \" focus to disabled Choice\");\n-            }\n-\n-            if (!choice.isFocusOwner()) {\n-                throw new RuntimeException(\n-                    \"FAIL: Choice.isFocusOwner for disabled Choice returns false\"\n-                        + \" after calling Choice.requestFocusInWindow\");\n-            }\n+            checkComponentGainFocus(choiceFocusLatch, choice);\n@@ -239,10 +206,1 @@\n-\n-            if (focusGained) {\n-                throw new RuntimeException(\n-                    \"FAIL: Wrong component gained focus: textField.requestFocusInWindow()\");\n-            }\n-            if (textField.isFocusOwner()) {\n-                throw new RuntimeException(\n-                    \"FAIL: TextField.isFocusOwner for hidden TextField returns true\"\n-                        + \" after calling TextField.requestFocusInWindow\");\n-            }\n+            checkFocusOwner(textField, focusGained);\n@@ -255,2 +213,0 @@\n-            robot.waitForIdle();\n-\n@@ -262,10 +218,1 @@\n-\n-            if (focusGained) {\n-                throw new RuntimeException(\n-                    \"FAIL: Wrong component gained focus: list.requestFocusInWindow()\");\n-            }\n-            if (list.isFocusOwner()) {\n-                throw new RuntimeException(\n-                    \"FAIL: List.isFocusOwner for non-focusable List returns true\"\n-                        + \" after calling List.requestFocusInWindow\");\n-            }\n+            checkFocusOwner(list, focusGained);\n@@ -280,0 +227,26 @@\n+    private static void checkComponentGainFocus(CountDownLatch latch,\n+        Component comp) throws InterruptedException {\n+        if (!latch.await(waitDelay, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\n+                \"FAIL: requestFocusInWindow did not transfer the focus to\"\n+                    + comp);\n+        }\n+        if (!comp.isFocusOwner()) {\n+            throw new RuntimeException(\"FAIL: isFocusOwner returns false for \"\n+                + comp + \" after calling requestFocusInWindow\");\n+        }\n+    }\n+\n+    private static void checkFocusOwner(Component comp, boolean focusGained) {\n+        if (focusGained) {\n+            throw new RuntimeException(\n+                \"FAIL: Wrong component gained focus while calling requestFocusInWindow for \"\n+                    + comp);\n+        }\n+        if (comp.isFocusOwner()) {\n+            throw new RuntimeException(\n+                \"FAIL: isFocusOwner for non-focusable component returns true\"\n+                    + \" after calling requestFocusInWindow for \" + comp);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/RequestFocusOwnerTest\/RequestFocusOwnerTest.java","additions":38,"deletions":65,"binary":false,"changes":103,"status":"modified"}]}