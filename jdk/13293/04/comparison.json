{"files":[{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8305427\n+ * @summary Verify that focus changes when requestFocus is used to traverse randomly.\n+ * @run main RequestFocusOwnerTest\n+ *\/\n+public class RequestFocusOwnerTest {\n+\n+    private static Frame frame;\n+    private volatile static Button button;\n+    private volatile static Choice choice;\n+    private volatile static TextField textField;\n+    private volatile static Checkbox checkbox;\n+    private volatile static List list;\n+    private volatile static Point buttonAt;\n+    private volatile static Dimension buttonSize;\n+    private volatile static boolean focusGained = false;\n+    private volatile static boolean requestStatus;\n+    private static final int waitDelay = 500;\n+    private static final CountDownLatch buttonFocusLatch =\n+        new CountDownLatch(1);\n+    private static final CountDownLatch checkboxFocusLatch =\n+        new CountDownLatch(1);\n+    private static final CountDownLatch choiceFocusLatch =\n+        new CountDownLatch(1);\n+\n+    private volatile static FocusListener listener = new FocusListener() {\n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            System.out.println(e.getSource() + \": lost focus.\");\n+        }\n+\n+        @Override\n+        public void focusGained(FocusEvent e) {\n+            System.out.println(e.getSource() + \": gained focus.\");\n+            focusGained = true;\n+        }\n+    };\n+\n+    private volatile static FocusListener choiceListener = new FocusListener() {\n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            System.out.println(e.getSource() + \": lost focus.\");\n+        }\n+\n+        @Override\n+        public void focusGained(FocusEvent e) {\n+            System.out.println(e.getSource() + \": gained focus.\");\n+            choiceFocusLatch.countDown();\n+        }\n+    };\n+\n+    private volatile static FocusListener butonListener = new FocusListener() {\n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            System.out.println(e.getSource() + \": lost focus.\");\n+        }\n+\n+        @Override\n+        public void focusGained(FocusEvent e) {\n+            System.out.println(e.getSource() + \": gained focus.\");\n+            buttonFocusLatch.countDown();\n+        }\n+    };\n+\n+    private volatile static FocusListener checkboxListener =\n+        new FocusListener() {\n+            @Override\n+            public void focusLost(FocusEvent e) {\n+                System.out.println(e.getSource() + \": lost focus.\");\n+            }\n+\n+            @Override\n+            public void focusGained(FocusEvent e) {\n+                System.out.println(e.getSource() + \": gained focus.\");\n+                checkboxFocusLatch.countDown();\n+            }\n+        };\n+\n+    private static void initializeGUI() {\n+        frame = new Frame(\"Test Frame\");\n+        frame.setLayout(new FlowLayout());\n+        button = new Button(\"Button\");\n+        button.addFocusListener(butonListener);\n+        frame.add(button);\n+        textField = new TextField(15);\n+        textField.addFocusListener(listener);\n+        frame.add(textField);\n+        choice = new Choice();\n+        choice.addItem(\"One\");\n+        choice.addItem(\"Two\");\n+        choice.addFocusListener(choiceListener);\n+        choice.setEnabled(false);\n+        frame.add(choice);\n+        checkbox = new Checkbox(\"Checkbox\");\n+        checkbox.addFocusListener(checkboxListener);\n+        frame.add(checkbox);\n+        list = new List();\n+        list.add(\"One\");\n+        list.add(\"Two\");\n+        list.add(\"Three\");\n+        list.add(\"Four\");\n+        list.add(\"Five\");\n+        list.addFocusListener(listener);\n+        list.setFocusable(false);\n+        frame.add(list);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args)\n+        throws InvocationTargetException, InterruptedException, AWTException {\n+        try {\n+\n+            EventQueue.invokeAndWait(RequestFocusOwnerTest::initializeGUI);\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(500);\n+            robot.setAutoWaitForIdle(true);\n+            EventQueue.invokeAndWait(() -> {\n+                buttonAt = button.getLocationOnScreen();\n+                buttonSize = button.getSize();\n+            });\n+\n+            if (!button.isFocusOwner()) {\n+\n+                robot.mouseMove(buttonAt.x + buttonSize.width \/ 2,\n+                    buttonAt.y + buttonSize.height \/ 2);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                if (!buttonFocusLatch.await(waitDelay, TimeUnit.MILLISECONDS)) {\n+                    throw new RuntimeException(\n+                        \"FAIL: Button did not gain focus when clicked!\");\n+                }\n+            }\n+\n+            EventQueue.invokeAndWait(() -> {\n+                checkbox.requestFocusInWindow();\n+            });\n+\n+            checkComponentGainFocus(checkboxFocusLatch, checkbox);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                choice.requestFocusInWindow();\n+            });\n+\n+            checkComponentGainFocus(choiceFocusLatch, choice);\n+\n+            focusGained = false;\n+            EventQueue.invokeAndWait(() -> {\n+                textField.setVisible(false);\n+                requestStatus = textField.requestFocusInWindow();\n+            });\n+\n+            if (requestStatus) {\n+                throw new RuntimeException(\n+                    \"FAIL: TextField.requestFocusInWindow returned true for\"\n+                        + \" hidden TextField\");\n+            }\n+            checkFocusOwner(textField, focusGained);\n+\n+            focusGained = false;\n+            EventQueue.invokeAndWait(() -> {\n+                requestStatus = list.requestFocusInWindow();\n+            });\n+\n+            if (requestStatus) {\n+                throw new RuntimeException(\n+                    \"FAIL: List.requestFocusInWindow returned true for\"\n+                        + \" non-focusable List\");\n+            }\n+            checkFocusOwner(list, focusGained);\n+\n+            System.out.println(\"Test passed!\");\n+\n+        } finally {\n+            EventQueue.invokeAndWait(RequestFocusOwnerTest::disposeFrame);\n+        }\n+    }\n+\n+    private static void checkComponentGainFocus(CountDownLatch latch,\n+        Component comp) throws InterruptedException {\n+        if (!latch.await(waitDelay, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\n+                \"FAIL: requestFocusInWindow did not transfer the focus to\"\n+                    + comp);\n+        }\n+        if (!comp.isFocusOwner()) {\n+            throw new RuntimeException(\"FAIL: isFocusOwner returns false for \"\n+                + comp + \" after calling requestFocusInWindow\");\n+        }\n+    }\n+\n+    private static void checkFocusOwner(Component comp, boolean focusGained) {\n+        if (focusGained) {\n+            throw new RuntimeException(\n+                \"FAIL: Wrong component gained focus while calling requestFocusInWindow for \"\n+                    + comp);\n+        }\n+        if (comp.isFocusOwner()) {\n+            throw new RuntimeException(\n+                \"FAIL: isFocusOwner for non-focusable component returns true\"\n+                    + \" after calling requestFocusInWindow for \" + comp);\n+        }\n+    }\n+\n+    public static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/RequestFocusOwnerTest\/RequestFocusOwnerTest.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"}]}