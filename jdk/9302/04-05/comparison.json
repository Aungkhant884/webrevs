{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,6 +25,0 @@\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n@@ -33,1 +27,1 @@\n- * @summary The test verifies that options can only be specified once with jcmd JFR.*\n+ * @summary The test verifies that options can only be specified once with jcmd JFR\n@@ -44,86 +38,1 @@\n-        testCheckingLog();\n-        checkStarting();\n-        checkStopping();\n-        checkDumping();\n-        checkChecking();\n-    }\n-\n-    private static void testCheckingLog() {\n-\n-        testSpecifiedOption(\"JFR.start\", \"name=abc name=def\", \"name\" );\n-        testSpecifiedOptions(\"JFR.start\", \"name=abc name=def disk=true disk=false\", Set.of(\"name\", \"disk\"));\n-        testSpecifiedOptions(\"JFR.start\", \"name=abc name=def disk=true disk=false delay=1s delay=2s\", Set.of(\"name\", \"disk\", \"delay\"));\n-        testSpecifiedOptions(\"JFR.start\", \"name=abc name=def disk=true disk=false delay=1s delay=2s maxage=1s maxage=2s\", Set.of(\"name\", \"disk\", \"delay\", \"maxage\"));\n-    }\n-\n-    public static void checkStarting() {\n-\n-        testSpecifiedOption(\"JFR.start\", \"name=abc name=def\", \"name\" );\n-        testSpecifiedOption(\"JFR.start\", \"disk=true disk=false\", \"disk\" );\n-        testSpecifiedOption(\"JFR.start\", \"delay=1s delay=2s\", \"delay\" );\n-        testSpecifiedOption(\"JFR.start\", \"duration=1s duration=2s\", \"duration\" );\n-        testSpecifiedOption(\"JFR.start\", \"maxage=1s maxage=2s\", \"maxage\" );\n-        testSpecifiedOption(\"JFR.start\", \"maxsize=1m maxsize=2m\", \"maxsize\" );\n-        testSpecifiedOption(\"JFR.start\", \"flush-interval=1s flush-interval=2s\", \"flush-interval\" );\n-        testSpecifiedOption(\"JFR.start\", \"dumponexit=true dumponexit=false\", \"dumponexit\" );\n-        testSpecifiedOption(\"JFR.start\", \"filename=filename1 filename=filename2\", \"filename\" );\n-        testSpecifiedOption(\"JFR.start\", \"path-to-gc-roots=true path-to-gc-roots=false\", \"path-to-gc-roots\" );\n-\n-        testMultipleOption(\"JFR.start\", \"settings=default settings=profile\");\n-    }\n-\n-    public static void checkStopping() {\n-\n-        testSpecifiedOption(\"JFR.stop\", \"filename=filename1 filename=filename2\", \"filename\" );\n-        testSpecifiedOption(\"JFR.stop\", \"name=abc name=def\", \"name\" );\n-    }\n-\n-    public static void checkDumping() {\n-\n-        testSpecifiedOption(\"JFR.dump\", \"begin=0:00 begin=0:01\", \"begin\" );\n-        testSpecifiedOption(\"JFR.dump\", \"end=1:00 end=1:01\", \"end\" );\n-        testSpecifiedOption(\"JFR.dump\", \"filename=filename1 filename=filename2\", \"filename\" );\n-        testSpecifiedOption(\"JFR.dump\", \"maxage=1s maxage=2s\", \"maxage\" );\n-        testSpecifiedOption(\"JFR.dump\", \"name=abc name=def\", \"name\" );\n-        testSpecifiedOption(\"JFR.dump\", \"path-to-gc-roots=true path-to-gc-roots=false\", \"path-to-gc-roots\" );\n-    }\n-\n-    public static void checkChecking() {\n-\n-        testSpecifiedOption(\"JFR.check\", \"name=abc name=def\", \"name\" );\n-        testSpecifiedOption(\"JFR.check\", \"verbose=true verbose=false\", \"verbose\" );\n-    }\n-\n-    private static void testSpecifiedOption(String command, String option, String expectOption){\n-\n-        String output = JcmdHelper.jcmd(\"%s %s\".formatted(command, option)).getOutput();\n-\n-        try {\n-            Matcher matcher = Pattern.compile(\"Option ([a-z-]+) can only be specified once\").matcher(output);\n-            matcher.find();\n-            String outputtedOption = matcher.group(1);\n-\n-            if (!outputtedOption.equals(expectOption)){\n-                throw new RuntimeException(\"expected option is %s, but actual is %s\".formatted(expectOption, outputtedOption));\n-            }\n-\n-        } catch (Exception e){\n-            System.err.println(output);\n-            throw e;\n-        }\n-    }\n-\n-    private static void testMultipleOption(String command, String option){\n-\n-        String output = JcmdHelper.jcmd(\"%s %s\".formatted(command, option)).getOutput();\n-        final String regex = \"Option ([a-z-]+) can only be specified once with ([a-z]+) flight recording\";\n-\n-        try {\n-            Matcher matcher = Pattern.compile(regex).matcher(output);\n-            if (matcher.find()){\n-                throw new RuntimeException(\"found in output : \\\"%s\\\"\".formatted(regex));\n-            }\n-        } catch (Exception e){\n-            System.err.println(output);\n-            throw e;\n-        }\n+        testJCmdConflict();\n@@ -132,28 +41,3 @@\n-\n-    private static void testSpecifiedOptions(String command, String option, Set<String> expectOptions){\n-\n-        String output = JcmdHelper.jcmd(\"%s %s\".formatted(command, option)).getOutput();\n-\n-        try {\n-            Matcher matcher = Pattern.compile(\"Options ([a-z-]+)((?:, [a-z-]+)*) and ([a-z-]+) can only be specified once\").matcher(output);\n-            matcher.find();\n-\n-            Set<String> outputtedOptions = new HashSet<>();\n-\n-            \/\/ Mandatory First option\n-            outputtedOptions.add(matcher.group(1));\n-\n-            \/\/ A collection of non-mandatory options, strings joined by \",\".\n-            Arrays.stream(matcher.group(2).split(\", \")).filter(s->s.length() > 0).forEach(outputtedOptions::add);\n-\n-            \/\/ Mandatory last option\n-            outputtedOptions.add(matcher.group(3));\n-\n-            if (!outputtedOptions.equals(expectOptions)){\n-                throw new RuntimeException(\"expected options are %s, but actual are %s\".formatted(expectOptions, outputtedOptions));\n-            }\n-\n-        } catch (Exception e){\n-            System.err.println(output);\n-            throw e;\n-        }\n+    private static void testJCmdConflict() {\n+        var output= JcmdHelper.jcmd(\"JFR.start name=hello name=greetings\");\n+        output.shouldContain(\"name can only be specified once\");\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdOptionSpecifiedOnce.java","additions":6,"deletions":122,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n@@ -28,4 +27,0 @@\n-import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n@@ -41,5 +36,0 @@\n-    public static class TestMessage {\n-        public static void main(String[] args) throws Exception {\n-        }\n-    }\n-\n@@ -47,17 +37,3 @@\n-\n-        testSpecifiedOption(\"name=abc,name=def\", \"name\" );\n-        testSpecifiedOption(\"disk=true,disk=false\", \"disk\" );\n-        testSpecifiedOption(\"delay=1s,delay=2s\", \"delay\" );\n-        testSpecifiedOption(\"duration=1s,duration=2s\", \"duration\" );\n-        testSpecifiedOption(\"maxage=1s,maxage=2s\", \"maxage\" );\n-        testSpecifiedOption(\"maxsize=1m,maxsize=2m\", \"maxsize\" );\n-        testSpecifiedOption(\"flush-interval=1s,flush-interval=2s\", \"flush-interval\" );\n-        testSpecifiedOption(\"dumponexit=true,dumponexit=false\", \"dumponexit\" );\n-        testSpecifiedOption(\"filename=filename1,filename=filename2\", \"filename\" );\n-        testSpecifiedOption(\"path-to-gc-roots=true,path-to-gc-roots=false\", \"path-to-gc-roots\" );\n-\n-        testMultipleOption(\"settings=default,settings=default\");\n-\n-        testSpecifiedOptions(\"name=abc,name=def,disk=true,disk=false\", Set.of(\"name\", \"disk\"));\n-        testSpecifiedOptions(\"name=abc,name=def,disk=true,disk=false,delay=1s,delay=2s\", Set.of(\"name\", \"disk\", \"delay\"));\n-        testSpecifiedOptions(\"name=abc,name=def,disk=true,disk=false,delay=1s,delay=2s,maxage=1s,maxage=2s\", Set.of(\"name\", \"disk\", \"delay\", \"maxage\"));\n+        testStartFlightRecordingConflict();\n+        testConflictThreeOptions();\n+        testAbleMultipleOption();\n@@ -66,7 +42,3 @@\n-    private static OutputAnalyzer startJfrJvm(String addedOptions) throws Exception {\n-        List<String> commands = new ArrayList<>(2);\n-        commands.add(\"-XX:StartFlightRecording=\" + addedOptions);\n-        commands.add(TestMessage.class.getName());\n-        ProcessBuilder pb = ProcessTools.createTestJvm(commands);\n-        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n-        return out;\n+    private static void testStartFlightRecordingConflict() throws Exception {\n+        var output = ProcessTools.executeTestJava(\"-XX:StartFlightRecording:disk=true,disk=false,name=cat,name=dog\");\n+        output.shouldContain(\"disk and name can only be specified once.\");\n@@ -75,17 +47,3 @@\n-    private static void testSpecifiedOption(String option, String expectOption) throws Exception{\n-\n-        String output = startJfrJvm(option).getOutput();\n-\n-        try {\n-            Matcher matcher = Pattern.compile(\"Option ([a-z-]+) can only be specified once\").matcher(output);\n-            matcher.find();\n-            String outputtedOption = matcher.group(1);\n-\n-            if (!outputtedOption.equals(expectOption)){\n-                throw new RuntimeException(\"expected option is %s, but actual is %s\".formatted(expectOption, outputtedOption));\n-            }\n-\n-        } catch (Exception e){\n-            System.err.println(output);\n-            throw e;\n-        }\n+    private static void testConflictThreeOptions() throws Exception {\n+        var output = ProcessTools.executeTestJava(\"-XX:StartFlightRecording:name=abc,name=def,disk=true,disk=false,delay=1s,delay=2s\");\n+        output.shouldContain(\"name, disk and delay can only be specified once.\");\n@@ -94,44 +52,3 @@\n-    private static void testMultipleOption(String option) throws Exception{\n-\n-        String output = startJfrJvm(option).getOutput();\n-        final String regex = \"Option ([a-z-]+) can only be specified once\";\n-\n-        try {\n-            Matcher matcher = Pattern.compile(regex).matcher(output);\n-            if (matcher.find()){\n-                throw new RuntimeException(\"found in output : \\\"%s\\\"\".formatted(regex));\n-            }\n-        } catch (Exception e){\n-            System.err.println(output);\n-            throw e;\n-        }\n-    }\n-\n-\n-    private static void testSpecifiedOptions(String option, Set<String> expectOptions) throws Exception{\n-\n-        String output = startJfrJvm(option).getOutput();\n-\n-        try {\n-            Matcher matcher = Pattern.compile(\"Options ([a-z-]+)((?:, [a-z-]+)*) and ([a-z-]+) can only be specified once\").matcher(output);\n-            matcher.find();\n-\n-            Set<String> outputtedOptions = new HashSet<>();\n-\n-            \/\/ Mandatory First option\n-            outputtedOptions.add(matcher.group(1));\n-\n-            \/\/ A collection of non-mandatory options, strings joined by \",\".\n-            Arrays.stream(matcher.group(2).split(\", \")).filter(s->s.length() > 0).forEach(outputtedOptions::add);\n-\n-            \/\/ Mandatory last option\n-            outputtedOptions.add(matcher.group(3));\n-\n-            if (!outputtedOptions.equals(expectOptions)){\n-                throw new RuntimeException(\"expected options are %s, but actual are %s\".formatted(expectOptions, outputtedOptions));\n-            }\n-\n-        } catch (Exception e){\n-            System.err.println(output);\n-            throw e;\n-        }\n+    private static void testAbleMultipleOption() throws Exception {\n+        var output = ProcessTools.executeTestJava(\"-XX:StartFlightRecording:settings=default,settings=profile\");\n+        output.shouldNotContain(\"settings can only be specified once\");\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestStartupOptionSpecifiedOnce.java","additions":13,"deletions":96,"binary":false,"changes":109,"status":"modified"}]}