{"files":[{"patch":"@@ -174,7 +174,24 @@\n-void* Chunk::operator new (size_t requested_size, AllocFailType alloc_failmode, size_t length) throw() {\n-  \/\/ requested_size is equal to sizeof(Chunk) but in order for the arena\n-  \/\/ allocations to come out aligned as expected the size must be aligned\n-  \/\/ to expected arena alignment.\n-  \/\/ expect requested_size but if sizeof(Chunk) doesn't match isn't proper size we must align it.\n-  assert(ARENA_ALIGN(requested_size) == aligned_overhead_size(), \"Bad alignment\");\n-  size_t bytes = ARENA_ALIGN(requested_size) + length;\n+void* Chunk::operator new (size_t sizeofChunk, AllocFailType alloc_failmode, size_t length) throw() {\n+\n+  \/\/ - requested_size = sizeof(Chunk)\n+  \/\/ - length = payload size\n+  \/\/ We must ensure that the boundaries of the payload (C and D) are aligned to 64-bit:\n+  \/\/\n+  \/\/ +-----------+--+--------------------------------------------+\n+  \/\/ |           |g |                                            |\n+  \/\/ | Chunk     |a |               Payload                      |\n+  \/\/ |           |p |                                            |\n+  \/\/ +-----------+--+--------------------------------------------+\n+  \/\/ A           B  C                                            D\n+  \/\/\n+  \/\/ - The Chunk is allocated from C-heap, therefore its start address (A) should be\n+  \/\/   64-bit aligned on all our platforms, including 32-bit.\n+  \/\/ - sizeof(Chunk) (B) may not be aligned to 64-bit, and we have to take that into\n+  \/\/   account when calculating the Payload bottom (C) (see Chunk::bottom())\n+  \/\/ - the payload size (length) must be aligned to 64-bit, which takes care of 64-bit\n+  \/\/   aligning (D)\n+\n+  assert(sizeofChunk == sizeof(Chunk), \"weird request size\");\n+  assert(is_aligned(length, BytesPerLong), \"chunk payload length not 64-bit aligned: \"\n+                                           SIZE_FORMAT \".\", length);\n+  size_t bytes = ARENA_ALIGN(sizeofChunk) + length;\n@@ -191,0 +208,1 @@\n+     assert(is_aligned(p, BytesPerLong), \"Chunk start address not malloc aligned?\");\n@@ -242,2 +260,1 @@\n-  size_t round_size = (sizeof (char *)) - 1;\n-  init_size = (init_size+round_size) & ~round_size;\n+  init_size = ARENA_ALIGN(init_size);\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    \/\/ Note: please keep these constants 64-bit aligned.\n@@ -59,1 +60,1 @@\n-    slack      = 20,            \/\/ suspected sizeof(Chunk) + internal malloc headers\n+    slack      = 24,            \/\/ suspected sizeof(Chunk) + internal malloc headers\n@@ -137,9 +138,5 @@\n-    \/\/ JDK-8270308: Amalloc guarantees 64-bit alignment and we need to ensure that in case the preceding\n-    \/\/ allocation was AmallocWords. Note though that padding plays havoc with arenas holding packed arrays,\n-    \/\/ like HandleAreas. Those areas should never mix Amalloc.. calls with differing alignment.\n-#ifndef LP64 \/\/ Since this is a hot path, and on 64-bit Amalloc and AmallocWords are identical, restrict this alignment to 32-bit.\n-    if (x > 0) {\n-      _hwm = ARENA_ALIGN(_hwm);\n-      _hwm = MIN2(_hwm, _max); \/\/ _max is not guaranteed to be 64 bit aligned.\n-    }\n-#endif \/\/ !LP64\n+    \/\/ Amalloc guarantees 64-bit alignment and we need to ensure that in case the preceding\n+    \/\/ allocation was AmallocWords. Only needed on 32-bit - on 64-bit Amalloc and AmallocWords are\n+    \/\/ identical.\n+    assert(is_aligned(_max, ARENA_AMALLOC_ALIGNMENT), \"chunk end unaligned?\");\n+    NOT_LP64(_hwm = ARENA_ALIGN(_hwm));\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-TEST(Arena, mixed_alignment_allocation) {\n+TEST_VM(Arena, mixed_alignment_allocation) {\n@@ -37,0 +37,10 @@\n+\n+TEST_VM(Arena, Arena_with_crooked_initial_size) {\n+  \/\/ Test that an arena with a crooked, not 64-bit aligned initial size\n+  \/\/ works\n+  Arena ar(mtTest, 4097);\n+  void* p1 = ar.AmallocWords(BytesPerWord);\n+  void* p2 = ar.Amalloc(BytesPerLong);\n+  ASSERT_TRUE(is_aligned(p1, BytesPerWord));\n+  ASSERT_TRUE(is_aligned(p2, BytesPerLong));\n+}\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"}]}