{"files":[{"patch":"@@ -360,1 +360,2 @@\n-  size_t len = MAX2(x, (size_t) Chunk::size);\n+  \/\/ (Note: all chunk sizes have to be 64-bit aligned)\n+  size_t len = MAX2(ARENA_ALIGN(x), (size_t) Chunk::size);\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+#ifndef LP64\n+\/\/ These tests below are about alignment issues when mixing Amalloc and AmallocWords.\n+\/\/ Since on 64-bit these APIs offer the same alignment, they only matter for 32-bit.\n+\n@@ -47,0 +51,16 @@\n+\n+TEST_VM(Arena, Arena_grows_large_unaligned) {\n+  \/\/ Test that if the arena grows with a large unaligned value, nothing bad happens.\n+  \/\/ We trigger allocation of a new, large, unaligned chunk with a non-standard size\n+  \/\/ (only possible on 32-bit when allocating with word alignment).\n+  \/\/ Then we alloc some more. If Arena::grow() does not correctly align, on 32-bit\n+  \/\/ something should assert at some point.\n+  Arena ar(mtTest, 100); \/\/ first chunk is small\n+  void* p = ar.AmallocWords(Chunk::size + BytesPerWord); \/\/ if Arena::grow() misaligns, this asserts\n+  ASSERT_TRUE(is_aligned(p, BytesPerLong));\n+  for (int i = 0; i < 100; i ++) {\n+    ar.Amalloc(1);\n+  }\n+}\n+\n+#endif \/\/  LP64\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}