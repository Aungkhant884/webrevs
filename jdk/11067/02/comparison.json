{"files":[{"patch":"@@ -60,1 +60,4 @@\n-    \/\/ the \"encryptionAlgorithm\" field\n+    \/\/ The \"encryptionAlgorithm\" field. If this object is created by\n+    \/\/ {@link #EncryptedPrivateKeyInfo(AlgorithmParameters, byte[])}\n+    \/\/ with an uninitialized params, it's stored here and algid is null.\n+    \/\/ In all other case, algid is non null and params is null.\n@@ -62,3 +65,1 @@\n-\n-    \/\/ the algorithm name of the encrypted private key\n-    private String keyAlg;\n+    private final AlgorithmParameters params;\n@@ -70,1 +71,1 @@\n-    private byte[] encoded;\n+    private final byte[] encoded;\n@@ -103,0 +104,1 @@\n+        this.params = null;\n@@ -144,0 +146,1 @@\n+        this.params = null;\n@@ -184,1 +187,16 @@\n-        this.algid = AlgorithmId.get(algParams);\n+        AlgorithmId tmp;\n+        try {\n+            tmp = AlgorithmId.get(algParams);\n+        } catch (IllegalStateException e) {\n+            \/\/ This exception is thrown when algParams.getEncoded() fails.\n+            \/\/ While the spec of this constructor requires that\n+            \/\/ \"getEncoded should return...\", in reality people might\n+            \/\/ create with an uninitialized algParams first and only\n+            \/\/ initialize it before calling getEncoded(). Thus we support\n+            \/\/ this case as well.\n+            tmp = null;\n+        }\n+\n+        \/\/ one and only one is non null\n+        this.algid = tmp;\n+        this.params = this.algid != null ? null : algParams;\n@@ -200,1 +218,0 @@\n-\n@@ -212,1 +229,1 @@\n-        return this.algid.getName();\n+        return algid == null ? params.getAlgorithm() : algid.getName();\n@@ -220,1 +237,1 @@\n-        return this.algid.getParameters();\n+        return algid == null ? params : algid.getParameters();\n@@ -255,1 +272,1 @@\n-            checkPKCS8Encoding(encoded);\n+            return pkcs8EncodingToSpec(encoded);\n@@ -262,1 +279,0 @@\n-        return new PKCS8EncodedKeySpec(encoded, keyAlg);\n@@ -273,1 +289,1 @@\n-                c = Cipher.getInstance(algid.getName());\n+                c = Cipher.getInstance(getAlgName());\n@@ -275,1 +291,1 @@\n-                c = Cipher.getInstance(algid.getName(), provider);\n+                c = Cipher.getInstance(getAlgName(), provider);\n@@ -277,1 +293,1 @@\n-            c.init(Cipher.DECRYPT_MODE, decryptKey, algid.getParameters());\n+            c.init(Cipher.DECRYPT_MODE, decryptKey, getAlgParameters());\n@@ -279,1 +295,1 @@\n-            checkPKCS8Encoding(encoded);\n+            return pkcs8EncodingToSpec(encoded);\n@@ -287,1 +303,0 @@\n-        return new PKCS8EncodedKeySpec(encoded, keyAlg);\n@@ -391,1 +406,10 @@\n-            algid.encode(tmp);\n+            if (algid != null) {\n+                algid.encode(tmp);\n+            } else {\n+                try {\n+                    \/\/ Let's hope params has been initialized by now.\n+                    AlgorithmId.get(params).encode(tmp);\n+                } catch (Exception e) {\n+                    throw new IOException(\"not initialized\", e);\n+                }\n+            }\n@@ -398,1 +422,1 @@\n-            this.encoded = out.toByteArray();\n+            return out.toByteArray();\n@@ -412,1 +436,1 @@\n-    private void checkPKCS8Encoding(byte[] encodedKey)\n+    private static PKCS8EncodedKeySpec pkcs8EncodingToSpec(byte[] encodedKey)\n@@ -423,1 +447,1 @@\n-            keyAlg = AlgorithmId.parse(values[1]).getName();\n+            String keyAlg = AlgorithmId.parse(values[1]).getName();\n@@ -425,1 +449,1 @@\n-            break;\n+            return new PKCS8EncodedKeySpec(encodedKey, keyAlg);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":45,"deletions":21,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -119,30 +119,0 @@\n-    MacData(AlgorithmParameters algParams, byte[] digest,\n-        byte[] salt, int iterations) throws NoSuchAlgorithmException\n-    {\n-        if (algParams == null)\n-           throw new NullPointerException(\"the algParams parameter \" +\n-                                               \"must be non-null\");\n-\n-        AlgorithmId algid = AlgorithmId.get(algParams);\n-        this.digestAlgorithmName = algid.getName();\n-        this.digestAlgorithmParams = algid.getParameters();\n-\n-        if (digest == null) {\n-            throw new NullPointerException(\"the digest \" +\n-                                           \"parameter must be non-null\");\n-        } else if (digest.length == 0) {\n-            throw new IllegalArgumentException(\"the digest \" +\n-                                                \"parameter must not be empty\");\n-        } else {\n-            this.digest = digest.clone();\n-        }\n-\n-        this.macSalt = salt;\n-        this.iterations = iterations;\n-\n-        \/\/ delay the generation of ASN.1 encoding until\n-        \/\/ getEncoded() is called\n-        this.encoded = null;\n-\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/MacData.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+     * @exception IllegalStateException if algparams is not initialized\n@@ -111,3 +112,2 @@\n-                \/\/ Ignore this at the moment. This exception can occur\n-                \/\/ if AlgorithmParameters was not initialized yet. Will\n-                \/\/ try to re-getEncoded() again later.\n+                throw new IllegalStateException(\n+                        \"AlgorithmParameters not initialized\", ioe);\n@@ -172,6 +172,0 @@\n-        \/\/ Re-getEncoded() from algParams if it was not initialized\n-        if (algParams != null && encodedParams == null) {\n-            encodedParams = algParams.getEncoded();\n-            \/\/ If still not initialized. Let the IOE be thrown.\n-        }\n-\n@@ -498,0 +492,1 @@\n+     * @exception IllegalStateException if algparams is not initialized\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4941596\n+ * @bug 4941596 8296442\n@@ -30,3 +30,0 @@\n-import java.util.*;\n-import java.nio.*;\n-import java.io.*;\n@@ -34,2 +31,0 @@\n-import java.util.Arrays;\n-import java.security.spec.*;\n@@ -64,2 +59,10 @@\n-                System.out.println(\"...expect: \" + algo);\n-                System.out.println(\"...got: \" + epki.getAlgName());\n+                System.out.println(\"...expected: \" + algo);\n+                System.out.println(\"     ...got: \" + epki.getAlgName());\n+                status = false;\n+            }\n+\n+            AlgorithmParameters ap2 = AlgorithmParameters.getInstance(ap.getAlgorithm());\n+            epki = new EncryptedPrivateKeyInfo(ap2, BYTES);\n+            if (!epki.getAlgName().equalsIgnoreCase(algo)) {\n+                System.out.println(\"...expected: \" + algo);\n+                System.out.println(\"     ...got: \" + epki.getAlgName());\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetAlgName.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8261779\n+ * @bug 8261779 8296442\n@@ -59,0 +59,8 @@\n+\n+        try {\n+            epki1.getEncoded();\n+            throw new Exception(\"Should have thrown IOException\");\n+        } catch (IOException ioe) {\n+            \/\/ test passed, expected exception\n+        }\n+\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetEncoded.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296442\n+ * @summary EncryptedPrivateKeyInfo can be created with an uninitialized AlgorithmParameters\n+ * @modules java.base\/sun.security.x509\n+ *\/\n+\n+import sun.security.x509.AlgorithmId;\n+\n+import java.security.AlgorithmParameters;\n+\n+public class Uninitialized {\n+    public static void main(String[] args) throws Exception {\n+        AlgorithmParameters ap = AlgorithmParameters.getInstance(\"EC\");\n+        boolean success;\n+        try {\n+            AlgorithmId.get(ap);\n+            success = true;\n+        } catch (Exception e) {\n+            success = false;\n+        }\n+        if (success) {\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/x509\/AlgorithmId\/Uninitialized.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}