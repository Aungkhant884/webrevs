{"files":[{"patch":"@@ -168,1 +168,1 @@\n-    private String functionList = \"C_GetFunctionList\";\n+    private String functionList = null;\n@@ -314,0 +314,6 @@\n+        if (functionList == null) {\n+            \/\/ defaults to \"C_GetFunctionList\" for NSS secmod\n+            if (nssUseSecmod || nssUseSecmodTrust) {\n+                return \"C_GetFunctionList\";\n+            }\n+        }\n@@ -411,21 +417,21 @@\n-            String word = st.sval;\n-            if (word.equals(\"name\")) {\n-                name = parseStringEntry(word);\n-            } else if (word.equals(\"library\")) {\n-                library = parseLibrary(word);\n-            } else if (word.equals(\"description\")) {\n-                parseDescription(word);\n-            } else if (word.equals(\"slot\")) {\n-                parseSlotID(word);\n-            } else if (word.equals(\"slotListIndex\")) {\n-                parseSlotListIndex(word);\n-            } else if (word.equals(\"enabledMechanisms\")) {\n-                parseEnabledMechanisms(word);\n-            } else if (word.equals(\"disabledMechanisms\")) {\n-                parseDisabledMechanisms(word);\n-            } else if (word.equals(\"attributes\")) {\n-                parseAttributes(word);\n-            } else if (word.equals(\"handleStartupErrors\")) {\n-                parseHandleStartupErrors(word);\n-            } else if (word.endsWith(\"insertionCheckInterval\")) {\n-                insertionCheckInterval = parseIntegerEntry(word);\n+            switch (st.sval) {\n+            case \"name\"->\n+                name = parseStringEntry(st.sval);\n+            case \"library\"->\n+                library = parseLibrary(st.sval);\n+            case \"description\"->\n+                parseDescription(st.sval);\n+            case \"slot\"->\n+                parseSlotID(st.sval);\n+            case \"slotListIndex\"->\n+                parseSlotListIndex(st.sval);\n+            case \"enabledMechanisms\"->\n+                parseEnabledMechanisms(st.sval);\n+            case \"disabledMechanisms\"->\n+                parseDisabledMechanisms(st.sval);\n+            case \"attributes\"->\n+                parseAttributes(st.sval);\n+            case \"handleStartupErrors\"->\n+                parseHandleStartupErrors(st.sval);\n+            case \"insertionCheckInterval\"-> {\n+                insertionCheckInterval = parseIntegerEntry(st.sval);\n@@ -433,1 +439,1 @@\n-                    throw excLine(word + \" must be at least 100 ms\");\n+                    throw excLine(st.sval + \" must be at least 100 ms\");\n@@ -435,2 +441,3 @@\n-            } else if (word.equals(\"cleaner.shortInterval\")) {\n-                resourceCleanerShortInterval = parseIntegerEntry(word);\n+            }\n+            case \"cleaner.shortInterval\"-> {\n+                resourceCleanerShortInterval = parseIntegerEntry(st.sval);\n@@ -438,1 +445,1 @@\n-                    throw excLine(word + \" must be at least 1000 ms\");\n+                    throw excLine(st.sval + \" must be at least 1000 ms\");\n@@ -440,2 +447,3 @@\n-            } else if (word.equals(\"cleaner.longInterval\")) {\n-                resourceCleanerLongInterval = parseIntegerEntry(word);\n+            }\n+            case \"cleaner.longInterval\"-> {\n+                resourceCleanerLongInterval = parseIntegerEntry(st.sval);\n@@ -443,1 +451,1 @@\n-                    throw excLine(word + \" must be at least 1000 ms\");\n+                    throw excLine(st.sval + \" must be at least 1000 ms\");\n@@ -445,18 +453,19 @@\n-            } else if (word.equals(\"destroyTokenAfterLogout\")) {\n-                destroyTokenAfterLogout = parseBooleanEntry(word);\n-            } else if (word.equals(\"showInfo\")) {\n-                showInfo = parseBooleanEntry(word);\n-            } else if (word.equals(\"keyStoreCompatibilityMode\")) {\n-                keyStoreCompatibilityMode = parseBooleanEntry(word);\n-            } else if (word.equals(\"explicitCancel\")) {\n-                explicitCancel = parseBooleanEntry(word);\n-            } else if (word.equals(\"omitInitialize\")) {\n-                omitInitialize = parseBooleanEntry(word);\n-            } else if (word.equals(\"allowSingleThreadedModules\")) {\n-                allowSingleThreadedModules = parseBooleanEntry(word);\n-            } else if (word.equals(\"functionList\")) {\n-                functionList = parseStringEntry(word);\n-            } else if (word.equals(\"nssUseSecmod\")) {\n-                nssUseSecmod = parseBooleanEntry(word);\n-            } else if (word.equals(\"nssLibraryDirectory\")) {\n-                nssLibraryDirectory = parseLibrary(word);\n+            }\n+            case \"destroyTokenAfterLogout\"->\n+                destroyTokenAfterLogout = parseBooleanEntry(st.sval);\n+            case \"showInfo\"->\n+                showInfo = parseBooleanEntry(st.sval);\n+            case \"keyStoreCompatibilityMode\"->\n+                keyStoreCompatibilityMode = parseBooleanEntry(st.sval);\n+            case \"explicitCancel\"->\n+                explicitCancel = parseBooleanEntry(st.sval);\n+            case \"omitInitialize\"->\n+                omitInitialize = parseBooleanEntry(st.sval);\n+            case \"allowSingleThreadedModules\"->\n+                allowSingleThreadedModules = parseBooleanEntry(st.sval);\n+            case \"functionList\"->\n+                functionList = parseStringEntry(st.sval);\n+            case \"nssUseSecmod\"->\n+                nssUseSecmod = parseBooleanEntry(st.sval);\n+            case \"nssLibraryDirectory\"-> {\n+                nssLibraryDirectory = parseLibrary(st.sval);\n@@ -464,2 +473,3 @@\n-            } else if (word.equals(\"nssSecmodDirectory\")) {\n-                nssSecmodDirectory = expand(parseStringEntry(word));\n+            }\n+            case \"nssSecmodDirectory\"-> {\n+                nssSecmodDirectory = expand(parseStringEntry(st.sval));\n@@ -467,2 +477,3 @@\n-            } else if (word.equals(\"nssModule\")) {\n-                nssModule = parseStringEntry(word);\n+            }\n+            case \"nssModule\"-> {\n+                nssModule = parseStringEntry(st.sval);\n@@ -470,2 +481,3 @@\n-            } else if (word.equals(\"nssDbMode\")) {\n-                String mode = parseStringEntry(word);\n+            }\n+            case \"nssDbMode\"-> {\n+                String mode = parseStringEntry(st.sval);\n@@ -482,2 +494,3 @@\n-            } else if (word.equals(\"nssNetscapeDbWorkaround\")) {\n-                nssNetscapeDbWorkaround = parseBooleanEntry(word);\n+            }\n+            case \"nssNetscapeDbWorkaround\"-> {\n+                nssNetscapeDbWorkaround = parseBooleanEntry(st.sval);\n@@ -485,9 +498,10 @@\n-            } else if (word.equals(\"nssArgs\")) {\n-                parseNSSArgs(word);\n-            } else if (word.equals(\"nssUseSecmodTrust\")) {\n-                nssUseSecmodTrust = parseBooleanEntry(word);\n-            } else if (word.equals(\"useEcX963Encoding\")) {\n-                useEcX963Encoding = parseBooleanEntry(word);\n-            } else if (word.equals(\"nssOptimizeSpace\")) {\n-                nssOptimizeSpace = parseBooleanEntry(word);\n-            } else {\n+            }\n+            case \"nssArgs\"->\n+                parseNSSArgs(st.sval);\n+            case \"nssUseSecmodTrust\"->\n+                nssUseSecmodTrust = parseBooleanEntry(st.sval);\n+            case \"useEcX963Encoding\"->\n+                useEcX963Encoding = parseBooleanEntry(st.sval);\n+            case \"nssOptimizeSpace\"->\n+                nssOptimizeSpace = parseBooleanEntry(st.sval);\n+            default->\n@@ -495,1 +509,2 @@\n-                        (\"Unknown keyword '\" + word + \"', line \" + st.lineno());\n+                        (\"Unknown keyword '\" + st.sval + \"', line \" +\n+                        st.lineno());\n@@ -497,1 +512,1 @@\n-            parsedKeywords.add(word);\n+            parsedKeywords.add(st.sval);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":81,"deletions":66,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -404,1 +404,7 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n+        token.ensureValid();\n+        if (P11Util.trySessionCancel(token, session,\n+                (encrypt ? CKF_ENCRYPT : CKF_DECRYPT))) {\n+            return;\n+        }\n+\n+        \/\/ cancel by finishing operations; avoid killSession as some\n@@ -456,1 +462,1 @@\n-        byte[] aad = (aadBuffer.size() > 0? aadBuffer.toByteArray() : null);\n+        byte[] aad = (aadBuffer.size() > 0 ? aadBuffer.toByteArray() : null);\n@@ -510,1 +516,1 @@\n-        return (result > 0? result : 0);\n+        return (result > 0 ? result : 0);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -448,2 +448,8 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n-        \/\/ hardware vendors may require re-login\n+\n+        if (P11Util.trySessionCancel(token, session,\n+                (encrypt ? CKF_ENCRYPT : CKF_DECRYPT))) {\n+            return;\n+        }\n+\n+        \/\/ cancel by finishing operations; avoid killSession as\n+        \/\/ some hardware vendors may require re-login\n@@ -461,1 +467,1 @@\n-                \/\/ call. If the operation inside the token was already cancelled,\n+                \/\/ call. If the operation inside the token is already cancelled,\n@@ -491,1 +497,1 @@\n-            CK_MECHANISM mechParams = (blockMode == MODE_CTR?\n+            CK_MECHANISM mechParams = (blockMode == MODE_CTR ?\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-            fixedKeySize = (index == -1? -1 :\n+            fixedKeySize = (index == -1 ? -1 :\n@@ -183,1 +183,1 @@\n-        byte[] iv = (this.iv == null? type.defIv : this.iv);\n+        byte[] iv = (this.iv == null ? type.defIv : this.iv);\n@@ -216,1 +216,1 @@\n-        byte[] ivValue = (params == null? null :\n+        byte[] ivValue = (params == null ? null :\n@@ -288,1 +288,8 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n+        token.ensureValid();\n+\n+        if (P11Util.trySessionCancel(token, session,\n+                (opmode == Cipher.ENCRYPT_MODE ? CKF_ENCRYPT : CKF_DECRYPT))) {\n+            return;\n+        }\n+\n+        \/\/ cancel by finishing operations; avoid killSession as some\n@@ -382,1 +389,1 @@\n-        return (result > 0? result : 0);\n+        return (result > 0 ? result : 0);\n@@ -657,1 +664,1 @@\n-                tbwP11Key = (tbwKey instanceof SecretKey?\n+                tbwP11Key = (tbwKey instanceof SecretKey ?\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -150,1 +150,6 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n+\n+        if (P11Util.trySessionCancel(token, session, CKF_SIGN)) {\n+            return;\n+        }\n+\n+        \/\/ cancel by finishing operations; avoid killSession as some\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-        this.mdAlg = (idx == -1?\n+        this.mdAlg = (idx == -1 ?\n@@ -196,1 +196,1 @@\n-            this.md = (this.mdAlg == null? null :\n+            this.md = (this.mdAlg == null ? null :\n@@ -272,0 +272,1 @@\n+\n@@ -274,1 +275,7 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n+        if (P11Util.trySessionCancel(token, session,\n+                (mode == M_SIGN ? CKF_SIGN : CKF_VERIFY))) {\n+            if (DEBUG) System.out.println(\" by C_SessionCancel\");\n+            return;\n+        }\n+\n+        \/\/ cancel by finishing operations; avoid killSession call as some\n@@ -283,1 +290,1 @@\n-                        (md == null? new byte[0] : md.digest());\n+                        (md == null ? new byte[0] : md.digest());\n@@ -295,1 +302,1 @@\n-                        (md == null? new byte[0] : md.digest());\n+                        (md == null ? new byte[0] : md.digest());\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -269,1 +270,15 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n+\n+        long flags = switch(mode) {\n+            case MODE_ENCRYPT -> CKF_ENCRYPT;\n+            case MODE_DECRYPT -> CKF_DECRYPT;\n+            case MODE_SIGN -> CKF_SIGN;\n+            case MODE_VERIFY -> CKF_VERIFY;\n+            default -> {\n+                throw new AssertionError(\"Unexpected value: \" + mode);\n+            }\n+        };\n+        if (P11Util.trySessionCancel(token, session, flags)) {\n+            return;\n+        }\n+\n+        \/\/ cancel by finishing operations; avoid killSession as some\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSACipher.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -283,1 +283,7 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n+\n+        if (P11Util.trySessionCancel(token, session,\n+                (mode == M_SIGN ? CKF_SIGN : CKF_VERIFY))) {\n+            return;\n+        }\n+\n+        \/\/ cancel by finishing operations; avoid killSession call as some\n@@ -320,3 +326,3 @@\n-                \/\/ call. If the operation inside the token was already cancelled,\n-                \/\/ do not fail here. This is part of a defensive mechanism for\n-                \/\/ PKCS#11 libraries that do not strictly follow the standard.\n+                \/\/ call. If the operation was already cancelled, do not fail\n+                \/\/ here. This is part of a defensive mechanism for PKCS#11\n+                \/\/ libraries that do not strictly follow the standard.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import sun.security.pkcs11.wrapper.PKCS11Exception;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n+\n@@ -190,0 +193,18 @@\n+    \/\/ returns true if successfully cancelled\n+    static boolean trySessionCancel(Token token, Session session, long flags)\n+            throws ProviderException {\n+        if (token.p11.getVersion().major == 3) {\n+            try {\n+                token.p11.C_SessionCancel(session.id(), flags);\n+                return true;\n+            } catch (PKCS11Exception e) {\n+                \/\/ return false for CKR_OPERATION_CANCEL_FAILED, so callers\n+                \/\/ can cancel in the pre v3.0 way, i.e. by finishing off the\n+                \/\/ current operation\n+                if (!e.match(CKR_OPERATION_CANCEL_FAILED)) {\n+                    throw new ProviderException(\"cancel failed\", e);\n+                }\n+            }\n+        }\n+        return false;\n+    }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Util.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-            System.out.println(\"SunPKCS11 loading \" + config.getFileName());\n+            debug.println(\"SunPKCS11 loading \" + config.getFileName());\n@@ -179,1 +179,0 @@\n-\n@@ -331,2 +330,1 @@\n-                tmpPKCS11 = PKCS11.getInstance(\n-                    library, functionList, initArgs,\n+                tmpPKCS11 = PKCS11.getInstance(library, functionList, initArgs,\n@@ -348,2 +346,2 @@\n-                tmpPKCS11 = PKCS11.getInstance(library,\n-                    functionList, initArgs, config.getOmitInitialize());\n+                tmpPKCS11 = PKCS11.getInstance(library, functionList, initArgs,\n+                    config.getOmitInitialize());\n@@ -353,2 +351,1 @@\n-            CK_INFO p11Info = p11.C_GetInfo();\n-            if (p11Info.cryptokiVersion.major < 2) {\n+            if (p11.getVersion().major < 2) {\n@@ -356,1 +353,1 @@\n-                + \"supported, library version is v\" + p11Info.cryptokiVersion);\n+                + \"supported, library version is v\" + p11.getVersion());\n@@ -360,0 +357,1 @@\n+                CK_INFO p11Info = p11.C_GetInfo();\n@@ -1485,1 +1483,0 @@\n-\n@@ -1490,1 +1487,0 @@\n-\n@@ -1506,0 +1502,1 @@\n+\n@@ -1525,1 +1522,0 @@\n-\n@@ -1529,1 +1525,0 @@\n-\n@@ -1532,0 +1527,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-\n+    private final CK_VERSION version;\n@@ -144,0 +144,2 @@\n+     * @param functionList the method name for retrieving the PKCS#11\n+     *         function list; may be null if not set in config file\n@@ -147,1 +149,1 @@\n-    PKCS11(String pkcs11ModulePath, String functionListName)\n+    PKCS11(String pkcs11ModulePath, String functionList)\n@@ -149,1 +151,1 @@\n-        connect(pkcs11ModulePath, functionListName);\n+        this.version = connect(pkcs11ModulePath, functionList);\n@@ -151,0 +153,15 @@\n+        \/\/ bug in native PKCS#11 lib; workaround it by calling C_GetInfo()\n+        \/\/ and get cryptoki version from there\n+        if (this.version.major != 2 && this.version.major != 3) {\n+            try {\n+                CK_INFO p11Info = C_GetInfo();\n+                this.version.major = p11Info.cryptokiVersion.major;\n+                this.version.minor = p11Info.cryptokiVersion.minor;\n+            } catch (PKCS11Exception e) {\n+                \/\/ give up; just use what is returned by connect()\n+            }\n+        }\n+    }\n+\n+    public CK_VERSION getVersion() {\n+        return version;\n@@ -189,0 +206,3 @@\n+     * @param functionList the method name for retrieving the PKCS#11\n+     *         function list; may be null if not set in config file\n+     * @return the actual PKCS11 interface version\n@@ -192,2 +212,2 @@\n-    private native void connect(String pkcs11ModulePath, String functionListName)\n-            throws IOException;\n+    private native CK_VERSION connect(String pkcs11ModulePath,\n+            String functionList) throws IOException;\n@@ -466,0 +486,14 @@\n+    \/**\n+     * C_SessionCancel terminates active session based operations.\n+     * (Session management) (New in PKCS#11 v3.0)\n+     *\n+     * @param hSession the session's handle\n+     *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+     * @param flags indicates the operations to cancel.\n+     *         (PKCS#11 param: CK_FLAGS flags)\n+     * @exception PKCS11Exception If function returns other value than CKR_OK.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public native void C_SessionCancel(long hSession, long flags)\n+            throws PKCS11Exception;\n@@ -524,0 +558,18 @@\n+    \/\/\/**\n+    \/\/ * C_LoginUser logs a user into a token. (New in PKCS#11 v3.0)\n+    \/\/ * (Session management)\n+    \/\/ *\n+    \/\/ * @param hSession the session's handle\n+    \/\/ *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+    \/\/ * @param userType the user type\n+    \/\/ *         (PKCS#11 param: CK_USER_TYPE userType)\n+    \/\/ * @param pPin the user's PIN and the length of the PIN\n+    \/\/ *         (PKCS#11 param: CK_CHAR_PTR pPin, CK_ULONG ulPinLen)\n+    \/\/ * @param pUsername the user name and the length of the user name\n+    \/\/ *         (PKCS#11 param: CK_CHAR_PTR pUsername, CK_ULONG ulUsernameLen)\n+    \/\/ * @exception PKCS11Exception If function returns other value than CKR_OK.\n+    \/\/ * @preconditions\n+    \/\/ * @postconditions\n+    \/\/ *\/\n+    \/\/public native void C_LoginUser(long hSession, long userType, char[] pPin,\n+    \/\/        String pUsername) throws PKCS11Exception;\n@@ -810,1 +862,0 @@\n-\n@@ -905,2 +956,0 @@\n-\n-\n@@ -1627,1 +1676,1 @@\n-    SynchronizedPKCS11(String pkcs11ModulePath, String functionListName)\n+    SynchronizedPKCS11(String pkcs11ModulePath, String functionList)\n@@ -1629,1 +1678,1 @@\n-        super(pkcs11ModulePath, functionListName);\n+        super(pkcs11ModulePath, functionList);\n@@ -1685,1 +1734,1 @@\n-    public synchronized void C_Login(long hSession, long userType, char[] pPin)\n+    public synchronized void C_SessionCancel(long hSession, long flags)\n@@ -1687,0 +1736,5 @@\n+        super.C_SessionCancel(hSession, flags);\n+    }\n+\n+    public synchronized void C_Login(long hSession, long userType,\n+            char[] pPin) throws PKCS11Exception {\n@@ -1690,0 +1744,6 @@\n+    \/\/public synchronized void C_LoginUser(long hSession, long userType,\n+    \/\/        char[] pPin, String pUsername)\n+    \/\/        throws PKCS11Exception {\n+    \/\/    super.C_LoginUser(hSession, userType, pPin, pUsername);\n+    \/\/}\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":71,"deletions":11,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -275,0 +275,27 @@\n+#ifdef P11_ENABLE_C_SESSIONCANCEL\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_SessionCancel\n+ * Signature: (JJ)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jlong jFlags                CK_FLAGS flags\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SessionCancel\n+    (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jFlags)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_RV rv;\n+\n+    CK_FUNCTION_LIST_3_0_PTR ckpFunctions30 = getFunctionList30(env, obj);\n+    if (ckpFunctions30 == NULL) { return; }\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+\n+    rv = (*ckpFunctions30->C_SessionCancel)(ckSessionHandle,\n+            jLongToCKULong(jFlags));\n+\n+    ckAssertReturnValueOK(env, rv);\n+}\n+#endif\n+\n@@ -354,1 +381,1 @@\n-    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+    ckAssertReturnValueOK(env, rv);\n@@ -370,1 +397,2 @@\n-    (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jUserType, jcharArray jPin)\n+    (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jUserType,\n+     jcharArray jPin)\n@@ -377,0 +405,1 @@\n+    CK_FUNCTION_LIST_PTR ckpFunctions;\n@@ -378,2 +407,5 @@\n-    CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);\n-    if (ckpFunctions == NULL) { return; }\n+    ckpFunctions = getFunctionList(env, obj);\n+\n+    if (ckpFunctions == NULL) {\n+        return;\n+    }\n@@ -386,1 +418,49 @@\n-    rv = (*ckpFunctions->C_Login)(ckSessionHandle, ckUserType, ckpPinArray, ckPinLength);\n+    rv = (*ckpFunctions->C_Login)(ckSessionHandle, ckUserType, ckpPinArray,\n+            ckPinLength);\n+    free(ckpPinArray);\n+\n+    ckAssertReturnValueOK(env, rv);\n+}\n+#endif\n+\n+#ifdef P11_ENABLE_C_LOGINUSER\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_LoginUser\n+ * Signature: (JJ[C;Ljava\/lang\/String;)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jlong jUserType             CK_USER_TYPE userType\n+ * @param   jcharArray jPin             CK_CHAR_PTR pPin\n+ *                                      CK_ULONG ulPinLen\n+ * @param   jstring jUsername           CK_CHAR_PTR pUsername\n+ *                                      CK_ULONG ulUsernameLen\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1LoginUser\n+    (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jUserType,\n+     jcharArray jPin, jstring jUsername)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_USER_TYPE ckUserType;\n+    CK_CHAR_PTR ckpPinArray = NULL_PTR;\n+    CK_ULONG ckPinLength;\n+    CK_CHAR_PTR ckpUsername = NULL_PTR;\n+    CK_ULONG ckUsernameLength;\n+    CK_RV rv;\n+    CK_FUNCTION_LIST_3_0_PTR ckpFunctions30;\n+\n+    ckpFunctions30 = getFunctionList30(env, obj);\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+    ckUserType = jLongToCKULong(jUserType);\n+    jCharArrayToCKCharArray(env, jPin, &ckpPinArray, &ckPinLength);\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+    jStringToCKUTF8CharArray(env, jUsername, &ckpUsername,\n+            &ckUsernameLength);\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+\n+    if (ckpFunctions30 == NULL) {\n+        return;\n+    }\n+    rv = (*ckpFunctions30->C_LoginUser)(ckSessionHandle, ckUserType,\n+            ckpPinArray, ckPinLength, ckpUsername, ckUsernameLength);\n@@ -389,0 +469,1 @@\n+    free(ckpUsername);\n@@ -390,1 +471,1 @@\n-    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+    ckAssertReturnValueOK(env, rv);\n@@ -392,0 +473,1 @@\n+\n@@ -414,1 +496,1 @@\n-    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+    ckAssertReturnValueOK(env, rv);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_sessmgmt.c","additions":90,"deletions":8,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -139,0 +139,14 @@\n+CK_FUNCTION_LIST_3_0_PTR getFunctionList30(JNIEnv *env, jobject\n+        pkcs11Implementation) {\n+    ModuleData *moduleData;\n+    CK_FUNCTION_LIST_3_0_PTR ckpFunctions30;\n+\n+    moduleData = getModuleEntry(env, pkcs11Implementation);\n+    if (moduleData == NULL) {\n+        throwDisconnectedRuntimeException(env);\n+        return NULL;\n+    }\n+    ckpFunctions30 = moduleData->ckFunctionList30Ptr;\n+    return ckpFunctions30;\n+}\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+#define P11_ENABLE_C_SESSIONCANCEL\n@@ -106,0 +107,1 @@\n+\/\/#define P11_ENABLE_C_LOGINUSER\n@@ -212,0 +214,2 @@\n+\/\/#define TRACE3d(s, p1, p2, p3) { printf(s, p1, p2, p3); fflush(stdout); }\n+\/\/#define TRACE4d(s, p1, p2, p3, p4) { printf(s, p1, p2, p3, p4); fflush(stdout); }\n@@ -218,0 +222,1 @@\n+#define TRACE4(s, p1, p2, p3, p4) { printf(s, p1, p2, p3, p4); fflush(stdout); }\n@@ -223,0 +228,1 @@\n+#define TRACE4(s, p1, p2, p3, p4)\n@@ -415,0 +421,2 @@\n+CK_FUNCTION_LIST_3_0_PTR getFunctionList30(JNIEnv *env, jobject\n+        pkcs11Implementation);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n- * Signature: (Ljava\/lang\/String;)V\n+ * Signature: (Ljava\/lang\/String;)Lsun\/security\/pkcs11\/wrapper\/CK_VERSION;\n@@ -77,3 +77,4 @@\n-JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n-    (JNIEnv *env, jobject obj, jstring jPkcs11ModulePath, jstring jGetFunctionList)\n-{\n+JNIEXPORT jobject JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n+    (JNIEnv *env, jobject obj, jstring jPkcs11ModulePath,\n+    jstring jGetFunctionList) {\n+\n@@ -82,1 +83,7 @@\n-    CK_C_GetFunctionList C_GetFunctionList=NULL;\n+    int i;\n+    CK_ULONG ulCount = 0;\n+    CK_C_GetInterfaceList C_GetInterfaceList = NULL;\n+    CK_INTERFACE_PTR iList = NULL;\n+    CK_C_GetInterface C_GetInterface = NULL;\n+    CK_INTERFACE_PTR interface = NULL;\n+    CK_C_GetFunctionList C_GetFunctionList = NULL;\n@@ -84,1 +91,1 @@\n-    ModuleData *moduleData;\n+    ModuleData *moduleData = NULL;\n@@ -88,1 +95,1 @@\n-    const char *getFunctionListStr;\n+    const char *getFunctionListStr = NULL;\n@@ -90,1 +97,2 @@\n-    const char *libraryNameStr = (*env)->GetStringUTFChars(env, jPkcs11ModulePath, 0);\n+    const char *libraryNameStr = (*env)->GetStringUTFChars(env,\n+            jPkcs11ModulePath, 0);\n@@ -92,1 +100,1 @@\n-        return;\n+        return NULL;\n@@ -94,1 +102,1 @@\n-    TRACE1(\"DEBUG: connect to PKCS#11 module: %s ... \", libraryNameStr);\n+    TRACE1(\"Connect: connect to PKCS#11 module: %s ... \", libraryNameStr);\n@@ -111,2 +119,1 @@\n-            (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n-            return;\n+            goto cleanup;\n@@ -117,1 +124,0 @@\n-        (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n@@ -119,1 +125,1 @@\n-        return;\n+        goto cleanup;\n@@ -121,1 +127,0 @@\n-    (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n@@ -123,5 +128,34 @@\n-    \/*\n-     * Get function pointer to C_GetFunctionList\n-     *\/\n-    dlerror(); \/* clear any old error message not fetched *\/\n-    \/\/ with the old JAR file jGetFunctionList is null, temporarily check for that\n+    \/\/ clear any old error message not fetched\n+    dlerror();\n+\n+#ifdef DEBUG\n+    C_GetInterfaceList = (CK_C_GetInterfaceList) dlsym(hModule,\n+            \"C_GetInterfaceList\");\n+    if (C_GetInterfaceList != NULL) {\n+        TRACE0(\"Connect: Found C_GetInterfaceList func\\n\");\n+        rv = (C_GetInterfaceList)(NULL, &ulCount);\n+        if (rv == CKR_OK) {\n+            TRACE1(\"Connect: interface list size %ld \\n\", ulCount);\n+            \/\/ retrieve available interfaces and report their info\n+            iList = (CK_INTERFACE_PTR)\n+                malloc(ulCount*sizeof(CK_INTERFACE));\n+            rv = C_GetInterfaceList(iList, &ulCount);\n+            if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {\n+                TRACE0(\"Connect: error polling interface list\\n\");\n+                goto cleanup;\n+            }\n+            for (i=0; i < (int)ulCount; i++) {\n+                TRACE4(\"Connect: name %s, version %d.%d, flags 0x%lX\\n\",\n+                        iList[i].pInterfaceName,\n+                        ((CK_VERSION *)iList[i].pFunctionList)->major,\n+                        ((CK_VERSION *)iList[i].pFunctionList)->minor,\n+                        iList[i].flags);\n+            }\n+        } else {\n+            TRACE0(\"Connect: error polling interface list size\\n\");\n+        }\n+    } else {\n+        TRACE0(\"Connect: No C_GetInterfaceList func\\n\");\n+    }\n+#endif\n+\n@@ -129,1 +163,2 @@\n-        getFunctionListStr = (*env)->GetStringUTFChars(env, jGetFunctionList, 0);\n+        getFunctionListStr = (*env)->GetStringUTFChars(env,\n+            jGetFunctionList, 0);\n@@ -131,1 +166,1 @@\n-            return;\n+            goto cleanup;\n@@ -133,9 +168,34 @@\n-        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule, getFunctionListStr);\n-        (*env)->ReleaseStringUTFChars(env, jGetFunctionList, getFunctionListStr);\n-    }\n-    if (C_GetFunctionList == NULL) {\n-        throwIOException(env, \"ERROR: C_GetFunctionList == NULL\");\n-        return;\n-    } else if ( (systemErrorMessage = dlerror()) != NULL ){\n-        throwIOException(env, systemErrorMessage);\n-        return;\n+        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule,\n+            getFunctionListStr);\n+        if ((systemErrorMessage = dlerror()) != NULL){\n+            throwIOException(env, systemErrorMessage);\n+            goto cleanup;\n+        }\n+        if (C_GetFunctionList == NULL) {\n+            TRACE1(\"Connect: No %s func\\n\", getFunctionListStr);\n+            throwIOException(env, \"ERROR: C_GetFunctionList == NULL\");\n+            goto cleanup;\n+        }\n+        TRACE1(\"Connect: Found %s func\\n\", getFunctionListStr);\n+    } else {\n+        \/\/ if none specified, then we try 3.0 API first before trying 2.40\n+        C_GetInterface = (CK_C_GetInterface) dlsym(hModule, \"C_GetInterface\");\n+        if ((C_GetInterface != NULL) && (dlerror() == NULL)) {\n+            TRACE0(\"Connect: Found C_GetInterface func\\n\");\n+            rv = (C_GetInterface)(NULL, NULL, &interface, 0L);\n+            if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {\n+                goto setModuleData;\n+            }\n+        }\n+        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule,\n+                \"C_GetFunctionList\");\n+        if ((systemErrorMessage = dlerror()) != NULL){\n+            throwIOException(env, systemErrorMessage);\n+            goto cleanup;\n+        }\n+        if (C_GetFunctionList == NULL) {\n+            TRACE0(\"Connect: No C_GetFunctionList func\\n\");\n+            throwIOException(env, \"ERROR: C_GetFunctionList == NULL\");\n+            goto cleanup;\n+        }\n+        TRACE0(\"Connect: Found C_GetFunctionList func\\n\");\n@@ -144,0 +204,1 @@\n+setModuleData:\n@@ -151,1 +212,1 @@\n-        return;\n+        goto cleanup;\n@@ -155,1 +216,25 @@\n-    rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n+    if (C_GetFunctionList != NULL) {\n+        rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n+        if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {\n+            goto cleanup;\n+        }\n+    } else if (interface != NULL) {\n+        moduleData->ckFunctionListPtr = interface->pFunctionList;\n+        if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n+            moduleData->ckFunctionList30Ptr = interface->pFunctionList;\n+        }\n+    } else {\n+        \/\/ should never happen\n+        throwIOException(env, \"ERROR: No function list ptr found\");\n+        goto cleanup;\n+    }\n+    if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n+        moduleData->ckFunctionList30Ptr = interface->pFunctionList;\n+    } else {\n+        moduleData->ckFunctionList30Ptr = NULL;\n+    }\n+\n+    TRACE2(\"Connect: FunctionListPtr version = %d.%d\\n\",\n+        ((CK_VERSION *)moduleData->ckFunctionListPtr)->major,\n+        ((CK_VERSION *)moduleData->ckFunctionListPtr)->minor);\n+\n@@ -159,3 +244,15 @@\n-    TRACE0(\"FINISHED\\n\");\n-\n-    if(ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+cleanup:\n+    if (jPkcs11ModulePath != NULL && libraryNameStr != NULL) {\n+        (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n+    }\n+    if (jGetFunctionList != NULL && getFunctionListStr != NULL) {\n+        (*env)->ReleaseStringUTFChars(env, jGetFunctionList,\n+        getFunctionListStr);\n+    }\n+    TRACE0(\"Connect: FINISHED\\n\");\n+    if (moduleData != NULL) {\n+        return ckVersionPtrToJVersion(env,\n+                (CK_VERSION *)moduleData->ckFunctionListPtr);\n+    } else {\n+        return NULL;\n+    }\n@@ -164,0 +261,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/unix\/native\/libj2pkcs11\/p11_md.c","additions":135,"deletions":37,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-    \/* The pointer to the PKCS#11 functions of this module. *\/\n+    \/* The pointers to the PKCS#11 functions of this module. *\/\n@@ -88,0 +88,1 @@\n+    CK_FUNCTION_LIST_3_0_PTR ckFunctionList30Ptr;\n","filename":"src\/jdk.crypto.cryptoki\/unix\/native\/libj2pkcs11\/p11_md.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n- * Signature: (Ljava\/lang\/String;)V\n+ * Signature: (Ljava\/lang\/String;)Lsun\/security\/pkcs11\/wrapper\/CK_VERSION;\n@@ -77,1 +77,1 @@\n-JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n+JNIEXPORT jobject JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n@@ -79,1 +79,1 @@\n-        jstring jGetFunctionList)\n+    jstring jGetFunctionList)\n@@ -82,1 +82,7 @@\n-    CK_C_GetFunctionList C_GetFunctionList;\n+    int i = 0;\n+    CK_ULONG ulCount = 0;\n+    CK_C_GetInterfaceList C_GetInterfaceList = NULL;\n+    CK_INTERFACE_PTR iList = NULL;\n+    CK_C_GetInterface C_GetInterface = NULL;\n+    CK_INTERFACE_PTR interface = NULL;\n+    CK_C_GetFunctionList C_GetFunctionList = NULL;\n@@ -84,1 +90,1 @@\n-    ModuleData *moduleData;\n+    ModuleData *moduleData = NULL;\n@@ -94,4 +100,3 @@\n-\n-  \/*\n-   * Load the PKCS #11 DLL\n-   *\/\n+    \/*\n+     * Load the PKCS #11 DLL\n+     *\/\n@@ -123,0 +128,1 @@\n+#ifdef DEBUG\n@@ -124,1 +130,1 @@\n-     * Get function pointer to C_GetFunctionList\n+     * Get function pointer to C_GetInterfaceList\n@@ -126,18 +132,80 @@\n-    getFunctionListStr = (*env)->GetStringUTFChars(env, jGetFunctionList, 0);\n-    C_GetFunctionList = (CK_C_GetFunctionList) GetProcAddress(hModule,\n-            getFunctionListStr);\n-    (*env)->ReleaseStringUTFChars(env, jGetFunctionList, getFunctionListStr);\n-    if (C_GetFunctionList == NULL) {\n-        FormatMessage(\n-            FORMAT_MESSAGE_ALLOCATE_BUFFER |\n-            FORMAT_MESSAGE_FROM_SYSTEM |\n-            FORMAT_MESSAGE_IGNORE_INSERTS,\n-            NULL,\n-            GetLastError(),\n-            0, \/* Default language *\/\n-            (LPTSTR) &lpMsgBuf,\n-            0,\n-            NULL\n-        );\n-        throwIOException(env, (LPTSTR) lpMsgBuf);\n-        goto cleanup;\n+    C_GetInterfaceList = (CK_C_GetInterfaceList) GetProcAddress(hModule,\n+            \"C_GetInterfaceList\");\n+    if (C_GetInterfaceList != NULL) {\n+        TRACE0(\"Found C_GetInterfaceList func\\n\");\n+        rv = (C_GetInterfaceList)(NULL, &ulCount);\n+        if (rv == CKR_OK) {\n+            \/* get copy of interfaces *\/\n+            iList = (CK_INTERFACE_PTR)\n+                    malloc(ulCount*sizeof(CK_INTERFACE));\n+            rv = C_GetInterfaceList(iList, &ulCount);\n+            for (i=0; i < (int)ulCount; i++) {\n+                printf(\"interface %s version %d.%d funcs %p flags 0x%lu\\n\",\n+                        iList[i].pInterfaceName,\n+                        ((CK_VERSION *)iList[i].pFunctionList)->major,\n+                        ((CK_VERSION *)iList[i].pFunctionList)->minor,\n+                        iList[i].pFunctionList, iList[i].flags);\n+            }\n+        } else {\n+            TRACE0(\"Connect: error polling interface list size\\n\");\n+        }\n+    } else {\n+        TRACE0(\"Connect: No C_GetInterfaceList func\\n\");\n+    }\n+#endif\n+\n+    if (jGetFunctionList != NULL) {\n+        getFunctionListStr = (*env)->GetStringUTFChars(env,\n+                jGetFunctionList, 0);\n+        if (getFunctionListStr == NULL) {\n+            goto cleanup;\n+        }\n+        C_GetFunctionList = (CK_C_GetFunctionList) GetProcAddress(hModule,\n+                getFunctionListStr);\n+        if (C_GetFunctionList == NULL) {\n+            TRACE1(\"Connect: No %s func\\n\", getFunctionListStr);\n+            FormatMessage(\n+                FORMAT_MESSAGE_ALLOCATE_BUFFER |\n+                FORMAT_MESSAGE_FROM_SYSTEM |\n+                FORMAT_MESSAGE_IGNORE_INSERTS,\n+                NULL,\n+                GetLastError(),\n+                0, \/* Default language *\/\n+                (LPTSTR) &lpMsgBuf,\n+                0,\n+                NULL\n+            );\n+            throwIOException(env, (LPTSTR) lpMsgBuf);\n+            goto cleanup;\n+        }\n+        TRACE1(\"Connect: Found %s func\\n\", getFunctionListStr);\n+    } else {\n+        \/\/ if none specified, then we try 3.0 API first before trying 2.40\n+        C_GetInterface = (CK_C_GetInterface) GetProcAddress(hModule,\n+            \"C_GetInterface\");\n+        if (C_GetInterface != NULL) {\n+            TRACE0(\"Connect: Found C_GetInterface func\\n\");\n+            rv = (C_GetInterface)(NULL, NULL, &interface, 0);\n+            if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {\n+                goto setModuleData;\n+            }\n+        }\n+        C_GetFunctionList = (CK_C_GetFunctionList) GetProcAddress(hModule,\n+                \"C_GetFunctionList\");\n+        if (C_GetFunctionList == NULL) {\n+            TRACE0(\"Connect: No C_GetFunctionList func\\n\");\n+            FormatMessage(\n+                FORMAT_MESSAGE_ALLOCATE_BUFFER |\n+                FORMAT_MESSAGE_FROM_SYSTEM |\n+                FORMAT_MESSAGE_IGNORE_INSERTS,\n+                NULL,\n+                GetLastError(),\n+                0, \/* Default language *\/\n+                (LPTSTR) &lpMsgBuf,\n+                0,\n+                NULL\n+            );\n+            throwIOException(env, (LPTSTR) lpMsgBuf);\n+            goto cleanup;\n+        }\n+        TRACE0(\"Connect: Found C_GetFunctionList func\\n\");\n@@ -146,0 +214,1 @@\n+setModuleData:\n@@ -156,1 +225,22 @@\n-    rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n+    if (C_GetFunctionList != NULL) {\n+        rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n+        if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {\n+            goto cleanup;\n+        }\n+    } else if (interface != NULL) {\n+        moduleData->ckFunctionListPtr = interface->pFunctionList;\n+    } else {\n+        \/\/ should never happen\n+        throwIOException(env, \"ERROR: No function list ptr found\");\n+        goto cleanup;\n+    }\n+    if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n+        moduleData->ckFunctionList30Ptr = interface->pFunctionList;\n+    } else {\n+        moduleData->ckFunctionList30Ptr = NULL;\n+    }\n+\n+    TRACE2(\"Connect: FunctionListPtr version = %d.%d\\n\",\n+        ((CK_VERSION *)moduleData->ckFunctionListPtr)->major,\n+        ((CK_VERSION *)moduleData->ckFunctionListPtr)->minor);\n+\n@@ -160,2 +250,0 @@\n-    TRACE0(\"FINISHED\\n\");\n-\n@@ -170,0 +258,4 @@\n+    if (jGetFunctionList != NULL && getFunctionListStr != NULL) {\n+        (*env)->ReleaseStringUTFChars(env, jGetFunctionList,\n+            getFunctionListStr);\n+    }\n@@ -173,0 +265,7 @@\n+    TRACE0(\"Connect: FINISHED\\n\");\n+    if (moduleData != NULL) {\n+        return ckVersionPtrToJVersion(env,\n+                (CK_VERSION *)moduleData->ckFunctionListPtr);\n+    } else {\n+        return NULL;\n+    }\n@@ -174,1 +273,0 @@\n-    if(ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/p11_md.c","additions":131,"deletions":33,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-    \/* The pointer to the PKCS#11 functions of this module. *\/\n+    \/* The pointers to the PKCS#11 functions of this module. *\/\n@@ -98,0 +98,1 @@\n+    CK_FUNCTION_LIST_3_0_PTR ckFunctionList30Ptr;\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/p11_md.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}