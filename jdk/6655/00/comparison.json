{"files":[{"patch":"@@ -168,1 +168,1 @@\n-    private String functionList = \"C_GetFunctionList\";\n+    private String functionList = null;\n@@ -314,0 +314,6 @@\n+        if (functionList == null) {\n+            \/\/ defaults to \"C_GetFunctionList\" for NSS secmod\n+            if (nssUseSecmod || nssUseSecmodTrust) {\n+                return \"C_GetFunctionList\";\n+            }\n+        }\n@@ -412,1 +418,2 @@\n-            if (word.equals(\"name\")) {\n+            switch (word) {\n+            case \"name\":\n@@ -414,1 +421,2 @@\n-            } else if (word.equals(\"library\")) {\n+                break;\n+            case \"library\":\n@@ -416,1 +424,2 @@\n-            } else if (word.equals(\"description\")) {\n+                break;\n+            case \"description\":\n@@ -418,1 +427,2 @@\n-            } else if (word.equals(\"slot\")) {\n+                break;\n+            case \"slot\":\n@@ -420,1 +430,2 @@\n-            } else if (word.equals(\"slotListIndex\")) {\n+                break;\n+            case \"slotListIndex\":\n@@ -422,1 +433,2 @@\n-            } else if (word.equals(\"enabledMechanisms\")) {\n+                break;\n+            case \"enabledMechanisms\":\n@@ -424,1 +436,2 @@\n-            } else if (word.equals(\"disabledMechanisms\")) {\n+                break;\n+            case \"disabledMechanisms\":\n@@ -426,1 +439,2 @@\n-            } else if (word.equals(\"attributes\")) {\n+                break;\n+            case \"attributes\":\n@@ -428,1 +442,2 @@\n-            } else if (word.equals(\"handleStartupErrors\")) {\n+                break;\n+            case \"handleStartupErrors\":\n@@ -430,1 +445,2 @@\n-            } else if (word.endsWith(\"insertionCheckInterval\")) {\n+                break;\n+            case \"insertionCheckInterval\":\n@@ -435,1 +451,2 @@\n-            } else if (word.equals(\"cleaner.shortInterval\")) {\n+                break;\n+            case \"cleaner.shortInterval\":\n@@ -440,1 +457,2 @@\n-            } else if (word.equals(\"cleaner.longInterval\")) {\n+                break;\n+            case \"cleaner.longInterval\":\n@@ -445,1 +463,2 @@\n-            } else if (word.equals(\"destroyTokenAfterLogout\")) {\n+                break;\n+            case \"destroyTokenAfterLogout\":\n@@ -447,1 +466,2 @@\n-            } else if (word.equals(\"showInfo\")) {\n+                break;\n+            case \"showInfo\":\n@@ -449,1 +469,2 @@\n-            } else if (word.equals(\"keyStoreCompatibilityMode\")) {\n+                break;\n+            case \"keyStoreCompatibilityMode\":\n@@ -451,1 +472,2 @@\n-            } else if (word.equals(\"explicitCancel\")) {\n+                break;\n+            case \"explicitCancel\":\n@@ -453,1 +475,2 @@\n-            } else if (word.equals(\"omitInitialize\")) {\n+                break;\n+            case \"omitInitialize\":\n@@ -455,1 +478,2 @@\n-            } else if (word.equals(\"allowSingleThreadedModules\")) {\n+                break;\n+            case \"allowSingleThreadedModules\":\n@@ -457,1 +481,2 @@\n-            } else if (word.equals(\"functionList\")) {\n+                break;\n+            case \"functionList\":\n@@ -459,1 +484,2 @@\n-            } else if (word.equals(\"nssUseSecmod\")) {\n+                break;\n+            case \"nssUseSecmod\":\n@@ -461,1 +487,2 @@\n-            } else if (word.equals(\"nssLibraryDirectory\")) {\n+                break;\n+            case \"nssLibraryDirectory\":\n@@ -464,1 +491,2 @@\n-            } else if (word.equals(\"nssSecmodDirectory\")) {\n+                break;\n+            case \"nssSecmodDirectory\":\n@@ -467,1 +495,2 @@\n-            } else if (word.equals(\"nssModule\")) {\n+                break;\n+            case \"nssModule\":\n@@ -470,1 +499,2 @@\n-            } else if (word.equals(\"nssDbMode\")) {\n+                break;\n+            case \"nssDbMode\":\n@@ -482,1 +512,2 @@\n-            } else if (word.equals(\"nssNetscapeDbWorkaround\")) {\n+                break;\n+            case \"nssNetscapeDbWorkaround\":\n@@ -485,1 +516,2 @@\n-            } else if (word.equals(\"nssArgs\")) {\n+                break;\n+            case \"nssArgs\":\n@@ -487,1 +519,2 @@\n-            } else if (word.equals(\"nssUseSecmodTrust\")) {\n+                break;\n+            case \"nssUseSecmodTrust\":\n@@ -489,1 +522,2 @@\n-            } else if (word.equals(\"useEcX963Encoding\")) {\n+                break;\n+            case \"useEcX963Encoding\":\n@@ -491,1 +525,2 @@\n-            } else if (word.equals(\"nssOptimizeSpace\")) {\n+                break;\n+            case \"nssOptimizeSpace\":\n@@ -493,1 +528,2 @@\n-            } else {\n+                break;\n+            default:\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":67,"deletions":31,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -404,2 +404,21 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n-        \/\/ hardware vendors may require re-login\n+        token.ensureValid();\n+        if (token.p11.getVersion().major == 3) {\n+            long flags = (encrypt? CKF_ENCRYPT : CKF_DECRYPT);\n+            try {\n+                token.p11.C_SessionCancel(session.id(), flags);\n+            } catch (PKCS11Exception e) {\n+                \/\/ try only if CKR_OPERATION_CANCEL_FAILED?\n+                if (e.match(CKR_OPERATION_CANCEL_FAILED)) {\n+                    tryFinishingOff();\n+                } else {\n+                    throw new ProviderException(\"cancel failed\", e);\n+                }\n+            }\n+        } else {\n+            tryFinishingOff();\n+        }\n+    }\n+\n+    \/\/ only used by cancelOperation(); cancel by finishing operations\n+    \/\/ avoid killSession as some hardware vendors may require re-login\n+    private void tryFinishingOff() {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -448,2 +448,20 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n-        \/\/ hardware vendors may require re-login\n+        if (token.p11.getVersion().major == 3) {\n+            long flags = (encrypt? CKF_ENCRYPT : CKF_DECRYPT);\n+            try {\n+                token.p11.C_SessionCancel(session.id(), flags);\n+            } catch (PKCS11Exception e) {\n+                \/\/ try only if CKR_OPERATION_CANCEL_FAILED?\n+                if (e.match(CKR_OPERATION_CANCEL_FAILED)) {\n+                    tryFinishingOff();\n+                } else {\n+                    throw new ProviderException(\"cancel failed\", e);\n+                }\n+            }\n+        } else {\n+            tryFinishingOff();\n+        }\n+    }\n+\n+    \/\/ only used by cancelOperation(); cancel by finishing operations\n+    \/\/ avoid killSession as some hardware vendors may require re-login\n+    private void tryFinishingOff() {\n@@ -461,1 +479,1 @@\n-                \/\/ call. If the operation inside the token was already cancelled,\n+                \/\/ call. If the operation inside the token is already cancelled,\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -288,2 +288,23 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n-        \/\/ hardware vendors may require re-login\n+        token.ensureValid();\n+\n+        if (token.p11.getVersion().major == 3) {\n+            long flags = (opmode == Cipher.ENCRYPT_MODE? CKF_ENCRYPT :\n+                    CKF_DECRYPT);\n+            try {\n+                token.p11.C_SessionCancel(session.id(), flags);\n+            } catch (PKCS11Exception e) {\n+                \/\/ try only if CKR_OPERATION_CANCEL_FAILED?\n+                if (e.match(CKR_OPERATION_CANCEL_FAILED)) {\n+                    tryFinishingOff();\n+                } else {\n+                    throw new ProviderException(\"cancel failed\", e);\n+                }\n+            }\n+        } else {\n+            tryFinishingOff();\n+        }\n+    }\n+\n+    \/\/ only used by cancelOperation(); cancel by finishing operations\n+    \/\/ avoid killSession as some hardware vendors may require re-login\n+    private void tryFinishingOff() {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -150,2 +150,19 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n-        \/\/ hardware vendors may require re-login\n+        if (token.p11.getVersion().major == 3) {\n+            try {\n+                token.p11.C_SessionCancel(session.id(), CKF_SIGN);\n+            } catch (PKCS11Exception e) {\n+                \/\/ try only if CKR_OPERATION_CANCEL_FAILED?\n+                if (e.match(CKR_OPERATION_CANCEL_FAILED)) {\n+                    tryFinishingOff();\n+                } else {\n+                    throw new ProviderException(\"cancel failed\", e);\n+                }\n+            }\n+        } else {\n+            tryFinishingOff();\n+        }\n+    }\n+\n+    \/\/ only used by cancelOperation(); cancel by finishing operations\n+    \/\/ avoid killSession as some hardware vendors may require re-login\n+    private void tryFinishingOff() {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -274,2 +274,21 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n-        \/\/ hardware vendors may require re-login\n+        if (token.p11.getVersion().major == 3) {\n+            long flags = (mode == M_SIGN? CKF_SIGN : CKF_VERIFY);\n+            try {\n+                token.p11.C_SessionCancel(session.id(), flags);\n+                if (DEBUG) System.out.println(\" by C_SessionCancel\");\n+            } catch (PKCS11Exception e) {\n+                \/\/ try only if CKR_OPERATION_CANCEL_FAILED?\n+                if (e.match(CKR_OPERATION_CANCEL_FAILED)) {\n+                    tryFinishingOff();\n+                } else {\n+                    throw new ProviderException(\"cancel failed\", e);\n+                }\n+            }\n+        } else {\n+            tryFinishingOff();\n+        }\n+    }\n+\n+    \/\/ only used by cancelOperation; cancel by finishing operations\n+    \/\/ avoid killSession call as some hardware vendors may require re-login\n+    private void tryFinishingOff() {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -269,2 +270,29 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n-        \/\/ hardware vendors may require re-login\n+\n+        if (token.p11.getVersion().major == 3) {\n+            long flags = switch(mode) {\n+                case MODE_ENCRYPT -> CKF_ENCRYPT;\n+                case MODE_DECRYPT -> CKF_DECRYPT;\n+                case MODE_SIGN -> CKF_SIGN;\n+                case MODE_VERIFY -> CKF_VERIFY;\n+                default -> {\n+                    throw new AssertionError(\"Unexpected value: \" + mode);\n+                }\n+            };\n+            try {\n+                token.p11.C_SessionCancel(session.id(), flags);\n+            } catch (PKCS11Exception e) {\n+                \/\/ try only if CKR_OPERATION_CANCEL_FAILED?\n+                if (e.match(CKR_OPERATION_CANCEL_FAILED)) {\n+                    tryFinishingOff();\n+                } else {\n+                    throw new ProviderException(\"cancel failed\", e);\n+                }\n+            }\n+        } else {\n+            tryFinishingOff();\n+        }\n+    }\n+\n+    \/\/ only used by cancelOperation(); cancel by finishing operations\n+    \/\/ avoid killSession as some hardware vendors may require re-login\n+    private void tryFinishingOff() {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSACipher.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -283,2 +283,21 @@\n-        \/\/ cancel operation by finishing it; avoid killSession as some\n-        \/\/ hardware vendors may require re-login\n+\n+        if (token.p11.getVersion().major == 3) {\n+            long flags = (mode == M_SIGN? CKF_SIGN : CKF_VERIFY);\n+            try {\n+                token.p11.C_SessionCancel(session.id(), flags);\n+            } catch (PKCS11Exception e) {\n+                \/\/ try only if CKR_OPERATION_CANCEL_FAILED?\n+                if (e.match(CKR_OPERATION_CANCEL_FAILED)) {\n+                    tryFinishingOff();\n+                } else {\n+                    throw new ProviderException(\"cancel failed\", e);\n+                }\n+            }\n+        } else {\n+            tryFinishingOff();\n+        }\n+    }\n+\n+    \/\/ only used by cancelOperation; cancel by finishing operations\n+    \/\/ avoid killSession call as some hardware vendors may require re-login\n+    private void tryFinishingOff() {\n@@ -320,3 +339,3 @@\n-                \/\/ call. If the operation inside the token was already cancelled,\n-                \/\/ do not fail here. This is part of a defensive mechanism for\n-                \/\/ PKCS#11 libraries that do not strictly follow the standard.\n+                \/\/ call. If the operation was already cancelled, do not fail\n+                \/\/ here. This is part of a defensive mechanism for PKCS#11\n+                \/\/ libraries that do not strictly follow the standard.\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-            System.out.println(\"SunPKCS11 loading \" + config.getFileName());\n+            debug.println(\"SunPKCS11 loading \" + config.getFileName());\n@@ -179,1 +179,0 @@\n-\n@@ -331,2 +330,1 @@\n-                tmpPKCS11 = PKCS11.getInstance(\n-                    library, functionList, initArgs,\n+                tmpPKCS11 = PKCS11.getInstance(library, functionList, initArgs,\n@@ -348,2 +346,2 @@\n-                tmpPKCS11 = PKCS11.getInstance(library,\n-                    functionList, initArgs, config.getOmitInitialize());\n+                tmpPKCS11 = PKCS11.getInstance(library, functionList, initArgs,\n+                    config.getOmitInitialize());\n@@ -353,2 +351,1 @@\n-            CK_INFO p11Info = p11.C_GetInfo();\n-            if (p11Info.cryptokiVersion.major < 2) {\n+            if (p11.getVersion().major < 2) {\n@@ -356,1 +353,1 @@\n-                + \"supported, library version is v\" + p11Info.cryptokiVersion);\n+                + \"supported, library version is v\" + p11.getVersion());\n@@ -360,0 +357,1 @@\n+                CK_INFO p11Info = p11.C_GetInfo();\n@@ -1485,1 +1483,0 @@\n-\n@@ -1490,1 +1487,0 @@\n-\n@@ -1506,0 +1502,1 @@\n+\n@@ -1525,1 +1522,0 @@\n-\n@@ -1529,1 +1525,0 @@\n-\n@@ -1532,0 +1527,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-\n+    private final CK_VERSION version;\n@@ -144,0 +144,2 @@\n+     * @param functionList the method name for retrieving the PKCS#11\n+     *         function list; maybe null if not set in config file\n@@ -147,1 +149,1 @@\n-    PKCS11(String pkcs11ModulePath, String functionListName)\n+    PKCS11(String pkcs11ModulePath, String functionList)\n@@ -149,1 +151,1 @@\n-        connect(pkcs11ModulePath, functionListName);\n+        this.version = connect(pkcs11ModulePath, functionList);\n@@ -151,0 +153,15 @@\n+        \/\/ bug in native PKCS#11 lib; workaround it by calling C_GetInfo()\n+        \/\/ and get cryptoki version from there\n+        if (this.version.major != 2 && this.version.major != 3) {\n+            try {\n+                CK_INFO p11Info = C_GetInfo();\n+                this.version.major = p11Info.cryptokiVersion.major;\n+                this.version.minor = p11Info.cryptokiVersion.minor;\n+            } catch (PKCS11Exception e) {\n+                \/\/ give up; just use what is returned by connect()\n+            }\n+        }\n+    }\n+\n+    public CK_VERSION getVersion() {\n+        return version;\n@@ -189,0 +206,3 @@\n+     * @param functionList the method name for retrieving the PKCS#11\n+     *         function list; maybe null if not set in config file\n+     * @return the actual PKCS11 interface version\n@@ -192,2 +212,2 @@\n-    private native void connect(String pkcs11ModulePath, String functionListName)\n-            throws IOException;\n+    private native CK_VERSION connect(String pkcs11ModulePath,\n+            String functionList) throws IOException;\n@@ -466,0 +486,14 @@\n+    \/**\n+     * C_SessionCancel terminates active session based operations.\n+     * (Session management) (New in PKCS#11 v3.0)\n+     *\n+     * @param hSession the session's handle\n+     *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+     * @param flags indicates the operations to cancel.\n+     *         (PKCS#11 param: CK_FLAGS flags)\n+     * @exception PKCS11Exception If function returns other value than CKR_OK.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public native void C_SessionCancel(long hSession, long flags)\n+            throws PKCS11Exception;\n@@ -524,0 +558,18 @@\n+    \/\/\/**\n+    \/\/ * C_LoginUser logs a user into a token. (New in PKCS#11 v3.0)\n+    \/\/ * (Session management)\n+    \/\/ *\n+    \/\/ * @param hSession the session's handle\n+    \/\/ *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+    \/\/ * @param userType the user type\n+    \/\/ *         (PKCS#11 param: CK_USER_TYPE userType)\n+    \/\/ * @param pPin the user's PIN and the length of the PIN\n+    \/\/ *         (PKCS#11 param: CK_CHAR_PTR pPin, CK_ULONG ulPinLen)\n+    \/\/ * @param pUsername the user name and the length of the user name\n+    \/\/ *         (PKCS#11 param: CK_CHAR_PTR pUsername, CK_ULONG ulUsernameLen)\n+    \/\/ * @exception PKCS11Exception If function returns other value than CKR_OK.\n+    \/\/ * @preconditions\n+    \/\/ * @postconditions\n+    \/\/ *\/\n+    \/\/public native void C_LoginUser(long hSession, long userType, char[] pPin,\n+    \/\/        String pUsername) throws PKCS11Exception;\n@@ -810,1 +862,0 @@\n-\n@@ -905,2 +956,0 @@\n-\n-\n@@ -1627,1 +1676,1 @@\n-    SynchronizedPKCS11(String pkcs11ModulePath, String functionListName)\n+    SynchronizedPKCS11(String pkcs11ModulePath, String functionList)\n@@ -1629,1 +1678,1 @@\n-        super(pkcs11ModulePath, functionListName);\n+        super(pkcs11ModulePath, functionList);\n@@ -1685,1 +1734,1 @@\n-    public synchronized void C_Login(long hSession, long userType, char[] pPin)\n+    public synchronized void C_SessionCancel(long hSession, long flags)\n@@ -1687,0 +1736,5 @@\n+        super.C_SessionCancel(hSession, flags);\n+    }\n+\n+    public synchronized void C_Login(long hSession, long userType,\n+            char[] pPin) throws PKCS11Exception {\n@@ -1690,0 +1744,6 @@\n+    \/\/public synchronized void C_LoginUser(long hSession, long userType,\n+    \/\/        char[] pPin, String pUsername)\n+    \/\/        throws PKCS11Exception {\n+    \/\/    super.C_LoginUser(hSession, userType, pPin, pUsername);\n+    \/\/}\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":71,"deletions":11,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -275,0 +275,27 @@\n+#ifdef P11_ENABLE_C_SESSIONCANCEL\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_SessionCancel\n+ * Signature: (JJ)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jlong jFlags                CK_FLAGS flags\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SessionCancel\n+    (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jFlags)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_RV rv;\n+\n+    CK_FUNCTION_LIST_3_0_PTR ckpFunctions30 = getFunctionList30(env, obj);\n+    if (ckpFunctions30 == NULL) { return; }\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+\n+    rv = (*ckpFunctions30->C_SessionCancel)(ckSessionHandle,\n+            jLongToCKULong(jFlags));\n+\n+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+}\n+#endif\n+\n@@ -354,1 +381,1 @@\n-    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+    ckAssertReturnValueOK(env, rv);\n@@ -370,1 +397,2 @@\n-    (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jUserType, jcharArray jPin)\n+    (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jUserType,\n+     jcharArray jPin)\n@@ -377,0 +405,1 @@\n+    CK_FUNCTION_LIST_PTR ckpFunctions;\n@@ -378,2 +407,5 @@\n-    CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);\n-    if (ckpFunctions == NULL) { return; }\n+    ckpFunctions = getFunctionList(env, obj);\n+\n+    if (ckpFunctions == NULL) {\n+        return;\n+    }\n@@ -386,1 +418,49 @@\n-    rv = (*ckpFunctions->C_Login)(ckSessionHandle, ckUserType, ckpPinArray, ckPinLength);\n+    rv = (*ckpFunctions->C_Login)(ckSessionHandle, ckUserType, ckpPinArray,\n+            ckPinLength);\n+    free(ckpPinArray);\n+\n+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+}\n+#endif\n+\n+#ifdef P11_ENABLE_C_LOGINUSER\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_LoginUser\n+ * Signature: (JJ[C;Ljava\/lang\/String;)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jlong jUserType             CK_USER_TYPE userType\n+ * @param   jcharArray jPin             CK_CHAR_PTR pPin\n+ *                                      CK_ULONG ulPinLen\n+ * @param   jstring jUsername           CK_CHAR_PTR pUsername\n+ *                                      CK_ULONG ulUsernameLen\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1LoginUser\n+    (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jUserType,\n+     jcharArray jPin, jstring jUsername)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_USER_TYPE ckUserType;\n+    CK_CHAR_PTR ckpPinArray = NULL_PTR;\n+    CK_ULONG ckPinLength;\n+    CK_CHAR_PTR ckpUsername = NULL_PTR;\n+    CK_ULONG ckUsernameLength;\n+    CK_RV rv;\n+    CK_FUNCTION_LIST_3_0_PTR ckpFunctions30;\n+\n+    ckpFunctions30 = getFunctionList30(env, obj);\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+    ckUserType = jLongToCKULong(jUserType);\n+    jCharArrayToCKCharArray(env, jPin, &ckpPinArray, &ckPinLength);\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+    jStringToCKUTF8CharArray(env, jUsername, &ckpUsername,\n+            &ckUsernameLength);\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+\n+    if (ckpFunctions30 == NULL) {\n+        return;\n+    }\n+    rv = (*ckpFunctions30->C_LoginUser)(ckSessionHandle, ckUserType,\n+            ckpPinArray, ckPinLength, ckpUsername, ckUsernameLength);\n@@ -389,0 +469,1 @@\n+    free(ckpUsername);\n@@ -392,0 +473,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_sessmgmt.c","additions":88,"deletions":6,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -139,0 +139,14 @@\n+CK_FUNCTION_LIST_3_0_PTR getFunctionList30(JNIEnv *env, jobject\n+        pkcs11Implementation) {\n+    ModuleData *moduleData;\n+    CK_FUNCTION_LIST_3_0_PTR ckpFunctions30;\n+\n+    moduleData = getModuleEntry(env, pkcs11Implementation);\n+    if (moduleData == NULL) {\n+        throwDisconnectedRuntimeException(env);\n+        return NULL;\n+    }\n+    ckpFunctions30 = moduleData->ckFunctionList30Ptr;\n+    return ckpFunctions30;\n+}\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+#define P11_ENABLE_C_SESSIONCANCEL\n@@ -106,0 +107,1 @@\n+\/\/#define P11_ENABLE_C_LOGINUSER\n@@ -212,0 +214,2 @@\n+\/\/#define TRACE3d(s, p1, p2, p3) { printf(s, p1, p2, p3); fflush(stdout); }\n+\/\/#define TRACE4d(s, p1, p2, p3, p4) { printf(s, p1, p2, p3, p4); fflush(stdout); }\n@@ -218,0 +222,1 @@\n+#define TRACE4(s, p1, p2, p3, p4) { printf(s, p1, p2, p3, p4); fflush(stdout); }\n@@ -223,0 +228,1 @@\n+#define TRACE4(s, p1, p2, p3, p4)\n@@ -415,0 +421,2 @@\n+CK_FUNCTION_LIST_3_0_PTR getFunctionList30(JNIEnv *env, jobject\n+        pkcs11Implementation);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n- * Signature: (Ljava\/lang\/String;)V\n+ * Signature: (Ljava\/lang\/String;)Lsun\/security\/pkcs11\/wrapper\/CK_VERSION;\n@@ -77,3 +77,4 @@\n-JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n-    (JNIEnv *env, jobject obj, jstring jPkcs11ModulePath, jstring jGetFunctionList)\n-{\n+JNIEXPORT jobject JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n+    (JNIEnv *env, jobject obj, jstring jPkcs11ModulePath,\n+    jstring jGetFunctionList) {\n+\n@@ -82,1 +83,7 @@\n-    CK_C_GetFunctionList C_GetFunctionList=NULL;\n+    int i;\n+    CK_ULONG ulCount = 0;\n+    CK_C_GetInterfaceList C_GetInterfaceList = NULL;\n+    CK_INTERFACE_PTR iList = NULL;\n+    CK_C_GetInterface C_GetInterface = NULL;\n+    CK_INTERFACE_PTR interface = NULL;\n+    CK_C_GetFunctionList C_GetFunctionList = NULL;\n@@ -84,1 +91,1 @@\n-    ModuleData *moduleData;\n+    ModuleData *moduleData = NULL;\n@@ -88,1 +95,1 @@\n-    const char *getFunctionListStr;\n+    const char *getFunctionListStr = NULL;\n@@ -90,1 +97,2 @@\n-    const char *libraryNameStr = (*env)->GetStringUTFChars(env, jPkcs11ModulePath, 0);\n+    const char *libraryNameStr = (*env)->GetStringUTFChars(env,\n+            jPkcs11ModulePath, 0);\n@@ -92,1 +100,1 @@\n-        return;\n+        return NULL;\n@@ -94,1 +102,1 @@\n-    TRACE1(\"DEBUG: connect to PKCS#11 module: %s ... \", libraryNameStr);\n+    TRACE1(\"Connect: connect to PKCS#11 module: %s ... \", libraryNameStr);\n@@ -111,2 +119,1 @@\n-            (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n-            return;\n+            goto cleanup;\n@@ -117,1 +124,0 @@\n-        (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n@@ -119,1 +125,1 @@\n-        return;\n+        goto cleanup;\n@@ -121,1 +127,0 @@\n-    (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n@@ -123,5 +128,34 @@\n-    \/*\n-     * Get function pointer to C_GetFunctionList\n-     *\/\n-    dlerror(); \/* clear any old error message not fetched *\/\n-    \/\/ with the old JAR file jGetFunctionList is null, temporarily check for that\n+    \/\/ clear any old error message not fetched\n+    dlerror();\n+\n+#ifdef DEBUG\n+    C_GetInterfaceList = (CK_C_GetInterfaceList) dlsym(hModule,\n+            \"C_GetInterfaceList\");\n+    if (C_GetInterfaceList != NULL) {\n+        TRACE0(\"Connect: Found C_GetInterfaceList func\\n\");\n+        rv = (C_GetInterfaceList)(NULL, &ulCount);\n+        if (rv == CKR_OK) {\n+            TRACE1(\"Connect: interface list size %ld \\n\", ulCount);\n+            \/\/ retrieve available interfaces and report their info\n+            iList = (CK_INTERFACE_PTR)\n+                malloc(ulCount*sizeof(CK_INTERFACE));\n+            rv = C_GetInterfaceList(iList, &ulCount);\n+            if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {\n+                TRACE0(\"Connect: error polling interface list\\n\");\n+                goto cleanup;\n+            }\n+            for (i=0; i < (int)ulCount; i++) {\n+                TRACE4(\"Connect: name %s, version %d.%d, flags 0x%lX\\n\",\n+                        iList[i].pInterfaceName,\n+                        ((CK_VERSION *)iList[i].pFunctionList)->major,\n+                        ((CK_VERSION *)iList[i].pFunctionList)->minor,\n+                        iList[i].flags);\n+            }\n+        } else {\n+            TRACE0(\"Connect: error polling interface list size\\n\");\n+        }\n+    } else {\n+        TRACE0(\"Connect: No C_GetInterfaceList func\\n\");\n+    }\n+#endif\n+\n@@ -129,1 +163,2 @@\n-        getFunctionListStr = (*env)->GetStringUTFChars(env, jGetFunctionList, 0);\n+        getFunctionListStr = (*env)->GetStringUTFChars(env,\n+            jGetFunctionList, 0);\n@@ -131,1 +166,1 @@\n-            return;\n+            goto cleanup;\n@@ -133,9 +168,34 @@\n-        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule, getFunctionListStr);\n-        (*env)->ReleaseStringUTFChars(env, jGetFunctionList, getFunctionListStr);\n-    }\n-    if (C_GetFunctionList == NULL) {\n-        throwIOException(env, \"ERROR: C_GetFunctionList == NULL\");\n-        return;\n-    } else if ( (systemErrorMessage = dlerror()) != NULL ){\n-        throwIOException(env, systemErrorMessage);\n-        return;\n+        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule,\n+            getFunctionListStr);\n+        if ((systemErrorMessage = dlerror()) != NULL){\n+            throwIOException(env, systemErrorMessage);\n+            goto cleanup;\n+        }\n+        if (C_GetFunctionList == NULL) {\n+            TRACE1(\"Connect: No %s func\\n\", getFunctionListStr);\n+            throwIOException(env, \"ERROR: C_GetFunctionList == NULL\");\n+            goto cleanup;\n+        }\n+        TRACE1(\"Connect: Found %s func\\n\", getFunctionListStr);\n+    } else {\n+        \/\/ if none specified, then we try 3.0 API first before trying 2.40\n+        C_GetInterface = (CK_C_GetInterface) dlsym(hModule, \"C_GetInterface\");\n+        if ((C_GetInterface != NULL) && (dlerror() == NULL)) {\n+            TRACE0(\"Connect: Found C_GetInterface func\\n\");\n+            rv = (C_GetInterface)(NULL, NULL, &interface, 0L);\n+            if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {\n+                goto setModuleData;\n+            }\n+        }\n+        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule,\n+                \"C_GetFunctionList\");\n+        if ((systemErrorMessage = dlerror()) != NULL){\n+            throwIOException(env, systemErrorMessage);\n+            goto cleanup;\n+        }\n+        if (C_GetFunctionList == NULL) {\n+            TRACE0(\"Connect: No C_GetFunctionList func\\n\");\n+            throwIOException(env, \"ERROR: C_GetFunctionList == NULL\");\n+            goto cleanup;\n+        }\n+        TRACE0(\"Connect: Found C_GetFunctionList func\\n\");\n@@ -144,0 +204,1 @@\n+setModuleData:\n@@ -151,1 +212,1 @@\n-        return;\n+        goto cleanup;\n@@ -155,1 +216,25 @@\n-    rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n+    if (C_GetFunctionList != NULL) {\n+        rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n+        if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {\n+            goto cleanup;\n+        }\n+    } else if (interface != NULL) {\n+        moduleData->ckFunctionListPtr = interface->pFunctionList;\n+        if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n+            moduleData->ckFunctionList30Ptr = interface->pFunctionList;\n+        }\n+    } else {\n+        \/\/ should never happen\n+        throwIOException(env, \"ERROR: No function list ptr found\");\n+        goto cleanup;\n+    }\n+    if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n+        moduleData->ckFunctionList30Ptr = interface->pFunctionList;\n+    } else {\n+        moduleData->ckFunctionList30Ptr = NULL;\n+    }\n+\n+    TRACE2(\"Connect: FunctionListPtr version = %d.%d\\n\",\n+        ((CK_VERSION *)moduleData->ckFunctionListPtr)->major,\n+        ((CK_VERSION *)moduleData->ckFunctionListPtr)->minor);\n+\n@@ -159,3 +244,15 @@\n-    TRACE0(\"FINISHED\\n\");\n-\n-    if(ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+cleanup:\n+    if (jPkcs11ModulePath != NULL && libraryNameStr != NULL) {\n+        (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n+    }\n+    if (jGetFunctionList != NULL && getFunctionListStr != NULL) {\n+        (*env)->ReleaseStringUTFChars(env, jGetFunctionList,\n+        getFunctionListStr);\n+    }\n+    TRACE0(\"Connect: FINISHED\\n\");\n+    if (moduleData != NULL) {\n+        return ckVersionPtrToJVersion(env,\n+                (CK_VERSION *)moduleData->ckFunctionListPtr);\n+    } else {\n+        return NULL;\n+    }\n@@ -164,0 +261,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/unix\/native\/libj2pkcs11\/p11_md.c","additions":135,"deletions":37,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-    \/* The pointer to the PKCS#11 functions of this module. *\/\n+    \/* The pointers to the PKCS#11 functions of this module. *\/\n@@ -88,0 +88,1 @@\n+    CK_FUNCTION_LIST_3_0_PTR ckFunctionList30Ptr;\n","filename":"src\/jdk.crypto.cryptoki\/unix\/native\/libj2pkcs11\/p11_md.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n- * Signature: (Ljava\/lang\/String;)V\n+ * Signature: (Ljava\/lang\/String;)Lsun\/security\/pkcs11\/wrapper\/CK_VERSION;\n@@ -77,1 +77,1 @@\n-JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n+JNIEXPORT jobject JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n@@ -79,1 +79,1 @@\n-        jstring jGetFunctionList)\n+    jstring jGetFunctionList)\n@@ -82,1 +82,7 @@\n-    CK_C_GetFunctionList C_GetFunctionList;\n+    int i = 0;\n+    CK_ULONG ulCount = 0;\n+    CK_C_GetInterfaceList C_GetInterfaceList = NULL;\n+    CK_INTERFACE_PTR iList = NULL;\n+    CK_C_GetInterface C_GetInterface = NULL;\n+    CK_INTERFACE_PTR interface = NULL;\n+    CK_C_GetFunctionList C_GetFunctionList = NULL;\n@@ -84,1 +90,1 @@\n-    ModuleData *moduleData;\n+    ModuleData *moduleData = NULL;\n@@ -94,4 +100,3 @@\n-\n-  \/*\n-   * Load the PKCS #11 DLL\n-   *\/\n+    \/*\n+     * Load the PKCS #11 DLL\n+     *\/\n@@ -123,0 +128,1 @@\n+#ifdef DEBUG\n@@ -124,1 +130,1 @@\n-     * Get function pointer to C_GetFunctionList\n+     * Get function pointer to C_GetInterfaceList\n@@ -126,18 +132,80 @@\n-    getFunctionListStr = (*env)->GetStringUTFChars(env, jGetFunctionList, 0);\n-    C_GetFunctionList = (CK_C_GetFunctionList) GetProcAddress(hModule,\n-            getFunctionListStr);\n-    (*env)->ReleaseStringUTFChars(env, jGetFunctionList, getFunctionListStr);\n-    if (C_GetFunctionList == NULL) {\n-        FormatMessage(\n-            FORMAT_MESSAGE_ALLOCATE_BUFFER |\n-            FORMAT_MESSAGE_FROM_SYSTEM |\n-            FORMAT_MESSAGE_IGNORE_INSERTS,\n-            NULL,\n-            GetLastError(),\n-            0, \/* Default language *\/\n-            (LPTSTR) &lpMsgBuf,\n-            0,\n-            NULL\n-        );\n-        throwIOException(env, (LPTSTR) lpMsgBuf);\n-        goto cleanup;\n+    C_GetInterfaceList = (CK_C_GetInterfaceList) GetProcAddress(hModule,\n+            \"C_GetInterfaceList\");\n+    if (C_GetInterfaceList != NULL) {\n+        TRACE0(\"Found C_GetInterfaceList func\\n\");\n+        rv = (C_GetInterfaceList)(NULL, &ulCount);\n+        if (rv == CKR_OK) {\n+            \/* get copy of interfaces *\/\n+            iList = (CK_INTERFACE_PTR)\n+                    malloc(ulCount*sizeof(CK_INTERFACE));\n+            rv = C_GetInterfaceList(iList, &ulCount);\n+            for (i=0; i < (int)ulCount; i++) {\n+                printf(\"interface %s version %d.%d funcs %p flags 0x%lu\\n\",\n+                        iList[i].pInterfaceName,\n+                        ((CK_VERSION *)iList[i].pFunctionList)->major,\n+                        ((CK_VERSION *)iList[i].pFunctionList)->minor,\n+                        iList[i].pFunctionList, iList[i].flags);\n+            }\n+        } else {\n+            TRACE0(\"Connect: error polling interface list size\\n\");\n+        }\n+    } else {\n+        TRACE0(\"Connect: No C_GetInterfaceList func\\n\");\n+    }\n+#endif\n+\n+    if (jGetFunctionList != NULL) {\n+        getFunctionListStr = (*env)->GetStringUTFChars(env,\n+                jGetFunctionList, 0);\n+        if (getFunctionListStr == NULL) {\n+            goto cleanup;\n+        }\n+        C_GetFunctionList = (CK_C_GetFunctionList) GetProcAddress(hModule,\n+                getFunctionListStr);\n+        if (C_GetFunctionList == NULL) {\n+            TRACE1(\"Connect: No %s func\\n\", getFunctionListStr);\n+            FormatMessage(\n+                FORMAT_MESSAGE_ALLOCATE_BUFFER |\n+                FORMAT_MESSAGE_FROM_SYSTEM |\n+                FORMAT_MESSAGE_IGNORE_INSERTS,\n+                NULL,\n+                GetLastError(),\n+                0, \/* Default language *\/\n+                (LPTSTR) &lpMsgBuf,\n+                0,\n+                NULL\n+            );\n+            throwIOException(env, (LPTSTR) lpMsgBuf);\n+            goto cleanup;\n+        }\n+        TRACE1(\"Connect: Found %s func\\n\", getFunctionListStr);\n+    } else {\n+        \/\/ if none specified, then we try 3.0 API first before trying 2.40\n+        C_GetInterface = (CK_C_GetInterface) GetProcAddress(hModule,\n+            \"C_GetInterface\");\n+        if (C_GetInterface != NULL) {\n+            TRACE0(\"Connect: Found C_GetInterface func\\n\");\n+            rv = (C_GetInterface)(NULL, NULL, &interface, 0);\n+            if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {\n+                goto setModuleData;\n+            }\n+        }\n+        C_GetFunctionList = (CK_C_GetFunctionList) GetProcAddress(hModule,\n+                \"C_GetFunctionList\");\n+        if (C_GetFunctionList == NULL) {\n+            TRACE0(\"Connect: No C_GetFunctionList func\\n\");\n+            FormatMessage(\n+                FORMAT_MESSAGE_ALLOCATE_BUFFER |\n+                FORMAT_MESSAGE_FROM_SYSTEM |\n+                FORMAT_MESSAGE_IGNORE_INSERTS,\n+                NULL,\n+                GetLastError(),\n+                0, \/* Default language *\/\n+                (LPTSTR) &lpMsgBuf,\n+                0,\n+                NULL\n+            );\n+            throwIOException(env, (LPTSTR) lpMsgBuf);\n+            goto cleanup;\n+        }\n+        TRACE0(\"Connect: Found C_GetFunctionList func\\n\");\n@@ -146,0 +214,1 @@\n+setModuleData:\n@@ -156,1 +225,22 @@\n-    rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n+    if (C_GetFunctionList != NULL) {\n+        rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n+        if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {\n+            goto cleanup;\n+        }\n+    } else if (interface != NULL) {\n+        moduleData->ckFunctionListPtr = interface->pFunctionList;\n+    } else {\n+        \/\/ should never happen\n+        throwIOException(env, \"ERROR: No function list ptr found\");\n+        goto cleanup;\n+    }\n+    if (((CK_VERSION *)moduleData->ckFunctionListPtr)->major == 3) {\n+        moduleData->ckFunctionList30Ptr = interface->pFunctionList;\n+    } else {\n+        moduleData->ckFunctionList30Ptr = NULL;\n+    }\n+\n+    TRACE2(\"Connect: FunctionListPtr version = %d.%d\\n\",\n+        ((CK_VERSION *)moduleData->ckFunctionListPtr)->major,\n+        ((CK_VERSION *)moduleData->ckFunctionListPtr)->minor);\n+\n@@ -160,2 +250,0 @@\n-    TRACE0(\"FINISHED\\n\");\n-\n@@ -170,0 +258,4 @@\n+    if (jGetFunctionList != NULL && getFunctionListStr != NULL) {\n+        (*env)->ReleaseStringUTFChars(env, jGetFunctionList,\n+            getFunctionListStr);\n+    }\n@@ -173,0 +265,7 @@\n+    TRACE0(\"Connect: FINISHED\\n\");\n+    if (moduleData != NULL) {\n+        return ckVersionPtrToJVersion(env,\n+                (CK_VERSION *)moduleData->ckFunctionListPtr);\n+    } else {\n+        return NULL;\n+    }\n@@ -174,1 +273,0 @@\n-    if(ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/p11_md.c","additions":131,"deletions":33,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-    \/* The pointer to the PKCS#11 functions of this module. *\/\n+    \/* The pointers to the PKCS#11 functions of this module. *\/\n@@ -98,0 +98,1 @@\n+    CK_FUNCTION_LIST_3_0_PTR ckFunctionList30Ptr;\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/p11_md.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}