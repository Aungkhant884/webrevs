{"files":[{"patch":"@@ -47,1 +47,1 @@\n-  assert(dummy_region->par_allocate_no_bot_updates(1, 1, &assert_tmp) == NULL, \"should fail\");\n+  assert(dummy_region->par_allocate(1, 1, &assert_tmp) == NULL, \"should fail\");\n@@ -53,6 +53,0 @@\n-void G1AllocRegion::update_bot_for_region_waste(HeapWord* addr, size_t size) {\n-  assert(_alloc_region != NULL, \"invariant\");\n-  assert(_bot_updates, \"must only be called for regions doing BOT updates\");\n-  _alloc_region->update_bot_at(addr, size);\n-}\n-\n@@ -83,2 +77,3 @@\n-      \/\/ If the allocation was successful we should fill in the space.\n-      CollectedHeap::fill_with_object(dummy, free_word_size);\n+      \/\/ If the allocation was successful we should fill in the space. If the\n+      \/\/ allocation was in old any necessary BOT updates will be done.\n+      alloc_region->fill_with_dummy_object(dummy, free_word_size);\n@@ -87,4 +82,0 @@\n-      \/\/ Update BOT if this is an old region requiring BOT updates.\n-      if (_bot_updates) {\n-        update_bot_for_region_waste(dummy, free_word_size);\n-      }\n@@ -266,1 +257,0 @@\n-    _bot_updates(bot_updates),\n@@ -399,2 +389,1 @@\n-        CollectedHeap::fill_with_object(dummy, to_allocate_words);\n-        update_bot_for_region_waste(dummy, to_allocate_words);\n+        cur->fill_with_dummy_object(dummy, to_allocate_words);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -71,3 +71,0 @@\n-  \/\/ When true, indicates that allocate calls should do BOT updates.\n-  const bool _bot_updates;\n-\n@@ -129,3 +126,0 @@\n-  \/\/ Update the BOT for the filler object allocated at the given address.\n-  void update_bot_for_region_waste(HeapWord* addr, size_t size);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-    assert((p), \"[%s] %s c: %u b: %s r: \" PTR_FORMAT \" u: \" SIZE_FORMAT, \\\n-           _name, (message), _count, BOOL_TO_STR(_bot_updates),          \\\n-           p2i(_alloc_region), _used_bytes_before);                      \\\n+    assert((p), \"[%s] %s c: %u r: \" PTR_FORMAT \" u: \" SIZE_FORMAT,       \\\n+           _name, (message), _count, p2i(_alloc_region),                 \\\n+           _used_bytes_before);                                          \\\n@@ -48,1 +48,1 @@\n-  return alloc_region->allocate_no_bot_updates(word_size);\n+  return alloc_region->allocate(word_size);\n@@ -63,1 +63,1 @@\n-  return alloc_region->par_allocate_no_bot_updates(min_word_size, desired_word_size, actual_word_size);\n+  return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -295,13 +295,0 @@\n-G1PLAB::G1PLAB(size_t word_sz) : PLAB(word_sz) { }\n-\n-bool G1PLAB::is_allocated() {\n-  return _top != nullptr;\n-}\n-HeapWord* G1PLAB::get_filler() {\n-  return _top;\n-}\n-\n-size_t G1PLAB::get_filler_size() {\n-  return pointer_delta(_hard_end, _top);\n-}\n-\n@@ -310,3 +297,1 @@\n-  _allocator(allocator),\n-  _bot_plab_region(nullptr),\n-  _bot_plab_threshold(nullptr) {\n+  _allocator(allocator) {\n@@ -316,1 +301,1 @@\n-    _alloc_buffers[state] = NEW_C_HEAP_ARRAY(G1PLAB*, length, mtGC);\n+    _alloc_buffers[state] = NEW_C_HEAP_ARRAY(PLAB*, length, mtGC);\n@@ -318,1 +303,6 @@\n-      _alloc_buffers[state][node_index] = new G1PLAB(_g1h->desired_plab_sz(state));\n+      if (state == G1HeapRegionAttr::Old) {\n+        \/\/ Specialized PLABs for old that handle BOT updates for object allocations.\n+        _alloc_buffers[state][node_index] = new G1BotUpdatingPLAB(_g1h->desired_plab_sz(state));\n+      } else {\n+        _alloc_buffers[state][node_index] = new PLAB(_g1h->desired_plab_sz(state));\n+      }\n@@ -349,2 +339,1 @@\n-    G1PLAB* alloc_buf = alloc_buffer(dest, node_index);\n-    update_bot_for_plab_waste(dest, alloc_buf);\n+    PLAB* alloc_buf = alloc_buffer(dest, node_index);\n@@ -365,1 +354,0 @@\n-      calculate_new_bot_threshold(dest, buf);\n@@ -394,1 +382,1 @@\n-      G1PLAB* const buf = alloc_buffer(state, node_index);\n+      PLAB* const buf = alloc_buffer(state, node_index);\n@@ -396,1 +384,0 @@\n-        update_bot_for_plab_waste(state, buf);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -148,3 +148,8 @@\n-\/\/ Helper class to get the information needed to do\n-\/\/ BOT updates for the end of the PLAB.\n-class G1PLAB : public PLAB {\n+\/\/ Specialized PLAB for old generation promotions. For old regions the\n+\/\/ BOT needs to be updated and the relevant data to do this efficiently\n+\/\/ is stored in the PLAB.\n+class G1BotUpdatingPLAB : public PLAB {\n+  \/\/ An object spanning this threshold will cause a BOT update.\n+  HeapWord* _next_bot_threshold;\n+  \/\/ The region in which the PLAB resides.\n+  HeapRegion* _region;\n@@ -152,4 +157,5 @@\n-  G1PLAB(size_t word_sz);\n-  bool is_allocated();\n-  HeapWord* get_filler();\n-  size_t get_filler_size();\n+  G1BotUpdatingPLAB(size_t word_sz) : PLAB(word_sz) { }\n+  \/\/ Sets the new PLAB buffer as well as updates the threshold and region.\n+  virtual void set_buf(HeapWord* buf, size_t word_sz);\n+  \/\/ Updates the BOT if the last allocation crossed the threshold.\n+  inline void update_bot(size_t word_sz);\n@@ -169,7 +175,1 @@\n-  \/\/ Region where the current old generation PLAB is allocated. Used to do BOT updates.\n-  HeapRegion* _bot_plab_region;\n-  \/\/ Current BOT threshold, a PLAB allocation crossing this threshold will cause a BOT\n-  \/\/ update.\n-  HeapWord* _bot_plab_threshold;\n-\n-  G1PLAB** _alloc_buffers[G1HeapRegionAttr::Num];\n+  PLAB** _alloc_buffers[G1HeapRegionAttr::Num];\n@@ -181,2 +181,2 @@\n-  inline G1PLAB* alloc_buffer(G1HeapRegionAttr dest, uint node_index) const;\n-  inline G1PLAB* alloc_buffer(region_type_t dest, uint node_index) const;\n+  inline PLAB* alloc_buffer(G1HeapRegionAttr dest, uint node_index) const;\n+  inline PLAB* alloc_buffer(region_type_t dest, uint node_index) const;\n@@ -186,4 +186,0 @@\n-  void update_bot_for_plab_waste(G1HeapRegionAttr dest, G1PLAB* plab);\n-  \/\/ When a new PLAB is allocated a new threshold needs to be calculated and\n-  \/\/ possibly also the current region where BOT updates should be done.\n-  void calculate_new_bot_threshold(G1HeapRegionAttr attr, HeapWord* addr);\n@@ -224,1 +220,2 @@\n-  void undo_allocation(G1HeapRegionAttr dest, HeapWord* obj, size_t word_sz, uint node_index);\n+  \/\/ Update the BOT for the last PLAB allocation.\n+  inline void update_bot_for_allocation(G1HeapRegionAttr dest, size_t word_sz, uint node_index);\n@@ -226,2 +223,1 @@\n-  \/\/ Update the BOT for an allocation inside an old PLAB.\n-  void update_bot_for_object(HeapWord* obj_start, size_t obj_size);\n+  void undo_allocation(G1HeapRegionAttr dest, HeapWord* obj, size_t word_sz, uint node_index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-inline G1PLAB* G1PLABAllocator::alloc_buffer(G1HeapRegionAttr dest, uint node_index) const {\n+inline PLAB* G1PLABAllocator::alloc_buffer(G1HeapRegionAttr dest, uint node_index) const {\n@@ -97,1 +97,1 @@\n-inline G1PLAB* G1PLABAllocator::alloc_buffer(region_type_t dest, uint node_index) const {\n+inline PLAB* G1PLABAllocator::alloc_buffer(region_type_t dest, uint node_index) const {\n@@ -136,29 +136,0 @@\n-inline void G1PLABAllocator::update_bot_for_plab_waste(G1HeapRegionAttr attr, G1PLAB* plab) {\n-  if (!attr.is_old()) {\n-    \/\/ BOT updates are only done for old generation.\n-    return;\n-  }\n-\n-  if (!plab->is_allocated()) {\n-    return;\n-  }\n-  update_bot_for_object(plab->get_filler(), plab->get_filler_size());\n-}\n-\n-inline void G1PLABAllocator::calculate_new_bot_threshold(G1HeapRegionAttr attr, HeapWord* addr) {\n-  if (!attr.is_old()) {\n-    \/\/ BOT updates are only done for old generation.\n-    return;\n-  }\n-\n-  _bot_plab_region = _g1h->heap_region_containing(addr);\n-  _bot_plab_threshold = _bot_plab_region->bot_threshold_for_addr(addr);\n-\n-  assert(_bot_plab_threshold >= addr,\n-         \"threshold must be at or after PLAB start. \" PTR_FORMAT \" >= \" PTR_FORMAT,\n-         p2i(_bot_plab_threshold), p2i(addr));\n-  assert(_bot_plab_region->is_old(),\n-         \"Updating BOT threshold for non-old region. addr: \" PTR_FORMAT \" region:\" HR_FORMAT,\n-         p2i(addr), HR_FORMAT_PARAMS(_bot_plab_region));\n-}\n-\n@@ -166,1 +137,1 @@\n-  if (!attr.is_old()) {\n+  if (!attr.needs_bot_update()) {\n@@ -176,6 +147,5 @@\n-inline void G1PLABAllocator::update_bot_for_object(HeapWord* obj_start, size_t obj_size) {\n-  HeapWord* obj_end = obj_start + obj_size;\n-  if (obj_end <= _bot_plab_threshold) {\n-    \/\/ Not crossing the threshold.\n-    return;\n-  }\n+inline void G1PLABAllocator::update_bot_for_allocation(G1HeapRegionAttr dest, size_t word_sz, uint node_index) {\n+  assert(dest.needs_bot_update(), \"Wrong destination: %s\", dest.get_type_str());\n+  G1BotUpdatingPLAB* plab = static_cast<G1BotUpdatingPLAB*>(alloc_buffer(dest, node_index));\n+  plab->update_bot(word_sz);\n+}\n@@ -183,2 +153,11 @@\n-  if (!alloc_buffer(G1HeapRegionAttr::Old, 0)->contains(obj_start)) {\n-    \/\/ Out of PLAB allocation, BOT already updated.\n+inline void G1BotUpdatingPLAB::set_buf(HeapWord* buf, size_t word_sz) {\n+  PLAB::set_buf(buf, word_sz);\n+  \/\/ Update the region and threshold to allow efficient BOT updates.\n+  _region = G1CollectedHeap::heap()->heap_region_containing(buf);\n+  _next_bot_threshold = _region->bot_threshold_for_addr(buf);\n+}\n+\n+inline void G1BotUpdatingPLAB::update_bot(size_t word_sz) {\n+  \/\/ The last object end is at _top, if it did not cross the\n+  \/\/ threshold, there is nothing to do.\n+  if (_top <= _next_bot_threshold) {\n@@ -188,2 +167,9 @@\n-  \/\/ Update the BOT. The threshold also gets updated to the next threshold by this call.\n-  _bot_plab_region->update_bot_crossing_threshold(&_bot_plab_threshold, obj_start, obj_end);\n+  HeapWord* obj_start = _top - word_sz;\n+  assert(contains(obj_start),\n+         \"Object start outside PLAB. bottom: \" PTR_FORMAT \" object: \" PTR_FORMAT,\n+         p2i(_bottom), p2i(obj_start));\n+  assert(obj_start <= _next_bot_threshold,\n+         \"Object start not below or at threshold. threshold: \" PTR_FORMAT \" object: \" PTR_FORMAT,\n+         p2i(_next_bot_threshold), p2i(obj_start));\n+\n+  _region->update_bot_crossing_threshold(&_next_bot_threshold, obj_start, _top);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":28,"deletions":42,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -3449,0 +3449,5 @@\n+\n+void G1CollectedHeap::fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap) {\n+  HeapRegion* region = heap_region_containing(start);\n+  region->fill_with_dummy_object(start, pointer_delta(end, start), zap);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -937,0 +937,2 @@\n+  virtual void fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  bool needs_bot_update() const        { return is_old(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -502,2 +502,2 @@\n-      assert(dest_attr.is_old(), \"Only update bot for allocations in old\");\n-      _plab_allocator->update_bot_for_object(obj_ptr, word_sz);\n+      \/\/ Currently we only have two destinations we only skip BOT updates for young.\n+      _plab_allocator->update_bot_for_allocation(dest_attr, word_sz, node_index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -817,0 +817,9 @@\n+\n+void HeapRegion::fill_with_dummy_object(HeapWord* address, size_t word_size, bool zap) {\n+  \/\/ Keep the BOT in sync for old generation regions.\n+  if (is_old()) {\n+    update_bot_at(address, word_size);\n+  }\n+  \/\/ Fill in the object.\n+  CollectedHeap::fill_with_object(address, word_size, zap);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -155,0 +155,4 @@\n+  \/\/ At the given address create an object with the given size. If the region\n+  \/\/ is old the BOT will be updated if the object spans a threshold.\n+  void fill_with_dummy_object(HeapWord* address, size_t word_size, bool zap = true);\n+\n@@ -158,3 +162,3 @@\n-  inline HeapWord* par_allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* word_size);\n-  inline HeapWord* allocate_no_bot_updates(size_t word_size);\n-  inline HeapWord* allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* actual_size);\n+  inline HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* word_size);\n+  inline HeapWord* allocate(size_t word_size);\n+  inline HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -224,3 +224,3 @@\n-inline HeapWord* HeapRegion::par_allocate_no_bot_updates(size_t min_word_size,\n-                                                         size_t desired_word_size,\n-                                                         size_t* actual_word_size) {\n+inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,\n+                                          size_t desired_word_size,\n+                                          size_t* actual_word_size) {\n@@ -230,1 +230,1 @@\n-inline HeapWord* HeapRegion::allocate_no_bot_updates(size_t word_size) {\n+inline HeapWord* HeapRegion::allocate(size_t word_size) {\n@@ -232,1 +232,1 @@\n-  return allocate_no_bot_updates(word_size, word_size, &temp);\n+  return allocate(word_size, word_size, &temp);\n@@ -235,3 +235,3 @@\n-inline HeapWord* HeapRegion::allocate_no_bot_updates(size_t min_word_size,\n-                                                     size_t desired_word_size,\n-                                                     size_t* actual_word_size) {\n+inline HeapWord* HeapRegion::allocate(size_t min_word_size,\n+                                      size_t desired_word_size,\n+                                      size_t* actual_word_size) {\n@@ -242,0 +242,6 @@\n+  assert(_bot_part.threshold_for_addr(addr) >= addr,\n+         \"threshold must be at or after given address. \" PTR_FORMAT \" >= \" PTR_FORMAT,\n+         p2i(_bot_part.threshold_for_addr(addr)), p2i(addr));\n+  assert(is_old(),\n+         \"Should only calculate BOT threshold for old regions. addr: \" PTR_FORMAT \" region:\" HR_FORMAT,\n+         p2i(addr), HR_FORMAT_PARAMS(this));\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  void set_buf(HeapWord* buf, size_t new_word_sz) {\n+  virtual void set_buf(HeapWord* buf, size_t new_word_sz) {\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}