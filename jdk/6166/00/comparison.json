{"files":[{"patch":"@@ -46,2 +46,0 @@\n-  assert(dummy_region->allocate_no_bot_updates(1) == NULL, \"should fail\");\n-  assert(dummy_region->allocate(1) == NULL, \"should fail\");\n@@ -50,1 +48,0 @@\n-  assert(dummy_region->par_allocate(1, 1, &assert_tmp) == NULL, \"should fail\");\n@@ -56,0 +53,6 @@\n+void G1AllocRegion::update_bot_for_region_waste(HeapWord* addr, size_t size) {\n+  assert(_alloc_region != NULL, \"invariant\");\n+  assert(_bot_updates, \"must only be called for regions doing BOT updates\");\n+  _alloc_region->update_bot_at(addr, size);\n+}\n+\n@@ -84,0 +87,4 @@\n+      \/\/ Update BOT if this is an old region requiring BOT updates.\n+      if (_bot_updates) {\n+        update_bot_for_region_waste(dummy, free_word_size);\n+      }\n@@ -393,0 +400,1 @@\n+        update_bot_for_region_waste(dummy, to_allocate_words);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -129,0 +129,3 @@\n+  \/\/ Update the BOT for the filler object allocated at the given address.\n+  void update_bot_for_region_waste(HeapWord* addr, size_t size);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,5 +48,1 @@\n-  if (!_bot_updates) {\n-    return alloc_region->allocate_no_bot_updates(word_size);\n-  } else {\n-    return alloc_region->allocate(word_size);\n-  }\n+  return alloc_region->allocate_no_bot_updates(word_size);\n@@ -67,5 +63,1 @@\n-  if (!_bot_updates) {\n-    return alloc_region->par_allocate_no_bot_updates(min_word_size, desired_word_size, actual_word_size);\n-  } else {\n-    return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n-  }\n+  return alloc_region->par_allocate_no_bot_updates(min_word_size, desired_word_size, actual_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -295,0 +295,13 @@\n+G1PLAB::G1PLAB(size_t word_sz) : PLAB(word_sz) { }\n+\n+bool G1PLAB::is_allocated() {\n+  return _top != nullptr;\n+}\n+HeapWord* G1PLAB::get_filler() {\n+  return _top;\n+}\n+\n+size_t G1PLAB::get_filler_size() {\n+  return pointer_delta(_hard_end, _top);\n+}\n+\n@@ -297,1 +310,3 @@\n-  _allocator(allocator) {\n+  _allocator(allocator),\n+  _bot_plab_region(nullptr),\n+  _bot_plab_threshold(nullptr) {\n@@ -301,1 +316,1 @@\n-    _alloc_buffers[state] = NEW_C_HEAP_ARRAY(PLAB*, length, mtGC);\n+    _alloc_buffers[state] = NEW_C_HEAP_ARRAY(G1PLAB*, length, mtGC);\n@@ -303,1 +318,1 @@\n-      _alloc_buffers[state][node_index] = new PLAB(_g1h->desired_plab_sz(state));\n+      _alloc_buffers[state][node_index] = new G1PLAB(_g1h->desired_plab_sz(state));\n@@ -334,1 +349,2 @@\n-    PLAB* alloc_buf = alloc_buffer(dest, node_index);\n+    G1PLAB* alloc_buf = alloc_buffer(dest, node_index);\n+    update_bot_for_plab_waste(dest, alloc_buf);\n@@ -349,0 +365,1 @@\n+      calculate_new_bot_threshold(dest, buf);\n@@ -363,0 +380,1 @@\n+    update_bot_for_direct_allocation(dest, result, word_sz);\n@@ -376,1 +394,1 @@\n-      PLAB* const buf = alloc_buffer(state, node_index);\n+      G1PLAB* const buf = alloc_buffer(state, node_index);\n@@ -378,0 +396,1 @@\n+        update_bot_for_plab_waste(state, buf);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -148,0 +148,10 @@\n+\/\/ Helper class to get the information needed to do\n+\/\/ BOT updates for the end of the PLAB.\n+class G1PLAB : public PLAB {\n+public:\n+  G1PLAB(size_t word_sz);\n+  bool is_allocated();\n+  HeapWord* get_filler();\n+  size_t get_filler_size();\n+};\n+\n@@ -159,1 +169,7 @@\n-  PLAB** _alloc_buffers[G1HeapRegionAttr::Num];\n+  \/\/ Region where the current old generation PLAB is allocated. Used to do BOT updates.\n+  HeapRegion* _bot_plab_region;\n+  \/\/ Current BOT threshold, a PLAB allocation crossing this threshold will cause a BOT\n+  \/\/ update.\n+  HeapWord* _bot_plab_threshold;\n+\n+  G1PLAB** _alloc_buffers[G1HeapRegionAttr::Num];\n@@ -165,2 +181,9 @@\n-  inline PLAB* alloc_buffer(G1HeapRegionAttr dest, uint node_index) const;\n-  inline PLAB* alloc_buffer(region_type_t dest, uint node_index) const;\n+  inline G1PLAB* alloc_buffer(G1HeapRegionAttr dest, uint node_index) const;\n+  inline G1PLAB* alloc_buffer(region_type_t dest, uint node_index) const;\n+\n+  \/\/ Helpers to do explicit BOT updates for allocations in old generation regions.\n+  void update_bot_for_direct_allocation(G1HeapRegionAttr attr, HeapWord* addr, size_t size);\n+  void update_bot_for_plab_waste(G1HeapRegionAttr dest, G1PLAB* plab);\n+  \/\/ When a new PLAB is allocated a new threshold needs to be calculated and\n+  \/\/ possibly also the current region where BOT updates should be done.\n+  void calculate_new_bot_threshold(G1HeapRegionAttr attr, HeapWord* addr);\n@@ -202,0 +225,3 @@\n+\n+  \/\/ Update the BOT for an allocation inside an old PLAB.\n+  void update_bot_for_object(HeapWord* obj_start, size_t obj_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-inline PLAB* G1PLABAllocator::alloc_buffer(G1HeapRegionAttr dest, uint node_index) const {\n+inline G1PLAB* G1PLABAllocator::alloc_buffer(G1HeapRegionAttr dest, uint node_index) const {\n@@ -97,1 +97,1 @@\n-inline PLAB* G1PLABAllocator::alloc_buffer(region_type_t dest, uint node_index) const {\n+inline G1PLAB* G1PLABAllocator::alloc_buffer(region_type_t dest, uint node_index) const {\n@@ -136,0 +136,56 @@\n+inline void G1PLABAllocator::update_bot_for_plab_waste(G1HeapRegionAttr attr, G1PLAB* plab) {\n+  if (!attr.is_old()) {\n+    \/\/ BOT updates are only done for old generation.\n+    return;\n+  }\n+\n+  if (!plab->is_allocated()) {\n+    return;\n+  }\n+  update_bot_for_object(plab->get_filler(), plab->get_filler_size());\n+}\n+\n+inline void G1PLABAllocator::calculate_new_bot_threshold(G1HeapRegionAttr attr, HeapWord* addr) {\n+  if (!attr.is_old()) {\n+    \/\/ BOT updates are only done for old generation.\n+    return;\n+  }\n+\n+  _bot_plab_region = _g1h->heap_region_containing(addr);\n+  _bot_plab_threshold = _bot_plab_region->bot_threshold_for_addr(addr);\n+\n+  assert(_bot_plab_threshold >= addr,\n+         \"threshold must be at or after PLAB start. \" PTR_FORMAT \" >= \" PTR_FORMAT,\n+         p2i(_bot_plab_threshold), p2i(addr));\n+  assert(_bot_plab_region->is_old(),\n+         \"Updating BOT threshold for non-old region. addr: \" PTR_FORMAT \" region:\" HR_FORMAT,\n+         p2i(addr), HR_FORMAT_PARAMS(_bot_plab_region));\n+}\n+\n+inline void G1PLABAllocator::update_bot_for_direct_allocation(G1HeapRegionAttr attr, HeapWord* addr, size_t size) {\n+  if (!attr.is_old()) {\n+    \/\/ BOT updates are only done for old generation.\n+    return;\n+  }\n+\n+  \/\/ Out of PLAB allocations in an old generation region. Update BOT.\n+  HeapRegion* region = _g1h->heap_region_containing(addr);\n+  region->update_bot_at(addr, size);\n+}\n+\n+inline void G1PLABAllocator::update_bot_for_object(HeapWord* obj_start, size_t obj_size) {\n+  HeapWord* obj_end = obj_start + obj_size;\n+  if (obj_end <= _bot_plab_threshold) {\n+    \/\/ Not crossing the threshold.\n+    return;\n+  }\n+\n+  if (!alloc_buffer(G1HeapRegionAttr::Old, 0)->contains(obj_start)) {\n+    \/\/ Out of PLAB allocation, BOT already updated.\n+    return;\n+  }\n+\n+  \/\/ Update the BOT. The threshold also gets updated to the next threshold by this call.\n+  _bot_plab_region->update_bot_crossing_threshold(&_bot_plab_threshold, obj_start, obj_end);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":58,"deletions":2,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+  friend class HeapRegion;\n@@ -184,0 +185,3 @@\n+  \/\/ Given an address calculate where the next threshold needing an update is.\n+  inline HeapWord* threshold_for_addr(const void* addr);\n+\n@@ -207,0 +211,5 @@\n+  \/\/ Sets the threshold explicitly to keep it consistent with what has been\n+  \/\/ updated. This needs to be done when the threshold is not used for updating\n+  \/\/ the bot, for example when promoting to old in young collections.\n+  void set_threshold(HeapWord* threshold) { _next_offset_threshold = threshold; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,14 @@\n+inline HeapWord* G1BlockOffsetTablePart::threshold_for_addr(const void* addr) {\n+  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+  size_t index = _bot->index_for(addr);\n+  HeapWord* card_boundary = _bot->address_for_index(index);\n+  \/\/ Address at card boundary, use as threshold.\n+  if (card_boundary == addr) {\n+    return card_boundary;\n+  }\n+\n+  \/\/ Calculate next threshold.\n+  HeapWord* threshold = card_boundary + BOTConstants::N_words;\n+  return threshold;\n+}\n+\n@@ -112,3 +126,0 @@\n-  \/\/ We must make sure that the offset table entry we use is valid.\n-  assert(addr < _next_offset_threshold, \"Precondition\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3296,0 +3296,1 @@\n+    alloc_region->update_bot_threshold();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -501,0 +501,3 @@\n+    } else {\n+      assert(dest_attr.is_old(), \"Only update bot for allocations in old\");\n+      _plab_allocator->update_bot_for_object(obj_ptr, word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -236,1 +236,0 @@\n-  _par_alloc_lock(Mutex::service-2, \"HeapRegionParAlloc_lock\"),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  Mutex _par_alloc_lock;\n+\n@@ -155,9 +155,3 @@\n-  \/\/ Allocation (return NULL if full).  Assumes the caller has established\n-  \/\/ mutually exclusive access to the HeapRegion.\n-  HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-  \/\/ Allocation (return NULL if full).  Enforces mutual exclusion internally.\n-  HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-\n-  HeapWord* allocate(size_t word_size);\n-  HeapWord* par_allocate(size_t word_size);\n-\n+  \/\/ All allocations are done without updating the BOT. The BOT\n+  \/\/ needs to be kept in sync for old generation regions and\n+  \/\/ this is done by explicit updates when crossing thresholds.\n@@ -168,0 +162,8 @@\n+  \/\/ Update the BOT for the given address if it crosses the next\n+  \/\/ BOT threshold at or after obj_start.\n+  inline void update_bot_at(HeapWord* obj_start, size_t obj_size);\n+  \/\/ Update BOT at the given threshold for the given object. The\n+  \/\/ given object must cross the threshold.\n+  inline void update_bot_crossing_threshold(HeapWord** threshold, HeapWord* obj_start, HeapWord* obj_end);\n+  inline HeapWord* bot_threshold_for_addr(const void* addr);\n+\n@@ -203,0 +205,4 @@\n+  void update_bot_threshold() {\n+    _bot_part.set_threshold(top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -81,30 +81,0 @@\n-inline HeapWord* HeapRegion::allocate(size_t min_word_size,\n-                                      size_t desired_word_size,\n-                                      size_t* actual_size) {\n-  HeapWord* res = allocate_impl(min_word_size, desired_word_size, actual_size);\n-  if (res != NULL) {\n-    _bot_part.alloc_block(res, *actual_size);\n-  }\n-  return res;\n-}\n-\n-inline HeapWord* HeapRegion::allocate(size_t word_size) {\n-  size_t temp;\n-  return allocate(word_size, word_size, &temp);\n-}\n-\n-inline HeapWord* HeapRegion::par_allocate(size_t word_size) {\n-  size_t temp;\n-  return par_allocate(word_size, word_size, &temp);\n-}\n-\n-\/\/ Because of the requirement of keeping \"_offsets\" up to date with the\n-\/\/ allocations, we sequentialize these with a lock.  Therefore, best if\n-\/\/ this is used for larger LAB allocations only.\n-inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,\n-                                          size_t desired_word_size,\n-                                          size_t* actual_size) {\n-  MutexLocker x(&_par_alloc_lock, Mutex::_no_safepoint_check_flag);\n-  return allocate(min_word_size, desired_word_size, actual_size);\n-}\n-\n@@ -257,1 +227,0 @@\n-  assert(is_young(), \"we can only skip BOT updates on young regions\");\n@@ -269,1 +238,0 @@\n-  assert(is_young(), \"we can only skip BOT updates on young regions\");\n@@ -273,0 +241,22 @@\n+inline HeapWord* HeapRegion::bot_threshold_for_addr(const void* addr) {\n+  return _bot_part.threshold_for_addr(addr);\n+}\n+\n+inline void HeapRegion::update_bot_crossing_threshold(HeapWord** threshold, HeapWord* obj_start, HeapWord* obj_end) {\n+  assert(is_old(), \"should only do BOT updates for old regions\");\n+  assert(is_in(obj_start), \"obj_start must be in this region: \" HR_FORMAT\n+         \" obj_start \" PTR_FORMAT \" obj_end \" PTR_FORMAT \" threshold \" PTR_FORMAT,\n+         HR_FORMAT_PARAMS(this),\n+         p2i(obj_start), p2i(obj_end), p2i(*threshold));\n+  _bot_part.alloc_block_work(threshold, obj_start, obj_end);\n+}\n+\n+inline void HeapRegion::update_bot_at(HeapWord* obj_start, size_t obj_size) {\n+  HeapWord* threshold = bot_threshold_for_addr(obj_start);\n+  HeapWord* obj_end = obj_start + obj_size;\n+\n+  if (obj_end > threshold) {\n+    update_bot_crossing_threshold(&threshold, obj_start, obj_end);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":22,"deletions":32,"binary":false,"changes":54,"status":"modified"}]}