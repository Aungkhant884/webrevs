{"files":[{"patch":"@@ -46,2 +46,0 @@\n-  assert(dummy_region->allocate_no_bot_updates(1) == NULL, \"should fail\");\n-  assert(dummy_region->allocate(1) == NULL, \"should fail\");\n@@ -49,1 +47,0 @@\n-  assert(dummy_region->par_allocate_no_bot_updates(1, 1, &assert_tmp) == NULL, \"should fail\");\n@@ -80,2 +77,3 @@\n-      \/\/ If the allocation was successful we should fill in the space.\n-      CollectedHeap::fill_with_object(dummy, free_word_size);\n+      \/\/ If the allocation was successful we should fill in the space. If the\n+      \/\/ allocation was in old any necessary BOT updates will be done.\n+      alloc_region->fill_with_dummy_object(dummy, free_word_size);\n@@ -259,1 +257,0 @@\n-    _bot_updates(bot_updates),\n@@ -392,1 +389,1 @@\n-        CollectedHeap::fill_with_object(dummy, to_allocate_words);\n+        cur->fill_with_dummy_object(dummy, to_allocate_words);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -71,3 +71,0 @@\n-  \/\/ When true, indicates that allocate calls should do BOT updates.\n-  const bool _bot_updates;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-    assert((p), \"[%s] %s c: %u b: %s r: \" PTR_FORMAT \" u: \" SIZE_FORMAT, \\\n-           _name, (message), _count, BOOL_TO_STR(_bot_updates),          \\\n-           p2i(_alloc_region), _used_bytes_before);                      \\\n+    assert((p), \"[%s] %s c: %u r: \" PTR_FORMAT \" u: \" SIZE_FORMAT,       \\\n+           _name, (message), _count, p2i(_alloc_region),                 \\\n+           _used_bytes_before);                                          \\\n@@ -48,5 +48,1 @@\n-  if (!_bot_updates) {\n-    return alloc_region->allocate_no_bot_updates(word_size);\n-  } else {\n-    return alloc_region->allocate(word_size);\n-  }\n+  return alloc_region->allocate(word_size);\n@@ -67,5 +63,1 @@\n-  if (!_bot_updates) {\n-    return alloc_region->par_allocate_no_bot_updates(min_word_size, desired_word_size, actual_word_size);\n-  } else {\n-    return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n-  }\n+  return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -302,0 +302,1 @@\n+    size_t word_sz = _g1h->desired_plab_sz(state);\n@@ -303,1 +304,4 @@\n-      _alloc_buffers[state][node_index] = new PLAB(_g1h->desired_plab_sz(state));\n+      \/\/ Specialized PLABs for old that handle BOT updates for object allocations.\n+      _alloc_buffers[state][node_index] = (state == G1HeapRegionAttr::Old)\n+                                        ? new G1BotUpdatingPLAB(word_sz)\n+                                        : new PLAB(word_sz);\n@@ -363,0 +367,1 @@\n+    update_bot_for_direct_allocation(dest, result, word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -148,0 +148,16 @@\n+\/\/ Specialized PLAB for old generation promotions. For old regions the\n+\/\/ BOT needs to be updated and the relevant data to do this efficiently\n+\/\/ is stored in the PLAB.\n+class G1BotUpdatingPLAB : public PLAB {\n+  \/\/ An object spanning this threshold will cause a BOT update.\n+  HeapWord* _next_bot_threshold;\n+  \/\/ The region in which the PLAB resides.\n+  HeapRegion* _region;\n+public:\n+  G1BotUpdatingPLAB(size_t word_sz) : PLAB(word_sz) { }\n+  \/\/ Sets the new PLAB buffer as well as updates the threshold and region.\n+  void set_buf(HeapWord* buf, size_t word_sz) override;\n+  \/\/ Updates the BOT if the last allocation crossed the threshold.\n+  inline void update_bot(size_t word_sz);\n+};\n+\n@@ -168,0 +184,3 @@\n+  \/\/ Helpers to do explicit BOT updates for allocations in old generation regions.\n+  void update_bot_for_direct_allocation(G1HeapRegionAttr attr, HeapWord* addr, size_t size);\n+\n@@ -173,0 +192,4 @@\n+  \/\/ Returns if BOT updates are needed for the given destinaion. Currently we only have\n+  \/\/ two destinations and BOT updates are only needed for the old generation.\n+  inline bool needs_bot_update(G1HeapRegionAttr dest) const;\n+\n@@ -201,0 +224,3 @@\n+  \/\/ Update the BOT for the last PLAB allocation.\n+  inline void update_bot_for_plab_allocation(G1HeapRegionAttr dest, size_t word_sz, uint node_index);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -136,0 +136,45 @@\n+inline bool G1PLABAllocator::needs_bot_update(G1HeapRegionAttr dest) const {\n+  return dest.is_old();\n+}\n+\n+inline void G1PLABAllocator::update_bot_for_direct_allocation(G1HeapRegionAttr attr, HeapWord* addr, size_t size) {\n+  if (!needs_bot_update(attr)) {\n+    return;\n+  }\n+\n+  \/\/ Out of PLAB allocations in an old generation region. Update BOT.\n+  HeapRegion* region = _g1h->heap_region_containing(addr);\n+  region->update_bot_at(addr, size);\n+}\n+\n+inline void G1PLABAllocator::update_bot_for_plab_allocation(G1HeapRegionAttr dest, size_t word_sz, uint node_index) {\n+  assert(needs_bot_update(dest), \"Wrong destination: %s\", dest.get_type_str());\n+  G1BotUpdatingPLAB* plab = static_cast<G1BotUpdatingPLAB*>(alloc_buffer(dest, node_index));\n+  plab->update_bot(word_sz);\n+}\n+\n+inline void G1BotUpdatingPLAB::set_buf(HeapWord* buf, size_t word_sz) {\n+  PLAB::set_buf(buf, word_sz);\n+  \/\/ Update the region and threshold to allow efficient BOT updates.\n+  _region = G1CollectedHeap::heap()->heap_region_containing(buf);\n+  _next_bot_threshold = _region->bot_threshold_for_addr(buf);\n+}\n+\n+inline void G1BotUpdatingPLAB::update_bot(size_t word_sz) {\n+  \/\/ The last object end is at _top, if it did not cross the\n+  \/\/ threshold, there is nothing to do.\n+  if (_top <= _next_bot_threshold) {\n+    return;\n+  }\n+\n+  HeapWord* obj_start = _top - word_sz;\n+  assert(contains(obj_start),\n+         \"Object start outside PLAB. bottom: \" PTR_FORMAT \" object: \" PTR_FORMAT,\n+         p2i(_bottom), p2i(obj_start));\n+  assert(obj_start <= _next_bot_threshold,\n+         \"Object start not below or at threshold. threshold: \" PTR_FORMAT \" object: \" PTR_FORMAT,\n+         p2i(_next_bot_threshold), p2i(obj_start));\n+\n+  _region->update_bot_crossing_threshold(&_next_bot_threshold, obj_start, _top);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+  friend class HeapRegion;\n@@ -184,0 +185,3 @@\n+  \/\/ Given an address calculate where the next threshold needing an update is.\n+  inline HeapWord* threshold_for_addr(const void* addr);\n+\n@@ -207,0 +211,5 @@\n+  \/\/ Sets the threshold explicitly to keep it consistent with what has been\n+  \/\/ updated. This needs to be done when the threshold is not used for updating\n+  \/\/ the bot, for example when promoting to old in young collections.\n+  void set_threshold(HeapWord* threshold) { _next_offset_threshold = threshold; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,14 @@\n+inline HeapWord* G1BlockOffsetTablePart::threshold_for_addr(const void* addr) {\n+  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+  size_t index = _bot->index_for(addr);\n+  HeapWord* card_boundary = _bot->address_for_index(index);\n+  \/\/ Address at card boundary, use as threshold.\n+  if (card_boundary == addr) {\n+    return card_boundary;\n+  }\n+\n+  \/\/ Calculate next threshold.\n+  HeapWord* threshold = card_boundary + BOTConstants::N_words;\n+  return threshold;\n+}\n+\n@@ -112,3 +126,0 @@\n-  \/\/ We must make sure that the offset table entry we use is valid.\n-  assert(addr < _next_offset_threshold, \"Precondition\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3296,0 +3296,1 @@\n+    alloc_region->update_bot_threshold();\n@@ -3448,0 +3449,5 @@\n+\n+void G1CollectedHeap::fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap) {\n+  HeapRegion* region = heap_region_containing(start);\n+  region->fill_with_dummy_object(start, pointer_delta(end, start), zap);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -937,0 +937,2 @@\n+  virtual void fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,0 +501,5 @@\n+    } else {\n+      \/\/ Currently we only have two destinations and we only need BOT updates for\n+      \/\/ old. If the current allocation was done outside the PLAB this call will\n+      \/\/ have no effect since the _top of the PLAB has not changed.\n+      _plab_allocator->update_bot_for_plab_allocation(dest_attr, word_sz, node_index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -236,1 +236,0 @@\n-  _par_alloc_lock(Mutex::service-2, \"HeapRegionParAlloc_lock\"),\n@@ -818,0 +817,9 @@\n+\n+void HeapRegion::fill_with_dummy_object(HeapWord* address, size_t word_size, bool zap) {\n+  \/\/ Keep the BOT in sync for old generation regions.\n+  if (is_old()) {\n+    update_bot_at(address, word_size);\n+  }\n+  \/\/ Fill in the object.\n+  CollectedHeap::fill_with_object(address, word_size, zap);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  Mutex _par_alloc_lock;\n+\n@@ -155,12 +155,18 @@\n-  \/\/ Allocation (return NULL if full).  Assumes the caller has established\n-  \/\/ mutually exclusive access to the HeapRegion.\n-  HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-  \/\/ Allocation (return NULL if full).  Enforces mutual exclusion internally.\n-  HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-\n-  HeapWord* allocate(size_t word_size);\n-  HeapWord* par_allocate(size_t word_size);\n-\n-  inline HeapWord* par_allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* word_size);\n-  inline HeapWord* allocate_no_bot_updates(size_t word_size);\n-  inline HeapWord* allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* actual_size);\n+  \/\/ At the given address create an object with the given size. If the region\n+  \/\/ is old the BOT will be updated if the object spans a threshold.\n+  void fill_with_dummy_object(HeapWord* address, size_t word_size, bool zap = true);\n+\n+  \/\/ All allocations are done without updating the BOT. The BOT\n+  \/\/ needs to be kept in sync for old generation regions and\n+  \/\/ this is done by explicit updates when crossing thresholds.\n+  inline HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* word_size);\n+  inline HeapWord* allocate(size_t word_size);\n+  inline HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_size);\n+\n+  \/\/ Update the BOT for the given address if it crosses the next\n+  \/\/ BOT threshold at or after obj_start.\n+  inline void update_bot_at(HeapWord* obj_start, size_t obj_size);\n+  \/\/ Update BOT at the given threshold for the given object. The\n+  \/\/ given object must cross the threshold.\n+  inline void update_bot_crossing_threshold(HeapWord** threshold, HeapWord* obj_start, HeapWord* obj_end);\n+  inline HeapWord* bot_threshold_for_addr(const void* addr);\n@@ -203,0 +209,4 @@\n+  void update_bot_threshold() {\n+    _bot_part.set_threshold(top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -81,30 +81,0 @@\n-inline HeapWord* HeapRegion::allocate(size_t min_word_size,\n-                                      size_t desired_word_size,\n-                                      size_t* actual_size) {\n-  HeapWord* res = allocate_impl(min_word_size, desired_word_size, actual_size);\n-  if (res != NULL) {\n-    _bot_part.alloc_block(res, *actual_size);\n-  }\n-  return res;\n-}\n-\n-inline HeapWord* HeapRegion::allocate(size_t word_size) {\n-  size_t temp;\n-  return allocate(word_size, word_size, &temp);\n-}\n-\n-inline HeapWord* HeapRegion::par_allocate(size_t word_size) {\n-  size_t temp;\n-  return par_allocate(word_size, word_size, &temp);\n-}\n-\n-\/\/ Because of the requirement of keeping \"_offsets\" up to date with the\n-\/\/ allocations, we sequentialize these with a lock.  Therefore, best if\n-\/\/ this is used for larger LAB allocations only.\n-inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,\n-                                          size_t desired_word_size,\n-                                          size_t* actual_size) {\n-  MutexLocker x(&_par_alloc_lock, Mutex::_no_safepoint_check_flag);\n-  return allocate(min_word_size, desired_word_size, actual_size);\n-}\n-\n@@ -254,4 +224,3 @@\n-inline HeapWord* HeapRegion::par_allocate_no_bot_updates(size_t min_word_size,\n-                                                         size_t desired_word_size,\n-                                                         size_t* actual_word_size) {\n-  assert(is_young(), \"we can only skip BOT updates on young regions\");\n+inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,\n+                                          size_t desired_word_size,\n+                                          size_t* actual_word_size) {\n@@ -261,1 +230,1 @@\n-inline HeapWord* HeapRegion::allocate_no_bot_updates(size_t word_size) {\n+inline HeapWord* HeapRegion::allocate(size_t word_size) {\n@@ -263,1 +232,1 @@\n-  return allocate_no_bot_updates(word_size, word_size, &temp);\n+  return allocate(word_size, word_size, &temp);\n@@ -266,4 +235,3 @@\n-inline HeapWord* HeapRegion::allocate_no_bot_updates(size_t min_word_size,\n-                                                     size_t desired_word_size,\n-                                                     size_t* actual_word_size) {\n-  assert(is_young(), \"we can only skip BOT updates on young regions\");\n+inline HeapWord* HeapRegion::allocate(size_t min_word_size,\n+                                      size_t desired_word_size,\n+                                      size_t* actual_word_size) {\n@@ -273,0 +241,29 @@\n+inline HeapWord* HeapRegion::bot_threshold_for_addr(const void* addr) {\n+  HeapWord* threshold = _bot_part.threshold_for_addr(addr);\n+  assert(threshold >= addr,\n+         \"threshold must be at or after given address. \" PTR_FORMAT \" >= \" PTR_FORMAT,\n+         p2i(threshold), p2i(addr));\n+  assert(is_old(),\n+         \"Should only calculate BOT threshold for old regions. addr: \" PTR_FORMAT \" region:\" HR_FORMAT,\n+         p2i(addr), HR_FORMAT_PARAMS(this));\n+  return threshold;\n+}\n+\n+inline void HeapRegion::update_bot_crossing_threshold(HeapWord** threshold, HeapWord* obj_start, HeapWord* obj_end) {\n+  assert(is_old(), \"should only do BOT updates for old regions\");\n+  assert(is_in(obj_start), \"obj_start must be in this region: \" HR_FORMAT\n+         \" obj_start \" PTR_FORMAT \" obj_end \" PTR_FORMAT \" threshold \" PTR_FORMAT,\n+         HR_FORMAT_PARAMS(this),\n+         p2i(obj_start), p2i(obj_end), p2i(*threshold));\n+  _bot_part.alloc_block_work(threshold, obj_start, obj_end);\n+}\n+\n+inline void HeapRegion::update_bot_at(HeapWord* obj_start, size_t obj_size) {\n+  HeapWord* threshold = bot_threshold_for_addr(obj_start);\n+  HeapWord* obj_end = obj_start + obj_size;\n+\n+  if (obj_end > threshold) {\n+    update_bot_crossing_threshold(&threshold, obj_start, obj_end);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":37,"deletions":40,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  void set_buf(HeapWord* buf, size_t new_word_sz) {\n+  virtual void set_buf(HeapWord* buf, size_t new_word_sz) {\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}