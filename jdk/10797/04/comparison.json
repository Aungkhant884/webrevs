{"files":[{"patch":"@@ -229,0 +229,28 @@\n+    \/**\n+     * Get the enum constants for the given enum class symbol, if known.\n+     * They will only be found if they are defined within the same top-level\n+     * class as the class being compiled, so it's safe to assume that they\n+     * can't change at runtime due to a recompilation.\n+     *\/\n+    List<Name> enumNamesFor(ClassSymbol c) {\n+\n+        \/\/ Find the class definition and verify it is an enum class\n+        final JCClassDecl classDef = classDef(c);\n+        if (classDef == null ||\n+            (classDef.mods.flags & ENUM) == 0 ||\n+            (types.supertype(currentClass.type).tsym.flags() & ENUM) != 0) {\n+            return null;\n+        }\n+\n+        \/\/ Gather the enum identifiers\n+        ListBuffer<Name> idents = new ListBuffer<>();\n+        for (List<JCTree> defs = classDef.defs; defs.nonEmpty(); defs=defs.tail) {\n+            if (defs.head.hasTag(VARDEF) &&\n+                (((JCVariableDecl) defs.head).mods.flags & ENUM) != 0) {\n+                JCVariableDecl var = (JCVariableDecl)defs.head;\n+                idents.append(var.name);\n+            }\n+        }\n+        return idents.toList();\n+    }\n+\n@@ -429,0 +457,9 @@\n+\n+        \/\/ If enum class is part of this compilation, just switch on ordinal value\n+        if (enumClass.kind == TYP) {\n+            final List<Name> idents = enumNamesFor((ClassSymbol)enumClass);\n+            if (idents != null)\n+                return new CompileTimeEnumMapping(idents);\n+        }\n+\n+        \/\/ Map identifiers to ordinal values at runtime, and then switch on that\n@@ -431,1 +468,1 @@\n-            enumSwitchMap.put(enumClass, map = new EnumMapping(pos, enumClass));\n+            enumSwitchMap.put(enumClass, map = new RuntimeEnumMapping(pos, enumClass));\n@@ -435,2 +472,44 @@\n-    \/** This map gives a translation table to be used for enum\n-     *  switches.\n+    \/** Generates a test value and corresponding cases for a switch on an enum type.\n+     *\/\n+    interface EnumMapping {\n+\n+        \/** Given an expression for the enum value's ordinal, generate an expression for the switch statement.\n+         *\/\n+        JCExpression switchValue(JCExpression ordinalExpr);\n+\n+        \/** Generate the switch statement case value corresponding to the given enum value.\n+         *\/\n+        JCLiteral caseValue(VarSymbol v);\n+\n+        default void translate() {\n+        }\n+    }\n+\n+    \/** EnumMapping using compile-time constants. Only valid when compiling the enum class itself,\n+     *  because otherwise the ordinals we use could become obsolete if\/when the enum class is recompiled.\n+     *\/\n+    class CompileTimeEnumMapping implements EnumMapping {\n+\n+        final List<Name> enumNames;\n+\n+        CompileTimeEnumMapping(List<Name> enumNames) {\n+            Assert.check(enumNames != null);\n+            this.enumNames = enumNames;\n+        }\n+\n+        @Override\n+        public JCExpression switchValue(JCExpression ordinalExpr) {\n+            return ordinalExpr;\n+        }\n+\n+        @Override\n+        public JCLiteral caseValue(VarSymbol v) {\n+            final int ordinal = enumNames.indexOf(v.name);\n+            Assert.check(ordinal != -1);\n+            return make.Literal(ordinal);\n+        }\n+    }\n+\n+    \/** EnumMapping using run-time ordinal lookup.\n+     *\n+     *  This builds a translation table to be used for enum switches.\n@@ -468,2 +547,2 @@\n-    class EnumMapping {\n-        EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n+    class RuntimeEnumMapping implements EnumMapping {\n+        RuntimeEnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n@@ -480,1 +559,1 @@\n-            ClassSymbol outerCacheClass = outerCacheClass();\n+            ClassSymbol enumMapClass = makeEmptyClass(STATIC | SYNTHETIC, outermostClassDef.sym).sym;\n@@ -484,2 +563,2 @@\n-                                        outerCacheClass);\n-            enterSynthetic(pos, mapVar, outerCacheClass.members());\n+                                        enumMapClass);\n+            enterSynthetic(pos, mapVar, enumMapClass.members());\n@@ -502,1 +581,7 @@\n-        JCLiteral forConstant(VarSymbol v) {\n+        @Override\n+        public JCExpression switchValue(JCExpression ordinalExpr) {\n+            return make.Indexed(mapVar, ordinalExpr);\n+        }\n+\n+        @Override\n+        public JCLiteral caseValue(VarSymbol v) {\n@@ -510,1 +595,2 @@\n-        void translate() {\n+        @Override\n+        public void translate() {\n@@ -1863,17 +1949,0 @@\n-    \/** Return the symbol of a class to contain a cache of\n-     *  compiler-generated statics such as class$ and the\n-     *  $assertionsDisabled flag.  We create an anonymous nested class\n-     *  (unless one already exists) and return its symbol.  However,\n-     *  for backward compatibility in 1.4 and earlier we use the\n-     *  top-level class itself.\n-     *\/\n-    private ClassSymbol outerCacheClass() {\n-        ClassSymbol clazz = outermostClassDef.sym;\n-        Scope s = clazz.members();\n-        for (Symbol sym : s.getSymbols(NON_RECURSIVE))\n-            if (sym.kind == TYP &&\n-                sym.name == names.empty &&\n-                (sym.flags() & INTERFACE) == 0) return (ClassSymbol) sym;\n-        return makeEmptyClass(STATIC | SYNTHETIC, clazz).sym;\n-    }\n-\n@@ -3762,1 +3831,1 @@\n-            newSelector = make.Indexed(map.mapVar,\n+            newSelector = map.switchValue(\n@@ -3773,1 +3842,1 @@\n-            newSelector = make.Indexed(map.mapVar,\n+            newSelector = map.switchValue(\n@@ -3785,1 +3854,1 @@\n-                    pat = map.forConstant(label);\n+                    pat = map.caseValue(label);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":99,"deletions":30,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8219412\n+ * @summary Verify switched-on enum classes are not initialized until actual 'first use'\n+ *\/\n+\n+public class EnumExtraClassInit {\n+\n+    static boolean Ainit;\n+    static boolean Binit;\n+\n+    enum A {\n+        X;\n+        static {\n+            Ainit = true;\n+        }\n+    }\n+\n+    enum B {\n+        X;\n+        static {\n+            Binit = true;\n+        }\n+    }\n+\n+    static void testA(A x) {\n+        switch (x) {\n+        }\n+    }\n+\n+    static void testB(A x) {\n+        switch (x) {\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        testA(A.X);\n+        if (!Ainit || Binit)\n+            throw new RuntimeException(\"Ainit=\" + Ainit + \", Binit=\" + Binit);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/enum\/EnumExtraClassInit.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 7176515 8299760\n+ * @summary ExceptionInInitializerError for an enum with multiple switch statements\n+ *\/\n+\n+import java.math.RoundingMode;\n+\n+public class EnumLookupTableExceptionInInitializer {\n+\n+    public enum MyEnum {\n+        FIRST(RoundingMode.CEILING),\n+        SECOND(RoundingMode.HALF_DOWN),\n+        THIRD(RoundingMode.UNNECESSARY),\n+        FOURTH(RoundingMode.HALF_EVEN),\n+        FIFTH(RoundingMode.HALF_DOWN),\n+        SIXTH(RoundingMode.CEILING),\n+        SEVENTH(RoundingMode.UNNECESSARY);\n+\n+        private final RoundingMode mode;\n+\n+        private MyEnum(RoundingMode mode) {\n+            switch (mode) {\n+            case CEILING:\n+            case HALF_DOWN:\n+            case UNNECESSARY:\n+            case HALF_EVEN:\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+            this.mode = mode;\n+        }\n+\n+        public boolean isOdd() {\n+            switch (this) {\n+            case FIRST:\n+            case THIRD:\n+            case FIFTH:\n+            case SEVENTH:\n+                return true;\n+            default:\n+                return false;\n+            }\n+        }\n+    }\n+\n+    public enum Nested {\n+        AAA(MyEnum.FIRST),\n+        BBB(MyEnum.THIRD),\n+        CCC(MyEnum.FIFTH),\n+        DDD(MyEnum.SEVENTH),\n+        EEE(MyEnum.SECOND);\n+\n+        private Nested(MyEnum x) {\n+            switch (x) {\n+            default:\n+                break;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        boolean shouldBeOdd = true;\n+        for (MyEnum x : MyEnum.values()) {\n+            if (x.isOdd() != shouldBeOdd)\n+                throw new RuntimeException(\"failed\");\n+            shouldBeOdd = !shouldBeOdd;\n+        }\n+        Nested.class.hashCode();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/enum\/EnumLookupTableExceptionInInitializer.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}