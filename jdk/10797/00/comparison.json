{"files":[{"patch":"@@ -147,0 +147,4 @@\n+    \/** If currentClass is an enum type, an ordered list of its identifiers.\n+     *\/\n+    List<Name> currentEnumNames;\n+\n@@ -422,0 +426,2 @@\n+        if (enumClass == currentClass)\n+            return new CompileTimeEnumMapping(currentEnumNames);\n@@ -424,1 +430,1 @@\n-            enumSwitchMap.put(enumClass, map = new EnumMapping(pos, enumClass));\n+            enumSwitchMap.put(enumClass, map = new RuntimeEnumMapping(pos, enumClass));\n@@ -428,2 +434,44 @@\n-    \/** This map gives a translation table to be used for enum\n-     *  switches.\n+    \/** Generates a test value and corresponding cases for a switch on an enum type.\n+     *\/\n+    interface EnumMapping {\n+\n+        \/** Given an expression for the enum value's ordinal, generate an expression for the switch statement.\n+         *\/\n+        JCExpression switchValue(JCExpression ordinalExpr);\n+\n+        \/** Generate the switch statement case value corresponding to the given enum value.\n+         *\/\n+        JCLiteral caseValue(VarSymbol v);\n+\n+        default void translate() {\n+        }\n+    }\n+\n+    \/** EnumMapping using compile-time constants. Only valid when compiling the enum class itself,\n+     *  because otherwise the ordinals we use could become obsolete if\/when the enum class is recompiled.\n+     *\/\n+    class CompileTimeEnumMapping implements EnumMapping {\n+\n+        final List<Name> enumNames;\n+\n+        CompileTimeEnumMapping(List<Name> enumNames) {\n+            Assert.check(enumNames != null);\n+            this.enumNames = enumNames;\n+        }\n+\n+        @Override\n+        public JCExpression switchValue(JCExpression ordinalExpr) {\n+            return ordinalExpr;\n+        }\n+\n+        @Override\n+        public JCLiteral caseValue(VarSymbol v) {\n+            final int ordinal = enumNames.indexOf(v.name);\n+            Assert.check(ordinal != -1);\n+            return make.Literal(ordinal);\n+        }\n+    }\n+\n+    \/** EnumMapping using run-time ordinal lookup.\n+     *\n+     *  This builds a translation table to be used for enum switches.\n@@ -461,2 +509,2 @@\n-    class EnumMapping {\n-        EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n+    class RuntimeEnumMapping implements EnumMapping {\n+        RuntimeEnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n@@ -495,1 +543,7 @@\n-        JCLiteral forConstant(VarSymbol v) {\n+        @Override\n+        public JCExpression switchValue(JCExpression ordinalExpr) {\n+            return make.Indexed(mapVar, ordinalExpr);\n+        }\n+\n+        @Override\n+        public JCLiteral caseValue(VarSymbol v) {\n@@ -503,1 +557,2 @@\n-        void translate() {\n+        @Override\n+        public void translate() {\n@@ -2180,0 +2235,1 @@\n+        List<Name> currentEnumNamesPrev = currentEnumNames;\n@@ -2183,0 +2239,1 @@\n+        currentEnumNames = null;\n@@ -2276,0 +2333,1 @@\n+        currentEnumNames = currentEnumNamesPrev;\n@@ -2327,0 +2385,1 @@\n+        ListBuffer<Name> idents = new ListBuffer<>();\n@@ -2335,0 +2394,1 @@\n+                idents.append(var.name);\n@@ -2339,0 +2399,1 @@\n+        currentEnumNames = idents.toList();\n@@ -3742,1 +3803,1 @@\n-            newSelector = make.Indexed(map.mapVar,\n+            newSelector = map.switchValue(\n@@ -3753,1 +3814,1 @@\n-            newSelector = make.Indexed(map.mapVar,\n+            newSelector = map.switchValue(\n@@ -3765,1 +3826,1 @@\n-                    pat = map.forConstant(label);\n+                    pat = map.caseValue(label);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":71,"deletions":10,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 7176515\n+ * @summary ExceptionInInitializerError for an enum with multiple switch statements\n+ *\/\n+\n+import java.math.RoundingMode;\n+\n+public class T7176515 {\n+\n+    public enum MyEnum {\n+        FIRST(RoundingMode.CEILING),\n+        SECOND(RoundingMode.HALF_DOWN),\n+        THIRD(RoundingMode.UNNECESSARY),\n+        FOURTH(RoundingMode.HALF_EVEN),\n+        FIFTH(RoundingMode.HALF_DOWN),\n+        SIXTH(RoundingMode.CEILING),\n+        SEVENTH(RoundingMode.UNNECESSARY);\n+\n+        private final RoundingMode mode;\n+\n+        private MyEnum(RoundingMode mode) {\n+            switch (mode) {\n+            case CEILING:\n+            case HALF_DOWN:\n+            case UNNECESSARY:\n+            case HALF_EVEN:\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+            this.mode = mode;\n+        }\n+\n+        public boolean isOdd() {\n+            switch (this) {\n+            case FIRST:\n+            case THIRD:\n+            case FIFTH:\n+            case SEVENTH:\n+                return true;\n+            default:\n+                return false;\n+            }\n+        }\n+    }\n+\n+    public enum Nested {\n+        AAA(MyEnum.FIRST),\n+        BBB(MyEnum.THIRD),\n+        CCC(MyEnum.FIFTH),\n+        DDD(MyEnum.SEVENTH),\n+        EEE(MyEnum.SECOND);\n+\n+        private Nested(MyEnum x) {\n+\/\/ Bug still occurs if this is uncommented\n+\/\/            switch (x) {\n+\/\/            default:\n+\/\/                break;\n+\/\/            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        boolean shouldBeOdd = true;\n+        for (MyEnum x : MyEnum.values()) {\n+            assert x.isOdd() == shouldBeOdd;\n+            shouldBeOdd = !shouldBeOdd;\n+        }\n+        Nested.class.hashCode();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/enum\/T7176515.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}