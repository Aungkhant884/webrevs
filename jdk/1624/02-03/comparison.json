{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/threadLocalAllocBuffer.inline.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"runtime\/handles.hpp\"\n@@ -35,1 +35,17 @@\n-static void send_allocation_sample(Klass* klass, HeapWord* obj, size_t weight, Thread* thread) {\n+static THREAD_LOCAL int64_t _last_allocated_bytes = 0;\n+\n+inline void send_allocation_sample(const Klass* klass, int64_t allocated_bytes) {\n+  assert(allocated_bytes > 0, \"invariant\");\n+  EventObjectAllocationSample event;\n+  if (event.should_commit()) {\n+    const size_t weight = allocated_bytes - _last_allocated_bytes;\n+    assert(weight > 0, \"invariant\");\n+    event.set_objectClass(klass);\n+    event.set_weight(weight);\n+    event.commit();\n+    _last_allocated_bytes = allocated_bytes;\n+  }\n+}\n+\n+inline bool send_allocation_sample_with_result(const Klass* klass, int64_t allocated_bytes) {\n+  assert(allocated_bytes > 0, \"invariant\");\n@@ -38,0 +54,2 @@\n+    const size_t weight = allocated_bytes - _last_allocated_bytes;\n+    assert(weight > 0, \"invariant\");\n@@ -41,0 +59,2 @@\n+    _last_allocated_bytes = allocated_bytes;\n+    return true;\n@@ -42,0 +62,43 @@\n+  return false;\n+}\n+\n+inline intptr_t estimate_tlab_size_bytes(Thread* thread) {\n+  assert(thread != NULL, \"invariant\");\n+  const size_t desired_tlab_size_bytes = thread->tlab().desired_size() * HeapWordSize;\n+  const size_t alignment_reserve_bytes = thread->tlab().alignment_reserve_in_bytes();\n+  assert(desired_tlab_size_bytes > alignment_reserve_bytes, \"invariant\");\n+  return static_cast<intptr_t>(desired_tlab_size_bytes - alignment_reserve_bytes);\n+}\n+\n+inline int64_t load_allocated_bytes(Thread* thread) {\n+  const int64_t allocated_bytes = thread->allocated_bytes();\n+  if (allocated_bytes < _last_allocated_bytes) {\n+    \/\/ A hw thread can detach and reattach to the VM, and when it does,\n+    \/\/ it gets a new JavaThread representation. The thread local variable\n+    \/\/ tracking _last_allocated_bytes is mapped to the existing hw thread,\n+    \/\/ so it needs to be reset.\n+    _last_allocated_bytes = 0;\n+  }\n+  return allocated_bytes == _last_allocated_bytes ? 0 : allocated_bytes;\n+}\n+\n+\/\/ To avoid large objects from being undersampled compared to the regular TLAB samples,\n+\/\/ the data amount is normalized as if it was a TLAB, giving a number of TLAB sampling attempts to the large object.\n+static void normalize_as_tlab_and_send_allocation_samples(Klass* klass, intptr_t obj_alloc_size_bytes, Thread* thread) {\n+  const int64_t allocated_bytes = load_allocated_bytes(thread);\n+  assert(allocated_bytes > 0, \"invariant\"); \/\/ obj_alloc_size_bytes is already attributed to allocated_bytes at this point.\n+  if (!UseTLAB) {\n+    send_allocation_sample(klass, allocated_bytes);\n+    return;\n+  }\n+  const intptr_t tlab_size_bytes = estimate_tlab_size_bytes(thread);\n+  if (allocated_bytes - _last_allocated_bytes < tlab_size_bytes) {\n+    return;\n+  }\n+  assert(obj_alloc_size_bytes > 0, \"invariant\");\n+  do {\n+    if (send_allocation_sample_with_result(klass, allocated_bytes)) {\n+      return;\n+    }\n+    obj_alloc_size_bytes -= tlab_size_bytes;\n+  } while (obj_alloc_size_bytes > 0);\n@@ -52,1 +115,1 @@\n-  send_allocation_sample(klass, obj, alloc_size, thread);\n+  normalize_as_tlab_and_send_allocation_samples(klass, static_cast<intptr_t>(alloc_size), thread);\n@@ -64,1 +127,5 @@\n-  send_allocation_sample(klass, obj, tlab_size, thread);\n+  const int64_t allocated_bytes = load_allocated_bytes(thread);\n+  if (allocated_bytes == 0) {\n+    return;\n+  }\n+  send_allocation_sample(klass, allocated_bytes);\n","filename":"src\/hotspot\/share\/gc\/shared\/allocTracer.cpp","additions":71,"deletions":4,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  JfrEventThrottler::for_event(static_cast<JfrEventId>(event_type_id))->configure(event_sample_size, period_ms);\n+  JfrEventThrottler::configure(static_cast<JfrEventId>(event_type_id), event_sample_size, period_ms);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -617,2 +617,1 @@\n-  <Event name=\"ObjectAllocationSample\" category=\"Java Application\" label=\"Allocation sample\" description=\"Allocation sample\"\n-    thread=\"true\" stackTrace=\"true\" startTime=\"false\" throttle=\"true\">\n+  <Event name=\"ObjectAllocationSample\" category=\"Java Application\" label=\"Object Allocation Sample\" thread=\"true\" stackTrace=\"true\" startTime=\"false\" throttle=\"true\">\n@@ -620,1 +619,2 @@\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"weight\" label=\"Sample Weight\" description=\"An attribute to facilitate the relative comparison of samples, not necesarily the memory amount allocated by the sampled object\" \/>\n+    <Field type=\"long\" contentType=\"bytes\" name=\"weight\" label=\"Sample Weight\"\n+      description=\"The relative weight of the sample. Aggregating the weights for a large number of samples, for a particular class, thread or stack trace, gives a statistically accurate representation of the allocation pressure\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+static JfrEventThrottler* _throttler = NULL;\n+\n@@ -48,0 +50,27 @@\n+bool JfrEventThrottler::create() {\n+  assert(_throttler == NULL, \"invariant\");\n+  _throttler = new JfrEventThrottler(JfrObjectAllocationSampleEvent);\n+  return _throttler != NULL && _throttler->initialize();\n+}\n+\n+void JfrEventThrottler::destroy() {\n+  delete _throttler;\n+  _throttler = NULL;\n+}\n+\n+\/\/ There is currently only one throttler instance, for the jdk.ObjectAllocationSample event.\n+\/\/ When introducing additional throttlers, also add a lookup map keyed by event id.\n+JfrEventThrottler* JfrEventThrottler::for_event(JfrEventId event_id) {\n+  assert(_throttler != NULL, \"JfrEventThrottler has not been properly initialized\");\n+  assert(event_id == JfrObjectAllocationSampleEvent, \"Event type has an unconfigured throttler\");\n+  return event_id == JfrObjectAllocationSampleEvent ? _throttler : NULL;\n+}\n+\n+void JfrEventThrottler::configure(JfrEventId event_id, int64_t sample_size, int64_t period_ms) {\n+  if (event_id != JfrObjectAllocationSampleEvent) {\n+    return;\n+  }\n+  assert(_throttler != NULL, \"JfrEventThrottler has not been properly initialized\");\n+  _throttler->configure(sample_size, period_ms);\n+}\n+\n@@ -64,21 +93,0 @@\n-\/\/ There is currently only one throttler instance, for the jdk.ObjectAllocationSample event.\n-\/\/ When introducing additional throttlers, also add a lookup map keyed by event id.\n-static JfrEventThrottler* _throttler = NULL;\n-\n-bool JfrEventThrottler::create() {\n-  assert(_throttler == NULL, \"invariant\");\n-  _throttler = new JfrEventThrottler(JfrObjectAllocationSampleEvent);\n-  return _throttler != NULL && _throttler->initialize();\n-}\n-\n-void JfrEventThrottler::destroy() {\n-  delete _throttler;\n-  _throttler = NULL;\n-}\n-\n-JfrEventThrottler* JfrEventThrottler::for_event(JfrEventId event_id) {\n-  assert(_throttler != NULL, \"JfrEventThrottler has not been properly initialized\");\n-  assert(event_id == JfrObjectAllocationSampleEvent, \"need more throttlers?\");\n-  return _throttler;\n-}\n-\n@@ -86,1 +94,1 @@\n-bool JfrEventThrottler::accept(JfrEventId event_id, int64_t timestamp) {\n+bool JfrEventThrottler::accept(JfrEventId event_id, int64_t timestamp \/* 0 *\/) {\n@@ -88,2 +96,2 @@\n-  assert(throttler != NULL, \"invariant\");\n-  return throttler->_disabled ? true : throttler->sample(timestamp);\n+  if (throttler == NULL) return true;\n+  return _throttler->_disabled ? true : _throttler->sample(timestamp);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  JfrEventThrottler(JfrEventId event_id);\n+  void configure(int64_t event_sample_size, int64_t period_ms);\n@@ -48,0 +50,1 @@\n+  static JfrEventThrottler* for_event(JfrEventId event_id);\n@@ -50,4 +53,2 @@\n-  JfrEventThrottler(JfrEventId event_id);\n-  void configure(int64_t event_sample_size, int64_t period_ms);\n-  static JfrEventThrottler* for_event(JfrEventId event_id);\n-  static bool accept(JfrEventId event_id, int64_t timestamp);\n+  static void configure(JfrEventId event_id, int64_t event_sample_size, int64_t period_ms);\n+  static bool accept(JfrEventId event_id, int64_t timestamp = 0);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -209,3 +209,27 @@\n-    private static void throwThrottleNumberFormatException(String s) {\n-        throw new NumberFormatException(\"'\" + s + \"' is not valid. Should be a non-negative numeric value followed by a delimiter. i.e. \/ or \\\\, and then followed by a unit e.g. 20 ms.\");\n-    }\n+    enum ThrottleUnit {\n+        NANOSECONDS(\"ns\", TimeUnit.NANOSECONDS, TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toMillis(1)),\n+        MICROSECONDS(\"us\", TimeUnit.MICROSECONDS, TimeUnit.SECONDS.toNanos(1) \/ 1000, TimeUnit.SECONDS.toMillis(1)),\n+        MILLISECONDS(\"ms\", TimeUnit.MILLISECONDS, TimeUnit.SECONDS.toMillis(1), TimeUnit.SECONDS.toMillis(1)),\n+        SECONDS(\"s\", TimeUnit.SECONDS, 1, TimeUnit.SECONDS.toMillis(1)),\n+        MINUTES(\"m\", TimeUnit.MINUTES, 1, TimeUnit.MINUTES.toMillis(1)),\n+        HOUR(\"h\", TimeUnit.HOURS, 1, TimeUnit.HOURS.toMillis(1)),\n+        DAY(\"d\", TimeUnit.DAYS, 1, TimeUnit.DAYS.toMillis(1));\n+\n+        private final String text;\n+        private final TimeUnit timeUnit;\n+        private final long factor;\n+        private final long millis;\n+\n+        ThrottleUnit(String t, TimeUnit u, long factor, long millis) {\n+            this.text = t;\n+            this.timeUnit = u;\n+            this.factor = factor;\n+            this.millis = millis;\n+        }\n+\n+        private static ThrottleUnit parse(String s) {\n+            if (s.equals(OFF)) {\n+                return MILLISECONDS;\n+            }\n+            return unit(parseThrottleString(s, false));\n+        }\n@@ -213,3 +237,8 @@\n-    public static long parseThrottleValue(String s) {\n-        if (s.equals(OFF)) {\n-            return THROTTLE_OFF;\n+        private static ThrottleUnit unit(String s) {\n+            if (s.endsWith(\"ns\") || s.endsWith(\"us\") || s.endsWith(\"ms\")) {\n+                return value(s.substring(s.length() - 2));\n+            }\n+            if (s.endsWith(\"s\") || s.endsWith(\"m\") || s.endsWith(\"h\") || s.endsWith(\"d\")) {\n+                return value(s.substring(s.length() - 1));\n+            }\n+            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n@@ -217,6 +246,8 @@\n-        String parsedValue = parseThrottleString(s, true);\n-        long value = 0;\n-        try {\n-            value = Long.parseLong(parsedValue);\n-        } catch (NumberFormatException nfe) {\n-            throwThrottleNumberFormatException(s);\n+\n+        private static ThrottleUnit value(String s) {\n+            for (ThrottleUnit t : values()) {\n+                if (t.text.equals(s)) {\n+                    return t;\n+                }\n+            }\n+            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n@@ -224,2 +255,0 @@\n-        return value * throttleTimeFactor(parseThrottleTimeUnit(s));\n-    }\n@@ -227,6 +256,2 @@\n-    \/\/ Expected input format is \"x\/y\" or \"x\\y\" where x is a non-negative long\n-    \/\/ and y is a time unit. Split the string at the delimiter.\n-    private static String parseThrottleString(String s, boolean value) {\n-        String[] split = s.split(\"[\\\\\/\\\\\\\\]\");\n-        if (split.length != 2) {\n-            throwThrottleNumberFormatException(s);\n+        static long asMillis(String s) {\n+            return parse(s).millis;\n@@ -234,2 +259,0 @@\n-        return value ? split[0].trim() : split[1].trim();\n-    }\n@@ -237,3 +260,2 @@\n-    private static TimeUnit parseThrottleTimeUnit(String s) {\n-        if (s.equals(OFF)) {\n-            return TimeUnit.MILLISECONDS;\n+        static long normalizeValueAsMillis(long value, String s) {\n+            return value * parse(s).factor;\n@@ -241,2 +263,0 @@\n-        String parsedTimeUnit = parseThrottleString(s, false);\n-        return timeUnit(parsedTimeUnit);\n@@ -245,2 +265,2 @@\n-    public static long parseThrottleTimeUnitToMillis(String s) {\n-        return throttleMillis(parseThrottleTimeUnit(s));\n+    private static void throwThrottleNumberFormatException(String s) {\n+        throw new NumberFormatException(\"'\" + s + \"' is not valid. Should be a non-negative numeric value followed by a delimiter. i.e. '\/', and then followed by a unit e.g. 100\/s.\");\n@@ -249,21 +269,6 @@\n-    private static TimeUnit timeUnit(String unit) {\n-        if (unit.endsWith(\"ns\")) {\n-            return TimeUnit.NANOSECONDS;\n-        }\n-        if (unit.endsWith(\"us\")) {\n-            return TimeUnit.MICROSECONDS;\n-        }\n-        if (unit.endsWith(\"ms\")) {\n-            return TimeUnit.MILLISECONDS;\n-        }\n-        if (unit.endsWith(\"s\")) {\n-            return TimeUnit.SECONDS;\n-        }\n-        if (unit.endsWith(\"m\")) {\n-            return TimeUnit.MINUTES;\n-        }\n-        if (unit.endsWith(\"h\")) {\n-            return TimeUnit.HOURS;\n-        }\n-        if (unit.endsWith(\"d\")) {\n-            return TimeUnit.DAYS;\n+    \/\/ Expected input format is \"x\/y\" where x is a non-negative long\n+    \/\/ and y is a time unit. Split the string at the delimiter.\n+    private static String parseThrottleString(String s, boolean value) {\n+        String[] split = s.split(\"[\\\\\/]\");\n+        if (split.length != 2) {\n+            throwThrottleNumberFormatException(s);\n@@ -271,1 +276,1 @@\n-        throw new NumberFormatException(\"'\" + unit + \"' is not a valid time unit.\");\n+        return value ? split[0].trim() : split[1].trim();\n@@ -274,1 +279,1 @@\n-    public static double parseAndNormalizeThrottleValue(String s) {\n+    public static long parseThrottleValue(String s) {\n@@ -278,2 +283,2 @@\n-        long value = 0;\n-        TimeUnit unit = TimeUnit.MILLISECONDS;\n+        String parsedValue = parseThrottleString(s, true);\n+        long normalizedValue = 0;\n@@ -281,2 +286,1 @@\n-            value = parseThrottleValue(s);\n-            unit = parseThrottleTimeUnit(s);\n+            normalizedValue = ThrottleUnit.normalizeValueAsMillis(Long.parseLong(parsedValue), s);\n@@ -286,25 +290,1 @@\n-        return normalizeThrottleValue(value * throttleTimeFactor(unit), throttleMillis(unit));\n-    }\n-\n-    private static long throttleMillis(TimeUnit unit) {\n-        switch (unit) {\n-            case NANOSECONDS:\n-            case MICROSECONDS:\n-            case MILLISECONDS:\n-                return SECONDS.toMillis(1);\n-            default:\n-                return unit.toMillis(1);\n-        }\n-    }\n-\n-    private static long throttleTimeFactor(TimeUnit unit) {\n-        switch (unit) {\n-            case NANOSECONDS :\n-                return SECONDS.toNanos(1);\n-            case MICROSECONDS:\n-                return SECONDS.toNanos(1) \/ 1000;\n-            case MILLISECONDS:\n-                return SECONDS.toMillis(1);\n-            default:\n-                return 1;\n-        }\n+        return normalizedValue;\n@@ -313,2 +293,2 @@\n-    private static double normalizeThrottleValue(long value, long millis) {\n-        return value == THROTTLE_OFF ? THROTTLE_OFF : (double) value \/ (double) millis;\n+    public static long parseThrottleTimeUnit(String s) {\n+        return ThrottleUnit.asMillis(s);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":63,"deletions":83,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        double max = OFF;\n+        long max = OFF;\n@@ -68,1 +68,1 @@\n-            double l = parseAndNormalizeValueSafe(value);\n+            long l = parseValueSafe(value);\n@@ -77,2 +77,2 @@\n-    private static double parseAndNormalizeValueSafe(String s) {\n-        double value = 0.0;\n+    private static long parseValueSafe(String s) {\n+        long value = 0L;\n@@ -80,1 +80,1 @@\n-            value = Utils.parseAndNormalizeThrottleValue(s);\n+            value = Utils.parseThrottleValue(s);\n@@ -88,1 +88,0 @@\n-        this.value = s;\n@@ -93,1 +92,2 @@\n-            millis = Utils.parseThrottleTimeUnitToMillis(s);\n+            millis = Utils.parseThrottleTimeUnit(s);\n+            this.value = s;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleSetting.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-all\">false<\/setting>\n+      <setting name=\"enabled\" control=\"heap-statistics-enabled\">false<\/setting>\n@@ -446,1 +446,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">false<\/setting>\n+      <setting name=\"enabled\" control=\"promotion-enabled\">false<\/setting>\n@@ -450,1 +450,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">false<\/setting>\n+      <setting name=\"enabled\" control=\"promotion-enabled\">false<\/setting>\n@@ -608,1 +608,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">false<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -613,1 +613,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">false<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -618,1 +618,2 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\" control=\"enable-object-allocation\">true<\/setting>\n+      <setting name=\"throttle\" control=\"object-allocation-rate\">150\/s<\/setting>\n@@ -620,1 +621,0 @@\n-      <setting name=\"throttle\">150\/s<\/setting>\n@@ -835,1 +835,1 @@\n-      <selection name=\"memory-profiling\" default=\"off\" label=\"Memory Profiling\">\n+      <selection name=\"memory-profiling\" default=\"low\" label=\"Memory Profiling\">\n@@ -837,0 +837,1 @@\n+        <option label=\"Object Allocation\" name=\"low\">low<\/option>\n@@ -841,1 +842,5 @@\n-      <condition name=\"memory-profiling-enabled-medium\" true=\"true\" false=\"false\">\n+     <condition name=\"memory-profiling-enabled-low\" true=\"true\" false=\"false\">\n+        <test name=\"memory-profiling\" operator=\"equal\" value=\"low\"\/>\n+      <\/condition>\n+\n+      <condition name=\"object-allocation-enabled\" true=\"true\" false=\"false\">\n@@ -843,0 +848,1 @@\n+          <test name=\"memory-profiling\" operator=\"equal\" value=\"low\"\/>\n@@ -848,2 +854,16 @@\n-      <condition name=\"memory-profiling-enabled-all\" true=\"true\" false=\"false\">\n-        <test name=\"memory-profiling\" operator=\"equal\" value=\"all\"\/>\n+      <condition name=\"object-allocation-rate\" true=\"300\/s\" false=\"150\/s\">\n+         <or>\n+           <test name=\"memory-profiling\" operator=\"equal\" value=\"medium\"\/>\n+           <test name=\"memory-profiling\" operator=\"equal\" value=\"all\"\/>\n+         <\/or>\n+       <\/condition>\n+\n+      <condition name=\"promotion-enabled\" true=\"true\" false=\"false\">\n+        <or>\n+          <test name=\"memory-profiling\" operator=\"equal\" value=\"medium\"\/>\n+          <test name=\"memory-profiling\" operator=\"equal\" value=\"all\"\/>\n+        <\/or>\n+      <\/condition>\n+\n+      <condition name=\"heap-statistics-enabled\" true=\"true\" false=\"false\">\n+          <test name=\"memory-profiling\" operator=\"equal\" value=\"all\"\/>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-all\">false<\/setting>\n+      <setting name=\"enabled\" control=\"heap-statistics-enabled\">false<\/setting>\n@@ -446,1 +446,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">true<\/setting>\n+      <setting name=\"enabled\" control=\"promotion-enabled\">true<\/setting>\n@@ -450,1 +450,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">true<\/setting>\n+      <setting name=\"enabled\" control=\"promotion-enabled\">true<\/setting>\n@@ -608,1 +608,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">false<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -613,1 +613,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">false<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -618,1 +618,2 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\" control=\"enable-object-allocation\">true<\/setting>\n+      <setting name=\"throttle\" control=\"object-allocation-rate\">300\/s<\/setting>\n@@ -620,1 +621,0 @@\n-      <setting name=\"throttle\">300\/s<\/setting>\n@@ -835,1 +835,1 @@\n-      <selection name=\"memory-profiling\" default=\"medium\" label=\"Memory Profiling\">\n+      <selection name=\"memory-profiling\" default=\"low\" label=\"Memory Profiling\">\n@@ -837,0 +837,1 @@\n+        <option label=\"Object Allocation\" name=\"low\">low<\/option>\n@@ -841,1 +842,5 @@\n-      <condition name=\"memory-profiling-enabled-medium\" true=\"true\" false=\"false\">\n+     <condition name=\"memory-profiling-enabled-low\" true=\"true\" false=\"false\">\n+        <test name=\"memory-profiling\" operator=\"equal\" value=\"low\"\/>\n+      <\/condition>\n+\n+      <condition name=\"object-allocation-enabled\" true=\"true\" false=\"false\">\n@@ -843,0 +848,1 @@\n+          <test name=\"memory-profiling\" operator=\"equal\" value=\"low\"\/>\n@@ -848,2 +854,12 @@\n-      <condition name=\"memory-profiling-enabled-all\" true=\"true\" false=\"false\">\n-        <test name=\"memory-profiling\" operator=\"equal\" value=\"all\"\/>\n+      <condition name=\"object-allocation-rate\" true=\"300\/s\" false=\"150\/s\">\n+         <or>\n+           <test name=\"memory-profiling\" operator=\"equal\" value=\"medium\"\/>\n+           <test name=\"memory-profiling\" operator=\"equal\" value=\"all\"\/>\n+         <\/or>\n+       <\/condition>\n+\n+      <condition name=\"promotion-enabled\" true=\"true\" false=\"false\">\n+        <or>\n+          <test name=\"memory-profiling\" operator=\"equal\" value=\"medium\"\/>\n+          <test name=\"memory-profiling\" operator=\"equal\" value=\"all\"\/>\n+        <\/or>\n@@ -852,0 +868,3 @@\n+      <condition name=\"heap-statistics-enabled\" true=\"true\" false=\"false\">\n+          <test name=\"memory-profiling\" operator=\"equal\" value=\"all\"\/>\n+      <\/condition>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -75,2 +75,1 @@\n-            long weight = Events.assertField(event, \"weight\").atLeast(1L).getValue();\n-            Asserts.assertGreaterThanOrEqual(weight, (long)OBJECT_SIZE);\n+            Events.assertField(event, \"weight\").atLeast(1L);\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEvent.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.allocation;\n-\n-import static java.lang.Math.floor;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-import jdk.test.lib.Asserts;\n-\n-\/**\n- * @test\n- * @summary Test that an allocation sample event is triggered when an allocation takes the new TLAB path.\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 jdk.jfr.event.allocation.TestObjectAllocationSampleEventNewTLABPath\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 -Xint jdk.jfr.event.allocation.TestObjectAllocationSampleEventNewTLABPath\n- *\/\n-\n-\/**\n- * Test that an allocation sample event is triggered when an allocation takes the new TLAB path.\n- * The test is done for default and interpreted mode (-Xint).\n- *\n- * To force objects to be allocated using the TLAB path:\n- *      the size of TLAB is set to 100k (-XX:TLABSize=100k);\n- *      the size of allocated objects is set to 100k minus 16 bytes overhead;\n- *      max TLAB waste at refill is set to minimum (-XX:TLABRefillWasteFraction=1),\n- *          to provoke a new TLAB creation.\n- *\/\n-public class TestObjectAllocationSampleEventNewTLABPath {\n-    private final static String EVENT_NAME = EventNames.ObjectAllocationSample;\n-\n-    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n-    private static final int OBJECT_SIZE = 100 * 1024;\n-    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n-    private static final int OBJECTS_TO_ALLOCATE = 100;\n-    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n-    private static int eventCount;\n-\n-    \/\/ Make sure allocation isn't dead code eliminated.\n-    public static byte[] tmp;\n-\n-    public static void main(String[] args) throws Exception {\n-        Recording recording = new Recording();\n-        recording.enable(EVENT_NAME);\n-        recording.start();\n-        System.gc();\n-        allocate();\n-        recording.stop();\n-        verifyRecording(recording);\n-        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n-        Asserts.assertGreaterThanOrEqual(eventCount, minCount, \"Too few object samples allocated\");\n-    }\n-\n-    private static void allocate() {\n-        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n-            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n-        }\n-    }\n-\n-    private static void verifyRecording(Recording recording) throws Exception {\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n-            verify(event);\n-        }\n-    }\n-\n-    private static void verify(RecordedEvent event) {\n-        if (Thread.currentThread().getId() != event.getThread().getJavaThreadId()) {\n-            return;\n-        }\n-        if (Events.assertField(event, \"objectClass.name\").notEmpty().getValue().equals(BYTE_ARRAY_CLASS_NAME)) {\n-            Events.assertField(event, \"weight\").atLeast(1L);\n-            ++eventCount;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEventNewTLABPath.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.allocation;\n-\n-import static java.lang.Math.floor;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-import jdk.test.lib.Asserts;\n-\n-\/**\n- * @test\n- * @summary Test that an allocation sample event is triggered when an allocation takes the direct path, i.e. outside of a TLAB.\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 jdk.jfr.event.allocation.TestObjectAllocationSampleEventOutsideTLABPath\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 -Xint jdk.jfr.event.allocation.TestObjectAllocationSampleEventOutsideTLABPath\n- *\/\n-\n-\/**\n- * Test that an allocation sample event is triggered when an allocation takes a direct path, i.e. outside of a TLAB.\n- * The test is done for default and interpreted mode (-Xint).\n- *\n- * To force objects to be allocated outside TLAB:\n- *      the size of TLAB is set to 90k (-XX:TLABSize=90k);\n- *      the size of allocated objects is set to 100k.\n- *      max TLAB waste at refill is set to 256 (-XX:TLABRefillWasteFraction=256),\n- *          to prevent a new TLAB creation.\n-*\/\n-public class TestObjectAllocationSampleEventOutsideTLABPath {\n-    private final static String EVENT_NAME = EventNames.ObjectAllocationSample;\n-\n-    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n-    private static final int OBJECT_SIZE = 100 * 1024;\n-    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n-    private static final int OBJECTS_TO_ALLOCATE = 100;\n-    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n-    private static int eventCount;\n-\n-    \/\/ Make sure allocation isn't dead code eliminated.\n-    public static byte[] tmp;\n-\n-    public static void main(String[] args) throws Exception {\n-        Recording recording = new Recording();\n-        recording.enable(EVENT_NAME);\n-        recording.start();\n-        System.gc();\n-        allocate();\n-        recording.stop();\n-        verifyRecording(recording);\n-        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n-        Asserts.assertGreaterThanOrEqual(eventCount, minCount, \"Too few object samples allocated\");\n-    }\n-\n-    private static void allocate() {\n-        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n-            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n-        }\n-    }\n-\n-    private static void verifyRecording(Recording recording) throws Exception {\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n-            verify(event);\n-        }\n-    }\n-\n-    private static void verify(RecordedEvent event) {\n-        if (Thread.currentThread().getId() != event.getThread().getJavaThreadId()) {\n-            return;\n-        }\n-        if (Events.assertField(event, \"objectClass.name\").notEmpty().getValue().equals(BYTE_ARRAY_CLASS_NAME)) {\n-            Events.assertField(event, \"weight\").atLeast(1L);\n-            ++eventCount;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEventOutsideTLABPath.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -116,2 +116,1 @@\n-            long weight = Events.assertField(event, \"weight\").atLeast(1L).getValue();\n-            Asserts.assertGreaterThanOrEqual(weight, (long)OBJECT_SIZE);\n+            Events.assertField(event, \"weight\").atLeast(1L);\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEventThrottling.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}