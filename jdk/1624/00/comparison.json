{"files":[{"patch":"@@ -175,0 +175,1 @@\n+        boolean throttle;\n@@ -197,0 +198,1 @@\n+            pos.writeBoolean(throttle);\n@@ -493,0 +495,1 @@\n+                currentType.throttle = getBoolean(attributes, \"throttle\", false);\n@@ -762,0 +765,1 @@\n+            out.write(\"  bool is_started() const { return false; }\");\n@@ -823,0 +827,1 @@\n+            out.write(\"  static const bool hasThrottle = \" + event.throttle + \";\");\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,25 @@\n+\/*\n+ * Allocation events are throttled so not each event will get written to JFR.\n+ * _skipped_allocations and _skipped_events are maintained for tracking\n+ * information about discarded allocation events, and are included in an event\n+ * that is accepted.\n+ *\/\n+static THREAD_LOCAL size_t _skipped_allocations = 0;\n+static THREAD_LOCAL size_t _skipped_events = 0;\n+\n+static void send_allocation_sample(Klass* klass, HeapWord* obj, size_t obj_alloc_size, size_t memory_alloc_size, Thread* thread) {\n+  EventObjectAllocationSample event;\n+  if (event.should_commit()) {\n+    event.set_objectClass(klass);\n+    event.set_allocationSize(obj_alloc_size);\n+    event.set_allocatedSinceLast(_skipped_allocations + memory_alloc_size);\n+    event.set_skippedEvents(_skipped_events);\n+    event.commit();\n+    _skipped_allocations = 0;\n+    _skipped_events = 0;\n+  } else {\n+    _skipped_events++;\n+    _skipped_allocations += memory_alloc_size;\n+  }\n+}\n+\n@@ -43,0 +68,1 @@\n+  send_allocation_sample(klass, obj, alloc_size, alloc_size, thread);\n@@ -54,0 +80,1 @@\n+  send_allocation_sample(klass, obj, alloc_size, tlab_size, thread);\n","filename":"src\/hotspot\/share\/gc\/shared\/allocTracer.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"jfr\/recorder\/service\/jfrEventThrottler.hpp\"\n@@ -178,0 +179,5 @@\n+NO_TRANSITION(jboolean, jfr_set_throttle(JNIEnv* env, jobject jvm, jlong event_type_id, jlong event_sample_size, jlong period_ms))\n+  JfrEventThrottler::for_event(static_cast<JfrEventId>(event_type_id))->configure(event_sample_size, period_ms);\n+  return JNI_TRUE;\n+NO_TRANSITION_END\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+jboolean JNICALL jfr_set_throttle(JNIEnv* env, jobject jvm, jlong event_type_id, jlong event_sample_size, jlong period_ms);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+      (char*)\"setThrottle\", (char*)\"(JJJ)Z\", (void*)jfr_set_throttle,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  if (!tryLock.has_lock()) {\n+  if (!tryLock.acquired()) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -617,0 +617,8 @@\n+  <Event name=\"ObjectAllocationSample\" category=\"Java Application\" label=\"Allocation sample\" description=\"Allocation sample\"\n+    thread=\"true\" stackTrace=\"true\" startTime=\"false\" throttle=\"true\">\n+    <Field type=\"Class\" name=\"objectClass\" label=\"Object Class\" description=\"Class of allocated object\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"allocationSize\" label=\"Allocation Size\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"allocatedSinceLast\" label=\"Allocated since last sample\"\/>\n+    <Field type=\"ulong\" name=\"skippedEvents\" label=\"Number of events skipped since last sample\"\/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+              <xs:attribute name=\"throttle\" type=\"xs:boolean\" use=\"optional\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xsd","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"jfr\/recorder\/service\/jfrEventThrottler.hpp\"\n@@ -292,0 +293,3 @@\n+  if (!create_event_throttler()) {\n+    return false;\n+  }\n@@ -365,0 +369,4 @@\n+bool JfrRecorder::create_event_throttler() {\n+  return JfrEventThrottler::create();\n+}\n+\n@@ -399,0 +407,1 @@\n+  JfrEventThrottler::destroy();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  static bool create_event_throttler();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"jfr\/recorder\/service\/jfrEventThrottler.hpp\"\n@@ -66,0 +67,3 @@\n+  bool _untimed;\n+  bool _should_commit;\n+  bool _evaluated;\n@@ -68,1 +72,3 @@\n-  JfrEvent(EventStartTime timing=TIMED) : _start_time(0), _end_time(0), _started(false)\n+  JfrEvent(EventStartTime timing=TIMED) : _start_time(0), _end_time(0),\n+                                          _started(false), _untimed(timing == UNTIMED),\n+                                          _should_commit(false), _evaluated(false)\n@@ -82,3 +88,0 @@\n-    if (!should_commit()) {\n-      return;\n-    }\n@@ -86,8 +89,2 @@\n-    if (_start_time == 0) {\n-      set_starttime(JfrTicks::now());\n-    } else if (_end_time == 0) {\n-      set_endtime(JfrTicks::now());\n-    }\n-    if (should_write()) {\n-      write_event();\n-      DEBUG_ONLY(_verifier.set_committed();)\n+    if (!should_write()) {\n+      return;\n@@ -95,0 +92,2 @@\n+    write_event();\n+    DEBUG_ONLY(_verifier.set_committed();)\n@@ -150,1 +149,1 @@\n-  bool should_commit() {\n+  bool is_started() const {\n@@ -154,0 +153,15 @@\n+  bool should_commit() {\n+    if (!_started) {\n+      return false;\n+    }\n+    if (_untimed) {\n+      return true;\n+    }\n+    if (_evaluated) {\n+      return _should_commit;\n+    }\n+    _should_commit = evaluate();\n+    _evaluated = true;\n+    return _should_commit;\n+  }\n+\n@@ -156,2 +170,15 @@\n-    if (T::isInstant || T::isRequestable || T::hasCutoff) {\n-      return true;\n+    return _started && (_evaluated ? _should_commit : evaluate());\n+  }\n+\n+  bool evaluate() {\n+    assert(_started, \"invariant\");\n+    if (_start_time == 0) {\n+      set_starttime(JfrTicks::now());\n+    } else if (_end_time == 0) {\n+      set_endtime(JfrTicks::now());\n+    }\n+    if (T::isInstant || T::isRequestable) {\n+      return T::hasThrottle ? JfrEventThrottler::accept(T::eventId, _untimed ? 0 : _start_time) : true;\n+    }\n+    if (_end_time - _start_time < JfrEventSetting::threshold(T::eventId)) {\n+      return false;\n@@ -159,1 +186,1 @@\n-    return (_end_time - _start_time) >= JfrEventSetting::threshold(T::eventId);\n+    return T::hasThrottle ? JfrEventThrottler::accept(T::eventId, _untimed ? 0 : _end_time) : true;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEvent.hpp","additions":44,"deletions":17,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/recorder\/service\/jfrEventThrottler.hpp\"\n+#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+constexpr static const JfrSamplerParams _disabled_params = {\n+                                                             0, \/\/ sample points per window\n+                                                             0, \/\/ window duration ms\n+                                                             0, \/\/ window lookback count\n+                                                             false \/\/ reconfigure\n+                                                           };\n+\n+JfrEventThrottler::JfrEventThrottler(JfrEventId event_id) :\n+  JfrAdaptiveSampler(),\n+  _last_params(),\n+  _sample_size(0),\n+  _period_ms(0),\n+  _sample_size_ewma(0),\n+  _event_id(event_id),\n+  _disabled(false),\n+  _update(false) {}\n+\n+\/*\n+ * The event throttler currently only supports a single configuration option, a rate, but more may be added in the future:\n+ *\n+ * We configure to throttle dynamically, to maintain a continuous, maximal event emission rate per time period.\n+ *\n+ * - sample_size size of the event sample set\n+ * - period_ms   time period expressed in milliseconds\n+ *\/\n+void JfrEventThrottler::configure(int64_t sample_size, int64_t period_ms) {\n+  JfrSpinlockHelper mutex(&_lock);\n+  _sample_size = sample_size;\n+  _period_ms = period_ms;\n+  _update = true;\n+  reconfigure();\n+}\n+\n+\/\/ There is currently only one throttler instance, for the jdk.ObjectAllocationSample event.\n+\/\/ When introducing additional throttlers, also add a lookup map keyed by event id.\n+static JfrEventThrottler* _throttler = NULL;\n+\n+bool JfrEventThrottler::create() {\n+  assert(_throttler == NULL, \"invariant\");\n+  _throttler = new JfrEventThrottler(JfrObjectAllocationSampleEvent);\n+  return _throttler != NULL && _throttler->initialize();\n+}\n+\n+void JfrEventThrottler::destroy() {\n+  delete _throttler;\n+  _throttler = NULL;\n+}\n+\n+JfrEventThrottler* JfrEventThrottler::for_event(JfrEventId event_id) {\n+  assert(_throttler != NULL, \"JfrEventThrottler has not been properly initialized\");\n+  assert(event_id == JfrObjectAllocationSampleEvent, \"need more throttlers?\");\n+  return _throttler;\n+}\n+\n+\/\/ Predicate for event selection.\n+bool JfrEventThrottler::accept(JfrEventId event_id, int64_t timestamp) {\n+  JfrEventThrottler* const throttler = for_event(event_id);\n+  assert(throttler != NULL, \"invariant\");\n+  return throttler->_disabled ? true : throttler->sample(timestamp);\n+}\n+\n+\/*\n+ * The window_lookback_count defines the history in number of windows to take into account\n+ * when the JfrAdaptiveSampler engine is calcualting an expected weigthed moving average (EWMA) over the population.\n+ * Technically, it determines the alpha coefficient in the EMWA formula.\n+ *\/\n+constexpr static const size_t default_window_lookback_count = 25; \/\/ 25 windows == 5 seconds (for default window duration of 200 ms)\n+\n+\/*\n+ * Rates lower than or equal to the 'low rate upper bound', are considered special.\n+ * They will use a single window of whatever duration, because the rates are so low they\n+ * do not justify the overhead of more frequent window rotations.\n+ *\/\n+constexpr static const intptr_t low_rate_upper_bound = 9;\n+constexpr static const size_t  window_divisor = 5;\n+\n+constexpr static const int64_t MINUTE = 60 * MILLIUNITS;\n+constexpr static const int64_t TEN_PER_1000_MS_IN_MINUTES = 600;\n+constexpr static const int64_t HOUR = 60 * MINUTE;\n+constexpr static const int64_t TEN_PER_1000_MS_IN_HOURS = 36000;\n+constexpr static const int64_t DAY = 24 * HOUR;\n+constexpr static const int64_t TEN_PER_1000_MS_IN_DAYS = 864000;\n+\n+inline void set_window_lookback(JfrSamplerParams& params) {\n+  if (params.window_duration_ms <= MILLIUNITS) {\n+    params.window_lookback_count = default_window_lookback_count; \/\/ 5 seconds\n+    return;\n+  }\n+  if (params.window_duration_ms == MINUTE) {\n+    params.window_lookback_count = 5; \/\/ 5 windows == 5 minutes\n+    return;\n+  }\n+  params.window_lookback_count = 1; \/\/ 1 window == 1 hour or 1 day\n+}\n+\n+inline void set_low_rate(JfrSamplerParams& params, int64_t event_sample_size, int64_t period_ms) {\n+  params.sample_points_per_window = event_sample_size;\n+  params.window_duration_ms = period_ms;\n+}\n+\n+\/\/ If the throttler is off, it accepts all events.\n+constexpr static const int64_t event_throttler_off = -2;\n+\n+\/*\n+ * Set the number of sample points and window duration.\n+ *\/\n+inline void set_sample_points_and_window_duration(JfrSamplerParams& params, int64_t sample_size, int64_t period_ms) {\n+  assert(sample_size != event_throttler_off, \"invariant\");\n+  assert(sample_size >= 0, \"invariant\");\n+  assert(period_ms >= 1000, \"invariant\");\n+  if (sample_size <= low_rate_upper_bound) {\n+    set_low_rate(params, sample_size, period_ms);\n+    return;\n+  } else if (period_ms == MINUTE && sample_size < TEN_PER_1000_MS_IN_MINUTES) {\n+    set_low_rate(params, sample_size, period_ms);\n+    return;\n+  } else if (period_ms == HOUR && sample_size < TEN_PER_1000_MS_IN_HOURS) {\n+    set_low_rate(params, sample_size, period_ms);\n+    return;\n+  } else if (period_ms == DAY && sample_size < TEN_PER_1000_MS_IN_DAYS) {\n+    set_low_rate(params, sample_size, period_ms);\n+    return;\n+  }\n+  assert(period_ms % window_divisor == 0, \"invariant\");\n+  params.sample_points_per_window = sample_size \/ window_divisor;\n+  params.window_duration_ms = period_ms \/ window_divisor;\n+}\n+\n+\/*\n+ * If the input event sample size is large enough, normalize to per 1000 ms\n+ *\/\n+inline void normalize(int64_t* sample_size, int64_t* period_ms) {\n+  assert(sample_size != NULL, \"invariant\");\n+  assert(period_ms != NULL, \"invariant\");\n+  if (*period_ms == MILLIUNITS) {\n+    return;\n+  }\n+  if (*period_ms == MINUTE) {\n+    if (*sample_size >= TEN_PER_1000_MS_IN_MINUTES) {\n+      *sample_size \/= 60;\n+      *period_ms \/= 60;\n+    }\n+    return;\n+  }\n+  if (*period_ms == HOUR) {\n+    if (*sample_size >= TEN_PER_1000_MS_IN_HOURS) {\n+      *sample_size \/= 3600;\n+      *period_ms \/= 3600;\n+    }\n+    return;\n+  }\n+  if (*sample_size >= TEN_PER_1000_MS_IN_DAYS) {\n+    *sample_size \/= 86400;\n+    *period_ms \/= 86400;\n+  }\n+}\n+\n+inline bool is_disabled(int64_t event_sample_size) {\n+  return event_sample_size == event_throttler_off;\n+}\n+\n+const JfrSamplerParams& JfrEventThrottler::update_params(const JfrSamplerWindow* expired) {\n+  _disabled = is_disabled(_sample_size);\n+  if (_disabled) {\n+    return _disabled_params;\n+  }\n+  normalize(&_sample_size, &_period_ms);\n+  set_sample_points_and_window_duration(_last_params, _sample_size, _period_ms);\n+  set_window_lookback(_last_params);\n+  _sample_size_ewma = 0;\n+  _last_params.reconfigure = true;\n+  _update = false;\n+  return _last_params;\n+}\n+\n+\/*\n+ * Exponentially Weighted Moving Average (EWMA):\n+ *\n+ * Y is a datapoint (at time t)\n+ * S is the current EMWA (at time t-1)\n+ * alpha represents the degree of weighting decrease, a constant smoothing factor between 0 and 1.\n+ *\n+ * A higher alpha discounts older observations faster.\n+ * Returns the new EWMA for S\n+*\/\n+\n+inline double exponentially_weighted_moving_average(double Y, double alpha, double S) {\n+  return alpha * Y + (1 - alpha) * S;\n+}\n+\n+inline double compute_ewma_alpha_coefficient(size_t lookback_count) {\n+  return lookback_count <= 1 ? 1 : static_cast<double>(1) \/ static_cast<double>(lookback_count);\n+}\n+\n+\/*\n+ * To start debugging the throttler: -Xlog:jfr+system+throttle=debug\n+ * It will log details of each expired window together with an average sample size.\n+ *\n+ * Excerpt:\n+ *\n+ * \"jdk.ObjectAllocationSample: avg.sample size: 19.8377, window set point: 20 ...\"\n+ *\n+ * Monitoring the relation of average sample size to the window set point, i.e the target,\n+ * is a good indicator of how the throttler is performing over time.\n+ *\n+ * Note: there is currently only one throttler instance, for the ObjectAllocationSample event.\n+ * When introducing additional throttlers, also provide a map from the event id to the event name.\n+ *\/\n+static void log(const JfrSamplerWindow* expired, double* sample_size_ewma) {\n+  assert(sample_size_ewma != NULL, \"invariant\");\n+  if (log_is_enabled(Debug, jfr, system, throttle)) {\n+    *sample_size_ewma = exponentially_weighted_moving_average(expired->sample_size(), compute_ewma_alpha_coefficient(expired->params().window_lookback_count), *sample_size_ewma);\n+    log_debug(jfr, system, throttle)(\"jdk.ObjectAllocationSample: avg.sample size: %0.4f, window set point: %zu, sample size: %zu, population size: %zu, ratio: %.4f, window duration: %zu ms\\n\",\n+      *sample_size_ewma, expired->params().sample_points_per_window, expired->sample_size(), expired->population_size(),\n+      expired->population_size() == 0 ? 0 : (double)expired->sample_size() \/ (double)expired->population_size(),\n+      expired->params().window_duration_ms);\n+  }\n+}\n+\n+\/*\n+ * This is the feedback control loop.\n+ *\n+ * The JfrAdaptiveSampler engine calls this when a sampler window has expired, providing\n+ * us with an opportunity to perform some analysis. To reciprocate, we returns a set of\n+ * parameters, possibly updated, for the engine to apply to the next window.\n+ *\n+ * Try to keep relatively quick, since the engine is currently inside a critical section,\n+ * in the process of rotating windows.\n+ *\/\n+const JfrSamplerParams& JfrEventThrottler::next_window_params(const JfrSamplerWindow* expired) {\n+  assert(expired != NULL, \"invariant\");\n+  assert(_lock, \"invariant\");\n+  log(expired, &_sample_size_ewma);\n+  if (_update) {\n+    return update_params(expired); \/\/ Updates _last_params in-place.\n+  }\n+  return _disabled ? _disabled_params : _last_params;\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_SERVICE_JFREVENTTHROTTLER_HPP\n+#define SHARE_JFR_RECORDER_SERVICE_JFREVENTTHROTTLER_HPP\n+\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n+#include \"jfr\/support\/jfrAdaptiveSampler.hpp\"\n+\n+class JfrEventThrottler : public JfrAdaptiveSampler {\n+  friend class JfrRecorder;\n+ private:\n+  JfrSamplerParams _last_params;\n+  int64_t _sample_size;\n+  int64_t _period_ms;\n+  double _sample_size_ewma;\n+  JfrEventId _event_id;\n+  bool _disabled;\n+  bool _update;\n+\n+  static bool create();\n+  static void destroy();\n+\n+  const JfrSamplerParams& update_params(const JfrSamplerWindow* expired);\n+  const JfrSamplerParams& next_window_params(const JfrSamplerWindow* expired) override;\n+\n+ public:\n+  JfrEventThrottler(JfrEventId event_id);\n+  void configure(int64_t event_sample_size, int64_t period_ms);\n+  static JfrEventThrottler* for_event(JfrEventId event_id);\n+  static bool accept(JfrEventId event_id, int64_t timestamp);\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_SERVICE_JFREVENTTHROTTLER_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,385 @@\n+\/*\n+* Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/support\/jfrAdaptiveSampler.hpp\"\n+#include \"jfr\/utilities\/jfrRandom.inline.hpp\"\n+#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n+#include \"jfr\/utilities\/jfrTryLock.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include <cmath>\n+\n+JfrSamplerWindow::JfrSamplerWindow() :\n+  _params(),\n+  _end_ticks(0),\n+  _sampling_interval(1),\n+  _projected_population_size(0),\n+  _measured_population_size(0) {}\n+\n+JfrAdaptiveSampler::JfrAdaptiveSampler() :\n+  _prng(this),\n+  _window_0(NULL),\n+  _window_1(NULL),\n+  _active_window(NULL),\n+  _avg_population_size(0),\n+  _ewma_population_size_alpha(0),\n+  _acc_debt_carry_limit(0),\n+  _acc_debt_carry_count(0),\n+  _lock(0) {}\n+\n+JfrAdaptiveSampler::~JfrAdaptiveSampler() {\n+  delete _window_0;\n+  delete _window_1;\n+}\n+\n+bool JfrAdaptiveSampler::initialize() {\n+  assert(_window_0 == NULL, \"invariant\");\n+  _window_0 = new JfrSamplerWindow();\n+  if (_window_0 == NULL) {\n+    return false;\n+  }\n+  assert(_window_1 == NULL, \"invariant\");\n+  _window_1 = new JfrSamplerWindow();\n+  if (_window_1 == NULL) {\n+    return false;\n+  }\n+  _active_window = _window_0;\n+  return true;\n+}\n+\n+\/*\n+ * The entry point to the sampler.\n+ *\/\n+bool JfrAdaptiveSampler::sample(int64_t timestamp) {\n+  bool expired_window;\n+  const bool result = active_window()->sample(timestamp, &expired_window);\n+  if (expired_window) {\n+    JfrTryLock mutex(&_lock);\n+    if (mutex.acquired()) {\n+      rotate_window(timestamp);\n+    }\n+  }\n+  return result;\n+}\n+\n+inline const JfrSamplerWindow* JfrAdaptiveSampler::active_window() const {\n+  return Atomic::load_acquire(&_active_window);\n+}\n+\n+inline int64_t now() {\n+  return JfrTicks::now().value();\n+}\n+\n+inline bool JfrSamplerWindow::is_expired(int64_t timestamp) const {\n+  const int64_t end_ticks = Atomic::load(&_end_ticks);\n+  return timestamp == 0 ? now() >= end_ticks : timestamp >= end_ticks;\n+}\n+\n+bool JfrSamplerWindow::sample(int64_t timestamp, bool* expired_window) const {\n+  assert(expired_window != NULL, \"invariant\");\n+  *expired_window = is_expired(timestamp);\n+  return *expired_window ? false : sample();\n+}\n+\n+inline bool JfrSamplerWindow::sample() const {\n+  const size_t ordinal = Atomic::add(&_measured_population_size, static_cast<size_t>(1));\n+  return ordinal <= _projected_population_size && ordinal % _sampling_interval == 0;\n+}\n+\n+\/\/ Called exclusively by the holder of the lock when a window is determined to have expired.\n+void JfrAdaptiveSampler::rotate_window(int64_t timestamp) {\n+  assert(_lock, \"invariant\");\n+  const JfrSamplerWindow* const current = active_window();\n+  assert(current != NULL, \"invariant\");\n+  if (!current->is_expired(timestamp)) {\n+    \/\/ Someone took care of it.\n+    return;\n+  }\n+  rotate(current);\n+}\n+\n+\/\/ Subclasses can call this to immediately trigger a reconfiguration of the sampler.\n+\/\/ There is no need to await the expiration of the current active window.\n+void JfrAdaptiveSampler::reconfigure() {\n+  assert(_lock, \"invariant\");\n+  rotate(active_window());\n+}\n+\n+\/\/ Call next_window_param() to report the expired window and to retreive params for the next window.\n+void JfrAdaptiveSampler::rotate(const JfrSamplerWindow* expired) {\n+  assert(expired == active_window(), \"invariant\");\n+  install(configure(next_window_params(expired), expired));\n+}\n+\n+inline void JfrAdaptiveSampler::install(const JfrSamplerWindow* next) {\n+  assert(next != active_window(), \"invariant\");\n+  Atomic::release_store(&_active_window, next);\n+}\n+\n+const JfrSamplerWindow* JfrAdaptiveSampler::configure(const JfrSamplerParams& params, const JfrSamplerWindow* expired) {\n+  assert(_lock, \"invariant\");\n+  if (params.reconfigure) {\n+    \/\/ Store updated params once to both windows.\n+    const_cast<JfrSamplerWindow*>(expired)->_params = params;\n+    next_window(expired)->_params = params;\n+    configure(params);\n+  }\n+  JfrSamplerWindow* const next = set_rate(params, expired);\n+  next->initialize(params);\n+  return next;\n+}\n+\n+\/*\n+ * Exponentially Weighted Moving Average (EWMA):\n+ *\n+ * Y is a datapoint (at time t)\n+ * S is the current EMWA (at time t-1)\n+ * alpha represents the degree of weighting decrease, a constant smoothing factor between 0 and 1.\n+ *\n+ * A higher alpha discounts older observations faster.\n+ * Returns the new EWMA for S\n+*\/\n+\n+inline double exponentially_weighted_moving_average(double Y, double alpha, double S) {\n+  return alpha * Y + (1 - alpha) * S;\n+}\n+\n+inline double compute_ewma_alpha_coefficient(size_t lookback_count) {\n+  return lookback_count <= 1 ? 1 : static_cast<double>(1) \/ static_cast<double>(lookback_count);\n+}\n+\n+inline size_t compute_accumulated_debt_carry_limit(const JfrSamplerParams& params) {\n+  if (params.window_duration_ms == 0 || params.window_duration_ms >= MILLIUNITS) {\n+    return 1;\n+  }\n+  return MILLIUNITS \/ params.window_duration_ms;\n+}\n+\n+void JfrAdaptiveSampler::configure(const JfrSamplerParams& params) {\n+  assert(params.reconfigure, \"invariant\");\n+  _avg_population_size = 0;\n+  _ewma_population_size_alpha = compute_ewma_alpha_coefficient(params.window_lookback_count);\n+  _acc_debt_carry_limit = compute_accumulated_debt_carry_limit(params);\n+  _acc_debt_carry_count = _acc_debt_carry_limit;\n+  params.reconfigure = false;\n+}\n+\n+inline int64_t millis_to_countertime(int64_t millis) {\n+  return JfrTimeConverter::nanos_to_countertime(millis * NANOSECS_PER_MILLISEC);\n+}\n+\n+void JfrSamplerWindow::initialize(const JfrSamplerParams& params) {\n+  assert(_sampling_interval >= 1, \"invariant\");\n+  if (params.window_duration_ms == 0) {\n+    Atomic::store(&_end_ticks, static_cast<int64_t>(0));\n+    return;\n+  }\n+  Atomic::store(&_measured_population_size, static_cast<size_t>(0));\n+  const int64_t end_ticks = now() + millis_to_countertime(params.window_duration_ms);\n+  Atomic::store(&_end_ticks, end_ticks);\n+}\n+\n+\/*\n+ * Based on what it has learned from the past, the sampler creates a future 'projection',\n+ * a speculation, or model, of what the situation will be like during the next window.\n+ * This projection \/ model is used to derive values for the parameters, which are estimates for\n+ * collecting a sample set that, should the model hold, is as close as possible to the target,\n+ * i.e. the set point, which is a function of the number of sample_points_per_window + amortization.\n+ * The model is a geometric distribution over the number of trials \/ selections required until success.\n+ * For each window, the sampling interval is a random variable from this geometric distribution.\n+ *\/\n+JfrSamplerWindow* JfrAdaptiveSampler::set_rate(const JfrSamplerParams& params, const JfrSamplerWindow* expired) {\n+  JfrSamplerWindow* const next = next_window(expired);\n+  assert(next != expired, \"invariant\");\n+  const size_t sample_size = project_sample_size(params, expired);\n+  if (sample_size == 0) {\n+    next->_projected_population_size = 0;\n+    return next;\n+  }\n+  next->_sampling_interval = derive_sampling_interval(sample_size, expired);\n+  assert(next->_sampling_interval >= 1, \"invariant\");\n+  next->_projected_population_size = sample_size * next->_sampling_interval;\n+  return next;\n+}\n+\n+inline JfrSamplerWindow* JfrAdaptiveSampler::next_window(const JfrSamplerWindow* expired) const {\n+  assert(expired != NULL, \"invariant\");\n+  return expired == _window_0 ? _window_1 : _window_0;\n+}\n+\n+size_t JfrAdaptiveSampler::project_sample_size(const JfrSamplerParams& params, const JfrSamplerWindow* expired) {\n+  return params.sample_points_per_window + amortize_debt(expired);\n+}\n+\n+\/*\n+ * When the sampler is configured to maintain a rate, is employs the concepts\n+ * of 'debt' and 'accumulated debt'. 'Accumulated debt' can be thought of as\n+ * a cumulative error term, and is indicative for how much the sampler is\n+ * deviating from a set point, i.e. the ideal target rate. Debt accumulates naturally\n+ * as a function of undersampled windows, caused by system fluctuations,\n+ * i.e. too small populations.\n+ *\n+ * A specified rate is implicitly a _maximal_ rate, so the sampler must ensure\n+ * to respect this 'limit'. Rates are normalized as per-second ratios, hence the\n+ * limit to respect is on a per second basis. During this second, the sampler\n+ * has freedom to dynamically re-adjust, and it does so by 'amortizing'\n+ * accumulated debt over a certain number of windows that fall within the second.\n+ *\n+ * Intuitively, accumulated debt 'carry over' from the predecessor to the successor\n+ * window if within the allowable time frame (determined in # of 'windows' given by\n+ * _acc_debt_carry_limit). The successor window will sample more points to make amends,\n+ * or 'amortize' debt accumulated by its predecessor(s).\n+ *\/\n+size_t JfrAdaptiveSampler::amortize_debt(const JfrSamplerWindow* expired) {\n+  assert(expired != NULL, \"invariant\");\n+  const intptr_t accumulated_debt = expired->accumulated_debt();\n+  assert(accumulated_debt <= 0, \"invariant\");\n+  if (_acc_debt_carry_count == _acc_debt_carry_limit) {\n+    _acc_debt_carry_count = 1;\n+    return 0;\n+  }\n+  ++_acc_debt_carry_count;\n+  return -accumulated_debt; \/\/ negation\n+}\n+\n+inline size_t JfrSamplerWindow::max_sample_size() const {\n+  return _projected_population_size \/ _sampling_interval;\n+}\n+\n+\/\/ The sample size is derived from the measured population size.\n+size_t JfrSamplerWindow::sample_size() const {\n+  const size_t size = population_size();\n+  return size > _projected_population_size ? max_sample_size() : size \/ _sampling_interval;\n+}\n+\n+size_t JfrSamplerWindow::population_size() const {\n+  return Atomic::load(&_measured_population_size);\n+}\n+\n+intptr_t JfrSamplerWindow::accumulated_debt() const {\n+  return _projected_population_size == 0 ? 0 : static_cast<intptr_t>(_params.sample_points_per_window - max_sample_size()) + debt();\n+}\n+\n+intptr_t JfrSamplerWindow::debt() const {\n+  return _projected_population_size == 0 ? 0 : static_cast<intptr_t>(sample_size() - _params.sample_points_per_window);\n+}\n+\n+\/*\n+ * Inverse transform sampling from a uniform to a geometric distribution.\n+ *\n+ * PMF: f(x)  = P(X=x) = ((1-p)^x-1)p\n+ *\n+ * CDF: F(x)  = P(X<=x) = 1 - (1-p)^x\n+ *\n+ * Inv\n+ * CDF: F'(u) = ceil( ln(1-u) \/ ln(1-p) ) \/\/ u = random uniform, 0.0 < u < 1.0\n+ *\n+ *\/\n+inline size_t next_geometric(double p, double u) {\n+  assert(u >= 0.0, \"invariant\");\n+  assert(u <= 1.0, \"invariant\");\n+  if (u == 0.0) {\n+    u = 0.01;\n+  } else if (u == 1.0) {\n+    u = 0.99;\n+  }\n+  \/\/ Inverse CDF for the geometric distribution.\n+  return ceil(log(1.0 - u) \/ log(1.0 - p));\n+}\n+\n+size_t JfrAdaptiveSampler::derive_sampling_interval(double sample_size, const JfrSamplerWindow* expired) {\n+  assert(sample_size > 0, \"invariant\");\n+  const size_t population_size = project_population_size(expired);\n+  if (population_size <= sample_size) {\n+    return 1;\n+  }\n+  assert(population_size > 0, \"invariant\");\n+  const double projected_probability = sample_size \/ population_size;\n+  return next_geometric(projected_probability, _prng.next_uniform());\n+}\n+\n+\/\/ The projected population size is an exponentially weighted moving average, a function of the window_lookback_count.\n+inline size_t JfrAdaptiveSampler::project_population_size(const JfrSamplerWindow* expired) {\n+  assert(expired != NULL, \"invariant\");\n+  _avg_population_size = exponentially_weighted_moving_average(expired->population_size(), _ewma_population_size_alpha, _avg_population_size);\n+  return _avg_population_size;\n+}\n+\n+\/* GTEST support *\/\n+JfrGTestFixedRateSampler::JfrGTestFixedRateSampler(size_t sample_points_per_window, size_t window_duration_ms, size_t lookback_count) : JfrAdaptiveSampler(), _params() {\n+  _sample_size_ewma = 0.0;\n+  _params.sample_points_per_window = sample_points_per_window;\n+  _params.window_duration_ms = window_duration_ms;\n+  _params.window_lookback_count = lookback_count;\n+  _params.reconfigure = true;\n+}\n+\n+bool JfrGTestFixedRateSampler::initialize() {\n+  const bool result = JfrAdaptiveSampler::initialize();\n+  JfrSpinlockHelper mutex(&_lock);\n+  reconfigure();\n+  return result;\n+}\n+\n+\/*\n+ * To start debugging the sampler: -Xlog:jfr+system+throttle=debug\n+ * It will log details of each expired window together with an average sample size.\n+ *\n+ * Excerpt:\n+ *\n+ * \"JfrGTestFixedRateSampler: avg.sample size: 19.8377, window set point: 20 ...\"\n+ *\n+ * Monitoring the relation of average sample size to the window set point, i.e the target,\n+ * is a good indicator of how the sampler is performing over time.\n+ *\n+ *\/\n+static void log(const JfrSamplerWindow* expired, double* sample_size_ewma) {\n+  assert(sample_size_ewma != NULL, \"invariant\");\n+  if (log_is_enabled(Debug, jfr, system, throttle)) {\n+    *sample_size_ewma = exponentially_weighted_moving_average(expired->sample_size(), compute_ewma_alpha_coefficient(expired->params().window_lookback_count), *sample_size_ewma);\n+    log_debug(jfr, system, throttle)(\"JfrGTestFixedRateSampler: avg.sample size: %0.4f, window set point: %zu, sample size: %zu, population size: %zu, ratio: %.4f, window duration: %zu ms\\n\",\n+      *sample_size_ewma, expired->params().sample_points_per_window, expired->sample_size(), expired->population_size(),\n+      expired->population_size() == 0 ? 0 : (double)expired->sample_size() \/ (double)expired->population_size(),\n+      expired->params().window_duration_ms);\n+  }\n+}\n+\n+\/*\n+ * This is the feedback control loop.\n+ *\n+ * The JfrAdaptiveSampler engine calls this when a sampler window has expired, providing\n+ * us with an opportunity to perform some analysis.To reciprocate, we returns a set of\n+ * parameters, possibly updated, for the engine to apply to the next window.\n+ *\/\n+const JfrSamplerParams& JfrGTestFixedRateSampler::next_window_params(const JfrSamplerWindow* expired) {\n+  assert(expired != NULL, \"invariant\");\n+  assert(_lock, \"invariant\");\n+  log(expired, &_sample_size_ewma);\n+  return _params;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.cpp","additions":385,"deletions":0,"binary":false,"changes":385,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+* Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRADAPTIVESAMPLER_HPP\n+#define SHARE_JFR_SUPPORT_JFRADAPTIVESAMPLER_HPP\n+\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"jfr\/utilities\/jfrRandom.hpp\"\n+\n+\/*\n+ * The terminology is mostly from the domain of statistics:\n+ *\n+ * Population - a set of elements of interest.\n+ * Sample - a subset of elements from a population selected by a defined procedure.\n+ * Sample point - an element of a sample (sub)set.\n+ * Sampling interval - the distance between which measurements are taken, also referred to as 'nth selection'\n+ * Debt - an error term, signifying the deviation from a configured set point.\n+ * Amortization - a projection or strategy to recover accumulated debt.\n+ * Window - as in time window or time frame. The sampler sees the evolution of the system in time slices, i.e. in windows.\n+ * Rotate - the process of retiring an expired window and installing a new window with updated parameters.\n+ *\n+ * The adaptive sampler will guarantee a maximum number of sample points selected from a populuation\n+ * during a certain time interval. It is using fixed size time windows and adjusts the sampling interval for the next\n+ * window based on what it learned in the past. Each window has a set point, which is the target number of sample points\n+ * to select. The sampler keeps a cumulative error term, called 'accumulated debt', which is a measure\n+ * for how much the sampler is deviating from the set point over time. The maximum number of sample points selected\n+ * during an individual window is the set point + the accumulated debt.\n+ * The 'accumulated debt' also works as a 'spike damper', smoothing out the extremes in a way that the overall\n+ * target rate is obeyed without highly over- or under-sampled windows.\n+ *\n+ * Sample point selection is defined by a sampling interval, which gives instructions for selecting the 'nth' element\n+ * in a population. Which 'nth' to select is a random variable from a geometric distribution, recalculated for each window.\n+ *\n+ * Each window is configured individually, by an instance of the JfrSamplerParams struct. On window expiration,\n+ * but before switching in the next window, the sampler calls a subclass with the just expired window as an argument.\n+.* A subclass can inspect the window to study the history of the system and also get an overview of how the sampler\n+ * is performing to help draw inferences. Based on what it learned, it can choose to let the sampler re-apply an updated\n+ * set of parameters to the next, upcoming, window. This is a basic feedback control loop to be developed further,\n+ * perhaps evolving more elaborate sampling schemes in the future.\n+ *\n+ * Using the JfrAdaptiveSampler, we can let a user specify at a high level, for example that he\/she would like a\n+ * maximum rate of n sample points per second. Naturally, lower rates will be reported if the system does not produce\n+ * a population to sustain the requested rate, but n per second is respected as a maximum limit, hence it will never\n+ * report a rate higher than n per second.\n+ *\n+ * One good use of the sampler is to employ it as a throttler, or regulator, to help shape large data sets into smaller,\n+ * more managable subsets while still keeping the data somewhat representative.\n+ *\n+ *\/\n+\n+struct JfrSamplerParams {\n+  size_t sample_points_per_window; \/\/ The number of sample points to target per window.\n+  size_t window_duration_ms;\n+  size_t window_lookback_count; \/\/ The number of data points (windows) to include when calculating a moving average for the population size.\n+  mutable bool reconfigure;     \/\/ The sampler should issue a reconfiguration because some parameter changed.\n+};\n+\n+class JfrSamplerWindow : public JfrCHeapObj {\n+  friend class JfrAdaptiveSampler;\n+ private:\n+  JfrSamplerParams _params;\n+  volatile int64_t _end_ticks;\n+  size_t _sampling_interval;\n+  size_t _projected_population_size;\n+  mutable volatile size_t _measured_population_size;\n+\n+  JfrSamplerWindow();\n+  void initialize(const JfrSamplerParams& params);\n+  size_t max_sample_size() const;\n+  bool is_expired(int64_t timestamp) const;\n+  bool sample() const;\n+  bool sample(int64_t timestamp, bool* is_expired) const;\n+\n+ public:\n+  size_t population_size() const;\n+  size_t sample_size() const;\n+  intptr_t debt() const;\n+  intptr_t accumulated_debt() const;\n+  const JfrSamplerParams& params() const {\n+    return _params;\n+  }\n+};\n+\n+class JfrAdaptiveSampler : public JfrCHeapObj {\n+ private:\n+  JfrPRNG _prng;\n+  JfrSamplerWindow* _window_0;\n+  JfrSamplerWindow* _window_1;\n+  const JfrSamplerWindow* _active_window;\n+  double _avg_population_size;\n+  double _ewma_population_size_alpha;\n+  size_t _acc_debt_carry_limit;\n+  size_t _acc_debt_carry_count;\n+\n+  void rotate_window(int64_t timestamp);\n+  void rotate(const JfrSamplerWindow* expired);\n+  const JfrSamplerWindow* active_window() const;\n+  JfrSamplerWindow* next_window(const JfrSamplerWindow* expired) const;\n+  void install(const JfrSamplerWindow* next);\n+\n+  size_t amortize_debt(const JfrSamplerWindow* expired);\n+  size_t derive_sampling_interval(double sample_size, const JfrSamplerWindow* expired);\n+  size_t project_population_size(const JfrSamplerWindow* expired);\n+  size_t project_sample_size(const JfrSamplerParams& params, const JfrSamplerWindow* expired);\n+  JfrSamplerWindow* set_rate(const JfrSamplerParams& params, const JfrSamplerWindow* expired);\n+\n+  void configure(const JfrSamplerParams& params);\n+  const JfrSamplerWindow* configure(const JfrSamplerParams& params, const JfrSamplerWindow* expired);\n+\n+ protected:\n+  volatile int _lock;\n+  JfrAdaptiveSampler();\n+  virtual ~JfrAdaptiveSampler();\n+  virtual bool initialize();\n+  virtual const JfrSamplerParams& next_window_params(const JfrSamplerWindow* expired) = 0;\n+  void reconfigure();\n+\n+ public:\n+  bool sample(int64_t timestamp = 0);\n+};\n+\n+\/* GTEST support *\/\n+class JfrGTestFixedRateSampler : public JfrAdaptiveSampler {\n+ private:\n+  JfrSamplerParams _params;\n+  double _sample_size_ewma;\n+ public:\n+  JfrGTestFixedRateSampler(size_t sample_points_per_window, size_t window_duration_ms, size_t lookback_count);\n+  virtual bool initialize();\n+  const JfrSamplerParams& next_window_params(const JfrSamplerWindow* expired);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRADAPTIVESAMPLER_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.hpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -57,0 +57,1 @@\n+  JFR_LOG_TAG(jfr, system, throttle) \\\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLogTagSets.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_UTILITIES_JFRRANDOM_HPP\n+#define SHARE_JFR_UTILITIES_JFRRANDOM_HPP\n+\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+\n+\/\/ Cheap pseudorandom number generator\n+\n+class JfrPRNG : public JfrCHeapObj {\n+ private:\n+  mutable uint64_t _rnd;\n+ public:\n+  JfrPRNG(const void* seed);\n+  double next_uniform() const;\n+};\n+\n+#endif \/\/ SHARE_JFR_UTILITIES_JFRRANDOM_HPP\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrRandom.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_UTILITIES_JFRRANDOM_INLINE_HPP\n+#define SHARE_JFR_UTILITIES_JFRRANDOM_INLINE_HPP\n+\n+#include \"jfr\/utilities\/jfrRandom.hpp\"\n+\n+inline JfrPRNG::JfrPRNG(const void* seed) : _rnd(reinterpret_cast<uint64_t>(seed)) {\n+  assert(seed != NULL, \"invariant\");\n+}\n+\n+\/\/ Returns the next prng value.\n+\/\/ pRNG is: aX+b mod c with a = 0x5DEECE66D, b =  0xB, c = 1<<48\n+\/\/ This is the lrand64 generator.\n+inline uint64_t next(uint64_t rnd) {\n+  static const uint64_t PrngMult = 0x5DEECE66DLL;\n+  static const uint64_t PrngAdd = 0xB;\n+  static const uint64_t PrngModPower = 48;\n+  static const uint64_t PrngModMask = (static_cast<uint64_t>(1) << PrngModPower) - 1;\n+  return (PrngMult * rnd + PrngAdd) & PrngModMask;\n+}\n+\n+inline double JfrPRNG::next_uniform() const {\n+  _rnd = next(_rnd);\n+  \/\/ Take the top 26 bits as the random number\n+  \/\/ (This plus a 1<<58 sampling bound gives a max possible step of\n+  \/\/ 5194297183973780480 bytes.  In this case,\n+  \/\/ for sample_parameter = 1<<19, max possible step is\n+  \/\/ 9448372 bytes (24 bits).\n+  static const uint64_t PrngModPower = 48;  \/\/ Number of bits in prng\n+  \/\/ The uint32_t cast is to prevent a (hard-to-reproduce) NAN\n+  \/\/ under piii debug for some binaries.\n+  \/\/ the n_rand value is between 0 and 2**26-1 so it needs to be normalized by dividing by 2**26 (67108864)\n+  return (static_cast<uint32_t>(_rnd >> (PrngModPower - 26)) \/ static_cast<double>(67108864));\n+}\n+\n+#endif \/\/ SHARE_JFR_UTILITIES_JFRRANDOM_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrRandom.inline.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-  bool _has_lock;\n+  bool _acquired;\n@@ -39,1 +39,1 @@\n-  JfrTryLock(volatile int* lock) : _lock(lock), _has_lock(Atomic::cmpxchg(lock, 0, 1) == 0) {}\n+  JfrTryLock(volatile int* lock) : _lock(lock), _acquired(Atomic::cmpxchg(lock, 0, 1) == 0) {}\n@@ -42,1 +42,1 @@\n-    if (_has_lock) {\n+    if (_acquired) {\n@@ -48,2 +48,2 @@\n-  bool has_lock() const {\n-    return _has_lock;\n+  bool acquired() const {\n+    return _acquired;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTryLock.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+  LOG_TAG(throttle) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-  if (event.should_commit()) {\n+  if (event.is_started()) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.jfr.internal.settings.ThrottleSetting;\n@@ -72,0 +73,1 @@\n+    private static final Type TYPE_THROTTLE = TypeLibrary.createType(ThrottleSetting.class);\n@@ -79,1 +81,0 @@\n-        addControl(Enabled.NAME, defineEnabled(eventType));\n@@ -92,0 +93,4 @@\n+        if (eventType.hasThrottle()) {\n+            addControl(Throttle.NAME, defineThrottle(eventType));\n+        }\n+        addControl(Enabled.NAME, defineEnabled(eventType));\n@@ -99,0 +104,1 @@\n+        remove(eventType, aes, Throttle.class);\n@@ -255,0 +261,9 @@\n+    private static Control defineThrottle(PlatformEventType type) {\n+        Throttle throttle = type.getAnnotation(Throttle.class);\n+        String def = Throttle.DEFAULT;\n+        if (throttle != null) {\n+            def = throttle.value();\n+        }\n+        type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_THROTTLE, Throttle.NAME, def, Collections.emptyList()));\n+        return new Control(new ThrottleSetting(type), def);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -518,0 +518,12 @@\n+\n+    \/**\n+     * Sets the event emission rate in event sample size per time unit.\n+     *\n+     * Determines how events are throttled.\n+     *\n+     * @param eventTypeId the id of the event type\n+     * @param eventSampleSize event sample size\n+     * @param period_ms time period in milliseconds\n+     * @return true, if it could be set\n+     *\/\n+    public native boolean setThrottle(long eventTypeId, long eventSampleSize, long period_ms);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,0 +69,4 @@\n+    \/**\n+     *  Covers throttling (for Hotspot developers)\n+     *\/\n+    JFR_SYSTEM_THROTTLE(8),\n@@ -72,1 +76,1 @@\n-    JFR_METADATA(8),\n+    JFR_METADATA(9),\n@@ -76,1 +80,1 @@\n-    JFR_EVENT(9),\n+    JFR_EVENT(10),\n@@ -80,1 +84,1 @@\n-    JFR_SETTING(10),\n+    JFR_SETTING(11),\n@@ -84,1 +88,1 @@\n-    JFR_DCMD(11);\n+    JFR_DCMD(12);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LogTag.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+        private final boolean throttle;\n@@ -104,0 +105,1 @@\n+            throttle = dis.readBoolean();\n@@ -307,0 +309,3 @@\n+                if (t.throttle) {\n+                    aes.add(new AnnotationElement(Throttle.class, Throttle.DEFAULT));\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataLoader.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+                pEventType.setHasThrottle(eventType.getAnnotation(Throttle.class) != null);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    private boolean hasThrottle = false;\n@@ -145,0 +146,4 @@\n+    public void setHasThrottle(boolean hasThrottle) {\n+        this.hasThrottle = hasThrottle;\n+    }\n+\n@@ -152,0 +157,6 @@\n+    public void setThrottle(long ratePerSecond, long period_ms) {\n+        if (isJVM) {\n+            JVM.getJVM().setThrottle(getId(), ratePerSecond, period_ms);\n+        }\n+    }\n+\n@@ -172,0 +183,4 @@\n+    public boolean hasThrottle() {\n+        return this.hasThrottle;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import jdk.jfr.MetadataDefinition;\n+\n+\/**\n+ * Event annotation, determines the event emission rate in events per time unit.\n+ *\n+ * This setting is only supported for JVM events.\n+ *\n+ * @since 16\n+ *\/\n+@MetadataDefinition\n+@Target({ ElementType.TYPE })\n+@Inherited\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Throttle {\n+    \/**\n+     * Settings name {@code \"throttle\"} for configuring an event emission rate in events per time unit.\n+     *\/\n+    public final static String NAME = \"throttle\";\n+    public final static String DEFAULT = \"off\";\n+\n+    \/**\n+     * Throttle, for example {@code \"100\/s\"}.\n+     * <p>\n+     * String representation of a non-negative {@code Long} value followed by a slash (\"\/\")\n+     * and one of the following units<br>\n+     * {@code \"ns\"} (nanoseconds)<br>\n+     * {@code \"us\"} (microseconds)<br>\n+     * {@code \"ms\"} (milliseconds)<br>\n+     * {@code \"s\"} (seconds)<br>\n+     * {@code \"m\"} (minutes)<br>\n+     * {@code \"h\"} (hours)<br>\n+     * {@code \"d\"} (days)<br>\n+     * <p>\n+     * Example values, {@code \"6000\/m\"}, {@code \"10\/ms\"} and {@code \"200\/s\"}.\n+     * When zero is specified, for example {@code \"0\/s\"}, no events are emitted.\n+     * When {@code \"off\"} is specified, all events are emitted.\n+     *\n+     * @return the throttle value, default {@code \"off\"} not {@code null}\n+     *\n+     *\/\n+    String value() default DEFAULT;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Throttle.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -72,0 +73,1 @@\n+    private static final String OFF = \"off\";\n@@ -81,1 +83,0 @@\n-\n@@ -91,0 +92,1 @@\n+    private static long THROTTLE_OFF = -2;\n@@ -207,0 +209,108 @@\n+    private static void throwThrottleNumberFormatException(String s) {\n+        throw new NumberFormatException(\"'\" + s + \"' is not valid. Should be a non-negative numeric value followed by a delimiter. i.e. \/ or \\\\, and then followed by a unit e.g. 20 ms.\");\n+    }\n+\n+    public static long parseThrottleValue(String s) {\n+        if (s.equals(OFF)) {\n+            return THROTTLE_OFF;\n+        }\n+        String parsedValue = parseThrottleString(s, true);\n+        long value = 0;\n+        try {\n+            value = Long.parseLong(parsedValue);\n+        } catch (NumberFormatException nfe) {\n+            throwThrottleNumberFormatException(s);\n+        }\n+        return value * throttleTimeFactor(parseThrottleTimeUnit(s));\n+    }\n+\n+    \/\/ Expected input format is \"x\/y\" or \"x\\y\" where x is a non-negative long\n+    \/\/ and y is a time unit. Split the string at the delimiter.\n+    private static String parseThrottleString(String s, boolean value) {\n+        String[] split = s.split(\"[\\\\\/\\\\\\\\]\");\n+        if (split.length != 2) {\n+            throwThrottleNumberFormatException(s);\n+        }\n+        return value ? split[0].trim() : split[1].trim();\n+    }\n+\n+    private static TimeUnit parseThrottleTimeUnit(String s) {\n+        if (s.equals(OFF)) {\n+            return TimeUnit.MILLISECONDS;\n+        }\n+        String parsedTimeUnit = parseThrottleString(s, false);\n+        return timeUnit(parsedTimeUnit);\n+    }\n+\n+    public static long parseThrottleTimeUnitToMillis(String s) {\n+        return throttleMillis(parseThrottleTimeUnit(s));\n+    }\n+\n+    private static TimeUnit timeUnit(String unit) {\n+        if (unit.endsWith(\"ns\")) {\n+            return TimeUnit.NANOSECONDS;\n+        }\n+        if (unit.endsWith(\"us\")) {\n+            return TimeUnit.MICROSECONDS;\n+        }\n+        if (unit.endsWith(\"ms\")) {\n+            return TimeUnit.MILLISECONDS;\n+        }\n+        if (unit.endsWith(\"s\")) {\n+            return TimeUnit.SECONDS;\n+        }\n+        if (unit.endsWith(\"m\")) {\n+            return TimeUnit.MINUTES;\n+        }\n+        if (unit.endsWith(\"h\")) {\n+            return TimeUnit.HOURS;\n+        }\n+        if (unit.endsWith(\"d\")) {\n+            return TimeUnit.DAYS;\n+        }\n+        throw new NumberFormatException(\"'\" + unit + \"' is not a valid time unit.\");\n+    }\n+\n+    public static double parseAndNormalizeThrottleValue(String s) {\n+        if (s.equals(OFF)) {\n+            return THROTTLE_OFF;\n+        }\n+        long value = 0;\n+        TimeUnit unit = TimeUnit.MILLISECONDS;\n+        try {\n+            value = parseThrottleValue(s);\n+            unit = parseThrottleTimeUnit(s);\n+        } catch (NumberFormatException nfe) {\n+            throwThrottleNumberFormatException(s);\n+        }\n+        return normalizeThrottleValue(value * throttleTimeFactor(unit), throttleMillis(unit));\n+    }\n+\n+    private static long throttleMillis(TimeUnit unit) {\n+        switch (unit) {\n+            case NANOSECONDS:\n+            case MICROSECONDS:\n+            case MILLISECONDS:\n+                return SECONDS.toMillis(1);\n+            default:\n+                return unit.toMillis(1);\n+        }\n+    }\n+\n+    private static long throttleTimeFactor(TimeUnit unit) {\n+        switch (unit) {\n+            case NANOSECONDS :\n+                return SECONDS.toNanos(1);\n+            case MICROSECONDS:\n+                return SECONDS.toNanos(1) \/ 1000;\n+            case MILLISECONDS:\n+                return SECONDS.toMillis(1);\n+            default:\n+                return 1;\n+        }\n+    }\n+\n+    private static double normalizeThrottleValue(long value, long millis) {\n+        return value == THROTTLE_OFF ? THROTTLE_OFF : (double) value \/ (double) millis;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":111,"deletions":1,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.settings;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.MetadataDefinition;\n+import jdk.jfr.Name;\n+import jdk.jfr.Timespan;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.Utils;\n+\n+@MetadataDefinition\n+@Label(\"Event Emission Throttle\")\n+@Description(\"Throttles the emission rate for an event\")\n+@Name(Type.SETTINGS_PREFIX + \"Throttle\")\n+public final class ThrottleSetting extends JDKSettingControl {\n+    private final static long typeId = Type.getTypeId(ThrottleSetting.class);\n+    private final static long OFF = -2;\n+    private String value = \"0\/s\";\n+    private final PlatformEventType eventType;\n+\n+    public ThrottleSetting(PlatformEventType eventType) {\n+       this.eventType = Objects.requireNonNull(eventType);\n+    }\n+\n+    @Override\n+    public String combine(Set<String> values) {\n+        double max = OFF;\n+        String text = \"off\";\n+        for (String value : values) {\n+            double l = parseAndNormalizeValueSafe(value);\n+            if (l > max) {\n+                text = value;\n+                max = l;\n+            }\n+        }\n+        return text;\n+    }\n+\n+    private static double parseAndNormalizeValueSafe(String s) {\n+        double value = 0.0;\n+        try {\n+            value = Utils.parseAndNormalizeThrottleValue(s);\n+        } catch (NumberFormatException nfe) {\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public void setValue(String s) {\n+        this.value = s;\n+        long size = 0;\n+        long millis = 1000;\n+        try {\n+            size = Utils.parseThrottleValue(s);\n+            millis = Utils.parseThrottleTimeUnitToMillis(s);\n+        } catch (NumberFormatException nfe) {\n+        }\n+        eventType.setThrottle(size, millis);\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    public static boolean isType(long typeId) {\n+        return ThrottleSetting.typeId == typeId;\n+    }\n+}\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleSetting.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -617,0 +617,6 @@\n+    <event name=\"jdk.ObjectAllocationSample\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"throttle\">150\/s<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">true<\/setting>\n+      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">false<\/setting>\n@@ -613,1 +613,6 @@\n-      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">true<\/setting>\n+      <setting name=\"enabled\" control=\"memory-profiling-enabled-medium\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.ObjectAllocationSample\">\n+      <setting name=\"enabled\">true<\/setting>\n@@ -615,0 +620,1 @@\n+      <setting name=\"throttle\">300\/s<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+\/\/ This test performs mocking of certain JVM functionality. This works by\n+\/\/ including the source file under test inside an anonymous namespace (which\n+\/\/ prevents linking conflicts) with the mocked symbols redefined.\n+\n+\/\/ The include list should mirror the one found in the included source file -\n+\/\/ with the ones that should pick up the mocks removed. Those should be included\n+\/\/ later after the mocks have been defined.\n+\n+#include <cmath>\n+\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"jfr\/utilities\/jfrRandom.inline.hpp\"\n+#include \"jfr\/utilities\/jfrSpinlockHelper.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n+#include \"jfr\/utilities\/jfrTryLock.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include \"unittest.hpp\"\n+\n+\/\/ #undef SHARE_JFR_SUPPORT_JFRADAPTIVESAMPLER_HPP\n+\n+namespace {\n+  class MockJfrTimeConverter : public ::JfrTimeConverter {\n+  public:\n+    static double nano_to_counter_multiplier(bool is_os_time = false) {\n+      return 1.0;\n+    }\n+    static jlong counter_to_nanos(jlong c, bool is_os_time = false) {\n+      return c;\n+    }\n+    static jlong counter_to_millis(jlong c, bool is_os_time = false) {\n+      return c * NANOS_PER_MILLISEC;\n+    }\n+    static jlong nanos_to_countertime(jlong c, bool as_os_time = false) {\n+      return c;\n+    }\n+  };\n+\n+  class MockJfrTickValue {\n+  private:\n+    jlong _ticks;\n+  public:\n+    MockJfrTickValue(jlong ticks) : _ticks(ticks) {};\n+    jlong value() {\n+      return _ticks;\n+    }\n+  };\n+  class MockJfrTicks {\n+  public:\n+    static jlong tick;\n+    static MockJfrTickValue now() {\n+      return MockJfrTickValue(tick);\n+    }\n+  };\n+\n+  jlong MockJfrTicks::tick = 0;\n+\n+  \/\/ Reincluding source files in the anonymous namespace unfortunately seems to\n+  \/\/ behave strangely with precompiled headers (only when using gcc though)\n+#ifndef DONT_USE_PRECOMPILED_HEADER\n+#define DONT_USE_PRECOMPILED_HEADER\n+#endif\n+\n+#define JfrTicks MockJfrTicks\n+#define JfrTimeConverter MockJfrTimeConverter\n+\n+#include \"jfr\/support\/jfrAdaptiveSampler.hpp\"\n+#include \"jfr\/support\/jfrAdaptiveSampler.cpp\"\n+\n+#undef JfrTimeConverter\n+#undef JfrTicks\n+} \/\/ anonymous namespace\n+\n+class JfrGTestAdaptiveSampling : public ::testing::Test {\n+ protected:\n+  const int max_population_per_window = 2000;\n+  const int min_population_per_window = 2;\n+  const int window_count = 10000;\n+  const clock_t window_duration_ms = 100;\n+  const size_t expected_sample_points_per_window = 50;\n+  const size_t expected_sample_points = expected_sample_points_per_window * (size_t)window_count;\n+  const size_t window_lookback_count = 50; \/\/ 50 windows == 5 seconds (for a window duration of 100 ms)\n+  const double max_sample_bias = 0.11;\n+\n+  void SetUp() {\n+    \/\/ Ensure that tests are separated in time by spreading them by 24hrs apart\n+    MockJfrTicks::tick += (24 * 60 * 60) * NANOSECS_PER_SEC;\n+  }\n+\n+  void TearDown() {\n+    \/\/ nothing\n+  }\n+\n+  void assertDistributionProperties(int distr_slots, jlong* population, jlong* sample, size_t population_size, size_t sample_size, const char* msg) {\n+    size_t population_sum = 0;\n+    size_t sample_sum = 0;\n+    for (int i = 0; i < distr_slots; i++) {\n+      population_sum += i * population[i];\n+      sample_sum += i * sample[i];\n+    }\n+\n+    double population_mean = population_sum \/ (double)population_size;\n+    double sample_mean = sample_sum \/ (double)sample_size;\n+\n+    double population_variance = 0;\n+    double sample_variance = 0;\n+    for (int i = 0; i < distr_slots; i++) {\n+      double population_diff = i - population_mean;\n+      population_variance = population[i] * population_diff * population_diff;\n+\n+      double sample_diff = i - sample_mean;\n+      sample_variance = sample[i] * sample_diff * sample_diff;\n+    }\n+    population_variance = population_variance \/ (population_size - 1);\n+    sample_variance = sample_variance \/ (sample_size - 1);\n+    double population_stdev = sqrt(population_variance);\n+    double sample_stdev = sqrt(sample_variance);\n+\n+    \/\/ make sure the standard deviation is ok\n+    EXPECT_NEAR(population_stdev, sample_stdev, 0.5) << msg;\n+    \/\/ make sure that the subsampled set mean is within 2-sigma of the original set mean\n+    EXPECT_NEAR(population_mean, sample_mean, population_stdev) << msg;\n+    \/\/ make sure that the original set mean is within 2-sigma of the subsampled set mean\n+    EXPECT_NEAR(sample_mean, population_mean, sample_stdev) << msg;\n+  }\n+\n+  typedef size_t(JfrGTestAdaptiveSampling::* incoming)() const;\n+  void test(incoming inc, size_t events_per_window, double expectation, const char* description);\n+\n+ public:\n+  size_t incoming_uniform() const {\n+    return os::random() % max_population_per_window + min_population_per_window;\n+  }\n+\n+  size_t incoming_bursty_10_percent() const {\n+    bool is_burst = (os::random() % 100) < 10; \/\/ 10% burst chance\n+    return is_burst ? max_population_per_window : min_population_per_window;\n+  }\n+\n+  size_t incoming_bursty_90_percent() const {\n+    bool is_burst = (os::random() % 100) < 90; \/\/ 90% burst chance\n+    return is_burst ? max_population_per_window : min_population_per_window;\n+  }\n+\n+  size_t incoming_low_rate() const {\n+    return min_population_per_window;\n+  }\n+\n+  size_t incoming_high_rate() const {\n+    return max_population_per_window;\n+  }\n+\n+  size_t incoming_burst_eval(size_t& count, size_t mod_value) const {\n+    return count++ % 10 == mod_value ? max_population_per_window : 0;\n+  }\n+\n+  size_t incoming_early_burst() const {\n+    static size_t count = 1;\n+    return incoming_burst_eval(count, 1);\n+  }\n+\n+  size_t incoming_mid_burst() const {\n+    static size_t count = 1;\n+    return incoming_burst_eval(count, 5);\n+  }\n+\n+  size_t incoming_late_burst() const {\n+    static size_t count = 1;\n+    return incoming_burst_eval(count, 0);\n+  }\n+};\n+\n+void JfrGTestAdaptiveSampling::test(JfrGTestAdaptiveSampling::incoming inc, size_t sample_points_per_window, double error_factor, const char* const description) {\n+  assert(description != NULL, \"invariant\");\n+  char output[1024] = \"Adaptive sampling: \";\n+  strcat(output, description);\n+  fprintf(stdout, \"=== %s\\n\", output);\n+  jlong population[100] = { 0 };\n+  jlong sample[100] = { 0 };\n+  ::JfrGTestFixedRateSampler sampler = ::JfrGTestFixedRateSampler(expected_sample_points_per_window, window_duration_ms, window_lookback_count);\n+  EXPECT_TRUE(sampler.initialize());\n+\n+  size_t population_size = 0;\n+  size_t sample_size = 0;\n+  for (int t = 0; t < window_count; t++) {\n+    const size_t incoming_events = (this->*inc)();\n+    for (size_t i = 0; i < incoming_events; i++) {\n+      ++population_size;\n+      size_t index = os::random() % 100;\n+      population[index] += 1;\n+      if (sampler.sample()) {\n+        ++sample_size;\n+        sample[index] += 1;\n+      }\n+    }\n+    MockJfrTicks::tick += window_duration_ms * NANOSECS_PER_MILLISEC + 1;\n+    sampler.sample(); \/\/ window rotation\n+  }\n+\n+  const size_t target_sample_size = sample_points_per_window * window_count;\n+  EXPECT_NEAR(target_sample_size, sample_size, expected_sample_points * error_factor) << output;\n+  strcat(output, \", hit distribution\");\n+  assertDistributionProperties(100, population, sample, population_size, sample_size, output);\n+}\n+\n+TEST_VM_F(JfrGTestAdaptiveSampling, uniform_rate) {\n+  test(&JfrGTestAdaptiveSampling::incoming_uniform, expected_sample_points_per_window, 0.05, \"random uniform, all samples\");\n+}\n+\n+TEST_VM_F(JfrGTestAdaptiveSampling, low_rate) {\n+  test(&JfrGTestAdaptiveSampling::incoming_low_rate, min_population_per_window, 0.05, \"low rate\");\n+}\n+\n+TEST_VM_F(JfrGTestAdaptiveSampling, high_rate) {\n+  test(&JfrGTestAdaptiveSampling::incoming_high_rate, expected_sample_points_per_window, 0.02, \"high rate\");\n+}\n+\n+\/\/ We can think of the windows as splitting up a time period, for example a second (window_duration_ms = 100)\n+\/\/ The burst tests for early, mid and late apply a burst rate at a selected window, with other windows having no incoming input.\n+\/\/\n+\/\/ - early during the first window of a new time period\n+\/\/ - mid   during the middle window of a new time period\n+\/\/ - late  during the last window of a new time period\n+\/\/\n+\/\/ The tests verify the total sample size correspond to the selected bursts:\n+\/\/\n+\/\/ - early start of a second -> each second will have sampled the window set point for a single window only since no debt has accumulated into the new time period.\n+\/\/ - mid   middle of the second -> each second will have sampled the window set point + accumulated debt for the first 4 windows.\n+\/\/ - late end of the second -> each second will have sampled the window set point + accumulated debt for the first 9 windows (i.e. it will have sampled all)\n+\/\/\n+\n+TEST_VM_F(JfrGTestAdaptiveSampling, early_burst) {\n+  test(&JfrGTestAdaptiveSampling::incoming_early_burst, expected_sample_points_per_window, 0.9, \"early burst\");\n+}\n+\n+TEST_VM_F(JfrGTestAdaptiveSampling, mid_burst) {\n+  test(&JfrGTestAdaptiveSampling::incoming_mid_burst, expected_sample_points_per_window, 0.5, \"mid burst\");\n+}\n+\n+TEST_VM_F(JfrGTestAdaptiveSampling, late_burst) {\n+  test(&JfrGTestAdaptiveSampling::incoming_late_burst, expected_sample_points_per_window, 0.0, \"late burst\");\n+}\n+\n+\/\/ These are randomized burst tests\n+TEST_VM_F(JfrGTestAdaptiveSampling, bursty_rate_10_percent) {\n+  test(&JfrGTestAdaptiveSampling::incoming_bursty_10_percent, expected_sample_points_per_window, 0.96, \"bursty 10%\");\n+}\n+\n+TEST_VM_F(JfrGTestAdaptiveSampling, bursty_rate_90_percent) {\n+  test(&JfrGTestAdaptiveSampling::incoming_bursty_10_percent, expected_sample_points_per_window, 0.96, \"bursty 90%\");\n+}\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -467,1 +467,1 @@\n-    jdk\/jfr\/event\/compiler\/TestAllocInNewTLAB.java \\\n+    jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEvent.java \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.allocation;\n+\n+import static java.lang.Math.floor;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that event is triggered when an object is allocated in a new TLAB.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 jdk.jfr.event.allocation.TestObjectAllocationInNewTLABEvent\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 -Xint jdk.jfr.event.allocation.TestObjectAllocationInNewTLABEvent\n+ *\/\n+\n+\/**\n+ * Test that when an object is allocated in a new Thread Local Allocation Buffer (TLAB)\n+ * an event will be triggered. The test is done for default and interpreted mode (-Xint).\n+ *\n+ * To force objects to be allocated in a new TLAB:\n+ *      the size of TLAB is set to 100k (-XX:TLABSize=100k);\n+ *      the size of allocated objects is set to 100k minus 16 bytes overhead;\n+ *      max TLAB waste at refill is set to minimum (-XX:TLABRefillWasteFraction=1),\n+ *          to provoke a new TLAB creation.\n+ *\/\n+public class TestObjectAllocationInNewTLABEvent {\n+    private final static String EVENT_NAME = EventNames.ObjectAllocationInNewTLAB;\n+\n+    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array.\n+    private static final int OBJECT_SIZE  = 100 * 1024;\n+    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops.\n+    private static final int OBJECTS_TO_ALLOCATE = 100;\n+    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n+    private static final int INITIAL_TLAB_SIZE = 100 * 1024;\n+    private static int countAllTlabs; \/\/ Count all matching tlab allocations.\n+    private static int countFullTlabs; \/\/ Count matching tlab allocations with full tlab size.\n+\n+    \/\/ Make sure allocation isn't dead code eliminated.\n+    public static byte[] tmp;\n+\n+    public static void main(String[] args) throws Exception {\n+        Recording recording = new Recording();\n+        recording.enable(EVENT_NAME);\n+        recording.start();\n+        System.gc();\n+        allocate();\n+        recording.stop();\n+        verifyRecording(recording);\n+        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n+        Asserts.assertGreaterThanOrEqual(countAllTlabs, minCount, \"Too few tlab objects allocated\");\n+        Asserts.assertLessThanOrEqual(countAllTlabs, OBJECTS_TO_ALLOCATE, \"Too many tlab objects allocated\");\n+\n+        \/\/ For most GCs we expect the size of each tlab to be\n+        \/\/ INITIAL_TLAB_SIZE + ALLOCATION_SIZE, but that is not always true for G1.\n+        \/\/ G1 may use a smaller tlab size if the full tlab does not fit in the\n+        \/\/ selected memory region.\n+        \/\/\n+        \/\/ For example, if a G1 memory region has room for 4.7 tlabs,\n+        \/\/ then the first 4 tlabs will have the expected size,\n+        \/\/ but the fifth tlab would only have a size of 0.7*expected.\n+        \/\/\n+        \/\/ It is only the last tlab in each region that has a smaller size.\n+        \/\/ This means that at least 50% of the allocated tlabs should\n+        \/\/ have the expected size (1 full tlab, and 1 fractional tlab).\n+        Asserts.assertGreaterThanOrEqual(2*countFullTlabs, countAllTlabs, \"Too many fractional tlabs.\");\n+    }\n+\n+    private static void allocate() {\n+        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n+            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n+        }\n+    }\n+\n+    private static void verifyRecording(Recording recording) throws Exception {\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            verify(event);\n+        }\n+    }\n+\n+    private static void verify(RecordedEvent event) {\n+        if (Thread.currentThread().getId() != event.getThread().getJavaThreadId()) {\n+            return;\n+        }\n+        long allocationSize = Events.assertField(event, \"allocationSize\").atLeast(1L).getValue();\n+        long tlabSize = Events.assertField(event, \"tlabSize\").atLeast(allocationSize).getValue();\n+        String className = Events.assertField(event, \"objectClass.name\").notEmpty().getValue();\n+        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT)) {\n+            countAllTlabs++;\n+            if (tlabSize == INITIAL_TLAB_SIZE + OBJECT_SIZE || tlabSize == INITIAL_TLAB_SIZE + OBJECT_SIZE_ALT) {\n+                countFullTlabs++;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationInNewTLABEvent.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.allocation;\n+\n+import static java.lang.Math.floor;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that when an object is allocated outside a TLAB an event will be triggered.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 jdk.jfr.event.allocation.TestObjectAllocationOutsideTLABEvent\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 -Xint jdk.jfr.event.allocation.TestObjectAllocationOutsideTLABEvent\n+ *\/\n+\n+\/**\n+ * Test that an event is triggered when an object is allocated outside a\n+ * Thread Local Allocation Buffer (TLAB). The test is done for default interpreted mode (-Xint).\n+ *\n+ * To force objects to be allocated outside TLAB:\n+ *      the size of TLAB is set to 90k (-XX:TLABSize=90k);\n+ *      the size of allocated objects is set to 100k.\n+ *      max TLAB waste at refill is set to 256 (-XX:TLABRefillWasteFraction=256),\n+ *          to prevent a new TLAB creation.\n+*\/\n+public class TestObjectAllocationOutsideTLABEvent {\n+    private static final String EVENT_NAME = EventNames.ObjectAllocationOutsideTLAB;\n+\n+    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n+    private static final int OBJECT_SIZE = 100 * 1024;\n+    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n+    private static final int OBJECTS_TO_ALLOCATE = 100;\n+    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n+    private static int eventCount;\n+\n+    \/\/ Make sure allocation isn't dead code eliminated.\n+    public static byte[] tmp;\n+\n+    public static void main(String[] args) throws Exception {\n+        Recording recording = new Recording();\n+        recording.enable(EVENT_NAME);\n+        recording.start();\n+        allocate();\n+        recording.stop();\n+        verifyRecording(recording);\n+        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n+        Asserts.assertGreaterThanOrEqual(eventCount, minCount, \"Too few objects allocated\");\n+        Asserts.assertLessThanOrEqual(eventCount, OBJECTS_TO_ALLOCATE, \"Too many objects allocated\");\n+    }\n+\n+    private static void allocate() {\n+        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n+            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n+        }\n+    }\n+\n+    private static void verifyRecording(Recording recording) throws Exception {\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            verify(event);\n+        }\n+    }\n+\n+    private static void verify(RecordedEvent event) {\n+        if (Thread.currentThread().getId() != event.getThread().getJavaThreadId()) {\n+            return;\n+        }\n+        long allocationSize = Events.assertField(event, \"allocationSize\").atLeast(1L).getValue();\n+        String className = Events.assertField(event, \"objectClass.name\").notEmpty().getValue();\n+        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT)) {\n+            ++eventCount;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationOutsideTLABEvent.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.allocation;\n+\n+import java.util.concurrent.CountDownLatch;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests ObjectAllocationSampleEvent\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=2k -XX:-ResizeTLAB jdk.jfr.event.allocation.TestObjectAllocationSampleEvent\n+ *\/\n+public class TestObjectAllocationSampleEvent {\n+    private static final String EVENT_NAME = EventNames.ObjectAllocationSample;\n+    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n+    private static final int OBJECT_SIZE = 4 * 1024;\n+    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n+    private static final int OBJECTS_TO_ALLOCATE = 16;\n+    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n+\n+    \/\/ Make sure allocation isn't dead code eliminated.\n+    public static byte[] tmp;\n+\n+    public static void main(String... args) throws Exception {\n+        CountDownLatch delivered = new CountDownLatch(1);\n+        Thread current = Thread.currentThread();\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(EVENT_NAME);\n+            rs.onEvent(EVENT_NAME, e -> {\n+                if (verify(e, current)) {\n+                    delivered.countDown();\n+                }\n+            });\n+            rs.startAsync();\n+            for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n+                tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n+            }\n+            delivered.await();\n+        }\n+    }\n+\n+    private static boolean verify(RecordedEvent event, Thread thread) {\n+        Asserts.assertTrue(event.hasField(\"allocatedSinceLast\"));\n+        Asserts.assertTrue(event.hasField(\"skippedEvents\"));\n+        if (thread.getId() != event.getThread().getJavaThreadId()) {\n+            return false;\n+        }\n+        long allocationSize = Events.assertField(event, \"allocationSize\").atLeast(1L).getValue();\n+        String className = Events.assertField(event, \"objectClass.name\").notEmpty().getValue();\n+        return className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEvent.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.allocation;\n+\n+import static java.lang.Math.floor;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that an allocation sample event is triggered when an allocation takes the new TLAB path.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 jdk.jfr.event.allocation.TestObjectAllocationSampleEventNewTLABPath\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 -Xint jdk.jfr.event.allocation.TestObjectAllocationSampleEventNewTLABPath\n+ *\/\n+\n+\/**\n+ * Test that an allocation sample event is triggered when an allocation takes the new TLAB path.\n+ * The test is done for default and interpreted mode (-Xint).\n+ *\n+ * To force objects to be allocated using the TLAB path:\n+ *      the size of TLAB is set to 100k (-XX:TLABSize=100k);\n+ *      the size of allocated objects is set to 100k minus 16 bytes overhead;\n+ *      max TLAB waste at refill is set to minimum (-XX:TLABRefillWasteFraction=1),\n+ *          to provoke a new TLAB creation.\n+ *\/\n+public class TestObjectAllocationSampleEventNewTLABPath {\n+    private final static String EVENT_NAME = EventNames.ObjectAllocationSample;\n+\n+    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n+    private static final int OBJECT_SIZE = 100 * 1024;\n+    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n+    private static final int OBJECTS_TO_ALLOCATE = 100;\n+    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n+    private static int eventCount;\n+\n+    \/\/ Make sure allocation isn't dead code eliminated.\n+    public static byte[] tmp;\n+\n+    public static void main(String[] args) throws Exception {\n+        Recording recording = new Recording();\n+        recording.enable(EVENT_NAME);\n+        recording.start();\n+        System.gc();\n+        allocate();\n+        recording.stop();\n+        verifyRecording(recording);\n+        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n+        Asserts.assertGreaterThanOrEqual(eventCount, minCount, \"Too few object samples allocated\");\n+    }\n+\n+    private static void allocate() {\n+        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n+            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n+        }\n+    }\n+\n+    private static void verifyRecording(Recording recording) throws Exception {\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            verify(event);\n+        }\n+    }\n+\n+    private static void verify(RecordedEvent event) {\n+        Asserts.assertTrue(event.hasField(\"allocatedSinceLast\"));\n+        Asserts.assertTrue(event.hasField(\"skippedEvents\"));\n+        if (Thread.currentThread().getId() != event.getThread().getJavaThreadId()) {\n+            return;\n+        }\n+        long allocationSize = Events.assertField(event, \"allocationSize\").atLeast(1L).getValue();\n+        String className = Events.assertField(event, \"objectClass.name\").notEmpty().getValue();\n+        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT)) {\n+            \/\/ Count all matching allocation samples.\n+            ++eventCount;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEventNewTLABPath.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.allocation;\n+\n+import static java.lang.Math.floor;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that an allocation sample event is triggered when an allocation takes the direct path, i.e. outside of a TLAB.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 jdk.jfr.event.allocation.TestObjectAllocationSampleEventOutsideTLABPath\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 -Xint jdk.jfr.event.allocation.TestObjectAllocationSampleEventOutsideTLABPath\n+ *\/\n+\n+\/**\n+ * Test that an allocation sample event is triggered when an allocation takes a direct path, i.e. outside of a TLAB.\n+ * The test is done for default and interpreted mode (-Xint).\n+ *\n+ * To force objects to be allocated outside TLAB:\n+ *      the size of TLAB is set to 90k (-XX:TLABSize=90k);\n+ *      the size of allocated objects is set to 100k.\n+ *      max TLAB waste at refill is set to 256 (-XX:TLABRefillWasteFraction=256),\n+ *          to prevent a new TLAB creation.\n+*\/\n+public class TestObjectAllocationSampleEventOutsideTLABPath {\n+    private final static String EVENT_NAME = EventNames.ObjectAllocationSample;\n+\n+    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n+    private static final int OBJECT_SIZE = 100 * 1024;\n+    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n+    private static final int OBJECTS_TO_ALLOCATE = 100;\n+    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n+    private static int eventCount;\n+\n+    \/\/ Make sure allocation isn't dead code eliminated.\n+    public static byte[] tmp;\n+\n+    public static void main(String[] args) throws Exception {\n+        Recording recording = new Recording();\n+        recording.enable(EVENT_NAME);\n+        recording.start();\n+        System.gc();\n+        allocate();\n+        recording.stop();\n+        verifyRecording(recording);\n+        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n+        Asserts.assertGreaterThanOrEqual(eventCount, minCount, \"Too few object samples allocated\");\n+    }\n+\n+    private static void allocate() {\n+        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n+            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n+        }\n+    }\n+\n+    private static void verifyRecording(Recording recording) throws Exception {\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            verify(event);\n+        }\n+    }\n+\n+    private static void verify(RecordedEvent event) {\n+        Asserts.assertTrue(event.hasField(\"allocatedSinceLast\"));\n+        Asserts.assertTrue(event.hasField(\"skippedEvents\"));\n+        if (Thread.currentThread().getId() != event.getThread().getJavaThreadId()) {\n+            return;\n+        }\n+        long allocationSize = Events.assertField(event, \"allocationSize\").atLeast(1L).getValue();\n+        String className = Events.assertField(event, \"objectClass.name\").notEmpty().getValue();\n+        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT)) {\n+            ++eventCount;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEventOutsideTLABPath.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.allocation;\n+\n+import static java.lang.Math.floor;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @summary Test that when an object is allocated outside a TLAB an event will be triggered.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+*  @run main\/othervm -XX:+UseTLAB -XX:TLABSize=2k -XX:-ResizeTLAB jdk.jfr.event.allocation.TestObjectAllocationSampleEventThrottling\n+ *\/\n+\n+public class TestObjectAllocationSampleEventThrottling {\n+    private static final String EVENT_NAME = EventNames.ObjectAllocationSample;\n+\n+    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n+    private static final int OBJECT_SIZE = 100 * 1024;\n+    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n+    private static final int OBJECTS_TO_ALLOCATE = 100;\n+    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n+    private static int eventCount;\n+\n+    \/\/ Make sure allocation isn't dead code eliminated.\n+    public static byte[] tmp;\n+\n+    public static void main(String[] args) throws Exception {\n+        testZeroPerSecond();\n+        testThrottleSettings();\n+    }\n+\n+    private static void testZeroPerSecond() throws Exception {\n+        Recording r1 = new Recording();\n+        setThrottle(r1, \"0\/s\");\n+        r1.start();\n+        allocate();\n+        r1.stop();\n+        List<RecordedEvent> events = Events.fromRecording(r1);\n+        Asserts.assertTrue(events.isEmpty(), \"throttle rate 0\/s should not emit any events\");\n+    }\n+\n+    private static void testThrottleSettings() throws Exception {\n+        Recording r1 = new Recording();\n+        \/\/ 0\/s will not emit any events\n+        setThrottle(r1, \"0\/s\");\n+        r1.start();\n+        Recording r2 = new Recording();\n+        \/\/ 1\/ns is a *very* high emit rate, it should trump the previous 0\/s value\n+        \/\/ to allow the allocation sample events to be recorded.\n+        setThrottle(r2, \"1\/ns\");\n+        r2.start();\n+        allocate();\n+        r2.stop();\n+        r1.stop();\n+        verifyRecording(r2);\n+        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n+        Asserts.assertGreaterThanOrEqual(eventCount, minCount, \"Too few object samples allocated\");\n+        List<RecordedEvent> events = Events.fromRecording(r1);\n+        Asserts.assertFalse(events.isEmpty(), \"r1 should also have events\");\n+    }\n+\n+    private static void setThrottle(Recording recording, String rate) {\n+        recording.enable(EVENT_NAME).with(\"throttle\", rate);\n+    }\n+\n+    private static void allocate() {\n+        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n+            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n+        }\n+    }\n+\n+    private static void verifyRecording(Recording recording) throws Exception {\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            verify(event);\n+        }\n+    }\n+\n+    private static void verify(RecordedEvent event) {\n+        if (Thread.currentThread().getId() != event.getThread().getJavaThreadId()) {\n+            return;\n+        }\n+        long allocationSize = Events.assertField(event, \"allocationSize\").atLeast(1L).getValue();\n+        String className = Events.assertField(event, \"objectClass.name\").notEmpty().getValue();\n+        if (className.equals(BYTE_ARRAY_CLASS_NAME) && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT)) {\n+            ++eventCount;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEventThrottling.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.compiler;\n-\n-import static java.lang.Math.floor;\n-import static jdk.test.lib.Asserts.assertGreaterThanOrEqual;\n-import static jdk.test.lib.Asserts.assertLessThanOrEqual;\n-\n-import java.time.Duration;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-\n-\/**\n- * @test\n- * @summary Test that event is triggered when an object is allocated in a new TLAB.\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 jdk.jfr.event.compiler.TestAllocInNewTLAB\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=100k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=1 -Xint jdk.jfr.event.compiler.TestAllocInNewTLAB\n- *\/\n-\n-\/**\n- * Test that when an object is allocated in a new Thread Local Allocation Buffer (TLAB)\n- * an event will be triggered. The test is done for default and interpreted mode (-Xint).\n- *\n- * To force objects to be allocated in a new TLAB:\n- *      the size of TLAB is set to 100k (-XX:TLABSize=100k);\n- *      the size of allocated objects is set to 100k minus 16 bytes overhead;\n- *      max TLAB waste at refill is set to minimum (-XX:TLABRefillWasteFraction=1),\n- *          to provoke a new TLAB creation.\n- *\/\n-public class TestAllocInNewTLAB {\n-    private final static String EVENT_NAME = EventNames.ObjectAllocationInNewTLAB;\n-\n-    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array.\n-    private static final int OBJECT_SIZE  = 100 * 1024;\n-    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n-    private static final int OBJECTS_TO_ALLOCATE = 100;\n-    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n-    private static final int INITIAL_TLAB_SIZE = 100 * 1024;\n-\n-    \/\/ make sure allocation isn't dead code eliminated\n-    public static byte[] tmp;\n-\n-    public static void main(String[] args) throws Exception {\n-        Recording recording = new Recording();\n-        recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n-\n-        recording.start();\n-        System.gc();\n-        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n-            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n-        }\n-        recording.stop();\n-\n-        int countAllTlabs = 0;  \/\/ Count all matching tlab allocations.\n-        int countFullTlabs = 0; \/\/ Count matching tlab allocations with full tlab size.\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n-            if (!EVENT_NAME.equals(event.getEventType().getName())) {\n-                continue;\n-            }\n-            System.out.println(\"Event:\" + event);\n-\n-            long allocationSize = Events.assertField(event, \"allocationSize\").atLeast(1L).getValue();\n-            long tlabSize = Events.assertField(event, \"tlabSize\").atLeast(allocationSize).getValue();\n-            String className = Events.assertField(event, \"objectClass.name\").notEmpty().getValue();\n-\n-            boolean isMyEvent = Thread.currentThread().getId() == event.getThread().getJavaThreadId()\n-                 && className.equals(BYTE_ARRAY_CLASS_NAME)\n-                 && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT);\n-            if (isMyEvent) {\n-                countAllTlabs++;\n-                if (tlabSize == INITIAL_TLAB_SIZE + OBJECT_SIZE || tlabSize == INITIAL_TLAB_SIZE + OBJECT_SIZE_ALT) {\n-                    countFullTlabs++;\n-                }\n-            }\n-        }\n-\n-        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n-        assertGreaterThanOrEqual(countAllTlabs, minCount, \"Too few tlab objects allocated\");\n-        assertLessThanOrEqual(countAllTlabs, OBJECTS_TO_ALLOCATE, \"Too many tlab objects allocated\");\n-\n-        \/\/ For most GCs we expect the size of each tlab to be\n-        \/\/ INITIAL_TLAB_SIZE + ALLOCATION_SIZE, but that is not always true for G1.\n-        \/\/ G1 may use a smaller tlab size if the full tlab does not fit in the\n-        \/\/ selected memory region.\n-        \/\/\n-        \/\/ For example, if a G1 memory region has room for 4.7 tlabs,\n-        \/\/ then the first 4 tlabs will have the expected size,\n-        \/\/ but the fifth tlab would only have a size of 0.7*expected.\n-        \/\/\n-        \/\/ It is only the last tlab in each region that has a smaller size.\n-        \/\/ This means that at least 50% of the allocated tlabs should\n-        \/\/ have the expected size (1 full tlab, and 1 fractional tlab).\n-        assertGreaterThanOrEqual(2*countFullTlabs, countAllTlabs, \"Too many fractional tlabs.\");\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestAllocInNewTLAB.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.compiler;\n-\n-import static java.lang.Math.floor;\n-import static jdk.test.lib.Asserts.assertGreaterThanOrEqual;\n-import static jdk.test.lib.Asserts.assertLessThanOrEqual;\n-\n-import java.time.Duration;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-\n-\/**\n- * @test\n- * @summary Test that when an object is allocated outside a TLAB an event will be triggered.\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 jdk.jfr.event.compiler.TestAllocOutsideTLAB\n- * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=90k -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=256 -Xint jdk.jfr.event.compiler.TestAllocOutsideTLAB\n- *\/\n-\n-\/**\n- * Test that an event is triggered when an object is allocated outside a\n- * Thread Local Allocation Buffer (TLAB). The test is done for default interpreted mode (-Xint).\n- *\n- * To force objects to be allocated outside TLAB:\n- *      the size of TLAB is set to 90k (-XX:TLABSize=90k);\n- *      the size of allocated objects is set to 100k.\n- *      max TLAB waste at refill is set to 256 (-XX:TLABRefillWasteFraction=256),\n- *          to prevent a new TLAB creation.\n-*\/\n-public class TestAllocOutsideTLAB {\n-    private static final String EVENT_NAME = EventNames.ObjectAllocationOutsideTLAB;\n-\n-    private static final int BYTE_ARRAY_OVERHEAD = 16; \/\/ Extra bytes used by a byte array\n-    private static final int OBJECT_SIZE = 100 * 1024;\n-    private static final int OBJECT_SIZE_ALT = OBJECT_SIZE + 8; \/\/ Object size in case of disabled CompressedOops\n-    private static final int OBJECTS_TO_ALLOCATE = 100;\n-    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n-\n-    public static byte[] tmp; \/\/ Used to prevent optimizer from removing code.\n-\n-    public static void main(String[] args) throws Exception {\n-        Recording recording = new Recording();\n-        recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n-        recording.start();\n-        for (int i = 0; i < OBJECTS_TO_ALLOCATE; ++i) {\n-            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];\n-        }\n-        recording.stop();\n-\n-        int countEvents = 0;\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n-            if (!EVENT_NAME.equals(event.getEventType().getName())) {\n-                continue;\n-            }\n-            System.out.println(\"Event:\" + event);\n-\n-            long allocationSize = Events.assertField(event, \"allocationSize\").atLeast(1L).getValue();\n-            String className = Events.assertField(event, \"objectClass.name\").notEmpty().getValue();\n-\n-            boolean isMyEvent = Thread.currentThread().getId() == event.getThread().getJavaThreadId()\n-                && className.equals(BYTE_ARRAY_CLASS_NAME)\n-                 && (allocationSize == OBJECT_SIZE || allocationSize == OBJECT_SIZE_ALT);\n-            if (isMyEvent) {\n-                ++countEvents;\n-            }\n-        }\n-\n-        int minCount = (int) floor(OBJECTS_TO_ALLOCATE * 0.80);\n-        assertGreaterThanOrEqual(countEvents, minCount, \"Too few tlab objects allocated\");\n-        assertLessThanOrEqual(countEvents, OBJECTS_TO_ALLOCATE, \"Too many tlab objects allocated\");\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestAllocOutsideTLAB.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -168,0 +168,1 @@\n+    public final static String ObjectAllocationSample = PREFIX + \"ObjectAllocationSample\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}