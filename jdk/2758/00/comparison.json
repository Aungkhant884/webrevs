{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,1 @@\n-  bool cmpi_folds(PhaseIterGVN* igvn, bool fold_ne = false);\n+  bool cmpi_folds(PhaseIterGVN* igvn);\n@@ -302,1 +302,3 @@\n-  bool fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);\n+  bool get_base_comparing_value(Node* dom_if, PhaseIterGVN* igvn, jint& this_adj_val, jint& dom_adj_val);\n+  bool fold_dominated_if(ProjNode* proj, PhaseIterGVN* igvn);\n+  bool fold_to_unsigned(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-        const CmpNode* cmp  = bol->in(1)->as_Cmp();\n+        const CmpNode* cmp = bol->in(1)->as_Cmp();\n@@ -615,0 +615,2 @@\n+            const TypeInt* val_t = gvn->type(val)->isa_int();\n+            bool is_unsigned = (cmp->Opcode() == Op_CmpU);\n@@ -618,0 +620,1 @@\n+              assert(!is_unsigned, \"unsigned comparison is not supported\");\n@@ -619,1 +622,0 @@\n-              const TypeInt* val_t = gvn->type(val)->isa_int();\n@@ -631,0 +633,1 @@\n+              assert(!is_unsigned, \"unsigned comparison is not supported\");\n@@ -633,1 +636,6 @@\n-              lo = TypeInt::INT->_lo;\n+              if (is_unsigned && lo >= 0) {\n+                \/\/ val u< cmp2 only passes for val >= 0 if cmp2 >= 0\n+                lo = 0;\n+              } else {\n+                lo = TypeInt::INT->_lo;\n+              }\n@@ -639,1 +647,6 @@\n-              lo = TypeInt::INT->_lo;\n+              if (is_unsigned && lo >= 0) {\n+                \/\/ val u<= cmp2 only passes for val >= 0 if cmp2 >= 0\n+                lo = 0;\n+              } else {\n+                lo = TypeInt::INT->_lo;\n+              }\n@@ -642,1 +655,4 @@\n-              if (lo != max_jint) {\n+              if (is_unsigned && (val_t == NULL || val_t->_lo < 0)) {\n+                \/\/ val u> cmp2 passes for val < 0\n+                lo = TypeInt::INT->_lo;\n+              } else if (lo != max_jint) {\n@@ -649,0 +665,4 @@\n+              if (is_unsigned && (val_t == NULL || val_t->_lo < 0)) {\n+                \/\/ val u>= cmp2 passes for val < 0\n+                lo = TypeInt::INT->_lo;\n+              }\n@@ -652,0 +672,1 @@\n+              ShouldNotReachHere();\n@@ -654,2 +675,1 @@\n-            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n-            return rtn_t;\n+            return TypeInt::make(lo, hi, cmp2_t->_widen);\n@@ -703,1 +723,1 @@\n-bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {\n+bool IfNode::cmpi_folds(PhaseIterGVN* igvn) {\n@@ -707,1 +727,2 @@\n-    in(1)->in(1)->Opcode() == Op_CmpI &&\n+    (in(1)->in(1)->Opcode() == Op_CmpI ||\n+     in(1)->in(1)->Opcode() == Op_CmpU) &&\n@@ -712,1 +733,1 @@\n-     (fold_ne && in(1)->as_Bool()->_test._test == BoolTest::ne));\n+     in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -722,2 +743,1 @@\n-    ctrl->in(0)->as_If()->cmpi_folds(igvn, true) &&\n-    \/\/ Must compare same value\n+    ctrl->in(0)->as_If()->cmpi_folds(igvn) &&\n@@ -725,1 +745,1 @@\n-    ctrl->in(0)->in(1)->in(1)->in(1) == in(1)->in(1)->in(1);\n+    in(1)->in(1)->in(1) != NULL;\n@@ -840,0 +860,86 @@\n+\/\/ There might be an AddINode (marked with *) with a constant increment\n+\/\/ in-between the CmpNodes and the common value we compare.\n+\/\/ Check for the following cases and return true if a common value is\n+\/\/ compared. Also save the constant value that is added to infer\n+\/\/ the type of the common value we compare.\n+\/\/\n+\/\/   Variant 1         Variant 2         Variant 3           Variant 4\n+\/\/\n+\/\/    res_val           res_val             res_val          res_val\n+\/\/    \/   \\             \/    \\              \/    \\           \/     \\\n+\/\/ dom_cmp \\           \/   this_val*   dom_val*   \\     dom_val*  this_val*\n+\/\/        this_cmp    \/       \\            \/       \\        |        \\\n+\/\/                  dom_cmp    \\        dom_cmp     \\     dom_cmp     \\\n+\/\/                          this_cmp            this_cmp           this_cmp\n+bool IfNode::get_base_comparing_value (Node* dom_if, PhaseIterGVN* igvn, jint& this_adj_val, jint& dom_adj_val) {\n+  Node* this_cmp = in(1)->in(1)->as_Cmp();\n+  Node* dom_cmp = dom_if->in(1)->in(1)->as_Cmp();\n+  Node* dom_val = dom_cmp->in(1);\n+  Node* this_val = this_cmp->in(1);\n+  if (this_val == dom_val) {\n+    \/\/ Variant 1\n+    return true;\n+  } else if (this_val->is_Add() && this_val->in(1) != NULL && this_val->in(1) == dom_val) {\n+    const TypeInt* val_t = igvn->type(this_val->in(2))->isa_int();\n+    if (val_t != NULL && val_t->is_con()) {\n+      \/\/ Variant 2\n+      this_adj_val = val_t->get_con();\n+      return true;\n+    }\n+  } else if (dom_val->is_Add() && dom_val->in(1) != NULL && this_val == dom_val->in(1)) {\n+    const TypeInt* val_t = igvn->type(dom_val->in(2))->isa_int();\n+    if (val_t != NULL && val_t->is_con()) {\n+      \/\/ Variant 3\n+      dom_adj_val = val_t->get_con();\n+      return true;\n+    }\n+  } else if (this_val->is_Add() && dom_val->is_Add() && this_val->in(1) != NULL && dom_val->in(1) != NULL && this_val->in(1) == dom_val->in(1)) {\n+    const TypeInt* domval_t = igvn->type(dom_val->in(2))->isa_int();\n+    const TypeInt* thisval_t = igvn->type(this_val->in(2))->isa_int();\n+    if (thisval_t != NULL && domval_t != NULL && thisval_t->is_con() && domval_t->is_con()) {\n+      \/\/ Variant 4\n+      this_adj_val = thisval_t->get_con();\n+      dom_adj_val = domval_t->get_con();\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Check if dominating if determines the result of this if\n+bool IfNode::fold_dominated_if(ProjNode* proj, PhaseIterGVN* igvn) {\n+  Node* this_val = in(1)->in(1)->in(1);\n+  Node* dom_if = proj->in(0)->as_If();\n+  Node* dom_val = dom_if->in(1)->in(1)->in(1);\n+  jint this_adj_val = 0;\n+  jint dom_adj_val = 0;\n+\n+  \/\/ Must compare same value\n+  if (get_base_comparing_value(dom_if, igvn, this_adj_val, dom_adj_val)) {\n+    const TypeInt* failtype = filtered_int_type(igvn, dom_val, proj);\n+    if (failtype != NULL) {\n+      if (dom_adj_val != 0) {\n+        \/\/ To account for the AddINode, subtract the constant increment from the type\n+        failtype = dom_val->as_Add()->add_ring(failtype, TypeInt::make(-dom_adj_val))->is_int();\n+      }\n+      for (int i = 0; i < 2; ++i) {\n+        const TypeInt* type = filtered_int_type(igvn, this_val, proj_out(i));\n+        if (type != NULL) {\n+          if (this_adj_val != 0) {\n+            \/\/ To account for the AddINode, subtract the constant increment from the type\n+            type = this_val->as_Add()->add_ring(type, TypeInt::make(-this_adj_val))->is_int();\n+          }\n+          type = failtype->join(type)->is_int();\n+          if (type->empty()) {\n+            \/\/ Replace Bool with constant\n+            igvn->_worklist.push(in(1));\n+            igvn->replace_input_of(this, 1, igvn->intcon(proj_out(1-i)->_con));\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -841,1 +947,1 @@\n-bool IfNode::fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {\n+bool IfNode::fold_to_unsigned(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {\n@@ -850,3 +956,1 @@\n-\n-  const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);\n-  const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);\n+  assert(this_cmp->Opcode() == Op_CmpI && dom_iff->in(1)->in(1)->Opcode() == Op_CmpI, \"Unexpected CmpNode\");\n@@ -857,0 +961,6 @@\n+  if (lo_test == BoolTest::ne || hi_test == BoolTest::ne) {\n+    return false;\n+  }\n+\n+  const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);\n+  const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);\n@@ -884,1 +994,1 @@\n-      hi_type->_hi == max_jint && lo_type->_lo == min_jint && lo_test != BoolTest::ne) {\n+      hi_type->_hi == max_jint && lo_type->_lo == min_jint) {\n@@ -929,1 +1039,1 @@\n-             lo_type->_hi == max_jint && hi_type->_lo == min_jint && lo_test != BoolTest::ne) {\n+             lo_type->_hi == max_jint && hi_type->_lo == min_jint) {\n@@ -987,14 +1097,0 @@\n-    const TypeInt* failtype = filtered_int_type(igvn, n, proj);\n-    if (failtype != NULL) {\n-      const TypeInt* type2 = filtered_int_type(igvn, n, fail);\n-      if (type2 != NULL) {\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->_lo > failtype->_hi) {\n-          \/\/ previous if determines the result of this if so\n-          \/\/ replace Bool with constant\n-          igvn->_worklist.push(in(1));\n-          igvn->replace_input_of(this, 1, igvn->intcon(success->_con));\n-          return true;\n-        }\n-      }\n-    }\n@@ -1266,9 +1362,6 @@\n-    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n-      \/\/ A integer comparison immediately dominated by another integer\n-      \/\/ comparison\n-      ProjNode* success = NULL;\n-      ProjNode* fail = NULL;\n-      ProjNode* dom_cmp = ctrl->as_Proj();\n-      if (has_shared_region(dom_cmp, success, fail) &&\n-          \/\/ Next call modifies graph so must be last\n-          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n+    Node* cmp = in(1)->in(1);\n+    Node* val = cmp->in(1);\n+    \/\/ An integer comparison immediately dominated by another integer comparison\n+    if (is_ctrl_folds(ctrl, igvn)) {\n+      ProjNode* proj = ctrl->as_Proj();\n+      if (fold_dominated_if(proj, igvn)) {\n@@ -1277,4 +1370,15 @@\n-      if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &&\n-          \/\/ Next call modifies graph so must be last\n-          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n-        return merge_uncommon_traps(dom_cmp, success, fail, igvn);\n+      Node* dom_cmp = ctrl->in(0)->in(1)->in(1);\n+      Node* dom_val = dom_cmp->in(1);\n+      if (cmp->Opcode() == Op_CmpI && dom_cmp->Opcode() == Op_CmpI && val == dom_val && ctrl->outcnt() == 1) {\n+        ProjNode* success = NULL;\n+        ProjNode* fail = NULL;\n+        if (has_shared_region(proj, success, fail) &&\n+            \/\/ Next call modifies graph so must be last\n+            fold_to_unsigned(proj, success, fail, igvn)) {\n+          return this;\n+        }\n+        if (has_only_uncommon_traps(proj, success, fail, igvn) &&\n+            \/\/ Next call modifies graph so must be last\n+            fold_to_unsigned(proj, success, fail, igvn)) {\n+          return merge_uncommon_traps(proj, success, fail, igvn);\n+        }\n@@ -1282,3 +1386,3 @@\n-      return NULL;\n-    } else if (ctrl->in(0) != NULL &&\n-               ctrl->in(0)->in(0) != NULL) {\n+    }\n+    if (ctrl->in(0) != NULL &&\n+        ctrl->in(0)->in(0) != NULL) {\n@@ -1288,2 +1392,2 @@\n-      ProjNode* dom_cmp = dom->isa_Proj();\n-      ProjNode* other_cmp = ctrl->isa_Proj();\n+      ProjNode* dom_proj = dom->isa_Proj();\n+      ProjNode* other_proj = ctrl->isa_Proj();\n@@ -1293,7 +1397,14 @@\n-      if (is_ctrl_folds(dom, igvn) &&\n-          has_only_uncommon_traps(dom_cmp, success, fail, igvn) &&\n-          is_side_effect_free_test(other_cmp, igvn) &&\n-          \/\/ Next call modifies graph so must be last\n-          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n-        reroute_side_effect_free_unc(other_cmp, dom_cmp, igvn);\n-        return merge_uncommon_traps(dom_cmp, success, fail, igvn);\n+      if (is_ctrl_folds(dom, igvn)) {\n+        if (fold_dominated_if(dom_proj, igvn)) {\n+            return this;\n+        }\n+        Node* dom_cmp = dom->in(0)->in(1)->in(1);\n+        Node* dom_val = dom_cmp->in(1);\n+        if (cmp->Opcode() == Op_CmpI && dom_cmp->Opcode() == Op_CmpI && val == dom_val &&\n+            has_only_uncommon_traps(dom_proj, success, fail, igvn) &&\n+            is_side_effect_free_test(other_proj, igvn) &&\n+            \/\/ Next call modifies graph so must be last\n+            fold_to_unsigned(dom_proj, success, fail, igvn)) {\n+          reroute_side_effect_free_unc(other_proj, dom_proj, igvn);\n+          return merge_uncommon_traps(dom_proj, success, fail, igvn);\n+        }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":169,"deletions":58,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8229855\n+ * @bug 8229855 8238812\n@@ -31,0 +31,6 @@\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.c2.TestJumpTable::test*\n+ *                   -Xbatch -XX:-TieredCompilation -XX:-UseOnStackReplacement\n+ *                   compiler.c2.TestJumpTable\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.c2.TestJumpTable::test*\n+ *                   -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -XX:+StressIGVN\n+ *                   compiler.c2.TestJumpTable\n@@ -37,1 +43,1 @@\n-    public static int test() {\n+    public static int test0() {\n@@ -56,0 +62,180 @@\n+    static int field;\n+\n+    \/\/ Original (slightly simplified) fuzzer generated test\n+    public static void test1() {\n+        int i4, i5=99, i6, i9=89;\n+        for (i4 = 12; i4 < 365; i4++) {\n+            for (i6 = 5; i6 > 1; i6--) {\n+                switch ((i6 * 5) + 11) {\n+                case 13:\n+                case 19:\n+                case 26:\n+                case 31:\n+                case 35:\n+                case 41:\n+                case 43:\n+                case 61:\n+                case 71:\n+                case 83:\n+                case 314:\n+                    i9 = i5;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: -10..4\n+        if ((i+min_jint) u<= max_jint) {    <- This is always true but not folded by C2\n+            ...\n+        } else {\n+            ...\n+            CastII(i-5, 0..45)              <- Replaced by TOP because i-5 range is -15..-1 but still considered reachable by C2 although it is dead code\n+            ...\n+        }\n+    *\/\n+    public static void test2() {\n+        for (int i = 5; i > -10; i--) {\n+            switch (i) {\n+            case 0:\n+            case 4:\n+            case 10:\n+            case 20:\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 100:\n+                field = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: -20..0\n+        if (i != 0) {\n+            \/\/ i: -20..-1\n+            if (i < 0) {                    <- This is always true but not folded by C2\n+                \/\/ Fall through\n+            } else {\n+                ...\n+                CastII(i-1, 0..4)           <- Replaced by TOP because i-1 range is -21..-1 but still considered reachable by C2 although it is dead code\n+                ...\n+            }\n+        } else {\n+            StoreI                          <- Due to this additional store on, IfNode::has_shared_region returns false and the fold compares optimization does not kick in\n+        }\n+    *\/\n+    public static void test3() {\n+        for (int i = 5; i > -20; i -= 5) {\n+            switch (i) {\n+            case 0:\n+            case 10:\n+            case 20:\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 60:\n+            case 100:\n+                field = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: -20..0\n+        if (i != 0) {\n+            \/\/ i: -20..-1\n+            if (i u< 101) {                 <- This is always false but not folded by C2 because CmpU is not handled\n+                CastII(i-1, 0..49)          <- Replaced by TOP because i-1 range is -21..-1 but still considered reachable by C2 although it is dead code\n+            } else {\n+                ...\n+            }\n+        } else {\n+            ...\n+        }\n+    *\/\n+    public static void test4() {\n+        int local = 0;\n+        for (int i = 5; i > -20; i -= 5) {\n+            switch (i) {\n+            case 0:\n+            case 10:\n+            case 20:\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 100:\n+                local = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: 0..20\n+        if (i != 20) {\n+            \/\/ i: 0..19\n+            if ((i-20) u< 281) {            <- This is always false but not folded by C2 because the two ifs compare different values\n+                CastII(i-21, 0..49)         <- Replaced by TOP because i-21 range is -21..-1 but still considered reachable by C2 although it is dead code\n+            } else {\n+                ...\n+            }\n+        } else {\n+            ...\n+        }\n+    *\/\n+    public static void test5() {\n+        int local;\n+        for (int i = 25; i > 0; i -= 5) {\n+            switch (i) {\n+            case 20:\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 60:\n+            case 70:\n+            case 300:\n+                local = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: 0..20\n+        if ((i+10) != 30) {\n+            \/\/ i: 0..19\n+            if ((i-20) u< 271) {            <- This is always false but not folded by C2 because the two ifs compare different values\n+                CastII(i-21, 0..4)          <- Replaced by TOP because i-21 range is -21..-1 but still considered reachable by C2 although it is dead code\n+            } else {\n+                ...\n+            }\n+        } else {\n+            ...\n+        }\n+    *\/\n+    public static void test6() {\n+        int local;\n+        for (int i = 25; i > 0; i -= 5) {\n+            switch (i + 10) {\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 60:\n+            case 70:\n+            case 80:\n+            case 300:\n+                local = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n@@ -57,2 +243,8 @@\n-        for (int i = 0; i < 20_000; ++i) {\n-            test();\n+        for (int i = 0; i < 50_000; ++i) {\n+            test0();\n+            test1();\n+            test2();\n+            test3();\n+            test4();\n+            test5();\n+            test6();\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestJumpTable.java","additions":197,"deletions":5,"binary":false,"changes":202,"status":"modified"}]}