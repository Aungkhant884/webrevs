{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,1 @@\n-  bool cmp_folds(PhaseIterGVN* igvn);\n+  bool cmpi_folds(PhaseIterGVN* igvn, bool fold_ne = false);\n@@ -302,3 +302,1 @@\n-  bool get_base_comparing_value(Node* dom_if, PhaseIterGVN* igvn, jint& this_adj_val, jint& dom_adj_val);\n-  bool fold_dominated_if(ProjNode* proj, PhaseIterGVN* igvn);\n-  bool fold_to_unsigned(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);\n+  bool fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-        const CmpNode* cmp = bol->in(1)->as_Cmp();\n+        const CmpNode* cmp  = bol->in(1)->as_Cmp();\n@@ -615,2 +615,0 @@\n-            const TypeInt* val_t = gvn->type(val)->isa_int();\n-            bool is_unsigned = (cmp->Opcode() == Op_CmpU);\n@@ -620,1 +618,0 @@\n-              assert(!is_unsigned, \"unsigned comparison is not supported\");\n@@ -622,0 +619,1 @@\n+              const TypeInt* val_t = gvn->type(val)->isa_int();\n@@ -633,1 +631,0 @@\n-              assert(!is_unsigned, \"unsigned comparison is not supported\");\n@@ -636,7 +633,1 @@\n-              if (is_unsigned && lo >= 0) {\n-                \/\/ cmp2 >= 0: val u<= cmp2 can only pass if val >= 0. Set val->_lo to 0.\n-                lo = 0;\n-              } else {\n-                \/\/ The lower bound of val cannot be improved.\n-                lo = TypeInt::INT->_lo;\n-              }\n+              lo = TypeInt::INT->_lo;\n@@ -648,7 +639,1 @@\n-              if (is_unsigned && lo >= 0) {\n-                \/\/ cmp2 >= 0: val u<= cmp2 can only pass if val >= 0. Set val->_lo to 0.\n-                lo = 0;\n-              } else {\n-                \/\/ The lower bound of val cannot be improved.\n-                lo = TypeInt::INT->_lo;\n-              }\n+              lo = TypeInt::INT->_lo;\n@@ -657,4 +642,1 @@\n-              if (is_unsigned && (val_t == NULL || val_t->_lo < 0)) {\n-                \/\/ val u> cmp2 passes for val < 0\n-                lo = TypeInt::INT->_lo;\n-              } else if (lo != max_jint) {\n+              if (lo != max_jint) {\n@@ -666,5 +648,1 @@\n-              if (is_unsigned && (val_t == NULL || val_t->_lo < 0)) {\n-                \/\/ val u>= cmp2 passes for val < 0\n-                lo = TypeInt::INT->_lo;\n-              }\n-              \/\/ else lo unchanged\n+              \/\/ lo unchanged\n@@ -674,1 +652,0 @@\n-              ShouldNotReachHere();\n@@ -677,1 +654,2 @@\n-            return TypeInt::make(lo, hi, cmp2_t->_widen);\n+            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n+            return rtn_t;\n@@ -725,1 +703,1 @@\n-bool IfNode::cmp_folds(PhaseIterGVN* igvn) {\n+bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {\n@@ -729,2 +707,1 @@\n-    (in(1)->in(1)->Opcode() == Op_CmpI ||\n-     in(1)->in(1)->Opcode() == Op_CmpU) &&\n+    in(1)->in(1)->Opcode() == Op_CmpI &&\n@@ -735,1 +712,1 @@\n-     in(1)->as_Bool()->_test._test == BoolTest::ne);\n+     (fold_ne && in(1)->as_Bool()->_test._test == BoolTest::ne));\n@@ -745,1 +722,2 @@\n-    ctrl->in(0)->as_If()->cmp_folds(igvn) &&\n+    ctrl->in(0)->as_If()->cmpi_folds(igvn, true) &&\n+    \/\/ Must compare same value\n@@ -747,1 +725,1 @@\n-    in(1)->in(1)->in(1) != NULL;\n+    ctrl->in(0)->in(1)->in(1)->in(1) == in(1)->in(1)->in(1);\n@@ -862,86 +840,0 @@\n-\/\/ There might be an AddINode (marked with *) with a constant increment\n-\/\/ in-between the CmpNodes and the common value we compare.\n-\/\/ Check for the following cases and return true if a common value is\n-\/\/ compared. Also save the constant value that is added to infer\n-\/\/ the type of the common value we compare.\n-\/\/\n-\/\/   Variant 1         Variant 2         Variant 3           Variant 4\n-\/\/\n-\/\/    res_val           res_val             res_val          res_val\n-\/\/    \/   \\             \/    \\              \/    \\           \/     \\\n-\/\/ dom_cmp \\           \/   this_val*   dom_val*   \\     dom_val*  this_val*\n-\/\/        this_cmp    \/       \\            \/       \\        |        \\\n-\/\/                  dom_cmp    \\        dom_cmp     \\     dom_cmp     \\\n-\/\/                          this_cmp            this_cmp           this_cmp\n-bool IfNode::get_base_comparing_value (Node* dom_if, PhaseIterGVN* igvn, jint& this_adj_val, jint& dom_adj_val) {\n-  assert(dom_if->in(1)->in(1)->is_Cmp() && in(1)->in(1)->is_Cmp(), \"compare expected\");\n-  Node* dom_val = dom_if->in(1)->in(1)->in(1);\n-  Node* this_val = in(1)->in(1)->in(1);\n-  assert(dom_val != NULL && this_val != NULL, \"sanity\");\n-  if (this_val == dom_val) {\n-    \/\/ Variant 1\n-    return true;\n-  } else if (this_val->is_Add() && this_val->in(1) == dom_val) {\n-    const TypeInt* val_t = igvn->type(this_val->in(2))->isa_int();\n-    if (val_t != NULL && val_t->is_con()) {\n-      \/\/ Variant 2\n-      this_adj_val = val_t->get_con();\n-      return true;\n-    }\n-  } else if (dom_val->is_Add() && this_val == dom_val->in(1)) {\n-    const TypeInt* val_t = igvn->type(dom_val->in(2))->isa_int();\n-    if (val_t != NULL && val_t->is_con()) {\n-      \/\/ Variant 3\n-      dom_adj_val = val_t->get_con();\n-      return true;\n-    }\n-  } else if (this_val->is_Add() && dom_val->is_Add() && this_val->in(1) != NULL && this_val->in(1) == dom_val->in(1)) {\n-    const TypeInt* domval_t = igvn->type(dom_val->in(2))->isa_int();\n-    const TypeInt* thisval_t = igvn->type(this_val->in(2))->isa_int();\n-    if (thisval_t != NULL && domval_t != NULL && thisval_t->is_con() && domval_t->is_con()) {\n-      \/\/ Variant 4\n-      this_adj_val = thisval_t->get_con();\n-      dom_adj_val = domval_t->get_con();\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ Check if dominating if determines the result of this if\n-bool IfNode::fold_dominated_if(ProjNode* proj, PhaseIterGVN* igvn) {\n-  Node* this_val = in(1)->in(1)->in(1);\n-  Node* dom_if = proj->in(0)->as_If();\n-  Node* dom_val = dom_if->in(1)->in(1)->in(1);\n-  jint this_adj_val = 0;\n-  jint dom_adj_val = 0;\n-\n-  \/\/ Must compare same value\n-  if (get_base_comparing_value(dom_if, igvn, this_adj_val, dom_adj_val)) {\n-    const TypeInt* failtype = filtered_int_type(igvn, dom_val, proj);\n-    if (failtype != NULL) {\n-      if (dom_adj_val != 0) {\n-        \/\/ To account for the AddINode, subtract the constant increment from the type\n-        failtype = dom_val->as_Add()->add_ring(failtype, TypeInt::make(-dom_adj_val))->is_int();\n-      }\n-      for (int i = 0; i < 2; ++i) {\n-        const TypeInt* type = filtered_int_type(igvn, this_val, proj_out(i));\n-        if (type != NULL) {\n-          if (this_adj_val != 0) {\n-            \/\/ To account for the AddINode, subtract the constant increment from the type\n-            type = this_val->as_Add()->add_ring(type, TypeInt::make(-this_adj_val))->is_int();\n-          }\n-          type = failtype->join(type)->is_int();\n-          if (type->empty()) {\n-            \/\/ Replace Bool with constant\n-            igvn->_worklist.push(in(1));\n-            igvn->replace_input_of(this, 1, igvn->intcon(proj_out(1-i)->_con));\n-            return true;\n-          }\n-        }\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -949,1 +841,1 @@\n-bool IfNode::fold_to_unsigned(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {\n+bool IfNode::fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {\n@@ -958,1 +850,3 @@\n-  assert(this_cmp->Opcode() == Op_CmpI && dom_iff->in(1)->in(1)->Opcode() == Op_CmpI, \"Unexpected CmpNode\");\n+\n+  const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);\n+  const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);\n@@ -963,6 +857,0 @@\n-  if (lo_test == BoolTest::ne || hi_test == BoolTest::ne) {\n-    return false;\n-  }\n-\n-  const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);\n-  const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);\n@@ -996,1 +884,1 @@\n-      hi_type->_hi == max_jint && lo_type->_lo == min_jint) {\n+      hi_type->_hi == max_jint && lo_type->_lo == min_jint && lo_test != BoolTest::ne) {\n@@ -1041,1 +929,1 @@\n-             lo_type->_hi == max_jint && hi_type->_lo == min_jint) {\n+             lo_type->_hi == max_jint && hi_type->_lo == min_jint && lo_test != BoolTest::ne) {\n@@ -1099,0 +987,14 @@\n+    const TypeInt* failtype = filtered_int_type(igvn, n, proj);\n+    if (failtype != NULL) {\n+      const TypeInt* type2 = filtered_int_type(igvn, n, fail);\n+      if (type2 != NULL) {\n+        failtype = failtype->join(type2)->is_int();\n+        if (failtype->_lo > failtype->_hi) {\n+          \/\/ previous if determines the result of this if so\n+          \/\/ replace Bool with constant\n+          igvn->_worklist.push(in(1));\n+          igvn->replace_input_of(this, 1, igvn->intcon(success->_con));\n+          return true;\n+        }\n+      }\n+    }\n@@ -1362,1 +1264,1 @@\n-  if (cmp_folds(igvn)) {\n+  if (cmpi_folds(igvn)) {\n@@ -1364,6 +1266,9 @@\n-    Node* cmp = in(1)->in(1);\n-    Node* val = cmp->in(1);\n-    \/\/ An integer comparison immediately dominated by another integer comparison\n-    if (is_ctrl_folds(ctrl, igvn)) {\n-      ProjNode* proj = ctrl->as_Proj();\n-      if (fold_dominated_if(proj, igvn)) {\n+    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n+      \/\/ A integer comparison immediately dominated by another integer\n+      \/\/ comparison\n+      ProjNode* success = NULL;\n+      ProjNode* fail = NULL;\n+      ProjNode* dom_cmp = ctrl->as_Proj();\n+      if (has_shared_region(dom_cmp, success, fail) &&\n+          \/\/ Next call modifies graph so must be last\n+          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n@@ -1372,15 +1277,4 @@\n-      Node* dom_cmp = ctrl->in(0)->in(1)->in(1);\n-      Node* dom_val = dom_cmp->in(1);\n-      if (cmp->Opcode() == Op_CmpI && dom_cmp->Opcode() == Op_CmpI && val == dom_val && ctrl->outcnt() == 1) {\n-        ProjNode* success = NULL;\n-        ProjNode* fail = NULL;\n-        if (has_shared_region(proj, success, fail) &&\n-            \/\/ Next call modifies graph so must be last\n-            fold_to_unsigned(proj, success, fail, igvn)) {\n-          return this;\n-        }\n-        if (has_only_uncommon_traps(proj, success, fail, igvn) &&\n-            \/\/ Next call modifies graph so must be last\n-            fold_to_unsigned(proj, success, fail, igvn)) {\n-          return merge_uncommon_traps(proj, success, fail, igvn);\n-        }\n+      if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &&\n+          \/\/ Next call modifies graph so must be last\n+          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n+        return merge_uncommon_traps(dom_cmp, success, fail, igvn);\n@@ -1388,3 +1282,3 @@\n-    }\n-    if (ctrl->in(0) != NULL &&\n-        ctrl->in(0)->in(0) != NULL) {\n+      return NULL;\n+    } else if (ctrl->in(0) != NULL &&\n+               ctrl->in(0)->in(0) != NULL) {\n@@ -1394,2 +1288,2 @@\n-      ProjNode* dom_proj = dom->isa_Proj();\n-      ProjNode* other_proj = ctrl->isa_Proj();\n+      ProjNode* dom_cmp = dom->isa_Proj();\n+      ProjNode* other_cmp = ctrl->isa_Proj();\n@@ -1399,14 +1293,7 @@\n-      if (is_ctrl_folds(dom, igvn)) {\n-        if (fold_dominated_if(dom_proj, igvn)) {\n-            return this;\n-        }\n-        Node* dom_cmp = dom->in(0)->in(1)->in(1);\n-        Node* dom_val = dom_cmp->in(1);\n-        if (cmp->Opcode() == Op_CmpI && dom_cmp->Opcode() == Op_CmpI && val == dom_val &&\n-            has_only_uncommon_traps(dom_proj, success, fail, igvn) &&\n-            is_side_effect_free_test(other_proj, igvn) &&\n-            \/\/ Next call modifies graph so must be last\n-            fold_to_unsigned(dom_proj, success, fail, igvn)) {\n-          reroute_side_effect_free_unc(other_proj, dom_proj, igvn);\n-          return merge_uncommon_traps(dom_proj, success, fail, igvn);\n-        }\n+      if (is_ctrl_folds(dom, igvn) &&\n+          has_only_uncommon_traps(dom_cmp, success, fail, igvn) &&\n+          is_side_effect_free_test(other_cmp, igvn) &&\n+          \/\/ Next call modifies graph so must be last\n+          fold_compares_helper(dom_cmp, success, fail, igvn)) {\n+        reroute_side_effect_free_unc(other_cmp, dom_cmp, igvn);\n+        return merge_uncommon_traps(dom_cmp, success, fail, igvn);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":60,"deletions":173,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -866,1 +866,0 @@\n-  const TypeInt* ikeytype = TypeInt::make(0, num_cases, Type::WidenMin);\n@@ -869,1 +868,7 @@\n-  key_val = C->conv_I2X_index(&_gvn, key_val, ikeytype, control());\n+  \/\/ Do not use a narrow int type here to prevent the data path from dying\n+  \/\/ while the control path is not removed. This can happen if the type of key_val\n+  \/\/ is later known to be out of bounds of [0, num_cases] and therefore a narrow cast\n+  \/\/ would be replaced by TOP while C2 is not able to fold the corresponding range checks.\n+#ifdef _LP64\n+  key_val = C->constrained_convI2L(&_gvn, key_val, TypeInt::INT, control());\n+#endif\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}