{"files":[{"patch":"@@ -866,1 +866,0 @@\n-  const TypeInt* ikeytype = TypeInt::make(0, num_cases, Type::WidenMin);\n@@ -869,1 +868,7 @@\n-  key_val = C->conv_I2X_index(&_gvn, key_val, ikeytype, control());\n+  \/\/ Do not use a narrow int type here to prevent the data path from dying\n+  \/\/ while the control path is not removed. This can happen if the type of key_val\n+  \/\/ is later known to be out of bounds of [0, num_cases] and therefore a narrow cast\n+  \/\/ would be replaced by TOP while C2 is not able to fold the corresponding range checks.\n+#ifdef _LP64\n+  key_val = C->constrained_convI2L(&_gvn, key_val, TypeInt::INT, control());\n+#endif\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8229855\n+ * @bug 8229855 8238812\n@@ -31,0 +31,6 @@\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.c2.TestJumpTable::test*\n+ *                   -Xbatch -XX:-TieredCompilation -XX:-UseOnStackReplacement\n+ *                   compiler.c2.TestJumpTable\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.c2.TestJumpTable::test*\n+ *                   -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -XX:+StressIGVN\n+ *                   compiler.c2.TestJumpTable\n@@ -37,1 +43,1 @@\n-    public static int test() {\n+    public static int test0() {\n@@ -56,0 +62,180 @@\n+    static int field;\n+\n+    \/\/ Original (slightly simplified) fuzzer generated test\n+    public static void test1() {\n+        int i4, i5 = 99, i6, i9 = 89;\n+        for (i4 = 12; i4 < 365; i4++) {\n+            for (i6 = 5; i6 > 1; i6--) {\n+                switch ((i6 * 5) + 11) {\n+                case 13:\n+                case 19:\n+                case 26:\n+                case 31:\n+                case 35:\n+                case 41:\n+                case 43:\n+                case 61:\n+                case 71:\n+                case 83:\n+                case 314:\n+                    i9 = i5;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: -10..4\n+        if ((i+min_jint) u<= max_jint) {    <- This is always true but not folded by C2\n+            ...\n+        } else {\n+            ...\n+            CastII(i-5, 0..45)              <- Replaced by TOP because i-5 range is -15..-1 but still considered reachable by C2 although it is dead code\n+            ...\n+        }\n+    *\/\n+    public static void test2() {\n+        for (int i = 5; i > -10; i--) {\n+            switch (i) {\n+            case 0:\n+            case 4:\n+            case 10:\n+            case 20:\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 100:\n+                field = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: -20..0\n+        if (i != 0) {\n+            \/\/ i: -20..-1\n+            if (i < 0) {                    <- This is always true but not folded by C2\n+                \/\/ Fall through\n+            } else {\n+                ...\n+                CastII(i-1, 0..4)           <- Replaced by TOP because i-1 range is -21..-1 but still considered reachable by C2 although it is dead code\n+                ...\n+            }\n+        } else {\n+            StoreI                          <- Due to this additional store on, IfNode::has_shared_region returns false and the fold compares optimization does not kick in\n+        }\n+    *\/\n+    public static void test3() {\n+        for (int i = 5; i > -20; i -= 5) {\n+            switch (i) {\n+            case 0:\n+            case 10:\n+            case 20:\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 60:\n+            case 100:\n+                field = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: -20..0\n+        if (i != 0) {\n+            \/\/ i: -20..-1\n+            if (i u< 101) {                 <- This is always false but not folded by C2 because CmpU is not handled\n+                CastII(i-1, 0..49)          <- Replaced by TOP because i-1 range is -21..-1 but still considered reachable by C2 although it is dead code\n+            } else {\n+                ...\n+            }\n+        } else {\n+            ...\n+        }\n+    *\/\n+    public static void test4() {\n+        int local = 0;\n+        for (int i = 5; i > -20; i -= 5) {\n+            switch (i) {\n+            case 0:\n+            case 10:\n+            case 20:\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 100:\n+                local = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: 0..20\n+        if (i != 20) {\n+            \/\/ i: 0..19\n+            if ((i-20) u< 281) {            <- This is always false but not folded by C2 because the two ifs compare different values\n+                CastII(i-21, 0..49)         <- Replaced by TOP because i-21 range is -21..-1 but still considered reachable by C2 although it is dead code\n+            } else {\n+                ...\n+            }\n+        } else {\n+            ...\n+        }\n+    *\/\n+    public static void test5() {\n+        int local;\n+        for (int i = 25; i > 0; i -= 5) {\n+            switch (i) {\n+            case 20:\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 60:\n+            case 70:\n+            case 300:\n+                local = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ This generates the following subgraph:\n+    \/*\n+        \/\/ i: 0..20\n+        if ((i+10) != 30) {\n+            \/\/ i: 0..19\n+            if ((i-20) u< 271) {            <- This is always false but not folded by C2 because the two ifs compare different values\n+                CastII(i-21, 0..4)          <- Replaced by TOP because i-21 range is -21..-1 but still considered reachable by C2 although it is dead code\n+            } else {\n+                ...\n+            }\n+        } else {\n+            ...\n+        }\n+    *\/\n+    public static void test6() {\n+        int local;\n+        for (int i = 25; i > 0; i -= 5) {\n+            switch (i + 10) {\n+            case 30:\n+            case 40:\n+            case 50:\n+            case 60:\n+            case 70:\n+            case 80:\n+            case 300:\n+                local = 42;\n+                break;\n+            }\n+        }\n+    }\n+\n@@ -57,2 +243,8 @@\n-        for (int i = 0; i < 20_000; ++i) {\n-            test();\n+        for (int i = 0; i < 50_000; ++i) {\n+            test0();\n+            test1();\n+            test2();\n+            test3();\n+            test4();\n+            test5();\n+            test6();\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestJumpTable.java","additions":197,"deletions":5,"binary":false,"changes":202,"status":"modified"}]}