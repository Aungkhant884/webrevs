{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -102,0 +103,3 @@\n+     *\n+     * @implSpec the default implementation of this method always throws {@code SocketException}\n+     *\n@@ -108,1 +112,3 @@\n-    protected void connect(InetAddress address, int port) throws SocketException {}\n+    protected void connect(InetAddress address, int port) throws SocketException {\n+        throw new SocketException(\"connect not implemented\");\n+    }\n@@ -112,0 +118,4 @@\n+     *\n+     * @implSpec The default implementation of this method always throws {@code UncheckedIOException}.\n+     *\n+     * @throws UncheckedIOException if disconnect fails or no implementation is provided\n@@ -114,1 +124,3 @@\n-    protected void disconnect() {}\n+    protected void disconnect() {\n+        throw new UncheckedIOException(new SocketException(\"disconnect not implemented\"));\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,5 +59,0 @@\n-    \/**\n-     * Are we using an older DatagramSocketImpl?\n-     *\/\n-    private final boolean oldImpl;\n-\n@@ -79,1 +74,0 @@\n-     * ST_CONNECTED_NO_IMPL = socket connected but not at impl level\n@@ -83,1 +77,0 @@\n-    static final int ST_CONNECTED_NO_IMPL = 2;\n@@ -100,1 +93,0 @@\n-        this.oldImpl = checkOldImpl(impl);\n@@ -138,19 +130,1 @@\n-        \/\/ old impls do not support connect\/disconnect\n-        if (oldImpl) {\n-            connectState = ST_CONNECTED_NO_IMPL;\n-        } else {\n-            try {\n-                getImpl().connect(address, port);\n-\n-                \/\/ socket is now connected by the impl\n-                connectState = ST_CONNECTED;\n-                \/\/ Do we need to filter some packets?\n-                int avail = getImpl().dataAvailable();\n-                if (avail == -1) {\n-                    throw new SocketException();\n-                }\n-                explicitFilter = avail > 0;\n-                if (explicitFilter) {\n-                    bytesLeftToFilter = getReceiveBufferSize();\n-                }\n-            } catch (SocketException se) {\n+        getImpl().connect(address, port);\n@@ -158,3 +132,10 @@\n-                \/\/ connection will be emulated by DatagramSocket\n-                connectState = ST_CONNECTED_NO_IMPL;\n-            }\n+        \/\/ socket is now connected by the impl\n+        connectState = ST_CONNECTED;\n+        \/\/ Do we need to filter some packets?\n+        int avail = getImpl().dataAvailable();\n+        if (avail == -1) {\n+            throw new SocketException();\n+        }\n+        explicitFilter = avail > 0;\n+        if (explicitFilter) {\n+            bytesLeftToFilter = getReceiveBufferSize();\n@@ -167,24 +148,0 @@\n-    \/**\n-     * Return true if the given DatagramSocketImpl is an \"old\" impl. An old impl\n-     * is one that doesn't implement the abstract methods added in Java SE 1.4.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static boolean checkOldImpl(DatagramSocketImpl impl) {\n-        \/\/ DatagramSocketImpl.peekData() is a protected method, therefore we need to use\n-        \/\/ getDeclaredMethod, therefore we need permission to access the member\n-        try {\n-            AccessController.doPrivileged(\n-                new PrivilegedExceptionAction<>() {\n-                    public Void run() throws NoSuchMethodException {\n-                        Class<?>[] cl = new Class<?>[1];\n-                        cl[0] = DatagramPacket.class;\n-                        impl.getClass().getDeclaredMethod(\"peekData\", cl);\n-                        return null;\n-                    }\n-                });\n-            return false;\n-        } catch (java.security.PrivilegedActionException e) {\n-            return true;\n-        }\n-    }\n-\n@@ -388,10 +345,3 @@\n-                        if (!oldImpl) {\n-                            \/\/ We can use the new peekData() API\n-                            DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);\n-                            peekPort = getImpl().peekData(peekPacket);\n-                            peekAd = peekPacket.getAddress().getHostAddress();\n-                        } else {\n-                            InetAddress adr = new InetAddress();\n-                            peekPort = getImpl().peek(adr);\n-                            peekAd = adr.getHostAddress();\n-                        }\n+                        DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);\n+                        peekPort = getImpl().peekData(peekPacket);\n+                        peekAd = peekPacket.getAddress().getHostAddress();\n@@ -421,1 +371,1 @@\n-            if ((connectState == ST_CONNECTED_NO_IMPL) || explicitFilter) {\n+            if (explicitFilter) {\n@@ -432,10 +382,3 @@\n-                    if (!oldImpl) {\n-                        \/\/ We can use the new peekData() API\n-                        DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);\n-                        peekPort = getImpl().peekData(peekPacket);\n-                        peekAddress = peekPacket.getAddress();\n-                    } else {\n-                        \/\/ this api only works for IPv4\n-                        peekAddress = new InetAddress();\n-                        peekPort = getImpl().peek(peekAddress);\n-                    }\n+                    DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);\n+                    peekPort = getImpl().peekData(peekPacket);\n+                    peekAddress = peekPacket.getAddress();\n@@ -581,5 +524,1 @@\n-        \/\/ Integer instead of Boolean for compatibility with older DatagramSocketImpl\n-        if (oldImpl)\n-            getImpl().setOption(SocketOptions.SO_REUSEADDR, on ? -1 : 0);\n-        else\n-            getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n+        getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n@@ -812,3 +751,0 @@\n-        if (oldImpl)\n-            throw new UnsupportedOperationException();\n-\n@@ -838,3 +774,0 @@\n-        if (oldImpl)\n-            throw new UnsupportedOperationException();\n-\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetMulticastSocket.java","additions":19,"deletions":86,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260428\n+ * @summary Drop support for pre JDK 1.4 DatagramSocketImpl implementations\n+ * @run testng\/othervm OldDatagramSocketImplTest\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.net.*;\n+import java.io.*;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class OldDatagramSocketImplTest {\n+\n+    InetAddress LOOPBACK = InetAddress.getLoopbackAddress();\n+\n+    @Test\n+    public void testOldImplConnect() {\n+        try (var ds = new DatagramSocket(new OldDatagramSocketImpl()) {}) {\n+            ds.connect(new InetSocketAddress(LOOPBACK, 6667));\n+            throw new RuntimeException(\"ERROR: test failed\");\n+        } catch (SocketException ex) {\n+            assertEquals(ex.getMessage(), \"connect not implemented\");\n+            System.out.println(\"PASSED: default implementation of connect has thrown as expected\");\n+        }\n+    }\n+\n+    @Test\n+    public void testOldImplConnectTwoArgs() {\n+        try (var ds = new DatagramSocket(new OldDatagramSocketImpl()) {}) {\n+            ds.connect(LOOPBACK, 6667);\n+            throw new RuntimeException(\"ERROR: test failed\");\n+        } catch (UncheckedIOException ex) {\n+            assertEquals(ex.getMessage(), \"connect failed\");\n+            System.out.println(\"PASSED: default implementation of connect has thrown as expected\");\n+        }\n+    }\n+\n+    @Test\n+    public void testOldImplDisconnect() {\n+        try (var ds = new DatagramSocket(new OldDatagramSocketImplWithValidConnect()) { }){\n+            ds.connect(LOOPBACK, 6667);\n+            ds.disconnect();\n+            throw new RuntimeException(\"ERROR: test failed\");\n+        } catch (UncheckedIOException ex) {\n+            var innerException = ex.getCause();\n+            assertEquals(innerException.getClass(), SocketException.class);\n+            assertEquals(innerException.getMessage(), \"disconnect not implemented\");\n+            System.out.println(\"PASSED: default implementation of disconnect has thrown as expected\");\n+        }\n+    }\n+\n+    @Test\n+    public void testOldImplPublic() {\n+        try (var ds = new PublicOldDatagramSocketImpl()) {\n+            ds.connect(LOOPBACK, 0);\n+            throw new RuntimeException(\"ERROR: test failed\");\n+        } catch (SocketException ex) {\n+            assertEquals(ex.getMessage(), \"connect not implemented\");\n+            System.out.println(\"PASSED: default implementation of disconnect has thrown as expected\");\n+        }\n+    }\n+    @Test\n+    public void testOldImplPublicDisconnect() {\n+        try (var ds = new PublicOldDatagramSocketImplWithValidConnect()) {\n+            ds.disconnect();\n+            throw new RuntimeException(\"ERROR: test failed\");\n+        } catch (UncheckedIOException ex) {\n+            var innerException = ex.getCause();\n+            assertEquals(innerException.getClass(), SocketException.class);\n+            assertEquals(innerException.getMessage(), \"disconnect not implemented\");\n+            System.out.println(\"PASSED: default implementation of disconnect has thrown as expected\");\n+        }\n+    }\n+\n+    private class OldDatagramSocketImpl extends DatagramSocketImpl implements AutoCloseable {\n+\n+        @Override\n+        protected void create() throws SocketException { }\n+\n+        @Override\n+        protected void bind(int lport, InetAddress laddr) throws SocketException { }\n+\n+        @Override\n+        protected void send(DatagramPacket p) throws IOException { }\n+\n+        @Override\n+        protected int peek(InetAddress i) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected int peekData(DatagramPacket p) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void receive(DatagramPacket p) throws IOException { }\n+\n+        @Override\n+        protected void setTTL(byte ttl) throws IOException { }\n+\n+        @Override\n+        protected byte getTTL() throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void setTimeToLive(int ttl) throws IOException { }\n+\n+        @Override\n+        protected int getTimeToLive() throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void join(InetAddress inetaddr) throws IOException { }\n+\n+        @Override\n+        protected void leave(InetAddress inetaddr) throws IOException { }\n+\n+        @Override\n+        protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException { }\n+\n+        @Override\n+        protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException { }\n+\n+        @Override\n+        public void close() { }\n+\n+        @Override\n+        public void setOption(int optID, Object value) throws SocketException { }\n+\n+        @Override\n+        public Object getOption(int optID) throws SocketException {\n+            return null;\n+        }\n+    }\n+\n+    private class OldDatagramSocketImplWithValidConnect extends DatagramSocketImpl implements AutoCloseable {\n+\n+        @Override\n+        protected void connect(InetAddress address, int port) throws SocketException { }\n+\n+        @Override\n+        protected void create() throws SocketException { }\n+\n+        @Override\n+        protected void bind(int lport, InetAddress laddr) throws SocketException { }\n+\n+        @Override\n+        protected void send(DatagramPacket p) throws IOException { }\n+\n+        @Override\n+        protected int peek(InetAddress i) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected int peekData(DatagramPacket p) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void receive(DatagramPacket p) throws IOException { }\n+\n+        @Override\n+        protected void setTTL(byte ttl) throws IOException { }\n+\n+        @Override\n+        protected byte getTTL() throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void setTimeToLive(int ttl) throws IOException { }\n+\n+        @Override\n+        protected int getTimeToLive() throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void join(InetAddress inetaddr) throws IOException { }\n+\n+        @Override\n+        protected void leave(InetAddress inetaddr) throws IOException { }\n+\n+        @Override\n+        protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException { }\n+\n+        @Override\n+        protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException { }\n+\n+        @Override\n+        public void close() { }\n+\n+        @Override\n+        public void setOption(int optID, Object value) throws SocketException { }\n+\n+        @Override\n+        public Object getOption(int optID) throws SocketException {\n+            return null;\n+        }\n+    }\n+\n+    private class PublicOldDatagramSocketImpl extends OldDatagramSocketImpl {\n+        public void connect(InetAddress addr, int port) throws SocketException { super.connect(addr, port); }\n+    }\n+\n+    private class PublicOldDatagramSocketImplWithValidConnect extends OldDatagramSocketImplWithValidConnect {\n+        public void disconnect() { super.disconnect(); }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/OldDatagramSocketImplTest.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"}]}