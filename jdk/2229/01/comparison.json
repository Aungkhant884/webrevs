{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -44,0 +45,3 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.access.JavaNioAccess;\n+\n@@ -87,0 +91,8 @@\n+    \/\/ Number of references to the shared mapped buffer.  Initialized to unity\n+    \/\/ when the buffer is created by the root spliterator.  Incremented in the\n+    \/\/ sub-spliterator constructor.  Decremented when 'buffer' transitions from\n+    \/\/ non-null to null, either when traversing begins or if the spliterator is\n+    \/\/ closed before traversal.  If the count is zero after decrementing, then\n+    \/\/ the buffer is unmapped.\n+    private AtomicInteger bufRefCount;\n+\n@@ -94,1 +106,2 @@\n-    private FileChannelLinesSpliterator(FileChannel fc, Charset cs, int index, int fence, ByteBuffer buffer) {\n+    private FileChannelLinesSpliterator(FileChannel fc, Charset cs, int index,\n+        int fence, ByteBuffer buffer, AtomicInteger bufRefCount) {\n@@ -96,1 +109,0 @@\n-        this.buffer = buffer;\n@@ -100,0 +112,3 @@\n+        this.buffer = buffer;\n+        this.bufRefCount = bufRefCount;\n+        this.bufRefCount.incrementAndGet();\n@@ -170,1 +185,1 @@\n-            buffer = null;\n+            unmap();\n@@ -181,7 +196,0 @@\n-        \/\/ TODO can the mapped byte buffer be explicitly unmapped?\n-        \/\/ It's possible, via a shared-secret mechanism, when either\n-        \/\/ 1) the spliterator starts traversing, although traversal can\n-        \/\/    happen concurrently for mulitple spliterators, so care is\n-        \/\/    needed in this case; or\n-        \/\/ 2) when the stream is closed using some shared holder to pass\n-        \/\/    the mapped byte buffer when it is created.\n@@ -204,0 +212,1 @@\n+            bufRefCount = new AtomicInteger(1);\n@@ -249,1 +258,2 @@\n-               ? new FileChannelLinesSpliterator(fc, cs, lo, index = mid, b)\n+               ? new FileChannelLinesSpliterator(fc, cs, lo, index = mid,\n+                                                 b, bufRefCount)\n@@ -270,0 +280,18 @@\n+\n+    private void unmap() {\n+        if (buffer != null) {\n+            ByteBuffer b = buffer;\n+            buffer = null;\n+            if (bufRefCount.decrementAndGet() == 0) {\n+                JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n+                try {\n+                    nioAccess.unmapper(b).unmap();\n+                } catch (UnsupportedOperationException ignored) {\n+                }\n+            }\n+        }\n+    }\n+\n+    void close() {\n+        unmap();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/FileChannelLinesSpliterator.java","additions":40,"deletions":12,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4124,3 +4124,5 @@\n-                Spliterator<String> s = new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n-                return StreamSupport.stream(s, false)\n-                        .onClose(Files.asUncheckedRunnable(fc));\n+                FileChannelLinesSpliterator fcls =\n+                    new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n+                return StreamSupport.stream(fcls, false)\n+                        .onClose(Files.asUncheckedRunnable(fc))\n+                        .onClose(() -> fcls.close());\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}