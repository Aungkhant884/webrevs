{"files":[{"patch":"@@ -1120,2 +1120,2 @@\n-        \/\/ Dealing with finite values in exponent range of\n-        \/\/ binary16 (when rounding is done, could still round up)\n+        \/\/ Dealing with finite values in exponent range of binary16\n+        \/\/ (when rounding is done, could still round up)\n@@ -1124,1 +1124,0 @@\n-        short signif_bits;\n@@ -1126,23 +1125,13 @@\n-        if (exp <= -15) { \/\/ scale down to float subnormal range to do rounding\n-            \/\/ Use a float multiply to compute the correct trailing\n-            \/\/ significand bits for a binary16 subnormal.\n-            \/\/\n-            \/\/ The exponent range of normalized binary16 subnormal\n-            \/\/ values is [-24, -15]. The exponent range of float\n-            \/\/ subnormals is [-149, -140]. Multiply abs_f down by\n-            \/\/ 2^(-125) -- since (-125 = -149 - (-24)) -- so that the\n-            \/\/ trailing bits of a subnormal float represent the\n-            \/\/ correct trailing bits of a binary16 subnormal.\n-            exp = -15; \/\/ Subnormal encoding using -E_max.\n-            float f_adjust = abs_f * 0x1.0p-125f;\n-\n-            \/\/ In case the significand rounds up and has a carry\n-            \/\/ propagate all the way up, take the bottom 11 bits\n-            \/\/ rather than bottom 10 bits. Adding this value, rather\n-            \/\/ than OR'ing this value, will cause the right exponent\n-            \/\/ adjustment.\n-            signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x07ff);\n-        } else {\n-            \/\/ All remaining values of f are in the normalized range\n-            \/\/ of binary16 (which is also in the normalized range of\n-            \/\/ float).\n+        \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+        \/\/ the difference expdelta = E_min - exp.  This is the excess\n+        \/\/ shift value, in addition to 13, to be used in the\n+        \/\/ computations below.  Further the (hidden) msb with value 1\n+        \/\/ in f must be involved as well.\n+        int expdelta = 0;\n+        int msb = 0x0000_0000;\n+        if (exp < -14) {\n+            expdelta = -14 - exp;\n+            exp = -15;\n+            msb = 0x0080_0000;\n+        }\n+        int f_signif_bits = doppel & 0x007f_ffff | msb;\n@@ -1150,3 +1139,2 @@\n-            \/\/ Significand bits as if using rounding to zero (truncation).\n-            signif_bits = (short)((doppel & 0x007f_e000) >>\n-                                  (FloatConsts.SIGNIFICAND_WIDTH - 11));\n+        \/\/ Significand bits as if using rounding to zero (truncation).\n+        short signif_bits = (short)(f_signif_bits >> (13 + expdelta));\n@@ -1154,12 +1142,12 @@\n-            \/\/ For round to nearest even, determining whether or not\n-            \/\/ to round up (in magnitude) is a function of the least\n-            \/\/ significant bit (LSB), the next bit position (the round\n-            \/\/ position), and the sticky bit (whether there are any\n-            \/\/ nonzero bits in the exact result to the right of the\n-            \/\/ round digit). An increment occurs in three cases:\n-            \/\/\n-            \/\/ LSB  Round Sticky\n-            \/\/ 0    1     1\n-            \/\/ 1    1     0\n-            \/\/ 1    1     1\n-            \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+        \/\/ For round to nearest even, determining whether or not to\n+        \/\/ round up (in magnitude) is a function of the least\n+        \/\/ significant bit (LSB), the next bit position (the round\n+        \/\/ position), and the sticky bit (whether there are any\n+        \/\/ nonzero bits in the exact result to the right of the round\n+        \/\/ digit). An increment occurs in three cases:\n+        \/\/\n+        \/\/ LSB  Round Sticky\n+        \/\/ 0    1     1\n+        \/\/ 1    1     0\n+        \/\/ 1    1     1\n+        \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n@@ -1167,5 +1155,3 @@\n-            \/\/ Bits of binary16 significand in a float: 0x0007f_e000;\n-            \/\/ therefore, the other quantities of interest are:\n-            int lsb   =  doppel & 0x0000_2000;\n-            int round =  doppel & 0x0000_1000;\n-            int sticky = doppel & 0x0000_0fff;\n+        int lsb    = f_signif_bits & (1 << 13 + expdelta);\n+        int round  = f_signif_bits & (1 << 12 + expdelta);\n+        int sticky = f_signif_bits & ((1 << 12 + expdelta) - 1);\n@@ -1173,3 +1159,2 @@\n-            if (round != 0 && ((lsb | sticky) != 0 )) {\n-                signif_bits++;\n-            }\n+        if (round != 0 && ((lsb | sticky) != 0 )) {\n+            signif_bits++;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":34,"deletions":49,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -418,5 +418,2 @@\n-            if (bin16_1 == bin16_2) {\n-                return true;\n-            } else {\n-                return isNaN(bin16_1) ? isNaN(bin16_2) : false;\n-            }\n+            return (bin16_1 == bin16_2) ||\n+                isNaN(bin16_1) && isNaN(bin16_2);\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16Conversion.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}