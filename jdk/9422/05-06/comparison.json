{"files":[{"patch":"@@ -1036,1 +1036,1 @@\n-        int bin16Exp = (((bin16ExpBits >> 10) - 15));\n+        int bin16Exp = (bin16ExpBits >> 10) - 15;\n@@ -1051,1 +1051,1 @@\n-        assert -14 <= bin16Exp  && bin16Exp <= 15;\n+        assert -15 < bin16Exp  && bin16Exp < 16;\n@@ -1057,3 +1057,3 @@\n-        int result = (floatExpBits |\n-                      (bin16SignifBits << SIGNIF_SHIFT));\n-        return sign * Float.intBitsToFloat(result);\n+        return Float.intBitsToFloat((bin16SignBit << 16) |\n+                                    floatExpBits |\n+                                    (bin16SignifBits << SIGNIF_SHIFT));\n@@ -1110,1 +1110,1 @@\n-        if (abs_f >= (65504.0f + 16.0f) ) {\n+        if (abs_f >= (0x1.ffcp15f + 0x0.002p15f) ) {\n@@ -1112,6 +1112,7 @@\n-        } else {\n-            \/\/ Smallest magnitude nonzero representable binary16 value\n-            \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n-            if (abs_f <= 0x1.0p-25f) { \/\/ Covers float zeros and subnormals.\n-                return sign_bit; \/\/ Positive or negative zero\n-            }\n+        }\n+\n+        \/\/ Smallest magnitude nonzero representable binary16 value\n+        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+        if (abs_f <= 0x1.0p-25f) { \/\/ Covers float zeros and subnormals.\n+            return sign_bit; \/\/ Positive or negative zero\n+        }\n@@ -1119,57 +1120,55 @@\n-            \/\/ Dealing with finite values in exponent range of\n-            \/\/ binary16 (when rounding is done, could still round up)\n-            int exp = Math.getExponent(f);\n-            assert -25 <= exp && exp <= 15;\n-            short signif_bits;\n-\n-            if (exp <= -15) { \/\/ scale down to float subnormal range to do rounding\n-                \/\/ Use a float multiply to compute the correct\n-                \/\/ trailing significand bits for a binary16 subnormal.\n-                \/\/\n-                \/\/ The exponent range of normalized binary16 subnormal\n-                \/\/ values is [-24, -15]. The exponent range of float\n-                \/\/ subnormals is [-149, -140]. Multiply abs_f down by\n-                \/\/ 2^(-125) -- since (-125 = -149 - (-24)) -- so that\n-                \/\/ the trailing bits of a subnormal float represent\n-                \/\/ the correct trailing bits of a binary16 subnormal.\n-                exp = -15; \/\/ Subnormal encoding using -E_max.\n-                float f_adjust = abs_f * 0x1.0p-125f;\n-\n-                \/\/ In case the significand rounds up and has a carry\n-                \/\/ propagate all the way up, take the bottom 11 bits\n-                \/\/ rather than bottom 10 bits. Adding this value,\n-                \/\/ rather than OR'ing this value, will cause the right\n-                \/\/ exponent adjustment.\n-                signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x07ff);\n-            } else {\n-                \/\/ All remaining values of f are in the normalized\n-                \/\/ range of binary16 (which is also in the normalized\n-                \/\/ range of float).\n-\n-                \/\/ Significand bits as if using rounding to zero (truncation).\n-                signif_bits = (short)((doppel & 0x007f_e000) >>\n-                                      (FloatConsts.SIGNIFICAND_WIDTH - 11));\n-\n-                \/\/ For round to nearest even, determining whether or\n-                \/\/ not to round up (in magnitude) is a function of the\n-                \/\/ least significant bit (LSB), the next bit position\n-                \/\/ (the round position), and the sticky bit (whether\n-                \/\/ there are any nonzero bits in the exact result to\n-                \/\/ the right of the round digit). An increment occurs\n-                \/\/ in three cases:\n-                \/\/\n-                \/\/ LSB  Round Sticky\n-                \/\/ 0    1     1\n-                \/\/ 1    1     0\n-                \/\/ 1    1     1\n-                \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n-\n-                \/\/ Bits of binary16 significand in a float: 0x0007f_e000;\n-                \/\/ therefore, the other quantities of interest are:\n-                int lsb   =  doppel & 0x0000_2000;\n-                int round =  doppel & 0x0000_1000;\n-                int sticky = doppel & 0x0000_0fff;\n-\n-                if (round != 0 && ((lsb | sticky) != 0 )) {\n-                    signif_bits++;\n-                }\n+        \/\/ Dealing with finite values in exponent range of\n+        \/\/ binary16 (when rounding is done, could still round up)\n+        int exp = Math.getExponent(f);\n+        assert -25 <= exp && exp <= 15;\n+        short signif_bits;\n+\n+        if (exp <= -15) { \/\/ scale down to float subnormal range to do rounding\n+            \/\/ Use a float multiply to compute the correct trailing\n+            \/\/ significand bits for a binary16 subnormal.\n+            \/\/\n+            \/\/ The exponent range of normalized binary16 subnormal\n+            \/\/ values is [-24, -15]. The exponent range of float\n+            \/\/ subnormals is [-149, -140]. Multiply abs_f down by\n+            \/\/ 2^(-125) -- since (-125 = -149 - (-24)) -- so that the\n+            \/\/ trailing bits of a subnormal float represent the\n+            \/\/ correct trailing bits of a binary16 subnormal.\n+            exp = -15; \/\/ Subnormal encoding using -E_max.\n+            float f_adjust = abs_f * 0x1.0p-125f;\n+\n+            \/\/ In case the significand rounds up and has a carry\n+            \/\/ propagate all the way up, take the bottom 11 bits\n+            \/\/ rather than bottom 10 bits. Adding this value, rather\n+            \/\/ than OR'ing this value, will cause the right exponent\n+            \/\/ adjustment.\n+            signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x07ff);\n+        } else {\n+            \/\/ All remaining values of f are in the normalized range\n+            \/\/ of binary16 (which is also in the normalized range of\n+            \/\/ float).\n+\n+            \/\/ Significand bits as if using rounding to zero (truncation).\n+            signif_bits = (short)((doppel & 0x007f_e000) >>\n+                                  (FloatConsts.SIGNIFICAND_WIDTH - 11));\n+\n+            \/\/ For round to nearest even, determining whether or not\n+            \/\/ to round up (in magnitude) is a function of the least\n+            \/\/ significant bit (LSB), the next bit position (the round\n+            \/\/ position), and the sticky bit (whether there are any\n+            \/\/ nonzero bits in the exact result to the right of the\n+            \/\/ round digit). An increment occurs in three cases:\n+            \/\/\n+            \/\/ LSB  Round Sticky\n+            \/\/ 0    1     1\n+            \/\/ 1    1     0\n+            \/\/ 1    1     1\n+            \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+            \/\/ Bits of binary16 significand in a float: 0x0007f_e000;\n+            \/\/ therefore, the other quantities of interest are:\n+            int lsb   =  doppel & 0x0000_2000;\n+            int round =  doppel & 0x0000_1000;\n+            int sticky = doppel & 0x0000_0fff;\n+\n+            if (round != 0 && ((lsb | sticky) != 0 )) {\n+                signif_bits++;\n@@ -1177,0 +1176,1 @@\n+        }\n@@ -1178,5 +1178,4 @@\n-            \/\/ No bits set in significand beyond the *first* exponent\n-            \/\/ bit, not just the sigificand; quantity is added to the\n-            \/\/ exponent to implement a carry out from rounding the\n-            \/\/ significand.\n-            assert (0xf800 & signif_bits) == 0x0;\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the sigificand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xf800 & signif_bits) == 0x0;\n@@ -1184,3 +1183,2 @@\n-            return (short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n-        }\n-}\n+        return (short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":75,"deletions":77,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import static java.lang.Float.*;\n-\n@@ -100,1 +98,1 @@\n-    };\n+    }\n@@ -403,1 +401,0 @@\n-        public static final short NEGATIVE_INFINITY = (short)0xfc00;\n@@ -409,1 +406,0 @@\n-        public static final short NEGATIVE_ZERO     = (short)0x8000;\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16Conversion.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import static java.lang.Float.*;\n-\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}