{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.math.FloatConsts;\n@@ -978,0 +979,207 @@\n+    \/**\n+     * {@return the {@code float} value closest to the numerical value\n+     * of the argument, a floating-point binary16 value encoded in a\n+     * {@code short}} The conversion is exact; all binary16 values can\n+     * be exactly represented in {@code float}.\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * same sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the same sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * <h4><a id=binary16Format>IEEE 754 binary16 format<\/a><\/h4>\n+     * The IEEE 754 standard defines binary16 as a 16-bit format, along\n+     * with the 32-bit binary32 format (corresponding to the {@code\n+     * float} type) and the 64-bit binary64 format (corresponding to\n+     * the {@code double} type). The binary16 format is similar to the\n+     * other IEEE 754 formats, except smaller, having all the usual\n+     * IEEE 754 values such as NaN, signed infinities, signed zeros,\n+     * and subnormals. The parameters (JLS {@jls 4.2.3}) for the\n+     * binary16 format are N = 11 precision bits, K = 5 exponent bits,\n+     * <i>E<\/i><sub><i>max<\/i><\/sub> = 15, and\n+     * <i>E<\/i><sub><i>min<\/i><\/sub> = -14.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754 from the binary16 format to the binary32 format.\n+     * The operation of this method is analogous to a primitive\n+     * widening conversion (JLS {@jls 5.1.2}).\n+     *\n+     * @param floatBinary16 the binary16 value to convert to {@code float}\n+     * @since 20\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static float float16ToFloat(short floatBinary16) {\n+        \/*\n+         * The binary16 format has 1 sign bit, 5 exponent bits, and 10\n+         * significand bits. The exponent bias is 15.\n+         *\/\n+        int bin16arg = (int)floatBinary16;\n+        int bin16SignBit     = 0x8000 & bin16arg;\n+        int bin16ExpBits     = 0x7c00 & bin16arg;\n+        int bin16SignifBits  = 0x03FF & bin16arg;\n+\n+        \/\/ Shift left difference in the number of significand bits in\n+        \/\/ the float and binary16 formats\n+        final int SIGNIF_SHIFT = (FloatConsts.SIGNIFICAND_WIDTH - 11);\n+\n+        float sign = (bin16SignBit != 0) ? -1.0f : 1.0f;\n+\n+        \/\/ Extract binary16 exponent, remove its bias, add in the bias\n+        \/\/ of a float exponent and shift to correct bit location\n+        \/\/ (significand width includes the implicit bit so shift one\n+        \/\/ less).\n+        int bin16Exp = (bin16ExpBits >> 10) - 15;\n+        if (bin16Exp == -15) {\n+            \/\/ For subnormal binary16 values and 0, the numerical\n+            \/\/ value is 2^24 * the significand as an integer (no\n+            \/\/ implicit bit).\n+            return sign * (0x1p-24f * bin16SignifBits);\n+        } else if (bin16Exp == 16) {\n+            return (bin16SignifBits == 0) ?\n+                sign * Float.POSITIVE_INFINITY :\n+                Float.intBitsToFloat((bin16SignBit << 16) |\n+                                     0x7f80_0000 |\n+                                     \/\/ Preserve NaN signif bits\n+                                     ( bin16SignifBits << SIGNIF_SHIFT ));\n+        }\n+\n+        assert -15 < bin16Exp  && bin16Exp < 16;\n+\n+        int floatExpBits = (bin16Exp + FloatConsts.EXP_BIAS)\n+            << (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+\n+        \/\/ Compute and combine result sign, exponent, and significand bits.\n+        return Float.intBitsToFloat((bin16SignBit << 16) |\n+                                    floatExpBits |\n+                                    (bin16SignifBits << SIGNIF_SHIFT));\n+    }\n+\n+    \/**\n+     * {@return the floating-point binary16 value, encoded in a {@code\n+     * short}, closest in value to the argument}\n+     * The conversion is computed under the {@linkplain\n+     * java.math.RoundingMode#HALF_EVEN round to nearest even rounding\n+     * mode}.\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * same sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the same sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * The <a href=\"#binary16Format\">binary16 format<\/a> is discussed in\n+     * more detail in the {@link #float16ToFloat} method.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754 from the binary32 format to the binary16 format.\n+     * The operation of this method is analogous to a primitive\n+     * narrowing conversion (JLS {@jls 5.1.3}).\n+     *\n+     * @param f the {@code float} value to convert to binary16\n+     * @since 20\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static short floatToFloat16(float f) {\n+        int doppel = Float.floatToRawIntBits(f);\n+        short sign_bit = (short)((doppel & 0x8000_0000) >> 16);\n+\n+        if (Float.isNaN(f)) {\n+            \/\/ Preserve sign and attempt to preserve significand bits\n+            return (short)(sign_bit\n+                    | 0x7c00 \/\/ max exponent + 1\n+                    \/\/ Preserve high order bit of float NaN in the\n+                    \/\/ binary16 result NaN (tenth bit); OR in remaining\n+                    \/\/ bits into lower 9 bits of binary 16 significand.\n+                    | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+                    | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+                    | (doppel & 0x0000_000f));     \/\/  4 bits\n+        }\n+\n+        float abs_f = Math.abs(f);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_f >= (0x1.ffcp15f + 0x0.002p15f) ) {\n+            return (short)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+        }\n+\n+        \/\/ Smallest magnitude nonzero representable binary16 value\n+        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+        if (abs_f <= 0x1.0p-25f) { \/\/ Covers float zeros and subnormals.\n+            return sign_bit; \/\/ Positive or negative zero\n+        }\n+\n+        \/\/ Dealing with finite values in exponent range of\n+        \/\/ binary16 (when rounding is done, could still round up)\n+        int exp = Math.getExponent(f);\n+        assert -25 <= exp && exp <= 15;\n+        short signif_bits;\n+\n+        if (exp <= -15) { \/\/ scale down to float subnormal range to do rounding\n+            \/\/ Use a float multiply to compute the correct trailing\n+            \/\/ significand bits for a binary16 subnormal.\n+            \/\/\n+            \/\/ The exponent range of normalized binary16 subnormal\n+            \/\/ values is [-24, -15]. The exponent range of float\n+            \/\/ subnormals is [-149, -140]. Multiply abs_f down by\n+            \/\/ 2^(-125) -- since (-125 = -149 - (-24)) -- so that the\n+            \/\/ trailing bits of a subnormal float represent the\n+            \/\/ correct trailing bits of a binary16 subnormal.\n+            exp = -15; \/\/ Subnormal encoding using -E_max.\n+            float f_adjust = abs_f * 0x1.0p-125f;\n+\n+            \/\/ In case the significand rounds up and has a carry\n+            \/\/ propagate all the way up, take the bottom 11 bits\n+            \/\/ rather than bottom 10 bits. Adding this value, rather\n+            \/\/ than OR'ing this value, will cause the right exponent\n+            \/\/ adjustment.\n+            signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x07ff);\n+        } else {\n+            \/\/ All remaining values of f are in the normalized range\n+            \/\/ of binary16 (which is also in the normalized range of\n+            \/\/ float).\n+\n+            \/\/ Significand bits as if using rounding to zero (truncation).\n+            signif_bits = (short)((doppel & 0x007f_e000) >>\n+                                  (FloatConsts.SIGNIFICAND_WIDTH - 11));\n+\n+            \/\/ For round to nearest even, determining whether or not\n+            \/\/ to round up (in magnitude) is a function of the least\n+            \/\/ significant bit (LSB), the next bit position (the round\n+            \/\/ position), and the sticky bit (whether there are any\n+            \/\/ nonzero bits in the exact result to the right of the\n+            \/\/ round digit). An increment occurs in three cases:\n+            \/\/\n+            \/\/ LSB  Round Sticky\n+            \/\/ 0    1     1\n+            \/\/ 1    1     0\n+            \/\/ 1    1     1\n+            \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+            \/\/ Bits of binary16 significand in a float: 0x0007f_e000;\n+            \/\/ therefore, the other quantities of interest are:\n+            int lsb   =  doppel & 0x0000_2000;\n+            int round =  doppel & 0x0000_1000;\n+            int sticky = doppel & 0x0000_0fff;\n+\n+            if (round != 0 && ((lsb | sticky) != 0 )) {\n+                signif_bits++;\n+            }\n+        }\n+\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the sigificand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xf800 & signif_bits) == 0x0;\n+\n+        return (short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -0,0 +1,425 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289551\n+ * @summary Verify conversion between float and the binary16 format\n+ * @library ..\/Math\n+ * @build FloatConsts\n+ * @run main Binary16Conversion\n+ *\/\n+\n+public class Binary16Conversion {\n+    public static void main(String... argv) {\n+        int errors = 0;\n+        errors += binary16RoundTrip();\n+        \/\/ Note that helper methods do sign-symmetric testing\n+        errors += binary16CardinalValues();\n+        errors += roundFloatToBinary16();\n+        errors += roundFloatToBinary16HalfWayCases();\n+        errors += roundFloatToBinary16FullBinade();\n+        errors += alternativeImplementation();\n+\n+        if (errors > 0)\n+            throw new RuntimeException(errors + \" errors\");\n+    }\n+\n+    \/*\n+     * Put all 16-bit values through a conversion loop and make sure\n+     * the values are preserved (NaN bit patterns notwithstanding).\n+     *\/\n+    private static int binary16RoundTrip() {\n+        int errors = 0;\n+        for (int i = Short.MIN_VALUE; i < Short.MAX_VALUE; i++) {\n+            short s = (short)i;\n+            float f =  Float.float16ToFloat(s);\n+            short s2 = Float.floatToFloat16(f);\n+\n+            if (!Binary16.equivalent(s, s2)) {\n+                errors++;\n+                System.out.println(\"Roundtrip failure on \" +\n+                                   Integer.toHexString(0xFFFF & (int)s) +\n+                                   \"\\t got back \" + Integer.toHexString(0xFFFF & (int)s2));\n+            }\n+        }\n+        return errors;\n+    }\n+\n+    private static int binary16CardinalValues() {\n+        int errors = 0;\n+        \/\/ Encode short value for different binary16 cardinal values as an\n+        \/\/ integer-valued float.\n+        float[][] testCases = {\n+            {Binary16.POSITIVE_ZERO,         +0.0f},\n+            {Binary16.MIN_VALUE,              0x1.0p-24f},\n+            {Binary16.MAX_SUBNORMAL,          0x1.ff8p-15f},\n+            {Binary16.MIN_NORMAL,             0x1.0p-14f},\n+            {Binary16.ONE,                    1.0f},\n+            {Binary16.MAX_VALUE,              65504.0f},\n+            {Binary16.POSITIVE_INFINITY,      Float.POSITIVE_INFINITY},\n+        };\n+\n+        \/\/ Check conversions in both directions\n+\n+        \/\/ short -> float\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError((short)testCase[0],\n+                                            testCase[1]);\n+        }\n+\n+        \/\/ float -> short\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError(testCase[1],\n+                                            (short)testCase[0]);\n+        }\n+\n+        return errors;\n+    }\n+\n+    private static int roundFloatToBinary16() {\n+        int errors = 0;\n+\n+        float[][] testCases = {\n+            \/\/ Test all combinations of LSB, round, and sticky bit\n+\n+            \/\/ LSB = 0, test combination of round and sticky\n+            {0x1.ff8000p-1f,       (short)0x3bfe},              \/\/ round = 0, sticky = 0\n+            {0x1.ff8010p-1f,       (short)0x3bfe},              \/\/ round = 0, sticky = 1\n+            {0x1.ffa000p-1f,       (short)0x3bfe},              \/\/ round = 1, sticky = 0\n+            {0x1.ffa010p-1f,       (short)0x3bff},              \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ LSB = 1, test combination of round and sticky\n+            {0x1.ffc000p-1f,       Binary16.ONE-1},             \/\/ round = 0, sticky = 0\n+            {0x1.ffc010p-1f,       Binary16.ONE-1},             \/\/ round = 0, sticky = 1\n+            {0x1.ffe000p-1f,       Binary16.ONE},               \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffe010p-1f,       Binary16.ONE},               \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ Test subnormal rounding\n+            \/\/ Largest subnormal binary16 0x03ff => 0x1.ff8p-15f; LSB = 1\n+            {0x1.ff8000p-15f,      Binary16.MAX_SUBNORMAL},     \/\/ round = 0, sticky = 0\n+            {0x1.ff8010p-15f,      Binary16.MAX_SUBNORMAL},     \/\/ round = 0, sticky = 1\n+            {0x1.ffc000p-15f,      Binary16.MIN_NORMAL},        \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffc010p-15f,      Binary16.MIN_NORMAL},        \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ Test rounding near binary16 MIN_VALUE\n+            \/\/ Smallest in magnitude subnormal binary16 value 0x0001 => 0x1.0p-24f\n+            \/\/ Half-way case,0x1.0p-25f, and smaller should round down to zero\n+            {0x1.fffffep-26f,      Binary16.POSITIVE_ZERO},     \/\/ nextDown in float\n+            {0x1.000000p-25f,      Binary16.POSITIVE_ZERO},\n+            {0x1.000002p-25f,      Binary16.MIN_VALUE},         \/\/ nextUp in float\n+            {0x1.100000p-25f,      Binary16.MIN_VALUE},\n+\n+            \/\/ Test rounding near overflow threshold\n+            \/\/ Largest normal binary16 number 0x7bff => 0x1.ffcp15f; LSB = 1\n+            {0x1.ffc000p15f,       Binary16.MAX_VALUE},         \/\/ round = 0, sticky = 0\n+            {0x1.ffc010p15f,       Binary16.MAX_VALUE},         \/\/ round = 0, sticky = 1\n+            {0x1.ffe000p15f,       Binary16.POSITIVE_INFINITY}, \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffe010p15f,       Binary16.POSITIVE_INFINITY}, \/\/ round = 1, sticky = 1 => ++\n+        };\n+\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError(testCase[0],\n+                                            (short)testCase[1]);\n+        }\n+        return errors;\n+    }\n+\n+    private static int roundFloatToBinary16HalfWayCases() {\n+        int errors = 0;\n+\n+        \/\/ Test rounding of exact half-way cases between each pair of\n+        \/\/ finite exactly-representable binary16 numbers. Also test\n+        \/\/ rounding of half-way +\/- ulp of the *float* value.\n+        \/\/ Additionally, test +\/- float ulp of the endpoints. (Other\n+        \/\/ tests in this file make sure all short values round-trip so\n+        \/\/ that doesn't need to be tested here.)\n+\n+        for (int i = Binary16.POSITIVE_ZERO; \/\/ 0x0000\n+             i    <= Binary16.MAX_VALUE;     \/\/ 0x7bff\n+             i += 2) {     \/\/ Check every even\/odd pair once\n+            short lower = (short) i;\n+            short upper = (short)(i+1);\n+\n+            float lowerFloat = Float.float16ToFloat(lower);\n+            float upperFloat = Float.float16ToFloat(upper);\n+            assert lowerFloat < upperFloat;\n+\n+            float midway = (lowerFloat + upperFloat) * 0.5f; \/\/ Exact midpoint\n+\n+            errors += compareAndReportError(Math.nextUp(lowerFloat),   lower);\n+            errors += compareAndReportError(Math.nextDown(midway),     lower);\n+\n+            \/\/ Under round to nearest even, the midway point will\n+            \/\/ round *down* to the (even) lower endpoint.\n+            errors += compareAndReportError(              midway,      lower);\n+\n+            errors += compareAndReportError(Math.nextUp(  midway),     upper);\n+            errors += compareAndReportError(Math.nextDown(upperFloat), upper);\n+        }\n+\n+        \/\/ More testing around the overflow threshold\n+        \/\/ Binary16.ulp(Binary16.MAX_VALUE) == 32.0f; test around Binary16.MAX_VALUE + 1\/2 ulp\n+        float binary16_MAX_VALUE = Float.float16ToFloat(Binary16.MAX_VALUE);\n+        float binary16_MAX_VALUE_halfUlp = binary16_MAX_VALUE + 16.0f;\n+\n+        errors += compareAndReportError(Math.nextDown(binary16_MAX_VALUE), Binary16.MAX_VALUE);\n+        errors += compareAndReportError(              binary16_MAX_VALUE,  Binary16.MAX_VALUE);\n+        errors += compareAndReportError(Math.nextUp(  binary16_MAX_VALUE), Binary16.MAX_VALUE);\n+\n+        \/\/ Binary16.MAX_VALUE is an \"odd\" value since its LSB = 1 so\n+        \/\/ the half-way value greater than Binary16.MAX_VALUE should\n+        \/\/ round up to the next even value, in this case Binary16.POSITIVE_INFINITY.\n+        errors += compareAndReportError(Math.nextDown(binary16_MAX_VALUE_halfUlp), Binary16.MAX_VALUE);\n+        errors += compareAndReportError(              binary16_MAX_VALUE_halfUlp,  Binary16.POSITIVE_INFINITY);\n+        errors += compareAndReportError(Math.nextUp(  binary16_MAX_VALUE_halfUlp), Binary16.POSITIVE_INFINITY);\n+\n+        return errors;\n+    }\n+\n+    private static int compareAndReportError(float input,\n+                                             short expected) {\n+        \/\/ Round to nearest even is sign symmetric\n+        return compareAndReportError0( input,                 expected) +\n+               compareAndReportError0(-input, Binary16.negate(expected));\n+    }\n+\n+    private static int compareAndReportError0(float input,\n+                                              short expected) {\n+        short actual = Float.floatToFloat16(input);\n+        if (!Binary16.equivalent(actual, expected)) {\n+            System.out.println(\"Unexpected result of converting \" +\n+                               Float.toHexString(input) +\n+                               \" to short. Expected 0x\" + Integer.toHexString(0xFFFF & expected) +\n+                               \" got 0x\" + Integer.toHexString(0xFFFF & actual));\n+            return 1;\n+            }\n+        return 0;\n+    }\n+\n+    private static int compareAndReportError0(short input,\n+                                              float expected) {\n+        float actual = Float.float16ToFloat(input);\n+        if (Float.compare(actual, expected) != 0) {\n+            System.out.println(\"Unexpected result of converting \" +\n+                               Integer.toHexString(input & 0xFFFF) +\n+                               \" to float. Expected \" + Float.toHexString(expected) +\n+                               \" got \" + Float.toHexString(actual));\n+            return 1;\n+            }\n+        return 0;\n+    }\n+\n+    private static int compareAndReportError(short input,\n+                                             float expected) {\n+        \/\/ Round to nearest even is sign symmetric\n+        return compareAndReportError0(                input,   expected) +\n+               compareAndReportError0(Binary16.negate(input), -expected);\n+    }\n+\n+    private static int roundFloatToBinary16FullBinade() {\n+        int errors = 0;\n+\n+        \/\/ For each float value between 1.0 and less than 2.0\n+        \/\/ (i.e. set of float values with an exponent of 0), convert\n+        \/\/ each value to binary16 and then convert that binary16 value\n+        \/\/ back to float.\n+        \/\/\n+        \/\/ Any exponent could be used; the maximum exponent for normal\n+        \/\/ values would not exercise the full set of code paths since\n+        \/\/ there is an up-front check on values that would overflow,\n+        \/\/ which correspond to a ripple-carry of the significand that\n+        \/\/ bumps the exponent.\n+        short previous = (short)0;\n+        for (int i = Float.floatToIntBits(1.0f);\n+             i <= Float.floatToIntBits(Math.nextDown(2.0f));\n+             i++) {\n+            \/\/ (Could also express the loop control directly in terms\n+            \/\/ of floating-point operations, incrementing by ulp(1.0),\n+            \/\/ etc.)\n+\n+            float f = Float.intBitsToFloat(i);\n+            short f_as_bin16 = Float.floatToFloat16(f);\n+            short f_as_bin16_down = (short)(f_as_bin16 - 1);\n+            short f_as_bin16_up   = (short)(f_as_bin16 + 1);\n+\n+            \/\/ Across successive float values to convert to binary16,\n+            \/\/ the binary16 results should be semi-monotonic,\n+            \/\/ non-decreasing in this case.\n+\n+            \/\/ Only positive binary16 values so can compare using integer operations\n+            if (f_as_bin16 < previous) {\n+                errors++;\n+                System.out.println(\"Semi-monotonicity violation observed on \" +\n+                                   Integer.toHexString(0xfff & f_as_bin16));\n+            }\n+            previous = f_as_bin16;\n+\n+            \/\/ If round-to-nearest was correctly done, when exactly\n+            \/\/ mapped back to float, f_as_bin16 should be at least as\n+            \/\/ close as either of its neighbors to the original value\n+            \/\/ of f.\n+\n+            float f_prime_down = Float.float16ToFloat(f_as_bin16_down);\n+            float f_prime      = Float.float16ToFloat(f_as_bin16);\n+            float f_prime_up   = Float.float16ToFloat(f_as_bin16_up);\n+\n+            float f_prime_diff = Math.abs(f - f_prime);\n+            if (f_prime_diff == 0.0) {\n+                continue;\n+            }\n+            float f_prime_down_diff = Math.abs(f - f_prime_down);\n+            float f_prime_up_diff   = Math.abs(f - f_prime_up);\n+\n+            if (f_prime_diff > f_prime_down_diff ||\n+                f_prime_diff > f_prime_up_diff) {\n+                errors++;\n+                System.out.println(\"Round-to-nearest violation on converting \" +\n+                                   Float.toHexString(f) + \" to binary16 and back.\");\n+            }\n+        }\n+        return errors;\n+    }\n+\n+    private static int alternativeImplementation() {\n+        int errors = 0;\n+\n+        \/\/ For exhaustive test of all float values use\n+        \/\/ for (long ell = Integer.MIN_VALUE; ell <= Integer.MAX_VALUE; ell++) {\n+\n+        for (long ell   = Float.floatToIntBits(2.0f);\n+             ell       <= Float.floatToIntBits(4.0f);\n+             ell++) {\n+            float f = Float.intBitsToFloat((int)ell);\n+            short s1 = Float.floatToFloat16(f);\n+            short s2 =    altFloatToFloat16(f);\n+\n+            if (s1 != s2) {\n+                errors++;\n+                System.out.println(\"Different conversion of float value \" + Float.toHexString(f));\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n+    \/*\n+     * Rely on float operations to do rounding in both normal and\n+     * subnormal binary16 cases.\n+     *\/\n+    public static short altFloatToFloat16(float f) {\n+        int doppel = Float.floatToRawIntBits(f);\n+        short sign_bit = (short)((doppel & 0x8000_0000) >> 16);\n+\n+        if (Float.isNaN(f)) {\n+            \/\/ Preserve sign and attempt to preserve significand bits\n+            return (short)(sign_bit\n+                    | 0x7c00 \/\/ max exponent + 1\n+                    \/\/ Preserve high order bit of float NaN in the\n+                    \/\/ binary16 result NaN (tenth bit); OR in remaining\n+                    \/\/ bits into lower 9 bits of binary 16 significand.\n+                    | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+                    | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+                    | (doppel & 0x0000_000f));     \/\/  4 bits\n+        }\n+\n+        float abs_f = Math.abs(f);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_f >= (65504.0f + 16.0f) ) {\n+            return (short)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+        } else {\n+            \/\/ Smallest magnitude nonzero representable binary16 value\n+            \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+            if (abs_f <= 0x1.0p-25f) { \/\/ Covers float zeros and subnormals.\n+                return sign_bit; \/\/ Positive or negative zero\n+            }\n+\n+            \/\/ Dealing with finite values in exponent range of\n+            \/\/ binary16 (when rounding is done, could still round up)\n+            int exp = Math.getExponent(f);\n+            assert -25 <= exp && exp <= 15;\n+            short signif_bits;\n+\n+            if (exp <= -15) { \/\/ scale down to float subnormal range to do rounding\n+                \/\/ Use a float multiply to compute the correct\n+                \/\/ trailing significand bits for a binary16 subnormal.\n+                \/\/\n+                \/\/ The exponent range of normalized binary16 subnormal\n+                \/\/ values is [-24, -15]. The exponent range of float\n+                \/\/ subnormals is [-149, -140]. Multiply abs_f down by\n+                \/\/ 2^(-125) -- since (-125 = -149 - (-24)) -- so that\n+                \/\/ the trailing bits of a subnormal float represent\n+                \/\/ the correct trailing bits of a binary16 subnormal.\n+                exp = -15; \/\/ Subnormal encoding using -E_max.\n+                float f_adjust = abs_f * 0x1.0p-125f;\n+\n+                \/\/ In case the significand rounds up and has a carry\n+                \/\/ propagate all the way up, take the bottom 11 bits\n+                \/\/ rather than bottom 10 bits. Adding this value,\n+                \/\/ rather than OR'ing htis value, will cause the right\n+                \/\/ exponent adjustment.\n+                signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x07ff);\n+                return (short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+            } else {\n+                \/\/ Scale down to subnormal range to round off excess bits\n+                int scalingExp = -139 - exp;\n+                float scaled = Math.scalb(Math.scalb(f, scalingExp),\n+                                                       -scalingExp);\n+                exp = Math.getExponent(scaled);\n+                doppel = Float.floatToRawIntBits(scaled);\n+\n+                signif_bits = (short)((doppel & 0x007f_e000) >>\n+                                      (FloatConsts.SIGNIFICAND_WIDTH - 11));\n+                return (short)(sign_bit | ( ((exp + 15) << 10) | signif_bits ) );\n+            }\n+        }\n+    }\n+\n+    public static class Binary16 {\n+        public static final short POSITIVE_INFINITY = (short)0x7c00;\n+        public static final short MAX_VALUE         = 0x7bff;\n+        public static final short ONE               = 0x3c00;\n+        public static final short MIN_NORMAL        = 0x0400;\n+        public static final short MAX_SUBNORMAL     = 0x03ff;\n+        public static final short MIN_VALUE         = 0x0001;\n+        public static final short POSITIVE_ZERO     = 0x0000;\n+\n+        public static boolean isNaN(short binary16) {\n+            return ((binary16 & 0x7c00) == 0x7c00) \/\/ Max exponent and...\n+                && ((binary16 & 0x03ff) != 0 );    \/\/ significand nonzero.\n+        }\n+\n+        public static short negate(short binary16) {\n+            return (short)(binary16 ^ 0x8000 ); \/\/ Flip only sign bit.\n+        }\n+\n+        public static boolean equivalent(short bin16_1, short bin16_2) {\n+            if (bin16_1 == bin16_2) {\n+                return true;\n+            } else {\n+                return isNaN(bin16_1) ? isNaN(bin16_2) : false;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16Conversion.java","additions":425,"deletions":0,"binary":false,"changes":425,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289551\n+ * @summary Verify NaN sign and significand bits are preserved across conversions\n+ *\/\n+\n+\/*\n+ * The behavior tested below is an implementation property not\n+ * required by the specification. It would be acceptable for this\n+ * information to not be preserved (as long as a NaN is returned) if,\n+ * say, a intrinsified version using native hardware instructions\n+ * behaved differently.\n+ *\n+ * If that is the case, this test should be modified to disable\n+ * intrinsics or to otherwise not run on platforms with an differently\n+ * behaving intrinsic.\n+ *\/\n+public class Binary16ConversionNaN {\n+    public static void main(String... argv) {\n+        int errors = 0;\n+        errors += binary16NaNRoundTrip();\n+\n+        if (errors > 0)\n+            throw new RuntimeException(errors + \" errors\");\n+    }\n+\n+    \/*\n+     * Put all 16-bit NaN values through a conversion loop and make\n+     * sure the significand, sign, and exponent are all preserved.\n+     *\/\n+    private static int binary16NaNRoundTrip() {\n+        int errors = 0;\n+        final int NAN_EXPONENT = 0x7c00;\n+        final int SIGN_BIT     = 0x8000;\n+\n+        \/\/ A NaN has a nonzero significand\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            short binary16NaN = (short)(NAN_EXPONENT | i);\n+            assert isNaN(binary16NaN);\n+            errors += testRoundTrip(                   binary16NaN);\n+            errors += testRoundTrip((short)(SIGN_BIT | binary16NaN));\n+        }\n+        return errors;\n+    }\n+\n+    private static boolean isNaN(short binary16) {\n+        return ((binary16 & 0x7c00) == 0x7c00) \/\/ Max exponent and...\n+            && ((binary16 & 0x03ff) != 0 );    \/\/ significand nonzero.\n+    }\n+\n+    private static int testRoundTrip(int i) {\n+        int errors = 0;\n+        short s = (short)i;\n+        float f =  Float.float16ToFloat(s);\n+        short s2 = Float.floatToFloat16(f);\n+\n+        if (s != s2) {\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(0xFFFF & (int)s) +\n+                               \"\\t got back \" + Integer.toHexString(0xFFFF & (int)s2));\n+        }\n+        return errors;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}