{"files":[{"patch":"@@ -995,1 +995,1 @@\n-     * IEEE 754 standard defines binary16 as a 16-bit format, along\n+     * The IEEE 754 standard defines binary16 as a 16-bit format, along\n@@ -1026,0 +1026,4 @@\n+        \/\/ Shift left difference in the number of significand bits in\n+        \/\/ the float and binary16 formats\n+        final int SIGNIF_SHIFT = (FloatConsts.SIGNIFICAND_WIDTH - 11);\n+\n@@ -1041,1 +1045,2 @@\n-                Float.NaN; \/\/ Could try to preserve NaN significand bits\n+                Float.intBitsToFloat(0x7f80_0000 | \/\/ Preserve NaN signif bits\n+                                     ( bin16SignifBits << SIGNIF_SHIFT ));\n@@ -1049,7 +1054,3 @@\n-        int result = 0;\n-        \/\/ Compute result sign, exponent, and significand bits.\n-        result |= (floatExpBits |\n-                   \/\/ Shift left difference in the number of\n-                   \/\/ significand bits in the float and binary16\n-                   \/\/ formats\n-                   (bin16SignifBits << (FloatConsts.SIGNIFICAND_WIDTH - 11)));\n+        \/\/ Compute and combine result sign, exponent, and significand bits.\n+        int result = (floatExpBits |\n+                      (bin16SignifBits << SIGNIF_SHIFT));\n@@ -1089,0 +1090,3 @@\n+        int doppel = Float.floatToRawIntBits(f);\n+        short sign_bit = (short)((doppel >> 16) & 0x8000);\n+\n@@ -1090,3 +1094,9 @@\n-            \/\/ Arbitrary binary16 NaN value; could try to preserve the\n-            \/\/ sign and some bits of the NaN significand.\n-            return (short)0x7fff;\n+            \/\/ Preserve sign and attempt to preserve significand bits\n+            return (short)(sign_bit\n+                    | 0x7c00 \/\/ max exponent + 1\n+                    \/\/ Preserve high order bit of float NaN in the\n+                    \/\/ binary16 result NaN (tenth bit); OR in remaining\n+                    \/\/ bits into lower 9 bits of binary 16 significand.\n+                    | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+                    | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+                    | (doppel & 0x0000_000f));     \/\/  4 bits\n@@ -1096,2 +1106,0 @@\n-        int doppel = Float.floatToRawIntBits(f);\n-        short sign_bit = (short)((doppel >> 16) & 0x8000);\n@@ -1100,1 +1108,1 @@\n-        if (abs_f > (65504.0f + 16.0f) ) {\n+        if (abs_f >= (65504.0f + 16.0f) ) {\n@@ -1120,2 +1128,2 @@\n-                \/\/ values is [-15, -24]. The exponent range of float\n-                \/\/ subnormals is [-140, -149]. Multiply abs_f down by\n+                \/\/ values is [-24, -15]. The exponent range of float\n+                \/\/ subnormals is [-149, -140]. Multiply abs_f down by\n@@ -1127,8 +1135,7 @@\n-                signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x03ff);\n-                if (signif_bits == 0) {\n-                    \/\/ Since zero cases have already been handled, if\n-                    \/\/ the significand is all zeros, there was a\n-                    \/\/ round-up to normal range so the exponent needs\n-                    \/\/ to be adjusted accordingly.\n-                    exp++;\n-                }\n+\n+                \/\/ In case the significand rounds up and has a carry\n+                \/\/ propagate all the way up, take the bottom 11 bits\n+                \/\/ rather than bottom 10 bits. Adding this value,\n+                \/\/ rather than OR'ing htis value, will cause the right\n+                \/\/ exponent adjustment.\n+                signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x07ff);\n@@ -1141,1 +1148,1 @@\n-                signif_bits = (short)((doppel & 0x0007f_e000) >>\n+                signif_bits = (short)((doppel & 0x007f_e000) >>\n@@ -1160,3 +1167,3 @@\n-                int lsb   =  doppel & 0x00000_2000;\n-                int round =  doppel & 0x00000_1000;\n-                int sticky = doppel & 0x00000_0fff;\n+                int lsb   =  doppel & 0x0000_2000;\n+                int round =  doppel & 0x0000_1000;\n+                int sticky = doppel & 0x0000_0fff;\n@@ -1166,3 +1173,0 @@\n-                    \/\/ Due to the representational properties, an\n-                    \/\/ increment will also handle a ripple carry that\n-                    \/\/ updates the exponent too.\n@@ -1173,3 +1177,7 @@\n-            short result = 0;\n-            result = (short)(((exp + 15) << 10) | signif_bits);\n-            return (short)(sign_bit | (0x7fff & result));\n+            \/\/ No bits set in significand beyond the *first* exponent\n+            \/\/ bit, not just the sigificand; quantity is added to the\n+            \/\/ exponent to implement a carry out from rounding the\n+            \/\/ significand.\n+            assert (0xf800 & signif_bits) == 0x0;\n+\n+            return (short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":43,"deletions":35,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+        errors += roundFloatToBinary16FullBinade();\n@@ -59,1 +60,1 @@\n-            if (Binary16.compare(s, s2) != 0) {\n+            if (!Binary16.equivalent(s, s2)) {\n@@ -62,2 +63,2 @@\n-                                   Integer.toHexString((int)s) +\n-                                   \"\\t got back \" + Integer.toHexString((int)s2));\n+                                   Integer.toHexString(0xFFFF & (int)s) +\n+                                   \"\\t got back \" + Integer.toHexString(0xFFFF & (int)s2));\n@@ -108,4 +109,4 @@\n-            {0x1.ff8p-1f,                (short)0x3bfe}, \/\/ round = 0, sticky = 0\n-            {0x1.ff801p-1f,              (short)0x3bfe}, \/\/ round = 0, sticky = 1\n-            {0x1.ffap-1f,                (short)0x3bfe}, \/\/ round = 1, sticky = 0\n-            {0x1.ffa01p-1f,              (short)0x3bff}, \/\/ round = 1, sticky = 1 => ++\n+            {0x1.ff8000p-1f,       (short)0x3bfe},              \/\/ round = 0, sticky = 0\n+            {0x1.ff8010p-1f,       (short)0x3bfe},              \/\/ round = 0, sticky = 1\n+            {0x1.ffa000p-1f,       (short)0x3bfe},              \/\/ round = 1, sticky = 0\n+            {0x1.ffa010p-1f,       (short)0x3bff},              \/\/ round = 1, sticky = 1 => ++\n@@ -114,5 +115,4 @@\n-            \/\/ (short)0x3bff is the largest binary16 less than one\n-            {0x1.ffcp-1f,                (short)0x3bff}, \/\/ round = 0, sticky = 0\n-            {0x1.ffc01p-1f,              (short)0x3bff}, \/\/ round = 0, sticky = 1\n-            {0x1.ffep-1f,                (short)0x3c00}, \/\/ round = 1, sticky = 0 => ++\n-            {0x1.ffe01p-1f,              (short)0x3c00}, \/\/ round = 1, sticky = 1 => ++\n+            {0x1.ffc000p-1f,       Binary16.ONE-1},             \/\/ round = 0, sticky = 0\n+            {0x1.ffc010p-1f,       Binary16.ONE-1},             \/\/ round = 0, sticky = 1\n+            {0x1.ffe000p-1f,       Binary16.ONE},               \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffe010p-1f,       Binary16.ONE},               \/\/ round = 1, sticky = 1 => ++\n@@ -122,4 +122,4 @@\n-            {0x1.ff8p-15f,               (short)0x03ff}, \/\/ round = 0, sticky = 0\n-            {0x1.ff801p-15f,             (short)0x03ff}, \/\/ round = 0, sticky = 1\n-            {0x1.ffcp-15f,               (short)0x0400}, \/\/ round = 1, sticky = 0 => ++\n-            {0x1.ffc01p-15f,             (short)0x0400}, \/\/ round = 1, sticky = 1 => ++\n+            {0x1.ff8000p-15f,      Binary16.MAX_SUBNORMAL},     \/\/ round = 0, sticky = 0\n+            {0x1.ff8010p-15f,      Binary16.MAX_SUBNORMAL},     \/\/ round = 0, sticky = 1\n+            {0x1.ffc000p-15f,      Binary16.MIN_NORMAL},        \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffc010p-15f,      Binary16.MIN_NORMAL},        \/\/ round = 1, sticky = 1 => ++\n@@ -129,5 +129,5 @@\n-            \/\/ Half-way case and small should round down to zero\n-            {0x1.fffffep-26f,             (short)0x0000}, \/\/ nextDown in float\n-            {0x1.0p-25f,                  (short)0x0000},\n-            {0x1.000002p-25f,             (short)0x0001}, \/\/ nextUp in float\n-            {0x1.1p-25f,                  (short)0x0001},\n+            \/\/ Half-way case,0x1.0p-25f, and smaller should round down to zero\n+            {0x1.fffffep-26f,      Binary16.POSITIVE_ZERO},     \/\/ nextDown in float\n+            {0x1.000000p-25f,      Binary16.POSITIVE_ZERO},\n+            {0x1.000002p-25f,      Binary16.MIN_VALUE},         \/\/ nextUp in float\n+            {0x1.100000p-25f,      Binary16.MIN_VALUE},\n@@ -137,4 +137,4 @@\n-            {0x1.ffcp15f,                (short)0x7bff}, \/\/ round = 0, sticky = 0\n-            {0x1.ffc01p15f,              (short)0x7bff}, \/\/ round = 0, sticky = 1\n-            {0x1.ffep15f,                (short)0x7c00}, \/\/ round = 1, sticky = 0 => ++\n-            {0x1.ffe01p15f,              (short)0x7c00}, \/\/ round = 1, sticky = 1 => ++\n+            {0x1.ffc000p15f,       Binary16.MAX_VALUE},         \/\/ round = 0, sticky = 0\n+            {0x1.ffc010p15f,       Binary16.MAX_VALUE},         \/\/ round = 0, sticky = 1\n+            {0x1.ffe000p15f,       Binary16.POSITIVE_INFINITY}, \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffe010p15f,       Binary16.POSITIVE_INFINITY}, \/\/ round = 1, sticky = 1 => ++\n@@ -160,3 +160,3 @@\n-        for (int i = 0;   \/\/ binary16 0.0\n-             i < 0x7bff ; \/\/ Largest normal binary16 value\n-             i += 2) {    \/\/ Check every even\/odd pair once\n+        for (int i = Binary16.POSITIVE_ZERO; \/\/ 0x0000\n+             i <= Binary16.MAX_VALUE;        \/\/ 0x7bff\n+             i += 2) {     \/\/ Check every even\/odd pair once\n@@ -177,1 +177,1 @@\n-            errors += compareAndReportError(midway, lower);\n+            errors += compareAndReportError(              midway,      lower);\n@@ -179,1 +179,1 @@\n-            errors += compareAndReportError(Math.nextUp(midway),       upper);\n+            errors += compareAndReportError(Math.nextUp(  midway),     upper);\n@@ -183,0 +183,16 @@\n+        \/\/ More testing around the overflow threshold\n+        \/\/ Binary16.ulp(Binary16.MAX_VALUE) == 32.0f; test around Binary16.MAX_VALUE + 1\/2 ulp\n+        float binary16_MAX_VALUE = Float.binary16AsShortBitsToFloat(Binary16.MAX_VALUE);\n+        float binary16_MAX_VALUE_halfUlp = binary16_MAX_VALUE + 16.0f;\n+\n+        errors += compareAndReportError(Math.nextDown(binary16_MAX_VALUE), Binary16.MAX_VALUE);\n+        errors += compareAndReportError(              binary16_MAX_VALUE,  Binary16.MAX_VALUE);\n+        errors += compareAndReportError(Math.nextUp(  binary16_MAX_VALUE), Binary16.MAX_VALUE);\n+\n+        \/\/ Binary16.MAX_VALUE is an \"odd\" value since its LSB = 1 so\n+        \/\/ the half-way value greater than Binary16.MAX_VALUE should\n+        \/\/ round up to the next even value, in this case Binary16.POSITIVE_INFINITY.\n+        errors += compareAndReportError(Math.nextDown(binary16_MAX_VALUE_halfUlp), Binary16.MAX_VALUE);\n+        errors += compareAndReportError(              binary16_MAX_VALUE_halfUlp,  Binary16.POSITIVE_INFINITY);\n+        errors += compareAndReportError(Math.nextUp(  binary16_MAX_VALUE_halfUlp), Binary16.POSITIVE_INFINITY);\n+\n@@ -189,1 +205,1 @@\n-        if (Binary16.compare(actual, expected) != 0) {\n+        if (!Binary16.equivalent(actual, expected)) {\n@@ -226,0 +242,65 @@\n+    private static int roundFloatToBinary16FullBinade() {\n+        int errors = 0;\n+\n+        \/\/ For each float value between 1.0 and less than two\n+        \/\/ (i.e. set of float values with an exponent of 0), convert\n+        \/\/ each value to binary16 and then convert that binary16 value\n+        \/\/ back to float.\n+        \/\/\n+        \/\/ Any exponent could be used; the maximum exponent for normal\n+        \/\/ values would not exercise the full set of code path since\n+        \/\/ there is an up-front check on values that would overflow,\n+        \/\/ which correspond to a ripple-carry of the significand that\n+        \/\/ bumps the exponent.\n+        short previous = (short)0;\n+        for (int i = Float.floatToIntBits(1.0f);\n+             i <= Float.floatToIntBits(Math.nextDown(2.0f));\n+             i++) {\n+            \/\/ (Could also express the loop control directly in terms\n+            \/\/ of floating-point operations, incrementing by ulp(1.0),\n+            \/\/ etc.)\n+\n+            float f = Float.intBitsToFloat(i);\n+            short f_as_bin16 = Float.floatToBinary16AsShortBits(f);\n+            short f_as_bin16_down = (short)(f_as_bin16 - 1);\n+            short f_as_bin16_up   = (short)(f_as_bin16 + 1);\n+\n+            \/\/ Across successive float values to convert to binary16,\n+            \/\/ the binary16 results should be semi-monotonic,\n+            \/\/ non-decreasing in this case.\n+\n+            \/\/ Only positive binary16 values so can compare using integer operations\n+            if (f_as_bin16 < previous) {\n+                errors++;\n+                System.out.println(\"Semi-monotonicity violation observed on \" +\n+                                   Integer.toHexString(0xfff & f_as_bin16));\n+            }\n+            previous = f_as_bin16;\n+\n+            \/\/ If round-to-nearest was correctly done, when exactly\n+            \/\/ mapped back to float, f_as_bin16 should be at least as\n+            \/\/ close as either of its neighbors to the original value\n+            \/\/ of f.\n+\n+            float f_prime_down = Float.binary16AsShortBitsToFloat(f_as_bin16_down);\n+            float f_prime      = Float.binary16AsShortBitsToFloat(f_as_bin16);\n+            float f_prime_up   = Float.binary16AsShortBitsToFloat(f_as_bin16_up);\n+\n+            float f_prime_diff = Math.abs(f - f_prime);\n+            if (f_prime_diff == 0.0) {\n+                continue;\n+            }\n+            float f_prime_down_diff = Math.abs(f - f_prime_down);\n+            float f_prime_up_diff   = Math.abs(f - f_prime_up);\n+\n+            if (f_prime_diff > f_prime_down_diff ||\n+                f_prime_diff > f_prime_up_diff) {\n+                errors++;\n+                System.out.println(\"Round-to-nearest violation on converting \" +\n+                                   Float.toHexString(f) + \" to binary16 and back.\");\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n@@ -232,0 +313,1 @@\n+        public static final short MAX_SUBNORMAL = 0x03ff;\n@@ -235,1 +317,0 @@\n-        public static final short MAX_SUBNORMAL = (short)0x03ff;\n@@ -243,2 +324,1 @@\n-            return (short)(((binary16 & 0x8000) ^ 0x8000) | \/\/ Isolate and flip sign bit\n-                           (binary16 & 0x7fff));\n+            return (short)(binary16 ^ 0x8000 ); \/\/ Flip only sign bit.\n@@ -247,1 +327,1 @@\n-        public static int compare(short bin16_1, short bin16_2) {\n+        public static boolean equivalent(short bin16_1, short bin16_2) {\n@@ -249,1 +329,1 @@\n-                return 0;\n+                return true;\n@@ -251,9 +331,1 @@\n-                if (isNaN(bin16_1)) {\n-                    return isNaN(bin16_2) ? 0 : 1;\n-                } else {\n-                    if (isNaN(bin16_2)) {\n-                        return -1;\n-                    }\n-                    return Integer.compare((int)(bin16_1 & 0xFFFF),\n-                                           (int)(bin16_2 & 0xFFFF));\n-                }\n+                return isNaN(bin16_1) ? isNaN(bin16_2) : false;\n","filename":"test\/jdk\/java\/lang\/Float\/SixteenBitFormats.java","additions":117,"deletions":45,"binary":false,"changes":162,"status":"modified"}]}