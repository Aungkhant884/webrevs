{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.math.FloatConsts;\n@@ -978,0 +979,200 @@\n+    \/**\n+     * {@return the {@code float} value closest to the numerical value\n+     * of the argument, a binary16 value encoded in a {@code short}}\n+     * The conversion is exact; all binary16 values can be exactly\n+     * represented in {@code float}.\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * same sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the same sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * <h4><a id=binary16Format>IEEE 754 binary16 format<\/a><\/h4>\n+     * IEEE 754 standard defines binary16 as a 16-bit format, along\n+     * with the 32-bit binary32 format (corresponding to the {@code\n+     * float} type) and the 64-bit binary64 format (corresponding to\n+     * the {@code double} type). The binary16 format is similar to the\n+     * other IEEE 754 formats, except smaller, having all the usual\n+     * IEEE 754 values such as NaN, signed infinities, signed zeros,\n+     * and subnormals. The parameters (JLS {@jls 4.2.3}) for the\n+     * binary16 format are N = 11 precision bits, K = 5 exponent bits,\n+     * <i>E<\/i><sub><i>max<\/i><\/sub> = 15, and\n+     * <i>E<\/i><sub><i>min<\/i><\/sub> = -14.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754 from the binary16 format to the binary32 format.\n+     * The operation of this method is analogous to a primitive\n+     * widening conversion (JLS {@jls 5.1.2}).\n+     *\n+     * @param binary16asShort the binary16 value to convert to {@code float}\n+     * @since 20\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static float binary16AsShortBitsToFloat(short binary16asShort) {\n+        \/*\n+         * The binary16 format has 1 sign bit, 5 exponent bits, and 10\n+         * significand bits. The exponent bias is 15.\n+         *\/\n+        int bin16arg = (int)binary16asShort;\n+        int bin16SignBit     = 0x8000 & bin16arg;\n+        int bin16ExpBits     = 0x7c00 & bin16arg;\n+        int bin16SignifBits  = 0x03FF & bin16arg;\n+\n+        float sign = (bin16SignBit != 0) ? -1.0f : 1.0f;\n+\n+        \/\/ Extract binary16 exponent, remove its bias, add in the bias\n+        \/\/ of a float exponent and shift to correct bit location\n+        \/\/ (significand width includes the implicit bit so shift one\n+        \/\/ less).\n+        int bin16Exp = (((bin16ExpBits >> 10) - 15));\n+        if (bin16Exp == -15) {\n+            \/\/ For subnormal binary16 values and 0, the numerical\n+            \/\/ value is 2^24 * the significand as an integer (no\n+            \/\/ implicit bit).\n+            return sign * (0x1p-24f * bin16SignifBits);\n+        } else if (bin16Exp == 16) {\n+            return (bin16SignifBits == 0) ?\n+                sign * Float.POSITIVE_INFINITY :\n+                Float.NaN; \/\/ Could try to preserve NaN significand bits\n+        }\n+\n+        assert -14 <= bin16Exp  && bin16Exp <= 15;\n+\n+        int floatExpBits = (bin16Exp + FloatConsts.EXP_BIAS)\n+            << (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+\n+        int result = 0;\n+        \/\/ Compute result sign, exponent, and significand bits.\n+        result |= (floatExpBits |\n+                   \/\/ Shift left difference in the number of\n+                   \/\/ significand bits in the float and binary16\n+                   \/\/ formats\n+                   (bin16SignifBits << (FloatConsts.SIGNIFICAND_WIDTH - 11)));\n+        return sign * Float.intBitsToFloat(result);\n+    }\n+\n+    \/**\n+     * {@return the binary16 value, encoded in a {@code short},\n+     * closest in value to the argument}\n+     * The conversion is computed under the {@linkplain\n+     * java.math.RoundingMode#HALF_EVEN round to nearest even rounding\n+     * mode}.\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * same sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the same sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * The <a href=\"#binary16Format\">binary16 format<\/a> is discussed in\n+     * more detail in the {@link #binary16AsShortBitsToFloat} method.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754 from the binary32 format to the binary16 format.\n+     * The operation of this method is analogous to a primitive\n+     * narrowing conversion (JLS {@jls 5.1.3}).\n+     *\n+     * @param f the {@code float} value to convert to binary16\n+     * @since 20\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static short floatToBinary16AsShortBits(float f) {\n+        if (Float.isNaN(f)) {\n+            \/\/ Arbitrary binary16 NaN value; could try to preserve the\n+            \/\/ sign and some bits of the NaN significand.\n+            return (short)0x7fff;\n+        }\n+\n+        float abs_f = Math.abs(f);\n+        int doppel = Float.floatToRawIntBits(f);\n+        short sign_bit = (short)((doppel >> 16) & 0x8000);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_f > (65504.0f + 16.0f) ) {\n+            return (short)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+        } else {\n+            \/\/ Smallest magnitude nonzero representable binary16 value\n+            \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+            if (abs_f <= 0x1.0p-25f) { \/\/ Covers float zeros and subnormals.\n+                return sign_bit; \/\/ Positive or negative zero\n+            }\n+\n+            \/\/ Dealing with finite values in exponent range of\n+            \/\/ binary16 (when rounding is done, could still round up)\n+            int exp = Math.getExponent(f);\n+            assert -25 <= exp && exp <= 15;\n+            short signif_bits;\n+\n+            if (exp <= -15) { \/\/ scale down to float subnormal range to do rounding\n+                \/\/ Use a float multiply to compute the correct\n+                \/\/ trailing significand bits for a binary16 subnormal.\n+                \/\/\n+                \/\/ The exponent range of normalized binary16 subnormal\n+                \/\/ values is [-15, -24]. The exponent range of float\n+                \/\/ subnormals is [-140, -149]. Multiply abs_f down by\n+                \/\/ 2^(-125) -- since (-125 = -149 - (-24)) -- so that\n+                \/\/ the trailing bits of a subnormal float represent\n+                \/\/ the correct trailing bits of a binary16 subnormal.\n+                exp = -15; \/\/ Subnormal encoding using -E_max.\n+                float f_adjust = abs_f * 0x1.0p-125f;\n+                signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x03ff);\n+                if (signif_bits == 0) {\n+                    \/\/ Since zero cases have already been handled, if\n+                    \/\/ the significand is all zeros, there was a\n+                    \/\/ round-up to normal range so the exponent needs\n+                    \/\/ to be adjusted accordingly.\n+                    exp++;\n+                }\n+            } else {\n+                \/\/ All remaining values of f are in the normalized\n+                \/\/ range of binary16 (which is also in the normalized\n+                \/\/ range of float).\n+\n+                \/\/ Significand bits as if using rounding to zero (truncation).\n+                signif_bits = (short)((doppel & 0x0007f_e000) >>\n+                                      (FloatConsts.SIGNIFICAND_WIDTH - 11));\n+\n+                \/\/ For round to nearest even, determining whether or\n+                \/\/ not to round up (in magnitude) is a function of the\n+                \/\/ least significant bit (LSB), the next bit position\n+                \/\/ (the round position), and the sticky bit (whether\n+                \/\/ there are any nonzero bits in the exact result to\n+                \/\/ the right of the round digit). An increment occurs\n+                \/\/ in three cases:\n+                \/\/\n+                \/\/ LSB  Round Sticky\n+                \/\/ 0    1     1\n+                \/\/ 1    1     0\n+                \/\/ 1    1     1\n+                \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+                \/\/ Bits of binary16 significand in a float: 0x0007f_e000;\n+                \/\/ therefore, the other quantities of interest are:\n+                int lsb   =  doppel & 0x00000_2000;\n+                int round =  doppel & 0x00000_1000;\n+                int sticky = doppel & 0x00000_0fff;\n+\n+                if (((lsb == 0) && (round != 0) && (sticky != 0)) ||\n+                    ( lsb != 0  &&  round != 0 ) ) { \/\/ sticky not needed\n+                    \/\/ Due to the representational properties, an\n+                    \/\/ increment will also handle a ripple carry that\n+                    \/\/ updates the exponent too.\n+                    signif_bits++;\n+                }\n+            }\n+\n+            short result = 0;\n+            result = (short)(((exp + 15) << 10) | signif_bits);\n+            return (short)(sign_bit | (0x7fff & result));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289551\n+ * @summary Verify conversion between float and 16-bit formats\n+ * @library ..\/Math\n+ * @build FloatConsts\n+ * @run main SixteenBitFormats\n+ *\/\n+\n+import static java.lang.Float.*;\n+\n+public class SixteenBitFormats {\n+    public static void main(String... argv) {\n+        int errors = 0;\n+        errors += binary16RoundTrip();\n+        \/\/ Note that helper methods do sign-symmetric testing\n+        errors += binary16CardinalValues();\n+        errors += roundFloatToBinary16();\n+        errors += roundFloatToBinary16HalfWayCases();\n+\n+        if (errors > 0)\n+            throw new RuntimeException(errors + \" errors\");\n+    }\n+\n+    \/*\n+     * Put all 16-bit values through a conversion loop and make sure\n+     * the values are preserved. (NaN bit patterns notwithstanding.)\n+     *\/\n+    private static int binary16RoundTrip() {\n+        int errors = 0;\n+        for (int i = Short.MIN_VALUE; i < Short.MAX_VALUE; i++) {\n+            short s = (short)i;\n+            float f =  Float.binary16AsShortBitsToFloat(s);\n+            short s2 = Float.floatToBinary16AsShortBits(f);\n+\n+            if (Binary16.compare(s, s2) != 0) {\n+                errors++;\n+                System.out.println(\"Roundtrip failure on \" +\n+                                   Integer.toHexString((int)s) +\n+                                   \"\\t got back \" + Integer.toHexString((int)s2));\n+            }\n+        }\n+        return errors;\n+    }\n+\n+    private static int binary16CardinalValues() {\n+        int errors = 0;\n+        \/\/ Encode short value for different binary16 cardinal values as an\n+        \/\/ integer-valued float.\n+        float[][] testCases = {\n+            {Binary16.POSITIVE_INFINITY,      Float.POSITIVE_INFINITY},\n+            {Binary16.POSITIVE_ZERO,         +0.0f},\n+            {Binary16.MIN_VALUE,              0x1.0p-24f},\n+            {Binary16.MAX_SUBNORMAL,          0x1.ff8p-15f},\n+            {Binary16.MIN_NORMAL,             0x1.0p-14f},\n+            {Binary16.ONE,                    1.0f},\n+            {Binary16.MAX_VALUE,              65504.0f},\n+        };\n+\n+        \/\/ Check conversions in both directions\n+\n+        \/\/ short -> float\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError((short)testCase[0],\n+                                            testCase[1]);\n+        }\n+\n+        \/\/ float -> short\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError(testCase[1],\n+                                            (short)testCase[0]);\n+        }\n+\n+        return errors;\n+    };\n+\n+\n+    private static int roundFloatToBinary16() {\n+        int errors = 0;\n+\n+        float[][] testCases = {\n+            \/\/ Test all combinations of LSB, round, and sticky bit\n+\n+            \/\/ LSB = 0, test combination of round and sticky\n+            {0x1.ff8p-1f,                (short)0x3bfe}, \/\/ round = 0, sticky = 0\n+            {0x1.ff801p-1f,              (short)0x3bfe}, \/\/ round = 0, sticky = 1\n+            {0x1.ffap-1f,                (short)0x3bfe}, \/\/ round = 1, sticky = 0\n+            {0x1.ffa01p-1f,              (short)0x3bff}, \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ LSB = 1, test combination of round and sticky\n+            \/\/ (short)0x3bff is the largest binary16 less than one\n+            {0x1.ffcp-1f,                (short)0x3bff}, \/\/ round = 0, sticky = 0\n+            {0x1.ffc01p-1f,              (short)0x3bff}, \/\/ round = 0, sticky = 1\n+            {0x1.ffep-1f,                (short)0x3c00}, \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffe01p-1f,              (short)0x3c00}, \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ Test subnormal rounding\n+            \/\/ Largest subnormal binary16 0x03ff => 0x1.ff8p-15f; LSB = 1\n+            {0x1.ff8p-15f,               (short)0x03ff}, \/\/ round = 0, sticky = 0\n+            {0x1.ff801p-15f,             (short)0x03ff}, \/\/ round = 0, sticky = 1\n+            {0x1.ffcp-15f,               (short)0x0400}, \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffc01p-15f,             (short)0x0400}, \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ Test rounding near binary16 MIN_VALUE\n+            \/\/ Smallest in magnitude subnormal binary16 value 0x0001 => 0x1.0p-24f\n+            \/\/ Half-way case and small should round down to zero\n+            {0x1.fffffep-26f,             (short)0x0000}, \/\/ nextDown in float\n+            {0x1.0p-25f,                  (short)0x0000},\n+            {0x1.000002p-25f,             (short)0x0001}, \/\/ nextUp in float\n+            {0x1.1p-25f,                  (short)0x0001},\n+\n+            \/\/ Test rounding near overflow threshold\n+            \/\/ Largest normal binary16 number 0x7bff => 0x1.ffcp15f; LSB = 1\n+            {0x1.ffcp15f,                (short)0x7bff}, \/\/ round = 0, sticky = 0\n+            {0x1.ffc01p15f,              (short)0x7bff}, \/\/ round = 0, sticky = 1\n+            {0x1.ffep15f,                (short)0x7c00}, \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffe01p15f,              (short)0x7c00}, \/\/ round = 1, sticky = 1 => ++\n+        };\n+\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError(testCase[0],\n+                                            (short)testCase[1]);\n+        }\n+        return errors;\n+    }\n+\n+    private static int roundFloatToBinary16HalfWayCases() {\n+        int errors = 0;\n+\n+        \/\/ Test rounding of exact half-way cases between each pair of\n+        \/\/ finite exactly-representable binary16 numbers. Also test\n+        \/\/ rounding of half-way +\/- ulp of the *float* value.\n+        \/\/ Additionally, test +\/- float ulp of the endpoints. (Other\n+        \/\/ tests in this file make sure all short values round-trip so\n+        \/\/ that doesn't need to be tested here.)\n+\n+        for (int i = 0;   \/\/ binary16 0.0\n+             i < 0x7bff ; \/\/ Largest normal binary16 value\n+             i += 2) {    \/\/ Check every even\/odd pair once\n+            short lower = (short)i;\n+            short upper = (short)(i+1);\n+\n+            float lowerFloat = Float.binary16AsShortBitsToFloat(lower);\n+            float upperFloat = Float.binary16AsShortBitsToFloat(upper);\n+            assert lowerFloat < upperFloat;\n+\n+            float midway = (lowerFloat + upperFloat) * 0.5f; \/\/ Exact midpoint\n+\n+            errors += compareAndReportError(Math.nextUp(lowerFloat),   lower);\n+            errors += compareAndReportError(Math.nextDown(midway),     lower);\n+\n+            \/\/ Under round to nearest even, the midway point will\n+            \/\/ round *down* to the (even) lower endpoint.\n+            errors += compareAndReportError(midway, lower);\n+\n+            errors += compareAndReportError(Math.nextUp(midway),       upper);\n+            errors += compareAndReportError(Math.nextDown(upperFloat), upper);\n+        }\n+\n+        return errors;\n+    }\n+\n+    private static int compareAndReportError0(float input,\n+                                              short expected) {\n+        short actual = Float.floatToBinary16AsShortBits(input);\n+        if (Binary16.compare(actual, expected) != 0) {\n+            System.out.println(\"Unexpected result of converting \" +\n+                               Float.toHexString(input) +\n+                               \" to short. Expected 0x\" + Integer.toHexString(expected) +\n+                               \" got 0x\" + Integer.toHexString(actual));\n+            return 1;\n+            }\n+        return 0;\n+    }\n+\n+    private static int compareAndReportError(float input,\n+                                             short expected) {\n+        \/\/ Round to nearest even is sign symmetric\n+        return compareAndReportError0( input, expected) +\n+               compareAndReportError0(-input, Binary16.negate(expected));\n+    }\n+\n+    private static int compareAndReportError0(short input,\n+                                              float expected) {\n+        float actual = Float.binary16AsShortBitsToFloat(input);\n+        if (Float.compare(actual, expected) != 0) {\n+            System.out.println(\"Unexpected result of converting \" +\n+                               Integer.toHexString(input & 0xFFFF) +\n+                               \" to float. Expected \" + Float.toHexString(expected) +\n+                               \" got \" + Float.toHexString(actual));\n+            return 1;\n+            }\n+        return 0;\n+    }\n+\n+    private static int compareAndReportError(short input,\n+                                             float expected) {\n+        \/\/ Round to nearest even is sign symmetric\n+        return compareAndReportError0(                input,   expected) +\n+               compareAndReportError0(Binary16.negate(input), -expected);\n+    }\n+\n+    public static class Binary16 {\n+        public static final short POSITIVE_INFINITY = (short)0x7c00;\n+        public static final short NEGATIVE_INFINITY = (short)0xfc00;\n+        public static final short MAX_VALUE = 0x7bff;\n+        public static final short ONE = 0x3c00;\n+        public static final short MIN_NORMAL = 0x0400;\n+        public static final short MIN_VALUE = 0x0001;\n+        public static final short NEGATIVE_ZERO = (short)0x8000;\n+        public static final short POSITIVE_ZERO = 0x0000;\n+        public static final short MAX_SUBNORMAL = (short)0x03ff;\n+\n+        public static boolean isNaN(short binary16) {\n+            return ((binary16 & 0x7c00) == 0x7c00) \/\/ Max exponent and...\n+                && ((binary16 & 0x03ff) != 0 );    \/\/ significand nonzero.\n+        }\n+\n+        public static short negate(short binary16) {\n+            return (short)(((binary16 & 0x8000) ^ 0x8000) | \/\/ Isolate and flip sign bit\n+                           (binary16 & 0x7fff));\n+        }\n+\n+        public static int compare(short bin16_1, short bin16_2) {\n+            if (bin16_1 == bin16_2) {\n+                return 0;\n+            } else {\n+                if (isNaN(bin16_1)) {\n+                    return isNaN(bin16_2) ? 0 : 1;\n+                } else {\n+                    if (isNaN(bin16_2)) {\n+                        return -1;\n+                    }\n+                    return Integer.compare((int)(bin16_1 & 0xFFFF),\n+                                           (int)(bin16_2 & 0xFFFF));\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float\/SixteenBitFormats.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"}]}