{"files":[{"patch":"@@ -45,2 +45,2 @@\n-  const GrowableArray<VMReg>& _input_registers;\n-  const GrowableArray<VMReg>& _output_registers;\n+  const GrowableArray<VMStorage>& _input_registers;\n+  const GrowableArray<VMStorage>& _output_registers;\n@@ -49,0 +49,1 @@\n+  int _captured_state_mask;\n@@ -51,1 +52,1 @@\n-  int _framesize;\n+  int _frame_size_slots;\n@@ -59,3 +60,4 @@\n-                         const GrowableArray<VMReg>& input_registers,\n-                         const GrowableArray<VMReg>& output_registers,\n-                         bool needs_return_buffer)\n+                         const GrowableArray<VMStorage>& input_registers,\n+                         const GrowableArray<VMStorage>& output_registers,\n+                         bool needs_return_buffer,\n+                         int captured_state_mask)\n@@ -70,0 +72,1 @@\n+     _captured_state_mask(captured_state_mask),\n@@ -71,1 +74,1 @@\n-     _framesize(0),\n+     _frame_size_slots(0),\n@@ -82,1 +85,1 @@\n-    return (_framesize >> (LogBytesPerWord - LogBytesPerInt));\n+    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n@@ -96,4 +99,5 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n-                                                bool needs_return_buffer) {\n-  int locs_size  = 64;\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n+  int locs_size = 64;\n@@ -101,1 +105,3 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                          input_registers, output_registers,\n+                          needs_return_buffer, captured_state_mask);\n@@ -140,1 +146,1 @@\n-  Register shuffle_reg = r19;\n+  VMStorage shuffle_reg = as_VMStorage(r19);\n@@ -143,1 +149,1 @@\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n+  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n@@ -155,4 +161,0 @@\n-  if (_needs_return_buffer) {\n-    allocated_frame_size += 8; \/\/ for address spill\n-  }\n-  allocated_frame_size += arg_shuffle.out_arg_stack_slots() <<LogBytesPerInt;\n@@ -160,0 +162,1 @@\n+  allocated_frame_size += arg_shuffle.out_arg_bytes();\n@@ -161,6 +164,1 @@\n-  int ret_buf_addr_sp_offset = -1;\n-  if (_needs_return_buffer) {\n-     \/\/ in sync with the above\n-     ret_buf_addr_sp_offset = allocated_frame_size - 8;\n-  }\n-\n+  bool should_save_return_value = !_needs_return_buffer;\n@@ -170,1 +168,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -172,1 +170,3 @@\n-    \/\/ spill area can be shared with the above, so we take the max of the 2\n+    \/\/ spill area can be shared with shadow space and out args,\n+    \/\/ since they are only used before the call,\n+    \/\/ and spill area is only used after.\n@@ -178,3 +178,13 @@\n-  _framesize = align_up(framesize\n-    + (allocated_frame_size >> LogBytesPerInt), 4);\n-  assert(is_even(_framesize\/2), \"sp not 16-byte aligned\");\n+  StubLocations locs;\n+  locs.set(StubLocations::TARGET_ADDRESS, _abi._scratch1);\n+  if (_needs_return_buffer) {\n+    locs.set_frame_data(StubLocations::RETURN_BUFFER, allocated_frame_size);\n+    allocated_frame_size += BytesPerWord; \/\/ for address spill\n+  }\n+  if (_captured_state_mask != 0) {\n+    locs.set_frame_data(StubLocations::CAPTURED_STATE_BUFFER, allocated_frame_size);\n+    allocated_frame_size += BytesPerWord;\n+  }\n+\n+  _frame_size_slots = align_up(framesize + (allocated_frame_size >> LogBytesPerInt), 4);\n+  assert(is_even(_frame_size_slots\/2), \"sp not 16-byte aligned\");\n@@ -188,1 +198,1 @@\n-  __ sub(sp, rfp, ((unsigned)_framesize-4) << LogBytesPerInt); \/\/ prolog\n+  __ sub(sp, rfp, ((unsigned)_frame_size_slots-4) << LogBytesPerInt); \/\/ prolog\n@@ -194,1 +204,1 @@\n-  OopMap* map = new OopMap(_framesize, 0);\n+  OopMap* map = new OopMap(_frame_size_slots, 0);\n@@ -203,5 +213,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), 0, _abi._shadow_space_bytes);\n-  if (_needs_return_buffer) {\n-    assert(ret_buf_addr_sp_offset != -1, \"no return buffer addr spill\");\n-    __ str(_abi._ret_buf_addr_reg, Address(sp, ret_buf_addr_sp_offset));\n-  }\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes, locs);\n@@ -210,1 +216,1 @@\n-  __ blr(_abi._target_addr_reg);\n+  __ blr(as_Register(locs.get(StubLocations::TARGET_ADDRESS)));\n@@ -214,2 +220,1 @@\n-    assert(ret_buf_addr_sp_offset != -1, \"no return buffer addr spill\");\n-    __ ldr(tmp1, Address(sp, ret_buf_addr_sp_offset));\n+    __ ldr(tmp1, Address(sp, locs.data_offset(StubLocations::RETURN_BUFFER)));\n@@ -218,3 +223,3 @@\n-      VMReg reg = _output_registers.at(i);\n-      if (reg->is_Register()) {\n-        __ str(reg->as_Register(), Address(tmp1, offset));\n+      VMStorage reg = _output_registers.at(i);\n+      if (reg.type() == StorageType::INTEGER) {\n+        __ str(as_Register(reg), Address(tmp1, offset));\n@@ -222,2 +227,2 @@\n-      } else if(reg->is_FloatRegister()) {\n-        __ strd(reg->as_FloatRegister(), Address(tmp1, offset));\n+      } else if (reg.type() == StorageType::VECTOR) {\n+        __ strd(as_FloatRegister(reg), Address(tmp1, offset));\n@@ -231,0 +236,22 @@\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  if (_captured_state_mask != 0) {\n+    __ block_comment(\"{ save thread local\");\n+\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n+\n+    __ ldr(c_rarg0, Address(sp, locs.data_offset(StubLocations::CAPTURED_STATE_BUFFER)));\n+    __ movw(c_rarg1, _captured_state_mask);\n+    __ rt_call(CAST_FROM_FN_PTR(address, DowncallLinker::capture_state), tmp1);\n+\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n+\n+    __ block_comment(\"} save thread local\");\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n@@ -275,1 +302,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -285,1 +312,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -297,1 +324,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -303,1 +330,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":76,"deletions":49,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"prims\/vmstorage.inline.hpp\"\n@@ -45,3 +46,0 @@\n-static constexpr int INTEGER_TYPE = 0;\n-static constexpr int VECTOR_TYPE = 1;\n-\n@@ -51,1 +49,0 @@\n-  constexpr Register (*to_Register)(int) = as_Register;\n@@ -54,2 +51,2 @@\n-  parse_register_array(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, to_Register);\n-  parse_register_array(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_FloatRegister);\n+  parse_register_array(inputStorage, StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, StorageType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n@@ -58,2 +55,2 @@\n-  parse_register_array(outputStorage, INTEGER_TYPE, abi._integer_return_registers, to_Register);\n-  parse_register_array(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_FloatRegister);\n+  parse_register_array(outputStorage, StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, StorageType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n@@ -62,2 +59,2 @@\n-  parse_register_array(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, to_Register);\n-  parse_register_array(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_FloatRegister);\n+  parse_register_array(volatileStorage, StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, StorageType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n@@ -68,2 +65,2 @@\n-  abi._target_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop))->as_Register();\n-  abi._ret_buf_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop))->as_Register();\n+  abi._scratch1 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch1(abi_oop));\n+  abi._scratch2 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch2(abi_oop));\n@@ -74,17 +71,2 @@\n-enum class RegType {\n-  INTEGER = 0,\n-  VECTOR = 1,\n-  STACK = 3\n-};\n-\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  switch(static_cast<RegType>(type)) {\n-    case RegType::INTEGER: return ::as_Register(index)->as_VMReg();\n-    case RegType::VECTOR: return ::as_FloatRegister(index)->as_VMReg();\n-    case RegType::STACK: return VMRegImpl::stack2reg(index LP64_ONLY(* 2));\n-  }\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n-  if (reg->is_Register()) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n+  if (reg.type() == StorageType::INTEGER) {\n@@ -92,1 +74,1 @@\n-  } else if (reg->is_FloatRegister()) {\n+  } else if (reg.type() == StorageType::VECTOR) {\n@@ -98,5 +80,5 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n-  if (reg->is_Register()) {\n-    masm->spill(reg->as_Register(), true, offset);\n-  } else if (reg->is_FloatRegister()) {\n-    masm->spill(reg->as_FloatRegister(), masm->Q, offset);\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n+  if (reg.type() == StorageType::INTEGER) {\n+    masm->spill(as_Register(reg), true, offset);\n+  } else if (reg.type() == StorageType::VECTOR) {\n+    masm->spill(as_FloatRegister(reg), masm->Q, offset);\n@@ -108,5 +90,5 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n-  if (reg->is_Register()) {\n-    masm->unspill(reg->as_Register(), true, offset);\n-  } else if (reg->is_FloatRegister()) {\n-    masm->unspill(reg->as_FloatRegister(), masm->Q, offset);\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n+  if (reg.type() == StorageType::INTEGER) {\n+    masm->unspill(as_Register(reg), true, offset);\n+  } else if (reg.type() == StorageType::VECTOR) {\n+    masm->unspill(as_FloatRegister(reg), masm->Q, offset);\n@@ -118,3 +100,97 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n-  assert(in_stk_bias == 0 && out_stk_bias == 0, \"bias not implemented\");\n-  Register tmp_reg = tmp->as_Register();\n+static constexpr int RFP_BIAS = 16; \/\/ skip old rfp and lr\n+\n+static void move_reg64(MacroAssembler* masm, int out_stk_bias,\n+                       Register from_reg, VMStorage to_reg) {\n+  int out_bias = 0;\n+  switch (to_reg.type()) {\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->mov(as_Register(to_reg), from_reg);\n+      break;\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA: {\n+      Address dest(sp, to_reg.offset() + out_bias);\n+      switch (to_reg.stack_size()) {\n+        case 8: masm->str (from_reg, dest); break;\n+        case 4: masm->strw(from_reg, dest); break;\n+        case 2: masm->strh(from_reg, dest); break;\n+        case 1: masm->strb(from_reg, dest); break;\n+        default: ShouldNotReachHere();\n+      }\n+    } break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+static void move_stack(MacroAssembler* masm, Register tmp_reg, int in_stk_bias, int out_stk_bias,\n+                       VMStorage from_reg, VMStorage to_reg) {\n+  Address from_addr(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias);\n+  int out_bias = 0;\n+  switch (to_reg.type()) {\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      switch (from_reg.stack_size()) {\n+        case 8: masm->ldr (as_Register(to_reg), from_addr); break;\n+        case 4: masm->ldrw(as_Register(to_reg), from_addr); break;\n+        case 2: masm->ldrh(as_Register(to_reg), from_addr); break;\n+        case 1: masm->ldrb(as_Register(to_reg), from_addr); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case StorageType::VECTOR:\n+      assert(to_reg.segment_mask() == V128_MASK, \"only moves to v128 registers supported\");\n+      switch (from_reg.stack_size()) {\n+        case 8:\n+          masm->ldrd(as_FloatRegister(to_reg), from_addr);\n+        break;\n+        case 4:\n+          masm->ldrs(as_FloatRegister(to_reg), from_addr);\n+        break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA: {\n+      switch (from_reg.stack_size()) {\n+        case 8: masm->ldr (tmp_reg, from_addr); break;\n+        case 4: masm->ldrw(tmp_reg, from_addr); break;\n+        case 2: masm->ldrh(tmp_reg, from_addr); break;\n+        case 1: masm->ldrb(tmp_reg, from_addr); break;\n+        default: ShouldNotReachHere();\n+      }\n+      Address dest(sp, to_reg.offset() + out_bias);\n+      switch (to_reg.stack_size()) {\n+        case 8: masm->str (tmp_reg, dest); break;\n+        case 4: masm->strw(tmp_reg, dest); break;\n+        case 2: masm->strh(tmp_reg, dest); break;\n+        case 1: masm->strb(tmp_reg, dest); break;\n+        default: ShouldNotReachHere();\n+      }\n+    } break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+static void move_v128(MacroAssembler* masm, int out_stk_bias,\n+                      FloatRegister from_reg, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case StorageType::VECTOR:\n+      assert(to_reg.segment_mask() == V128_MASK, \"only moves to v128 registers supported\");\n+      masm->fmovd(as_FloatRegister(to_reg), from_reg);\n+      break;\n+    case StorageType::STACK: {\n+      Address dest(sp, to_reg.offset() + out_stk_bias);\n+      switch (to_reg.stack_size()) {\n+        case 8: masm->strd(from_reg, dest); break;\n+        case 4: masm->strs(from_reg, dest); break;\n+        default: ShouldNotReachHere();\n+      }\n+    } break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+  Register tmp_reg = as_Register(tmp);\n@@ -123,13 +199,2 @@\n-    BasicType arg_bt     = move.bt;\n-    VMRegPair from_vmreg = move.from;\n-    VMRegPair to_vmreg   = move.to;\n-\n-    masm->block_comment(err_msg(\"bt=%s\", null_safe_string(type2name(arg_bt))));\n-    switch (arg_bt) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-        masm->move32_64(from_vmreg, to_vmreg, tmp_reg);\n-        break;\n+    VMStorage from_reg = move.from;\n+    VMStorage to_reg   = move.to;\n@@ -137,3 +202,7 @@\n-      case T_FLOAT:\n-        masm->float_move(from_vmreg, to_vmreg, tmp_reg);\n-        break;\n+    \/\/ replace any placeholders\n+    if (from_reg.type() == StorageType::PLACEHOLDER) {\n+      from_reg = locs.get(from_reg);\n+    }\n+    if (to_reg.type() == StorageType::PLACEHOLDER) {\n+      to_reg = locs.get(to_reg);\n+    }\n@@ -141,2 +210,4 @@\n-      case T_DOUBLE:\n-        masm->double_move(from_vmreg, to_vmreg, tmp_reg);\n+    switch (from_reg.type()) {\n+      case StorageType::INTEGER:\n+        assert(from_reg.segment_mask() == REG64_MASK, \"only 64-bit register supported\");\n+        move_reg64(masm, out_stk_bias, as_Register(from_reg), to_reg);\n@@ -144,3 +215,3 @@\n-\n-      case T_LONG :\n-        masm->long_move(from_vmreg, to_vmreg, tmp_reg);\n+      case StorageType::VECTOR:\n+        assert(from_reg.segment_mask() == V128_MASK, \"only v128 register supported\");\n+        move_v128(masm, out_stk_bias, as_FloatRegister(from_reg), to_reg);\n@@ -148,3 +219,4 @@\n-\n-      default:\n-        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+      case StorageType::STACK:\n+        move_stack(masm, tmp_reg, in_stk_bias, out_stk_bias, from_reg, to_reg);\n+        break;\n+      default: ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":139,"deletions":67,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-  Register _target_addr_reg;\n-  Register _ret_buf_addr_reg;\n+  VMStorage _scratch1;\n+  VMStorage _scratch2;\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -74,1 +74,1 @@\n-  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n+  constexpr const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -178,3 +178,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -195,1 +195,1 @@\n-  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n+  constexpr const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -131,3 +131,4 @@\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n-  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n-  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, as_VMStorage(shuffle_reg));\n+  int preserved_bytes = SharedRuntime::out_preserve_stack_slots() * VMRegImpl::stack_slot_size;\n+  int stack_bytes = preserved_bytes + arg_shuffle.out_arg_bytes();\n+  int out_arg_area = align_up(stack_bytes , StackAlignmentInBytes);\n@@ -161,0 +162,1 @@\n+  StubLocations locs;\n@@ -165,0 +167,3 @@\n+    \/\/ use a free register for shuffling code to pick up return\n+    \/\/ buffer address from\n+    locs.set(StubLocations::RETURN_BUFFER, abi._scratch1);\n@@ -221,1 +226,1 @@\n-    __ lea(abi._ret_buf_addr_reg, Address(sp, ret_buf_offset));\n+    __ lea(as_Register(locs.get(StubLocations::RETURN_BUFFER)), Address(sp, ret_buf_offset));\n@@ -223,1 +228,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n+  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0, locs);\n@@ -242,1 +247,1 @@\n-      VMReg j_expected_result_reg;\n+      VMStorage j_expected_result_reg;\n@@ -250,1 +255,1 @@\n-        j_expected_result_reg = r0->as_VMReg();\n+        j_expected_result_reg = as_VMStorage(r0);\n@@ -254,1 +259,1 @@\n-          j_expected_result_reg = v0->as_VMReg();\n+          j_expected_result_reg = as_VMStorage(v0);\n@@ -261,2 +266,1 @@\n-      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n-      \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg, \"unexpected result register\");\n@@ -270,3 +274,3 @@\n-      VMReg reg = call_regs._ret_regs.at(i);\n-      if (reg->is_Register()) {\n-        __ ldr(reg->as_Register(), Address(rscratch1, offset));\n+      VMStorage reg = call_regs._ret_regs.at(i);\n+      if (reg.type() == StorageType::INTEGER) {\n+        __ ldr(as_Register(reg), Address(rscratch1, offset));\n@@ -274,2 +278,2 @@\n-      } else if (reg->is_FloatRegister()) {\n-        __ ldrd(reg->as_FloatRegister(), Address(rscratch1, offset));\n+      } else if (reg.type() == StorageType::VECTOR) {\n+        __ ldrd(as_FloatRegister(reg), Address(rscratch1, offset));\n@@ -331,2 +335,5 @@\n-  if (TraceOptimizedUpcallStubs) {\n-    blob->print_on(tty);\n+#ifndef PRODUCT\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    blob->print_on(&ls);\n@@ -334,0 +341,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n+#define CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+\n+\/\/ keep in sync with jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture\n+enum class StorageType : int8_t {\n+  INTEGER = 0,\n+  VECTOR = 1,\n+  STACK = 2,\n+  PLACEHOLDER = 3,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return type == StorageType::INTEGER || type == StorageType::VECTOR;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+constexpr uint16_t REG64_MASK = 0b0000000000000001;\n+constexpr uint16_t V128_MASK  = 0b0000000000000001;\n+\n+inline Register as_Register(VMStorage vms) {\n+  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n+  return ::as_Register(vms.index());\n+}\n+\n+inline FloatRegister as_FloatRegister(VMStorage vms) {\n+  assert(vms.type() == StorageType::VECTOR, \"not the right type\");\n+  return ::as_FloatRegister(vms.index());\n+}\n+\n+constexpr inline VMStorage as_VMStorage(Register reg) {\n+  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n+}\n+\n+constexpr inline VMStorage as_VMStorage(FloatRegister reg) {\n+  return VMStorage::reg_storage(StorageType::VECTOR, V128_MASK, reg->encoding());\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  if (reg->is_Register()) {\n+    return as_VMStorage(reg->as_Register());\n+  } else if (reg->is_FloatRegister()) {\n+    return as_VMStorage(reg->as_FloatRegister());\n+  } else if (reg->is_stack()) {\n+    return VMStorage::stack_storage(reg);\n+  } else if (!reg->is_valid()) {\n+    return VMStorage::invalid();\n+  }\n+\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/aarch64\/vmstorage_aarch64.inline.hpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +33,4 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n-                                                bool needs_return_buffer) {\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/arm\/downcallLinker_arm.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +37,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -46,1 +42,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -50,1 +46,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -54,1 +50,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_ARM_VMSTORAGE_ARM_INLINE_HPP\n+#define CPU_ARM_VMSTORAGE_ARM_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ CPU_ARM_VMSTORAGE_ARM_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/arm\/vmstorage_arm.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -33,3 +33,4 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n-                                                bool needs_return_buffer) {\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,6 +38,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -48,1 +43,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -52,1 +47,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -56,1 +51,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_PPC_VMSTORAGE_PPC_INLINE_HPP\n+#define CPU_PPC_VMSTORAGE_PPC_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ CPU_PPC_VMSTORAGE_PPC_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/ppc\/vmstorage_ppc.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -34,3 +34,4 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n-                                                bool needs_return_buffer) {\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,6 +38,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -48,1 +43,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -52,1 +47,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -56,1 +51,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n@@ -59,1 +54,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_RISCV_VMSTORAGE_RISCV_INLINE_HPP\n+#define CPU_RISCV_VMSTORAGE_RISCV_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ CPU_RISCV_VMSTORAGE_RISCV_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/vmstorage_riscv.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +33,4 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n-                                                bool needs_return_buffer) {\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +37,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -46,1 +42,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -50,1 +46,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -54,1 +50,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_S390_VMSTORAGE_S390_INLINE_HPP\n+#define CPU_S390_VMSTORAGE_S390_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ CPU_S390_VMSTORAGE_S390_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/s390\/vmstorage_s390.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -31,3 +31,4 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n-                                                bool needs_return_buffer) {\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_32.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-  const GrowableArray<VMReg>& _input_registers;\n-  const GrowableArray<VMReg>& _output_registers;\n+  const GrowableArray<VMStorage>& _input_registers;\n+  const GrowableArray<VMStorage>& _output_registers;\n@@ -48,0 +48,1 @@\n+  int _captured_state_mask;\n@@ -50,1 +51,1 @@\n-  int _framesize;\n+  int _frame_size_slots;\n@@ -58,3 +59,4 @@\n-                         const GrowableArray<VMReg>& input_registers,\n-                         const GrowableArray<VMReg>& output_registers,\n-                         bool needs_return_buffer)\n+                         const GrowableArray<VMStorage>& input_registers,\n+                         const GrowableArray<VMStorage>& output_registers,\n+                         bool needs_return_buffer,\n+                         int captured_state_mask)\n@@ -69,0 +71,1 @@\n+     _captured_state_mask(captured_state_mask),\n@@ -70,1 +73,1 @@\n-     _framesize(0),\n+     _frame_size_slots(0),\n@@ -80,2 +83,2 @@\n-  int framesize() const {\n-    return (_framesize >> (LogBytesPerWord - LogBytesPerInt));\n+  int framesize() const { \/\/ frame size in 64-bit words\n+    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n@@ -95,4 +98,5 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n-                                                bool needs_return_buffer) {\n-  int locs_size  = 64;\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n+  int locs_size = 64;\n@@ -100,1 +104,3 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                          input_registers, output_registers,\n+                          needs_return_buffer, captured_state_mask);\n@@ -136,1 +142,1 @@\n-  Register shufffle_reg = rbx;\n+  VMStorage shuffle_reg = as_VMStorage(rbx);\n@@ -139,1 +145,1 @@\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shufffle_reg->as_VMReg());\n+  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n@@ -152,4 +158,0 @@\n-  if (_needs_return_buffer) {\n-    allocated_frame_size += 8; \/\/ store address\n-  }\n-  allocated_frame_size += arg_shuffle.out_arg_stack_slots() << LogBytesPerInt;\n@@ -157,0 +159,1 @@\n+  allocated_frame_size += arg_shuffle.out_arg_bytes();\n@@ -158,8 +161,2 @@\n-  int ret_buf_addr_rsp_offset = -1;\n-  if (_needs_return_buffer) {\n-    \/\/ the above\n-    ret_buf_addr_rsp_offset = allocated_frame_size - 8;\n-  }\n-\n-  \/\/ when we don't use a return buffer we need to spill the return value around our slowpath calls\n-  \/\/ when we use a return buffer case this SHOULD be unused.\n+  \/\/ when we don't use a return buffer we need to spill the return value around our slow path calls\n+  bool should_save_return_value = !_needs_return_buffer;\n@@ -169,1 +166,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -171,1 +168,3 @@\n-    \/\/ spill area can be shared with the above, so we take the max of the 2\n+    \/\/ spill area can be shared with shadow space and out args,\n+    \/\/ since they are only used before the call,\n+    \/\/ and spill area is only used after.\n@@ -176,0 +175,12 @@\n+\n+  StubLocations locs;\n+  locs.set(StubLocations::TARGET_ADDRESS, _abi._scratch1);\n+  if (_needs_return_buffer) {\n+    locs.set_frame_data(StubLocations::RETURN_BUFFER, allocated_frame_size);\n+    allocated_frame_size += BytesPerWord;\n+  }\n+  if (_captured_state_mask != 0) {\n+    locs.set_frame_data(StubLocations::CAPTURED_STATE_BUFFER, allocated_frame_size);\n+    allocated_frame_size += BytesPerWord;\n+  }\n+\n@@ -177,3 +188,2 @@\n-  \/\/ _framesize is in 32-bit stack slots:\n-  _framesize += framesize_base + (allocated_frame_size >> LogBytesPerInt);\n-  assert(is_even(_framesize\/2), \"sp not 16-byte aligned\");\n+  _frame_size_slots += framesize_base + (allocated_frame_size >> LogBytesPerInt);\n+  assert(is_even(_frame_size_slots\/2), \"sp not 16-byte aligned\");\n@@ -195,1 +205,1 @@\n-  OopMap* map = new OopMap(_framesize, 0);\n+  OopMap* map = new OopMap(_frame_size_slots, 0);\n@@ -203,6 +213,1 @@\n-  arg_shuffle.generate(_masm, shufffle_reg->as_VMReg(), 0, _abi._shadow_space_bytes);\n-  if (_needs_return_buffer) {\n-    \/\/ spill our return buffer address\n-    assert(ret_buf_addr_rsp_offset != -1, \"no return buffer addr spill\");\n-    __ movptr(Address(rsp, ret_buf_addr_rsp_offset), _abi._ret_buf_addr_reg);\n-  }\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes, locs);\n@@ -211,1 +216,1 @@\n-  __ call(_abi._target_addr_reg);\n+  __ call(as_Register(locs.get(StubLocations::TARGET_ADDRESS)));\n@@ -215,2 +220,1 @@\n-    assert(ret_buf_addr_rsp_offset != -1, \"no return buffer addr spill\");\n-    __ movptr(rscratch1, Address(rsp, ret_buf_addr_rsp_offset));\n+    __ movptr(rscratch1, Address(rsp, locs.data_offset(StubLocations::RETURN_BUFFER)));\n@@ -219,3 +223,3 @@\n-      VMReg reg = _output_registers.at(i);\n-      if (reg->is_Register()) {\n-        __ movptr(Address(rscratch1, offset), reg->as_Register());\n+      VMStorage reg = _output_registers.at(i);\n+      if (reg.type() == StorageType::INTEGER) {\n+        __ movptr(Address(rscratch1, offset), as_Register(reg));\n@@ -223,2 +227,2 @@\n-      } else if (reg->is_XMMRegister()) {\n-        __ movdqu(Address(rscratch1, offset), reg->as_XMMRegister());\n+      } else if (reg.type() == StorageType::VECTOR) {\n+        __ movdqu(Address(rscratch1, offset), as_XMMRegister(reg));\n@@ -232,0 +236,28 @@\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  if (_captured_state_mask != 0) {\n+    __ block_comment(\"{ save thread local\");\n+    __ vzeroupper();\n+\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n+\n+    __ movptr(c_rarg0, Address(rsp, locs.data_offset(StubLocations::CAPTURED_STATE_BUFFER)));\n+    __ movl(c_rarg1, _captured_state_mask);\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, DowncallLinker::capture_state)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n+\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n+\n+    __ block_comment(\"} save thread local\");\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n@@ -275,1 +307,1 @@\n-  if(!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -287,1 +319,1 @@\n-  if(!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -300,1 +332,1 @@\n-  if(!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -311,1 +343,1 @@\n-  if(!_needs_return_buffer) {\n+  if (should_save_return_value) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":84,"deletions":52,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-  Register _target_addr_reg;\n-  Register _ret_buf_addr_reg;\n+  VMStorage _scratch1;\n+  VMStorage _scratch2;\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -46,1 +41,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -50,1 +45,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -54,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_32.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,4 +43,0 @@\n-static constexpr int INTEGER_TYPE = 0;\n-static constexpr int VECTOR_TYPE = 1;\n-static constexpr int X87_TYPE = 2;\n-\n@@ -52,2 +48,2 @@\n-  parse_register_array(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n-  parse_register_array(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_XMMRegister);\n+  parse_register_array(inputStorage, StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, StorageType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n@@ -56,3 +52,3 @@\n-  parse_register_array(outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n-  parse_register_array(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_XMMRegister);\n-  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at(X87_TYPE));\n+  parse_register_array(outputStorage, StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, StorageType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n+  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at((int) StorageType::X87));\n@@ -62,2 +58,2 @@\n-  parse_register_array(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n-  parse_register_array(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_XMMRegister);\n+  parse_register_array(volatileStorage, StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, StorageType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n@@ -68,2 +64,2 @@\n-  abi._target_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop))->as_Register();\n-  abi._ret_buf_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop))->as_Register();\n+  abi._scratch1 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch1(abi_oop));\n+  abi._scratch2 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch2(abi_oop));\n@@ -74,19 +70,2 @@\n-enum class RegType {\n-  INTEGER = 0,\n-  VECTOR = 1,\n-  X87 = 2,\n-  STACK = 3\n-};\n-\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  switch(static_cast<RegType>(type)) {\n-    case RegType::INTEGER: return ::as_Register(index)->as_VMReg();\n-    case RegType::VECTOR: return ::as_XMMRegister(index)->as_VMReg();\n-    case RegType::STACK: return VMRegImpl::stack2reg(index LP64_ONLY(* 2)); \/\/ numbering on x64 goes per 64-bits\n-    case RegType::X87: break;\n-  }\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n-  if (reg->is_Register()) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n+  if (reg.type() == StorageType::INTEGER) {\n@@ -94,1 +73,1 @@\n-  } else if (reg->is_XMMRegister()) {\n+  } else if (reg.type() == StorageType::VECTOR) {\n@@ -100,5 +79,5 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n-  if (reg->is_Register()) {\n-    masm->movptr(Address(rsp, offset), reg->as_Register());\n-  } else if (reg->is_XMMRegister()) {\n-    masm->movdqu(Address(rsp, offset), reg->as_XMMRegister());\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n+  if (reg.type() == StorageType::INTEGER) {\n+    masm->movptr(Address(rsp, offset), as_Register(reg));\n+  } else if (reg.type() == StorageType::VECTOR) {\n+    masm->movdqu(Address(rsp, offset), as_XMMRegister(reg));\n@@ -110,5 +89,5 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n-  if (reg->is_Register()) {\n-    masm->movptr(reg->as_Register(), Address(rsp, offset));\n-  } else if (reg->is_XMMRegister()) {\n-    masm->movdqu(reg->as_XMMRegister(), Address(rsp, offset));\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n+  if (reg.type() == StorageType::INTEGER) {\n+    masm->movptr(as_Register(reg), Address(rsp, offset));\n+  } else if (reg.type() == StorageType::VECTOR) {\n+    masm->movdqu(as_XMMRegister(reg), Address(rsp, offset));\n@@ -120,2 +99,64 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n-  Register tmp_reg = tmp->as_Register();\n+static constexpr int RBP_BIAS = 16; \/\/ skip old rbp and return address\n+\n+static void move_reg64(MacroAssembler* masm, int out_stk_bias,\n+                       Register from_reg, VMStorage to_reg) {\n+  int out_bias = 0;\n+  switch (to_reg.type()) {\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->movq(as_Register(to_reg), from_reg);\n+      break;\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA:\n+      assert(to_reg.stack_size() == 8, \"only moves with 64-bit targets supported\");\n+      masm->movq(Address(rsp, to_reg.offset() + out_bias), from_reg);\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+static void move_stack64(MacroAssembler* masm, Register tmp_reg, int out_stk_bias,\n+                         Address from_address, VMStorage to_reg) {\n+  int out_bias = 0;\n+  switch (to_reg.type()) {\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->movq(as_Register(to_reg), from_address);\n+      break;\n+    case StorageType::VECTOR:\n+      assert(to_reg.segment_mask() == XMM_MASK, \"only moves to xmm registers supported\");\n+      masm->movdqu(as_XMMRegister(to_reg), from_address);\n+      break;\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA:\n+      assert(to_reg.stack_size() == 8, \"only moves with 64-bit targets supported\");\n+      masm->movq(tmp_reg, from_address);\n+      masm->movq(Address(rsp, to_reg.offset() + out_bias), tmp_reg);\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+static void move_xmm(MacroAssembler* masm, int out_stk_bias,\n+                     XMMRegister from_reg, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case StorageType::INTEGER: \/\/ windows vargarg floats\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->movq(as_Register(to_reg), from_reg);\n+      break;\n+    case StorageType::VECTOR:\n+      assert(to_reg.segment_mask() == XMM_MASK, \"only moves to xmm registers supported\");\n+      masm->movdqu(as_XMMRegister(to_reg), from_reg);\n+      break;\n+    case StorageType::STACK:\n+      assert(to_reg.stack_size() == 8, \"only moves with 64-bit targets supported\");\n+      masm->movq(Address(rsp, to_reg.offset() + out_stk_bias), from_reg);\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+  Register tmp_reg = as_Register(tmp);\n@@ -124,13 +165,2 @@\n-    BasicType arg_bt     = move.bt;\n-    VMRegPair from_vmreg = move.from;\n-    VMRegPair to_vmreg   = move.to;\n-\n-    masm->block_comment(err_msg(\"bt=%s\", null_safe_string(type2name(arg_bt))));\n-    switch (arg_bt) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-        masm->move32_64(from_vmreg, to_vmreg, tmp_reg, in_stk_bias, out_stk_bias);\n-        break;\n+    VMStorage from_reg = move.from;\n+    VMStorage to_reg   = move.to;\n@@ -138,7 +168,7 @@\n-      case T_FLOAT:\n-        if (to_vmreg.first()->is_Register()) { \/\/ Windows vararg call\n-          masm->movq(to_vmreg.first()->as_Register(), from_vmreg.first()->as_XMMRegister());\n-        } else {\n-          masm->float_move(from_vmreg, to_vmreg, tmp_reg, in_stk_bias, out_stk_bias);\n-        }\n-        break;\n+    \/\/ replace any placeholders\n+    if (from_reg.type() == StorageType::PLACEHOLDER) {\n+      from_reg = locs.get(from_reg);\n+    }\n+    if (to_reg.type() == StorageType::PLACEHOLDER) {\n+      to_reg = locs.get(to_reg);\n+    }\n@@ -146,6 +176,4 @@\n-      case T_DOUBLE:\n-        if (to_vmreg.first()->is_Register()) { \/\/ Windows vararg call\n-          masm->movq(to_vmreg.first()->as_Register(), from_vmreg.first()->as_XMMRegister());\n-        } else {\n-          masm->double_move(from_vmreg, to_vmreg, tmp_reg, in_stk_bias, out_stk_bias);\n-        }\n+    switch (from_reg.type()) {\n+      case StorageType::INTEGER:\n+        assert(from_reg.segment_mask() == REG64_MASK, \"only 64-bit register supported\");\n+        move_reg64(masm, out_stk_bias, as_Register(from_reg), to_reg);\n@@ -153,3 +181,3 @@\n-\n-      case T_LONG:\n-        masm->long_move(from_vmreg, to_vmreg, tmp_reg, in_stk_bias, out_stk_bias);\n+      case StorageType::VECTOR:\n+        assert(from_reg.segment_mask() == XMM_MASK, \"only xmm register supported\");\n+        move_xmm(masm, out_stk_bias, as_XMMRegister(from_reg), to_reg);\n@@ -157,3 +185,6 @@\n-\n-      default:\n-        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+      case StorageType::STACK: {\n+        assert(from_reg.stack_size() == 8, \"only stack_size 8 supported\");\n+        Address from_addr(rbp, RBP_BIAS + from_reg.offset() + in_stk_bias);\n+        move_stack64(masm, tmp_reg, out_stk_bias, from_addr, to_reg);\n+      } break;\n+      default: ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":108,"deletions":77,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-    int   raw_encoding() const      { return this - first(); }\n-    int   encoding() const          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool  is_valid() const          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int   raw_encoding() const { return this - first(); }\n+    constexpr int       encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool      is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -77,1 +77,1 @@\n-  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n+  constexpr const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -205,3 +205,3 @@\n-    int raw_encoding() const  { return this - first(); }\n-    int   encoding() const    { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool  is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -222,1 +222,1 @@\n-  const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n+  constexpr const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  Register shuffle_reg = rbx;\n+  VMStorage shuffle_reg = as_VMStorage(rbx);\n@@ -181,3 +181,4 @@\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n-  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n-  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg);\n+  int preserved_bytes = SharedRuntime::out_preserve_stack_slots() * VMRegImpl::stack_slot_size;\n+  int stack_bytes = preserved_bytes + arg_shuffle.out_arg_bytes();\n+  int out_arg_area = align_up(stack_bytes , StackAlignmentInBytes);\n@@ -211,0 +212,1 @@\n+  StubLocations locs;\n@@ -215,0 +217,3 @@\n+    \/\/ use a free register for shuffling code to pick up return\n+    \/\/ buffer address from\n+    locs.set(StubLocations::RETURN_BUFFER, abi._scratch1);\n@@ -276,1 +281,1 @@\n-    __ lea(abi._ret_buf_addr_reg, Address(rsp, ret_buf_offset));\n+    __ lea(as_Register(locs.get(StubLocations::RETURN_BUFFER)), Address(rsp, ret_buf_offset));\n@@ -278,1 +283,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n+  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, 0, locs);\n@@ -296,1 +301,1 @@\n-      VMReg j_expected_result_reg;\n+      VMStorage j_expected_result_reg;\n@@ -304,1 +309,1 @@\n-        j_expected_result_reg = rax->as_VMReg();\n+        j_expected_result_reg = as_VMStorage(rax);\n@@ -308,1 +313,1 @@\n-          j_expected_result_reg = xmm0->as_VMReg();\n+          j_expected_result_reg = as_VMStorage(xmm0);\n@@ -315,2 +320,1 @@\n-      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n-        \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg, \"unexpected result register\");\n@@ -324,3 +328,3 @@\n-      VMReg reg = call_regs._ret_regs.at(i);\n-      if (reg->is_Register()) {\n-        __ movptr(reg->as_Register(), Address(rscratch1, offset));\n+      VMStorage reg = call_regs._ret_regs.at(i);\n+      if (reg.type() == StorageType::INTEGER) {\n+        __ movptr(as_Register(reg), Address(rscratch1, offset));\n@@ -328,2 +332,2 @@\n-      } else if (reg->is_XMMRegister()) {\n-        __ movdqu(reg->as_XMMRegister(), Address(rscratch1, offset));\n+      } else if (reg.type() == StorageType::VECTOR) {\n+        __ movdqu(as_XMMRegister(reg), Address(rscratch1, offset));\n@@ -392,2 +396,5 @@\n-  if (TraceOptimizedUpcallStubs) {\n-    blob->print_on(tty);\n+#ifndef PRODUCT\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    blob->print_on(&ls);\n@@ -395,0 +402,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_X86_VMSTORAGE_X86_INLINE_HPP\n+#define CPU_X86_VMSTORAGE_X86_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+\n+\/\/ keep in sync with jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture\n+enum class StorageType : int8_t {\n+  INTEGER = 0,\n+  VECTOR = 1,\n+  X87 = 2,\n+  STACK = 3,\n+  PLACEHOLDER = 4,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return type == StorageType::INTEGER || type == StorageType::VECTOR || type == StorageType::X87;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+constexpr uint16_t REG64_MASK = 0b0000000000001111;\n+constexpr uint16_t XMM_MASK   = 0b0000000000000001;\n+\n+inline Register as_Register(VMStorage vms) {\n+  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n+  return ::as_Register(vms.index());\n+}\n+\n+inline XMMRegister as_XMMRegister(VMStorage vms) {\n+  assert(vms.type() == StorageType::VECTOR, \"not the right type\");\n+  return ::as_XMMRegister(vms.index());\n+}\n+\n+inline VMReg as_VMReg(VMStorage vms) {\n+  switch (vms.type()) {\n+    case StorageType::INTEGER: return as_Register(vms)->as_VMReg();\n+    case StorageType::VECTOR:  return as_XMMRegister(vms)->as_VMReg();\n+    case StorageType::STACK: {\n+      assert((vms.index() % VMRegImpl::stack_slot_size) == 0, \"can not represent as VMReg\");\n+      return VMRegImpl::stack2reg(vms.index() \/ VMRegImpl::stack_slot_size);\n+    }\n+    default: ShouldNotReachHere(); return VMRegImpl::Bad();\n+  }\n+}\n+\n+constexpr inline VMStorage as_VMStorage(Register reg) {\n+  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n+}\n+\n+constexpr inline VMStorage as_VMStorage(XMMRegister reg) {\n+  return VMStorage::reg_storage(StorageType::VECTOR, XMM_MASK, reg->encoding());\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  if (reg->is_Register()) {\n+    return as_VMStorage(reg->as_Register());\n+  } else if (reg->is_XMMRegister()) {\n+    return as_VMStorage(reg->as_XMMRegister());\n+  } else if (reg->is_stack()) {\n+    return VMStorage::stack_storage(reg);\n+  } else if (!reg->is_valid()) {\n+    return VMStorage::invalid();\n+  }\n+\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ CPU_X86_VMSTORAGE_X86_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/vmstorage_x86.inline.hpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -31,3 +31,4 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n-                                                bool needs_return_buffer) {\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/zero\/downcallLinker_zero.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -46,1 +41,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -50,1 +45,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -54,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/zero\/foreignGlobals_zero.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_ZERO_VMSTORAGE_ZERO_INLINE_HPP\n+#define CPU_ZERO_VMSTORAGE_ZERO_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+\n+#endif \/\/ CPU_ZERO_VMSTORAGE_ZERO_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/zero\/vmstorage_zero.inline.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -4163,2 +4163,2 @@\n-int jdk_internal_foreign_abi_ABIDescriptor::_targetAddrStorage_offset;\n-int jdk_internal_foreign_abi_ABIDescriptor::_retBufAddrStorage_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_scratch1_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_scratch2_offset;\n@@ -4167,7 +4167,7 @@\n-  macro(_inputStorage_offset,      k, \"inputStorage\",      jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_outputStorage_offset,     k, \"outputStorage\",     jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_volatileStorage_offset,   k, \"volatileStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_stackAlignment_offset,    k, \"stackAlignment\",    int_signature, false); \\\n-  macro(_shadowSpace_offset,       k, \"shadowSpace\",       int_signature, false); \\\n-  macro(_targetAddrStorage_offset, k, \"targetAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false); \\\n-  macro(_retBufAddrStorage_offset, k, \"retBufAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false);\n+  macro(_inputStorage_offset,    k, \"inputStorage\",    jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_outputStorage_offset,   k, \"outputStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_volatileStorage_offset, k, \"volatileStorage\", jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_stackAlignment_offset,  k, \"stackAlignment\",  int_signature, false); \\\n+  macro(_shadowSpace_offset,     k, \"shadowSpace\",     int_signature, false); \\\n+  macro(_scratch1_offset,        k, \"scratch1\",        jdk_internal_foreign_abi_VMStorage_signature, false); \\\n+  macro(_scratch2_offset,        k, \"scratch2\",        jdk_internal_foreign_abi_VMStorage_signature, false);\n@@ -4210,2 +4210,2 @@\n-oop jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(oop entry) {\n-  return entry->obj_field(_targetAddrStorage_offset);\n+oop jdk_internal_foreign_abi_ABIDescriptor::scratch1(oop entry) {\n+  return entry->obj_field(_scratch1_offset);\n@@ -4214,2 +4214,2 @@\n-oop jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(oop entry) {\n-  return entry->obj_field(_retBufAddrStorage_offset);\n+oop jdk_internal_foreign_abi_ABIDescriptor::scratch2(oop entry) {\n+  return entry->obj_field(_scratch2_offset);\n@@ -4219,1 +4219,2 @@\n-int jdk_internal_foreign_abi_VMStorage::_index_offset;\n+int jdk_internal_foreign_abi_VMStorage::_indexOrOffset_offset;\n+int jdk_internal_foreign_abi_VMStorage::_segmentMaskOrSize_offset;\n@@ -4223,3 +4224,4 @@\n-  macro(_type_offset,      k, \"type\",      int_signature, false); \\\n-  macro(_index_offset,     k, \"index\",     int_signature, false); \\\n-  macro(_debugName_offset, k, \"debugName\", string_signature, false); \\\n+  macro(_type_offset,              k, \"type\",              byte_signature, false); \\\n+  macro(_indexOrOffset_offset,     k, \"indexOrOffset\",     int_signature, false); \\\n+  macro(_segmentMaskOrSize_offset, k, \"segmentMaskOrSize\", short_signature, false); \\\n+  macro(_debugName_offset,         k, \"debugName\",         string_signature, false); \\\n@@ -4242,2 +4244,2 @@\n-jint jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n-  return entry->int_field(_type_offset);\n+jbyte jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n+  return entry->byte_field(_type_offset);\n@@ -4246,2 +4248,6 @@\n-jint jdk_internal_foreign_abi_VMStorage::index(oop entry) {\n-  return entry->int_field(_index_offset);\n+jint jdk_internal_foreign_abi_VMStorage::index_or_offset(oop entry) {\n+  return entry->int_field(_indexOrOffset_offset);\n+}\n+\n+jshort jdk_internal_foreign_abi_VMStorage::segment_mask_or_size(oop entry) {\n+  return entry->short_field(_segmentMaskOrSize_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":27,"deletions":21,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1139,2 +1139,2 @@\n-  static int _targetAddrStorage_offset;\n-  static int _retBufAddrStorage_offset;\n+  static int _scratch1_offset;\n+  static int _scratch2_offset;\n@@ -1153,2 +1153,2 @@\n-  static oop         targetAddrStorage(oop entry);\n-  static oop         retBufAddrStorage(oop entry);\n+  static oop         scratch1(oop entry);\n+  static oop         scratch2(oop entry);\n@@ -1169,1 +1169,2 @@\n-  static int _index_offset;\n+  static int _indexOrOffset_offset;\n+  static int _segmentMaskOrSize_offset;\n@@ -1178,3 +1179,4 @@\n-  static jint        type(oop entry);\n-  static jint        index(oop entry);\n-  static oop         debugName(oop entry);\n+  static jbyte  type(oop entry);\n+  static jint   index_or_offset(oop entry);\n+  static jshort segment_mask_or_size(oop entry);\n+  static oop    debugName(oop entry);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -795,0 +795,1 @@\n+  Disassembler::decode((RuntimeBlob*)this, st);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  int        _frame_size;                        \/\/ size of stack frame\n+  int        _frame_size;                        \/\/ size of stack frame in words (NOT slots. On x64 these are 64bit words)\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"downcallLinker.hpp\"\n+\n+#include <cerrno>\n+#ifdef _WIN64\n+#include <Windows.h>\n+#include <Winsock2.h>\n+#endif\n+\n+void DowncallLinker::capture_state(int32_t* value_ptr, int captured_state_mask) {\n+  \/\/ keep in synch with jdk.internal.foreign.abi.PreservableValues\n+  enum PreservableValues {\n+    NONE = 0,\n+    GET_LAST_ERROR = 1,\n+    WSA_GET_LAST_ERROR = 1 << 1,\n+    ERRNO = 1 << 2\n+  };\n+#ifdef _WIN64\n+  if (captured_state_mask & GET_LAST_ERROR) {\n+    *value_ptr = GetLastError();\n+    value_ptr++;\n+  }\n+  if (captured_state_mask & WSA_GET_LAST_ERROR) {\n+    *value_ptr = WSAGetLastError();\n+    value_ptr++;\n+  }\n+#endif\n+  if (captured_state_mask & ERRNO) {\n+    *value_ptr = errno;\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -37,3 +37,6 @@\n-                                         const GrowableArray<VMReg>& input_registers,\n-                                         const GrowableArray<VMReg>& output_registers,\n-                                         bool needs_return_buffer);\n+                                         const GrowableArray<VMStorage>& input_registers,\n+                                         const GrowableArray<VMStorage>& output_registers,\n+                                         bool needs_return_buffer,\n+                                         int captured_state_mask);\n+\n+  static void capture_state(int32_t* value_ptr, int captured_state_mask);\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,33 @@\n+StubLocations::StubLocations() {\n+  for (uint32_t i = 0; i < LOCATION_LIMIT; i++) {\n+    _locs[i] = VMStorage::invalid();\n+  }\n+}\n+\n+void StubLocations::set(uint32_t loc, VMStorage storage) {\n+  assert(loc < LOCATION_LIMIT, \"oob\");\n+  _locs[loc] = storage;\n+}\n+\n+void StubLocations::set_frame_data(uint32_t loc, int offset) {\n+  set(loc, VMStorage(StorageType::FRAME_DATA, 8, offset));\n+}\n+\n+VMStorage StubLocations::get(uint32_t loc) const {\n+  assert(loc < LOCATION_LIMIT, \"oob\");\n+  VMStorage storage = _locs[loc];\n+  assert(storage.is_valid(), \"not set\");\n+  return storage;\n+}\n+\n+VMStorage StubLocations::get(VMStorage placeholder) const {\n+  assert(placeholder.type() == StorageType::PLACEHOLDER, \"must be\");\n+  return get(placeholder.index());\n+}\n+\n+int StubLocations::data_offset(uint32_t loc) const {\n+  VMStorage storage = get(loc);\n+  assert(storage.type() == StorageType::FRAME_DATA, \"must be\");\n+  return storage.offset();\n+}\n+\n@@ -52,4 +85,6 @@\n-VMReg ForeignGlobals::parse_vmstorage(oop storage) {\n-  jint index = jdk_internal_foreign_abi_VMStorage::index(storage);\n-  jint type = jdk_internal_foreign_abi_VMStorage::type(storage);\n-  return vmstorage_to_vmreg(type, index);\n+VMStorage ForeignGlobals::parse_vmstorage(oop storage) {\n+  jbyte type = jdk_internal_foreign_abi_VMStorage::type(storage);\n+  jshort segment_mask_or_size = jdk_internal_foreign_abi_VMStorage::segment_mask_or_size(storage);\n+  jint index_or_offset = jdk_internal_foreign_abi_VMStorage::index_or_offset(storage);\n+\n+  return VMStorage(static_cast<StorageType>(type), segment_mask_or_size, index_or_offset);\n@@ -58,1 +93,1 @@\n-int RegSpiller::compute_spill_area(const GrowableArray<VMReg>& regs) {\n+int RegSpiller::compute_spill_area(const GrowableArray<VMStorage>& regs) {\n@@ -70,1 +105,1 @@\n-    VMReg reg = _regs.at(i);\n+    VMStorage reg = _regs.at(i);\n@@ -84,13 +119,9 @@\n-    BasicType arg_bt     = move.bt;\n-    VMRegPair from_vmreg = move.from;\n-    VMRegPair to_vmreg   = move.to;\n-\n-    os->print(\"Move a %s from (\", null_safe_string(type2name(arg_bt)));\n-    from_vmreg.first()->print_on(os);\n-    os->print(\",\");\n-    from_vmreg.second()->print_on(os);\n-    os->print(\") to (\");\n-    to_vmreg.first()->print_on(os);\n-    os->print(\",\");\n-    to_vmreg.second()->print_on(os);\n-    os->print_cr(\")\");\n+    BasicType arg_bt   = move.bt;\n+    VMStorage from_reg = move.from;\n+    VMStorage to_reg   = move.to;\n+\n+    os->print(\"Move a %s from \", null_safe_string(type2name(arg_bt)));\n+    from_reg.print_on(os);\n+    os->print(\" to \");\n+    to_reg.print_on(os);\n+    os->print_cr(\"\");\n@@ -98,1 +129,1 @@\n-  os->print_cr(\"Stack argument slots: %d\", _out_arg_stack_slots);\n+  os->print_cr(\"Stack argument bytes: %d\", _out_arg_bytes);\n@@ -102,1 +133,1 @@\n-int NativeCallingConvention::calling_convention(BasicType* sig_bt, VMRegPair* out_regs, int num_args) const {\n+int NativeCallingConvention::calling_convention(const BasicType* sig_bt, VMStorage* out_regs, int num_args) const {\n@@ -104,1 +135,1 @@\n-  int stk_slots = 0;\n+  uint32_t max_stack_offset = 0;\n@@ -113,5 +144,4 @@\n-        assert(src_pos < _input_regs.length(), \"oob\");\n-        VMReg reg = _input_regs.at(src_pos++);\n-        out_regs[i].set1(reg);\n-        if (reg->is_stack())\n-          stk_slots += 2;\n+        VMStorage reg = _input_regs.at(src_pos++);\n+        out_regs[i] = reg;\n+        if (reg.is_stack())\n+          max_stack_offset = MAX2(max_stack_offset, reg.offset() + reg.stack_size());\n@@ -123,5 +153,4 @@\n-        assert(src_pos < _input_regs.length(), \"oob\");\n-        VMReg reg = _input_regs.at(src_pos++);\n-        out_regs[i].set2(reg);\n-        if (reg->is_stack())\n-          stk_slots += 2;\n+        VMStorage reg = _input_regs.at(src_pos++);\n+        out_regs[i] = reg;\n+        if (reg.is_stack())\n+          max_stack_offset = MAX2(max_stack_offset, reg.offset() + reg.stack_size());\n@@ -132,1 +161,1 @@\n-        out_regs[i].set_bad();\n+        out_regs[i] = VMStorage::invalid();\n@@ -139,1 +168,14 @@\n-  return stk_slots;\n+  return align_up(max_stack_offset, 8);\n+}\n+\n+int JavaCallingConvention::calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const {\n+  VMRegPair* vm_regs = NEW_RESOURCE_ARRAY(VMRegPair, num_args);\n+  int slots = SharedRuntime::java_calling_convention(sig_bt, vm_regs, num_args);\n+  for (int i = 0; i < num_args; i++) {\n+    VMRegPair pair = vm_regs[i];\n+    \/\/ note, we ignore second here. Signature should consist of register-size values. So there should be\n+    \/\/ no need for multi-register pairs.\n+    \/\/assert(!pair.first()->is_valid() || pair.is_single_reg(), \"must be: %s\");\n+    regs[i] = as_VMStorage(pair.first());\n+  }\n+  return slots << LogBytesPerInt;\n@@ -146,9 +188,11 @@\n-    VMRegPair      _src;\n-    VMRegPair      _dst;\n-    bool           _processed;\n-    MoveOperation* _next;\n-    MoveOperation* _prev;\n-    BasicType      _bt;\n-\n-    static int get_id(VMRegPair r) {\n-      return r.first()->value();\n+    VMStorage        _src;\n+    VMStorage        _dst;\n+    bool             _processed;\n+    MoveOperation*  _next;\n+    MoveOperation*  _prev;\n+    BasicType       _bt;\n+\n+    static int get_id(VMStorage r) {\n+      assert((r.index_or_offset() & 0xFF000000) == 0, \"index or offset too large\");\n+      \/\/ assuming mask and size doesn't matter for now\n+      return ((int) r.type()) | (r.index_or_offset() << 8);\n@@ -158,2 +202,2 @@\n-    MoveOperation(VMRegPair src, VMRegPair dst, BasicType bt)\n-      : _src(src), _dst(dst), _processed(false), _next(NULL), _prev(NULL), _bt(bt) {}\n+    MoveOperation(VMStorage src, VMStorage dst, BasicType bt):\n+      _src(src), _dst(dst), _processed(false), _next(NULL), _prev(NULL), _bt(bt) {}\n@@ -169,1 +213,1 @@\n-    void break_cycle(VMRegPair temp_register) {\n+    void break_cycle(VMStorage temp_register) {\n@@ -203,1 +247,1 @@\n-  const VMRegPair* _in_regs;\n+  const VMStorage* _in_regs;\n@@ -205,1 +249,1 @@\n-  const VMRegPair* _out_regs;\n+  const VMStorage* _out_regs;\n@@ -207,1 +251,1 @@\n-  VMRegPair _tmp_vmreg;\n+  VMStorage _tmp_vmreg;\n@@ -211,2 +255,3 @@\n-  ComputeMoveOrder(int total_in_args, const VMRegPair* in_regs, int total_out_args, VMRegPair* out_regs,\n-                   const BasicType* in_sig_bt, VMRegPair tmp_vmreg) :\n+ public:\n+  ComputeMoveOrder(int total_in_args, const VMStorage* in_regs, int total_out_args, VMStorage* out_regs,\n+                   const BasicType* in_sig_bt, VMStorage tmp_vmreg) :\n@@ -235,2 +280,2 @@\n-      VMRegPair in_reg = _in_regs[in_idx];\n-      VMRegPair out_reg = _out_regs[out_idx];\n+      VMStorage in_reg = _in_regs[in_idx];\n+      VMStorage out_reg = _out_regs[out_idx];\n@@ -238,1 +283,1 @@\n-      if (out_reg.first()->is_stack()) {\n+      if (out_reg.is_stack()) {\n@@ -244,1 +289,1 @@\n-      } else if (in_reg.first() == out_reg.first()\n+      } else if (in_reg == out_reg\n@@ -262,1 +307,1 @@\n-  void compute_store_order(VMRegPair temp_register) {\n+  void compute_store_order(VMStorage temp_register) {\n@@ -264,0 +309,1 @@\n+    \/\/ FIXME should be a map\n@@ -307,3 +353,3 @@\n-  static GrowableArray<Move> compute_move_order(int total_in_args, const VMRegPair* in_regs,\n-                                                int total_out_args, VMRegPair* out_regs,\n-                                                const BasicType* in_sig_bt, VMRegPair tmp_vmreg) {\n+  static GrowableArray<Move> compute_move_order(int total_in_args, const VMStorage* in_regs,\n+                                                int total_out_args, VMStorage* out_regs,\n+                                                const BasicType* in_sig_bt, VMStorage tmp_vmreg) {\n@@ -323,1 +369,1 @@\n-    VMReg shuffle_temp) {\n+    VMStorage shuffle_temp) {\n@@ -325,1 +371,1 @@\n-  VMRegPair* in_regs = NEW_RESOURCE_ARRAY(VMRegPair, num_in_args);\n+  VMStorage* in_regs = NEW_RESOURCE_ARRAY(VMStorage, num_in_args);\n@@ -328,5 +374,2 @@\n-  VMRegPair* out_regs = NEW_RESOURCE_ARRAY(VMRegPair, num_out_args);\n-  _out_arg_stack_slots = output_conv->calling_convention(out_sig_bt, out_regs, num_out_args);\n-\n-  VMRegPair tmp_vmreg;\n-  tmp_vmreg.set2(shuffle_temp);\n+  VMStorage* out_regs = NEW_RESOURCE_ARRAY(VMStorage, num_out_args);\n+  _out_arg_bytes = output_conv->calling_convention(out_sig_bt, out_regs, num_out_args);\n@@ -334,6 +377,0 @@\n-  \/\/ Compute a valid move order, using tmp_vmreg to break any cycles.\n-  \/\/ Note that ComputeMoveOrder ignores the upper half of our VMRegPairs.\n-  \/\/ We are not moving Java values here, only register-sized values,\n-  \/\/ so we shouldn't have to worry about the upper half any ways.\n-  \/\/ This should work fine on 32-bit as well, since we would only be\n-  \/\/ moving 32-bit sized values (i.e. low-level MH shouldn't take any double\/long).\n@@ -342,1 +379,1 @@\n-                                                in_sig_bt, tmp_vmreg);\n+                                                in_sig_bt, shuffle_temp);\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":110,"deletions":73,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"prims\/vmstorage.inline.hpp\"\n@@ -35,0 +36,23 @@\n+\/\/ needs to match StubLocations in Java code.\n+\/\/ placeholder locations to be filled in by\n+\/\/ the code gen code\n+class StubLocations {\n+public:\n+  enum Location : uint32_t {\n+    TARGET_ADDRESS,\n+    RETURN_BUFFER,\n+    CAPTURED_STATE_BUFFER,\n+    LOCATION_LIMIT\n+  };\n+private:\n+  VMStorage _locs[LOCATION_LIMIT];\n+public:\n+  StubLocations();\n+\n+  void set(uint32_t loc, VMStorage storage);\n+  void set_frame_data(uint32_t loc, int offset);\n+  VMStorage get(uint32_t loc) const;\n+  VMStorage get(VMStorage placeholder) const;\n+  int data_offset(uint32_t loc) const;\n+};\n+\n@@ -37,1 +61,1 @@\n-  virtual int calling_convention(BasicType* sig_bt, VMRegPair* regs, int num_args) const = 0;\n+  virtual int calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const = 0;\n@@ -41,2 +65,2 @@\n-  GrowableArray<VMReg> _arg_regs;\n-  GrowableArray<VMReg> _ret_regs;\n+  GrowableArray<VMStorage> _arg_regs;\n+  GrowableArray<VMStorage> _ret_regs;\n@@ -48,0 +72,1 @@\n+\n@@ -50,2 +75,2 @@\n-  template<typename T, typename Func>\n-  static void parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter);\n+  template<typename T>\n+  static void parse_register_array(objArrayOop jarray, StorageType type_index, GrowableArray<T>& array, T (*converter)(int));\n@@ -56,2 +81,1 @@\n-  static VMReg vmstorage_to_vmreg(int type, int index);\n-  static VMReg parse_vmstorage(oop storage);\n+  static VMStorage parse_vmstorage(oop storage);\n@@ -60,2 +84,0 @@\n-\n-\n@@ -64,3 +86,1 @@\n-  int calling_convention(BasicType* sig_bt, VMRegPair* regs, int num_args) const override {\n-    return SharedRuntime::java_calling_convention(sig_bt, regs, num_args);\n-  }\n+  int calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const override;\n@@ -70,1 +90,1 @@\n-  GrowableArray<VMReg> _input_regs;\n+  GrowableArray<VMStorage> _input_regs;\n@@ -72,1 +92,1 @@\n-  NativeCallingConvention(const GrowableArray<VMReg>& input_regs)\n+  NativeCallingConvention(const GrowableArray<VMStorage>& input_regs)\n@@ -75,1 +95,1 @@\n-  int calling_convention(BasicType* sig_bt, VMRegPair* out_regs, int num_args) const override;\n+  int calling_convention(const BasicType* sig_bt, VMStorage* out_regs, int num_args) const override;\n@@ -79,1 +99,1 @@\n-  GrowableArray<VMReg> _regs;\n+  GrowableArray<VMStorage> _regs;\n@@ -82,1 +102,1 @@\n-  RegSpiller(const GrowableArray<VMReg>& regs) : _regs(regs), _spill_size_bytes(compute_spill_area(regs)) {\n+  RegSpiller(const GrowableArray<VMStorage>& regs) : _regs(regs), _spill_size_bytes(compute_spill_area(regs)) {\n@@ -90,1 +110,1 @@\n-  static int compute_spill_area(const GrowableArray<VMReg>& regs);\n+  static int compute_spill_area(const GrowableArray<VMStorage>& regs);\n@@ -93,3 +113,3 @@\n-  static int pd_reg_size(VMReg reg);\n-  static void pd_store_reg(MacroAssembler* masm, int offset, VMReg reg);\n-  static void pd_load_reg(MacroAssembler* masm, int offset, VMReg reg);\n+  static int pd_reg_size(VMStorage reg);\n+  static void pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg);\n+  static void pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg);\n@@ -100,2 +120,2 @@\n-  VMRegPair from;\n-  VMRegPair to;\n+  VMStorage from;\n+  VMStorage to;\n@@ -107,1 +127,1 @@\n-  int _out_arg_stack_slots;\n+  int _out_arg_bytes;\n@@ -113,1 +133,1 @@\n-    VMReg shuffle_temp);\n+    VMStorage shuffle_temp);\n@@ -115,3 +135,3 @@\n-  int out_arg_stack_slots() const { return _out_arg_stack_slots; }\n-  void generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n-    pd_generate(masm, tmp, in_stk_bias, out_stk_bias);\n+  int out_arg_bytes() const { return _out_arg_bytes; }\n+  void generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+    pd_generate(masm, tmp, in_stk_bias, out_stk_bias, locs);\n@@ -122,1 +142,1 @@\n-  void pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const;\n+  void pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const;\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":49,"deletions":29,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-template<typename T, typename Func>\n-void ForeignGlobals::parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) {\n-  objArrayOop subarray = oop_cast<objArrayOop>(jarray->obj_at(type_index));\n+template<typename T>\n+void ForeignGlobals::parse_register_array(objArrayOop jarray, StorageType type_index, GrowableArray<T>& array, T (*converter)(int)) {\n+  objArrayOop subarray = oop_cast<objArrayOop>(jarray->obj_at((int) type_index));\n@@ -40,1 +40,1 @@\n-    jint index = jdk_internal_foreign_abi_VMStorage::index(storage);\n+    jint index = jdk_internal_foreign_abi_VMStorage::index_or_offset(storage);\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-                                      jobjectArray arg_moves, jobjectArray ret_moves, jboolean needs_return_buffer))\n+                                      jobjectArray arg_moves, jobjectArray ret_moves,\n+                                      jboolean needs_return_buffer, jint captured_state_mask))\n@@ -50,1 +51,1 @@\n-  GrowableArray<VMReg> input_regs(pcount);\n+  GrowableArray<VMStorage> input_regs(pcount);\n@@ -68,1 +69,1 @@\n-  GrowableArray<VMReg> output_regs(outs);\n+  GrowableArray<VMStorage> output_regs(outs);\n@@ -77,2 +78,3 @@\n-  return (jlong) DowncallLinker::make_downcall_stub(\n-    basic_type, pslots, ret_bt, abi, input_regs, output_regs, needs_return_buffer)->code_begin();\n+  return (jlong) DowncallLinker::make_downcall_stub(basic_type, pslots, ret_bt, abi,\n+                                                    input_regs, output_regs,\n+                                                    needs_return_buffer, captured_state_mask)->code_begin();\n@@ -98,1 +100,1 @@\n-  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"Z)J\", FN_PTR(NEP_makeDowncallStub)},\n+  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"ZI)J\", FN_PTR(NEP_makeDowncallStub)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/vmstorage.inline.hpp\"\n+\n+void VMStorage::print_on(outputStream* os) const {\n+  os->print(\"{type=%d, index=%d, %s=%d}\", static_cast<int8_t>(_type), _index_or_offset,\n+    is_stack() ? \"size\" : \"segment_mask\", _segment_mask_or_size);\n+}\n","filename":"src\/hotspot\/share\/prims\/vmstorage.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE_INLINE_HPP\n+#define SHARE_PRIMS_VMSTORAGE_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"code\/vmreg.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+enum class StorageType : int8_t; \/\/ defined in arch specific headers\n+\n+class VMStorage {\n+public:\n+  constexpr static StorageType INVALID_TYPE = static_cast<StorageType>(-1);\n+private:\n+  StorageType _type;\n+  \/\/ 1 byte of padding\n+  uint16_t _segment_mask_or_size;\n+  uint32_t _index_or_offset; \/\/ stack offset in bytes for stack storage\n+\n+  friend bool operator==(const VMStorage& a, const VMStorage& b);\n+\n+  constexpr inline static bool is_reg(StorageType type);\n+  constexpr inline static StorageType stack_type();\n+  constexpr inline static StorageType placeholder_type();\n+  constexpr inline static StorageType frame_data_type();\n+public:\n+  constexpr VMStorage() : _type(INVALID_TYPE), _segment_mask_or_size(0), _index_or_offset(0) {};\n+  constexpr VMStorage(StorageType type, uint16_t segment_mask_or_size, uint32_t index_or_offset)\n+    : _type(type), _segment_mask_or_size(segment_mask_or_size), _index_or_offset(index_or_offset) {};\n+\n+  constexpr static VMStorage reg_storage(StorageType type, uint16_t segment_mask, uint32_t index) {\n+    assert(is_reg(type), \"must be reg\");\n+    return VMStorage(type, segment_mask, index);\n+  }\n+\n+  constexpr static VMStorage stack_storage(uint16_t size, uint32_t offset) {\n+    return VMStorage(stack_type(), size, offset);\n+  }\n+\n+  static VMStorage stack_storage(VMReg reg) {\n+    return stack_storage(BytesPerWord, checked_cast<uint16_t>(reg->reg2stack() * VMRegImpl::stack_slot_size));\n+  }\n+\n+  constexpr static VMStorage invalid() {\n+    VMStorage result;\n+    result._type = INVALID_TYPE;\n+    return result;\n+  }\n+\n+  StorageType type() const { return _type; }\n+\n+  \/\/ type specific accessors to make calling code more readable\n+  uint16_t segment_mask()    const { assert(is_reg(), \"must be reg\");                  return _segment_mask_or_size; }\n+  uint16_t stack_size()      const { assert(is_stack() || is_frame_data(), \"must be\"); return _segment_mask_or_size; }\n+  uint32_t index()           const { assert(is_reg() || is_placeholder(), \"must be\");  return _index_or_offset; }\n+  uint32_t offset()          const { assert(is_stack() || is_frame_data(), \"must be\"); return _index_or_offset; }\n+  uint32_t index_or_offset() const { assert(is_valid(), \"must be valid\");              return _index_or_offset; }\n+\n+  bool is_valid()       const { return _type != INVALID_TYPE; }\n+  bool is_reg()         const { return is_reg(_type); }\n+  bool is_stack()       const { return _type == stack_type(); }\n+  bool is_placeholder() const { return _type == placeholder_type(); }\n+  bool is_frame_data()  const { return _type == frame_data_type(); }\n+\n+  void print_on(outputStream* os) const;\n+};\n+\n+inline bool operator==(const VMStorage& a, const VMStorage& b) {\n+  return a._type == b._type\n+    && a._index_or_offset == b._index_or_offset\n+    && a._segment_mask_or_size == b._segment_mask_or_size;\n+}\n+\n+#include CPU_HEADER_INLINE(vmstorage)\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_INLINE_HPP\n","filename":"src\/hotspot\/share\/prims\/vmstorage.inline.hpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -1981,3 +1981,0 @@\n-                                                                            \\\n-  develop(bool, TraceOptimizedUpcallStubs, false,                           \\\n-                \"Trace optimized upcall stub generation\")                   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.CapturableState;\n@@ -36,0 +37,4 @@\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -299,1 +304,2 @@\n-            permits LinkerOptions.FirstVariadicArg {\n+            permits LinkerOptions.LinkerOptionImpl,\n+                    Option.CaptureCallState {\n@@ -309,0 +315,66 @@\n+\n+        \/**\n+         * {@return A linker option used to save portions of the execution state immediately after\n+         *          calling a foreign function associated with a downcall method handle,\n+         *          before it can be overwritten by the Java runtime, or read through conventional means}\n+         * <p>\n+         * A downcall method handle linked with this option will feature an additional {@link MemorySegment}\n+         * parameter directly following the target address parameter. This memory segment must be a\n+         * native segment into which the captured state is written.\n+         *\n+         * @param capturedState the names of the values to save.\n+         * @see CaptureCallState#supported()\n+         *\/\n+        static CaptureCallState captureCallState(String... capturedState) {\n+            Set<CapturableState> set = Stream.of(capturedState)\n+                    .map(CapturableState::forName)\n+                    .collect(Collectors.toSet());\n+            return new LinkerOptions.CaptureCallStateImpl(set);\n+        }\n+\n+        \/**\n+         * A linker option for saving portions of the execution state immediately\n+         * after calling a foreign function associated with a downcall method handle,\n+         * before it can be overwritten by the runtime, or read through conventional means.\n+         * <p>\n+         * Execution state is captured by a downcall method handle on invocation, by writing it\n+         * to a native segment provided by the user to the downcall method handle.\n+         * <p>\n+         * The native segment should have the layout {@linkplain CaptureCallState#layout associated}\n+         * with the particular {@code CaptureCallState} instance used to link the downcall handle.\n+         * <p>\n+         * Captured state can be retrieved from this native segment by constructing var handles\n+         * from the {@linkplain #layout layout} associated with the {@code CaptureCallState} instance.\n+         * <p>\n+         * The following example demonstrates the use of this linker option:\n+         * {@snippet lang = \"java\":\n+         * MemorySegment targetAddress = ...\n+         * CaptureCallState ccs = Linker.Option.captureCallState(\"errno\");\n+         * MethodHandle handle = Linker.nativeLinker().downcallHandle(targetAddress, FunctionDescriptor.ofVoid(), ccs);\n+         *\n+         * VarHandle errnoHandle = ccs.layout().varHandle(PathElement.groupElement(\"errno\"));\n+         * try (MemorySession session = MemorySession.openConfined()) {\n+         *     MemorySegment capturedState = session.allocate(ccs.layout());\n+         *     handle.invoke(capturedState);\n+         *     int errno = errnoHandle.get(capturedState);\n+         *     \/\/ use errno\n+         * }\n+         * }\n+         *\/\n+        sealed interface CaptureCallState extends Option\n+                                          permits LinkerOptions.CaptureCallStateImpl {\n+            \/**\n+             * {@return A struct layout that represents the layout of the native segment passed\n+             *          to a downcall handle linked with this {@code CapturedCallState} instance}\n+             *\/\n+            StructLayout layout();\n+\n+            \/**\n+             * {@return the names of the state that can be capture by this implementation}\n+             *\/\n+            static Set<String> supported() {\n+                return Arrays.stream(CapturableState.values())\n+                             .map(CapturableState::stateName)\n+                             .collect(Collectors.toSet());\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+    final VMStorage scratch1;\n+    final VMStorage scratch2;\n+\n@@ -45,0 +48,1 @@\n+    final VMStorage capturedStateStorage;\n@@ -48,1 +52,3 @@\n-                         VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+                         VMStorage scratch1, VMStorage scratch2,\n+                         VMStorage targetAddrStorage, VMStorage retBufAddrStorage,\n+                         VMStorage capturedStateStorage) {\n@@ -55,0 +61,2 @@\n+        this.scratch1 = scratch1;\n+        this.scratch2 = scratch2;\n@@ -57,0 +65,1 @@\n+        this.capturedStateStorage = capturedStateStorage;\n@@ -66,0 +75,4 @@\n+\n+    public VMStorage capturedStateStorage() {\n+        return capturedStateStorage;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        LinkerOptions optionSet = LinkerOptions.of(options);\n+        LinkerOptions optionSet = LinkerOptions.forDowncall(function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-    int stackType();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Architecture.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+    private final LinkerOptions linkerOptions;\n+\n@@ -47,1 +49,2 @@\n-                           List<List<Binding>> argumentBindings, List<Binding> returnBindings) {\n+                           List<List<Binding>> argumentBindings, List<Binding> returnBindings,\n+                           LinkerOptions linkerOptions) {\n@@ -57,0 +60,1 @@\n+        this.linkerOptions = linkerOptions;\n@@ -184,0 +188,10 @@\n+    public int capturedStateMask() {\n+        return linkerOptions.capturedCallState()\n+                .mapToInt(CapturableState::mask)\n+                .reduce(0, (a, b) -> a | b);\n+    }\n+\n+    public int numLeadingParams() {\n+        return 2 + (linkerOptions.hasCapturedCallState() ? 1 : 0); \/\/ 2 for addr, allocator\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private final LinkerOptions linkerOptions;\n@@ -58,1 +59,1 @@\n-    public CallingSequenceBuilder(ABIDescriptor abi, boolean forUpcall) {\n+    public CallingSequenceBuilder(ABIDescriptor abi, boolean forUpcall, LinkerOptions linkerOptions) {\n@@ -61,0 +62,1 @@\n+        this.linkerOptions = linkerOptions;\n@@ -98,0 +100,5 @@\n+            if (linkerOptions.hasCapturedCallState()) {\n+                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                        Binding.unboxAddress(),\n+                        Binding.vmStore(abi.capturedStateStorage(), long.class)));\n+            }\n@@ -120,1 +127,1 @@\n-                returnBufferSize, allocationSize, inputBindings, outputBindings);\n+                returnBufferSize, allocationSize, inputBindings, outputBindings, linkerOptions);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.foreign.ValueLayout;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public enum CapturableState {\n+    GET_LAST_ERROR    (\"GetLastError\",    JAVA_INT, 1 << 0),\n+    WSA_GET_LAST_ERROR(\"WSAGetLastError\", JAVA_INT, 1 << 1),\n+    ERRNO             (\"errno\",           JAVA_INT, 1 << 2);\n+\n+    private final String stateName;\n+    private final ValueLayout layout;\n+    private final int mask;\n+\n+    CapturableState(String stateName, ValueLayout layout, int mask) {\n+        this.stateName = stateName;\n+        this.layout = layout.withName(stateName);\n+        this.mask = mask;\n+    }\n+\n+    public static CapturableState forName(String name) {\n+        return Stream.of(values())\n+                .filter(stl -> stl.stateName().equals(name))\n+                .findAny()\n+                .orElseThrow(() -> new IllegalArgumentException(\n+                        \"Unknown name: \" + name +\", must be one of: \"\n+                            + Stream.of(CapturableState.values())\n+                                    .map(CapturableState::stateName)\n+                                    .collect(Collectors.joining(\", \"))));\n+    }\n+\n+    public String stateName() {\n+        return stateName;\n+    }\n+\n+    public ValueLayout layout() {\n+        return layout;\n+    }\n+\n+    public int mask() {\n+        return mask;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CapturableState.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -88,1 +88,2 @@\n-            callingSequence.needsReturnBuffer()\n+            callingSequence.needsReturnBuffer(),\n+            callingSequence.capturedStateMask()\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.FunctionDescriptor;\n@@ -28,0 +29,3 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.util.Comparator;\n@@ -31,0 +35,2 @@\n+import java.util.Set;\n+import java.util.stream.Stream;\n@@ -34,2 +40,2 @@\n-    private static final LinkerOptions EMPTY = LinkerOptions.of();\n-    private final Map<Class<?>, Linker.Option> optionsMap;\n+    private static final LinkerOptions EMPTY = new LinkerOptions(Map.of());\n+    private final Map<Class<?>, LinkerOptionImpl> optionsMap;\n@@ -37,1 +43,1 @@\n-    private LinkerOptions(Map<Class<?>, Linker.Option> optionsMap) {\n+    private LinkerOptions(Map<Class<?>, LinkerOptionImpl> optionsMap) {\n@@ -41,2 +47,2 @@\n-    public static LinkerOptions of(Linker.Option... options) {\n-        Map<Class<?>, Linker.Option> optionMap = new HashMap<>();\n+    public static LinkerOptions forDowncall(FunctionDescriptor desc, Linker.Option... options) {\n+        Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n@@ -48,1 +54,3 @@\n-            optionMap.put(option.getClass(), option);\n+            LinkerOptionImpl opImpl = (LinkerOptionImpl) option;\n+            opImpl.validateForDowncall(desc);\n+            optionMap.put(option.getClass(), opImpl);\n@@ -67,0 +75,9 @@\n+    public boolean hasCapturedCallState() {\n+        return getOption(CaptureCallStateImpl.class) != null;\n+    }\n+\n+    public Stream<CapturableState> capturedCallState() {\n+        CaptureCallStateImpl stl = getOption(CaptureCallStateImpl.class);\n+        return stl == null ? Stream.empty() : stl.saved().stream();\n+    }\n+\n@@ -79,1 +96,35 @@\n-    public record FirstVariadicArg(int index) implements Linker.Option { }\n+    public sealed interface LinkerOptionImpl extends Linker.Option\n+                                             permits FirstVariadicArg,\n+                                                     CaptureCallStateImpl {\n+        default void validateForDowncall(FunctionDescriptor descriptor) {\n+            throw new IllegalArgumentException(\"Not supported for downcall: \" + this);\n+        }\n+    }\n+\n+    public record FirstVariadicArg(int index) implements LinkerOptionImpl {\n+        @Override\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            if (index < 0 || index > descriptor.argumentLayouts().size()) {\n+                throw new IllegalArgumentException(\"Index '\" + index + \"' not in bounds for descriptor: \" + descriptor);\n+            }\n+        }\n+    }\n+\n+    public record CaptureCallStateImpl(Set<CapturableState> saved) implements LinkerOptionImpl, Linker.Option.CaptureCallState {\n+\n+        @Override\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            \/\/ done during construction\n+        }\n+\n+        @Override\n+        public StructLayout layout() {\n+            return MemoryLayout.structLayout(\n+                saved.stream()\n+                      .sorted(Comparator.comparingInt(CapturableState::ordinal))\n+                      .map(CapturableState::layout)\n+                      .toArray(MemoryLayout[]::new)\n+            );\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":58,"deletions":7,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                            boolean needsReturnBuffer) {}\n+                            boolean needsReturnBuffer, int capturedStateMask) {}\n@@ -59,1 +59,3 @@\n-                                        MethodType methodType, boolean needsReturnBuffer) {\n+                                        MethodType methodType,\n+                                        boolean needsReturnBuffer,\n+                                        int capturedStateMask) {\n@@ -61,1 +63,1 @@\n-            throw new IllegalArgumentException(\"Multiple register return, but needsReturnBuffer was false\");\n+            throw new AssertionError(\"Multiple register return, but needsReturnBuffer was false\");\n@@ -63,0 +65,1 @@\n+        checkType(methodType, needsReturnBuffer, capturedStateMask);\n@@ -64,4 +67,1 @@\n-        assert (methodType.parameterType(0) == long.class) : \"Address expected\";\n-        assert (!needsReturnBuffer || methodType.parameterType(1) == long.class) : \"return buffer address expected\";\n-\n-        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer);\n+        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer, capturedStateMask);\n@@ -69,1 +69,1 @@\n-            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer);\n+            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer, capturedStateMask);\n@@ -76,0 +76,11 @@\n+    private static void checkType(MethodType methodType, boolean needsReturnBuffer, int savedValueMask) {\n+        if (methodType.parameterType(0) != long.class) {\n+            throw new AssertionError(\"Address expected as first param: \" + methodType);\n+        }\n+        int checkIdx = 1;\n+        if ((needsReturnBuffer && methodType.parameterType(checkIdx++) != long.class)\n+            || (savedValueMask != 0 && methodType.parameterType(checkIdx) != long.class)) {\n+            throw new AssertionError(\"return buffer and\/or preserved value address expected: \" + methodType);\n+        }\n+    }\n+\n@@ -78,1 +89,2 @@\n-                                                boolean needsReturnBuffer);\n+                                                boolean needsReturnBuffer,\n+                                                int capturedStateMask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    public static MethodHandle adaptDowncallForIMR(MethodHandle handle, FunctionDescriptor cDesc) {\n+    public static MethodHandle adaptDowncallForIMR(MethodHandle handle, FunctionDescriptor cDesc, CallingSequence sequence) {\n@@ -116,1 +116,2 @@\n-        if (handle.type().parameterType(2) != MemorySegment.class)\n+        int imrAddrIdx = sequence.numLeadingParams();\n+        if (handle.type().parameterType(imrAddrIdx) != MemorySegment.class)\n@@ -123,1 +124,1 @@\n-        handle = mergeArguments(handle, 0, 3);  \/\/ (MemorySegment, MemorySegment, SegmentAllocator, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 1 + imrAddrIdx);  \/\/ (MemorySegment, MemorySegment, SegmentAllocator, ...) MemorySegment\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+\/\/ must keep in sync with StubLocations in VM code\n+public enum StubLocations {\n+    TARGET_ADDRESS,\n+    RETURN_BUFFER,\n+    CAPTURED_STATE_BUFFER;\n+\n+    public VMStorage storage(byte type) {\n+        return new VMStorage(type, (short) 8, ordinal());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/StubLocations.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -27,34 +27,14 @@\n-import java.util.Objects;\n-\n-public class VMStorage {\n-    private final int type;\n-    private final int index;\n-\n-    private final String debugName;\n-\n-    public VMStorage(int type, int index, String debugName) {\n-        this.type = type;\n-        this.index = index;\n-        this.debugName = debugName;\n-    }\n-\n-    public int type() {\n-        return type;\n-    }\n-\n-    public int index() {\n-        return index;\n-    }\n-\n-    public String name() {\n-        return debugName;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        VMStorage vmStorage = (VMStorage) o;\n-        return type == vmStorage.type &&\n-                index == vmStorage.index;\n-    }\n+\/**\n+ *\n+ * @param type              the type of storage. e.g. stack, or which register type (GP, FP, vector)\n+ * @param segmentMaskOrSize the (on stack) size in bytes when type = stack, a register mask otherwise,\n+ *                          the register mask indicates which segments of a register are used.\n+ * @param indexOrOffset     the index is either a register number within a type, or\n+ *                          a stack offset in bytes if type = stack.\n+ *                          (a particular platform might add a bias to this in generate code)\n+ * @param debugName         the debug name\n+ *\/\n+public record VMStorage(byte type,\n+                        short segmentMaskOrSize,\n+                        int indexOrOffset,\n+                        String debugName) {\n@@ -62,3 +42,2 @@\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(type, index);\n+    public VMStorage(byte type, short segmentMaskOrSize, int indexOrOffset) {\n+        this(type, segmentMaskOrSize, indexOrOffset, \"Stack@\" + indexOrOffset);\n@@ -67,8 +46,0 @@\n-    @Override\n-    public String toString() {\n-        return \"VMStorage{\" +\n-                \"type=\" + type +\n-                \", index=\" + index +\n-                \", debugName='\" + debugName + '\\'' +\n-                '}';\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/VMStorage.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.StubLocations;\n@@ -35,0 +36,3 @@\n+    private static final short REG64_MASK = 0b0000_0000_0000_0001;\n+    private static final short V128_MASK = 0b0000_0000_0000_0001;\n+\n@@ -37,1 +41,0 @@\n-    private static final int STACK_SLOT_SIZE = 8;\n@@ -41,1 +44,1 @@\n-        return cls == StorageClasses.STACK;\n+        return cls == StorageType.STACK;\n@@ -47,3 +50,3 @@\n-            case StorageClasses.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageClasses.VECTOR: return VECTOR_REG_SIZE;\n-            case StorageClasses.STACK: return STACK_SLOT_SIZE;\n+            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n+            case StorageType.VECTOR: return VECTOR_REG_SIZE;\n+            \/\/ STACK is deliberately omitted\n@@ -55,3 +58,5 @@\n-    @Override\n-    public int stackType() {\n-        return StorageClasses.STACK;\n+    public interface StorageType {\n+        byte INTEGER = 0;\n+        byte VECTOR = 1;\n+        byte STACK = 2;\n+        byte PLACEHOLDER = 3;\n@@ -60,4 +65,65 @@\n-    public interface StorageClasses {\n-        int INTEGER = 0;\n-        int VECTOR = 1;\n-        int STACK = 3;\n+    public static class Regs { \/\/ break circular dependency\n+        public static final VMStorage r0 = integerRegister(0);\n+        public static final VMStorage r1 = integerRegister(1);\n+        public static final VMStorage r2 = integerRegister(2);\n+        public static final VMStorage r3 = integerRegister(3);\n+        public static final VMStorage r4 = integerRegister(4);\n+        public static final VMStorage r5 = integerRegister(5);\n+        public static final VMStorage r6 = integerRegister(6);\n+        public static final VMStorage r7 = integerRegister(7);\n+        public static final VMStorage r8 = integerRegister(8);\n+        public static final VMStorage r9 = integerRegister(9);\n+        public static final VMStorage r10 = integerRegister(10);\n+        public static final VMStorage r11 = integerRegister(11);\n+        public static final VMStorage r12 = integerRegister(12);\n+        public static final VMStorage r13 = integerRegister(13);\n+        public static final VMStorage r14 = integerRegister(14);\n+        public static final VMStorage r15 = integerRegister(15);\n+        public static final VMStorage r16 = integerRegister(16);\n+        public static final VMStorage r17 = integerRegister(17);\n+        public static final VMStorage r18 = integerRegister(18);\n+        public static final VMStorage r19 = integerRegister(19);\n+        public static final VMStorage r20 = integerRegister(20);\n+        public static final VMStorage r21 = integerRegister(21);\n+        public static final VMStorage r22 = integerRegister(22);\n+        public static final VMStorage r23 = integerRegister(23);\n+        public static final VMStorage r24 = integerRegister(24);\n+        public static final VMStorage r25 = integerRegister(25);\n+        public static final VMStorage r26 = integerRegister(26);\n+        public static final VMStorage r27 = integerRegister(27);\n+        public static final VMStorage r28 = integerRegister(28);\n+        public static final VMStorage r29 = integerRegister(29);\n+        public static final VMStorage r30 = integerRegister(30);\n+        public static final VMStorage r31 = integerRegister(31);\n+        public static final VMStorage v0 = vectorRegister(0);\n+        public static final VMStorage v1 = vectorRegister(1);\n+        public static final VMStorage v2 = vectorRegister(2);\n+        public static final VMStorage v3 = vectorRegister(3);\n+        public static final VMStorage v4 = vectorRegister(4);\n+        public static final VMStorage v5 = vectorRegister(5);\n+        public static final VMStorage v6 = vectorRegister(6);\n+        public static final VMStorage v7 = vectorRegister(7);\n+        public static final VMStorage v8 = vectorRegister(8);\n+        public static final VMStorage v9 = vectorRegister(9);\n+        public static final VMStorage v10 = vectorRegister(10);\n+        public static final VMStorage v11 = vectorRegister(11);\n+        public static final VMStorage v12 = vectorRegister(12);\n+        public static final VMStorage v13 = vectorRegister(13);\n+        public static final VMStorage v14 = vectorRegister(14);\n+        public static final VMStorage v15 = vectorRegister(15);\n+        public static final VMStorage v16 = vectorRegister(16);\n+        public static final VMStorage v17 = vectorRegister(17);\n+        public static final VMStorage v18 = vectorRegister(18);\n+        public static final VMStorage v19 = vectorRegister(19);\n+        public static final VMStorage v20 = vectorRegister(20);\n+        public static final VMStorage v21 = vectorRegister(21);\n+        public static final VMStorage v22 = vectorRegister(22);\n+        public static final VMStorage v23 = vectorRegister(23);\n+        public static final VMStorage v24 = vectorRegister(24);\n+        public static final VMStorage v25 = vectorRegister(25);\n+        public static final VMStorage v26 = vectorRegister(26);\n+        public static final VMStorage v27 = vectorRegister(27);\n+        public static final VMStorage v28 = vectorRegister(28);\n+        public static final VMStorage v29 = vectorRegister(29);\n+        public static final VMStorage v30 = vectorRegister(30);\n+        public static final VMStorage v31 = vectorRegister(31);\n@@ -66,66 +132,0 @@\n-    public static final VMStorage r0  = integerRegister(0);\n-    public static final VMStorage r1  = integerRegister(1);\n-    public static final VMStorage r2  = integerRegister(2);\n-    public static final VMStorage r3  = integerRegister(3);\n-    public static final VMStorage r4  = integerRegister(4);\n-    public static final VMStorage r5  = integerRegister(5);\n-    public static final VMStorage r6  = integerRegister(6);\n-    public static final VMStorage r7  = integerRegister(7);\n-    public static final VMStorage r8  = integerRegister(8);\n-    public static final VMStorage r9  = integerRegister(9);\n-    public static final VMStorage r10 = integerRegister(10);\n-    public static final VMStorage r11 = integerRegister(11);\n-    public static final VMStorage r12 = integerRegister(12);\n-    public static final VMStorage r13 = integerRegister(13);\n-    public static final VMStorage r14 = integerRegister(14);\n-    public static final VMStorage r15 = integerRegister(15);\n-    public static final VMStorage r16 = integerRegister(16);\n-    public static final VMStorage r17 = integerRegister(17);\n-    public static final VMStorage r18 = integerRegister(18);\n-    public static final VMStorage r19 = integerRegister(19);\n-    public static final VMStorage r20 = integerRegister(20);\n-    public static final VMStorage r21 = integerRegister(21);\n-    public static final VMStorage r22 = integerRegister(22);\n-    public static final VMStorage r23 = integerRegister(23);\n-    public static final VMStorage r24 = integerRegister(24);\n-    public static final VMStorage r25 = integerRegister(25);\n-    public static final VMStorage r26 = integerRegister(26);\n-    public static final VMStorage r27 = integerRegister(27);\n-    public static final VMStorage r28 = integerRegister(28);\n-    public static final VMStorage r29 = integerRegister(29);\n-    public static final VMStorage r30 = integerRegister(30);\n-    public static final VMStorage r31 = integerRegister(31);\n-\n-    public static final VMStorage v0  = vectorRegister(0);\n-    public static final VMStorage v1  = vectorRegister(1);\n-    public static final VMStorage v2  = vectorRegister(2);\n-    public static final VMStorage v3  = vectorRegister(3);\n-    public static final VMStorage v4  = vectorRegister(4);\n-    public static final VMStorage v5  = vectorRegister(5);\n-    public static final VMStorage v6  = vectorRegister(6);\n-    public static final VMStorage v7  = vectorRegister(7);\n-    public static final VMStorage v8  = vectorRegister(8);\n-    public static final VMStorage v9  = vectorRegister(9);\n-    public static final VMStorage v10 = vectorRegister(10);\n-    public static final VMStorage v11 = vectorRegister(11);\n-    public static final VMStorage v12 = vectorRegister(12);\n-    public static final VMStorage v13 = vectorRegister(13);\n-    public static final VMStorage v14 = vectorRegister(14);\n-    public static final VMStorage v15 = vectorRegister(15);\n-    public static final VMStorage v16 = vectorRegister(16);\n-    public static final VMStorage v17 = vectorRegister(17);\n-    public static final VMStorage v18 = vectorRegister(18);\n-    public static final VMStorage v19 = vectorRegister(19);\n-    public static final VMStorage v20 = vectorRegister(20);\n-    public static final VMStorage v21 = vectorRegister(21);\n-    public static final VMStorage v22 = vectorRegister(22);\n-    public static final VMStorage v23 = vectorRegister(23);\n-    public static final VMStorage v24 = vectorRegister(24);\n-    public static final VMStorage v25 = vectorRegister(25);\n-    public static final VMStorage v26 = vectorRegister(26);\n-    public static final VMStorage v27 = vectorRegister(27);\n-    public static final VMStorage v28 = vectorRegister(28);\n-    public static final VMStorage v29 = vectorRegister(29);\n-    public static final VMStorage v30 = vectorRegister(30);\n-    public static final VMStorage v31 = vectorRegister(31);\n-\n@@ -133,1 +133,1 @@\n-        return new VMStorage(StorageClasses.INTEGER, index, \"r\" + index);\n+        return new VMStorage(StorageType.INTEGER, REG64_MASK, index, \"r\" + index);\n@@ -137,1 +137,1 @@\n-        return new VMStorage(StorageClasses.VECTOR, index, \"v\" + index);\n+        return new VMStorage(StorageType.VECTOR, V128_MASK, index, \"v\" + index);\n@@ -140,2 +140,2 @@\n-    public static VMStorage stackStorage(int index) {\n-        return new VMStorage(StorageClasses.STACK, index, \"Stack@\" + index);\n+    public static VMStorage stackStorage(short size, int byteOffset) {\n+        return new VMStorage(StorageType.STACK, size, byteOffset);\n@@ -152,1 +152,1 @@\n-                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+                                       VMStorage scratch1, VMStorage scratch2) {\n@@ -169,1 +169,4 @@\n-            targetAddrStorage, retBufAddrStorage);\n+            scratch1, scratch2,\n+            StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER),\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n+            StubLocations.CAPTURED_STATE_BUFFER.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":87,"deletions":84,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2019, 2022, Arm Limited. All rights reserved.\n@@ -53,0 +53,1 @@\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n@@ -87,1 +88,1 @@\n-        new VMStorage[] { v16, v17, v18, v19, v20, v21, v22, v23, v25,\n+        new VMStorage[] { v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n@@ -91,2 +92,1 @@\n-        r9,  \/\/ target addr reg\n-        r10  \/\/ return buffer addr reg\n+        r9, r10  \/\/ scratch 1 & 2\n@@ -122,1 +122,1 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall);\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall, options);\n@@ -155,1 +155,1 @@\n-            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n+            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc, bindings.callingSequence);\n@@ -189,0 +189,4 @@\n+        void alignStack(long alignment) {\n+            stackOffset = Utils.alignUp(stackOffset, alignment);\n+        }\n+\n@@ -191,15 +195,4 @@\n-            \/\/ Implementation limit: each arg must take up at least an 8 byte stack slot (on the Java side)\n-            \/\/ There is currently no way to address stack offsets that are not multiples of 8 bytes\n-            \/\/ The VM can only address multiple-of-4-bytes offsets, which is also not good enough for some ABIs\n-            \/\/ see JDK-8283462 and related issues\n-            long stackSlotAlignment = Math.max(alignment, STACK_SLOT_SIZE);\n-            long alignedStackOffset = Utils.alignUp(stackOffset, stackSlotAlignment);\n-            \/\/ macos-aarch64 ABI potentially requires addressing stack offsets that are not multiples of 8 bytes\n-            \/\/ Reject such call types here, to prevent undefined behavior down the line\n-            \/\/ Reject if the above stack-slot-aligned offset does not match the offset the ABI really wants\n-            \/\/ Except for variadic arguments, which _are_ passed at 8-byte-aligned offsets\n-            if (requiresSubSlotStackPacking() && alignedStackOffset != Utils.alignUp(stackOffset, alignment)\n-                    && !forVarArgs) \/\/ varargs are given a pass on all aarch64 ABIs\n-                throw new UnsupportedOperationException(\"Call type not supported on this platform\");\n-\n-            stackOffset = alignedStackOffset;\n+            long alignedStackOffset = Utils.alignUp(stackOffset, alignment);\n+\n+            short encodedSize = (short) size;\n+            assert (encodedSize & 0xFFFF) == size;\n@@ -208,2 +201,2 @@\n-                stackStorage((int)(stackOffset \/ STACK_SLOT_SIZE));\n-            stackOffset += size;\n+                AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n+            stackOffset = alignedStackOffset + size;\n@@ -214,1 +207,4 @@\n-            return stackAlloc(layout.byteSize(), layout.byteAlignment());\n+            long stackSlotAlignment = requiresSubSlotStackPacking() && !forVarArgs\n+                    ? layout.byteAlignment()\n+                    : Math.max(layout.byteAlignment(), STACK_SLOT_SIZE);\n+            return stackAlloc(layout.byteSize(), stackSlotAlignment);\n@@ -247,0 +243,20 @@\n+        VMStorage[] nextStorageForHFA(GroupLayout group) {\n+            final int nFields = group.memberLayouts().size();\n+            VMStorage[] regs = regAlloc(StorageType.VECTOR, nFields);\n+            if (regs == null && requiresSubSlotStackPacking() && !forVarArgs) {\n+                \/\/ For the ABI variants that pack arguments spilled to the\n+                \/\/ stack, HFA arguments are spilled as if their individual\n+                \/\/ fields had been allocated separately rather than as if the\n+                \/\/ struct had been spilled as a whole.\n+\n+                VMStorage[] slots = new VMStorage[nFields];\n+                for (int i = 0; i < nFields; i++) {\n+                    slots[i] = stackAlloc(group.memberLayouts().get(i));\n+                }\n+\n+                return slots;\n+            } else {\n+                return regs;\n+            }\n+        }\n+\n@@ -250,2 +266,2 @@\n-            nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n-            nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n+            nRegs[StorageType.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+            nRegs[StorageType.VECTOR] = MAX_REGISTER_ARGUMENTS;\n@@ -282,0 +298,6 @@\n+\n+            if (requiresSubSlotStackPacking()) {\n+                \/\/ Pad to the next stack slot boundary instead of packing\n+                \/\/ additional arguments into the unused space.\n+                storageCalculator.alignStack(STACK_SLOT_SIZE);\n+            }\n@@ -301,0 +323,6 @@\n+\n+            if (requiresSubSlotStackPacking()) {\n+                \/\/ Pad to the next stack slot boundary instead of packing\n+                \/\/ additional arguments into the unused space.\n+                storageCalculator.alignStack(STACK_SLOT_SIZE);\n+            }\n@@ -329,1 +357,1 @@\n-                        StorageClasses.INTEGER, layout);\n+                        StorageType.INTEGER, layout);\n@@ -336,1 +364,1 @@\n-                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -355,1 +383,1 @@\n-                        StorageClasses.INTEGER, AArch64.C_POINTER);\n+                        StorageType.INTEGER, AArch64.C_POINTER);\n@@ -362,2 +390,1 @@\n-                    VMStorage[] regs = storageCalculator.regAlloc(\n-                        StorageClasses.VECTOR, group.memberLayouts().size());\n+                    VMStorage[] regs = storageCalculator.nextStorageForHFA(group);\n@@ -369,1 +396,1 @@\n-                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -386,1 +413,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                        storageCalculator.nextStorage(StorageType.INTEGER, layout);\n@@ -392,1 +419,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                        storageCalculator.nextStorage(StorageType.INTEGER, layout);\n@@ -398,1 +425,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                        storageCalculator.nextStorage(StorageType.VECTOR, layout);\n@@ -431,1 +458,1 @@\n-                            StorageClasses.INTEGER, layout);\n+                            StorageType.INTEGER, layout);\n@@ -439,1 +466,1 @@\n-                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -452,1 +479,1 @@\n-                            StorageClasses.INTEGER, AArch64.C_POINTER);\n+                            StorageType.INTEGER, AArch64.C_POINTER);\n@@ -460,2 +487,1 @@\n-                    VMStorage[] regs = storageCalculator.regAlloc(\n-                            StorageClasses.VECTOR, group.memberLayouts().size());\n+                    VMStorage[] regs = storageCalculator.nextStorageForHFA(group);\n@@ -467,1 +493,1 @@\n-                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -480,1 +506,1 @@\n-                            storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                            storageCalculator.nextStorage(StorageType.INTEGER, layout);\n@@ -486,1 +512,1 @@\n-                            storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                            storageCalculator.nextStorage(StorageType.INTEGER, layout);\n@@ -491,1 +517,1 @@\n-                            storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                            storageCalculator.nextStorage(StorageType.VECTOR, layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":70,"deletions":44,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.StubLocations;\n@@ -35,0 +36,11 @@\n+\n+    private static final short REG8_H_MASK = 0b0000_0000_0000_0010;\n+    private static final short REG8_L_MASK = 0b0000_0000_0000_0001;\n+    private static final short REG16_MASK = 0b0000_0000_0000_0011;\n+    private static final short REG32_MASK = 0b0000_0000_0000_0111;\n+    private static final short REG64_MASK = 0b0000_0000_0000_1111;\n+    private static final short XMM_MASK = 0b0000_0000_0000_0001;\n+    private static final short YMM_MASK = 0b0000_0000_0000_0011;\n+    private static final short ZMM_MASK = 0b0000_0000_0000_0111;\n+    private static final short STP_MASK = 0b0000_0000_0000_0001;\n+\n@@ -38,1 +50,0 @@\n-    private static final int STACK_SLOT_SIZE = 8;\n@@ -42,1 +53,1 @@\n-        return cls == StorageClasses.STACK;\n+        return cls == StorageType.STACK;\n@@ -48,4 +59,4 @@\n-            case StorageClasses.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageClasses.VECTOR: return VECTOR_REG_SIZE;\n-            case StorageClasses.X87: return X87_REG_SIZE;\n-            case StorageClasses.STACK: return STACK_SLOT_SIZE;\n+            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n+            case StorageType.VECTOR: return VECTOR_REG_SIZE;\n+            case StorageType.X87: return X87_REG_SIZE;\n+            \/\/ STACK is deliberately omitted\n@@ -57,3 +68,7 @@\n-    @Override\n-    public int stackType() {\n-        return StorageClasses.STACK;\n+    \/\/ must keep in sync with StorageType in VM code\n+    public interface StorageType {\n+        byte INTEGER = 0;\n+        byte VECTOR = 1;\n+        byte X87 = 2;\n+        byte STACK = 3;\n+        byte PLACEHOLDER = 4;\n@@ -62,5 +77,50 @@\n-    public interface StorageClasses {\n-        int INTEGER = 0;\n-        int VECTOR = 1;\n-        int X87 = 2;\n-        int STACK = 3;\n+    public static class Regs { \/\/ break circular dependency\n+        public static final VMStorage rax = integerRegister(0, \"rax\");\n+        public static final VMStorage rcx = integerRegister(1, \"rcx\");\n+        public static final VMStorage rdx = integerRegister(2, \"rdx\");\n+        public static final VMStorage rbx = integerRegister(3, \"rbx\");\n+        public static final VMStorage rsp = integerRegister(4, \"rsp\");\n+        public static final VMStorage rbp = integerRegister(5, \"rbp\");\n+        public static final VMStorage rsi = integerRegister(6, \"rsi\");\n+        public static final VMStorage rdi = integerRegister(7, \"rdi\");\n+        public static final VMStorage r8 = integerRegister(8, \"r8\");\n+        public static final VMStorage r9 = integerRegister(9, \"r9\");\n+        public static final VMStorage r10 = integerRegister(10, \"r10\");\n+        public static final VMStorage r11 = integerRegister(11, \"r11\");\n+        public static final VMStorage r12 = integerRegister(12, \"r12\");\n+        public static final VMStorage r13 = integerRegister(13, \"r13\");\n+        public static final VMStorage r14 = integerRegister(14, \"r14\");\n+        public static final VMStorage r15 = integerRegister(15, \"r15\");\n+\n+        public static final VMStorage xmm0 = vectorRegister(0, \"xmm0\");\n+        public static final VMStorage xmm1 = vectorRegister(1, \"xmm1\");\n+        public static final VMStorage xmm2 = vectorRegister(2, \"xmm2\");\n+        public static final VMStorage xmm3 = vectorRegister(3, \"xmm3\");\n+        public static final VMStorage xmm4 = vectorRegister(4, \"xmm4\");\n+        public static final VMStorage xmm5 = vectorRegister(5, \"xmm5\");\n+        public static final VMStorage xmm6 = vectorRegister(6, \"xmm6\");\n+        public static final VMStorage xmm7 = vectorRegister(7, \"xmm7\");\n+        public static final VMStorage xmm8 = vectorRegister(8, \"xmm8\");\n+        public static final VMStorage xmm9 = vectorRegister(9, \"xmm9\");\n+        public static final VMStorage xmm10 = vectorRegister(10, \"xmm10\");\n+        public static final VMStorage xmm11 = vectorRegister(11, \"xmm11\");\n+        public static final VMStorage xmm12 = vectorRegister(12, \"xmm12\");\n+        public static final VMStorage xmm13 = vectorRegister(13, \"xmm13\");\n+        public static final VMStorage xmm14 = vectorRegister(14, \"xmm14\");\n+        public static final VMStorage xmm15 = vectorRegister(15, \"xmm15\");\n+        public static final VMStorage xmm16 = vectorRegister(16, \"xmm16\");\n+        public static final VMStorage xmm17 = vectorRegister(17, \"xmm17\");\n+        public static final VMStorage xmm18 = vectorRegister(18, \"xmm18\");\n+        public static final VMStorage xmm19 = vectorRegister(19, \"xmm19\");\n+        public static final VMStorage xmm20 = vectorRegister(20, \"xmm20\");\n+        public static final VMStorage xmm21 = vectorRegister(21, \"xmm21\");\n+        public static final VMStorage xmm22 = vectorRegister(22, \"xmm22\");\n+        public static final VMStorage xmm23 = vectorRegister(23, \"xmm23\");\n+        public static final VMStorage xmm24 = vectorRegister(24, \"xmm24\");\n+        public static final VMStorage xmm25 = vectorRegister(25, \"xmm25\");\n+        public static final VMStorage xmm26 = vectorRegister(26, \"xmm26\");\n+        public static final VMStorage xmm27 = vectorRegister(27, \"xmm27\");\n+        public static final VMStorage xmm28 = vectorRegister(28, \"xmm28\");\n+        public static final VMStorage xmm29 = vectorRegister(29, \"xmm29\");\n+        public static final VMStorage xmm30 = vectorRegister(30, \"xmm30\");\n+        public static final VMStorage xmm31 = vectorRegister(31, \"xmm31\");\n@@ -69,50 +129,0 @@\n-    public static final VMStorage rax = integerRegister(0, \"rax\");\n-    public static final VMStorage rcx = integerRegister(1, \"rcx\");\n-    public static final VMStorage rdx = integerRegister(2, \"rdx\");\n-    public static final VMStorage rbx = integerRegister(3, \"rbx\");\n-    public static final VMStorage rsp = integerRegister(4, \"rsp\");\n-    public static final VMStorage rbp = integerRegister(5, \"rbp\");\n-    public static final VMStorage rsi = integerRegister(6, \"rsi\");\n-    public static final VMStorage rdi = integerRegister(7, \"rdi\");\n-    public static final VMStorage r8 =  integerRegister(8, \"r8\");\n-    public static final VMStorage r9 =  integerRegister(9, \"r9\");\n-    public static final VMStorage r10 = integerRegister(10, \"r10\");\n-    public static final VMStorage r11 = integerRegister(11, \"r11\");\n-    public static final VMStorage r12 = integerRegister(12, \"r12\");\n-    public static final VMStorage r13 = integerRegister(13, \"r13\");\n-    public static final VMStorage r14 = integerRegister(14, \"r14\");\n-    public static final VMStorage r15 = integerRegister(15, \"r15\");\n-\n-    public static final VMStorage xmm0 =  vectorRegister(0, \"xmm0\");\n-    public static final VMStorage xmm1 =  vectorRegister(1, \"xmm1\");\n-    public static final VMStorage xmm2 =  vectorRegister(2, \"xmm2\");\n-    public static final VMStorage xmm3 =  vectorRegister(3, \"xmm3\");\n-    public static final VMStorage xmm4 =  vectorRegister(4, \"xmm4\");\n-    public static final VMStorage xmm5 =  vectorRegister(5, \"xmm5\");\n-    public static final VMStorage xmm6 =  vectorRegister(6, \"xmm6\");\n-    public static final VMStorage xmm7 =  vectorRegister(7, \"xmm7\");\n-    public static final VMStorage xmm8 =  vectorRegister(8, \"xmm8\");\n-    public static final VMStorage xmm9 =  vectorRegister(9, \"xmm9\");\n-    public static final VMStorage xmm10 = vectorRegister(10, \"xmm10\");\n-    public static final VMStorage xmm11 = vectorRegister(11, \"xmm11\");\n-    public static final VMStorage xmm12 = vectorRegister(12, \"xmm12\");\n-    public static final VMStorage xmm13 = vectorRegister(13, \"xmm13\");\n-    public static final VMStorage xmm14 = vectorRegister(14, \"xmm14\");\n-    public static final VMStorage xmm15 = vectorRegister(15, \"xmm15\");\n-    public static final VMStorage xmm16 = vectorRegister(16, \"xmm16\");\n-    public static final VMStorage xmm17 = vectorRegister(17, \"xmm17\");\n-    public static final VMStorage xmm18 = vectorRegister(18, \"xmm18\");\n-    public static final VMStorage xmm19 = vectorRegister(19, \"xmm19\");\n-    public static final VMStorage xmm20 = vectorRegister(20, \"xmm20\");\n-    public static final VMStorage xmm21 = vectorRegister(21, \"xmm21\");\n-    public static final VMStorage xmm22 = vectorRegister(22, \"xmm22\");\n-    public static final VMStorage xmm23 = vectorRegister(23, \"xmm23\");\n-    public static final VMStorage xmm24 = vectorRegister(24, \"xmm24\");\n-    public static final VMStorage xmm25 = vectorRegister(25, \"xmm25\");\n-    public static final VMStorage xmm26 = vectorRegister(26, \"xmm26\");\n-    public static final VMStorage xmm27 = vectorRegister(27, \"xmm27\");\n-    public static final VMStorage xmm28 = vectorRegister(28, \"xmm28\");\n-    public static final VMStorage xmm29 = vectorRegister(29, \"xmm29\");\n-    public static final VMStorage xmm30 = vectorRegister(30, \"xmm30\");\n-    public static final VMStorage xmm31 = vectorRegister(31, \"xmm31\");\n-\n@@ -120,1 +130,1 @@\n-        return new VMStorage(StorageClasses.INTEGER, index, debugName);\n+        return new VMStorage(StorageType.INTEGER, REG64_MASK, index, debugName);\n@@ -124,1 +134,1 @@\n-        return new VMStorage(StorageClasses.VECTOR, index, debugName);\n+        return new VMStorage(StorageType.VECTOR, XMM_MASK, index, debugName);\n@@ -127,2 +137,2 @@\n-    public static VMStorage stackStorage(int index) {\n-        return new VMStorage(StorageClasses.STACK, index, \"Stack@\" + index);\n+    public static VMStorage stackStorage(short size, int byteOffset) {\n+        return new VMStorage(StorageType.STACK, size, byteOffset);\n@@ -132,1 +142,1 @@\n-        return new VMStorage(StorageClasses.X87, index, \"X87(\" + index + \")\");\n+        return new VMStorage(StorageType.X87, STP_MASK, index, \"X87(\" + index + \")\");\n@@ -138,1 +148,1 @@\n-                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+                                       VMStorage scratch1, VMStorage scratch2) {\n@@ -156,1 +166,4 @@\n-            targetAddrStorage, retBufAddrStorage);\n+            scratch1, scratch2,\n+            StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER),\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n+            StubLocations.CAPTURED_STATE_BUFFER.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":84,"deletions":71,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -37,0 +38,1 @@\n+import jdk.internal.foreign.abi.x64.X86_64Architecture;\n@@ -52,0 +54,1 @@\n+import static jdk.internal.foreign.abi.x64.X86_64Architecture.Regs.*;\n@@ -60,3 +63,5 @@\n-    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 6;\n-    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;\n-    private static final ABIDescriptor CSysV = abiFor(\n+    private static final int STACK_SLOT_SIZE = 8;\n+    private static final int MAX_INTEGER_ARGUMENT_REGISTERS = 6;\n+    private static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;\n+\n+    private static final ABIDescriptor CSysV = X86_64Architecture.abiFor(\n@@ -72,2 +77,1 @@\n-        r10, \/\/ target addr reg\n-        r11  \/\/ ret buf addr reg\n+        r10, r11 \/\/ scratch 1 & 2\n@@ -83,1 +87,5 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(CSysV, forUpcall);\n+        return getBindings(mt, cDesc, forUpcall, LinkerOptions.empty());\n+    }\n+\n+    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, LinkerOptions options) {\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(CSysV, forUpcall, options);\n@@ -114,2 +122,2 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, false, options);\n@@ -121,1 +129,1 @@\n-            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n+            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc, bindings.callingSequence);\n@@ -156,1 +164,1 @@\n-            return type == StorageClasses.INTEGER ?\n+            return type == StorageType.INTEGER ?\n@@ -163,2 +171,2 @@\n-            VMStorage storage = stackStorage((int)stackOffset);\n-            stackOffset++;\n+            VMStorage storage = X86_64Architecture.stackStorage((short) STACK_SLOT_SIZE, (int)stackOffset);\n+            stackOffset += STACK_SLOT_SIZE;\n@@ -202,1 +210,1 @@\n-                storage[i] = nextStorage(sse ? StorageClasses.VECTOR : StorageClasses.INTEGER);\n+                storage[i] = nextStorage(sse ? StorageType.VECTOR : StorageType.INTEGER);\n@@ -209,2 +217,2 @@\n-                case StorageClasses.INTEGER -> nIntegerReg;\n-                case StorageClasses.VECTOR -> nVectorReg;\n+                case StorageType.INTEGER -> nIntegerReg;\n+                case StorageType.VECTOR -> nVectorReg;\n@@ -217,2 +225,2 @@\n-                case StorageClasses.INTEGER -> nIntegerReg++;\n-                case StorageClasses.VECTOR -> nVectorReg++;\n+                case StorageType.INTEGER -> nIntegerReg++;\n+                case StorageType.VECTOR -> nVectorReg++;\n@@ -256,1 +264,1 @@\n-                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -265,1 +273,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -269,1 +277,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -273,1 +281,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n@@ -303,1 +311,1 @@\n-                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -311,1 +319,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -316,1 +324,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -320,1 +328,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":33,"deletions":25,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        return CallArranger.arrangeDowncall(inferredMethodType, function);\n+        return CallArranger.arrangeDowncall(inferredMethodType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static jdk.internal.foreign.abi.x64.X86_64Architecture.Regs.*;\n@@ -72,2 +73,1 @@\n-        r10, \/\/ target addr reg\n-        r11  \/\/ ret buf addr reg\n+        r10, r11 \/\/ scratch 1 & 2\n@@ -87,1 +87,1 @@\n-            final CallingSequenceBuilder csb = new CallingSequenceBuilder(CWindows, forUpcall);\n+            final CallingSequenceBuilder csb = new CallingSequenceBuilder(CWindows, forUpcall, options);\n@@ -128,1 +128,1 @@\n-            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n+            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc, bindings.callingSequence);\n@@ -167,1 +167,1 @@\n-                VMStorage storage = X86_64Architecture.stackStorage((int) (stackOffset \/ STACK_SLOT_SIZE));\n+                VMStorage storage = X86_64Architecture.stackStorage((short) STACK_SLOT_SIZE, (int) stackOffset);\n@@ -179,1 +179,1 @@\n-            return CWindows.inputStorage[StorageClasses.INTEGER][nRegs - 1];\n+            return CWindows.inputStorage[StorageType.INTEGER][nRegs - 1];\n@@ -201,1 +201,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -211,1 +211,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -217,1 +217,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -222,1 +222,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -227,1 +227,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n@@ -232,1 +232,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n@@ -265,1 +265,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -273,1 +273,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -279,1 +279,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -285,1 +285,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -290,1 +290,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -484,2 +484,2 @@\n-java\/foreign\/TestUpcallStack.java 8275584 macosx-aarch64\n-java\/foreign\/TestDowncallStack.java 8275584 macosx-aarch64\n+java\/foreign\/callarranger\/TestAarch64CallArranger.java generic-x86\n+java\/foreign\/TestLargeSegmentCopy.java generic-x86\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class MemoryLayoutPrincipalTotalityTest extends NativeTestHelper {\n+public class MemoryLayoutPrincipalTotalityTest {\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public class MemoryLayoutTypeRetentionTest extends NativeTestHelper {\n+public class MemoryLayoutTypeRetentionTest {\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires sun.arch.data.model == \"64\"\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n@@ -30,0 +31,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -50,0 +52,23 @@\n+    @DataProvider\n+    public static Object[][] invalidIndexCases() {\n+        return new Object[][]{\n+                { -1, },\n+                { 42, },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invalidIndexCases\",\n+          expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*not in bounds for descriptor.*\")\n+    public void testInvalidOption(int invalidIndex) {\n+        Linker.Option option = Linker.Option.firstVariadicArg(invalidIndex);\n+        FunctionDescriptor desc = FunctionDescriptor.ofVoid();\n+        Linker.nativeLinker().downcallHandle(desc, option); \/\/ throws\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Unknown name.*\")\n+    public void testInvalidPreservedValueName() {\n+        Linker.Option.captureCallState(\"foo\"); \/\/ throws\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-        assertEquals(callingSequence.argumentBindingsCount(), argumentBindings.length);\n+        assertEquals(callingSequence.argumentBindingsCount(), argumentBindings.length,\n+          callingSequence.asString() + \" != \" + Arrays.deepToString(argumentBindings));\n@@ -40,1 +41,1 @@\n-            assertEquals(actual, Arrays.asList(expected));\n+            assertEquals(actual, Arrays.asList(expected), \"bindings at: \" + i + \": \" + actual + \" != \" + Arrays.toString(expected));\n@@ -45,1 +46,1 @@\n-        assertEquals(callingSequence.returnBindings(), Arrays.asList(returnBindings));\n+        assertEquals(callingSequence.returnBindings(), Arrays.asList(returnBindings), callingSequence.returnBindings() + \" != \" + Arrays.toString(returnBindings));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/CallArrangerTestBase.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires sun.arch.data.model == \"64\"\n@@ -37,0 +38,1 @@\n+import java.lang.foreign.StructLayout;\n@@ -41,0 +43,2 @@\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n@@ -52,0 +56,1 @@\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n@@ -59,0 +64,3 @@\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n+\n@@ -71,1 +79,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) }\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n@@ -95,1 +103,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -104,2 +112,2 @@\n-            { vmStore(stackStorage(0), int.class) },\n-            { vmStore(stackStorage(1), int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 8), int.class) },\n@@ -125,1 +133,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -147,1 +155,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -207,1 +215,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -238,1 +246,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -262,2 +270,2 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n-            { unboxAddress(), vmStore(r9, long.class) }\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n@@ -291,2 +299,2 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -329,1 +337,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -353,1 +361,1 @@\n-                vmStore(stackStorage(0), long.class),\n+                vmStore(stackStorage((short) 8, 0), long.class),\n@@ -355,1 +363,1 @@\n-                vmStore(stackStorage(1), int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n@@ -383,1 +391,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -392,2 +400,2 @@\n-            { copy(struct), unboxAddress(), vmStore(stackStorage(0), long.class) },\n-            { vmStore(stackStorage(1), int.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage((short) 8, 0), long.class) },\n+            { vmStore(stackStorage((short) 4, 8), int.class) },\n@@ -404,1 +412,1 @@\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(1)));\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n@@ -413,1 +421,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -427,1 +435,1 @@\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(1)));\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n@@ -436,1 +444,28 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 8), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, short.class, byte.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_SHORT, C_CHAR);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -438,2 +473,172 @@\n-            { vmStore(stackStorage(0), int.class) },\n-            { vmStore(stackStorage(1), float.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 4), int.class) },\n+            { cast(short.class, int.class), vmStore(stackStorage((short) 2, 8), int.class) },\n+            { cast(byte.class, int.class), vmStore(stackStorage((short) 1, 10), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack2() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_FLOAT,\n+            C_FLOAT\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_INT, struct);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, int.class),\n+                vmStore(stackStorage((short) 4, 4), int.class),\n+                bufferLoad(4, int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack3() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                MemorySegment.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                struct, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { dup(),\n+                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 0), long.class),\n+                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 8), long.class) },\n+            { vmStore(stackStorage((short) 4, 16), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack4() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_INT,\n+            C_INT,\n+            C_POINTER\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                float.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_FLOAT, struct);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { dup(),\n+                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 8), long.class),\n+                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 16), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":229,"deletions":24,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n@@ -51,0 +53,1 @@\n+import static jdk.internal.foreign.abi.x64.X86_64Architecture.Regs.*;\n@@ -58,0 +61,4 @@\n+    private static final short STACK_SLOT_SIZE = 8;\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n+\n@@ -70,1 +77,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -98,1 +105,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -129,1 +136,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -159,3 +166,3 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n-            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n-                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class)},\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n+                    bufferLoad(8, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class)},\n@@ -189,3 +196,3 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n-            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n-                    bufferLoad(8, int.class), vmStore(stackStorage(1), int.class)},\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n+                    bufferLoad(8, int.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class)},\n@@ -214,1 +221,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -245,1 +252,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -280,1 +287,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -287,2 +294,2 @@\n-            { vmStore(stackStorage(0), long.class) },\n-            { vmStore(stackStorage(1), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class) },\n@@ -297,2 +304,2 @@\n-            { vmStore(stackStorage(2), float.class) },\n-            { vmStore(stackStorage(3), float.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), float.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 24), float.class) },\n@@ -337,1 +344,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -350,2 +357,2 @@\n-            { vmStore(stackStorage(0), int.class) },\n-            { vmStore(stackStorage(1), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class) },\n@@ -380,1 +387,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -402,1 +409,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -428,1 +435,1 @@\n-                    bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                    bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n@@ -430,2 +437,2 @@\n-                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class),\n-                    bufferLoad(16, long.class), vmStore(stackStorage(2), long.class)\n+                    bufferLoad(8, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class),\n+                    bufferLoad(16, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 16), long.class)\n@@ -436,1 +443,1 @@\n-                    bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                    bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n@@ -438,1 +445,1 @@\n-                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class),\n+                    bufferLoad(8, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class),\n@@ -440,2 +447,2 @@\n-                    bufferLoad(16, long.class), vmStore(stackStorage(2), long.class),\n-                    bufferLoad(24, long.class), vmStore(stackStorage(3), long.class)\n+                    bufferLoad(16, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 16), long.class),\n+                    bufferLoad(24, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 24), long.class)\n@@ -461,2 +468,2 @@\n-            { unboxAddress(), vmStore(r11, long.class) },\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -493,1 +500,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":38,"deletions":31,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n@@ -53,0 +55,1 @@\n+import static jdk.internal.foreign.abi.x64.X86_64Architecture.Regs.*;\n@@ -58,0 +61,3 @@\n+    private static final short STACK_SLOT_SIZE = 8;\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+\n@@ -70,1 +76,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) }\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n@@ -87,1 +93,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -109,1 +115,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -133,1 +139,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -138,4 +144,4 @@\n-            { vmStore(stackStorage(0), long.class) },\n-            { vmStore(stackStorage(1), long.class) },\n-            { vmStore(stackStorage(2), float.class) },\n-            { vmStore(stackStorage(3), float.class) }\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), float.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 24), float.class) }\n@@ -164,1 +170,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -173,7 +179,7 @@\n-            { vmStore(stackStorage(0), int.class) },\n-            { vmStore(stackStorage(1), double.class) },\n-            { vmStore(stackStorage(2), double.class) },\n-            { vmStore(stackStorage(3), double.class) },\n-            { vmStore(stackStorage(4), int.class) },\n-            { vmStore(stackStorage(5), int.class) },\n-            { vmStore(stackStorage(6), int.class) }\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 24), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 32), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 40), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 48), int.class) }\n@@ -193,1 +199,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(2)));\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(2)));\n@@ -201,1 +207,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -206,1 +212,1 @@\n-            { vmStore(stackStorage(0), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), double.class) },\n@@ -235,1 +241,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -265,1 +271,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -296,1 +302,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -317,1 +323,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -341,1 +347,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -370,1 +376,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -375,12 +381,12 @@\n-            { copy(struct), unboxAddress(), vmStore(stackStorage(0), long.class) },\n-            { vmStore(stackStorage(1), int.class) },\n-            { vmStore(stackStorage(2), double.class) },\n-            { unboxAddress(), vmStore(stackStorage(3), long.class) },\n-            { copy(struct), unboxAddress(), vmStore(stackStorage(4), long.class) },\n-            { vmStore(stackStorage(5), int.class) },\n-            { vmStore(stackStorage(6), double.class) },\n-            { unboxAddress(), vmStore(stackStorage(7), long.class) },\n-            { copy(struct), unboxAddress(), vmStore(stackStorage(8), long.class) },\n-            { vmStore(stackStorage(9), int.class) },\n-            { vmStore(stackStorage(10), double.class) },\n-            { unboxAddress(), vmStore(stackStorage(11), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 24), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 32), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 40), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 48), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 56), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 64), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 72), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 80), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 88), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCaptureCallState\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestCaptureCallState extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"CaptureCallState\");\n+        if (IS_WINDOWS) {\n+            String system32 = System.getenv(\"SystemRoot\") + \"\\\\system32\";\n+            System.load(system32 + \"\\\\Kernel32.dll\");\n+            System.load(system32 + \"\\\\Ws2_32.dll\");\n+        }\n+    }\n+\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testSavedThreadLocal(SaveValuesCase testCase) throws Throwable {\n+        Linker.Option.CaptureCallState stl = Linker.Option.captureCallState(testCase.threadLocalName());\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n+\n+        VarHandle errnoHandle = stl.layout().varHandle(groupElement(testCase.threadLocalName()));\n+\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment saveSeg = arena.allocate(stl.layout());\n+            int testValue = 42;\n+            boolean needsAllocator = testCase.nativeDesc().returnLayout().map(StructLayout.class::isInstance).orElse(false);\n+            Object result = needsAllocator\n+                ? handle.invoke(arena, saveSeg, testValue)\n+                : handle.invoke(saveSeg, testValue);\n+            testCase.resultCheck().accept(result);\n+            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            assertEquals(savedErrno, testValue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        List<SaveValuesCase> cases = new ArrayList<>();\n+\n+        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n+        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n+        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n+\n+        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n+        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                           JAVA_LONG.withName(\"y\"), 42L)));\n+        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                            JAVA_LONG.withName(\"y\"), 42L,\n+                                            JAVA_LONG.withName(\"z\"), 42L)));\n+        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n+        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n+        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n+\n+        if (IS_WINDOWS) {\n+            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n+            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n+        }\n+\n+        return cases.stream().map(tc -> new Object[] {tc}).toArray(Object[][]::new);\n+    }\n+\n+    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n+        StructLayout layout = MemoryLayout.structLayout(fields.keySet().toArray(MemoryLayout[]::new));\n+\n+        Consumer<Object> check = o -> {};\n+        for (var field : fields.entrySet()) {\n+            MemoryLayout fieldLayout = field.getKey();\n+            VarHandle fieldHandle = layout.varHandle(MemoryLayout.PathElement.groupElement(fieldLayout.name().get()));\n+            Object value = field.getValue();\n+            check = check.andThen(o -> assertEquals(fieldHandle.get(o), value));\n+        }\n+\n+        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void set_errno_V(int value) {\n+    errno = value;\n+}\n+\n+EXPORT int set_errno_I(int value) {\n+    errno = value;\n+    return 42;\n+}\n+\n+EXPORT double set_errno_D(int value) {\n+    errno = value;\n+    return 42.0;\n+}\n+\n+struct SL {\n+    long long x;\n+};\n+\n+EXPORT struct SL set_errno_SL(int value) {\n+    errno = value;\n+    struct SL s;\n+    s.x = 42;\n+    return s;\n+}\n+\n+struct SLL {\n+    long long x;\n+    long long y;\n+};\n+\n+EXPORT struct SLL set_errno_SLL(int value) {\n+    errno = value;\n+    struct SLL s;\n+    s.x = 42;\n+    s.y = 42;\n+    return s;\n+}\n+\n+struct SLLL {\n+    long long x;\n+    long long y;\n+    long long z;\n+};\n+\n+EXPORT struct SLLL set_errno_SLLL(int value) {\n+    errno = value;\n+    struct SLLL s;\n+    s.x = 42;\n+    s.y = 42;\n+    s.z = 42;\n+    return s;\n+}\n+\n+struct SD {\n+    double x;\n+};\n+\n+EXPORT struct SD set_errno_SD(int value) {\n+    errno = value;\n+    struct SD s;\n+    s.x = 42.0;\n+    return s;\n+}\n+\n+struct SDD {\n+    double x;\n+    double y;\n+};\n+\n+EXPORT struct SDD set_errno_SDD(int value) {\n+    errno = value;\n+    struct SDD s;\n+    s.x = 42.0;\n+    s.y = 42.0;\n+    return s;\n+}\n+\n+struct SDDD {\n+    double x;\n+    double y;\n+    double z;\n+};\n+\n+EXPORT struct SDDD set_errno_SDDD(int value) {\n+    errno = value;\n+    struct SDDD s;\n+    s.x = 42.0;\n+    s.y = 42.0;\n+    s.z = 42.0;\n+    return s;\n+}\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/libCaptureCallState.c","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}