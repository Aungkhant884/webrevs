{"files":[{"patch":"@@ -146,1 +146,1 @@\n-  VMStorage shuffle_reg = VMS_R19;\n+  VMStorage shuffle_reg = as_VMStorage(r19);\n@@ -225,1 +225,1 @@\n-      } else if(reg.type() == StorageType::VECTOR) {\n+      } else if (reg.type() == StorageType::VECTOR) {\n@@ -239,1 +239,1 @@\n-    if(should_save_return_value) {\n+    if (should_save_return_value) {\n@@ -247,1 +247,1 @@\n-    if(should_save_return_value) {\n+    if (should_save_return_value) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-  parse_register_array(inputStorage, (int) StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n-  parse_register_array(inputStorage, (int) StorageType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n+  parse_register_array(inputStorage, StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, StorageType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n@@ -55,2 +55,2 @@\n-  parse_register_array(outputStorage, (int) StorageType::INTEGER, abi._integer_return_registers, as_Register);\n-  parse_register_array(outputStorage, (int) StorageType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n+  parse_register_array(outputStorage, StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, StorageType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n@@ -59,2 +59,2 @@\n-  parse_register_array(volatileStorage, (int) StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n-  parse_register_array(volatileStorage, (int) StorageType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n+  parse_register_array(volatileStorage, StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, StorageType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -74,1 +74,1 @@\n-  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n+  constexpr const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -178,3 +178,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -195,1 +195,1 @@\n-  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n+  constexpr const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-        j_expected_result_reg = VMS_R0;\n+        j_expected_result_reg = as_VMStorage(r0);\n@@ -259,1 +259,1 @@\n-          j_expected_result_reg = VMS_V0;\n+          j_expected_result_reg = as_VMStorage(v0);\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/vmstorageBase.inline.hpp\"\n@@ -54,4 +53,0 @@\n-constexpr VMStorage VMS_R0 = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 0);\n-constexpr VMStorage VMS_R19 = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 19);\n-constexpr VMStorage VMS_V0 = VMStorage::reg_storage(StorageType::VECTOR, V128_MASK, 0);\n-\n@@ -68,1 +63,1 @@\n-inline VMStorage as_VMStorage(Register reg) {\n+constexpr inline VMStorage as_VMStorage(Register reg) {\n@@ -72,1 +67,1 @@\n-inline VMStorage as_VMStorage(FloatRegister reg) {\n+constexpr inline VMStorage as_VMStorage(FloatRegister reg) {\n","filename":"src\/hotspot\/cpu\/aarch64\/vmstorage_aarch64.inline.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  VMStorage shuffle_reg = VMS_RBX;\n+  VMStorage shuffle_reg = as_VMStorage(rbx);\n@@ -239,1 +239,1 @@\n-    if(should_save_return_value) {\n+    if (should_save_return_value) {\n@@ -252,1 +252,1 @@\n-    if(should_save_return_value) {\n+    if (should_save_return_value) {\n@@ -304,1 +304,1 @@\n-  if(should_save_return_value) {\n+  if (should_save_return_value) {\n@@ -316,1 +316,1 @@\n-  if(should_save_return_value) {\n+  if (should_save_return_value) {\n@@ -329,1 +329,1 @@\n-  if(should_save_return_value) {\n+  if (should_save_return_value) {\n@@ -340,1 +340,1 @@\n-  if(should_save_return_value) {\n+  if (should_save_return_value) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-  parse_register_array(inputStorage, (int) StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n-  parse_register_array(inputStorage, (int) StorageType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n+  parse_register_array(inputStorage, StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, StorageType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n@@ -52,3 +52,3 @@\n-  parse_register_array(outputStorage, (int) StorageType::INTEGER, abi._integer_return_registers, as_Register);\n-  parse_register_array(outputStorage, (int) StorageType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n-  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at(((int) StorageType::X87)));\n+  parse_register_array(outputStorage, StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, StorageType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n+  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at((int) StorageType::X87));\n@@ -58,2 +58,2 @@\n-  parse_register_array(volatileStorage, (int) StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n-  parse_register_array(volatileStorage, (int) StorageType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n+  parse_register_array(volatileStorage, StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, StorageType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-    int   raw_encoding() const      { return this - first(); }\n-    int   encoding() const          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool  is_valid() const          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int   raw_encoding() const { return this - first(); }\n+    constexpr int       encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool      is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -77,1 +77,1 @@\n-  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n+  constexpr const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -205,3 +205,3 @@\n-    int raw_encoding() const  { return this - first(); }\n-    int   encoding() const    { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool  is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -222,1 +222,1 @@\n-  const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n+  constexpr const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  VMStorage shuffle_reg = VMS_RBX;\n+  VMStorage shuffle_reg = as_VMStorage(rbx);\n@@ -309,1 +309,1 @@\n-        j_expected_result_reg = VMS_RAX;\n+        j_expected_result_reg = as_VMStorage(rax);\n@@ -313,1 +313,1 @@\n-          j_expected_result_reg = VMS_XMM0;\n+          j_expected_result_reg = as_VMStorage(xmm0);\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"prims\/vmstorageBase.inline.hpp\"\n@@ -56,4 +55,0 @@\n-constexpr VMStorage VMS_RAX = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 0);\n-constexpr VMStorage VMS_RBX = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 3);\n-constexpr VMStorage VMS_XMM0 = VMStorage::reg_storage(StorageType::VECTOR, XMM_MASK, 0);\n-\n@@ -82,1 +77,1 @@\n-inline VMStorage as_VMStorage(Register reg) {\n+constexpr inline VMStorage as_VMStorage(Register reg) {\n@@ -86,1 +81,1 @@\n-inline VMStorage as_VMStorage(XMMRegister reg) {\n+constexpr inline VMStorage as_VMStorage(XMMRegister reg) {\n","filename":"src\/hotspot\/cpu\/x86\/vmstorage_x86.inline.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  static void parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, T (*converter)(int));\n+  static void parse_register_array(objArrayOop jarray, StorageType type_index, GrowableArray<T>& array, T (*converter)(int));\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-void ForeignGlobals::parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, T (*converter)(int)) {\n-  objArrayOop subarray = oop_cast<objArrayOop>(jarray->obj_at(type_index));\n+void ForeignGlobals::parse_register_array(objArrayOop jarray, StorageType type_index, GrowableArray<T>& array, T (*converter)(int)) {\n+  objArrayOop subarray = oop_cast<objArrayOop>(jarray->obj_at((int) type_index));\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,70 @@\n-#include \"utilities\/macros.hpp\"\n+#include <cstdint>\n+\n+#include \"code\/vmreg.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+enum class StorageType : int8_t; \/\/ defined in arch specific headers\n+\n+class VMStorage {\n+public:\n+  constexpr static StorageType INVALID_TYPE = static_cast<StorageType>(-1);\n+private:\n+  StorageType _type;\n+  \/\/ 1 byte of padding\n+  uint16_t _segment_mask_or_size;\n+  uint32_t _index_or_offset; \/\/ stack offset in bytes for stack storage\n+\n+  friend bool operator==(const VMStorage& a, const VMStorage& b);\n+\n+  constexpr inline static bool is_reg(StorageType type);\n+  constexpr inline static StorageType stack_type();\n+  constexpr inline static StorageType placeholder_type();\n+  constexpr inline static StorageType frame_data_type();\n+public:\n+  constexpr VMStorage() : _type(INVALID_TYPE), _segment_mask_or_size(0), _index_or_offset(0) {};\n+  constexpr VMStorage(StorageType type, uint16_t segment_mask_or_size, uint32_t index_or_offset)\n+    : _type(type), _segment_mask_or_size(segment_mask_or_size), _index_or_offset(index_or_offset) {};\n+\n+  constexpr static VMStorage reg_storage(StorageType type, uint16_t segment_mask, uint32_t index) {\n+    assert(is_reg(type), \"must be reg\");\n+    return VMStorage(type, segment_mask, index);\n+  }\n+\n+  constexpr static VMStorage stack_storage(uint16_t size, uint32_t offset) {\n+    return VMStorage(stack_type(), size, offset);\n+  }\n+\n+  static VMStorage stack_storage(VMReg reg) {\n+    return stack_storage(BytesPerWord, checked_cast<uint16_t>(reg->reg2stack() * VMRegImpl::stack_slot_size));\n+  }\n+\n+  constexpr static VMStorage invalid() {\n+    VMStorage result;\n+    result._type = INVALID_TYPE;\n+    return result;\n+  }\n+\n+  StorageType type() const { return _type; }\n+\n+  \/\/ type specific accessors to make calling code more readable\n+  uint16_t segment_mask()    const { assert(is_reg(), \"must be reg\");                  return _segment_mask_or_size; }\n+  uint16_t stack_size()      const { assert(is_stack() || is_frame_data(), \"must be\"); return _segment_mask_or_size; }\n+  uint32_t index()           const { assert(is_reg() || is_placeholder(), \"must be\");  return _index_or_offset; }\n+  uint32_t offset()          const { assert(is_stack() || is_frame_data(), \"must be\"); return _index_or_offset; }\n+  uint32_t index_or_offset() const { assert(is_valid(), \"must be valid\");              return _index_or_offset; }\n+\n+  bool is_valid()       const { return _type != INVALID_TYPE; }\n+  bool is_reg()         const { return is_reg(_type); }\n+  bool is_stack()       const { return _type == stack_type(); }\n+  bool is_placeholder() const { return _type == placeholder_type(); }\n+  bool is_frame_data()  const { return _type == frame_data_type(); }\n+\n+  void print_on(outputStream* os) const;\n+};\n+\n+inline bool operator==(const VMStorage& a, const VMStorage& b) {\n+  return a._type == b._type\n+    && a._index_or_offset == b._index_or_offset\n+    && a._segment_mask_or_size == b._segment_mask_or_size;\n+}\n@@ -31,1 +100,1 @@\n-#endif \/\/ SHARE_PRIMS_VMSTORAGE_INLINE_HPP\n\\ No newline at end of file\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_INLINE_HPP\n","filename":"src\/hotspot\/share\/prims\/vmstorage.inline.hpp","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_PRIMS_VMSTORAGEBASE_INLINE_HPP\n-#define SHARE_PRIMS_VMSTORAGEBASE_INLINE_HPP\n-\n-\/\/ DO NOT INCLUDE THIS FILE. INCLUDE vmstorage.inline.hpp INSTEAD\n-\n-#include <cstdint>\n-\n-#include \"code\/vmreg.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-enum class StorageType : int8_t; \/\/ defined in arch specific headers\n-\n-class VMStorage {\n-public:\n-  constexpr static StorageType INVALID_TYPE = static_cast<StorageType>(-1);\n-private:\n-  StorageType _type;\n-  \/\/ 1 byte of padding\n-  uint16_t _segment_mask_or_size;\n-  uint32_t _index_or_offset; \/\/ stack offset in bytes for stack storage\n-\n-  friend bool operator==(const VMStorage& a, const VMStorage& b);\n-\n-  constexpr inline static bool is_reg(StorageType type);\n-  constexpr inline static StorageType stack_type();\n-  constexpr inline static StorageType placeholder_type();\n-  constexpr inline static StorageType frame_data_type();\n-public:\n-  constexpr VMStorage() : _type(INVALID_TYPE), _segment_mask_or_size(0), _index_or_offset(0) {};\n-  constexpr VMStorage(StorageType type, uint16_t segment_mask_or_size, uint32_t index_or_offset)\n-    : _type(type), _segment_mask_or_size(segment_mask_or_size), _index_or_offset(index_or_offset) {};\n-\n-  constexpr static VMStorage reg_storage(StorageType type, uint16_t segment_mask, uint32_t index) {\n-    assert(is_reg(type), \"must be reg\");\n-    return VMStorage(type, segment_mask, index);\n-  }\n-\n-  constexpr static VMStorage stack_storage(uint16_t size, uint32_t offset) {\n-    return VMStorage(stack_type(), size, offset);\n-  }\n-\n-  static VMStorage stack_storage(VMReg reg) {\n-    return stack_storage(BytesPerWord, checked_cast<uint16_t>(reg->reg2stack() * VMRegImpl::stack_slot_size));\n-  }\n-\n-  constexpr static VMStorage invalid() {\n-    VMStorage result;\n-    result._type = INVALID_TYPE;\n-    return result;\n-  }\n-\n-  StorageType type() const { return _type; }\n-\n-  \/\/ type specific accessors to make calling code more readable\n-  uint16_t segment_mask()    const { assert(is_reg(), \"must be reg\");                  return _segment_mask_or_size; }\n-  uint16_t stack_size()      const { assert(is_stack() || is_frame_data(), \"must be\"); return _segment_mask_or_size; }\n-  uint32_t index()           const { assert(is_reg() || is_placeholder(), \"must be\");  return _index_or_offset; }\n-  uint32_t offset()          const { assert(is_stack() || is_frame_data(), \"must be\"); return _index_or_offset; }\n-  uint32_t index_or_offset() const { assert(is_valid(), \"must be valid\");              return _index_or_offset; }\n-\n-  bool is_valid()       const { return _type != INVALID_TYPE; }\n-  bool is_reg()         const { return is_reg(_type); }\n-  bool is_stack()       const { return _type == stack_type(); }\n-  bool is_placeholder() const { return _type == placeholder_type(); }\n-  bool is_frame_data()  const { return _type == frame_data_type(); }\n-\n-  void print_on(outputStream* os) const;\n-};\n-\n-inline bool operator==(const VMStorage& a, const VMStorage& b) {\n-  return a._type == b._type\n-    && a._index_or_offset == b._index_or_offset\n-    && a._segment_mask_or_size == b._segment_mask_or_size;\n-}\n-\n-#endif \/\/ SHARE_PRIMS_VMSTORAGEBASE_INLINE_HPP\n","filename":"src\/hotspot\/share\/prims\/vmstorageBase.inline.hpp","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"}]}