{"files":[{"patch":"@@ -460,4 +460,1 @@\n-  StackOverflow::set_stack_red_zone_size     (align_up(StackRedPages      * 4 * K, vm_page_size()));\n-  StackOverflow::set_stack_yellow_zone_size  (align_up(StackYellowPages   * 4 * K, vm_page_size()));\n-  StackOverflow::set_stack_reserved_zone_size(align_up(StackReservedPages * 4 * K, vm_page_size()));\n-  StackOverflow::set_stack_shadow_zone_size  (align_up(StackShadowPages   * 4 * K, vm_page_size()));\n+  StackOverflow::initialize_stack_zone_sizes(4 * K);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,26 @@\n+void StackOverflow::initialize_stack_zone_sizes(size_t alignment) {\n+  \/\/ Stack zone sizes must be page aligned.\n+  size_t page_size = os::vm_page_size();\n+\n+  assert(_stack_red_zone_size == 0, \"This should be called only once.\");\n+  _stack_red_zone_size = align_up(StackRedPages * alignment, page_size);\n+\n+  assert(_stack_yellow_zone_size == 0, \"This should be called only once.\");\n+  _stack_yellow_zone_size = align_up(StackYellowPages * alignment, page_size);\n+\n+  assert(_stack_reserved_zone_size == 0, \"This should be called only once.\");\n+  _stack_reserved_zone_size = align_up(StackReservedPages * alignment, page_size);\n+\n+  \/\/ The shadow area is not allocated or protected, so\n+  \/\/ it needs not be page aligned.\n+  \/\/ But the stack bang currently assumes that it is a\n+  \/\/ multiple of page size. This guarantees that the bang\n+  \/\/ loop touches all pages in the shadow zone.\n+  \/\/ This can be guaranteed differently, as well.  E.g., if\n+  \/\/ the page size is a multiple of 4K, banging in 4K steps\n+  \/\/ suffices to touch all pages. (Some pages are banged\n+  \/\/ several times, though.)\n+  assert(_stack_shadow_zone_size == 0, \"This should be called only once.\");\n+  _stack_shadow_zone_size = align_up(StackShadowPages * alignment, page_size);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  address stack_base() const           { assert(_stack_base != nullptr,\"Sanity check\"); return _stack_base; }\n+  address stack_base() const           { assert(_stack_base != nullptr, \"Sanity check\"); return _stack_base; }\n@@ -79,1 +79,1 @@\n-  \/\/  (small addresses)\n+  \/\/  (low addresses)\n@@ -83,1 +83,1 @@\n-  \/\/  |  red pages                           |\n+  \/\/  |  red zone                            |\n@@ -88,1 +88,1 @@\n-  \/\/  |  yellow pages                       zone\n+  \/\/  |  yellow zone                        zone\n@@ -94,1 +94,1 @@\n-  \/\/  |  reserved pages                      |\n+  \/\/  |  reserved zone                       |\n@@ -119,1 +119,1 @@\n-  \/\/  (large addresses)\n+  \/\/  (high addresses)\n@@ -124,2 +124,1 @@\n-  \/\/ StackReservedPages and StackShadowPages. The zone size is determined\n-  \/\/ ergonomically if page_size > 4K.\n+  \/\/ StackReservedPages and StackShadowPages.\n@@ -130,0 +129,1 @@\n+\n@@ -131,0 +131,2 @@\n+  static void initialize_stack_zone_sizes(size_t alignment);\n+\n@@ -135,6 +137,0 @@\n-  static void set_stack_red_zone_size(size_t s) {\n-    assert(is_aligned(s, os::vm_page_size()),\n-           \"We can not protect if the red zone size is not page aligned.\");\n-    assert(_stack_red_zone_size == 0, \"This should be called only once.\");\n-    _stack_red_zone_size = s;\n-  }\n@@ -152,6 +148,0 @@\n-  static void set_stack_yellow_zone_size(size_t s) {\n-    assert(is_aligned(s, os::vm_page_size()),\n-           \"We can not protect if the yellow zone size is not page aligned.\");\n-    assert(_stack_yellow_zone_size == 0, \"This should be called only once.\");\n-    _stack_yellow_zone_size = s;\n-  }\n@@ -163,6 +153,1 @@\n-  static void set_stack_reserved_zone_size(size_t s) {\n-    assert(is_aligned(s, os::vm_page_size()),\n-           \"We can not protect if the reserved zone size is not page aligned.\");\n-    assert(_stack_reserved_zone_size == 0, \"This should be called only once.\");\n-    _stack_reserved_zone_size = s;\n-  }\n+\n@@ -194,15 +179,0 @@\n-  static void set_stack_shadow_zone_size(size_t s) {\n-    \/\/ The shadow area is not allocated or protected, so\n-    \/\/ it needs not be page aligned.\n-    \/\/ But the stack bang currently assumes that it is a\n-    \/\/ multiple of page size. This guarantees that the bang\n-    \/\/ loop touches all pages in the shadow zone.\n-    \/\/ This can be guaranteed differently, as well.  E.g., if\n-    \/\/ the page size is a multiple of 4K, banging in 4K steps\n-    \/\/ suffices to touch all pages. (Some pages are banged\n-    \/\/ several times, though.)\n-    assert(is_aligned(s, os::vm_page_size()),\n-           \"Stack bang assumes multiple of page size.\");\n-    assert(_stack_shadow_zone_size == 0, \"This should be called only once.\");\n-    _stack_shadow_zone_size = s;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.hpp","additions":11,"deletions":41,"binary":false,"changes":52,"status":"modified"}]}