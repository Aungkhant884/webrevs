{"files":[{"patch":"@@ -4395,1 +4395,1 @@\n-  for (int i = 0; i < (int)(JavaThread::stack_shadow_zone_size() \/ os::vm_page_size()) - 1; i++) {\n+  for (int i = 0; i < (int)(StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size()) - 1; i++) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1527,1 +1527,1 @@\n-    __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());\n+    __ bang_stack_with_offset(StackOverflow::stack_shadow_zone_size());\n@@ -1896,1 +1896,1 @@\n-  __ cmpw(rscratch1, JavaThread::stack_guard_yellow_reserved_disabled);\n+  __ cmpw(rscratch1, StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1123,1 +1123,1 @@\n-    const int n_shadow_pages = JavaThread::stack_shadow_zone_size() \/ os::vm_page_size();\n+    const int n_shadow_pages = StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size();\n@@ -1448,1 +1448,1 @@\n-    __ cmp(rscratch1, (u1)JavaThread::stack_guard_yellow_reserved_disabled);\n+    __ cmp(rscratch1, (u1)StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -997,1 +997,1 @@\n-    sub_slow(tmp, SP, JavaThread::stack_shadow_zone_size());\n+    sub_slow(tmp, SP, StackOverflow::stack_shadow_zone_size());\n@@ -1010,1 +1010,1 @@\n-    add_slow(Rsize, Rsize, JavaThread::stack_shadow_zone_size() - os::vm_page_size());\n+    add_slow(Rsize, Rsize, StackOverflow::stack_shadow_zone_size() - os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1241,1 +1241,1 @@\n-  __ cmp(R2, JavaThread::stack_guard_yellow_reserved_disabled);\n+  __ cmp(R2, StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n-  const int reserved_pages = JavaThread::stack_shadow_zone_size();\n+  const int reserved_pages = StackOverflow::stack_shadow_zone_size();\n@@ -491,1 +491,1 @@\n-  const int guard_pages = JavaThread::stack_guard_zone_size();\n+  const int guard_pages = StackOverflow::stack_guard_zone_size();\n@@ -1019,1 +1019,1 @@\n-    __ cmp_32(Rtemp, JavaThread::stack_guard_yellow_reserved_disabled);\n+    __ cmp_32(Rtemp, StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1430,1 +1430,1 @@\n-    int bang_end = JavaThread::stack_shadow_zone_size();\n+    int bang_end = StackOverflow::stack_shadow_zone_size();\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2510,1 +2510,1 @@\n-  __ cmpwi(CCR0, r_temp_1, JavaThread::stack_guard_yellow_reserved_disabled);\n+  __ cmpwi(CCR0, r_temp_1, StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1189,1 +1189,1 @@\n-    const int n_shadow_pages = ((int)JavaThread::stack_shadow_zone_size()) \/ page_size;\n+    const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2212,2 +2212,2 @@\n-  __ z_cli(Address(Z_thread, JavaThread::stack_guard_state_offset() + in_ByteSize(sizeof(JavaThread::StackGuardState) - 1)),\n-           JavaThread::stack_guard_yellow_reserved_disabled);\n+  __ z_cli(Address(Z_thread, JavaThread::stack_guard_state_offset() + in_ByteSize(sizeof(StackOverflow::StackGuardState) - 1)),\n+           StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2070,1 +2070,1 @@\n-    const int n_shadow_pages = (int)(JavaThread::stack_shadow_zone_size()\/page_size);\n+    const int n_shadow_pages = (int)(StackOverflow::stack_shadow_zone_size()\/page_size);\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1133,1 +1133,1 @@\n-    cmpl(Address(rthread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_enabled);\n+    cmpl(Address(rthread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_enabled);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1061,1 +1061,1 @@\n-  for (int i = 1; i < ((int)JavaThread::stack_shadow_zone_size() \/ os::vm_page_size()); i++) {\n+  for (int i = 1; i < ((int)StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size()); i++) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1871,1 +1871,1 @@\n-    __ bang_stack_with_offset((int)JavaThread::stack_shadow_zone_size());\n+    __ bang_stack_with_offset((int)StackOverflow::stack_shadow_zone_size());\n@@ -2282,1 +2282,1 @@\n-  __ cmpl(Address(thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);\n+  __ cmpl(Address(thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2177,1 +2177,1 @@\n-    __ bang_stack_with_offset((int)JavaThread::stack_shadow_zone_size());\n+    __ bang_stack_with_offset((int)StackOverflow::stack_shadow_zone_size());\n@@ -2641,1 +2641,1 @@\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);\n+  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -774,1 +774,1 @@\n-    const int n_shadow_pages = ((int)JavaThread::stack_shadow_zone_size()) \/ page_size;\n+    const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n@@ -1183,1 +1183,1 @@\n-            JavaThread::stack_guard_yellow_reserved_disabled);\n+            StackOverflow::stack_guard_yellow_reserved_disabled);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    _shadow_pages_size = JavaThread::stack_shadow_zone_size();\n+    _shadow_pages_size = StackOverflow::stack_shadow_zone_size();\n","filename":"src\/hotspot\/cpu\/zero\/stack_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    + (JavaThread::stack_guard_zone_size() + JavaThread::stack_shadow_zone_size());\n+    + (StackOverflow::stack_guard_zone_size() + StackOverflow::stack_shadow_zone_size());\n","filename":"src\/hotspot\/cpu\/zero\/stack_zero.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1037,1 +1037,2 @@\n-    address addr = thread->stack_reserved_zone_base();\n+    StackOverflow* overflow_state = thread->stack_overflow_state();\n+    address addr = overflow_state->stack_reserved_zone_base();\n@@ -1039,1 +1040,1 @@\n-    assert(thread->stack_available(addr) > 0, \"stack guard should not be enabled\");\n+    assert(overflow_state->stack_available(addr) > 0, \"stack guard should not be enabled\");\n@@ -2033,3 +2034,4 @@\n-      if (!jt->stack_guard_zone_unused() &&     \/\/ Stack not yet fully initialized\n-          jt->stack_guards_enabled()) {         \/\/ No pending stack overflow exceptions\n-        if (!os::guard_memory((char *)jt->stack_end(), jt->stack_guard_zone_size())) {\n+      StackOverflow* overflow_state = jt->stack_overflow_state();\n+      if (!overflow_state->stack_guard_zone_unused() &&     \/\/ Stack not yet fully initialized\n+          overflow_state->stack_guards_enabled()) {         \/\/ No pending stack overflow exceptions\n+        if (!os::guard_memory((char *)jt->stack_end(), overflow_state->stack_guard_zone_size())) {\n@@ -6210,1 +6212,1 @@\n-\/\/    +------------------------+ JavaThread::stack_reserved_zone_base()\n+\/\/    +------------------------+ StackOverflow::stack_reserved_zone_base()\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1407,2 +1407,2 @@\n-                                   JavaThread::stack_guard_zone_size() +\n-                                   JavaThread::stack_shadow_zone_size();\n+                                   StackOverflow::stack_guard_zone_size() +\n+                                   StackOverflow::stack_shadow_zone_size();\n@@ -1431,2 +1431,2 @@\n-                                       JavaThread::stack_guard_zone_size() +\n-                                       JavaThread::stack_shadow_zone_size();\n+                                       StackOverflow::stack_guard_zone_size() +\n+                                       StackOverflow::stack_shadow_zone_size();\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2476,1 +2476,2 @@\n-      if (thread->stack_guards_enabled()) {\n+      StackOverflow* overflow_state = thread->stack_overflow_state();\n+      if (overflow_state->stack_guards_enabled()) {\n@@ -2488,1 +2489,1 @@\n-        thread->disable_stack_yellow_reserved_zone();\n+        overflow_state->disable_stack_yellow_reserved_zone();\n@@ -2495,1 +2496,1 @@\n-        thread->disable_stack_red_zone();\n+        overflow_state->disable_stack_red_zone();\n@@ -4094,2 +4095,2 @@\n-            (size_t)(JavaThread::stack_guard_zone_size() +\n-                     JavaThread::stack_shadow_zone_size() +\n+            (size_t)(StackOverflow::stack_guard_zone_size() +\n+                     StackOverflow::stack_shadow_zone_size() +\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  const size_t n_pages = JavaThread::stack_shadow_zone_size() \/ page_size;\n+  const size_t n_pages = StackOverflow::stack_shadow_zone_size() \/ page_size;\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,0 +269,2 @@\n+      StackOverflow* overflow_state = thread->stack_overflow_state();\n+\n@@ -275,1 +277,1 @@\n-      if (thread->in_stack_yellow_reserved_zone(addr)) {\n+      if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n@@ -277,1 +279,1 @@\n-            if (thread->in_stack_reserved_zone(addr)) {\n+            if (overflow_state->in_stack_reserved_zone(addr)) {\n@@ -284,1 +286,1 @@\n-                  thread->disable_stack_reserved_zone();\n+                  overflow_state->disable_stack_reserved_zone();\n@@ -286,1 +288,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.fp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.fp());\n@@ -288,1 +290,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.unextended_sp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n@@ -296,1 +298,1 @@\n-          thread->disable_stack_yellow_reserved_zone();\n+          overflow_state->disable_stack_yellow_reserved_zone();\n@@ -301,1 +303,1 @@\n-          thread->disable_stack_yellow_reserved_zone();\n+          overflow_state->disable_stack_yellow_reserved_zone();\n@@ -304,1 +306,1 @@\n-      } else if (thread->in_stack_red_zone(addr)) {\n+      } else if (overflow_state->in_stack_red_zone(addr)) {\n@@ -307,1 +309,1 @@\n-        thread->disable_stack_red_zone();\n+        overflow_state->disable_stack_red_zone();\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -497,1 +497,2 @@\n-        if (thread->in_stack_yellow_reserved_zone(addr)) {\n+        StackOverflow* overflow_state = thread->stack_overflow_state();\n+        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n@@ -499,1 +500,1 @@\n-            if (thread->in_stack_reserved_zone(addr)) {\n+            if (overflow_state->in_stack_reserved_zone(addr)) {\n@@ -505,1 +506,1 @@\n-                  thread->disable_stack_reserved_zone();\n+                  overflow_state->disable_stack_reserved_zone();\n@@ -507,1 +508,1 @@\n-                    thread->set_reserved_stack_activation((address)(\n+                    overflow_state->set_reserved_stack_activation((address)(\n@@ -510,1 +511,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.unextended_sp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n@@ -518,1 +519,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -522,1 +523,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -525,1 +526,1 @@\n-        } else if (thread->in_stack_red_zone(addr)) {\n+        } else if (overflow_state->in_stack_red_zone(addr)) {\n@@ -528,1 +529,1 @@\n-          thread->disable_stack_red_zone();\n+          overflow_state->disable_stack_red_zone();\n@@ -858,1 +859,1 @@\n-\/\/    +------------------------+ JavaThread::stack_reserved_zone_base()\n+\/\/    +------------------------+ StackOverflow::stack_reserved_zone_base()\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+        StackOverflow* overflow_state = thread->stack_overflow_state();\n@@ -282,1 +283,1 @@\n-        if (thread->in_stack_yellow_reserved_zone(addr)) {\n+        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n@@ -284,1 +285,1 @@\n-            if (thread->in_stack_reserved_zone(addr)) {\n+            if (overflow_state->in_stack_reserved_zone(addr)) {\n@@ -291,1 +292,1 @@\n-                  thread->disable_stack_reserved_zone();\n+                  overflow_state->disable_stack_reserved_zone();\n@@ -293,1 +294,1 @@\n-                    thread->set_reserved_stack_activation((address)(\n+                    overflow_state->set_reserved_stack_activation((address)(\n@@ -296,1 +297,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.unextended_sp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n@@ -304,1 +305,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -308,1 +309,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -311,1 +312,1 @@\n-        } else if (thread->in_stack_red_zone(addr)) {\n+        } else if (overflow_state->in_stack_red_zone(addr)) {\n@@ -314,1 +315,1 @@\n-          thread->disable_stack_red_zone();\n+          overflow_state->disable_stack_red_zone();\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -325,2 +325,3 @@\n-        if (thread->in_stack_yellow_reserved_zone(addr)) {\n-          thread->disable_stack_yellow_reserved_zone();\n+        StackOverflow* overflow_state = thread->stack_overflow_state();\n+        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n+          overflow_state->disable_stack_yellow_reserved_zone();\n@@ -335,1 +336,1 @@\n-        } else if (thread->in_stack_red_zone(addr)) {\n+        } else if (overflow_state->in_stack_red_zone(addr)) {\n@@ -338,1 +339,1 @@\n-          thread->disable_stack_red_zone();\n+          overflow_state->disable_stack_red_zone();\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -329,1 +329,2 @@\n-        if (thread->in_stack_yellow_reserved_zone(addr)) {\n+        StackOverflow* overflow_state = thread->stack_overflow_state();\n+        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n@@ -331,1 +332,1 @@\n-            if (thread->in_stack_reserved_zone(addr)) {\n+            if (overflow_state->in_stack_reserved_zone(addr)) {\n@@ -338,1 +339,1 @@\n-                  thread->disable_stack_reserved_zone();\n+                  overflow_state->disable_stack_reserved_zone();\n@@ -340,1 +341,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.fp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.fp());\n@@ -342,1 +343,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.unextended_sp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n@@ -350,1 +351,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -354,1 +355,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -357,1 +358,1 @@\n-        } else if (thread->in_stack_red_zone(addr)) {\n+        } else if (overflow_state->in_stack_red_zone(addr)) {\n@@ -360,1 +361,1 @@\n-          thread->disable_stack_red_zone();\n+          overflow_state->disable_stack_red_zone();\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -325,1 +325,2 @@\n-        if (thread->in_stack_yellow_reserved_zone(addr)) {\n+        StackOverflow* overflow_state = thread->stack_overflow_state();\n+        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n@@ -327,1 +328,1 @@\n-            if (thread->in_stack_reserved_zone(addr)) {\n+            if (overflow_state->in_stack_reserved_zone(addr)) {\n@@ -334,1 +335,1 @@\n-                  thread->disable_stack_reserved_zone();\n+                  overflow_state->disable_stack_reserved_zone();\n@@ -336,1 +337,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.fp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.fp());\n@@ -338,1 +339,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.unextended_sp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n@@ -346,1 +347,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -350,1 +351,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -353,1 +354,1 @@\n-        } else if (thread->in_stack_red_zone(addr)) {\n+        } else if (overflow_state->in_stack_red_zone(addr)) {\n@@ -356,1 +357,1 @@\n-          thread->disable_stack_red_zone();\n+          overflow_state->disable_stack_red_zone();\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -326,1 +326,2 @@\n-        if (thread->in_stack_yellow_reserved_zone(addr)) {\n+        StackOverflow* overflow_state = thread->stack_overflow_state();\n+        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n@@ -328,1 +329,1 @@\n-            if (thread->in_stack_reserved_zone(addr)) {\n+            if (overflow_state->in_stack_reserved_zone(addr)) {\n@@ -335,1 +336,1 @@\n-                  thread->disable_stack_reserved_zone();\n+                  overflow_state->disable_stack_reserved_zone();\n@@ -337,1 +338,1 @@\n-                    thread->set_reserved_stack_activation((address)(\n+                    overflow_state->set_reserved_stack_activation((address)(\n@@ -340,1 +341,1 @@\n-                    thread->set_reserved_stack_activation((address)activation.unextended_sp());\n+                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n@@ -348,1 +349,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -352,1 +353,1 @@\n-            thread->disable_stack_yellow_reserved_zone();\n+            overflow_state->disable_stack_yellow_reserved_zone();\n@@ -355,1 +356,1 @@\n-        } else if (thread->in_stack_red_zone(addr)) {\n+        } else if (overflow_state->in_stack_red_zone(addr)) {\n@@ -358,1 +359,1 @@\n-          thread->disable_stack_red_zone();\n+          overflow_state->disable_stack_red_zone();\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+        StackOverflow* overflow_state = thread->stack_overflow_state();\n@@ -171,2 +172,2 @@\n-        if (thread->in_stack_yellow_reserved_zone(addr)) {\n-          thread->disable_stack_yellow_reserved_zone();\n+        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n+          overflow_state->disable_stack_yellow_reserved_zone();\n@@ -175,2 +176,2 @@\n-        else if (thread->in_stack_red_zone(addr)) {\n-          thread->disable_stack_red_zone();\n+        else if (overflow_state->in_stack_red_zone(addr)) {\n+          overflow_state->disable_stack_red_zone();\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,1 +138,1 @@\n-    int bang_end = (int)JavaThread::stack_shadow_zone_size();\n+    int bang_end = (int)StackOverflow::stack_shadow_zone_size();\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -530,2 +530,1 @@\n-  bool guard_pages_enabled = thread->stack_guards_enabled();\n-  if (!guard_pages_enabled) guard_pages_enabled = thread->reguard_stack();\n+  bool guard_pages_enabled = thread->stack_overflow_state()->reguard_stack_if_needed();\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -551,1 +551,1 @@\n-  if (handler_bci < 0 || !thread->reguard_stack((address) &continuation)) {\n+  if (handler_bci < 0 || !thread->stack_overflow_state()->reguard_stack((address) &continuation)) {\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,2 +270,1 @@\n-  bool guard_pages_enabled = thread->stack_guards_enabled();\n-  if (!guard_pages_enabled) guard_pages_enabled = thread->reguard_stack();\n+  bool guard_pages_enabled = thread->stack_overflow_state()->reguard_stack_if_needed();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-  nonstatic_field(JavaThread,                  _reserved_stack_activation,                    address)                               \\\n+  nonstatic_field(JavaThread,                  _stack_overflow_state._reserved_stack_activation, address)                            \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1347,1 +1347,1 @@\n-    bool force_unwind = !thread->reguard_stack();\n+    bool force_unwind = !thread->stack_overflow_state()->reguard_stack();\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3967,1 +3967,1 @@\n-  thread->create_stack_guard_pages();\n+  thread->stack_overflow_state()->create_stack_guard_pages();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3686,1 +3686,1 @@\n-  if (thread->stack_available((address) &method_handle) >= JVMInvokeMethodSlack) {\n+  if (thread->stack_overflow_state()->stack_available((address) &method_handle) >= JVMInvokeMethodSlack) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1688,1 +1688,2 @@\n-  return (jlong) thread->stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();\n+  return (jlong) thread->stack_overflow_state()->stack_available(\n+                   os::current_stack_pointer()) - (jlong)StackOverflow::stack_shadow_zone_size();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1692,2 +1692,1 @@\n-      bool guard_pages_enabled = jt->stack_guards_enabled();\n-      if (!guard_pages_enabled) guard_pages_enabled = jt->reguard_stack();\n+      bool guard_pages_enabled = jt->stack_overflow_state()->reguard_stack_if_needed();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -172,2 +172,2 @@\n-    if (_thread->stack_yellow_reserved_zone_disabled()) {\n-      _thread->enable_stack_yellow_reserved_zone();\n+    if (_thread->stack_overflow_state()->stack_yellow_reserved_zone_disabled()) {\n+      _thread->stack_overflow_state()->enable_stack_yellow_reserved_zone();\n@@ -312,2 +312,2 @@\n-    if (_thread->stack_yellow_reserved_zone_disabled()) {\n-      _thread->enable_stack_yellow_reserved_zone();\n+    if (_thread->stack_overflow_state()->stack_yellow_reserved_zone_disabled()) {\n+      _thread->stack_overflow_state()->enable_stack_yellow_reserved_zone();\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -381,3 +381,1 @@\n-  if (!thread->stack_guards_enabled()) {\n-    thread->reguard_stack();\n-  }\n+  thread->stack_overflow_state()->reguard_stack_if_needed();\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -460,4 +460,4 @@\n-  JavaThread::set_stack_red_zone_size     (align_up(StackRedPages      * 4 * K, vm_page_size()));\n-  JavaThread::set_stack_yellow_zone_size  (align_up(StackYellowPages   * 4 * K, vm_page_size()));\n-  JavaThread::set_stack_reserved_zone_size(align_up(StackReservedPages * 4 * K, vm_page_size()));\n-  JavaThread::set_stack_shadow_zone_size  (align_up(StackShadowPages   * 4 * K, vm_page_size()));\n+  StackOverflow::set_stack_red_zone_size     (align_up(StackRedPages      * 4 * K, vm_page_size()));\n+  StackOverflow::set_stack_yellow_zone_size  (align_up(StackYellowPages   * 4 * K, vm_page_size()));\n+  StackOverflow::set_stack_reserved_zone_size(align_up(StackReservedPages * 4 * K, vm_page_size()));\n+  StackOverflow::set_stack_shadow_zone_size  (align_up(StackShadowPages   * 4 * K, vm_page_size()));\n@@ -1379,1 +1379,1 @@\n-                  (JavaThread::stack_guard_zone_size() + JavaThread::stack_shadow_zone_size());\n+                  (StackOverflow::stack_guard_zone_size() + StackOverflow::stack_shadow_zone_size());\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -483,4 +483,4 @@\n-      bool guard_pages_enabled = thread->stack_guards_enabled();\n-      if (!guard_pages_enabled) guard_pages_enabled = thread->reguard_stack();\n-      if (thread->reserved_stack_activation() != thread->stack_base()) {\n-        thread->set_reserved_stack_activation(thread->stack_base());\n+      StackOverflow* overflow_state = thread->stack_overflow_state();\n+      bool guard_pages_enabled = overflow_state->reguard_stack_if_needed();\n+      if (overflow_state->reserved_stack_activation() != thread->stack_base()) {\n+        overflow_state->set_reserved_stack_activation(thread->stack_base());\n@@ -2068,1 +2068,1 @@\n-  (void) JavaThread::current()->reguard_stack();\n+  (void) JavaThread::current()->stack_overflow_state()->reguard_stack();\n@@ -3161,4 +3161,3 @@\n-  if (thread->stack_reserved_zone_disabled()) {\n-    thread->enable_stack_reserved_zone();\n-  }\n-  thread->set_reserved_stack_activation(thread->stack_base());\n+  StackOverflow* overflow_state = thread->stack_overflow_state();\n+  overflow_state->enable_stack_reserved_zone(\/*check_if_disabled*\/true);\n+  overflow_state->set_reserved_stack_activation(thread->stack_base());\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/stackOverflow.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+size_t StackOverflow::_stack_red_zone_size = 0;\n+size_t StackOverflow::_stack_yellow_zone_size = 0;\n+size_t StackOverflow::_stack_reserved_zone_size = 0;\n+size_t StackOverflow::_stack_shadow_zone_size = 0;\n+\n+bool StackOverflow::stack_guards_enabled() {\n+#ifdef ASSERT\n+  if (os::uses_stack_guard_pages() &&\n+      !(DisablePrimordialThreadGuardPages && os::is_primordial_thread())) {\n+    assert(_stack_guard_state != stack_guard_unused, \"guard pages must be in use\");\n+  }\n+#endif\n+  return _stack_guard_state == stack_guard_enabled;\n+}\n+\n+void StackOverflow::create_stack_guard_pages() {\n+  if (!os::uses_stack_guard_pages() ||\n+      _stack_guard_state != stack_guard_unused ||\n+      (DisablePrimordialThreadGuardPages && os::is_primordial_thread())) {\n+      log_info(os, thread)(\"Stack guard page creation for thread \"\n+                           UINTX_FORMAT \" disabled\", os::current_thread_id());\n+    return;\n+  }\n+  address low_addr = stack_end();\n+  size_t len = stack_guard_zone_size();\n+\n+  assert(is_aligned(low_addr, os::vm_page_size()), \"Stack base should be the start of a page\");\n+  assert(is_aligned(len, os::vm_page_size()), \"Stack size should be a multiple of page size\");\n+\n+  int must_commit = os::must_commit_stack_guard_pages();\n+  \/\/ warning(\"Guarding at \" PTR_FORMAT \" for len \" SIZE_FORMAT \"\\n\", low_addr, len);\n+\n+  if (must_commit && !os::create_stack_guard_pages((char *) low_addr, len)) {\n+    log_warning(os, thread)(\"Attempt to allocate stack guard pages failed.\");\n+    return;\n+  }\n+\n+  if (os::guard_memory((char *) low_addr, len)) {\n+    _stack_guard_state = stack_guard_enabled;\n+  } else {\n+    log_warning(os, thread)(\"Attempt to protect stack guard pages failed (\"\n+      PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n+    if (os::uncommit_memory((char *) low_addr, len)) {\n+      log_warning(os, thread)(\"Attempt to deallocate stack guard pages failed.\");\n+    }\n+    return;\n+  }\n+\n+  log_debug(os, thread)(\"Thread \" UINTX_FORMAT \" stack guard pages activated: \"\n+    PTR_FORMAT \"-\" PTR_FORMAT \".\",\n+    os::current_thread_id(), p2i(low_addr), p2i(low_addr + len));\n+}\n+\n+void StackOverflow::remove_stack_guard_pages() {\n+  if (_stack_guard_state == stack_guard_unused) return;\n+  address low_addr = stack_end();\n+  size_t len = stack_guard_zone_size();\n+\n+  if (os::must_commit_stack_guard_pages()) {\n+    if (os::remove_stack_guard_pages((char *) low_addr, len)) {\n+      _stack_guard_state = stack_guard_unused;\n+    } else {\n+      log_warning(os, thread)(\"Attempt to deallocate stack guard pages failed (\"\n+        PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n+      return;\n+    }\n+  } else {\n+    if (_stack_guard_state == stack_guard_unused) return;\n+    if (os::unguard_memory((char *) low_addr, len)) {\n+      _stack_guard_state = stack_guard_unused;\n+    } else {\n+      log_warning(os, thread)(\"Attempt to unprotect stack guard pages failed (\"\n+        PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n+      return;\n+    }\n+  }\n+\n+  log_debug(os, thread)(\"Thread \" UINTX_FORMAT \" stack guard pages removed: \"\n+    PTR_FORMAT \"-\" PTR_FORMAT \".\",\n+    os::current_thread_id(), p2i(low_addr), p2i(low_addr + len));\n+}\n+\n+void StackOverflow::enable_stack_reserved_zone(bool check_if_disabled) {\n+  if (check_if_disabled && _stack_guard_state == stack_guard_reserved_disabled) {\n+    return;\n+  }\n+  assert(_stack_guard_state == stack_guard_reserved_disabled, \"inconsistent state\");\n+\n+  \/\/ The base notation is from the stack's point of view, growing downward.\n+  \/\/ We need to adjust it to work correctly with guard_memory()\n+  address base = stack_reserved_zone_base() - stack_reserved_zone_size();\n+\n+  guarantee(base < stack_base(),\"Error calculating stack reserved zone\");\n+  guarantee(base < os::current_stack_pointer(),\"Error calculating stack reserved zone\");\n+\n+  if (os::guard_memory((char *) base, stack_reserved_zone_size())) {\n+    _stack_guard_state = stack_guard_enabled;\n+  } else {\n+    warning(\"Attempt to guard stack reserved zone failed.\");\n+  }\n+}\n+\n+void StackOverflow::disable_stack_reserved_zone() {\n+  assert(_stack_guard_state == stack_guard_enabled, \"inconsistent state\");\n+\n+  \/\/ Simply return if called for a thread that does not use guard pages.\n+  if (_stack_guard_state != stack_guard_enabled) return;\n+\n+  \/\/ The base notation is from the stack's point of view, growing downward.\n+  \/\/ We need to adjust it to work correctly with guard_memory()\n+  address base = stack_reserved_zone_base() - stack_reserved_zone_size();\n+\n+  if (os::unguard_memory((char *)base, stack_reserved_zone_size())) {\n+    _stack_guard_state = stack_guard_reserved_disabled;\n+  } else {\n+    warning(\"Attempt to unguard stack reserved zone failed.\");\n+  }\n+}\n+\n+void StackOverflow::enable_stack_yellow_reserved_zone() {\n+  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n+  assert(_stack_guard_state != stack_guard_enabled, \"already enabled\");\n+\n+  \/\/ The base notation is from the stacks point of view, growing downward.\n+  \/\/ We need to adjust it to work correctly with guard_memory()\n+  address base = stack_red_zone_base();\n+\n+  guarantee(base < stack_base(), \"Error calculating stack yellow zone\");\n+  guarantee(base < os::current_stack_pointer(), \"Error calculating stack yellow zone\");\n+\n+  if (os::guard_memory((char *) base, stack_yellow_reserved_zone_size())) {\n+    _stack_guard_state = stack_guard_enabled;\n+  } else {\n+    warning(\"Attempt to guard stack yellow zone failed.\");\n+  }\n+}\n+\n+void StackOverflow::disable_stack_yellow_reserved_zone() {\n+  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n+  assert(_stack_guard_state != stack_guard_yellow_reserved_disabled, \"already disabled\");\n+\n+  \/\/ Simply return if called for a thread that does not use guard pages.\n+  if (_stack_guard_state == stack_guard_unused) return;\n+\n+  \/\/ The base notation is from the stacks point of view, growing downward.\n+  \/\/ We need to adjust it to work correctly with guard_memory()\n+  address base = stack_red_zone_base();\n+\n+  if (os::unguard_memory((char *)base, stack_yellow_reserved_zone_size())) {\n+    _stack_guard_state = stack_guard_yellow_reserved_disabled;\n+  } else {\n+    warning(\"Attempt to unguard stack yellow zone failed.\");\n+  }\n+}\n+\n+void StackOverflow::enable_stack_red_zone() {\n+  \/\/ The base notation is from the stacks point of view, growing downward.\n+  \/\/ We need to adjust it to work correctly with guard_memory()\n+  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n+  address base = stack_red_zone_base() - stack_red_zone_size();\n+\n+  guarantee(base < stack_base(), \"Error calculating stack red zone\");\n+  guarantee(base < os::current_stack_pointer(), \"Error calculating stack red zone\");\n+\n+  if (!os::guard_memory((char *) base, stack_red_zone_size())) {\n+    warning(\"Attempt to guard stack red zone failed.\");\n+  }\n+}\n+\n+void StackOverflow::disable_stack_red_zone() {\n+  \/\/ The base notation is from the stacks point of view, growing downward.\n+  \/\/ We need to adjust it to work correctly with guard_memory()\n+  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n+  address base = stack_red_zone_base() - stack_red_zone_size();\n+  if (!os::unguard_memory((char *)base, stack_red_zone_size())) {\n+    warning(\"Attempt to unguard stack red zone failed.\");\n+  }\n+}\n+\n+bool StackOverflow::reguard_stack(address cur_sp) {\n+  if (_stack_guard_state != stack_guard_yellow_reserved_disabled\n+      && _stack_guard_state != stack_guard_reserved_disabled) {\n+    return true; \/\/ Stack already guarded or guard pages not needed.\n+  }\n+\n+  \/\/ Java code never executes within the yellow zone: the latter is only\n+  \/\/ there to provoke an exception during stack banging.  If java code\n+  \/\/ is executing there, either StackShadowPages should be larger, or\n+  \/\/ some exception code in c1, c2 or the interpreter isn't unwinding\n+  \/\/ when it should.\n+  guarantee(cur_sp > stack_reserved_zone_base(),\n+            \"not enough space to reguard - increase StackShadowPages\");\n+  if (_stack_guard_state == stack_guard_yellow_reserved_disabled) {\n+    enable_stack_yellow_reserved_zone();\n+    if (reserved_stack_activation() != stack_base()) {\n+      set_reserved_stack_activation(stack_base());\n+    }\n+  } else if (_stack_guard_state == stack_guard_reserved_disabled) {\n+    set_reserved_stack_activation(stack_base());\n+    enable_stack_reserved_zone();\n+  }\n+  return true;\n+}\n+\n+bool StackOverflow::reguard_stack(void) {\n+  return reguard_stack(os::current_stack_pointer());\n+}\n+\n+bool StackOverflow::reguard_stack_if_needed() {\n+  return !stack_guards_enabled() ? reguard_stack() : true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.cpp","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_STACKOVERFLOW_HPP\n+#define SHARE_RUNTIME_STACKOVERFLOW_HPP\n+\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+class JavaThread;\n+\n+\/\/ StackOverflow handling is encapsulated in this class.  This class contains state variables\n+\/\/ for each JavaThread that implement stack overflow checking and guard page implementation.\n+\n+class StackOverflow {\n+  friend class JVMCIVMStructs;\n+  friend class JavaThread;\n+ public:\n+  \/\/ State of the stack guard pages for the containing thread.\n+  enum StackGuardState {\n+    stack_guard_unused,         \/\/ not needed\n+    stack_guard_reserved_disabled,\n+    stack_guard_yellow_reserved_disabled,\/\/ disabled (temporarily) after stack overflow\n+    stack_guard_enabled         \/\/ enabled\n+  };\n+\n+  StackOverflow() :\n+    _stack_guard_state(stack_guard_unused),\n+    _stack_overflow_limit(nullptr),\n+    _reserved_stack_activation(nullptr),  \/\/ stack base not known yet\n+    _stack_base(nullptr), _stack_end(nullptr) {}\n+\n+  \/\/ Initialization after thread is started.\n+  void initialize(address base, address end) {\n+     _stack_base = base;\n+     _stack_end = end;\n+    set_stack_overflow_limit();\n+    set_reserved_stack_activation(base);\n+  }\n+ private:\n+\n+  StackGuardState  _stack_guard_state;\n+\n+  \/\/ Precompute the limit of the stack as used in stack overflow checks.\n+  \/\/ We load it from here to simplify the stack overflow check in assembly.\n+  address          _stack_overflow_limit;\n+  address          _reserved_stack_activation;\n+\n+  \/\/ Support for stack overflow handling, copied down from thread.\n+  address          _stack_base;\n+  address          _stack_end;\n+\n+  address stack_end()  const           { return _stack_end; }\n+  address stack_base() const           { assert(_stack_base != nullptr,\"Sanity check\"); return _stack_base; }\n+\n+  \/\/ Stack overflow support\n+  \/\/\n+  \/\/  (small addresses)\n+  \/\/\n+  \/\/  --  <-- stack_end()                   ---\n+  \/\/  |                                      |\n+  \/\/  |  red pages                           |\n+  \/\/  |                                      |\n+  \/\/  --  <-- stack_red_zone_base()          |\n+  \/\/  |                                      |\n+  \/\/  |                                     guard\n+  \/\/  |  yellow pages                       zone\n+  \/\/  |                                      |\n+  \/\/  |                                      |\n+  \/\/  --  <-- stack_yellow_zone_base()       |\n+  \/\/  |                                      |\n+  \/\/  |                                      |\n+  \/\/  |  reserved pages                      |\n+  \/\/  |                                      |\n+  \/\/  --  <-- stack_reserved_zone_base()    ---      ---\n+  \/\/                                                 \/|\\  shadow     <--  stack_overflow_limit() (somewhere in here)\n+  \/\/                                                  |   zone\n+  \/\/                                                 \\|\/  size\n+  \/\/  some untouched memory                          ---\n+  \/\/\n+  \/\/\n+  \/\/  --\n+  \/\/  |\n+  \/\/  |  shadow zone\n+  \/\/  |\n+  \/\/  --\n+  \/\/  x    frame n\n+  \/\/  --\n+  \/\/  x    frame n-1\n+  \/\/  x\n+  \/\/  --\n+  \/\/  ...\n+  \/\/\n+  \/\/  --\n+  \/\/  x    frame 0\n+  \/\/  --  <-- stack_base()\n+  \/\/\n+  \/\/  (large addresses)\n+  \/\/\n+\n+ private:\n+  \/\/ These values are derived from flags StackRedPages, StackYellowPages,\n+  \/\/ StackReservedPages and StackShadowPages. The zone size is determined\n+  \/\/ ergonomically if page_size > 4K.\n+  static size_t _stack_red_zone_size;\n+  static size_t _stack_yellow_zone_size;\n+  static size_t _stack_reserved_zone_size;\n+  static size_t _stack_shadow_zone_size;\n+ public:\n+  static size_t stack_red_zone_size() {\n+    assert(_stack_red_zone_size > 0, \"Don't call this before the field is initialized.\");\n+    return _stack_red_zone_size;\n+  }\n+  static void set_stack_red_zone_size(size_t s) {\n+    assert(is_aligned(s, os::vm_page_size()),\n+           \"We can not protect if the red zone size is not page aligned.\");\n+    assert(_stack_red_zone_size == 0, \"This should be called only once.\");\n+    _stack_red_zone_size = s;\n+  }\n+  address stack_red_zone_base() {\n+    return (address)(stack_end() + stack_red_zone_size());\n+  }\n+  bool in_stack_red_zone(address a) {\n+    return a <= stack_red_zone_base() && a >= stack_end();\n+  }\n+\n+  static size_t stack_yellow_zone_size() {\n+    assert(_stack_yellow_zone_size > 0, \"Don't call this before the field is initialized.\");\n+    return _stack_yellow_zone_size;\n+  }\n+  static void set_stack_yellow_zone_size(size_t s) {\n+    assert(is_aligned(s, os::vm_page_size()),\n+           \"We can not protect if the yellow zone size is not page aligned.\");\n+    assert(_stack_yellow_zone_size == 0, \"This should be called only once.\");\n+    _stack_yellow_zone_size = s;\n+  }\n+\n+  static size_t stack_reserved_zone_size() {\n+    \/\/ _stack_reserved_zone_size may be 0. This indicates the feature is off.\n+    return _stack_reserved_zone_size;\n+  }\n+  static void set_stack_reserved_zone_size(size_t s) {\n+    assert(is_aligned(s, os::vm_page_size()),\n+           \"We can not protect if the reserved zone size is not page aligned.\");\n+    assert(_stack_reserved_zone_size == 0, \"This should be called only once.\");\n+    _stack_reserved_zone_size = s;\n+  }\n+  address stack_reserved_zone_base() const {\n+    return (address)(stack_end() +\n+                     (stack_red_zone_size() + stack_yellow_zone_size() + stack_reserved_zone_size()));\n+  }\n+  bool in_stack_reserved_zone(address a) {\n+    return (a <= stack_reserved_zone_base()) &&\n+           (a >= (address)((intptr_t)stack_reserved_zone_base() - stack_reserved_zone_size()));\n+  }\n+\n+  static size_t stack_yellow_reserved_zone_size() {\n+    return _stack_yellow_zone_size + _stack_reserved_zone_size;\n+  }\n+  bool in_stack_yellow_reserved_zone(address a) {\n+    return (a <= stack_reserved_zone_base()) && (a >= stack_red_zone_base());\n+  }\n+\n+  \/\/ Size of red + yellow + reserved zones.\n+  static size_t stack_guard_zone_size() {\n+    return stack_red_zone_size() + stack_yellow_reserved_zone_size();\n+  }\n+\n+  static size_t stack_shadow_zone_size() {\n+    assert(_stack_shadow_zone_size > 0, \"Don't call this before the field is initialized.\");\n+    return _stack_shadow_zone_size;\n+  }\n+  static void set_stack_shadow_zone_size(size_t s) {\n+    \/\/ The shadow area is not allocated or protected, so\n+    \/\/ it needs not be page aligned.\n+    \/\/ But the stack bang currently assumes that it is a\n+    \/\/ multiple of page size. This guarantees that the bang\n+    \/\/ loop touches all pages in the shadow zone.\n+    \/\/ This can be guaranteed differently, as well.  E.g., if\n+    \/\/ the page size is a multiple of 4K, banging in 4K steps\n+    \/\/ suffices to touch all pages. (Some pages are banged\n+    \/\/ several times, though.)\n+    assert(is_aligned(s, os::vm_page_size()),\n+           \"Stack bang assumes multiple of page size.\");\n+    assert(_stack_shadow_zone_size == 0, \"This should be called only once.\");\n+    _stack_shadow_zone_size = s;\n+  }\n+\n+  void create_stack_guard_pages();\n+  void remove_stack_guard_pages();\n+\n+  void enable_stack_reserved_zone(bool check_if_disabled = false);\n+  void disable_stack_reserved_zone();\n+  void enable_stack_yellow_reserved_zone();\n+  void disable_stack_yellow_reserved_zone();\n+  void enable_stack_red_zone();\n+  void disable_stack_red_zone();\n+\n+  bool stack_guard_zone_unused() { return _stack_guard_state == stack_guard_unused; }\n+\n+  bool stack_yellow_reserved_zone_disabled() {\n+    return _stack_guard_state == stack_guard_yellow_reserved_disabled;\n+  }\n+\n+  size_t stack_available(address cur_sp) {\n+    \/\/ This code assumes java stacks grow down\n+    address low_addr; \/\/ Limit on the address for deepest stack depth\n+    if (_stack_guard_state == stack_guard_unused) {\n+      low_addr = stack_end();\n+    } else {\n+      low_addr = stack_reserved_zone_base();\n+    }\n+    return cur_sp > low_addr ? cur_sp - low_addr : 0;\n+  }\n+\n+  bool stack_guards_enabled();\n+\n+  address reserved_stack_activation() const { return _reserved_stack_activation; }\n+  void set_reserved_stack_activation(address addr) {\n+    assert(_reserved_stack_activation == stack_base()\n+            || _reserved_stack_activation == nullptr\n+            || addr == stack_base(), \"Must not be set twice\");\n+    _reserved_stack_activation = addr;\n+  }\n+\n+  \/\/ Attempt to reguard the stack after a stack overflow may have occurred.\n+  \/\/ Returns true if (a) guard pages are not needed on this thread, (b) the\n+  \/\/ pages are already guarded, or (c) the pages were successfully reguarded.\n+  \/\/ Returns false if there is not enough stack space to reguard the pages, in\n+  \/\/ which case the caller should unwind a frame and try again.  The argument\n+  \/\/ should be the caller's (approximate) sp.\n+  bool reguard_stack(address cur_sp);\n+  \/\/ Similar to above but see if current stackpoint is out of the guard area\n+  \/\/ and reguard if possible.\n+  bool reguard_stack(void);\n+  bool reguard_stack_if_needed(void);\n+\n+  void set_stack_overflow_limit() {\n+    _stack_overflow_limit =\n+      stack_end() + MAX2(stack_guard_zone_size(), stack_shadow_zone_size());\n+  }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_STACKOVERFLOW_HPP\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.hpp","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -355,2 +355,1 @@\n-    as_Java_thread()->set_stack_overflow_limit();\n-    as_Java_thread()->set_reserved_stack_activation(stack_base());\n+    as_Java_thread()->stack_overflow_state()->initialize(stack_base(), stack_end());\n@@ -1665,1 +1664,1 @@\n-void JavaThread::initialize() {\n+JavaThread::JavaThread() :\n@@ -1668,3 +1667,66 @@\n-  set_saved_exception_pc(NULL);\n-  _anchor.clear();\n-  set_entry_point(NULL);\n+  _on_thread_list(false),\n+  DEBUG_ONLY(_java_call_counter(0) COMMA)\n+  _entry_point(nullptr),\n+  _deopt_mark(nullptr),\n+  _deopt_nmethod(nullptr),\n+  _vframe_array_head(nullptr),\n+  _vframe_array_last(nullptr),\n+  _deferred_locals_updates(nullptr),\n+  _callee_target(nullptr),\n+  _vm_result(nullptr),\n+  _vm_result_2(nullptr),\n+\n+  _monitor_chunks(nullptr),\n+  _special_runtime_exit_condition(_no_async_condition),\n+  _pending_async_exception(nullptr),\n+\n+  _thread_state(_thread_new),\n+  _saved_exception_pc(nullptr),\n+\n+  _terminated(_not_terminated),\n+  _suspend_equivalent(false),\n+  _in_deopt_handler(0),\n+  _doing_unsafe_access(false),\n+  _do_not_unlock_if_synchronized(false),\n+  _jni_attach_state(_not_attaching_via_jni),\n+#if INCLUDE_JVMCI\n+  _pending_deoptimization(-1),\n+  _pending_monitorenter(false),\n+  _pending_transfer_to_interpreter(false),\n+  _in_retryable_allocation(false),\n+  _pending_failed_speculation(0),\n+  _jvmci{nullptr},\n+  _jvmci_counters(nullptr),\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  _exception_oop(oop()),\n+  _exception_pc(0),\n+  _exception_handler_pc(0),\n+  _is_method_handle_return(0),\n+\n+  _jni_active_critical(0),\n+  _pending_jni_exception_check_fn(nullptr),\n+  _depth_first_number(0),\n+\n+  \/\/ JVMTI PopFrame support\n+  _popframe_condition(popframe_inactive),\n+  _frames_to_pop_failed_realloc(0),\n+\n+  _handshake(this),\n+\n+  _popframe_preserved_args(nullptr),\n+  _popframe_preserved_args_size(0),\n+\n+  _jvmti_thread_state(nullptr),\n+  _interp_only_mode(0),\n+  _should_post_on_exceptions_flag(JNI_FALSE),\n+  _thread_stat(new ThreadStatistics()),\n+\n+  _parker(Parker::Allocate(this)),\n+  _cached_monitor_info(nullptr),\n+\n+  _class_to_be_initialized(nullptr),\n+\n+  _SleepEvent(ParkEvent::Allocate(this))\n+{\n+\n@@ -1672,16 +1734,1 @@\n-  set_callee_target(NULL);\n-  set_vm_result(NULL);\n-  set_vm_result_2(NULL);\n-  set_vframe_array_head(NULL);\n-  set_vframe_array_last(NULL);\n-  set_deferred_locals(NULL);\n-  set_deopt_mark(NULL);\n-  set_deopt_compiled_method(NULL);\n-  set_monitor_chunks(NULL);\n-  _on_thread_list = false;\n-  _thread_state = _thread_new;\n-  _terminated = _not_terminated;\n-  _suspend_equivalent = false;\n-  _in_deopt_handler = 0;\n-  _doing_unsafe_access = false;\n-  _stack_guard_state = stack_guard_unused;\n+\n@@ -1689,8 +1736,1 @@\n-  _pending_monitorenter = false;\n-  _pending_deoptimization = -1;\n-  _pending_failed_speculation = 0;\n-  _pending_transfer_to_interpreter = false;\n-  _in_retryable_allocation = false;\n-  _jvmci._alternate_call_target = NULL;\n-  assert(_jvmci._implicit_exception_pc == NULL, \"must be\");\n-  _jvmci_counters = NULL;\n+  assert(_jvmci._implicit_exception_pc == nullptr, \"must be\");\n@@ -1701,18 +1741,1 @@\n-  _reserved_stack_activation = NULL;  \/\/ stack base not known yet\n-  set_exception_oop(oop());\n-  _exception_pc  = 0;\n-  _exception_handler_pc = 0;\n-  _is_method_handle_return = 0;\n-  _jvmti_thread_state= NULL;\n-  _should_post_on_exceptions_flag = JNI_FALSE;\n-  _interp_only_mode    = 0;\n-  _special_runtime_exit_condition = _no_async_condition;\n-  _pending_async_exception = NULL;\n-  _thread_stat = NULL;\n-  _thread_stat = new ThreadStatistics();\n-  _jni_active_critical = 0;\n-  _pending_jni_exception_check_fn = NULL;\n-  _do_not_unlock_if_synchronized = false;\n-  _cached_monitor_info = NULL;\n-  _parker = Parker::Allocate(this);\n-  _SleepEvent = ParkEvent::Allocate(this);\n+\n@@ -1722,8 +1745,0 @@\n-  debug_only(_java_call_counter = 0);\n-\n-  \/\/ JVMTI PopFrame support\n-  _popframe_condition = popframe_inactive;\n-  _popframe_preserved_args = NULL;\n-  _popframe_preserved_args_size = 0;\n-  _frames_to_pop_failed_realloc = 0;\n-\n@@ -1731,3 +1746,0 @@\n-\n-  _class_to_be_initialized = NULL;\n-\n@@ -1735,0 +1747,1 @@\n+  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n@@ -1737,3 +1750,1 @@\n-JavaThread::JavaThread(bool is_attaching_via_jni) :\n-                       Thread(), _handshake(this) {\n-  initialize();\n+JavaThread::JavaThread(bool is_attaching_via_jni) : JavaThread() {\n@@ -1742,2 +1753,0 @@\n-  } else {\n-    _jni_attach_state = _not_attaching_via_jni;\n@@ -1745,1 +1754,0 @@\n-  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n@@ -1806,29 +1814,0 @@\n-bool JavaThread::reguard_stack(address cur_sp) {\n-  if (_stack_guard_state != stack_guard_yellow_reserved_disabled\n-      && _stack_guard_state != stack_guard_reserved_disabled) {\n-    return true; \/\/ Stack already guarded or guard pages not needed.\n-  }\n-\n-  \/\/ Java code never executes within the yellow zone: the latter is only\n-  \/\/ there to provoke an exception during stack banging.  If java code\n-  \/\/ is executing there, either StackShadowPages should be larger, or\n-  \/\/ some exception code in c1, c2 or the interpreter isn't unwinding\n-  \/\/ when it should.\n-  guarantee(cur_sp > stack_reserved_zone_base(),\n-            \"not enough space to reguard - increase StackShadowPages\");\n-  if (_stack_guard_state == stack_guard_yellow_reserved_disabled) {\n-    enable_stack_yellow_reserved_zone();\n-    if (reserved_stack_activation() != stack_base()) {\n-      set_reserved_stack_activation(stack_base());\n-    }\n-  } else if (_stack_guard_state == stack_guard_reserved_disabled) {\n-    set_reserved_stack_activation(stack_base());\n-    enable_stack_reserved_zone();\n-  }\n-  return true;\n-}\n-\n-bool JavaThread::reguard_stack(void) {\n-  return reguard_stack(os::current_stack_pointer());\n-}\n-\n@@ -1852,3 +1831,1 @@\n-JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :\n-                       Thread(), _handshake(this) {\n-  initialize();\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : JavaThread() {\n@@ -1938,1 +1915,1 @@\n-  this->initialize_tlab();\n+  initialize_tlab();\n@@ -1940,1 +1917,1 @@\n-  this->create_stack_guard_pages();\n+  _stack_overflow_state.create_stack_guard_pages();\n@@ -1942,1 +1919,1 @@\n-  this->cache_global_variables();\n+  cache_global_variables();\n@@ -1959,1 +1936,1 @@\n-  this->set_active_handles(JNIHandleBlock::allocate_block());\n+  set_active_handles(JNIHandleBlock::allocate_block());\n@@ -2178,1 +2155,1 @@\n-  remove_stack_guard_pages();\n+  _stack_overflow_state.remove_stack_guard_pages();\n@@ -2237,1 +2214,1 @@\n-  remove_stack_guard_pages();\n+  _stack_overflow_state.remove_stack_guard_pages();\n@@ -2700,178 +2677,0 @@\n-size_t JavaThread::_stack_red_zone_size = 0;\n-size_t JavaThread::_stack_yellow_zone_size = 0;\n-size_t JavaThread::_stack_reserved_zone_size = 0;\n-size_t JavaThread::_stack_shadow_zone_size = 0;\n-\n-void JavaThread::create_stack_guard_pages() {\n-  if (!os::uses_stack_guard_pages() ||\n-      _stack_guard_state != stack_guard_unused ||\n-      (DisablePrimordialThreadGuardPages && os::is_primordial_thread())) {\n-      log_info(os, thread)(\"Stack guard page creation for thread \"\n-                           UINTX_FORMAT \" disabled\", os::current_thread_id());\n-    return;\n-  }\n-  address low_addr = stack_end();\n-  size_t len = stack_guard_zone_size();\n-\n-  assert(is_aligned(low_addr, os::vm_page_size()), \"Stack base should be the start of a page\");\n-  assert(is_aligned(len, os::vm_page_size()), \"Stack size should be a multiple of page size\");\n-\n-  int must_commit = os::must_commit_stack_guard_pages();\n-  \/\/ warning(\"Guarding at \" PTR_FORMAT \" for len \" SIZE_FORMAT \"\\n\", low_addr, len);\n-\n-  if (must_commit && !os::create_stack_guard_pages((char *) low_addr, len)) {\n-    log_warning(os, thread)(\"Attempt to allocate stack guard pages failed.\");\n-    return;\n-  }\n-\n-  if (os::guard_memory((char *) low_addr, len)) {\n-    _stack_guard_state = stack_guard_enabled;\n-  } else {\n-    log_warning(os, thread)(\"Attempt to protect stack guard pages failed (\"\n-      PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n-    if (os::uncommit_memory((char *) low_addr, len)) {\n-      log_warning(os, thread)(\"Attempt to deallocate stack guard pages failed.\");\n-    }\n-    return;\n-  }\n-\n-  log_debug(os, thread)(\"Thread \" UINTX_FORMAT \" stack guard pages activated: \"\n-    PTR_FORMAT \"-\" PTR_FORMAT \".\",\n-    os::current_thread_id(), p2i(low_addr), p2i(low_addr + len));\n-}\n-\n-void JavaThread::remove_stack_guard_pages() {\n-  assert(Thread::current() == this, \"from different thread\");\n-  if (_stack_guard_state == stack_guard_unused) return;\n-  address low_addr = stack_end();\n-  size_t len = stack_guard_zone_size();\n-\n-  if (os::must_commit_stack_guard_pages()) {\n-    if (os::remove_stack_guard_pages((char *) low_addr, len)) {\n-      _stack_guard_state = stack_guard_unused;\n-    } else {\n-      log_warning(os, thread)(\"Attempt to deallocate stack guard pages failed (\"\n-        PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n-      return;\n-    }\n-  } else {\n-    if (_stack_guard_state == stack_guard_unused) return;\n-    if (os::unguard_memory((char *) low_addr, len)) {\n-      _stack_guard_state = stack_guard_unused;\n-    } else {\n-      log_warning(os, thread)(\"Attempt to unprotect stack guard pages failed (\"\n-        PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n-      return;\n-    }\n-  }\n-\n-  log_debug(os, thread)(\"Thread \" UINTX_FORMAT \" stack guard pages removed: \"\n-    PTR_FORMAT \"-\" PTR_FORMAT \".\",\n-    os::current_thread_id(), p2i(low_addr), p2i(low_addr + len));\n-}\n-\n-void JavaThread::enable_stack_reserved_zone() {\n-  assert(_stack_guard_state == stack_guard_reserved_disabled, \"inconsistent state\");\n-\n-  \/\/ The base notation is from the stack's point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  address base = stack_reserved_zone_base() - stack_reserved_zone_size();\n-\n-  guarantee(base < stack_base(),\"Error calculating stack reserved zone\");\n-  guarantee(base < os::current_stack_pointer(),\"Error calculating stack reserved zone\");\n-\n-  if (os::guard_memory((char *) base, stack_reserved_zone_size())) {\n-    _stack_guard_state = stack_guard_enabled;\n-  } else {\n-    warning(\"Attempt to guard stack reserved zone failed.\");\n-  }\n-}\n-\n-void JavaThread::disable_stack_reserved_zone() {\n-  assert(_stack_guard_state == stack_guard_enabled, \"inconsistent state\");\n-\n-  \/\/ Simply return if called for a thread that does not use guard pages.\n-  if (_stack_guard_state != stack_guard_enabled) return;\n-\n-  \/\/ The base notation is from the stack's point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  address base = stack_reserved_zone_base() - stack_reserved_zone_size();\n-\n-  if (os::unguard_memory((char *)base, stack_reserved_zone_size())) {\n-    _stack_guard_state = stack_guard_reserved_disabled;\n-  } else {\n-    warning(\"Attempt to unguard stack reserved zone failed.\");\n-  }\n-}\n-\n-void JavaThread::enable_stack_yellow_reserved_zone() {\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  assert(_stack_guard_state != stack_guard_enabled, \"already enabled\");\n-\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  address base = stack_red_zone_base();\n-\n-  guarantee(base < stack_base(), \"Error calculating stack yellow zone\");\n-  guarantee(base < os::current_stack_pointer(), \"Error calculating stack yellow zone\");\n-\n-  if (os::guard_memory((char *) base, stack_yellow_reserved_zone_size())) {\n-    _stack_guard_state = stack_guard_enabled;\n-  } else {\n-    warning(\"Attempt to guard stack yellow zone failed.\");\n-  }\n-}\n-\n-void JavaThread::disable_stack_yellow_reserved_zone() {\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  assert(_stack_guard_state != stack_guard_yellow_reserved_disabled, \"already disabled\");\n-\n-  \/\/ Simply return if called for a thread that does not use guard pages.\n-  if (_stack_guard_state == stack_guard_unused) return;\n-\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  address base = stack_red_zone_base();\n-\n-  if (os::unguard_memory((char *)base, stack_yellow_reserved_zone_size())) {\n-    _stack_guard_state = stack_guard_yellow_reserved_disabled;\n-  } else {\n-    warning(\"Attempt to unguard stack yellow zone failed.\");\n-  }\n-}\n-\n-void JavaThread::enable_stack_red_zone() {\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  address base = stack_red_zone_base() - stack_red_zone_size();\n-\n-  guarantee(base < stack_base(), \"Error calculating stack red zone\");\n-  guarantee(base < os::current_stack_pointer(), \"Error calculating stack red zone\");\n-\n-  if (!os::guard_memory((char *) base, stack_red_zone_size())) {\n-    warning(\"Attempt to guard stack red zone failed.\");\n-  }\n-}\n-\n-void JavaThread::disable_stack_red_zone() {\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  address base = stack_red_zone_base() - stack_red_zone_size();\n-  if (!os::unguard_memory((char *)base, stack_red_zone_size())) {\n-    warning(\"Attempt to unguard stack red zone failed.\");\n-  }\n-}\n-\n-void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {\n-  \/\/ ignore is there is no stack\n-  if (!has_last_Java_frame()) return;\n-  \/\/ traverse the stack frames. Starts from top frame.\n-  for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {\n-    frame* fr = fst.current();\n-    f(fr, fst.register_map());\n-  }\n-}\n-\n-\n@@ -3151,0 +2950,1 @@\n+\n@@ -3153,0 +2953,10 @@\n+void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {\n+  \/\/ ignore if there is no stack\n+  if (!has_last_Java_frame()) return;\n+  \/\/ traverse the stack frames. Starts from top frame.\n+  for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {\n+    frame* fr = fst.current();\n+    f(fr, fst.register_map());\n+  }\n+}\n+\n@@ -3897,1 +3707,1 @@\n-  main_thread->create_stack_guard_pages();\n+  main_thread->stack_overflow_state()->create_stack_guard_pages();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":92,"deletions":282,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/stackOverflow.hpp\"\n@@ -1136,10 +1137,0 @@\n- public:\n-  \/\/ State of the stack guard pages for this thread.\n-  enum StackGuardState {\n-    stack_guard_unused,         \/\/ not needed\n-    stack_guard_reserved_disabled,\n-    stack_guard_yellow_reserved_disabled,\/\/ disabled (temporarily) after stack overflow\n-    stack_guard_enabled         \/\/ enabled\n-  };\n-\n- private:\n@@ -1193,6 +1184,1 @@\n-  StackGuardState  _stack_guard_state;\n-\n-  \/\/ Precompute the limit of the stack as used in stack overflow checks.\n-  \/\/ We load it from here to simplify the stack overflow check in assembly.\n-  address          _stack_overflow_limit;\n-  address          _reserved_stack_activation;\n+  StackOverflow    _stack_overflow_state;\n@@ -1232,1 +1218,0 @@\n-  void initialize();                             \/\/ Initialized the instance variables\n@@ -1236,1 +1221,2 @@\n-  JavaThread(bool is_attaching_via_jni = false); \/\/ for main thread and JNI attached threads\n+  JavaThread();                            \/\/ delegating constructor\n+  JavaThread(bool is_attaching_via_jni);   \/\/ for main thread and JNI attached threads\n@@ -1245,0 +1231,2 @@\n+  StackOverflow* stack_overflow_state() { return &_stack_overflow_state; }\n+\n@@ -1290,1 +1278,0 @@\n-\n@@ -1576,175 +1563,0 @@\n-  \/\/ Stack overflow support\n-  \/\/\n-  \/\/  (small addresses)\n-  \/\/\n-  \/\/  --  <-- stack_end()                   ---\n-  \/\/  |                                      |\n-  \/\/  |  red pages                           |\n-  \/\/  |                                      |\n-  \/\/  --  <-- stack_red_zone_base()          |\n-  \/\/  |                                      |\n-  \/\/  |                                     guard\n-  \/\/  |  yellow pages                       zone\n-  \/\/  |                                      |\n-  \/\/  |                                      |\n-  \/\/  --  <-- stack_yellow_zone_base()       |\n-  \/\/  |                                      |\n-  \/\/  |                                      |\n-  \/\/  |  reserved pages                      |\n-  \/\/  |                                      |\n-  \/\/  --  <-- stack_reserved_zone_base()    ---      ---\n-  \/\/                                                 \/|\\  shadow     <--  stack_overflow_limit() (somewhere in here)\n-  \/\/                                                  |   zone\n-  \/\/                                                 \\|\/  size\n-  \/\/  some untouched memory                          ---\n-  \/\/\n-  \/\/\n-  \/\/  --\n-  \/\/  |\n-  \/\/  |  shadow zone\n-  \/\/  |\n-  \/\/  --\n-  \/\/  x    frame n\n-  \/\/  --\n-  \/\/  x    frame n-1\n-  \/\/  x\n-  \/\/  --\n-  \/\/  ...\n-  \/\/\n-  \/\/  --\n-  \/\/  x    frame 0\n-  \/\/  --  <-- stack_base()\n-  \/\/\n-  \/\/  (large addresses)\n-  \/\/\n-\n- private:\n-  \/\/ These values are derived from flags StackRedPages, StackYellowPages,\n-  \/\/ StackReservedPages and StackShadowPages. The zone size is determined\n-  \/\/ ergonomically if page_size > 4K.\n-  static size_t _stack_red_zone_size;\n-  static size_t _stack_yellow_zone_size;\n-  static size_t _stack_reserved_zone_size;\n-  static size_t _stack_shadow_zone_size;\n- public:\n-  inline size_t stack_available(address cur_sp);\n-\n-  static size_t stack_red_zone_size() {\n-    assert(_stack_red_zone_size > 0, \"Don't call this before the field is initialized.\");\n-    return _stack_red_zone_size;\n-  }\n-  static void set_stack_red_zone_size(size_t s) {\n-    assert(is_aligned(s, os::vm_page_size()),\n-           \"We can not protect if the red zone size is not page aligned.\");\n-    assert(_stack_red_zone_size == 0, \"This should be called only once.\");\n-    _stack_red_zone_size = s;\n-  }\n-  address stack_red_zone_base() {\n-    return (address)(stack_end() + stack_red_zone_size());\n-  }\n-  bool in_stack_red_zone(address a) {\n-    return a <= stack_red_zone_base() && a >= stack_end();\n-  }\n-\n-  static size_t stack_yellow_zone_size() {\n-    assert(_stack_yellow_zone_size > 0, \"Don't call this before the field is initialized.\");\n-    return _stack_yellow_zone_size;\n-  }\n-  static void set_stack_yellow_zone_size(size_t s) {\n-    assert(is_aligned(s, os::vm_page_size()),\n-           \"We can not protect if the yellow zone size is not page aligned.\");\n-    assert(_stack_yellow_zone_size == 0, \"This should be called only once.\");\n-    _stack_yellow_zone_size = s;\n-  }\n-\n-  static size_t stack_reserved_zone_size() {\n-    \/\/ _stack_reserved_zone_size may be 0. This indicates the feature is off.\n-    return _stack_reserved_zone_size;\n-  }\n-  static void set_stack_reserved_zone_size(size_t s) {\n-    assert(is_aligned(s, os::vm_page_size()),\n-           \"We can not protect if the reserved zone size is not page aligned.\");\n-    assert(_stack_reserved_zone_size == 0, \"This should be called only once.\");\n-    _stack_reserved_zone_size = s;\n-  }\n-  address stack_reserved_zone_base() const {\n-    return (address)(stack_end() +\n-                     (stack_red_zone_size() + stack_yellow_zone_size() + stack_reserved_zone_size()));\n-  }\n-  bool in_stack_reserved_zone(address a) {\n-    return (a <= stack_reserved_zone_base()) &&\n-           (a >= (address)((intptr_t)stack_reserved_zone_base() - stack_reserved_zone_size()));\n-  }\n-\n-  static size_t stack_yellow_reserved_zone_size() {\n-    return _stack_yellow_zone_size + _stack_reserved_zone_size;\n-  }\n-  bool in_stack_yellow_reserved_zone(address a) {\n-    return (a <= stack_reserved_zone_base()) && (a >= stack_red_zone_base());\n-  }\n-\n-  \/\/ Size of red + yellow + reserved zones.\n-  static size_t stack_guard_zone_size() {\n-    return stack_red_zone_size() + stack_yellow_reserved_zone_size();\n-  }\n-\n-  static size_t stack_shadow_zone_size() {\n-    assert(_stack_shadow_zone_size > 0, \"Don't call this before the field is initialized.\");\n-    return _stack_shadow_zone_size;\n-  }\n-  static void set_stack_shadow_zone_size(size_t s) {\n-    \/\/ The shadow area is not allocated or protected, so\n-    \/\/ it needs not be page aligned.\n-    \/\/ But the stack bang currently assumes that it is a\n-    \/\/ multiple of page size. This guarantees that the bang\n-    \/\/ loop touches all pages in the shadow zone.\n-    \/\/ This can be guaranteed differently, as well.  E.g., if\n-    \/\/ the page size is a multiple of 4K, banging in 4K steps\n-    \/\/ suffices to touch all pages. (Some pages are banged\n-    \/\/ several times, though.)\n-    assert(is_aligned(s, os::vm_page_size()),\n-           \"Stack bang assumes multiple of page size.\");\n-    assert(_stack_shadow_zone_size == 0, \"This should be called only once.\");\n-    _stack_shadow_zone_size = s;\n-  }\n-\n-  void create_stack_guard_pages();\n-  void remove_stack_guard_pages();\n-\n-  void enable_stack_reserved_zone();\n-  void disable_stack_reserved_zone();\n-  void enable_stack_yellow_reserved_zone();\n-  void disable_stack_yellow_reserved_zone();\n-  void enable_stack_red_zone();\n-  void disable_stack_red_zone();\n-\n-  inline bool stack_guard_zone_unused();\n-  inline bool stack_yellow_reserved_zone_disabled();\n-  inline bool stack_reserved_zone_disabled();\n-  inline bool stack_guards_enabled();\n-\n-  address reserved_stack_activation() const { return _reserved_stack_activation; }\n-  void set_reserved_stack_activation(address addr) {\n-    assert(_reserved_stack_activation == stack_base()\n-            || _reserved_stack_activation == NULL\n-            || addr == stack_base(), \"Must not be set twice\");\n-    _reserved_stack_activation = addr;\n-  }\n-\n-  \/\/ Attempt to reguard the stack after a stack overflow may have occurred.\n-  \/\/ Returns true if (a) guard pages are not needed on this thread, (b) the\n-  \/\/ pages are already guarded, or (c) the pages were successfully reguarded.\n-  \/\/ Returns false if there is not enough stack space to reguard the pages, in\n-  \/\/ which case the caller should unwind a frame and try again.  The argument\n-  \/\/ should be the caller's (approximate) sp.\n-  bool reguard_stack(address cur_sp);\n-  \/\/ Similar to above but see if current stackpoint is out of the guard area\n-  \/\/ and reguard if possible.\n-  bool reguard_stack(void);\n-\n-  address stack_overflow_limit() { return _stack_overflow_limit; }\n-  void set_stack_overflow_limit() {\n-    _stack_overflow_limit =\n-      stack_end() + MAX2(JavaThread::stack_guard_zone_size(), JavaThread::stack_shadow_zone_size());\n-  }\n-\n@@ -1755,1 +1567,1 @@\n-    return is_in_stack_range_incl(adr, stack_reserved_zone_base());\n+    return is_in_stack_range_incl(adr, _stack_overflow_state.stack_reserved_zone_base());\n@@ -1795,1 +1607,0 @@\n-  static ByteSize stack_overflow_limit_offset()  { return byte_offset_of(JavaThread, _stack_overflow_limit); }\n@@ -1797,2 +1608,12 @@\n-  static ByteSize stack_guard_state_offset()     { return byte_offset_of(JavaThread, _stack_guard_state); }\n-  static ByteSize reserved_stack_activation_offset() { return byte_offset_of(JavaThread, _reserved_stack_activation); }\n+\n+  \/\/ StackOverflow offsets\n+  static ByteSize stack_overflow_limit_offset()  {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._stack_overflow_limit);\n+  }\n+  static ByteSize stack_guard_state_offset()     {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._stack_guard_state);\n+  }\n+  static ByteSize reserved_stack_activation_offset() {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._reserved_stack_activation);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":19,"deletions":198,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,33 +169,0 @@\n-inline bool JavaThread::stack_guard_zone_unused() {\n-  return _stack_guard_state == stack_guard_unused;\n-}\n-\n-inline bool JavaThread::stack_yellow_reserved_zone_disabled() {\n-  return _stack_guard_state == stack_guard_yellow_reserved_disabled;\n-}\n-\n-inline bool JavaThread::stack_reserved_zone_disabled() {\n-  return _stack_guard_state == stack_guard_reserved_disabled;\n-}\n-\n-inline size_t JavaThread::stack_available(address cur_sp) {\n-  \/\/ This code assumes java stacks grow down\n-  address low_addr; \/\/ Limit on the address for deepest stack depth\n-  if (_stack_guard_state == stack_guard_unused) {\n-    low_addr = stack_end();\n-  } else {\n-    low_addr = stack_reserved_zone_base();\n-  }\n-  return cur_sp > low_addr ? cur_sp - low_addr : 0;\n-}\n-\n-inline bool JavaThread::stack_guards_enabled() {\n-#ifdef ASSERT\n-  if (os::uses_stack_guard_pages() &&\n-      !(DisablePrimordialThreadGuardPages && os::is_primordial_thread())) {\n-    assert(_stack_guard_state != stack_guard_unused, \"guard pages must be in use\");\n-  }\n-#endif\n-  return _stack_guard_state == stack_guard_enabled;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":1,"deletions":34,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    public final int javaThreadReservedStackActivationOffset = JDK <= 8 ? 0 : getFieldOffset(\"JavaThread::_reserved_stack_activation\", Integer.class, \"address\"); \/\/ JDK-8046936\n+    public final int javaThreadReservedStackActivationOffset = JDK <= 8 ? 0 : getFieldOffset(\"JavaThread::_stack_overflow_state._reserved_stack_activation\", Integer.class, \"address\"); \/\/ JDK-8046936\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/GraalHotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}