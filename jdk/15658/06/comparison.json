{"files":[{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n@@ -818,0 +820,24 @@\n+    void appendDigit2(int i) {\n+        ensureCapacityInternal(count + 2);\n+        if (isLatin1()) {\n+            ByteArrayLittleEndian.setShort(value, count, DecimalDigits.digitPair(i));\n+        } else {\n+            StringUTF16.putPair(value, count, i);\n+        }\n+        count += 2;\n+    }\n+\n+    void appendDigit3(int i) {\n+        ensureCapacityInternal(count + 3);\n+        int v = DecimalDigits.digitTriple(i);\n+        if (isLatin1()) {\n+            ByteArrayLittleEndian.setShort(value, count, (short) (v >> 8));\n+            value[count + 2] = (byte) (v >> 24);\n+        } else {\n+            StringUTF16.putChar(value, count, (byte) (v >> 8));\n+            StringUTF16.putChar(value, count + 1, (byte) (v >> 16));\n+            StringUTF16.putChar(value, count + 2, (byte) (v >> 24));\n+        }\n+        count += 3;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1615,1 +1615,1 @@\n-    private static void putPair(byte[] buf, int charPos, int v) {\n+    static void putPair(byte[] buf, int charPos, int v) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2547,0 +2547,8 @@\n+            public void appendDigit2(StringBuilder sb, int i) {\n+                sb.appendDigit2(i);\n+            }\n+\n+            public void appendDigit3(StringBuilder sb, int i) {\n+                sb.appendDigit3(i);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -99,0 +101,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -213,0 +218,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -1355,1 +1362,22 @@\n-        return DateTimeFormatter.ISO_INSTANT.format(this);\n+        LocalDate date = LocalDate.ofEpochDay(\n+                Math.floorDiv(seconds, SECONDS_PER_DAY));\n+        LocalTime time = LocalTime.ofSecondOfDay(\n+                Math.floorMod(seconds, SECONDS_PER_DAY));\n+\n+        int yearSize = LocalDate.yearSize(date.getYear());\n+        int nanoSize = LocalTime.nanoSize(nanos);\n+\n+        byte[] buf = new byte[yearSize + 16 + nanoSize];\n+\n+        int off = date.getChars(buf, 0);\n+        buf[off] = 'T';\n+\n+        off = time.getChars(buf, off + 1);\n+        LocalTime.getNanoChars(buf, off, nanos);\n+        buf[off + nanoSize] = 'Z';\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -106,0 +108,5 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -143,0 +150,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -2150,10 +2159,24 @@\n-        int yearValue = year;\n-        int monthValue = month;\n-        int dayValue = day;\n-        int absYear = Math.abs(yearValue);\n-        StringBuilder buf = new StringBuilder(10);\n-        if (absYear < 1000) {\n-            if (yearValue < 0) {\n-                buf.append(yearValue - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(yearValue + 10000).deleteCharAt(0);\n+        byte[] buf = new byte[yearSize(year) + 6];\n+        getChars(buf, 0);\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    static int yearSize(int year) {\n+        if (Math.abs(year) < 1000) {\n+            return year < 0 ? 5 : 4;\n+        }\n+        return DecimalDigits.stringSize(year) + (year > 9999 ? 1 : 0);\n+    }\n+\n+    int getChars(byte[] buf, int off) {\n+        int year = this.year;\n+        int yearSize = yearSize(year);\n+        int yearAbs = Math.abs(year);\n+        if (yearAbs < 1000) {\n+            if (year < 0) {\n+                buf[off] = '-';\n@@ -2161,0 +2184,7 @@\n+            int y01 = yearAbs \/ 100;\n+            int y23 = yearAbs - y01 * 100;\n+\n+            ByteArrayLittleEndian.setInt(\n+                    buf,\n+                    off + (year < 0 ? 1 : 0),\n+                    (DecimalDigits.digitPair(y23) << 16) | DecimalDigits.digitPair(y01));\n@@ -2162,2 +2192,2 @@\n-            if (yearValue > 9999) {\n-                buf.append('+');\n+            if (year > 9999) {\n+                buf[off] = '+';\n@@ -2165,1 +2195,1 @@\n-            buf.append(yearValue);\n+            DecimalDigits.getCharsLatin1(year, off + yearSize, buf);\n@@ -2167,5 +2197,14 @@\n-        return buf.append(monthValue < 10 ? \"-0\" : \"-\")\n-            .append(monthValue)\n-            .append(dayValue < 10 ? \"-0\" : \"-\")\n-            .append(dayValue)\n-            .toString();\n+\n+        off += yearSize;\n+        buf[off] = '-';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 1,\n+                DecimalDigits.digitPair(month)); \/\/ mm\n+        buf[off + 3] = '-';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 4,\n+                DecimalDigits.digitPair(day)); \/\/ dd\n+\n+        return off + 6;\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":57,"deletions":18,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -99,0 +101,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -1968,1 +1972,17 @@\n-        return date.toString() + 'T' + time.toString();\n+        int yearSize = LocalDate.yearSize(date.getYear());\n+        int nano = time.getNano();\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        byte[] buf = new byte[yearSize + 15 + nanoSize];\n+\n+        int off = date.getChars(buf, 0);\n+        buf[off] = 'T';\n+        off = time.getChars(buf, off + 1);\n+        LocalTime.getNanoChars(buf, off, nano);\n+\n+        try {\n+            return SharedSecrets.getJavaLangAccess()\n+                    .newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -95,0 +97,6 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -129,0 +137,5 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n+    @Stable\n+    static final int[] DIGITS_K = new int[1000];\n+\n@@ -159,0 +172,8 @@\n+\n+        for (int i = 0; i < 1000; i++) {\n+            int c0 = i < 10 ? 2 : i < 100 ? 1 : 0;\n+            int c1 = (i \/ 100) + '0';\n+            int c2 = ((i \/ 10) % 10) + '0';\n+            int c3 = i % 10 + '0';\n+            DIGITS_K[i] = c0 + (c1 << 8) + (c2 << 16) + (c3 << 24);\n+        }\n@@ -1632,18 +1653,67 @@\n-        StringBuilder buf = new StringBuilder(18);\n-        int hourValue = hour;\n-        int minuteValue = minute;\n-        int secondValue = second;\n-        int nanoValue = nano;\n-        buf.append(hourValue < 10 ? \"0\" : \"\").append(hourValue)\n-            .append(minuteValue < 10 ? \":0\" : \":\").append(minuteValue);\n-        if (secondValue > 0 || nanoValue > 0) {\n-            buf.append(secondValue < 10 ? \":0\" : \":\").append(secondValue);\n-            if (nanoValue > 0) {\n-                buf.append('.');\n-                if (nanoValue % 1000_000 == 0) {\n-                    buf.append(Integer.toString((nanoValue \/ 1000_000) + 1000).substring(1));\n-                } else if (nanoValue % 1000 == 0) {\n-                    buf.append(Integer.toString((nanoValue \/ 1000) + 1000_000).substring(1));\n-                } else {\n-                    buf.append(Integer.toString((nanoValue) + 1000_000_000).substring(1));\n-                }\n+        int nano = this.nano;\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        byte[] buf = new byte[8 + nanoSize];\n+        getChars(buf, 0);\n+        LocalTime.getNanoChars(buf, 8, nano);\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    static int nanoSize(int nano) {\n+        if (nano == 0) {\n+            return 0;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        if (nano - div * 1000 != 0) {\n+            return 10;\n+        }\n+\n+        return (div - div2 * 1000 == 0) ? 4 : 7;\n+    }\n+\n+    int getChars(byte[] buf, int off) {\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off,\n+                DecimalDigits.digitPair(hour)); \/\/ hh\n+        buf[off + 2] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 3,\n+                DecimalDigits.digitPair(minute)); \/\/ minute\n+        buf[off + 5] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 6,\n+                DecimalDigits.digitPair(second)); \/\/ second\n+        return off + 8;\n+    }\n+\n+    static void getNanoChars(byte[] buf, int off, int nano) {\n+        if (nano == 0) {\n+            return;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+        ByteArrayLittleEndian.setInt(\n+                buf,\n+                off,\n+                DIGITS_K[div2] & 0xffffff00 | '.'\n+        );\n+        off += 4;\n+\n+        int rem1 = nano - div * 1000;\n+        int v;\n+        if (rem1 == 0) {\n+            int rem2 = div - div2 * 1000;\n+            if (rem2 == 0) {\n+                return;\n@@ -1651,0 +1721,21 @@\n+\n+            v = DIGITS_K[rem2];\n+        } else {\n+            v = DIGITS_K[div - div2 * 1000];\n+        }\n+\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off,\n+                (short) (v >> 8)\n+        );\n+        off += 2;\n+\n+        if (rem1 == 0) {\n+            buf[off] = (byte) (v >> 24);\n+        } else {\n+            ByteArrayLittleEndian.setInt(\n+                    buf,\n+                    off,\n+                    DIGITS_K[rem1] & 0xffffff00 | (v >> 24)\n+            );\n@@ -1652,1 +1743,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalTime.java","additions":109,"deletions":19,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -96,0 +98,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -1925,0 +1929,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -1926,1 +1931,20 @@\n-        return dateTime.toString() + offset.toString();\n+        int yearSize = LocalDate.yearSize(dateTime.getYear());\n+        int nano = dateTime.getNano();\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        String offSetId = offset.getId();\n+\n+        byte[] buf = new byte[yearSize + 15 + nanoSize + offSetId.length()];\n+\n+        int off = toLocalDate().getChars(buf, 0);\n+        buf[off] = 'T';\n+        off = toLocalTime().getChars(buf, off + 1);\n+        LocalTime.getNanoChars(buf, off, nano);\n+        offSetId.getBytes(0, offSetId.length(), buf, off + nanoSize);\n+\n+        try {\n+            return SharedSecrets.getJavaLangAccess()\n+                    .newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -95,0 +97,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -121,1 +125,0 @@\n-\n@@ -1400,0 +1403,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -1401,1 +1405,16 @@\n-        return time.toString() + offset.toString();\n+        int nano = time.getNano();\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        String offSetId = offset.getId();\n+        byte[] buf = new byte[8 + nanoSize + offSetId.length()];\n+        time.getChars(buf, 0);\n+\n+        LocalTime.getNanoChars(buf, 8, nano);\n+        offSetId.getBytes(0, offSetId.length(), buf, 8 + nanoSize);\n+\n+        try {\n+            return SharedSecrets.getJavaLangAccess()\n+                    .newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -89,0 +91,4 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n@@ -137,0 +143,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -451,13 +459,31 @@\n-        } else {\n-            int absTotalSeconds = Math.abs(totalSeconds);\n-            StringBuilder buf = new StringBuilder();\n-            int absHours = absTotalSeconds \/ SECONDS_PER_HOUR;\n-            int absMinutes = (absTotalSeconds \/ SECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n-            buf.append(totalSeconds < 0 ? \"-\" : \"+\")\n-                .append(absHours < 10 ? \"0\" : \"\").append(absHours)\n-                .append(absMinutes < 10 ? \":0\" : \":\").append(absMinutes);\n-            int absSeconds = absTotalSeconds % SECONDS_PER_MINUTE;\n-            if (absSeconds != 0) {\n-                buf.append(absSeconds < 10 ? \":0\" : \":\").append(absSeconds);\n-            }\n-            return buf.toString();\n+        }\n+\n+        int absTotalSeconds = Math.abs(totalSeconds);\n+        int absHours = absTotalSeconds \/ SECONDS_PER_HOUR;\n+        int minuteSeconds = absTotalSeconds - absHours * SECONDS_PER_HOUR;\n+        int absMinutes = minuteSeconds \/ SECONDS_PER_MINUTE;\n+        int absSeconds = minuteSeconds - absMinutes * SECONDS_PER_MINUTE;\n+\n+        byte[] buf = new byte[6 + (absSeconds != 0 ? 3 : 0)];\n+        buf[0] = (byte) (totalSeconds < 0 ? '-' : '+');\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                1,\n+                DecimalDigits.digitPair(absHours));\n+        buf[3] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                4,\n+                DecimalDigits.digitPair(absMinutes));\n+        if (absSeconds != 0) {\n+            buf[6] = ':';\n+            ByteArrayLittleEndian.setShort(\n+                    buf,\n+                    7,\n+                    DecimalDigits.digitPair(absSeconds));\n+        }\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -94,0 +96,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -2216,0 +2220,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -2217,1 +2222,26 @@\n-        String str = dateTime.toString() + offset.toString();\n+        int yearSize = LocalDate.yearSize(dateTime.getYear());\n+        int nano = dateTime.getNano();\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        String offSetId = offset.getId();\n+        int offsetIdLenth = offSetId.length();\n+\n+        String zoneStr = null;\n+        int zoneLength = 0;\n+\n+        int offsetLength = offsetIdLenth;\n+        if (offset != zone) {\n+            zoneStr = zone.toString();\n+            zoneLength = zoneStr.length();\n+            offsetLength += zoneLength + 2;\n+        }\n+\n+        byte[] buf = new byte[yearSize + 15 + nanoSize + offsetLength];\n+\n+        int off = toLocalDate().getChars(buf, 0);\n+        buf[off] = 'T';\n+        off = toLocalTime().getChars(buf, off + 1);\n+        LocalTime.getNanoChars(buf, off, nano);\n+        off += nanoSize;\n+        offSetId.getBytes(0, offsetIdLenth, buf, off);\n+\n@@ -2219,1 +2249,11 @@\n-            str += '[' + zone.toString() + ']';\n+            off += offsetIdLenth;\n+            buf[off] = '[';\n+            zoneStr.getBytes(0, zoneLength, buf, off + 1);\n+            buf[off + zoneLength + 1] = ']';\n+        }\n+\n+        try {\n+            return SharedSecrets.getJavaLangAccess()\n+                    .newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n@@ -2221,1 +2261,0 @@\n-        return str;\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+import java.time.OffsetDateTime;\n+import java.time.ZonedDateTime;\n@@ -124,0 +126,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -162,0 +167,22 @@\n+    \/**\n+     * Hours per day.\n+     *\/\n+    static final int HOURS_PER_DAY = 24;\n+    \/**\n+     * Minutes per hour.\n+     *\/\n+    static final int MINUTES_PER_HOUR = 60;\n+    \/**\n+     * Seconds per minute.\n+     *\/\n+    static final int SECONDS_PER_MINUTE = 60;\n+    \/**\n+     * Seconds per hour.\n+     *\/\n+    static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    \/**\n+     * Seconds per day.\n+     *\/\n+    static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n+\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n@@ -2425,1 +2452,14 @@\n-        CompositePrinterParser pp = new CompositePrinterParser(printerParsers, false);\n+\n+        CompositePrinterParser pp = null;\n+\n+        int printerParsersSize = printerParsers.size();\n+        if (DateCompositePrinterParser.accept(printerParsers)) {\n+            pp = new DateCompositePrinterParser(printerParsers, false);\n+        } else if (TimeCompositePrinterParser.accept(printerParsers)) {\n+            pp = new TimeCompositePrinterParser(printerParsers, false);\n+        }\n+\n+        if (pp == null) {\n+            pp = new CompositePrinterParser(printerParsers, false);\n+        }\n+\n@@ -2491,1 +2531,169 @@\n-    \/\/-----------------------------------------------------------------------\n+    static final class DateCompositePrinterParser extends CompositePrinterParser {\n+        private final char literal;\n+        private DateCompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+            super(printerParsers, optional);\n+            literal = ((CharLiteralPrinterParser) printerParsers.get(1)).literal;\n+        }\n+\n+        static boolean accept(List<DateTimePrinterParser> printerParsers) {\n+            int printerParsersSize = printerParsers.size();\n+            if (printerParsersSize != 5) {\n+                return false;\n+            }\n+\n+            if (printerParsers.get(0) instanceof NumberPrinterParser\n+                    && printerParsers.get(1) instanceof CharLiteralPrinterParser\n+                    && printerParsers.get(2) instanceof NumberPrinterParser\n+                    && printerParsers.get(3) instanceof CharLiteralPrinterParser\n+                    && printerParsers.get(4) instanceof NumberPrinterParser\n+            ) {\n+                NumberPrinterParser p0 = (NumberPrinterParser) printerParsers.get(0);\n+                CharLiteralPrinterParser p1 = (CharLiteralPrinterParser) printerParsers.get(1);\n+                NumberPrinterParser p2 = (NumberPrinterParser) printerParsers.get(2);\n+                CharLiteralPrinterParser p3 = (CharLiteralPrinterParser) printerParsers.get(3);\n+                NumberPrinterParser p4 = (NumberPrinterParser) printerParsers.get(4);\n+                if (p0.field == ChronoField.YEAR\n+                        && p1.literal == p3.literal\n+                        && p0.signStyle == SignStyle.EXCEEDS_PAD\n+                        && p0.minWidth == 4\n+                        && p0.maxWidth == 10\n+                        && p0.subsequentWidth == 0\n+                        && p2.field == ChronoField.MONTH_OF_YEAR\n+                        && p2.signStyle == SignStyle.NOT_NEGATIVE\n+                        && p2.minWidth == 2\n+                        && p2.maxWidth == 2\n+                        && p4.subsequentWidth == 0\n+                        && p4.field == ChronoField.DAY_OF_MONTH\n+                        && p4.signStyle == SignStyle.NOT_NEGATIVE\n+                        && p4.minWidth == 2\n+                        && p4.maxWidth == 2\n+                        && p4.subsequentWidth == 0\n+                ) {\n+                    return true;\n+                }\n+            }\n+\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n+            TemporalAccessor temporal = context.getTemporal();\n+\n+            LocalDate date = null;\n+            if (temporal instanceof LocalDateTime) {\n+                date = ((LocalDateTime) temporal).toLocalDate();\n+            } else if (temporal instanceof LocalDate) {\n+                date = (LocalDate) temporal;\n+            } else if (temporal instanceof ZonedDateTime) {\n+                date = ((ZonedDateTime) temporal).toLocalDate();\n+            } else if (temporal instanceof OffsetDateTime) {\n+                date = ((OffsetDateTime) temporal).toLocalDate();\n+            }\n+\n+            if (date != null) {\n+                formatDate(buf, literal, date);\n+                return true;\n+            }\n+\n+            return super.format(context, buf);\n+        }\n+    }\n+\n+    static final class TimeCompositePrinterParser extends CompositePrinterParser {\n+        final char literal;\n+        final int fractionalDigits;\n+        private TimeCompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+            super(printerParsers, optional);\n+            literal = ((CharLiteralPrinterParser) printerParsers.get(1)).literal;\n+            CompositePrinterParser p3 = (CompositePrinterParser) printerParsers.get(3);\n+            CompositePrinterParser s2 = (CompositePrinterParser) p3.printerParsers[2];\n+            NanosPrinterParser n = (NanosPrinterParser) s2.printerParsers[0];\n+            if (n.minWidth == 0 && n.maxWidth == 9) {\n+                fractionalDigits = -2;\n+            } else {\n+                fractionalDigits = n.minWidth;\n+            }\n+        }\n+\n+        static boolean accept(List<DateTimePrinterParser> printerParsers) {\n+            if (printerParsers.size() != 4) {\n+                return false;\n+            }\n+\n+            if (printerParsers.get(0) instanceof NumberPrinterParser\n+                    && printerParsers.get(1) instanceof CharLiteralPrinterParser\n+                    && printerParsers.get(2) instanceof NumberPrinterParser\n+                    && printerParsers.get(3) instanceof CompositePrinterParser\n+            ) {\n+                NumberPrinterParser p0 = (NumberPrinterParser) printerParsers.get(0);\n+                CharLiteralPrinterParser p1 = (CharLiteralPrinterParser) printerParsers.get(1);\n+                NumberPrinterParser p2 = (NumberPrinterParser) printerParsers.get(2);\n+                CompositePrinterParser p3 = (CompositePrinterParser) printerParsers.get(3);\n+\n+                if (p0.field == ChronoField.HOUR_OF_DAY\n+                        && p0.signStyle == SignStyle.NOT_NEGATIVE\n+                        && p0.minWidth == 2\n+                        && p0.maxWidth == 2\n+                        && p0.subsequentWidth == 0\n+                        && p2.field == ChronoField.MINUTE_OF_HOUR\n+                        && p2.signStyle == SignStyle.NOT_NEGATIVE\n+                        && p2.minWidth == 2\n+                        && p2.maxWidth == 2\n+                        && p2.subsequentWidth == 0\n+                        && p3.printerParsers.length == 3\n+                        && p3.printerParsers[0] instanceof CharLiteralPrinterParser\n+                        && p3.printerParsers[1] instanceof NumberPrinterParser\n+                        && p3.printerParsers[2] instanceof CompositePrinterParser\n+                ) {\n+                    CharLiteralPrinterParser s0 = (CharLiteralPrinterParser) p3.printerParsers[0];\n+                    NumberPrinterParser s1 = (NumberPrinterParser) p3.printerParsers[1];\n+                    CompositePrinterParser s2 = (CompositePrinterParser) p3.printerParsers[2];\n+                    if (s1.field == ChronoField.SECOND_OF_MINUTE\n+                            && s0.literal == p1.literal\n+                            && s1.minWidth == 2\n+                            && s1.maxWidth == 2\n+                            && s1.subsequentWidth == 0\n+                            && s2.printerParsers.length == 1\n+                            && s2.printerParsers[0] instanceof NanosPrinterParser\n+                    ) {\n+                        NanosPrinterParser n = (NanosPrinterParser) s2.printerParsers[0];\n+                        if (n.decimalPoint\n+                                && n.field == ChronoField.NANO_OF_SECOND\n+                                && n.signStyle == SignStyle.NOT_NEGATIVE\n+                                && n.subsequentWidth == 0\n+                                && ((n.minWidth == 0 && n.maxWidth == 9) || n.minWidth == n.maxWidth)\n+                        ) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n+            TemporalAccessor temporal = context.getTemporal();\n+\n+            LocalTime time = null;\n+            if (temporal instanceof LocalDateTime) {\n+                time = ((LocalDateTime) temporal).toLocalTime();\n+            } else if (temporal instanceof LocalTime) {\n+                time = (LocalTime) temporal;\n+            } else if (temporal instanceof ZonedDateTime) {\n+                time = ((ZonedDateTime) temporal).toLocalTime();\n+            } else if (temporal instanceof OffsetDateTime) {\n+                time = ((OffsetDateTime) temporal).toLocalTime();\n+            }\n+\n+            if (time != null) {\n+                formatTime(buf, -2, time);\n+                return true;\n+            }\n+\n+            return super.format(context, buf);\n+        }\n+    }\n+        \/\/-----------------------------------------------------------------------\n@@ -2495,1 +2703,1 @@\n-    static final class CompositePrinterParser implements DateTimePrinterParser {\n+    static class CompositePrinterParser implements DateTimePrinterParser {\n@@ -2499,1 +2707,1 @@\n-        private CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+        CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n@@ -2833,1 +3041,1 @@\n-        private final SignStyle signStyle;\n+        final SignStyle signStyle;\n@@ -3279,1 +3487,1 @@\n-        private final boolean decimalPoint;\n+        final boolean decimalPoint;\n@@ -3796,0 +4004,123 @@\n+    static void formatDate(StringBuilder buf, char literal, LocalDate date) {\n+        int year = date.getYear();\n+        int yearAbs = Math.abs(year);\n+        if (yearAbs < 1000) {\n+            if (year < 0) {\n+                buf.append('-');\n+            }\n+            int y01 = yearAbs \/ 100;\n+            int y23 = yearAbs - y01 * 100;\n+\n+            jla.appendDigit2(buf, y01);\n+            jla.appendDigit2(buf, y23);\n+        } else {\n+            if (year > 9999) {\n+                buf.append('+');\n+            }\n+\n+            buf.append(year);\n+        }\n+        buf.append(literal);\n+        jla.appendDigit2(buf, date.getMonthValue());\n+        buf.append(literal);\n+        jla.appendDigit2(buf, date.getDayOfMonth());\n+    }\n+\n+    static void formatTime(StringBuilder buf, int fractionalDigits, LocalTime time) {\n+        jla.appendDigit2(buf, time.getHour());\n+        buf.append(':');\n+        jla.appendDigit2(buf, time.getMinute());\n+        buf.append(':');\n+        jla.appendDigit2(buf, time.getSecond());\n+\n+        int nano = time.getNano();\n+        if (fractionalDigits < 0) {\n+            formatNano(buf, nano);\n+        } else {\n+            formatNano(buf, fractionalDigits, nano);\n+        }\n+    }\n+\n+    static void formatNano(StringBuilder buf, int nano) {\n+        if (nano == 0) {\n+            return;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        buf.append('.');\n+        jla.appendDigit3(buf, div2);\n+\n+        int rem1 = nano - div * 1000;\n+        int rem2 = div - div2 * 1000;\n+\n+        if (rem1 == 0 && rem2 == 0) {\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem2);\n+        if (rem1 == 0) {\n+            return;\n+        }\n+        jla.appendDigit3(buf, rem1);\n+    }\n+\n+    static void formatNano(StringBuilder buf, int fractionalDigits, int nano) {\n+        if (fractionalDigits == 0) {\n+            return;\n+        }\n+\n+        buf.append('.');\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        if (fractionalDigits == 1) {\n+            buf.append((char) ('0' + (div2 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 2) {\n+            jla.appendDigit2(buf, div2 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, div2);\n+\n+        if (fractionalDigits == 3) {\n+            return;\n+        }\n+\n+        int rem1 = nano - div * 1000;\n+        int rem2 = div - div2 * 1000;\n+\n+        if (fractionalDigits == 4) {\n+            buf.append((char) ('0' + (rem2 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 5) {\n+            jla.appendDigit2(buf, rem2 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem2);\n+\n+        if (fractionalDigits == 6) {\n+            return;\n+        }\n+\n+        if (fractionalDigits == 7) {\n+            buf.append((char) ('0' + (rem1 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 8) {\n+            jla.appendDigit2(buf, rem1 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem1);\n+    }\n+\n@@ -3814,59 +4145,15 @@\n-            \/\/ use INSTANT_SECONDS, thus this code is not bound by Instant.MAX\n-            Long inSecs = context.getValue(INSTANT_SECONDS);\n-            Long inNanos = null;\n-            if (context.getTemporal().isSupported(NANO_OF_SECOND)) {\n-                inNanos = context.getTemporal().getLong(NANO_OF_SECOND);\n-            }\n-            if (inSecs == null) {\n-                return false;\n-            }\n-            long inSec = inSecs;\n-            int inNano = NANO_OF_SECOND.checkValidIntValue(inNanos != null ? inNanos : 0);\n-            \/\/ format mostly using LocalDateTime.toString\n-            if (inSec >= -SECONDS_0000_TO_1970) {\n-                \/\/ current era\n-                long zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n-                long hi = Math.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n-                long lo = Math.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n-                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n-                if (hi > 0) {\n-                    buf.append('+').append(hi);\n-                }\n-                buf.append(ldt);\n-                if (ldt.getSecond() == 0) {\n-                    buf.append(\":00\");\n-                }\n-            } else {\n-                \/\/ before current era\n-                long zeroSecs = inSec + SECONDS_0000_TO_1970;\n-                long hi = zeroSecs \/ SECONDS_PER_10000_YEARS;\n-                long lo = zeroSecs % SECONDS_PER_10000_YEARS;\n-                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n-                int pos = buf.length();\n-                buf.append(ldt);\n-                if (ldt.getSecond() == 0) {\n-                    buf.append(\":00\");\n-                }\n-                if (hi < 0) {\n-                    if (ldt.getYear() == -10_000) {\n-                        buf.replace(pos, pos + 2, Long.toString(hi - 1));\n-                    } else if (lo == 0) {\n-                        buf.insert(pos, hi);\n-                    } else {\n-                        buf.insert(pos + 1, Math.abs(hi));\n-                    }\n-                }\n-            }\n-            \/\/ add fraction\n-            if ((fractionalDigits < 0 && inNano > 0) || fractionalDigits > 0) {\n-                buf.append('.');\n-                int div = 100_000_000;\n-                for (int i = 0; ((fractionalDigits == -1 && inNano > 0) ||\n-                                    (fractionalDigits == -2 && (inNano > 0 || (i % 3) != 0)) ||\n-                                    i < fractionalDigits); i++) {\n-                    int digit = inNano \/ div;\n-                    buf.append((char) (digit + '0'));\n-                    inNano = inNano - (digit * div);\n-                    div = div \/ 10;\n-                }\n-            }\n+            Instant instant = (Instant) context.getTemporal();\n+            long seconds = instant.getEpochSecond();\n+            int nano = instant.getNano();\n+\n+            LocalDate date = LocalDate.ofEpochDay(\n+                    Math.floorDiv(seconds, SECONDS_PER_DAY));\n+\n+            formatDate(buf, '-', date);\n+            buf.append('T');\n+\n+            LocalTime time = LocalTime.ofSecondOfDay(\n+                    Math.floorMod(seconds, SECONDS_PER_DAY));\n+\n+            formatTime(buf, fractionalDigits, time);\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":352,"deletions":65,"binary":false,"changes":417,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -33,0 +35,4 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n@@ -131,0 +137,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -1028,0 +1036,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -1031,1 +1040,10 @@\n-        StringBuilder sb = new StringBuilder(28);\n+\n+        int year = date.getYear();\n+        int yearSize = year >= 1000 && year <= 9999 ? 4 : DecimalDigits.stringSize(year);\n+\n+        TimeZone zi = date.getZone();\n+        String shortName = zi != null ? zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US) : \"GMT\";\n+        int shortNameLength = shortName.length();\n+\n+        byte[] buf = new byte[21 + yearSize + shortNameLength];\n+\n@@ -1036,3 +1054,24 @@\n-        convertToAbbr(sb, wtb[index]).append(' ');                        \/\/ EEE\n-        convertToAbbr(sb, wtb[date.getMonth() - 1 + 2 + 7]).append(' ');  \/\/ MMM\n-        CalendarUtils.sprintf0d(sb, date.getDayOfMonth(), 2).append(' '); \/\/ dd\n+        convertToAbbr(buf, 0, wtb[index]); \/\/ EEE\n+        buf[3] = ' ';\n+        convertToAbbr(buf, 4, wtb[date.getMonth() - 1 + 2 + 7]); \/\/ MMM\n+        buf[7] = ' ';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                8,\n+                DecimalDigits.digitPair(date.getDayOfMonth())); \/\/ dd\n+        buf[10] = ' ';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                11,\n+                DecimalDigits.digitPair(date.getHours())); \/\/ HH\n+        buf[13] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                14,\n+                DecimalDigits.digitPair(date.getMinutes())); \/\/ mm\n+        buf[16] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                17,\n+                DecimalDigits.digitPair(date.getSeconds())); \/\/ ss\n+        buf[19] = ' ';\n@@ -1040,8 +1079,8 @@\n-        CalendarUtils.sprintf0d(sb, date.getHours(), 2).append(':');   \/\/ HH\n-        CalendarUtils.sprintf0d(sb, date.getMinutes(), 2).append(':'); \/\/ mm\n-        CalendarUtils.sprintf0d(sb, date.getSeconds(), 2).append(' '); \/\/ ss\n-        TimeZone zi = date.getZone();\n-        if (zi != null) {\n-            sb.append(zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US)); \/\/ zzz\n-        } else {\n-            sb.append(\"GMT\");\n+        shortName.getBytes(0, shortNameLength, buf, 20);\n+        buf[20 + shortNameLength] = ' ';\n+\n+        DecimalDigits.getCharsLatin1(year, buf.length, buf);\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n@@ -1049,2 +1088,0 @@\n-        sb.append(' ').append(date.getYear());  \/\/ yyyy\n-        return sb.toString();\n@@ -1055,2 +1092,1 @@\n-     * \"monday\" -> \"Mon\") and stored the abbreviation in the given\n-     * {@code StringBuilder}.\n+     * \"monday\" -> \"Mon\") and stored the abbreviation in the given buf\n@@ -1058,4 +1094,4 @@\n-    private static final StringBuilder convertToAbbr(StringBuilder sb, String name) {\n-        sb.append(Character.toUpperCase(name.charAt(0)));\n-        sb.append(name.charAt(1)).append(name.charAt(2));\n-        return sb;\n+    private static final void convertToAbbr(byte[] buf, int off, String name) {\n+        buf[off] = (byte) (name.charAt(0) - 32);\n+        buf[off + 1] = (byte) name.charAt(1);\n+        buf[off + 2] = (byte) name.charAt(2);\n@@ -1121,1 +1157,0 @@\n-        BaseCalendar cal = getCalendarSystem(t);\n@@ -1123,10 +1158,49 @@\n-            (BaseCalendar.Date) cal.getCalendarDate(getTime(), (TimeZone)null);\n-        StringBuilder sb = new StringBuilder(32);\n-        CalendarUtils.sprintf0d(sb, date.getDayOfMonth(), 1).append(' '); \/\/ d\n-        convertToAbbr(sb, wtb[date.getMonth() - 1 + 2 + 7]).append(' ');  \/\/ MMM\n-        sb.append(date.getYear()).append(' ');                            \/\/ yyyy\n-        CalendarUtils.sprintf0d(sb, date.getHours(), 2).append(':');      \/\/ HH\n-        CalendarUtils.sprintf0d(sb, date.getMinutes(), 2).append(':');    \/\/ mm\n-        CalendarUtils.sprintf0d(sb, date.getSeconds(), 2);                \/\/ ss\n-        sb.append(\" GMT\");                                                \/\/ ' GMT'\n-        return sb.toString();\n+                (BaseCalendar.Date) getCalendarSystem(t)\n+                        .getCalendarDate(getTime(), (TimeZone)null);\n+\n+        int year = date.getYear();\n+        int yearSize = year >= 1000 && year <= 9999 ? 4 : DecimalDigits.stringSize(year);\n+        int dayOfMonth = date.getDayOfMonth();\n+\n+        byte[] buf = new byte[(dayOfMonth < 10 ? 19 : 20) + yearSize];\n+        int off;\n+        if (dayOfMonth < 10) {\n+            buf[0] = (byte) ('0' + dayOfMonth);\n+            off = 1;\n+        } else {\n+            ByteArrayLittleEndian.setShort(\n+                    buf,\n+                    0,\n+                    DecimalDigits.digitPair(dayOfMonth)); \/\/ dd\n+            off = 2;\n+        }\n+        buf[off++] = ' ';\n+        convertToAbbr(buf, off, wtb[date.getMonth() + 8]); \/\/ EEE\n+        buf[off + 3] = ' ';\n+        DecimalDigits.getCharsLatin1(year, off + yearSize + 4, buf);\n+        off += yearSize + 4;\n+        buf[off++] = ' ';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off,\n+                DecimalDigits.digitPair(date.getHours())); \/\/ HH\n+        buf[off + 2] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 3,\n+                DecimalDigits.digitPair(date.getMinutes())); \/\/ mm\n+        buf[off + 5] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 6,\n+                DecimalDigits.digitPair(date.getSeconds())); \/\/ mm\n+        buf[off + 8] = ' ';\n+        buf[off + 9] = 'G';\n+        buf[off + 10] = 'M';\n+        buf[off + 11] = 'T';\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Date.java","additions":105,"deletions":31,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -437,0 +437,4 @@\n+   void appendDigit2(StringBuilder sb, int i);\n+\n+   void appendDigit3(StringBuilder sb, int i);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,0 +73,15 @@\n+    @Stable\n+    private static final int[] DIGITS_K;\n+\n+    static {\n+        int[] digits_k = new int[1000];\n+        for (int i = 0; i < 1000; i++) {\n+            int c0 = i < 10 ? 2 : i < 100 ? 1 : 0;\n+            int c1 = (i \/ 100) + '0';\n+            int c2 = ((i \/ 10) % 10) + '0';\n+            int c3 = i % 10 + '0';\n+            digits_k[i] = c0 + (c1 << 8) + (c2 << 16) + (c3 << 24);\n+        }\n+        DIGITS_K = digits_k;\n+    }\n+\n@@ -160,0 +175,85 @@\n+\n+    \/**\n+     * For values from 0 to 999 return a short encoding a triple of ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @return a short encoding a triple of ASCII-encoded digit characters\n+     *\/\n+    public static int digitTriple(int i) {\n+        return DIGITS_K[i];\n+    }\n+\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(int x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        int p = -10;\n+        for (int i = 1; i < 10; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 10 + d;\n+    }\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n+\n+        boolean negative = i < 0;\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Generate two digits per iteration\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[r]);\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[-i]);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i);\n+        }\n+\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n+        }\n+        return charPos;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.time;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class ToStringBench {\n+    private static final Instant[] INSTANTS;\n+    private static final ZonedDateTime[] ZONED_DATE_TIMES;\n+    private static final LocalDateTime[] LOCAL_DATE_TIMES;\n+    private static final LocalDate[] LOCAL_DATES;\n+    private static final LocalTime[] LOCAL_TIMES;\n+\n+    static {\n+        Instant loInstant = Instant.EPOCH.plus(Duration.ofDays(365*50)); \/\/ 2020-01-01\n+        Instant hiInstant = loInstant.plus(Duration.ofDays(1));\n+        long maxOffsetNanos = Duration.between(loInstant, hiInstant).toNanos();\n+        Random random = new Random(0);\n+        INSTANTS = IntStream\n+                .range(0, 1_000)\n+                .mapToObj(ignored -> {\n+                    final long offsetNanos = (long) Math.floor(random.nextDouble() * maxOffsetNanos);\n+                    return loInstant.plus(offsetNanos, ChronoUnit.NANOS);\n+                })\n+                .toArray(Instant[]::new);\n+\n+        ZONED_DATE_TIMES = Stream.of(INSTANTS)\n+                .map(instant -> ZonedDateTime.ofInstant(instant, ZoneOffset.UTC))\n+                .toArray(ZonedDateTime[]::new);\n+\n+        LOCAL_DATE_TIMES = Stream.of(ZONED_DATE_TIMES)\n+                .map(zdt -> zdt.toLocalDateTime())\n+                .toArray(LocalDateTime[]::new);\n+\n+        LOCAL_DATES = Stream.of(LOCAL_DATE_TIMES)\n+                .map(ldt -> ldt.toLocalDate())\n+                .toArray(LocalDate[]::new);\n+\n+        LOCAL_TIMES = Stream.of(LOCAL_DATE_TIMES)\n+                .map(ldt -> ldt.toLocalTime())\n+                .toArray(LocalTime[]::new);\n+    }\n+\n+    @Benchmark\n+    public void testZonedDateTimeToString(Blackhole bh) {\n+        for (final ZonedDateTime zonedDateTime : ZONED_DATE_TIMES) {\n+            bh.consume(zonedDateTime.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLocalDateTimeToString(Blackhole bh) {\n+        for (LocalDateTime localDateTime : LOCAL_DATE_TIMES) {\n+            bh.consume(localDateTime.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLocalDateToString(Blackhole bh) {\n+        for (LocalDate localDate : LOCAL_DATES) {\n+            bh.consume(localDate.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLocalTimeToString(Blackhole bh) {\n+        for (LocalTime localTime : LOCAL_TIMES) {\n+            bh.consume(localTime.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInstantToString(Blackhole bh) {\n+        for (Instant instant : INSTANTS) {\n+            bh.consume(instant.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testZoneOffsetOffHours(Blackhole bh) {\n+        for (int hour = 0; hour < 12; hour++) {\n+            for (int minute = 0; minute < 60; minute += 15) {\n+                for (int second = 0; second < 60; second += 15) {\n+                    bh.consume(ZoneOffset.ofHoursMinutesSeconds(hour, minute, second));\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/ToStringBench.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"}]}