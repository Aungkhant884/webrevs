{"files":[{"patch":"@@ -38,2 +38,0 @@\n-import jdk.internal.util.ByteArrayLittleEndian;\n-import jdk.internal.util.DecimalDigits;\n@@ -820,24 +818,0 @@\n-    void appendDigit2(int i) {\n-        ensureCapacityInternal(count + 2);\n-        if (isLatin1()) {\n-            ByteArrayLittleEndian.setShort(value, count, DecimalDigits.digitPair(i));\n-        } else {\n-            StringUTF16.putPair(value, count, i);\n-        }\n-        count += 2;\n-    }\n-\n-    void appendDigit3(int i) {\n-        ensureCapacityInternal(count + 3);\n-        int v = DecimalDigits.digitTriple(i);\n-        if (isLatin1()) {\n-            ByteArrayLittleEndian.setShort(value, count, (short) (v >> 8));\n-            value[count + 2] = (byte) (v >> 24);\n-        } else {\n-            StringUTF16.putChar(value, count, (byte) (v >> 8));\n-            StringUTF16.putChar(value, count + 1, (byte) (v >> 16));\n-            StringUTF16.putChar(value, count + 2, (byte) (v >> 24));\n-        }\n-        count += 3;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1615,1 +1615,1 @@\n-    static void putPair(byte[] buf, int charPos, int v) {\n+    private static void putPair(byte[] buf, int charPos, int v) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2547,8 +2547,0 @@\n-            public void appendDigit2(StringBuilder sb, int i) {\n-                sb.appendDigit2(i);\n-            }\n-\n-            public void appendDigit3(StringBuilder sb, int i) {\n-                sb.appendDigit3(i);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,2 +85,0 @@\n-import java.time.OffsetDateTime;\n-import java.time.ZonedDateTime;\n@@ -126,3 +124,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n@@ -167,22 +162,0 @@\n-    \/**\n-     * Hours per day.\n-     *\/\n-    static final int HOURS_PER_DAY = 24;\n-    \/**\n-     * Minutes per hour.\n-     *\/\n-    static final int MINUTES_PER_HOUR = 60;\n-    \/**\n-     * Seconds per minute.\n-     *\/\n-    static final int SECONDS_PER_MINUTE = 60;\n-    \/**\n-     * Seconds per hour.\n-     *\/\n-    static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n-    \/**\n-     * Seconds per day.\n-     *\/\n-    static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n-\n-    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n@@ -2452,14 +2425,1 @@\n-\n-        CompositePrinterParser pp = null;\n-\n-        int printerParsersSize = printerParsers.size();\n-        if (DateCompositePrinterParser.accept(printerParsers)) {\n-            pp = new DateCompositePrinterParser(printerParsers, false);\n-        } else if (TimeCompositePrinterParser.accept(printerParsers)) {\n-            pp = new TimeCompositePrinterParser(printerParsers, false);\n-        }\n-\n-        if (pp == null) {\n-            pp = new CompositePrinterParser(printerParsers, false);\n-        }\n-\n+        CompositePrinterParser pp = new CompositePrinterParser(printerParsers, false);\n@@ -2531,169 +2491,1 @@\n-    static final class DateCompositePrinterParser extends CompositePrinterParser {\n-        private final char literal;\n-        private DateCompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n-            super(printerParsers, optional);\n-            literal = ((CharLiteralPrinterParser) printerParsers.get(1)).literal;\n-        }\n-\n-        static boolean accept(List<DateTimePrinterParser> printerParsers) {\n-            int printerParsersSize = printerParsers.size();\n-            if (printerParsersSize != 5) {\n-                return false;\n-            }\n-\n-            if (printerParsers.get(0) instanceof NumberPrinterParser\n-                    && printerParsers.get(1) instanceof CharLiteralPrinterParser\n-                    && printerParsers.get(2) instanceof NumberPrinterParser\n-                    && printerParsers.get(3) instanceof CharLiteralPrinterParser\n-                    && printerParsers.get(4) instanceof NumberPrinterParser\n-            ) {\n-                NumberPrinterParser p0 = (NumberPrinterParser) printerParsers.get(0);\n-                CharLiteralPrinterParser p1 = (CharLiteralPrinterParser) printerParsers.get(1);\n-                NumberPrinterParser p2 = (NumberPrinterParser) printerParsers.get(2);\n-                CharLiteralPrinterParser p3 = (CharLiteralPrinterParser) printerParsers.get(3);\n-                NumberPrinterParser p4 = (NumberPrinterParser) printerParsers.get(4);\n-                if (p0.field == ChronoField.YEAR\n-                        && p1.literal == p3.literal\n-                        && p0.signStyle == SignStyle.EXCEEDS_PAD\n-                        && p0.minWidth == 4\n-                        && p0.maxWidth == 10\n-                        && p0.subsequentWidth == 0\n-                        && p2.field == ChronoField.MONTH_OF_YEAR\n-                        && p2.signStyle == SignStyle.NOT_NEGATIVE\n-                        && p2.minWidth == 2\n-                        && p2.maxWidth == 2\n-                        && p4.subsequentWidth == 0\n-                        && p4.field == ChronoField.DAY_OF_MONTH\n-                        && p4.signStyle == SignStyle.NOT_NEGATIVE\n-                        && p4.minWidth == 2\n-                        && p4.maxWidth == 2\n-                        && p4.subsequentWidth == 0\n-                ) {\n-                    return true;\n-                }\n-            }\n-\n-\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n-            TemporalAccessor temporal = context.getTemporal();\n-\n-            LocalDate date = null;\n-            if (temporal instanceof LocalDateTime) {\n-                date = ((LocalDateTime) temporal).toLocalDate();\n-            } else if (temporal instanceof LocalDate) {\n-                date = (LocalDate) temporal;\n-            } else if (temporal instanceof ZonedDateTime) {\n-                date = ((ZonedDateTime) temporal).toLocalDate();\n-            } else if (temporal instanceof OffsetDateTime) {\n-                date = ((OffsetDateTime) temporal).toLocalDate();\n-            }\n-\n-            if (date != null) {\n-                formatDate(buf, literal, date);\n-                return true;\n-            }\n-\n-            return super.format(context, buf);\n-        }\n-    }\n-\n-    static final class TimeCompositePrinterParser extends CompositePrinterParser {\n-        final char literal;\n-        final int fractionalDigits;\n-        private TimeCompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n-            super(printerParsers, optional);\n-            literal = ((CharLiteralPrinterParser) printerParsers.get(1)).literal;\n-            CompositePrinterParser p3 = (CompositePrinterParser) printerParsers.get(3);\n-            CompositePrinterParser s2 = (CompositePrinterParser) p3.printerParsers[2];\n-            NanosPrinterParser n = (NanosPrinterParser) s2.printerParsers[0];\n-            if (n.minWidth == 0 && n.maxWidth == 9) {\n-                fractionalDigits = -2;\n-            } else {\n-                fractionalDigits = n.minWidth;\n-            }\n-        }\n-\n-        static boolean accept(List<DateTimePrinterParser> printerParsers) {\n-            if (printerParsers.size() != 4) {\n-                return false;\n-            }\n-\n-            if (printerParsers.get(0) instanceof NumberPrinterParser\n-                    && printerParsers.get(1) instanceof CharLiteralPrinterParser\n-                    && printerParsers.get(2) instanceof NumberPrinterParser\n-                    && printerParsers.get(3) instanceof CompositePrinterParser\n-            ) {\n-                NumberPrinterParser p0 = (NumberPrinterParser) printerParsers.get(0);\n-                CharLiteralPrinterParser p1 = (CharLiteralPrinterParser) printerParsers.get(1);\n-                NumberPrinterParser p2 = (NumberPrinterParser) printerParsers.get(2);\n-                CompositePrinterParser p3 = (CompositePrinterParser) printerParsers.get(3);\n-\n-                if (p0.field == ChronoField.HOUR_OF_DAY\n-                        && p0.signStyle == SignStyle.NOT_NEGATIVE\n-                        && p0.minWidth == 2\n-                        && p0.maxWidth == 2\n-                        && p0.subsequentWidth == 0\n-                        && p2.field == ChronoField.MINUTE_OF_HOUR\n-                        && p2.signStyle == SignStyle.NOT_NEGATIVE\n-                        && p2.minWidth == 2\n-                        && p2.maxWidth == 2\n-                        && p2.subsequentWidth == 0\n-                        && p3.printerParsers.length == 3\n-                        && p3.printerParsers[0] instanceof CharLiteralPrinterParser\n-                        && p3.printerParsers[1] instanceof NumberPrinterParser\n-                        && p3.printerParsers[2] instanceof CompositePrinterParser\n-                ) {\n-                    CharLiteralPrinterParser s0 = (CharLiteralPrinterParser) p3.printerParsers[0];\n-                    NumberPrinterParser s1 = (NumberPrinterParser) p3.printerParsers[1];\n-                    CompositePrinterParser s2 = (CompositePrinterParser) p3.printerParsers[2];\n-                    if (s1.field == ChronoField.SECOND_OF_MINUTE\n-                            && s0.literal == p1.literal\n-                            && s1.minWidth == 2\n-                            && s1.maxWidth == 2\n-                            && s1.subsequentWidth == 0\n-                            && s2.printerParsers.length == 1\n-                            && s2.printerParsers[0] instanceof NanosPrinterParser\n-                    ) {\n-                        NanosPrinterParser n = (NanosPrinterParser) s2.printerParsers[0];\n-                        if (n.decimalPoint\n-                                && n.field == ChronoField.NANO_OF_SECOND\n-                                && n.signStyle == SignStyle.NOT_NEGATIVE\n-                                && n.subsequentWidth == 0\n-                                && ((n.minWidth == 0 && n.maxWidth == 9) || n.minWidth == n.maxWidth)\n-                        ) {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n-            TemporalAccessor temporal = context.getTemporal();\n-\n-            LocalTime time = null;\n-            if (temporal instanceof LocalDateTime) {\n-                time = ((LocalDateTime) temporal).toLocalTime();\n-            } else if (temporal instanceof LocalTime) {\n-                time = (LocalTime) temporal;\n-            } else if (temporal instanceof ZonedDateTime) {\n-                time = ((ZonedDateTime) temporal).toLocalTime();\n-            } else if (temporal instanceof OffsetDateTime) {\n-                time = ((OffsetDateTime) temporal).toLocalTime();\n-            }\n-\n-            if (time != null) {\n-                formatTime(buf, -2, time);\n-                return true;\n-            }\n-\n-            return super.format(context, buf);\n-        }\n-    }\n-        \/\/-----------------------------------------------------------------------\n+    \/\/-----------------------------------------------------------------------\n@@ -2703,1 +2495,1 @@\n-    static class CompositePrinterParser implements DateTimePrinterParser {\n+    static final class CompositePrinterParser implements DateTimePrinterParser {\n@@ -2707,1 +2499,1 @@\n-        CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+        private CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n@@ -3041,1 +2833,1 @@\n-        final SignStyle signStyle;\n+        private final SignStyle signStyle;\n@@ -3487,1 +3279,1 @@\n-        final boolean decimalPoint;\n+        private final boolean decimalPoint;\n@@ -4004,123 +3796,0 @@\n-    static void formatDate(StringBuilder buf, char literal, LocalDate date) {\n-        int year = date.getYear();\n-        int yearAbs = Math.abs(year);\n-        if (yearAbs < 1000) {\n-            if (year < 0) {\n-                buf.append('-');\n-            }\n-            int y01 = yearAbs \/ 100;\n-            int y23 = yearAbs - y01 * 100;\n-\n-            jla.appendDigit2(buf, y01);\n-            jla.appendDigit2(buf, y23);\n-        } else {\n-            if (year > 9999) {\n-                buf.append('+');\n-            }\n-\n-            buf.append(year);\n-        }\n-        buf.append(literal);\n-        jla.appendDigit2(buf, date.getMonthValue());\n-        buf.append(literal);\n-        jla.appendDigit2(buf, date.getDayOfMonth());\n-    }\n-\n-    static void formatTime(StringBuilder buf, int fractionalDigits, LocalTime time) {\n-        jla.appendDigit2(buf, time.getHour());\n-        buf.append(':');\n-        jla.appendDigit2(buf, time.getMinute());\n-        buf.append(':');\n-        jla.appendDigit2(buf, time.getSecond());\n-\n-        int nano = time.getNano();\n-        if (fractionalDigits < 0) {\n-            formatNano(buf, nano);\n-        } else {\n-            formatNano(buf, fractionalDigits, nano);\n-        }\n-    }\n-\n-    static void formatNano(StringBuilder buf, int nano) {\n-        if (nano == 0) {\n-            return;\n-        }\n-\n-        int div = nano \/ 1000;\n-        int div2 = div \/ 1000;\n-\n-        buf.append('.');\n-        jla.appendDigit3(buf, div2);\n-\n-        int rem1 = nano - div * 1000;\n-        int rem2 = div - div2 * 1000;\n-\n-        if (rem1 == 0 && rem2 == 0) {\n-            return;\n-        }\n-\n-        jla.appendDigit3(buf, rem2);\n-        if (rem1 == 0) {\n-            return;\n-        }\n-        jla.appendDigit3(buf, rem1);\n-    }\n-\n-    static void formatNano(StringBuilder buf, int fractionalDigits, int nano) {\n-        if (fractionalDigits == 0) {\n-            return;\n-        }\n-\n-        buf.append('.');\n-\n-        int div = nano \/ 1000;\n-        int div2 = div \/ 1000;\n-\n-        if (fractionalDigits == 1) {\n-            buf.append((char) ('0' + (div2 \/ 100)));\n-            return;\n-        }\n-\n-        if (fractionalDigits == 2) {\n-            jla.appendDigit2(buf, div2 \/ 10);\n-            return;\n-        }\n-\n-        jla.appendDigit3(buf, div2);\n-\n-        if (fractionalDigits == 3) {\n-            return;\n-        }\n-\n-        int rem1 = nano - div * 1000;\n-        int rem2 = div - div2 * 1000;\n-\n-        if (fractionalDigits == 4) {\n-            buf.append((char) ('0' + (rem2 \/ 100)));\n-            return;\n-        }\n-\n-        if (fractionalDigits == 5) {\n-            jla.appendDigit2(buf, rem2 \/ 10);\n-            return;\n-        }\n-\n-        jla.appendDigit3(buf, rem2);\n-\n-        if (fractionalDigits == 6) {\n-            return;\n-        }\n-\n-        if (fractionalDigits == 7) {\n-            buf.append((char) ('0' + (rem1 \/ 100)));\n-            return;\n-        }\n-\n-        if (fractionalDigits == 8) {\n-            jla.appendDigit2(buf, rem1 \/ 10);\n-            return;\n-        }\n-\n-        jla.appendDigit3(buf, rem1);\n-    }\n-\n@@ -4145,15 +3814,59 @@\n-            Instant instant = (Instant) context.getTemporal();\n-            long seconds = instant.getEpochSecond();\n-            int nano = instant.getNano();\n-\n-            LocalDate date = LocalDate.ofEpochDay(\n-                    Math.floorDiv(seconds, SECONDS_PER_DAY));\n-\n-            formatDate(buf, '-', date);\n-            buf.append('T');\n-\n-            LocalTime time = LocalTime.ofSecondOfDay(\n-                    Math.floorMod(seconds, SECONDS_PER_DAY));\n-\n-            formatTime(buf, fractionalDigits, time);\n-\n+            \/\/ use INSTANT_SECONDS, thus this code is not bound by Instant.MAX\n+            Long inSecs = context.getValue(INSTANT_SECONDS);\n+            Long inNanos = null;\n+            if (context.getTemporal().isSupported(NANO_OF_SECOND)) {\n+                inNanos = context.getTemporal().getLong(NANO_OF_SECOND);\n+            }\n+            if (inSecs == null) {\n+                return false;\n+            }\n+            long inSec = inSecs;\n+            int inNano = NANO_OF_SECOND.checkValidIntValue(inNanos != null ? inNanos : 0);\n+            \/\/ format mostly using LocalDateTime.toString\n+            if (inSec >= -SECONDS_0000_TO_1970) {\n+                \/\/ current era\n+                long zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n+                long hi = Math.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n+                long lo = Math.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n+                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n+                if (hi > 0) {\n+                    buf.append('+').append(hi);\n+                }\n+                buf.append(ldt);\n+                if (ldt.getSecond() == 0) {\n+                    buf.append(\":00\");\n+                }\n+            } else {\n+                \/\/ before current era\n+                long zeroSecs = inSec + SECONDS_0000_TO_1970;\n+                long hi = zeroSecs \/ SECONDS_PER_10000_YEARS;\n+                long lo = zeroSecs % SECONDS_PER_10000_YEARS;\n+                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n+                int pos = buf.length();\n+                buf.append(ldt);\n+                if (ldt.getSecond() == 0) {\n+                    buf.append(\":00\");\n+                }\n+                if (hi < 0) {\n+                    if (ldt.getYear() == -10_000) {\n+                        buf.replace(pos, pos + 2, Long.toString(hi - 1));\n+                    } else if (lo == 0) {\n+                        buf.insert(pos, hi);\n+                    } else {\n+                        buf.insert(pos + 1, Math.abs(hi));\n+                    }\n+                }\n+            }\n+            \/\/ add fraction\n+            if ((fractionalDigits < 0 && inNano > 0) || fractionalDigits > 0) {\n+                buf.append('.');\n+                int div = 100_000_000;\n+                for (int i = 0; ((fractionalDigits == -1 && inNano > 0) ||\n+                                    (fractionalDigits == -2 && (inNano > 0 || (i % 3) != 0)) ||\n+                                    i < fractionalDigits); i++) {\n+                    int digit = inNano \/ div;\n+                    buf.append((char) (digit + '0'));\n+                    inNano = inNano - (digit * div);\n+                    div = div \/ 10;\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":65,"deletions":352,"binary":false,"changes":417,"status":"modified"},{"patch":"@@ -437,4 +437,0 @@\n-   void appendDigit2(StringBuilder sb, int i);\n-\n-   void appendDigit3(StringBuilder sb, int i);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,15 +73,0 @@\n-    @Stable\n-    private static final int[] DIGITS_K;\n-\n-    static {\n-        int[] digits_k = new int[1000];\n-        for (int i = 0; i < 1000; i++) {\n-            int c0 = i < 10 ? 2 : i < 100 ? 1 : 0;\n-            int c1 = (i \/ 100) + '0';\n-            int c2 = ((i \/ 10) % 10) + '0';\n-            int c3 = i % 10 + '0';\n-            digits_k[i] = c0 + (c1 << 8) + (c2 << 16) + (c3 << 24);\n-        }\n-        DIGITS_K = digits_k;\n-    }\n-\n@@ -175,85 +160,0 @@\n-\n-    \/**\n-     * For values from 0 to 999 return a short encoding a triple of ASCII-encoded digit characters in little-endian\n-     * @param i value to convert\n-     * @return a short encoding a triple of ASCII-encoded digit characters\n-     *\/\n-    public static int digitTriple(int i) {\n-        return DIGITS_K[i];\n-    }\n-\n-    \/**\n-     * Returns the string representation size for a given int value.\n-     *\n-     * @param x int value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    public static int stringSize(int x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        int p = -10;\n-        for (int i = 1; i < 10; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 10 + d;\n-    }\n-\n-    \/**\n-     * Places characters representing the integer i into the\n-     * character array buf. The characters are placed into\n-     * the buffer backwards starting with the least significant\n-     * digit at the specified index (exclusive), and working\n-     * backwards from there.\n-     *\n-     * @implNote This method converts positive inputs into negative\n-     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n-     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n-     * integer.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, Latin1-encoded\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    public static int getCharsLatin1(int i, int index, byte[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        int q, r;\n-        int charPos = index;\n-\n-        boolean negative = i < 0;\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Generate two digits per iteration\n-        while (i <= -100) {\n-            q = i \/ 100;\n-            r = (q * 100) - i;\n-            i = q;\n-            charPos -= 2;\n-            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[r]);\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i < -9) {\n-            charPos -= 2;\n-            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[-i]);\n-        } else {\n-            buf[--charPos] = (byte)('0' - i);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = (byte)'-';\n-        }\n-        return charPos;\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"modified"}]}