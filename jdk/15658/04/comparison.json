{"files":[{"patch":"@@ -83,0 +83,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -99,0 +101,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -213,0 +218,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -1355,1 +1362,22 @@\n-        return DateTimeFormatter.ISO_INSTANT.format(this);\n+        LocalDate date = LocalDate.ofEpochDay(\n+                Math.floorDiv(seconds, SECONDS_PER_DAY));\n+        LocalTime time = LocalTime.ofSecondOfDay(\n+                Math.floorMod(seconds, SECONDS_PER_DAY));\n+\n+        int yearSize = LocalDate.yearSize(date.getYear());\n+        int nanoSize = LocalTime.nanoSize(nanos);\n+\n+        byte[] buf = new byte[yearSize + 16 + nanoSize];\n+\n+        int off = date.getChars(buf, 0);\n+        buf[off] = 'T';\n+\n+        off = time.getChars(buf, off + 1);\n+        LocalTime.getNanoChars(buf, off, nanos);\n+        buf[off + nanoSize] = 'Z';\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -106,0 +108,5 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -143,0 +150,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -2150,10 +2159,24 @@\n-        int yearValue = year;\n-        int monthValue = month;\n-        int dayValue = day;\n-        int absYear = Math.abs(yearValue);\n-        StringBuilder buf = new StringBuilder(10);\n-        if (absYear < 1000) {\n-            if (yearValue < 0) {\n-                buf.append(yearValue - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(yearValue + 10000).deleteCharAt(0);\n+        byte[] buf = new byte[yearSize(year) + 6];\n+        getChars(buf, 0);\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    static int yearSize(int year) {\n+        if (Math.abs(year) < 1000) {\n+            return year < 0 ? 5 : 4;\n+        }\n+        return DecimalDigits.stringSize(year) + (year > 9999 ? 1 : 0);\n+    }\n+\n+    int getChars(byte[] buf, int off) {\n+        int year = this.year;\n+        int yearSize = yearSize(year);\n+        int yearAbs = Math.abs(year);\n+        if (yearAbs < 1000) {\n+            if (year < 0) {\n+                buf[off] = '-';\n@@ -2161,0 +2184,7 @@\n+            int y01 = yearAbs \/ 100;\n+            int y23 = yearAbs - y01 * 100;\n+\n+            ByteArrayLittleEndian.setInt(\n+                    buf,\n+                    off + (year < 0 ? 1 : 0),\n+                    (DecimalDigits.digitPair(y23) << 16) | DecimalDigits.digitPair(y01));\n@@ -2162,2 +2192,2 @@\n-            if (yearValue > 9999) {\n-                buf.append('+');\n+            if (year > 9999) {\n+                buf[off] = '+';\n@@ -2165,1 +2195,1 @@\n-            buf.append(yearValue);\n+            DecimalDigits.getCharsLatin1(year, off + yearSize, buf);\n@@ -2167,5 +2197,14 @@\n-        return buf.append(monthValue < 10 ? \"-0\" : \"-\")\n-            .append(monthValue)\n-            .append(dayValue < 10 ? \"-0\" : \"-\")\n-            .append(dayValue)\n-            .toString();\n+\n+        off += yearSize;\n+        buf[off] = '-';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 1,\n+                DecimalDigits.digitPair(month)); \/\/ mm\n+        buf[off + 3] = '-';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 4,\n+                DecimalDigits.digitPair(day)); \/\/ dd\n+\n+        return off + 6;\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":57,"deletions":18,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -99,0 +101,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -1968,1 +1972,17 @@\n-        return date.toString() + 'T' + time.toString();\n+        int yearSize = LocalDate.yearSize(date.getYear());\n+        int nano = time.getNano();\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        byte[] buf = new byte[yearSize + 15 + nanoSize];\n+\n+        int off = date.getChars(buf, 0);\n+        buf[off] = 'T';\n+        off = time.getChars(buf, off + 1);\n+        LocalTime.getNanoChars(buf, off, nano);\n+\n+        try {\n+            return SharedSecrets.getJavaLangAccess()\n+                    .newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -95,0 +97,6 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -129,0 +137,5 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n+    @Stable\n+    static final int[] DIGITS_K = new int[1000];\n+\n@@ -159,0 +172,8 @@\n+\n+        for (int i = 0; i < 1000; i++) {\n+            int c0 = i < 10 ? 2 : i < 100 ? 1 : 0;\n+            int c1 = (i \/ 100) + '0';\n+            int c2 = ((i \/ 10) % 10) + '0';\n+            int c3 = i % 10 + '0';\n+            DIGITS_K[i] = c0 + (c1 << 8) + (c2 << 16) + (c3 << 24);\n+        }\n@@ -1632,18 +1653,67 @@\n-        StringBuilder buf = new StringBuilder(18);\n-        int hourValue = hour;\n-        int minuteValue = minute;\n-        int secondValue = second;\n-        int nanoValue = nano;\n-        buf.append(hourValue < 10 ? \"0\" : \"\").append(hourValue)\n-            .append(minuteValue < 10 ? \":0\" : \":\").append(minuteValue);\n-        if (secondValue > 0 || nanoValue > 0) {\n-            buf.append(secondValue < 10 ? \":0\" : \":\").append(secondValue);\n-            if (nanoValue > 0) {\n-                buf.append('.');\n-                if (nanoValue % 1000_000 == 0) {\n-                    buf.append(Integer.toString((nanoValue \/ 1000_000) + 1000).substring(1));\n-                } else if (nanoValue % 1000 == 0) {\n-                    buf.append(Integer.toString((nanoValue \/ 1000) + 1000_000).substring(1));\n-                } else {\n-                    buf.append(Integer.toString((nanoValue) + 1000_000_000).substring(1));\n-                }\n+        int nano = this.nano;\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        byte[] buf = new byte[8 + nanoSize];\n+        getChars(buf, 0);\n+        LocalTime.getNanoChars(buf, 8, nano);\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    static int nanoSize(int nano) {\n+        if (nano == 0) {\n+            return 0;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        if (nano - div * 1000 != 0) {\n+            return 10;\n+        }\n+\n+        return (div - div2 * 1000 == 0) ? 4 : 7;\n+    }\n+\n+    int getChars(byte[] buf, int off) {\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off,\n+                DecimalDigits.digitPair(hour)); \/\/ hh\n+        buf[off + 2] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 3,\n+                DecimalDigits.digitPair(minute)); \/\/ minute\n+        buf[off + 5] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 6,\n+                DecimalDigits.digitPair(second)); \/\/ second\n+        return off + 8;\n+    }\n+\n+    static void getNanoChars(byte[] buf, int off, int nano) {\n+        if (nano == 0) {\n+            return;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+        ByteArrayLittleEndian.setInt(\n+                buf,\n+                off,\n+                DIGITS_K[div2] & 0xffffff00 | '.'\n+        );\n+        off += 4;\n+\n+        int rem1 = nano - div * 1000;\n+        int v;\n+        if (rem1 == 0) {\n+            int rem2 = div - div2 * 1000;\n+            if (rem2 == 0) {\n+                return;\n@@ -1651,0 +1721,21 @@\n+\n+            v = DIGITS_K[rem2];\n+        } else {\n+            v = DIGITS_K[div - div2 * 1000];\n+        }\n+\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off,\n+                (short) (v >> 8)\n+        );\n+        off += 2;\n+\n+        if (rem1 == 0) {\n+            buf[off] = (byte) (v >> 24);\n+        } else {\n+            ByteArrayLittleEndian.setInt(\n+                    buf,\n+                    off,\n+                    DIGITS_K[rem1] & 0xffffff00 | (v >> 24)\n+            );\n@@ -1652,1 +1743,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalTime.java","additions":109,"deletions":19,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -96,0 +98,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -1925,0 +1929,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -1926,1 +1931,20 @@\n-        return dateTime.toString() + offset.toString();\n+        int yearSize = LocalDate.yearSize(dateTime.getYear());\n+        int nano = dateTime.getNano();\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        String offSetId = offset.getId();\n+\n+        byte[] buf = new byte[yearSize + 15 + nanoSize + offSetId.length()];\n+\n+        int off = toLocalDate().getChars(buf, 0);\n+        buf[off] = 'T';\n+        off = toLocalTime().getChars(buf, off + 1);\n+        LocalTime.getNanoChars(buf, off, nano);\n+        offSetId.getBytes(0, offSetId.length(), buf, off + nanoSize);\n+\n+        try {\n+            return SharedSecrets.getJavaLangAccess()\n+                    .newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -95,0 +97,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -121,1 +125,0 @@\n-\n@@ -1400,0 +1403,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -1401,1 +1405,16 @@\n-        return time.toString() + offset.toString();\n+        int nano = time.getNano();\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        String offSetId = offset.getId();\n+        byte[] buf = new byte[8 + nanoSize + offSetId.length()];\n+        time.getChars(buf, 0);\n+\n+        LocalTime.getNanoChars(buf, 8, nano);\n+        offSetId.getBytes(0, offSetId.length(), buf, 8 + nanoSize);\n+\n+        try {\n+            return SharedSecrets.getJavaLangAccess()\n+                    .newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -89,0 +91,4 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n@@ -137,0 +143,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -451,13 +459,31 @@\n-        } else {\n-            int absTotalSeconds = Math.abs(totalSeconds);\n-            StringBuilder buf = new StringBuilder();\n-            int absHours = absTotalSeconds \/ SECONDS_PER_HOUR;\n-            int absMinutes = (absTotalSeconds \/ SECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n-            buf.append(totalSeconds < 0 ? \"-\" : \"+\")\n-                .append(absHours < 10 ? \"0\" : \"\").append(absHours)\n-                .append(absMinutes < 10 ? \":0\" : \":\").append(absMinutes);\n-            int absSeconds = absTotalSeconds % SECONDS_PER_MINUTE;\n-            if (absSeconds != 0) {\n-                buf.append(absSeconds < 10 ? \":0\" : \":\").append(absSeconds);\n-            }\n-            return buf.toString();\n+        }\n+\n+        int absTotalSeconds = Math.abs(totalSeconds);\n+        int absHours = absTotalSeconds \/ SECONDS_PER_HOUR;\n+        int minuteSeconds = absTotalSeconds - absHours * SECONDS_PER_HOUR;\n+        int absMinutes = minuteSeconds \/ SECONDS_PER_MINUTE;\n+        int absSeconds = minuteSeconds - absMinutes * SECONDS_PER_MINUTE;\n+\n+        byte[] buf = new byte[6 + (absSeconds != 0 ? 3 : 0)];\n+        buf[0] = (byte) (totalSeconds < 0 ? '-' : '+');\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                1,\n+                DecimalDigits.digitPair(absHours));\n+        buf[3] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                4,\n+                DecimalDigits.digitPair(absMinutes));\n+        if (absSeconds != 0) {\n+            buf[6] = ':';\n+            ByteArrayLittleEndian.setShort(\n+                    buf,\n+                    7,\n+                    DecimalDigits.digitPair(absSeconds));\n+        }\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -94,0 +96,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -2216,0 +2220,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -2217,1 +2222,26 @@\n-        String str = dateTime.toString() + offset.toString();\n+        int yearSize = LocalDate.yearSize(dateTime.getYear());\n+        int nano = dateTime.getNano();\n+        int nanoSize = LocalTime.nanoSize(nano);\n+\n+        String offSetId = offset.getId();\n+        int offsetIdLenth = offSetId.length();\n+\n+        String zoneStr = null;\n+        int zoneLength = 0;\n+\n+        int offsetLength = offsetIdLenth;\n+        if (offset != zone) {\n+            zoneStr = zone.toString();\n+            zoneLength = zoneStr.length();\n+            offsetLength += zoneLength + 2;\n+        }\n+\n+        byte[] buf = new byte[yearSize + 15 + nanoSize + offsetLength];\n+\n+        int off = toLocalDate().getChars(buf, 0);\n+        buf[off] = 'T';\n+        off = toLocalTime().getChars(buf, off + 1);\n+        LocalTime.getNanoChars(buf, off, nano);\n+        off += nanoSize;\n+        offSetId.getBytes(0, offsetIdLenth, buf, off);\n+\n@@ -2219,1 +2249,11 @@\n-            str += '[' + zone.toString() + ']';\n+            off += offsetIdLenth;\n+            buf[off] = '[';\n+            zoneStr.getBytes(0, zoneLength, buf, off + 1);\n+            buf[off + zoneLength + 1] = ']';\n+        }\n+\n+        try {\n+            return SharedSecrets.getJavaLangAccess()\n+                    .newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n@@ -2221,1 +2261,0 @@\n-        return str;\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -3354,11 +3356,0 @@\n-        \/\/ Simplified variant of Integer.stringSize that assumes positive values\n-        private static int stringSize(int x) {\n-            int p = 10;\n-            for (int i = 1; i < 10; i++) {\n-                if (x < p)\n-                    return i;\n-                p = 10 * p;\n-            }\n-            return 10;\n-        }\n-\n@@ -3385,1 +3376,1 @@\n-            int stringSize = stringSize(val);\n+            int stringSize = DecimalDigits.stringSize(val);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -33,0 +35,4 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n@@ -131,0 +137,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -1028,0 +1036,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -1031,1 +1040,10 @@\n-        StringBuilder sb = new StringBuilder(28);\n+\n+        int year = date.getYear();\n+        int yearSize = year >= 1000 && year <= 9999 ? 4 : DecimalDigits.stringSize(year);\n+\n+        TimeZone zi = date.getZone();\n+        String shortName = zi != null ? zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US) : \"GMT\";\n+        int shortNameLength = shortName.length();\n+\n+        byte[] buf = new byte[21 + yearSize + shortNameLength];\n+\n@@ -1036,3 +1054,24 @@\n-        convertToAbbr(sb, wtb[index]).append(' ');                        \/\/ EEE\n-        convertToAbbr(sb, wtb[date.getMonth() - 1 + 2 + 7]).append(' ');  \/\/ MMM\n-        CalendarUtils.sprintf0d(sb, date.getDayOfMonth(), 2).append(' '); \/\/ dd\n+        convertToAbbr(buf, 0, wtb[index]); \/\/ EEE\n+        buf[3] = ' ';\n+        convertToAbbr(buf, 4, wtb[date.getMonth() - 1 + 2 + 7]); \/\/ MMM\n+        buf[7] = ' ';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                8,\n+                DecimalDigits.digitPair(date.getDayOfMonth())); \/\/ dd\n+        buf[10] = ' ';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                11,\n+                DecimalDigits.digitPair(date.getHours())); \/\/ HH\n+        buf[13] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                14,\n+                DecimalDigits.digitPair(date.getMinutes())); \/\/ mm\n+        buf[16] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                17,\n+                DecimalDigits.digitPair(date.getSeconds())); \/\/ ss\n+        buf[19] = ' ';\n@@ -1040,8 +1079,8 @@\n-        CalendarUtils.sprintf0d(sb, date.getHours(), 2).append(':');   \/\/ HH\n-        CalendarUtils.sprintf0d(sb, date.getMinutes(), 2).append(':'); \/\/ mm\n-        CalendarUtils.sprintf0d(sb, date.getSeconds(), 2).append(' '); \/\/ ss\n-        TimeZone zi = date.getZone();\n-        if (zi != null) {\n-            sb.append(zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US)); \/\/ zzz\n-        } else {\n-            sb.append(\"GMT\");\n+        shortName.getBytes(0, shortNameLength, buf, 20);\n+        buf[20 + shortNameLength] = ' ';\n+\n+        DecimalDigits.getCharsLatin1(year, buf.length, buf);\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n@@ -1049,2 +1088,0 @@\n-        sb.append(' ').append(date.getYear());  \/\/ yyyy\n-        return sb.toString();\n@@ -1055,2 +1092,1 @@\n-     * \"monday\" -> \"Mon\") and stored the abbreviation in the given\n-     * {@code StringBuilder}.\n+     * \"monday\" -> \"Mon\") and stored the abbreviation in the given buf\n@@ -1058,4 +1094,4 @@\n-    private static final StringBuilder convertToAbbr(StringBuilder sb, String name) {\n-        sb.append(Character.toUpperCase(name.charAt(0)));\n-        sb.append(name.charAt(1)).append(name.charAt(2));\n-        return sb;\n+    private static final void convertToAbbr(byte[] buf, int off, String name) {\n+        buf[off] = (byte) (name.charAt(0) - 32);\n+        buf[off + 1] = (byte) name.charAt(1);\n+        buf[off + 2] = (byte) name.charAt(2);\n@@ -1121,1 +1157,0 @@\n-        BaseCalendar cal = getCalendarSystem(t);\n@@ -1123,10 +1158,49 @@\n-            (BaseCalendar.Date) cal.getCalendarDate(getTime(), (TimeZone)null);\n-        StringBuilder sb = new StringBuilder(32);\n-        CalendarUtils.sprintf0d(sb, date.getDayOfMonth(), 1).append(' '); \/\/ d\n-        convertToAbbr(sb, wtb[date.getMonth() - 1 + 2 + 7]).append(' ');  \/\/ MMM\n-        sb.append(date.getYear()).append(' ');                            \/\/ yyyy\n-        CalendarUtils.sprintf0d(sb, date.getHours(), 2).append(':');      \/\/ HH\n-        CalendarUtils.sprintf0d(sb, date.getMinutes(), 2).append(':');    \/\/ mm\n-        CalendarUtils.sprintf0d(sb, date.getSeconds(), 2);                \/\/ ss\n-        sb.append(\" GMT\");                                                \/\/ ' GMT'\n-        return sb.toString();\n+                (BaseCalendar.Date) getCalendarSystem(t)\n+                        .getCalendarDate(getTime(), (TimeZone)null);\n+\n+        int year = date.getYear();\n+        int yearSize = year >= 1000 && year <= 9999 ? 4 : DecimalDigits.stringSize(year);\n+        int dayOfMonth = date.getDayOfMonth();\n+\n+        byte[] buf = new byte[(dayOfMonth < 10 ? 19 : 20) + yearSize];\n+        int off;\n+        if (dayOfMonth < 10) {\n+            buf[0] = (byte) ('0' + dayOfMonth);\n+            off = 1;\n+        } else {\n+            ByteArrayLittleEndian.setShort(\n+                    buf,\n+                    0,\n+                    DecimalDigits.digitPair(dayOfMonth)); \/\/ dd\n+            off = 2;\n+        }\n+        buf[off++] = ' ';\n+        convertToAbbr(buf, off, wtb[date.getMonth() + 8]); \/\/ EEE\n+        buf[off + 3] = ' ';\n+        DecimalDigits.getCharsLatin1(year, off + yearSize + 4, buf);\n+        off += yearSize + 4;\n+        buf[off++] = ' ';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off,\n+                DecimalDigits.digitPair(date.getHours())); \/\/ HH\n+        buf[off + 2] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 3,\n+                DecimalDigits.digitPair(date.getMinutes())); \/\/ mm\n+        buf[off + 5] = ':';\n+        ByteArrayLittleEndian.setShort(\n+                buf,\n+                off + 6,\n+                DecimalDigits.digitPair(date.getSeconds())); \/\/ mm\n+        buf[off + 8] = ' ';\n+        buf[off + 9] = 'G';\n+        buf[off + 10] = 'M';\n+        buf[off + 11] = 'T';\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Date.java","additions":105,"deletions":31,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -160,0 +160,76 @@\n+\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(int x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        int p = -10;\n+        for (int i = 1; i < 10; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 10 + d;\n+    }\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n+\n+        boolean negative = i < 0;\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Generate two digits per iteration\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[r]);\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[-i]);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i);\n+        }\n+\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n+        }\n+        return charPos;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.time;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class ToStringBench {\n+    private static final Instant[] INSTANTS;\n+    private static final ZonedDateTime[] ZONED_DATE_TIMES;\n+    private static final LocalDateTime[] LOCAL_DATE_TIMES;\n+    private static final LocalDate[] LOCAL_DATES;\n+    private static final LocalTime[] LOCAL_TIMES;\n+\n+    static {\n+        Instant loInstant = Instant.EPOCH.plus(Duration.ofDays(365*50)); \/\/ 2020-01-01\n+        Instant hiInstant = loInstant.plus(Duration.ofDays(1));\n+        long maxOffsetNanos = Duration.between(loInstant, hiInstant).toNanos();\n+        Random random = new Random(0);\n+        INSTANTS = IntStream\n+                .range(0, 1_000)\n+                .mapToObj(ignored -> {\n+                    final long offsetNanos = (long) Math.floor(random.nextDouble() * maxOffsetNanos);\n+                    return loInstant.plus(offsetNanos, ChronoUnit.NANOS);\n+                })\n+                .toArray(Instant[]::new);\n+\n+        ZONED_DATE_TIMES = Stream.of(INSTANTS)\n+                .map(instant -> ZonedDateTime.ofInstant(instant, ZoneOffset.UTC))\n+                .toArray(ZonedDateTime[]::new);\n+\n+        LOCAL_DATE_TIMES = Stream.of(ZONED_DATE_TIMES)\n+                .map(zdt -> zdt.toLocalDateTime())\n+                .toArray(LocalDateTime[]::new);\n+\n+        LOCAL_DATES = Stream.of(LOCAL_DATE_TIMES)\n+                .map(ldt -> ldt.toLocalDate())\n+                .toArray(LocalDate[]::new);\n+\n+        LOCAL_TIMES = Stream.of(LOCAL_DATE_TIMES)\n+                .map(ldt -> ldt.toLocalTime())\n+                .toArray(LocalTime[]::new);\n+    }\n+\n+    @Benchmark\n+    public void testZonedDateTimeToString(Blackhole bh) {\n+        for (final ZonedDateTime zonedDateTime : ZONED_DATE_TIMES) {\n+            bh.consume(zonedDateTime.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLocalDateTimeToString(Blackhole bh) {\n+        for (LocalDateTime localDateTime : LOCAL_DATE_TIMES) {\n+            bh.consume(localDateTime.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLocalDateToString(Blackhole bh) {\n+        for (LocalDate localDate : LOCAL_DATES) {\n+            bh.consume(localDate.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLocalTimeToString(Blackhole bh) {\n+        for (LocalTime localTime : LOCAL_TIMES) {\n+            bh.consume(localTime.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInstantToString(Blackhole bh) {\n+        for (Instant instant : INSTANTS) {\n+            bh.consume(instant.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testZoneOffsetOffHours(Blackhole bh) {\n+        for (int hour = 0; hour < 12; hour++) {\n+            for (int minute = 0; minute < 60; minute += 15) {\n+                for (int second = 0; second < 60; second += 15) {\n+                    bh.consume(ZoneOffset.ofHoursMinutesSeconds(hour, minute, second));\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/ToStringBench.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"}]}