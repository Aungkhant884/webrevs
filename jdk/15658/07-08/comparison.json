{"files":[{"patch":"@@ -73,0 +73,15 @@\n+    @Stable\n+    private static final int[] DIGITS_K;\n+\n+    static {\n+        int[] digits_k = new int[1000];\n+        for (int i = 0; i < 1000; i++) {\n+            int c0 = i < 10 ? 2 : i < 100 ? 1 : 0;\n+            int c1 = (i \/ 100) + '0';\n+            int c2 = ((i \/ 10) % 10) + '0';\n+            int c3 = i % 10 + '0';\n+            digits_k[i] = c0 + (c1 << 8) + (c2 << 16) + (c3 << 24);\n+        }\n+        DIGITS_K = digits_k;\n+    }\n+\n@@ -160,0 +175,85 @@\n+\n+    \/**\n+     * For values from 0 to 999 return a short encoding a triple of ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @return a short encoding a triple of ASCII-encoded digit characters\n+     *\/\n+    public static int digitTriple(int i) {\n+        return DIGITS_K[i];\n+    }\n+\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(int x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        int p = -10;\n+        for (int i = 1; i < 10; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 10 + d;\n+    }\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    public static int getCharsLatin1(int i, int index, byte[] buf) {\n+        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n+        int q, r;\n+        int charPos = index;\n+\n+        boolean negative = i < 0;\n+        if (!negative) {\n+            i = -i;\n+        }\n+\n+        \/\/ Generate two digits per iteration\n+        while (i <= -100) {\n+            q = i \/ 100;\n+            r = (q * 100) - i;\n+            i = q;\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[r]);\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i < -9) {\n+            charPos -= 2;\n+            ByteArrayLittleEndian.setShort(buf, charPos, DIGITS[-i]);\n+        } else {\n+            buf[--charPos] = (byte)('0' - i);\n+        }\n+\n+        if (negative) {\n+            buf[--charPos] = (byte)'-';\n+        }\n+        return charPos;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"modified"}]}