{"files":[{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.util.DecimalDigits;\n@@ -818,0 +820,24 @@\n+    void appendDigit2(int i) {\n+        ensureCapacityInternal(count + 2);\n+        if (isLatin1()) {\n+            ByteArrayLittleEndian.setShort(value, count, DecimalDigits.digitPair(i));\n+        } else {\n+            StringUTF16.putPair(value, count, i);\n+        }\n+        count += 2;\n+    }\n+\n+    void appendDigit3(int i) {\n+        ensureCapacityInternal(count + 3);\n+        int v = DecimalDigits.digitTriple(i);\n+        if (isLatin1()) {\n+            ByteArrayLittleEndian.setShort(value, count, (short) (v >> 8));\n+            value[count + 2] = (byte) (v >> 24);\n+        } else {\n+            StringUTF16.putChar(value, count, (byte) (v >> 8));\n+            StringUTF16.putChar(value, count + 1, (byte) (v >> 16));\n+            StringUTF16.putChar(value, count + 2, (byte) (v >> 24));\n+        }\n+        count += 3;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1615,1 +1615,1 @@\n-    private static void putPair(byte[] buf, int charPos, int v) {\n+    static void putPair(byte[] buf, int charPos, int v) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2547,0 +2547,8 @@\n+            public void appendDigit2(StringBuilder sb, int i) {\n+                sb.appendDigit2(i);\n+            }\n+\n+            public void appendDigit3(StringBuilder sb, int i) {\n+                sb.appendDigit3(i);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+import java.time.OffsetDateTime;\n+import java.time.ZonedDateTime;\n@@ -124,0 +126,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -162,0 +167,22 @@\n+    \/**\n+     * Hours per day.\n+     *\/\n+    static final int HOURS_PER_DAY = 24;\n+    \/**\n+     * Minutes per hour.\n+     *\/\n+    static final int MINUTES_PER_HOUR = 60;\n+    \/**\n+     * Seconds per minute.\n+     *\/\n+    static final int SECONDS_PER_MINUTE = 60;\n+    \/**\n+     * Seconds per hour.\n+     *\/\n+    static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    \/**\n+     * Seconds per day.\n+     *\/\n+    static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n+\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n@@ -2425,1 +2452,14 @@\n-        CompositePrinterParser pp = new CompositePrinterParser(printerParsers, false);\n+\n+        CompositePrinterParser pp = null;\n+\n+        int printerParsersSize = printerParsers.size();\n+        if (DateCompositePrinterParser.accept(printerParsers)) {\n+            pp = new DateCompositePrinterParser(printerParsers, false);\n+        } else if (TimeCompositePrinterParser.accept(printerParsers)) {\n+            pp = new TimeCompositePrinterParser(printerParsers, false);\n+        }\n+\n+        if (pp == null) {\n+            pp = new CompositePrinterParser(printerParsers, false);\n+        }\n+\n@@ -2491,1 +2531,169 @@\n-    \/\/-----------------------------------------------------------------------\n+    static final class DateCompositePrinterParser extends CompositePrinterParser {\n+        private final char literal;\n+        private DateCompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+            super(printerParsers, optional);\n+            literal = ((CharLiteralPrinterParser) printerParsers.get(1)).literal;\n+        }\n+\n+        static boolean accept(List<DateTimePrinterParser> printerParsers) {\n+            int printerParsersSize = printerParsers.size();\n+            if (printerParsersSize != 5) {\n+                return false;\n+            }\n+\n+            if (printerParsers.get(0) instanceof NumberPrinterParser\n+                    && printerParsers.get(1) instanceof CharLiteralPrinterParser\n+                    && printerParsers.get(2) instanceof NumberPrinterParser\n+                    && printerParsers.get(3) instanceof CharLiteralPrinterParser\n+                    && printerParsers.get(4) instanceof NumberPrinterParser\n+            ) {\n+                NumberPrinterParser p0 = (NumberPrinterParser) printerParsers.get(0);\n+                CharLiteralPrinterParser p1 = (CharLiteralPrinterParser) printerParsers.get(1);\n+                NumberPrinterParser p2 = (NumberPrinterParser) printerParsers.get(2);\n+                CharLiteralPrinterParser p3 = (CharLiteralPrinterParser) printerParsers.get(3);\n+                NumberPrinterParser p4 = (NumberPrinterParser) printerParsers.get(4);\n+                if (p0.field == ChronoField.YEAR\n+                        && p1.literal == p3.literal\n+                        && p0.signStyle == SignStyle.EXCEEDS_PAD\n+                        && p0.minWidth == 4\n+                        && p0.maxWidth == 10\n+                        && p0.subsequentWidth == 0\n+                        && p2.field == ChronoField.MONTH_OF_YEAR\n+                        && p2.signStyle == SignStyle.NOT_NEGATIVE\n+                        && p2.minWidth == 2\n+                        && p2.maxWidth == 2\n+                        && p4.subsequentWidth == 0\n+                        && p4.field == ChronoField.DAY_OF_MONTH\n+                        && p4.signStyle == SignStyle.NOT_NEGATIVE\n+                        && p4.minWidth == 2\n+                        && p4.maxWidth == 2\n+                        && p4.subsequentWidth == 0\n+                ) {\n+                    return true;\n+                }\n+            }\n+\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n+            TemporalAccessor temporal = context.getTemporal();\n+\n+            LocalDate date = null;\n+            if (temporal instanceof LocalDateTime) {\n+                date = ((LocalDateTime) temporal).toLocalDate();\n+            } else if (temporal instanceof LocalDate) {\n+                date = (LocalDate) temporal;\n+            } else if (temporal instanceof ZonedDateTime) {\n+                date = ((ZonedDateTime) temporal).toLocalDate();\n+            } else if (temporal instanceof OffsetDateTime) {\n+                date = ((OffsetDateTime) temporal).toLocalDate();\n+            }\n+\n+            if (date != null) {\n+                formatDate(buf, literal, date);\n+                return true;\n+            }\n+\n+            return super.format(context, buf);\n+        }\n+    }\n+\n+    static final class TimeCompositePrinterParser extends CompositePrinterParser {\n+        final char literal;\n+        final int fractionalDigits;\n+        private TimeCompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+            super(printerParsers, optional);\n+            literal = ((CharLiteralPrinterParser) printerParsers.get(1)).literal;\n+            CompositePrinterParser p3 = (CompositePrinterParser) printerParsers.get(3);\n+            CompositePrinterParser s2 = (CompositePrinterParser) p3.printerParsers[2];\n+            NanosPrinterParser n = (NanosPrinterParser) s2.printerParsers[0];\n+            if (n.minWidth == 0 && n.maxWidth == 9) {\n+                fractionalDigits = -2;\n+            } else {\n+                fractionalDigits = n.minWidth;\n+            }\n+        }\n+\n+        static boolean accept(List<DateTimePrinterParser> printerParsers) {\n+            if (printerParsers.size() != 4) {\n+                return false;\n+            }\n+\n+            if (printerParsers.get(0) instanceof NumberPrinterParser\n+                    && printerParsers.get(1) instanceof CharLiteralPrinterParser\n+                    && printerParsers.get(2) instanceof NumberPrinterParser\n+                    && printerParsers.get(3) instanceof CompositePrinterParser\n+            ) {\n+                NumberPrinterParser p0 = (NumberPrinterParser) printerParsers.get(0);\n+                CharLiteralPrinterParser p1 = (CharLiteralPrinterParser) printerParsers.get(1);\n+                NumberPrinterParser p2 = (NumberPrinterParser) printerParsers.get(2);\n+                CompositePrinterParser p3 = (CompositePrinterParser) printerParsers.get(3);\n+\n+                if (p0.field == ChronoField.HOUR_OF_DAY\n+                        && p0.signStyle == SignStyle.NOT_NEGATIVE\n+                        && p0.minWidth == 2\n+                        && p0.maxWidth == 2\n+                        && p0.subsequentWidth == 0\n+                        && p2.field == ChronoField.MINUTE_OF_HOUR\n+                        && p2.signStyle == SignStyle.NOT_NEGATIVE\n+                        && p2.minWidth == 2\n+                        && p2.maxWidth == 2\n+                        && p2.subsequentWidth == 0\n+                        && p3.printerParsers.length == 3\n+                        && p3.printerParsers[0] instanceof CharLiteralPrinterParser\n+                        && p3.printerParsers[1] instanceof NumberPrinterParser\n+                        && p3.printerParsers[2] instanceof CompositePrinterParser\n+                ) {\n+                    CharLiteralPrinterParser s0 = (CharLiteralPrinterParser) p3.printerParsers[0];\n+                    NumberPrinterParser s1 = (NumberPrinterParser) p3.printerParsers[1];\n+                    CompositePrinterParser s2 = (CompositePrinterParser) p3.printerParsers[2];\n+                    if (s1.field == ChronoField.SECOND_OF_MINUTE\n+                            && s0.literal == p1.literal\n+                            && s1.minWidth == 2\n+                            && s1.maxWidth == 2\n+                            && s1.subsequentWidth == 0\n+                            && s2.printerParsers.length == 1\n+                            && s2.printerParsers[0] instanceof NanosPrinterParser\n+                    ) {\n+                        NanosPrinterParser n = (NanosPrinterParser) s2.printerParsers[0];\n+                        if (n.decimalPoint\n+                                && n.field == ChronoField.NANO_OF_SECOND\n+                                && n.signStyle == SignStyle.NOT_NEGATIVE\n+                                && n.subsequentWidth == 0\n+                                && ((n.minWidth == 0 && n.maxWidth == 9) || n.minWidth == n.maxWidth)\n+                        ) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n+            TemporalAccessor temporal = context.getTemporal();\n+\n+            LocalTime time = null;\n+            if (temporal instanceof LocalDateTime) {\n+                time = ((LocalDateTime) temporal).toLocalTime();\n+            } else if (temporal instanceof LocalTime) {\n+                time = (LocalTime) temporal;\n+            } else if (temporal instanceof ZonedDateTime) {\n+                time = ((ZonedDateTime) temporal).toLocalTime();\n+            } else if (temporal instanceof OffsetDateTime) {\n+                time = ((OffsetDateTime) temporal).toLocalTime();\n+            }\n+\n+            if (time != null) {\n+                formatTime(buf, -2, time);\n+                return true;\n+            }\n+\n+            return super.format(context, buf);\n+        }\n+    }\n+        \/\/-----------------------------------------------------------------------\n@@ -2495,1 +2703,1 @@\n-    static final class CompositePrinterParser implements DateTimePrinterParser {\n+    static class CompositePrinterParser implements DateTimePrinterParser {\n@@ -2499,1 +2707,1 @@\n-        private CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+        CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n@@ -2833,1 +3041,1 @@\n-        private final SignStyle signStyle;\n+        final SignStyle signStyle;\n@@ -3279,1 +3487,1 @@\n-        private final boolean decimalPoint;\n+        final boolean decimalPoint;\n@@ -3796,0 +4004,123 @@\n+    static void formatDate(StringBuilder buf, char literal, LocalDate date) {\n+        int year = date.getYear();\n+        int yearAbs = Math.abs(year);\n+        if (yearAbs < 1000) {\n+            if (year < 0) {\n+                buf.append('-');\n+            }\n+            int y01 = yearAbs \/ 100;\n+            int y23 = yearAbs - y01 * 100;\n+\n+            jla.appendDigit2(buf, y01);\n+            jla.appendDigit2(buf, y23);\n+        } else {\n+            if (year > 9999) {\n+                buf.append('+');\n+            }\n+\n+            buf.append(year);\n+        }\n+        buf.append(literal);\n+        jla.appendDigit2(buf, date.getMonthValue());\n+        buf.append(literal);\n+        jla.appendDigit2(buf, date.getDayOfMonth());\n+    }\n+\n+    static void formatTime(StringBuilder buf, int fractionalDigits, LocalTime time) {\n+        jla.appendDigit2(buf, time.getHour());\n+        buf.append(':');\n+        jla.appendDigit2(buf, time.getMinute());\n+        buf.append(':');\n+        jla.appendDigit2(buf, time.getSecond());\n+\n+        int nano = time.getNano();\n+        if (fractionalDigits < 0) {\n+            formatNano(buf, nano);\n+        } else {\n+            formatNano(buf, fractionalDigits, nano);\n+        }\n+    }\n+\n+    static void formatNano(StringBuilder buf, int nano) {\n+        if (nano == 0) {\n+            return;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        buf.append('.');\n+        jla.appendDigit3(buf, div2);\n+\n+        int rem1 = nano - div * 1000;\n+        int rem2 = div - div2 * 1000;\n+\n+        if (rem1 == 0 && rem2 == 0) {\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem2);\n+        if (rem1 == 0) {\n+            return;\n+        }\n+        jla.appendDigit3(buf, rem1);\n+    }\n+\n+    static void formatNano(StringBuilder buf, int fractionalDigits, int nano) {\n+        if (fractionalDigits == 0) {\n+            return;\n+        }\n+\n+        buf.append('.');\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        if (fractionalDigits == 1) {\n+            buf.append((char) ('0' + (div2 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 2) {\n+            jla.appendDigit2(buf, div2 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, div2);\n+\n+        if (fractionalDigits == 3) {\n+            return;\n+        }\n+\n+        int rem1 = nano - div * 1000;\n+        int rem2 = div - div2 * 1000;\n+\n+        if (fractionalDigits == 4) {\n+            buf.append((char) ('0' + (rem2 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 5) {\n+            jla.appendDigit2(buf, rem2 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem2);\n+\n+        if (fractionalDigits == 6) {\n+            return;\n+        }\n+\n+        if (fractionalDigits == 7) {\n+            buf.append((char) ('0' + (rem1 \/ 100)));\n+            return;\n+        }\n+\n+        if (fractionalDigits == 8) {\n+            jla.appendDigit2(buf, rem1 \/ 10);\n+            return;\n+        }\n+\n+        jla.appendDigit3(buf, rem1);\n+    }\n+\n@@ -3814,59 +4145,15 @@\n-            \/\/ use INSTANT_SECONDS, thus this code is not bound by Instant.MAX\n-            Long inSecs = context.getValue(INSTANT_SECONDS);\n-            Long inNanos = null;\n-            if (context.getTemporal().isSupported(NANO_OF_SECOND)) {\n-                inNanos = context.getTemporal().getLong(NANO_OF_SECOND);\n-            }\n-            if (inSecs == null) {\n-                return false;\n-            }\n-            long inSec = inSecs;\n-            int inNano = NANO_OF_SECOND.checkValidIntValue(inNanos != null ? inNanos : 0);\n-            \/\/ format mostly using LocalDateTime.toString\n-            if (inSec >= -SECONDS_0000_TO_1970) {\n-                \/\/ current era\n-                long zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n-                long hi = Math.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n-                long lo = Math.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n-                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n-                if (hi > 0) {\n-                    buf.append('+').append(hi);\n-                }\n-                buf.append(ldt);\n-                if (ldt.getSecond() == 0) {\n-                    buf.append(\":00\");\n-                }\n-            } else {\n-                \/\/ before current era\n-                long zeroSecs = inSec + SECONDS_0000_TO_1970;\n-                long hi = zeroSecs \/ SECONDS_PER_10000_YEARS;\n-                long lo = zeroSecs % SECONDS_PER_10000_YEARS;\n-                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n-                int pos = buf.length();\n-                buf.append(ldt);\n-                if (ldt.getSecond() == 0) {\n-                    buf.append(\":00\");\n-                }\n-                if (hi < 0) {\n-                    if (ldt.getYear() == -10_000) {\n-                        buf.replace(pos, pos + 2, Long.toString(hi - 1));\n-                    } else if (lo == 0) {\n-                        buf.insert(pos, hi);\n-                    } else {\n-                        buf.insert(pos + 1, Math.abs(hi));\n-                    }\n-                }\n-            }\n-            \/\/ add fraction\n-            if ((fractionalDigits < 0 && inNano > 0) || fractionalDigits > 0) {\n-                buf.append('.');\n-                int div = 100_000_000;\n-                for (int i = 0; ((fractionalDigits == -1 && inNano > 0) ||\n-                                    (fractionalDigits == -2 && (inNano > 0 || (i % 3) != 0)) ||\n-                                    i < fractionalDigits); i++) {\n-                    int digit = inNano \/ div;\n-                    buf.append((char) (digit + '0'));\n-                    inNano = inNano - (digit * div);\n-                    div = div \/ 10;\n-                }\n-            }\n+            Instant instant = (Instant) context.getTemporal();\n+            long seconds = instant.getEpochSecond();\n+            int nano = instant.getNano();\n+\n+            LocalDate date = LocalDate.ofEpochDay(\n+                    Math.floorDiv(seconds, SECONDS_PER_DAY));\n+\n+            formatDate(buf, '-', date);\n+            buf.append('T');\n+\n+            LocalTime time = LocalTime.ofSecondOfDay(\n+                    Math.floorMod(seconds, SECONDS_PER_DAY));\n+\n+            formatTime(buf, fractionalDigits, time);\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":352,"deletions":65,"binary":false,"changes":417,"status":"modified"},{"patch":"@@ -437,0 +437,4 @@\n+   void appendDigit2(StringBuilder sb, int i);\n+\n+   void appendDigit3(StringBuilder sb, int i);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,0 +73,15 @@\n+    @Stable\n+    private static final int[] DIGITS_K;\n+\n+    static {\n+        int[] digits_k = new int[1000];\n+        for (int i = 0; i < 1000; i++) {\n+            int c0 = i < 10 ? 2 : i < 100 ? 1 : 0;\n+            int c1 = (i \/ 100) + '0';\n+            int c2 = ((i \/ 10) % 10) + '0';\n+            int c3 = i % 10 + '0';\n+            digits_k[i] = c0 + (c1 << 8) + (c2 << 16) + (c3 << 24);\n+        }\n+        DIGITS_K = digits_k;\n+    }\n+\n@@ -161,0 +176,9 @@\n+    \/**\n+     * For values from 0 to 999 return a short encoding a triple of ASCII-encoded digit characters in little-endian\n+     * @param i value to convert\n+     * @return a short encoding a triple of ASCII-encoded digit characters\n+     *\/\n+    public static int digitTriple(int i) {\n+        return DIGITS_K[i];\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}