{"files":[{"patch":"@@ -1385,8 +1385,0 @@\n-static bool file_exists(const char* filename) {\n-  struct stat statbuf;\n-  if (filename == NULL || strlen(filename) == 0) {\n-    return false;\n-  }\n-  return os::stat(filename, &statbuf) == 0;\n-}\n-\n@@ -2427,1 +2419,1 @@\n-      if (file_exists(hbuf_level)) {\n+      if (os::file_exists(hbuf_level)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-  assert(UseSharedSpaces && RecordDynamicDumpInfo, \"already checked in arguments.cpp?\");\n+  assert((UseSharedSpaces && RecordDynamicDumpInfo) || AutoCreateSharedArchive, \"already checked in arguments.cpp?\");\n@@ -374,1 +374,4 @@\n-    prepare_for_dynamic_dumping();\n+    if (!AutoCreateSharedArchive) {\n+      \/\/ When dump at exit, prepare_for_dynamic_dumping already called.\n+      prepare_for_dynamic_dumping();\n+    }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,0 +79,17 @@\n+#define CDS_MAX_PATH (2*K)\n+\/\/ Utility class to release file header memory\n+\/\/ and close open file handle\n+class ReleaseFileHeader {\n+  void* _header;\n+  int _fd;\n+ public:\n+  ReleaseFileHeader(void* header, int fd) {\n+    _header = header;\n+    _fd = fd;\n+  }\n+  ~ReleaseFileHeader() {\n+    os::free(_header);\n+    os::close(_fd);\n+  }\n+};\n+\n@@ -123,1 +140,0 @@\n-        ResourceMark rm;\n@@ -189,0 +205,11 @@\n+  if (is_static) {\n+    _full_path = Arguments::GetSharedArchivePath();\n+  } else {\n+    _full_path = Arguments::GetSharedDynamicArchivePath();\n+  }\n+  if (AutoCreateSharedArchive) {\n+    if (!_is_static && !validate_archive()) {\n+      \/\/ regenerate shared archive at exit\n+      DynamicDumpSharedSpaces = true;\n+    }\n+  }\n@@ -199,0 +226,16 @@\n+  if (_file_open) {\n+    os::close(_fd);\n+  }\n+}\n+\n+\/\/ Do preliminary validation on archive. More checks are in initialization.\n+bool FileMapInfo::validate_archive() {\n+  if (!os::file_exists(_full_path)) {\n+    return false;\n+  }\n+  \/\/ validate header info\n+  if (!check_archive(_full_path, _is_static)) {\n+    return false;\n+  }\n+\n+  return true;\n@@ -1026,0 +1069,2 @@\n+\n+  ReleaseFileHeader rl(header, fd);\n@@ -1029,2 +1074,0 @@\n-    os::free(header);\n-    os::close(fd);\n@@ -1037,3 +1080,2 @@\n-      os::free(header);\n-      os::close(fd);\n-      vm_exit_during_initialization(\"Not a base shared archive\", archive_name);\n+      log_info(cds)(\"The shared archive file has a bad magic number.\");\n+      log_info(cds)(\"Not a valid base shared archive: %s\", archive_name);\n@@ -1045,3 +1087,2 @@\n-      os::free(header);\n-      os::close(fd);\n-      vm_exit_during_initialization(\"Not a top shared archive\", archive_name);\n+      log_info(cds)(\"The shared archive file has a bad dynamic magic number.\");\n+      log_info(cds)(\"Not a valid top shared archive: %s\", archive_name);\n@@ -1051,2 +1092,0 @@\n-  os::free(header);\n-  os::close(fd);\n@@ -1063,1 +1102,0 @@\n-\n@@ -1067,0 +1105,3 @@\n+\n+  ReleaseFileHeader rl((void*)dynamic_header, fd);\n+  *base_archive_name = nullptr;\n@@ -1070,2 +1111,0 @@\n-    os::free(dynamic_header);\n-    os::close(fd);\n@@ -1074,5 +1113,6 @@\n-  if (dynamic_header->magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    \/\/ Not a dynamic header, no need to proceed further.\n-    *size = 0;\n-    os::free(dynamic_header);\n-    os::close(fd);\n+\n+  unsigned int magic = dynamic_header->magic();\n+  if (magic == CDS_ARCHIVE_MAGIC) {\n+    \/\/ this is a static archive\n+    \/\/ do not call fail_continue since RequireSharedSpaces will cause to exit\n+    log_info(cds)(\"This is a static archive\");\n@@ -1080,3 +1120,0 @@\n-  }\n-  if (dynamic_header->base_archive_is_default()) {\n-    *base_archive_name = Arguments::get_default_shared_archive_path();\n@@ -1084,1 +1121,3 @@\n-    \/\/ read the base archive name\n+    if (magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+      fail_continue(\"The shared archive file has a bad magic number.\");\n+    }\n@@ -1086,3 +1125,3 @@\n-    if (name_size == 0) {\n-      os::free(dynamic_header);\n-      os::close(fd);\n+    \/\/ read the base archive name\n+    if (name_size <=  0 || name_size > CDS_MAX_PATH) {\n+      fail_continue(\"Base archive name size is wrong.\");\n@@ -1096,3 +1135,2 @@\n-      *base_archive_name = NULL;\n-      os::free(dynamic_header);\n-      os::close(fd);\n+      *size = 0;\n+      *base_archive_name = nullptr;\n@@ -1101,0 +1139,9 @@\n+    sz = sizeof(FileMapHeader);\n+    FileMapHeader* static_header = (FileMapHeader*) os::malloc(sz, mtInternal);\n+    int fdh = os::open(*base_archive_name, O_RDONLY | O_BINARY, 0);\n+    ReleaseFileHeader rl((void*)static_header, fdh);\n+    if (fdh < 0) {\n+      fail_continue(\"Unable to open base archive.\");\n+      return false;\n+    }\n+    return true;\n@@ -1102,4 +1149,0 @@\n-\n-  os::free(dynamic_header);\n-  os::close(fd);\n-  return true;\n@@ -1119,1 +1162,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n+    fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n@@ -1127,1 +1170,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file has a bad magic number.\");\n+    fail_continue(\"The shared archive file has a bad magic number.\");\n@@ -1141,1 +1184,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n+    fail_continue(\"The shared archive file has an incorrect header size.\");\n@@ -1148,1 +1191,1 @@\n-    FileMapInfo::fail_continue(\"JVM version identifier is corrupted.\");\n+    fail_continue(\"JVM version identifier is corrupted.\");\n@@ -1157,1 +1200,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file was created by a different\"\n+    fail_continue(\"The shared archive file was created by a different\"\n@@ -1167,1 +1210,1 @@\n-      FileMapInfo::fail_continue(\"Header checksum verification failed.\");\n+      fail_continue(\"Header checksum verification failed.\");\n@@ -1200,5 +1243,0 @@\n-  if (is_static()) {\n-    _full_path = Arguments::GetSharedArchivePath();\n-  } else {\n-    _full_path = Arguments::GetSharedDynamicArchivePath();\n-  }\n@@ -1276,1 +1314,1 @@\n-    if (base_archive_name != NULL) {\n+    if (base_archive_name != nullptr && header()->base_archive_name_size() != 0) {\n@@ -2197,8 +2235,10 @@\n-\n-  if (!open_for_read()) {\n-    return false;\n-  }\n-  if (!init_from_file(_fd)) {\n-    return false;\n-  }\n-  if (!validate_header()) {\n+  \/\/ AutoCreateSharedArchive\n+  if (!open_for_read() || !init_from_file(_fd) || !validate_header()) {\n+    if (_is_static) {\n+      FileMapInfo::fail_continue(\"Read static archive failed.\");\n+    } else {\n+      FileMapInfo::fail_continue(\"Read dynamic archive failed.\");\n+      if (AutoCreateSharedArchive) {\n+        DynamicDumpSharedSpaces = true;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":93,"deletions":53,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+  bool  validate_archive() NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,5 +95,0 @@\n-static bool file_exists(const char* filename) {\n-  struct stat dummy_stat;\n-  return os::stat(filename, &dummy_stat) == 0;\n-}\n-\n@@ -142,1 +137,1 @@\n-    if (file_exists(archive_name) && !is_regular_file(archive_name)) {\n+    if (os::file_exists(archive_name) && !is_regular_file(archive_name)) {\n@@ -153,1 +148,1 @@\n-    if (!file_exists(archive_name)) {\n+    if (!os::file_exists(archive_name)) {\n@@ -236,1 +231,1 @@\n-  bool file_exist = file_exists(_file_name);\n+  bool file_exist = os::file_exists(_file_name);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3128,0 +3128,11 @@\n+  if (AutoCreateSharedArchive) {\n+    if (SharedArchiveFile == NULL) {\n+      log_info(cds)(\"-XX:+AutoCreateSharedArchive must work with a valid SharedArchiveFile\");\n+      return JNI_ERR;\n+    }\n+    if (ArchiveClassesAtExit != NULL) {\n+      log_info(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      return JNI_ERR;\n+    }\n+  }\n+\n@@ -3509,1 +3520,1 @@\n-    if (is_dumping_archive()) {\n+    if (is_dumping_archive() && !AutoCreateSharedArchive) {\n@@ -3514,1 +3525,1 @@\n-      if (DynamicDumpSharedSpaces) {\n+      if (DynamicDumpSharedSpaces && !AutoCreateSharedArchive) {\n@@ -3534,0 +3545,6 @@\n+          if (!RequireSharedSpaces && AutoCreateSharedArchive) {\n+              \/\/ -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=<file>\n+              \/\/ Will generate dynamic archive based on default shared archive, classes.jsa\n+              SharedArchivePath = get_default_shared_archive_path();\n+              SharedDynamicArchivePath = temp_archive_path;\n+          }\n@@ -3542,1 +3559,11 @@\n-      SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n+      if (!AutoCreateSharedArchive) {\n+        SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n+      } else {\n+        \/\/ -XX:+AutoCreateSharedArchive, if failed to get base archive, set it to default shared archive\n+        int name_size;\n+        bool success =\n+          FileMapInfo::get_base_archive_name_from_header(SharedArchiveFile, &name_size, &SharedArchivePath);\n+        if (!success) {\n+          SharedArchivePath = get_default_shared_archive_path();\n+        }\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1830,0 +1830,3 @@\n+  product(bool, AutoCreateSharedArchive, false,                             \\\n+          \"Create shared archive at exit if cds mapping failed\")            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -505,1 +506,10 @@\n-    DynamicArchive::dump(thread);\n+    if (AutoCreateSharedArchive) {\n+      \/\/ for case base:top, or top only\n+      const char* archive = Arguments::GetSharedDynamicArchivePath();\n+      if (archive == nullptr) {\n+        archive = Arguments::GetSharedArchivePath();\n+      }\n+      DynamicArchive::dump(archive, thread);\n+    } else {\n+      DynamicArchive::dump(thread);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1337,0 +1337,8 @@\n+bool os::file_exists(const char* filename) {\n+  struct stat statbuf;\n+  if (filename == NULL || strlen(filename) == 0) {\n+    return false;\n+  }\n+  return os::stat(filename, &statbuf) == 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -545,0 +545,1 @@\n+  static bool file_exists(const char* file);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,1 +149,3 @@\n-        opts.addSuffix(cmdLineSuffix);\n+        if (cmdLineSuffix != null) {\n+            opts.addSuffix(cmdLineSuffix);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,0 +97,13 @@\n+    \/**\n+     * Excute a JVM to dump a base archive by\n+     *  -Xshare:dump -XX:SharedArchiveFile=baseArchiveName\n+     *\/\n+    public static Result dumpBaseArchive(String baseArchiveName, String... cmdLineSuffix)\n+        throws Exception\n+    {\n+        OutputAnalyzer output = TestCommon.dumpBaseArchive(baseArchiveName, cmdLineSuffix);\n+        CDSOptions opts = new CDSOptions();\n+        opts.setXShareMode(\"dump\");\n+        return new Result(opts, output);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveTestBase.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-                    output.shouldMatch(\"Not a base shared archive:.*top.*.jsa\");\n+                    output.shouldMatch(\"Not a valid base shared archive:.*top.*.jsa\");\n@@ -117,1 +117,1 @@\n-                    output.shouldMatch(\"Not a top shared archive:.*base.*.jsa\");\n+                    output.shouldMatch(\"Not a valid top shared archive:.*base.*.jsa\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/SharedArchiveFileOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test -XX:+AutoCreateSharedArchive feature\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build Hello\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar TestAutoCreateSharedArchive\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.cds.CDSArchiveUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TestAutoCreateSharedArchive extends DynamicArchiveTestBase {\n+    private static final String BASE_NAME = CDSTestUtils.getOutputFileName(\"base.jsa\");\n+    private static final String TOP_NAME  = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+    private static final String mainAppClass = \"Hello\";\n+    private static final String HELLO_SOURCE = \"Hello source: shared objects file (top)\";\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(TestAutoCreateSharedArchive::testAutoCreateSharedArchive);\n+    }\n+\n+    public static void checkFileExists(String fileName) throws Exception {\n+        File file = new File(fileName);\n+        if (!file.exists()) {\n+             throw new IOException(\"Archive \" + file.getName() + \" is not autamatically created!\");\n+        }\n+    }\n+\n+    public static String startNewArchive(String testName) {\n+        String newArchiveName = TestCommon.getNewArchiveName(testName);\n+        TestCommon.setCurrentArchiveName(newArchiveName);\n+        return newArchiveName;\n+    }\n+\n+    public static void print(String message) {\n+        System.out.println(message);\n+    }\n+\n+    private static void testAutoCreateSharedArchive() throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+\n+        File archiveFile = new File(TOP_NAME);\n+        if (archiveFile.exists()) {\n+          archiveFile.delete();\n+        }\n+\n+        \/\/ 1. run with non-existing archive should automatically create dynamic archive\n+        print(\"1. run with non-existing archive should automatically create dynamic archive\");\n+        run(TOP_NAME,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(\"Dumping shared data to file:\")\n+                      .shouldContain(TOP_NAME);\n+                });\n+        checkFileExists(TOP_NAME);\n+\n+        \/\/ 2. run with the created dynamic archive should pass\n+        print(\"2. run with the created dynamic archive should pass\");\n+        run(TOP_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+\n+        \/\/ 3. run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\n+        print(\"3. run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\");\n+        run(TOP_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+\n+        \/\/ 4. run with a bad versioned archive should create dynamic archive\n+        print(\"4. run with a bad versioned archive should create dynamic archive\");\n+        archiveFile = new File(TOP_NAME);\n+        String modVersion = startNewArchive(\"modify-version\");\n+        File copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n+\n+        run(modVersion,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                });\n+        checkFileExists(modVersion);\n+\n+        \/\/ 5. run with the new created archive should pass\n+        print(\"5. run with the new created archive should pass\");\n+         run(modVersion,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+\n+         \/\/ 6. dump base archive and top archive\n+         print(\"6. dump base archive \" + BASE_NAME);\n+         dumpBaseArchive(BASE_NAME, null)\n+             .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+             });\n+         checkFileExists(BASE_NAME);\n+\n+         \/\/ 7. dump top based on base\n+         print(\"7. dump top based on base\");\n+         dump2(BASE_NAME, TOP_NAME,\n+               \"-Xlog:cds\",\n+               \"-cp\", appJar, mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldHaveExitValue(0)\n+                       .shouldContain(\"Dumping shared data to file:\")\n+                       .shouldContain(TOP_NAME);\n+             });\n+\n+         \/\/ 8. run with base and top\"\n+         print(\"8. run with base and top\");\n+         run2(BASE_NAME, TOP_NAME,\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=info\",\n+              \"-Xlog:class+load\",\n+              \"-cp\", appJar,\n+              mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldHaveExitValue(0)\n+                       .shouldContain(HELLO_SOURCE);\n+             });\n+\n+\n+         File topFile = new File(TOP_NAME);\n+         \/\/ 9. damaged top, regenerate top\n+         print(\"9. damaged top, regenerate top\");\n+         String modHeader = startNewArchive(\"modify-header\");\n+         copiedJsa = CDSArchiveUtils.copyArchiveFile(topFile, modHeader);\n+         CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, 0xffffffff);\n+         run2(BASE_NAME, modHeader,\n+              \"-Xshare:auto\",\n+              \"-XX:+AutoCreateSharedArchive\",\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=info\",\n+              \"-cp\", appJar,\n+              mainAppClass)\n+              .assertNormalExit(output -> {\n+                  output.shouldHaveExitValue(0)\n+                        .shouldContain(\"Dumping shared data to file:\")\n+                        .shouldContain(modHeader)\n+                        .shouldContain(\"Regenerate MethodHandle Holder classes\");\n+              });\n+         File baseFile = new File(BASE_NAME);\n+         \/\/ 10. screw up base archive\n+         print(\"10. screw up base archive\");\n+         String modBase = startNewArchive(\"modify-base\");\n+         copiedJsa = CDSArchiveUtils.copyArchiveFile(topFile, modBase);\n+         CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, 0x0);\n+         run2(modBase, TOP_NAME,\n+              \"-Xshare:auto\",\n+              \"-XX:+AutoCreateSharedArchive\",\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=info\",\n+              \"-cp\", appJar,\n+              mainAppClass)\n+              .assertNormalExit(output -> {\n+                  output.shouldContain(\"Unable to map shared spaces\")\n+                        .shouldContain(\"Read static archive failed\")\n+                        .shouldContain(\"Hello World\")\n+                        .shouldNotContain(\"Dumping shared data to file:\");\n+              });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"}]}