{"files":[{"patch":"@@ -1385,8 +1385,0 @@\n-static bool file_exists(const char* filename) {\n-  struct stat statbuf;\n-  if (filename == NULL || strlen(filename) == 0) {\n-    return false;\n-  }\n-  return os::stat(filename, &statbuf) == 0;\n-}\n-\n@@ -2427,1 +2419,1 @@\n-      if (file_exists(hbuf_level)) {\n+      if (os::file_exists(hbuf_level)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-  assert(UseSharedSpaces && RecordDynamicDumpInfo, \"already checked in arguments.cpp?\");\n+  assert((UseSharedSpaces && RecordDynamicDumpInfo) || AutoCreateSharedArchive, \"already checked in arguments.cpp?\");\n@@ -374,1 +374,4 @@\n-    prepare_for_dynamic_dumping();\n+    if (!AutoCreateSharedArchive) {\n+      \/\/ When dump at exit, prepare_for_dynamic_dumping already called.\n+      prepare_for_dynamic_dumping();\n+    }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,0 +79,16 @@\n+\/\/ Utility class to release file header memory\n+\/\/ and close open file handle\n+class ReleaseFileHeader {\n+  void* _header;\n+  int _fd;\n+ public:\n+  ReleaseFileHeader(void* header, int fd) {\n+    _header = header;\n+    _fd = fd;\n+  }\n+  ~ReleaseFileHeader() {\n+    os::free(_header);\n+    os::close(_fd);\n+  }\n+};\n+\n@@ -123,1 +139,0 @@\n-        ResourceMark rm;\n@@ -189,0 +204,11 @@\n+  if (is_static) {\n+    _full_path = Arguments::GetSharedArchivePath();\n+  } else {\n+    _full_path = Arguments::GetSharedDynamicArchivePath();\n+  }\n+  if (AutoCreateSharedArchive) {\n+     if (!validate_archive ()) {\n+       _full_path = Arguments::get_default_shared_archive_path();\n+       DynamicDumpSharedSpaces = true;\n+     }\n+  }\n@@ -199,0 +225,16 @@\n+  if (_file_open) {\n+    os::close(_fd);\n+  }\n+}\n+\n+\/\/ Do preliminary validation on archive. More checks are in initialization.\n+bool FileMapInfo::validate_archive() {\n+  if (!os::file_exists(_full_path)) {\n+    return false;\n+  }\n+  \/\/ validate header info\n+  if (!check_archive(_full_path, _is_static)) {\n+    return false;\n+  }\n+\n+  return true;\n@@ -1026,0 +1068,2 @@\n+\n+  ReleaseFileHeader rl(header, fd);\n@@ -1029,2 +1073,0 @@\n-    os::free(header);\n-    os::close(fd);\n@@ -1037,3 +1079,3 @@\n-      os::free(header);\n-      os::close(fd);\n-      vm_exit_during_initialization(\"Not a base shared archive\", archive_name);\n+      log_info(cds)(\"The shared archive file has a bad magic number.\");\n+      log_info(cds)(\"Not a base shared archive: %s\", archive_name);\n+      \/\/ vm_exit_during_initialization(\"Not a base shared archive\", archive_name);\n@@ -1045,3 +1087,3 @@\n-      os::free(header);\n-      os::close(fd);\n-      vm_exit_during_initialization(\"Not a top shared archive\", archive_name);\n+      log_info(cds)(\"The shared archive file has a bad dynamic magic number.\");\n+      log_info(cds)(\"Not a top shared archive: %s\", archive_name);\n+      \/\/ vm_exit_during_initialization(\"Not a top shared archive\", archive_name);\n@@ -1051,2 +1093,0 @@\n-  os::free(header);\n-  os::close(fd);\n@@ -1063,1 +1103,0 @@\n-\n@@ -1067,0 +1106,3 @@\n+\n+  ReleaseFileHeader rl((void*)dynamic_header, fd);\n+  *base_archive_name = nullptr;\n@@ -1070,2 +1112,0 @@\n-    os::free(dynamic_header);\n-    os::close(fd);\n@@ -1074,5 +1114,5 @@\n-  if (dynamic_header->magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    \/\/ Not a dynamic header, no need to proceed further.\n-    *size = 0;\n-    os::free(dynamic_header);\n-    os::close(fd);\n+  unsigned int magic = dynamic_header->magic();\n+  if (magic == CDS_ARCHIVE_MAGIC) {\n+    \/\/ this is a static archive\n+    \/\/ do not call fail_continue since RequireSharedSpaces will cause to exit\n+    log_info(cds)(\"This is a static archive\");\n@@ -1080,4 +1120,1 @@\n-  }\n-  if (dynamic_header->base_archive_is_default()) {\n-    *base_archive_name = Arguments::get_default_shared_archive_path();\n-  } else {\n+  } else if (magic == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n@@ -1087,2 +1124,1 @@\n-      os::free(dynamic_header);\n-      os::close(fd);\n+      fail_continue(\"Base archive name size is 0.\");\n@@ -1096,3 +1132,1 @@\n-      *base_archive_name = NULL;\n-      os::free(dynamic_header);\n-      os::close(fd);\n+      *base_archive_name = nullptr;\n@@ -1101,0 +1135,4 @@\n+  } else {\n+    \/\/ not a valid shared archive or the archive is damaged for testing purpose\n+    fail_continue(\"The shared archive file has a bad magic number.\");\n+    return false;\n@@ -1102,3 +1140,0 @@\n-\n-  os::free(dynamic_header);\n-  os::close(fd);\n@@ -1200,5 +1235,0 @@\n-  if (is_static()) {\n-    _full_path = Arguments::GetSharedArchivePath();\n-  } else {\n-    _full_path = Arguments::GetSharedDynamicArchivePath();\n-  }\n@@ -1276,1 +1306,1 @@\n-    if (base_archive_name != NULL) {\n+    if (base_archive_name != nullptr && header()->base_archive_name_size() != 0) {\n@@ -2197,8 +2227,10 @@\n-\n-  if (!open_for_read()) {\n-    return false;\n-  }\n-  if (!init_from_file(_fd)) {\n-    return false;\n-  }\n-  if (!validate_header()) {\n+  \/\/ AutoCreateSharedArchive\n+  if (!open_for_read() || !init_from_file(_fd) || !validate_header()) {\n+    if (_is_static) {\n+      FileMapInfo::fail_continue(\"Read static archive failed.\");\n+    } else {\n+      FileMapInfo::fail_continue(\"Read dynamic archive failed.\");\n+      if (AutoCreateSharedArchive) {\n+        DynamicDumpSharedSpaces = true;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":77,"deletions":45,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+  bool  validate_archive() NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,5 +95,0 @@\n-static bool file_exists(const char* filename) {\n-  struct stat dummy_stat;\n-  return os::stat(filename, &dummy_stat) == 0;\n-}\n-\n@@ -142,1 +137,1 @@\n-    if (file_exists(archive_name) && !is_regular_file(archive_name)) {\n+    if (os::file_exists(archive_name) && !is_regular_file(archive_name)) {\n@@ -153,1 +148,1 @@\n-    if (!file_exists(archive_name)) {\n+    if (!os::file_exists(archive_name)) {\n@@ -236,1 +231,1 @@\n-  bool file_exist = file_exists(_file_name);\n+  bool file_exist = os::file_exists(_file_name);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3128,0 +3128,11 @@\n+  if (AutoCreateSharedArchive) {\n+    if (SharedArchiveFile == NULL) {\n+      log_info(cds)(\"-XX:+AutoCreateSharedArchive must work with a valid SharedArchiveFile\");\n+      return JNI_ERR;\n+    }\n+    if (ArchiveClassesAtExit != NULL) {\n+      log_info(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      return JNI_ERR;\n+    }\n+  }\n+\n@@ -3509,1 +3520,1 @@\n-    if (is_dumping_archive()) {\n+    if (is_dumping_archive() && !AutoCreateSharedArchive) {\n@@ -3514,1 +3525,1 @@\n-      if (DynamicDumpSharedSpaces) {\n+      if (DynamicDumpSharedSpaces && !AutoCreateSharedArchive) {\n@@ -3542,1 +3553,11 @@\n-      SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n+      if (!AutoCreateSharedArchive) {\n+        SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n+      } else {\n+        \/\/ -XX:+AutoCreateSharedArchive, if failed to get base archive, set it to default shared archive\n+        int name_size;\n+        bool success =\n+          FileMapInfo::get_base_archive_name_from_header(SharedArchiveFile, &name_size, &SharedArchivePath);\n+        if (!success) {\n+          SharedArchivePath = get_default_shared_archive_path();\n+        }\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1830,0 +1830,3 @@\n+  product(bool, AutoCreateSharedArchive, false,                             \\\n+          \"Create shared archive at exit if cds mapping failed\")            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -505,1 +506,10 @@\n-    DynamicArchive::dump(thread);\n+    if (AutoCreateSharedArchive) {\n+      \/\/ for case base:top, or top only\n+      const char* archive = Arguments::GetSharedDynamicArchivePath();\n+      if (archive == nullptr) {\n+        archive = Arguments::GetSharedArchivePath();\n+      }\n+      DynamicArchive::dump(archive, thread);\n+    } else {\n+      DynamicArchive::dump(thread);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1337,0 +1337,8 @@\n+bool os::file_exists(const char* filename) {\n+  struct stat statbuf;\n+  if (filename == NULL || strlen(filename) == 0) {\n+    return false;\n+  }\n+  return os::stat(filename, &statbuf) == 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -545,0 +545,1 @@\n+  static bool file_exists(const char* file);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test -XX:+AutoCreateSharedArchive feature\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build Hello\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar TestAutoCreateSharedArchive\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.cds.CDSArchiveUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TestAutoCreateSharedArchive extends DynamicArchiveTestBase {\n+    private static final String ARCHIVE_NAME = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+    private static final String HELLO_SOURCE = \"Hello source: shared objects file (top)\";\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(TestAutoCreateSharedArchive::testAutoCreateSharedArchive);\n+    }\n+\n+    public static void checkFileExists(String fileName) throws Exception {\n+        File file = new File(fileName);\n+        if (!file.exists()) {\n+             throw new IOException(\"Archive \" + file.getName() + \" is not autamatically created!\");\n+        }\n+    }\n+\n+    public static String startNewArchive(String testName) {\n+        String newArchiveName = TestCommon.getNewArchiveName(testName);\n+        TestCommon.setCurrentArchiveName(newArchiveName);\n+        return newArchiveName;\n+    }\n+\n+    private static void testAutoCreateSharedArchive() throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+        String mainAppClass = \"Hello\";\n+\n+        File archiveFile = new File(ARCHIVE_NAME);\n+        if (archiveFile.exists()) {\n+          archiveFile.delete();\n+        }\n+\n+        \/\/ 1. run with non-existing archive should automatically create dynamic archive\n+        System.out.println(\"1. run with non-existing archive should automatically create dynamic archive\");\n+        run(ARCHIVE_NAME,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                });\n+        checkFileExists(ARCHIVE_NAME);\n+\n+        \/\/ 2. run with the created dynamic archive should pass\n+        System.out.println(\"2. run with the created dynamic archive should pass\");\n+        run(ARCHIVE_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+\n+        \/\/ 3. run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\n+        System.out.println(\"3. run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\");\n+        run(ARCHIVE_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+\n+        \/\/ 4. run with a bad versioned archive should create dynamic archive\n+        System.out.println(\"4. run with a bad versioned archive should create dynamic archive\");\n+        archiveFile = new File(ARCHIVE_NAME);\n+        String modVersion = startNewArchive(\"modify-version\");\n+        File copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n+\n+        run(modVersion,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                });\n+        checkFileExists(modVersion);\n+\n+        \/\/ 5. run with the new created archive should pass\n+        System.out.println(\"5. run with the new created archive should pass\");\n+         run(modVersion,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"}]}