{"files":[{"patch":"@@ -134,1 +134,2 @@\n-    private volatile IdleConnectionTimeoutEvent idleConnectionTimeoutEvent;  \/\/ may be null\n+    \/\/ may be null; must be accessed\/updated with the stateLock held\n+    private IdleConnectionTimeoutEvent idleConnectionTimeoutEvent;\n@@ -200,1 +201,1 @@\n-        private volatile boolean cancelled;\n+        private boolean cancelled;\n@@ -1131,8 +1132,7 @@\n-                \/\/ idleConnectionTimerEvent is always accessed within a lock protected block\n-                IdleConnectionTimeoutEvent idleTimeoutEvent = this.idleConnectionTimeoutEvent;\n-                if (streams.isEmpty() && idleTimeoutEvent == null) {\n-                    this.idleConnectionTimeoutEvent = idleTimeoutEvent =\n-                            client().idleConnectionTimeout().map(IdleConnectionTimeoutEvent::new)\n-                                    .orElse(null);\n-                    if (idleTimeoutEvent != null) {\n-                        client().registerTimer(idleTimeoutEvent);\n+                \/\/ idleConnectionTimeoutEvent is always accessed within a lock protected block\n+                if (streams.isEmpty() && idleConnectionTimeoutEvent == null) {\n+                    idleConnectionTimeoutEvent = client().idleConnectionTimeout()\n+                            .map(IdleConnectionTimeoutEvent::new)\n+                            .orElse(null);\n+                    if (idleConnectionTimeoutEvent != null) {\n+                        client().registerTimer(idleConnectionTimeoutEvent);\n@@ -1336,5 +1336,1 @@\n-            final IdleConnectionTimeoutEvent idleTimeoutEvent = this.idleConnectionTimeoutEvent;\n-            if (idleTimeoutEvent != null) {\n-                this.idleConnectionTimeoutEvent = null;\n-                idleTimeoutEvent.cancel();\n-            }\n+            cancelIdleShutdownEvent();\n@@ -1349,0 +1345,13 @@\n+    \/**\n+     * Cancels any event that might have been scheduled to shutdown this connection. Must be called\n+     * with the stateLock held.\n+     *\/\n+    private void cancelIdleShutdownEvent() {\n+        assert stateLock.isHeldByCurrentThread() : \"Current thread doesn't hold \" + stateLock;\n+        if (idleConnectionTimeoutEvent == null) {\n+            return;\n+        }\n+        idleConnectionTimeoutEvent.cancel();\n+        idleConnectionTimeoutEvent = null;\n+    }\n+\n@@ -1361,6 +1370,1 @@\n-                \/\/ idleConnectionTimerEvent is always accessed within a lock protected block\n-                final IdleConnectionTimeoutEvent idleTimeoutEvent = this.idleConnectionTimeoutEvent;\n-                if (idleTimeoutEvent != null) {\n-                    this.idleConnectionTimeoutEvent = null;\n-                    idleTimeoutEvent.cancel();\n-                }\n+                cancelIdleShutdownEvent();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -114,0 +114,5 @@\n+        \/\/ the wait time, which represents the time to wait before firing off additional requests,\n+        \/\/ is intentionally a few milliseconds smaller than the h2 idle connection timeout,\n+        \/\/ to allow for the requests to reach the place where connection checkout from the pool\n+        \/\/ happens and thus allow the code to race with the idle connection timer task\n+        \/\/ closing the connection.\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/IdlePooledConnectionTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}