{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import java.net.InetSocketAddress;\n-import java.net.URI;\n@@ -74,1 +72,2 @@\n-    private final ReentrantLock lock = new ReentrantLock();\n+    \/\/ used when dealing with connections in the pool\n+    private final ReentrantLock connectionPoolLock = new ReentrantLock();\n@@ -103,1 +102,1 @@\n-        lock.lock();\n+        connectionPoolLock.lock();\n@@ -108,1 +107,1 @@\n-                    if (!connection.isOpen() || !connection.reserveStream(true)) {\n+                    if (!connection.tryReserveForPoolCheckout() || !connection.reserveStream(true)) {\n@@ -110,2 +109,3 @@\n-                            debug.log(\"removing found closed or closing connection: %s\", connection);\n-                        deleteConnection(connection);\n+                            debug.log(\"removing connection from pool since it couldn't be\" +\n+                                    \" reserved for use: %s\", connection);\n+                        removeFromPool(connection);\n@@ -131,1 +131,1 @@\n-            lock.unlock();\n+            connectionPoolLock.unlock();\n@@ -136,1 +136,1 @@\n-                    lock.lock();\n+                    connectionPoolLock.lock();\n@@ -151,1 +151,1 @@\n-                        lock.unlock();\n+                        connectionPoolLock.unlock();\n@@ -172,1 +172,1 @@\n-        lock.lock();\n+        connectionPoolLock.lock();\n@@ -195,1 +195,1 @@\n-            lock.unlock();\n+            connectionPoolLock.unlock();\n@@ -199,1 +199,7 @@\n-    void deleteConnection(Http2Connection c) {\n+    \/**\n+     * Removes the connection from the pool (if it was in the pool).\n+     * This method doesn't close the connection.\n+     *\n+     * @param c the connection to remove from the pool\n+     *\/\n+    void removeFromPool(Http2Connection c) {\n@@ -202,1 +208,1 @@\n-        lock.lock();\n+        connectionPoolLock.lock();\n@@ -209,1 +215,1 @@\n-            lock.unlock();\n+            connectionPoolLock.unlock();\n@@ -218,1 +224,1 @@\n-        lock.lock();\n+        connectionPoolLock.lock();\n@@ -222,1 +228,1 @@\n-            lock.unlock();\n+            connectionPoolLock.unlock();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":23,"deletions":17,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -134,1 +134,2 @@\n-    private IdleConnectionTimeoutEvent idleConnectionTimeoutEvent;  \/\/ may be null\n+    \/\/ may be null; must be accessed\/updated with the stateLock held\n+    private IdleConnectionTimeoutEvent idleConnectionTimeoutEvent;\n@@ -199,1 +200,2 @@\n-        private boolean fired;\n+        \/\/ expected to be accessed\/updated with \"stateLock\" being held\n+        private boolean cancelled;\n@@ -203,1 +205,0 @@\n-            fired = false;\n@@ -206,0 +207,4 @@\n+        \/**\n+         * {@link #shutdown(Throwable) Shuts down} the connection, unless this event is\n+         * {@link #cancelled}\n+         *\/\n@@ -208,1 +213,22 @@\n-            fired = true;\n+            \/\/ first check if the connection is still idle.\n+            \/\/ must be done with the \"stateLock\" held, to allow for synchronizing actions like\n+            \/\/ closing the connection and checking out from connection pool (which too is expected\n+            \/\/ to use this same lock)\n+            stateLock.lock();\n+            try {\n+                if (cancelled) {\n+                    if (debug.on()) {\n+                        debug.log(\"Not initiating idle connection shutdown\");\n+                    }\n+                    return;\n+                }\n+                if (!markIdleShutdownInitiated()) {\n+                    if (debug.on()) {\n+                        debug.log(\"Unexpected state %s, skipping idle connection shutdown\",\n+                                describeClosedState(closedState));\n+                    }\n+                    return;\n+                }\n+            } finally {\n+                stateLock.unlock();\n+            }\n@@ -210,1 +236,1 @@\n-                debug.log(\"HTTP connection idle for too long\");\n+                debug.log(\"Initiating shutdown of HTTP connection which is idle for too long\");\n@@ -212,1 +238,2 @@\n-            HttpConnectTimeoutException hte = new HttpConnectTimeoutException(\"HTTP connection idle, no active streams. Shutting down.\");\n+            HttpConnectTimeoutException hte = new HttpConnectTimeoutException(\n+                    \"HTTP connection idle, no active streams. Shutting down.\");\n@@ -216,0 +243,12 @@\n+        \/**\n+         * Cancels this event. Should be called with stateLock held\n+         *\/\n+        void cancel() {\n+            assert stateLock.isHeldByCurrentThread() : \"Current thread doesn't hold \" + stateLock;\n+            \/\/ mark as cancelled to prevent potentially already triggered event from actually\n+            \/\/ doing the shutdown\n+            this.cancelled = true;\n+            \/\/ cancel the timer to prevent the event from being triggered (if it hasn't already)\n+            client().cancelTimer(this);\n+        }\n+\n@@ -220,4 +259,0 @@\n-\n-        public boolean isFired() {\n-            return fired;\n-        }\n@@ -297,2 +332,5 @@\n-    private final Lock stateLock = new ReentrantLock();\n-    volatile int closedState;\n+    \/\/ state when idle connection management initiates a shutdown of the connection, after\n+    \/\/ which the connection will go into SHUTDOWN_REQUESTED state\n+    private static final int IDLE_SHUTDOWN_INITIATED = 8;\n+    private final ReentrantLock stateLock = new ReentrantLock();\n+    private volatile int closedState;\n@@ -499,1 +537,1 @@\n-            client2.deleteConnection(this);\n+            client2.removeFromPool(this);\n@@ -503,1 +541,1 @@\n-            client2.deleteConnection(this);\n+            client2.removeFromPool(this);\n@@ -778,1 +816,1 @@\n-        client2.deleteConnection(this);\n+        client2.removeFromPool(this);\n@@ -997,2 +1035,1 @@\n-        return !isMarked(closedState, SHUTDOWN_REQUESTED)\n-                && connection.channel().isOpen();\n+        return !isMarkedForShutdown() && connection.channel().isOpen();\n@@ -1095,1 +1132,1 @@\n-                \/\/ idleConnectionTimerEvent is always accessed within a lock protected block\n+                \/\/ idleConnectionTimeoutEvent is always accessed within a lock protected block\n@@ -1098,1 +1135,2 @@\n-                            .map(IdleConnectionTimeoutEvent::new).orElse(null);\n+                            .map(IdleConnectionTimeoutEvent::new)\n+                            .orElse(null);\n@@ -1286,0 +1324,34 @@\n+    \/**\n+     * Attempts to notify the idle connection management that this connection should\n+     * be considered \"in use\". This way the idle connection management doesn't close\n+     * this connection during the time the connection is handed out from the pool and any\n+     * new stream created on that connection.\n+     * @return true if the connection has been successfully reserved and is {@link #isOpen()}. false\n+     *          otherwise; in which case the connection must not be handed out from the pool.\n+     *\/\n+    boolean tryReserveForPoolCheckout() {\n+        \/\/ must be done with \"stateLock\" held to co-ordinate idle connection management\n+        stateLock.lock();\n+        try {\n+            cancelIdleShutdownEvent();\n+            \/\/ consider the reservation successful only if the connection's state hasn't moved\n+            \/\/ to \"being closed\"\n+            return isOpen();\n+        } finally {\n+            stateLock.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * Cancels any event that might have been scheduled to shutdown this connection. Must be called\n+     * with the stateLock held.\n+     *\/\n+    private void cancelIdleShutdownEvent() {\n+        assert stateLock.isHeldByCurrentThread() : \"Current thread doesn't hold \" + stateLock;\n+        if (idleConnectionTimeoutEvent == null) {\n+            return;\n+        }\n+        idleConnectionTimeoutEvent.cancel();\n+        idleConnectionTimeoutEvent = null;\n+    }\n+\n@@ -1292,1 +1364,1 @@\n-            if (!isMarked(closedState, SHUTDOWN_REQUESTED)) {\n+            if (!isMarkedForShutdown()) {\n@@ -1298,5 +1370,1 @@\n-                \/\/ idleConnectionTimerEvent is always accessed within a lock protected block\n-                if (idleConnectionTimeoutEvent != null) {\n-                    client().cancelTimer(idleConnectionTimeoutEvent);\n-                    idleConnectionTimeoutEvent = null;\n-                }\n+                cancelIdleShutdownEvent();\n@@ -1666,0 +1734,6 @@\n+    private boolean isMarkedForShutdown() {\n+        final int closedSt = closedState;\n+        return isMarked(closedSt, IDLE_SHUTDOWN_INITIATED)\n+                || isMarked(closedSt, SHUTDOWN_REQUESTED);\n+    }\n+\n@@ -1678,0 +1752,4 @@\n+    private boolean markIdleShutdownInitiated() {\n+        return markClosedState(IDLE_SHUTDOWN_INITIATED);\n+    }\n+\n@@ -1691,0 +1769,3 @@\n+        if (isMarked(state, IDLE_SHUTDOWN_INITIATED)) {\n+            desc = \"idle-shutdown-initiated\";\n+        }\n@@ -1692,1 +1773,1 @@\n-            desc = \"shutdown\";\n+            desc = desc == null ? \"shutdown\" : desc + \"+shutdown\";\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":107,"deletions":26,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+\n+\/*\n+ * @test\n+ * @bug 8312433\n+ * @summary verify that the HttpClient's HTTP2 idle connection management doesn't close a connection\n+ *          when that connection has been handed out from the pool to a caller\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *\n+ * @run junit\/othervm   -Djdk.internal.httpclient.debug=true\n+ *                      -Djdk.httpclient.keepalive.timeout.h2=3\n+ *                      IdlePooledConnectionTest\n+ *\/\n+public class IdlePooledConnectionTest {\n+\n+    private static final String ALL_OK_PATH = \"\/allOK\";\n+    private static HttpTestServer h2Server;\n+    private static URI allOKUri;\n+    private static final String H2_KEEPALIVE_TIMEOUT_PROP = \"jdk.httpclient.keepalive.timeout.h2\";\n+    private static final String KEEPALIVE_TIMEOUT_PROP = \"jdk.httpclient.keepalive.timeout\";\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        h2Server = HttpTestServer.create(HTTP_2);\n+        h2Server.addHandler(new AllOKHandler(), ALL_OK_PATH);\n+        h2Server.start();\n+        System.err.println(\"Started H2 server at \" + h2Server.serverAuthority());\n+        allOKUri = new URI(\"http:\/\/\" + h2Server.serverAuthority() + ALL_OK_PATH);\n+    }\n+\n+    @AfterAll\n+    static void afterAll() throws Exception {\n+        if (h2Server != null) {\n+            System.err.println(\"Stopping h2 server: \" + h2Server.serverAuthority());\n+            h2Server.stop();\n+        }\n+    }\n+\n+    \/\/ just returns a 200 HTTP response for all requests\n+    private static final class AllOKHandler implements HttpServerAdapters.HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            System.err.println(\"Responding with 200 response code for request \"\n+                    + exchange.getRequestURI());\n+            exchange.sendResponseHeaders(200, 0);\n+        }\n+    }\n+\n+    \/*\n+     * Issues a HTTP2 request against a server and expects it to succeed.\n+     * The connection that was used is internally pooled by the HttpClient implementation.\n+     * Then waits for the H2 idle connection timeout, before again firing several concurrent HTTP2\n+     * requests against the same server. It is expected that all these requests complete\n+     * successfully without running into a race condition where the H2 idle connection management\n+     * closes the (pooled) connection during the time connection has been handed out to a caller\n+     * and a new stream hasn't yet been created.\n+     *\/\n+    @Test\n+    public void testPooledConnection() throws Exception {\n+        final Duration h2TimeoutDuration = getEffectiveH2IdleTimeoutDuration();\n+        assertNotNull(h2TimeoutDuration, \"H2 idle connection timeout cannot be null\");\n+        \/\/ the wait time, which represents the time to wait before firing off additional requests,\n+        \/\/ is intentionally a few milliseconds smaller than the h2 idle connection timeout,\n+        \/\/ to allow for the requests to reach the place where connection checkout from the pool\n+        \/\/ happens and thus allow the code to race with the idle connection timer task\n+        \/\/ closing the connection.\n+        final long waitTimeMillis = TimeUnit.of(ChronoUnit.MILLIS).convert(h2TimeoutDuration) - 5;\n+        try (final HttpClient client = HttpClient.newBuilder().proxy(NO_PROXY).build()) {\n+            final HttpRequest request = HttpRequest.newBuilder(allOKUri)\n+                    .GET().version(HTTP_2).build();\n+            \/\/ keep ready the additional concurrent requests that we will fire later.\n+            \/\/ we do this now so that when it's time to fire off these additional requests,\n+            \/\/ this main thread does as little work as possible to increase the chances of a\n+            \/\/ race condition in idle connection management closing a pooled connection\n+            \/\/ and new requests being fired\n+            final Callable<HttpResponse<Void>> task = () -> client.send(request,\n+                    BodyHandlers.discarding());\n+            final List<Callable<HttpResponse<Void>>> tasks = new ArrayList<>();\n+            final int numAdditionalReqs = 20;\n+            for (int i = 0; i < numAdditionalReqs; i++) {\n+                tasks.add(task);\n+            }\n+            \/\/ issue the first request\n+            System.err.println(\"issuing first request: \" + request);\n+            final HttpResponse<Void> firstResp = client.send(request, BodyHandlers.discarding());\n+            assertEquals(200, firstResp.statusCode(), \"unexpected response code for request \"\n+                    + request);\n+            System.err.println(\"waiting for \" + waitTimeMillis + \" milli seconds\" +\n+                    \" before issuing additional requests\");\n+            Thread.sleep(waitTimeMillis);\n+            \/\/ issue additional concurrent requests\n+            final List<Future<HttpResponse<Void>>> responses;\n+            try (final ExecutorService executor = Executors.newFixedThreadPool(numAdditionalReqs)) {\n+                responses = executor.invokeAll(tasks);\n+            }\n+            System.err.println(\"All \" + responses.size() + \" requests completed, now\" +\n+                    \" verifying each response\");\n+            \/\/ verify all requests succeeded\n+            for (final Future<HttpResponse<Void>> future : responses) {\n+                final HttpResponse<Void> rsp = future.get();\n+                assertEquals(200, rsp.statusCode(), \"unexpected response code for request \"\n+                        + request);\n+            }\n+        }\n+    }\n+\n+    \/\/ returns the effective idle timeout duration of a HTTP2 connection\n+    private static Duration getEffectiveH2IdleTimeoutDuration() {\n+        final long keepAliveTimeoutInSecs = getNetProp(KEEPALIVE_TIMEOUT_PROP, 30);\n+        final long h2TimeoutInSecs = getNetProp(H2_KEEPALIVE_TIMEOUT_PROP, keepAliveTimeoutInSecs);\n+        return Duration.of(h2TimeoutInSecs, ChronoUnit.SECONDS);\n+    }\n+\n+    private static long getNetProp(final String prop, final long def) {\n+        final String s = Utils.getNetProperty(prop);\n+        if (s == null) {\n+            return def;\n+        }\n+        try {\n+            final long timeoutVal = Long.parseLong(s);\n+            return timeoutVal >= 0 ? timeoutVal : def;\n+        } catch (NumberFormatException ignored) {\n+            return def;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/IdlePooledConnectionTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}