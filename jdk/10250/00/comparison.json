{"files":[{"patch":"@@ -409,1 +409,1 @@\n-void Compile::remove_useless_nodes(Unique_Node_List &useful) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n@@ -432,1 +432,1 @@\n-      record_for_igvn(n->unique_out());\n+      worklist->push(n->unique_out());\n@@ -443,0 +443,5 @@\n+#ifdef ASSERT\n+  if (_modified_nodes != NULL) {\n+    _modified_nodes->remove_useless_nodes(useful.member_set());\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -954,1 +954,1 @@\n-  void              remove_useless_nodes (Unique_Node_List &useful);\n+  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-  C->remove_useless_nodes(_useful);\n+  C->disconnect_useless_nodes(_useful, worklist);\n@@ -1771,0 +1771,3 @@\n+  assert(_root_and_safepoints.size() == 0, \"must be empty (unused)\");\n+  _root_and_safepoints.push(C->root());\n+\n@@ -1776,2 +1779,3 @@\n-      \/\/ Keep track of SafePoint nodes for PhaseCCP::transform()\n-      _safepoints.push(n);\n+      \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n+      \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n+      _root_and_safepoints.push(n);\n@@ -1955,2 +1959,0 @@\n-  new_node = transform_once(n);     \/\/ Check for constant\n-  _nodes.map( n->_idx, new_node );  \/\/ Flag as having been cloned\n@@ -1958,2 +1960,2 @@\n-  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n-  GrowableArray <Node *> trstack(C->live_nodes() >> 1);\n+  assert(n->is_Root(), \"traversal must start at root\");\n+  assert(_root_and_safepoints.member(n), \"root (n) must be in list\");\n@@ -1961,1 +1963,3 @@\n-  trstack.push(new_node);           \/\/ Process children of cloned node\n+  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n+  GrowableArray <Node *> transform_stack(C->live_nodes() >> 1);\n+  Unique_Node_List useful; \/\/ track all visited nodes, so that we can remove the complement\n@@ -1963,0 +1967,1 @@\n+  \/\/ Initialize the traversal.\n@@ -1970,2 +1975,2 @@\n-  for (uint i = 0; i < _safepoints.size(); ++i) {\n-    Node* nn = _safepoints.at(i);\n+  for (uint i = 0; i < _root_and_safepoints.size(); ++i) {\n+    Node* nn = _root_and_safepoints.at(i);\n@@ -1974,3 +1979,4 @@\n-    new_node = transform_once(nn);\n-    _nodes.map(nn->_idx, new_node);\n-    trstack.push(new_node);\n+    new_node = transform_once(nn);  \/\/ Check for constant\n+    _nodes.map(nn->_idx, new_node); \/\/ Flag as having been cloned\n+    transform_stack.push(new_node); \/\/ Process children of cloned node\n+    useful.push(new_node);\n@@ -1979,2 +1985,2 @@\n-  while ( trstack.is_nonempty() ) {\n-    Node *clone = trstack.pop();\n+  while ( transform_stack.is_nonempty() ) {\n+    Node *clone = transform_stack.pop();\n@@ -1989,1 +1995,2 @@\n-          trstack.push(new_input);\n+          transform_stack.push(new_input);     \/\/ Process children of cloned node\n+          useful.push(new_input);\n@@ -1995,1 +2002,20 @@\n-  return new_node;\n+\n+  \/\/ The above transformation might lead to subgraphs becoming unreachable from the\n+  \/\/ bottom while still being reachable from the top. As a result, nodes in that\n+  \/\/ subgraph are not transformed and their bottom types are not updated, leading to\n+  \/\/ an inconsistency between bottom_type() and type(). In rare cases, LoadNodes in\n+  \/\/ such a subgraph, might be re-enqueued for IGVN indefinitely by MemNode::Ideal_common\n+  \/\/ because their address type is inconsistent. Therefore, we aggressively remove\n+  \/\/ all useless nodes here even before PhaseIdealLoop::build_loop_late gets a chance\n+  \/\/ to remove them anyway.\n+  if (C->cached_top_node()) {\n+    useful.push(C->cached_top_node());\n+  }\n+  C->update_dead_node_list(useful);\n+  remove_useless_nodes(useful.member_set());\n+  _worklist.remove_useless_nodes(useful.member_set());\n+  C->disconnect_useless_nodes(useful, &_worklist);\n+\n+  Node* new_root = _nodes[n->_idx];\n+  assert(new_root->is_Root(), \"transformed root node must be a root node\");\n+  return new_root;\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":43,"deletions":17,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-  Unique_Node_List _safepoints;\n+  Unique_Node_List _root_and_safepoints;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8287217\n+ * @summary CCP must remove nodes that are not traversed, else their type can be inconsistent\n+ * @run main\/othervm -Xcomp -Xbatch -XX:CompileCommand=compileOnly,TestRemoveUnreachableCCP::test\n+ *                   TestRemoveUnreachableCCP\n+ *\/\n+\n+public class TestRemoveUnreachableCCP {\n+\n+    static void test() {\n+        Byte x = 1;\n+        for (int i = 0; i < 10000; i++) {\n+            if ((i & 1) == 0) {\n+                x = (byte)x;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestRemoveUnreachableCCP _instance = new TestRemoveUnreachableCCP();\n+        for (int i = 0; i < 11; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestRemoveUnreachableCCP.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"}]}