{"files":[{"patch":"@@ -2456,1 +2456,1 @@\n-    {\n+    if (THREAD->can_call_java()) {\n@@ -2478,0 +2478,3 @@\n+    } else {\n+      st->print_raw_cr(\"<<cannot call Java to get cause>>\");\n+      return;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-  assert(THREAD->can_call_java(),\n+  guarantee(THREAD->can_call_java(),\n@@ -2059,1 +2059,1 @@\n-  assert(THREAD->can_call_java() ,\"\");\n+  guarantee(THREAD->can_call_java(), \"\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  _can_call_java = false;\n@@ -59,0 +60,6 @@\n+void CompilerThread::set_compiler(AbstractCompiler* c) {\n+  \/\/ Only jvmci compiler threads can call Java\n+  _can_call_java = c != nullptr && c->is_jvmci();\n+  _compiler = c;\n+}\n+\n@@ -64,4 +71,0 @@\n-bool CompilerThread::can_call_java() const {\n-  return _compiler != nullptr && _compiler->is_jvmci();\n-}\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-class CompileThread;\n+class CompilerThread;\n@@ -40,2 +40,0 @@\n-class JVMCIEnv;\n-class JVMCIPrimitiveArray;\n@@ -46,0 +44,1 @@\n+  JVMCI_ONLY(friend class CompilerThreadCanCallJava;)\n@@ -54,0 +53,1 @@\n+  bool                  _can_call_java;\n@@ -76,1 +76,1 @@\n-  virtual bool can_call_java() const;\n+  virtual bool can_call_java() const             { return _can_call_java; }\n@@ -82,1 +82,1 @@\n-  void set_compiler(AbstractCompiler* c)         { _compiler = c; }\n+  void set_compiler(AbstractCompiler* c);\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"compiler\/abstractCompiler.hpp\"\n@@ -56,0 +57,23 @@\n+CompilerThreadCanCallJava::CompilerThreadCanCallJava(JavaThread* current, bool new_state) {\n+  _current = nullptr;\n+  if (current->is_Compiler_thread()) {\n+    CompilerThread* ct = CompilerThread::cast(current);\n+    if (ct->_can_call_java != new_state &&\n+        ct->_compiler != nullptr &&\n+        ct->_compiler->is_jvmci())\n+    {\n+      \/\/ Only enter a new context if the ability of the\n+      \/\/ current thread to call Java actually changes\n+      _reset_state = ct->_can_call_java;\n+      ct->_can_call_java = new_state;\n+      _current = ct;\n+    }\n+  }\n+}\n+\n+CompilerThreadCanCallJava::~CompilerThreadCanCallJava() {\n+  if (_current != nullptr) {\n+    _current->_can_call_java = _reset_state;\n+  }\n+}\n+\n@@ -179,0 +203,4 @@\n+  \/\/ Class resolution and initialization below\n+  \/\/ requires calling into Java\n+  CompilerThreadCanCallJava ccj(THREAD, true);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class CompilerThread;\n@@ -49,0 +50,28 @@\n+\/\/ A stack object that manages a scope in which the current thread, if\n+\/\/ it's a CompilerThread, can have its CompilerThread::_can_call_java\n+\/\/ field changed. This allows restricting libjvmci better in terms\n+\/\/ of when it can make Java calls. If a Java call on a CompilerThread\n+\/\/ reaches a clinit, there's a risk of dead-lock when async compilation\n+\/\/ is disabled (e.g. -Xbatch or -Xcomp) as the non-CompilerThread thread\n+\/\/ waiting for the blocking compilation may hold the clinit lock.\n+\/\/\n+\/\/ This scope is primarily used to disable Java calls when libjvmci enters\n+\/\/ the VM via a C2V (i.e. CompilerToVM) native method.\n+class CompilerThreadCanCallJava : StackObj {\n+ private:\n+  CompilerThread* _current; \/\/ Only non-null if state of thread changed\n+  bool _reset_state;        \/\/ Value prior to state change, undefined\n+                            \/\/ if no state change.\n+public:\n+  \/\/ Enters a scope in which the ability of the current CompilerThread\n+  \/\/ to call Java is specified by `new_state`. This call only makes a\n+  \/\/ change if the current thread is a CompilerThread associated with\n+  \/\/ a JVMCI compiler whose CompilerThread::_can_call_java is not\n+  \/\/ currently `new_state`.\n+  CompilerThreadCanCallJava(JavaThread* current, bool new_state);\n+\n+  \/\/ Resets CompilerThread::_can_call_java of the current thread if the\n+  \/\/ constructor changed it.\n+  ~CompilerThreadCanCallJava();\n+};\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  JavaThread* THREAD = thread;                                        \\\n+  JavaThread* THREAD = thread;                                    \\\n@@ -172,4 +172,9 @@\n-#define C2V_BLOCK(result_type, name, signature)      \\\n-  JVMCI_VM_ENTRY_MARK;                               \\\n-  ResourceMark rm;                                   \\\n-  JVMCIENV_FROM_JNI(JVMCI::compilation_tick(thread), env);\n+\/\/ Note: CompilerThreadCanCallJava must precede JVMCIENV_FROM_JNI so that\n+\/\/ the translation of an uncaught exception in the JVMCIEnv does not make\n+\/\/ a Java call when __is_hotspot == false.\n+#define C2V_BLOCK(result_type, name, signature)            \\\n+  JVMCI_VM_ENTRY_MARK;                                     \\\n+  ResourceMark rm;                                         \\\n+  bool __is_hotspot = env == thread->jni_environment();    \\\n+  CompilerThreadCanCallJava ccj(thread, __is_hotspot);     \\\n+  JVMCIENV_FROM_JNI(JVMCI::compilation_tick(thread), env); \\\n@@ -191,1 +196,1 @@\n-  if (thread == nullptr) {                                  \\\n+  if (thread == nullptr) {                               \\\n@@ -202,1 +207,1 @@\n-  if (thread == nullptr) {                                  \\\n+  if (thread == nullptr) {                               \\\n@@ -224,1 +229,1 @@\n-      tty->print_cr(\"Throwing \" #name \" in \" caller \" returned %d\", __throw_res); \\\n+      JVMCI_event_1(\"Throwing \" #name \" in \" caller \" returned %d\", __throw_res); \\\n@@ -232,1 +237,1 @@\n-      tty->print_cr(\"Throwing \" #name \" in \" caller \" returned %d\", __throw_res); \\\n+      JVMCI_event_1(\"Throwing \" #name \" in \" caller \" returned %d\", __throw_res); \\\n@@ -582,0 +587,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, resolve); \/\/ Resolution requires Java calls\n@@ -595,1 +601,1 @@\n-    } else if (strstr(val, str) != nullptr) {\n+    } else if (strstr(str, val) != nullptr) {\n@@ -941,0 +947,11 @@\n+\n+  Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) & 0xFF);\n+  int holder_index = cp->klass_ref_index_at(index, bc);\n+  if (!cp->tag_at(holder_index).is_klass() && !THREAD->can_call_java()) {\n+    \/\/ If the holder is not resolved in the constant pool and the current\n+    \/\/ thread cannot call Java, return null. This avoids a Java call\n+    \/\/ in LinkInfo to load the holder.\n+    Symbol* klass_name = cp->klass_ref_at_noresolve(index, bc);\n+    return nullptr;\n+  }\n+\n@@ -2729,0 +2746,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, PEER_JVMCIENV->is_hotspot());\n@@ -2948,0 +2966,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n@@ -2954,0 +2973,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n@@ -2960,0 +2980,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n@@ -3016,0 +3037,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -451,0 +451,9 @@\n+  char* print_throwable_to_buffer(Handle throwable, jlong buffer, int buffer_size) {\n+    char* char_buffer = (char*) buffer + 4;\n+    stringStream st(char_buffer, (size_t) buffer_size - 4);\n+    java_lang_Throwable::print_stack_trace(throwable, &st);\n+    u4 len = (u4) st.size();\n+    *((u4*) buffer) = len;\n+    return char_buffer;\n+  }\n+\n@@ -460,5 +469,1 @@\n-        char* char_buffer = (char*) buffer + 4;\n-        stringStream st(char_buffer, (size_t) buffer_size - 4);\n-        java_lang_Throwable::print_stack_trace(throwable, &st);\n-        u4 len = (u4) st.size();\n-        *((u4*) buffer) = len;\n+        char* char_buffer = print_throwable_to_buffer(throwable, buffer, buffer_size);\n@@ -474,0 +479,7 @@\n+    if (!THREAD->can_call_java()) {\n+      char* char_buffer = print_throwable_to_buffer(_throwable, buffer, buffer_size);\n+      const char* detail = log_is_enabled(Info, exceptions) ? \"\" : \" (-Xlog:exceptions may give more detail)\";\n+      JVMCI_event_1(\"cannot call Java to translate exception%s: %s\", detail, char_buffer);\n+      decode(THREAD, _encode_fail, buffer);\n+      return 0;\n+    }\n@@ -1314,0 +1326,1 @@\n+    CompilerThreadCanCallJava ccj(THREAD, true);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1822,51 +1822,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ Implementation of get_field_by_index.\n-\/\/\n-\/\/ Implementation note: the results of field lookups are cached\n-\/\/ in the accessor klass.\n-void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor& field_desc,\n-                                        int index, Bytecodes::Code bc) {\n-  JVMCI_EXCEPTION_CONTEXT;\n-\n-  assert(klass->is_linked(), \"must be linked before using its constant-pool\");\n-\n-  constantPoolHandle cpool(thread, klass->constants());\n-\n-  \/\/ Get the field's name, signature, and type.\n-  Symbol* name  = cpool->name_ref_at(index, bc);\n-\n-  int nt_index = cpool->name_and_type_ref_index_at(index, bc);\n-  int sig_index = cpool->signature_ref_index_at(nt_index);\n-  Symbol* signature = cpool->symbol_at(sig_index);\n-\n-  \/\/ Get the field's declared holder.\n-  int holder_index = cpool->klass_ref_index_at(index, bc);\n-  bool holder_is_accessible;\n-  Klass* declared_holder = get_klass_by_index(cpool, holder_index,\n-                                               holder_is_accessible,\n-                                               klass);\n-\n-  \/\/ The declared holder of this field may not have been loaded.\n-  \/\/ Bail out with partial field information.\n-  if (!holder_is_accessible) {\n-    return;\n-  }\n-\n-\n-  \/\/ Perform the field lookup.\n-  Klass*  canonical_holder =\n-    InstanceKlass::cast(declared_holder)->find_field(name, signature, &field_desc);\n-  if (canonical_holder == nullptr) {\n-    return;\n-  }\n-\n-  assert(canonical_holder == field_desc.field_holder(), \"just checking\");\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ Get a field by index from a klass's constant pool.\n-void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor& fd, int index, Bytecodes::Code bc) {\n-  ResourceMark rm;\n-  return get_field_by_index_impl(accessor, fd, index, bc);\n-}\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -234,2 +234,0 @@\n-  static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor& fd,\n-                                        int field_index, Bytecodes::Code bc);\n@@ -420,2 +418,0 @@\n-  static void   get_field_by_index(InstanceKlass* loading_klass, fieldDescriptor& fd,\n-                                   int field_index, Bytecodes::Code bc);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  assert(thread->can_call_java(), \"must be able to call Java\");\n+  guarantee(thread->can_call_java(), \"must be able to call Java\");\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -568,1 +568,2 @@\n-     * @return the type defining the field if resolution is successful, null otherwise\n+     * @return the type defining the field if resolution is successful, null if the type cannot be resolved\n+     * @throws LinkageError if there were other problems resolving the field\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -850,4 +850,4 @@\n-                \/*\n-                 * If there was an exception resolving the field we give up and return an unresolved\n-                 * field.\n-                 *\/\n+                resolvedHolder = null;\n+            }\n+            if (resolvedHolder == null) {\n+                \/\/ There was an exception resolving the field or it returned null so return an unresolved field.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}