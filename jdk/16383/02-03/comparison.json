{"files":[{"patch":"@@ -947,0 +947,11 @@\n+\n+  Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) & 0xFF);\n+  int holder_index = cp->klass_ref_index_at(index, bc);\n+  if (!cp->tag_at(holder_index).is_klass() && !THREAD->can_call_java()) {\n+    \/\/ If the holder is not resolved in the constant pool and the current\n+    \/\/ thread cannot call Java, return null. This avoids a Java call\n+    \/\/ in LinkInfo to load the holder.\n+    Symbol* klass_name = cp->klass_ref_at_noresolve(index, bc);\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1822,51 +1822,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ Implementation of get_field_by_index.\n-\/\/\n-\/\/ Implementation note: the results of field lookups are cached\n-\/\/ in the accessor klass.\n-void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor& field_desc,\n-                                        int index, Bytecodes::Code bc) {\n-  JVMCI_EXCEPTION_CONTEXT;\n-\n-  assert(klass->is_linked(), \"must be linked before using its constant-pool\");\n-\n-  constantPoolHandle cpool(thread, klass->constants());\n-\n-  \/\/ Get the field's name, signature, and type.\n-  Symbol* name  = cpool->name_ref_at(index, bc);\n-\n-  int nt_index = cpool->name_and_type_ref_index_at(index, bc);\n-  int sig_index = cpool->signature_ref_index_at(nt_index);\n-  Symbol* signature = cpool->symbol_at(sig_index);\n-\n-  \/\/ Get the field's declared holder.\n-  int holder_index = cpool->klass_ref_index_at(index, bc);\n-  bool holder_is_accessible;\n-  Klass* declared_holder = get_klass_by_index(cpool, holder_index,\n-                                               holder_is_accessible,\n-                                               klass);\n-\n-  \/\/ The declared holder of this field may not have been loaded.\n-  \/\/ Bail out with partial field information.\n-  if (!holder_is_accessible) {\n-    return;\n-  }\n-\n-\n-  \/\/ Perform the field lookup.\n-  Klass*  canonical_holder =\n-    InstanceKlass::cast(declared_holder)->find_field(name, signature, &field_desc);\n-  if (canonical_holder == nullptr) {\n-    return;\n-  }\n-\n-  assert(canonical_holder == field_desc.field_holder(), \"just checking\");\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ Get a field by index from a klass's constant pool.\n-void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor& fd, int index, Bytecodes::Code bc) {\n-  ResourceMark rm;\n-  return get_field_by_index_impl(accessor, fd, index, bc);\n-}\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -234,2 +234,0 @@\n-  static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor& fd,\n-                                        int field_index, Bytecodes::Code bc);\n@@ -420,2 +418,0 @@\n-  static void   get_field_by_index(InstanceKlass* loading_klass, fieldDescriptor& fd,\n-                                   int field_index, Bytecodes::Code bc);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -568,1 +568,2 @@\n-     * @return the type defining the field if resolution is successful, null otherwise\n+     * @return the type defining the field if resolution is successful, null if the type cannot be resolved\n+     * @throws LinkageError if there were other problems resolving the field\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -844,1 +844,1 @@\n-        if (fieldHolder instanceof HotSpotResolvedObjectTypeImpl) {\n+        if (fieldHolder instanceof HotSpotResolvedObjectTypeImpl)  {\n@@ -850,4 +850,4 @@\n-                \/*\n-                 * If there was an exception resolving the field we give up and return an unresolved\n-                 * field.\n-                 *\/\n+                resolvedHolder = null;\n+            }\n+            if (resolvedHolder == null) {\n+                \/\/ There was an exception resolving the field or it returned null so return an unresolved field.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}