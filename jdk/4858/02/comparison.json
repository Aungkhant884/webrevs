{"files":[{"patch":"@@ -1626,5 +1626,0 @@\n-\n-static int compare_fields_by_offset(int* a, int* b) {\n-  return a[0] - b[0];\n-}\n-\n@@ -1638,3 +1633,0 @@\n-  \/\/ In DebugInfo nonstatic fields are sorted by offset.\n-  int* fields_sorted = NEW_C_HEAP_ARRAY(int, 2*(length+1), mtClass);\n-  int j = 0;\n@@ -1644,3 +1636,1 @@\n-      fields_sorted[j + 0] = fd.offset();\n-      fields_sorted[j + 1] = i;\n-      j += 2;\n+      cl->do_field(&fd);\n@@ -1649,2 +1639,34 @@\n-  if (j > 0) {\n-    length = j;\n+}\n+\n+struct F {\n+  int _off;\n+  int _pos;\n+  F(int off, int pos) : _off(off), _pos(pos) {}\n+  F() : _off(0), _pos(0) {}\n+};\n+\n+static int compare_fields_by_offset(F* a, F* b) {\n+  return a->_off - b->_off;\n+}\n+\n+void InstanceKlass::print_nonstatic_fields(FieldClosure* cl) {\n+  InstanceKlass* super = superklass();\n+  if (super != NULL) {\n+    super->print_nonstatic_fields(cl);\n+  }\n+  ResourceMark rm;\n+  fieldDescriptor fd;\n+  \/\/ In DebugInfo nonstatic fields are sorted by offset.\n+  GrowableArray<F> fields_sorted;\n+  int i = 0;\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+    if (!fs.access_flags().is_static()) {\n+      fd = fs.field_descriptor();\n+      F f(fs.offset(), fs.index());\n+      fields_sorted.push(f);\n+      i++;\n+    }\n+  }\n+  if (i > 0) {\n+    int length = i;\n+    assert(length == fields_sorted.length(), \"duh\");\n@@ -1652,4 +1674,4 @@\n-    qsort(fields_sorted, length\/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);\n-    for (int i = 0; i < length; i += 2) {\n-      fd.reinitialize(this, fields_sorted[i + 1]);\n-      assert(!fd.is_static() && fd.offset() == fields_sorted[i], \"only nonstatic fields\");\n+    fields_sorted.sort(compare_fields_by_offset);\n+    for (int i = 0; i < length; i++) {\n+      fd.reinitialize(this, fields_sorted.at(i)._pos);\n+      assert(!fd.is_static() && fd.offset() == fields_sorted.at(i)._off, \"only nonstatic fields\");\n@@ -1659,1 +1681,0 @@\n-  FREE_C_HEAP_ARRAY(int, fields_sorted);\n@@ -1662,1 +1683,0 @@\n-\n@@ -3440,1 +3460,1 @@\n-  ik->do_nonstatic_fields(&print_nonstatic_field);\n+  ik->print_nonstatic_fields(&print_nonstatic_field);\n@@ -3482,1 +3502,0 @@\n-      if (!WizardMode)  return;  \/\/ that is enough\n@@ -3488,1 +3507,1 @@\n-  do_nonstatic_fields(&print_field);\n+  print_nonstatic_fields(&print_field);\n@@ -3494,10 +3513,0 @@\n-    Klass* mirrored_klass = java_lang_Class::as_Klass(obj);\n-    st->print(BULLET\"fake entry for mirror: \");\n-    Metadata::print_value_on_maybe_null(st, mirrored_klass);\n-    st->cr();\n-    Klass* array_klass = java_lang_Class::array_klass_acquire(obj);\n-    st->print(BULLET\"fake entry for array: \");\n-    Metadata::print_value_on_maybe_null(st, array_klass);\n-    st->cr();\n-    st->print_cr(BULLET\"fake entry for oop_size: %d\", java_lang_Class::oop_size(obj));\n-    st->print_cr(BULLET\"fake entry for static_oop_field_count: %d\", java_lang_Class::static_oop_field_count(obj));\n@@ -3506,0 +3515,1 @@\n+      st->print_cr(BULLET\"---- static fields (%d words):\", java_lang_Class::static_oop_field_count(obj));\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1010,0 +1010,1 @@\n+  void print_nonstatic_fields(FieldClosure* cl); \/\/ including inherited and injected fields\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,2 +113,0 @@\n-  assert(!f->is_internal(), \"regular Java fields only\");\n-\n@@ -128,1 +126,2 @@\n-    assert(_index < field_holder()->java_fields_count(), \"oob\");\n+    assert(access_flags().is_internal() ||\n+           _index < field_holder()->java_fields_count(), \"oob\");\n@@ -136,0 +135,1 @@\n+  if (access_flags().is_internal()) st->print(\"internal \");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -40,0 +42,20 @@\n+\n+TEST_VM(InstanceKlass, class_loader_printer) {\n+  ResourceMark rm;\n+  oop loader = SystemDictionary::java_platform_loader();\n+  stringStream st;\n+  loader->print_on(&st);\n+  \/\/ See if injected loader_data field is printed in string\n+  ASSERT_TRUE(strstr(st.as_string(), \"internal 'loader_data'\") != NULL) << \"Must contain internal fields\";\n+  st.reset();\n+  \/\/ See if mirror injected fields are printed.\n+  oop mirror = vmClasses::ClassLoader_klass()->java_mirror();\n+  mirror->print_on(&st);\n+  ASSERT_TRUE(strstr(st.as_string(), \"internal 'protection_domain'\") != NULL) << \"Must contain internal fields\";\n+  \/\/ We should test other printing functions too.\n+  st.reset();\n+  Method* method = vmClasses::ClassLoader_klass()->methods()->at(0);  \/\/ we know there's a method here!\n+  method->print_on(&st);\n+  ASSERT_TRUE(strstr(st.as_string(), \"method holder:\") != NULL) << \"Must contain method_holder field\";\n+  ASSERT_TRUE(strstr(st.as_string(), \"'java\/lang\/ClassLoader'\") != NULL) << \"Must be in ClassLoader\";\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_instanceKlass.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}