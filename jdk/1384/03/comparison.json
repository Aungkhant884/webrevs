{"files":[{"patch":"@@ -4908,1 +4908,1 @@\n-  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n@@ -4923,1 +4923,1 @@\n-  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -770,7 +770,7 @@\n-     Node* lshift = in(1)->in(2);\n-     Node* rshift = in(2)->in(2);\n-     Node* shift = rotate_shift(phase, lshift, rshift, 0x1F);\n-     if (shift != NULL) {\n-       return new RotateLeftNode(in(1)->in(1), shift, TypeInt::INT);\n-     }\n-     return NULL;\n+    Node* lshift = in(1)->in(2);\n+    Node* rshift = in(2)->in(2);\n+    Node* shift = rotate_shift(phase, lshift, rshift, 0x1F);\n+    if (shift != NULL) {\n+      return new RotateLeftNode(in(1)->in(1), shift, TypeInt::INT);\n+    }\n+    return NULL;\n@@ -780,6 +780,6 @@\n-     Node *rshift = in(1)->in(2);\n-     Node *lshift = in(2)->in(2);\n-     Node* shift = rotate_shift(phase, rshift, lshift, 0x1F);\n-     if (shift != NULL) {\n-       return new RotateRightNode(in(1)->in(1), shift, TypeInt::INT);\n-     }\n+    Node* rshift = in(1)->in(2);\n+    Node* lshift = in(2)->in(2);\n+    Node* shift = rotate_shift(phase, rshift, lshift, 0x1F);\n+    if (shift != NULL) {\n+      return new RotateRightNode(in(1)->in(1), shift, TypeInt::INT);\n+    }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -640,7 +640,7 @@\n-static int getShiftCon(PhaseGVN *phase, Node *shiftNode, int retVal) {\n-  const Type *t = phase->type(shiftNode->in(2));\n-  if (t == Type::TOP) return retVal;       \/\/ Right input is dead.\n-  const TypeInt *t2 = t->isa_int();\n-  if (!t2 || !t2->is_con()) return retVal; \/\/ Right input is a constant.\n-\n-  return t2->get_con();\n+static bool const_shift_count(PhaseGVN* phase, Node* shiftNode, int* count) {\n+  const TypeInt* tcount = phase->type(shiftNode->in(2))->isa_int();\n+  if (tcount != NULL && tcount->is_con()) {\n+    *count = tcount->get_con();\n+    return true;\n+  }\n+  return false;\n@@ -649,5 +649,8 @@\n-static int maskShiftAmount(PhaseGVN *phase, Node *shiftNode, int nBits) {\n-  int       shift = getShiftCon(phase, shiftNode, 0);\n-  int maskedShift = shift & (nBits - 1);\n-\n-  if (maskedShift == 0) return 0;         \/\/ Let Identity() handle 0 shift count.\n+static int maskShiftAmount(PhaseGVN* phase, Node* shiftNode, int nBits) {\n+  int count = 0;\n+  if (const_shift_count(phase, shiftNode, &count)) {\n+    int maskedShift = count & (nBits - 1);\n+    if (maskedShift == 0) {\n+      \/\/ Let Identity() handle 0 shift count.\n+      return 0;\n+    }\n@@ -655,5 +658,6 @@\n-  if (shift != maskedShift) {\n-    shiftNode->set_req(2, phase->intcon(maskedShift)); \/\/ Replace shift count with masked value.\n-    PhaseIterGVN* igvn = phase->is_IterGVN();\n-    if (igvn) {\n-      igvn->rehash_node_delayed(shiftNode);\n+    if (count != maskedShift) {\n+      shiftNode->set_req(2, phase->intcon(maskedShift)); \/\/ Replace shift count with masked value.\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      if (igvn) {\n+        igvn->rehash_node_delayed(shiftNode);\n+      }\n@@ -661,0 +665,1 @@\n+    return maskedShift;\n@@ -662,2 +667,1 @@\n-\n-  return maskedShift;\n+  return 0;\n@@ -668,1 +672,6 @@\n-  return ((getShiftCon(phase, this, -1) & (BitsPerJavaInteger - 1)) == 0) ? in(1) : this;\n+  int count = 0;\n+  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaInteger - 1)) == 0) {\n+    \/\/ Shift by a multiple of 32 does nothing\n+    return in(1);\n+  }\n+  return this;\n@@ -776,1 +785,6 @@\n-  return ((getShiftCon(phase, this, -1) & (BitsPerJavaLong - 1)) == 0) ? in(1) : this;\n+  int count = 0;\n+  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaLong - 1)) == 0) {\n+    \/\/ Shift by a multiple of 64 does nothing\n+    return in(1);\n+  }\n+  return this;\n@@ -881,17 +895,22 @@\n-  int shift = getShiftCon(phase, this, -1);\n-  if (shift == -1) return this;\n-  if ((shift & (BitsPerJavaInteger - 1)) == 0) return in(1);\n-\n-  \/\/ Check for useless sign-masking\n-  if (in(1)->Opcode() == Op_LShiftI &&\n-      in(1)->req() == 3 &&\n-      in(1)->in(2) == in(2)) {\n-    shift &= BitsPerJavaInteger-1; \/\/ semantics of Java shifts\n-    \/\/ Compute masks for which this shifting doesn't change\n-    int lo = (-1 << (BitsPerJavaInteger - ((uint)shift)-1)); \/\/ FFFF8000\n-    int hi = ~lo;               \/\/ 00007FFF\n-    const TypeInt *t11 = phase->type(in(1)->in(1))->isa_int();\n-    if (!t11) return this;\n-    \/\/ Does actual value fit inside of mask?\n-    if (lo <= t11->_lo && t11->_hi <= hi) {\n-      return in(1)->in(1);      \/\/ Then shifting is a nop\n+  int count = 0;\n+  if (const_shift_count(phase, this, &count)) {\n+    if ((count & (BitsPerJavaInteger - 1)) == 0) {\n+      \/\/ Shift by a multiple of 32 does nothing\n+      return in(1);\n+    }\n+    \/\/ Check for useless sign-masking\n+    if (in(1)->Opcode() == Op_LShiftI &&\n+        in(1)->req() == 3 &&\n+        in(1)->in(2) == in(2)) {\n+      count &= BitsPerJavaInteger-1; \/\/ semantics of Java shifts\n+      \/\/ Compute masks for which this shifting doesn't change\n+      int lo = (-1 << (BitsPerJavaInteger - ((uint)count)-1)); \/\/ FFFF8000\n+      int hi = ~lo;               \/\/ 00007FFF\n+      const TypeInt* t11 = phase->type(in(1)->in(1))->isa_int();\n+      if (t11 == NULL) {\n+        return this;\n+      }\n+      \/\/ Does actual value fit inside of mask?\n+      if (lo <= t11->_lo && t11->_hi <= hi) {\n+        return in(1)->in(1);      \/\/ Then shifting is a nop\n+      }\n@@ -900,1 +919,0 @@\n-\n@@ -1085,2 +1103,5 @@\n-  int shift = getShiftCon(phase, this, -1);\n-  if ((shift & (BitsPerJavaInteger - 1)) == 0) return in(1);\n+  int count = 0;\n+  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaInteger - 1)) == 0) {\n+    \/\/ Shift by a multiple of 32 does nothing\n+    return in(1);\n+  }\n@@ -1269,1 +1290,6 @@\n-  return ((getShiftCon(phase, this, -1) & (BitsPerJavaLong - 1)) == 0) ? in(1) : this;\n+  int count = 0;\n+  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaLong - 1)) == 0) {\n+    \/\/ Shift by a multiple of 64 does nothing\n+    return in(1);\n+  }\n+  return this;\n@@ -1447,0 +1473,15 @@\n+Node* RotateLeftNode::Identity(PhaseGVN* phase) {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) {\n+    return this;\n+  }\n+  int count = 0;\n+  assert(t1->isa_int() || t1->isa_long(), \"Unexpected type\");\n+  int mask = (t1->isa_int() ? BitsPerJavaInteger : BitsPerJavaLong) - 1;\n+  if (const_shift_count(phase, this, &count) && (count & mask) == 0) {\n+    \/\/ Rotate by a multiple of 32\/64 does nothing\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n@@ -1463,1 +1504,1 @@\n-    \/\/ Shift by zero does nothing\n+    \/\/ Rotate by zero does nothing\n@@ -1467,1 +1508,0 @@\n-\n@@ -1482,1 +1522,1 @@\n-    \/\/ Shift by zero does nothing\n+    \/\/ Rotate by zero does nothing\n@@ -1486,1 +1526,0 @@\n-\n@@ -1511,0 +1550,15 @@\n+Node* RotateRightNode::Identity(PhaseGVN* phase) {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) {\n+    return this;\n+  }\n+  int count = 0;\n+  assert(t1->isa_int() || t1->isa_long(), \"Unexpected type\");\n+  int mask = (t1->isa_int() ? BitsPerJavaInteger : BitsPerJavaLong) - 1;\n+  if (const_shift_count(phase, this, &count) && (count & mask) == 0) {\n+    \/\/ Rotate by a multiple of 32\/64 does nothing\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n@@ -1527,1 +1581,1 @@\n-    \/\/ Shift by zero does nothing\n+    \/\/ Rotate by zero does nothing\n@@ -1536,1 +1590,0 @@\n-\n@@ -1545,1 +1598,1 @@\n-    \/\/ Shift by zero does nothing\n+    \/\/ Rotate by zero does nothing\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":102,"deletions":49,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -235,0 +236,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8248830\n+ * @bug 8248830 8256823\n@@ -283,0 +283,56 @@\n+    public static void test_rol_int_zero(int val) {\n+        \/\/ Count is known to be zero only after loop opts\n+        int count = 42;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                count = 0;\n+            }\n+        }\n+        int res = Integer.rotateLeft(val, count);\n+        if (res != val) {\n+            throw new RuntimeException(\"test_rol_int_zero failed: \" + res + \" != \" + val);\n+        }\n+    }\n+\n+    public static void test_rol_long_zero(long val) {\n+        \/\/ Count is known to be zero only after loop opts\n+        int count = 42;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                count = 0;\n+            }\n+        }\n+        long res = Long.rotateLeft(val, count);\n+        if (res != val) {\n+            throw new RuntimeException(\"test_rol_long_zero failed: \" + res + \" != \" + val);\n+        }\n+    }\n+\n+    public static void test_ror_int_zero(int val) {\n+        \/\/ Count is known to be zero only after loop opts\n+        int count = 42;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                count = 0;\n+            }\n+        }\n+        int res = Integer.rotateRight(val, count);\n+        if (res != val) {\n+            throw new RuntimeException(\"test_ror_int_zero failed: \" + res + \" != \" + val);\n+        }\n+    }\n+\n+    public static void test_ror_long_zero(long val) {\n+        \/\/ Count is known to be zero only after loop opts\n+        int count = 42;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                count = 0;\n+            }\n+        }\n+        long res = Long.rotateRight(val, count);\n+        if (res != val) {\n+            throw new RuntimeException(\"test_ror_long_zero failed: \" + res + \" != \" + val);\n+        }\n+    }\n+\n@@ -303,0 +359,4 @@\n+          test_rol_int_zero(i);\n+          test_rol_long_zero(i);\n+          test_ror_int_zero(i);\n+          test_ror_long_zero(i);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestRotate.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"}]}