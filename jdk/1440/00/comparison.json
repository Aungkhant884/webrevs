{"files":[{"patch":"@@ -339,0 +339,42 @@\n+ * The ApplicationProtocol {@code String} values returned by the methods\n+ * in this class are in the network byte representation sent by the peer.\n+ * The bytes could be directly compared, or converted to its Unicode\n+ * {code String} format for comparison.\n+ *\n+ * <blockquote><pre>\n+ *     String networkString = sslEngine.getHandshakeApplicationProtocol();\n+ *     byte[] bytes = networkString.getBytes(StandardCharsets.ISO_8859_1);\n+ *\n+ *     \/\/\n+ *     \/\/ Match using bytes:\n+ *     \/\/\n+ *     \/\/   \"http\/1.1\"                       (7-bit ASCII values same in UTF-8)\n+ *     \/\/   MEETEI MAYEK LETTERS \"HUK UN I\"  (Unicode 0xabcd->0xabcf)\n+ *     \/\/\n+ *     String HTTP1_1 = \"http\/1.1\";\n+ *     byte[] HTTP1_1_BYTES = HTTP1_1.getBytes(StandardCharsets.UTF_8);\n+ *\n+ *     byte[] HUK_UN_I_BYTES = new byte[] {\n+ *         (byte) 0xab, (byte) 0xcd,\n+ *         (byte) 0xab, (byte) 0xce,\n+ *         (byte) 0xab, (byte) 0xcf};\n+ *\n+ *     if ((Arrays.compare(bytes, HTTP1_1_BYTES) == 0 )\n+ *             || Arrays.compare(bytes, HUK_UN_I_BYTES) == 0) {\n+ *        ...\n+ *     }\n+ *\n+ *     \/\/\n+ *     \/\/ Alternatively match using string.equals() if we know the ALPN value\n+ *     \/\/ was encoded from a {@code String} using a certain character set,\n+ *     \/\/ for example {@code UTF-8}.  The ALPN value must first be properly\n+ *     \/\/ decoded to a Unicode {@code String} before use.\n+ *     \/\/\n+ *     String unicodeString = new String(bytes, StandardCharsets.UTF_8);\n+ *     if (unicodeString.equals(HTTP1_1)\n+ *             || unicodeString.equals(\"\\u005cuabcd\\u005cuabce\\u005cuabcf\")) {\n+ *         ...\n+ *     }\n+ * <\/pre><\/blockquote>\n+ *\n+ * <P>\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLEngine.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -649,0 +649,21 @@\n+     * <p>\n+     * The {@code String} values must be presented using the network\n+     * byte representation expected by the peer.  For example, if an ALPN\n+     * {@code String} should be exchanged using {@code UTF-8}, the\n+     * {@code String} should be converted to its {@code byte[]} representation\n+     * and stored as a byte-oriented {@code String} before calling this method.\n+     *\n+     * <blockquote><pre>\n+     *     \/\/ MEETEI MAYEK LETTERS HUK UN I (Unicode 0xabcd->0xabcf): 2 bytes\n+     *     byte[] bytes = \"\\u005cuabcd\\u005cuabce\\u005cuabcf\"\n+     *             .getBytes(StandardCharsets.UTF_8);\n+     *     String HUK_UN_I = new String(bytes, StandardCharsets.ISO_8859_1);\n+     *\n+     *     \/\/ 0x00-0xFF:  1 byte\n+     *     String rfc7301Grease8F = \"\\u005c008F\\u005c008F\";\n+     *\n+     *     SSLParameters p = sslSocket.getSSLParameters();\n+     *     p.setApplicationProtocols(new String[] {\n+     *             \"h2\", \"http\/1.1\", rfc7301Grease8F, HUK_UN_I});\n+     *     sslSocket.setSSLParameters(p);\n+     * <\/pre><\/blockquote>\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLParameters.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,41 @@\n+ * <P> The ApplicationProtocol {@code String} values returned by the methods\n+ * in this class are in the network byte representation sent by the peer.\n+ * The bytes could be directly compared, or converted to its Unicode\n+ * {code String} format for comparison.\n+ *\n+ * <blockquote><pre>\n+ *     String networkString = sslSocket.getHandshakeApplicationProtocol();\n+ *     byte[] bytes = networkString.getBytes(StandardCharsets.ISO_8859_1);\n+ *\n+ *     \/\/\n+ *     \/\/ Match using bytes:\n+ *     \/\/\n+ *     \/\/   \"http\/1.1\"                       (7-bit ASCII values same in UTF-8)\n+ *     \/\/   MEETEI MAYEK LETTERS \"HUK UN I\"  (Unicode 0xabcd->0xabcf)\n+ *     \/\/\n+ *     String HTTP1_1 = \"http\/1.1\";\n+ *     byte[] HTTP1_1_BYTES = HTTP1_1.getBytes(StandardCharsets.UTF_8);\n+ *\n+ *     byte[] HUK_UN_I_BYTES = new byte[] {\n+ *         (byte) 0xab, (byte) 0xcd,\n+ *         (byte) 0xab, (byte) 0xce,\n+ *         (byte) 0xab, (byte) 0xcf};\n+ *\n+ *     if ((Arrays.compare(bytes, HTTP1_1_BYTES) == 0 )\n+ *             || Arrays.compare(bytes, HUK_UN_I_BYTES) == 0) {\n+ *        ...\n+ *     }\n+ *\n+ *     \/\/\n+ *     \/\/ Alternatively match using string.equals() if we know the ALPN value\n+ *     \/\/ was encoded from a {@code String} using a certain character set,\n+ *     \/\/ for example {@code UTF-8}.  The ALPN value must first be properly\n+ *     \/\/ decoded to a Unicode {@code String} before use.\n+ *     \/\/\n+ *     String unicodeString = new String(bytes, StandardCharsets.UTF_8);\n+ *     if (unicodeString.equals(HTTP1_1)\n+ *             || unicodeString.equals(\"\\u005cuabcd\\u005cuabce\\u005cuabcf\")) {\n+ *         ...\n+ *     }\n+ * <\/pre><\/blockquote>\n+ *\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLSocket.java","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -30,1 +30,4 @@\n-import java.nio.charset.StandardCharsets;\n+import java.nio.charset.Charset;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.Security;\n@@ -62,0 +65,14 @@\n+    \/\/ Encoding Charset to convert between String and byte[]\n+    static final Charset alpnCharset;\n+\n+    static {\n+        String alpnCharsetString = AccessController.doPrivileged(\n+                (PrivilegedAction<String>) ()\n+                        -> Security.getProperty(\"jdk.tls.alpnCharset\"));\n+        if ((alpnCharsetString == null)\n+                || (alpnCharsetString.length() == 0)) {\n+            alpnCharsetString = \"ISO_8859_1\";\n+        }\n+        alpnCharset = Charset.forName(alpnCharsetString);\n+    }\n+\n@@ -104,1 +121,1 @@\n-                String appProtocol = new String(bytes, StandardCharsets.UTF_8);\n+                String appProtocol = new String(bytes, alpnCharset);\n@@ -171,1 +188,1 @@\n-            \/\/ Produce the extension.\n+            \/\/ Produce the extension:  first find the overall length\n@@ -174,1 +191,1 @@\n-                int length = ap.getBytes(StandardCharsets.UTF_8).length;\n+                int length = ap.getBytes(alpnCharset).length;\n@@ -226,0 +243,2 @@\n+\n+            \/\/ opaque ProtocolName<1..2^8-1>;\n@@ -227,1 +246,1 @@\n-                Record.putBytes8(m, ap.getBytes(StandardCharsets.UTF_8));\n+                Record.putBytes8(m, ap.getBytes(alpnCharset));\n@@ -417,2 +436,3 @@\n-            int listLen = shc.applicationProtocol.length() + 1;\n-                                                        \/\/ 1: length byte\n+            byte[] bytes = shc.applicationProtocol.getBytes(alpnCharset);\n+            int listLen = bytes.length + 1;             \/\/ 1: length byte\n+\n@@ -423,2 +443,1 @@\n-            Record.putBytes8(m,\n-                    shc.applicationProtocol.getBytes(StandardCharsets.UTF_8));\n+            Record.putBytes8(m, bytes);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/AlpnExtension.java","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1312,0 +1312,10 @@\n+\n+#\n+# The default Character set name (java.nio.charset.Charset.forName())\n+# for converting TLS ALPN values between byte arrays and Strings.\n+# Prior versions of the JDK may use UTF-8 as the default charset. If\n+# you experience interoperability issues, setting this property to UTF-8\n+# may help.\n+#\n+# jdk.tls.alpnCharset=UTF-8\n+jdk.tls.alpnCharset=ISO_8859_1\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8254631\n+ * @summary Better support ALPN byte wire values in SunJSSE\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm AlpnGreaseTest\n+ *\/\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+\/**\n+ * A SSLEngine usage example which simplifies the presentation\n+ * by removing the I\/O and multi-threading concerns.\n+ *\n+ * The test creates two SSLEngines, simulating a client and server.\n+ * The \"transport\" layer consists two byte buffers:  think of them\n+ * as directly connected pipes.\n+ *\n+ * Note, this is a *very* simple example: real code will be much more\n+ * involved.  For example, different threading and I\/O models could be\n+ * used, transport mechanisms could close unexpectedly, and so on.\n+ *\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.\n+ *\/\n+public class AlpnGreaseTest implements SSLContextTemplate {\n+\n+    private final SSLEngine clientEngine;     \/\/ client Engine\n+    private final ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    private final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+\n+    private final SSLEngine serverEngine;     \/\/ server Engine\n+    private final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    private final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    \/\/ For data transport, this example uses local ByteBuffers.  This\n+    \/\/ isn't really useful, but the purpose of this example is to show\n+    \/\/ SSLEngine concepts, not how to do network transport.\n+    private final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    private final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+\n+    \/\/ These are the various 8-bit char values that could be sent as GREASE\n+    \/\/ values.  We'll just make one big String here to make it easy to check\n+    \/\/ that the right values are being output.\n+    private static final byte[] greaseBytes = new byte[] {\n+        (byte) 0x0A, (byte) 0x1A, (byte) 0x2A, (byte) 0x3A,\n+        (byte) 0x4A, (byte) 0x5A, (byte) 0x6A, (byte) 0x7A,\n+        (byte) 0x8A, (byte) 0x9A, (byte) 0xAA, (byte) 0xBA,\n+        (byte) 0xCA, (byte) 0xDA, (byte) 0xEA, (byte) 0xFA\n+    };\n+\n+    private static final String greaseString =\n+            new String(greaseBytes, StandardCharsets.ISO_8859_1);\n+\n+    private static void findGreaseInClientHello(byte[] bytes) throws Exception {\n+        for (int i = 0; i < bytes.length - greaseBytes.length; i++) {\n+            if (Arrays.equals(bytes, i, i + greaseBytes.length,\n+                    greaseBytes, 0, greaseBytes.length)) {\n+                System.out.println(\"Found greaseBytes in ClientHello at: \" + i);\n+                return;\n+            }\n+        }\n+        throw new Exception(\"Couldn't find greaseBytes\");\n+    }\n+\n+    private AlpnGreaseTest() throws Exception {\n+        serverEngine = configureServerEngine(\n+                createServerSSLContext().createSSLEngine());\n+\n+        clientEngine = configureClientEngine(\n+                createClientSSLContext().createSSLEngine());\n+\n+        \/\/ We'll assume the buffer sizes are the same\n+        \/\/ between client and server.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        \/\/\n+        \/\/ We'll use a mix of direct and indirect ByteBuffers for\n+        \/\/ tutorial purposes only.  In reality, only use direct\n+        \/\/ ByteBuffers when they give a clear performance enhancement.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    \/\/\n+    \/\/ Protected methods could be used to customize the test case.\n+    \/\/\n+\n+    \/*\n+     * Configure the client side engine.\n+     *\/\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+\n+        \/\/ Get\/set parameters if needed\n+        SSLParameters paramsClient = clientEngine.getSSLParameters();\n+        paramsClient.setApplicationProtocols(new String[] { greaseString });\n+\n+        clientEngine.setSSLParameters(paramsClient);\n+\n+        return clientEngine;\n+    }\n+\n+    \/*\n+     * Configure the server side engine.\n+     *\/\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+\n+        \/\/ Get\/set parameters if needed\n+        \/\/\n+        SSLParameters paramsServer = serverEngine.getSSLParameters();\n+        paramsServer.setApplicationProtocols(new String[] { greaseString });\n+        serverEngine.setSSLParameters(paramsServer);\n+\n+        return serverEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new AlpnGreaseTest().runTest();\n+    }\n+\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n+\n+    private void runTest() throws Exception {\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+\n+        boolean dataDone = false;\n+        boolean firstClientWrap = true;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            log(\"=================\");\n+\n+            \/\/ client wrap\n+            log(\"---Client Wrap---\");\n+            clientResult = clientEngine.wrap(clientOut, cTOs);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n+\n+            if (firstClientWrap) {\n+                firstClientWrap = false;\n+                byte[] bytes = new byte[cTOs.position()];\n+                cTOs.duplicate().flip().get(bytes);\n+                findGreaseInClientHello(bytes);\n+            }\n+\n+            \/\/ server wrap\n+            log(\"---Server Wrap---\");\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            logEngineStatus(serverEngine, serverResult);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.flip();\n+            sTOc.flip();\n+\n+            \/\/ client unwrap\n+            log(\"---Client Unwrap---\");\n+            clientResult = clientEngine.unwrap(sTOc, clientIn);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n+\n+            \/\/ server unwrap\n+            log(\"---Server Unwrap---\");\n+            serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            logEngineStatus(serverEngine, serverResult);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            \/\/ After we've transferred all application data between the client\n+            \/\/ and server, we close the clientEngine's outbound stream.\n+            \/\/ This generates a close_notify handshake message, which the\n+            \/\/ server engine receives and responds by closing itself.\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+\n+                \/\/ Check ALPN Value\n+                String alpnServerValue = serverEngine.getApplicationProtocol();\n+                String alpnClientValue = clientEngine.getApplicationProtocol();\n+\n+                if (!alpnServerValue.equals(greaseString)\n+                        || !alpnClientValue.equals(greaseString)) {\n+                    throw new Exception(\"greaseString didn't match\");\n+                }\n+\n+                \/\/ A sanity check to ensure we got what was sent.\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                log(\"\\tClosing clientEngine's *OUTBOUND*...\");\n+                clientEngine.closeOutbound();\n+                logEngineStatus(clientEngine);\n+\n+                dataDone = true;\n+                log(\"\\tClosing serverEngine's *OUTBOUND*...\");\n+                serverEngine.closeOutbound();\n+                logEngineStatus(serverEngine);\n+            }\n+        }\n+    }\n+\n+    private static boolean isOpen(SSLEngine engine) {\n+        return (!engine.isOutboundDone() || !engine.isInboundDone());\n+    }\n+\n+    private static void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    private static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    private static void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n+    private static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+\n+    \/\/ Simple check to make sure everything came across as expected.\n+    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+            throws Exception {\n+        a.flip();\n+        b.flip();\n+\n+        if (!a.equals(b)) {\n+            throw new Exception(\"Data didn't transfer cleanly\");\n+        } else {\n+            log(\"\\tData transferred cleanly\");\n+        }\n+\n+        a.position(a.limit());\n+        b.position(b.limit());\n+        a.limit(a.capacity());\n+        b.limit(b.capacity());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/ALPN\/AlpnGreaseTest.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"}]}