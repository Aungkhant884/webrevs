{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.Method;\n@@ -147,0 +148,33 @@\n+    \/**{@inheritDoc}\n+     *\n+     * @implSpec If the subclass of the {@code ForwardingJavaFileManager} overrides the\n+     * {@link #getJavaFileForOutput} method, this method will delegate to it as per the\n+     * general contract of {@link JavaFileManager#getJavaFileForOutputForOriginatingFiles}.\n+     * If the subclass does not override the method, the call will be delegated to the\n+     * {@code fileManager}.\n+     *\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IllegalStateException {@inheritDoc}\n+     *\/\n+    @Override\n+    public JavaFileObject getJavaFileForOutputForOriginatingFiles(Location location,\n+                                               String className,\n+                                               Kind kind,\n+                                               FileObject... originatingFiles) throws IOException {\n+        try {\n+            Method delegate = getClass().getMethod(\"getJavaFileForOutput\",\n+                                                   Location.class, String.class,\n+                                                   Kind.class, FileObject.class);\n+            if (delegate.getDeclaringClass() == ForwardingJavaFileManager.class) {\n+                return fileManager.getJavaFileForOutputForOriginatingFiles(location, className,\n+                                                                           kind, originatingFiles);\n+            } else {\n+                return JavaFileManager.super\n+                                      .getJavaFileForOutputForOriginatingFiles(location, className,\n+                                                                               kind, originatingFiles);\n+            }\n+        } catch (NoSuchMethodException ex) {\n+            throw new InternalError(\"This should never happen.\", ex);\n+        }\n+    }\n+\n@@ -174,0 +208,33 @@\n+    \/**{@inheritDoc}\n+     *\n+     * @implSpec If the subclass of the {@code ForwardingJavaFileManager} overrides the\n+     * {@link #getFileForOutput} method, this method will delegate to it as per the\n+     * general contract of {@link JavaFileManager#getFileForOutputForOriginatingFiles}.\n+     * If the subclass does not override the method, the call will be delegated to the\n+     * {@code fileManager}.\n+     *\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IllegalStateException {@inheritDoc}\n+     *\/\n+    @Override\n+    public FileObject getFileForOutputForOriginatingFiles(Location location,\n+                                       String packageName,\n+                                       String relativeName,\n+                                       FileObject... originatingFiles) throws IOException {\n+        try {\n+            Method delegate = getClass().getMethod(\"getFileForOutput\",\n+                                                   Location.class, String.class,\n+                                                   String.class, FileObject.class);\n+            if (delegate.getDeclaringClass() == ForwardingJavaFileManager.class) {\n+                return fileManager.getFileForOutputForOriginatingFiles(location, packageName,\n+                                                                       relativeName, originatingFiles);\n+            } else {\n+                return JavaFileManager.super\n+                                      .getFileForOutputForOriginatingFiles(location, packageName,\n+                                                                           relativeName, originatingFiles);\n+            }\n+        } catch (NoSuchMethodException ex) {\n+            throw new InternalError(\"This should never happen.\", ex);\n+        }\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingJavaFileManager.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import javax.annotation.processing.Filer;\n+import javax.lang.model.util.Elements;\n@@ -341,0 +343,43 @@\n+    \/**\n+     * Returns a {@linkplain JavaFileObject file object} for output\n+     * representing the specified class of the specified kind in the\n+     * given package-oriented location.\n+     *\n+     * <p>The provided {@code originatingFiles} represent files that\n+     * were in, an unspecified way, used to create the content of\n+     * the file created by this method. See {@code originatingElements}\n+     * in {@link Filer#createSourceFile}. {@link Elements#getFileObjectOf}\n+     * may be used to convert the {@code Element}s to {@code FileObject}s.\n+     *\n+     * @implSpec The default implementation calls\n+     * {@link #getJavaFileForOutput(javax.tools.JavaFileManager.Location, java.lang.String, javax.tools.JavaFileObject.Kind, javax.tools.FileObject) }\n+     * with the first element of the {@code originatingFiles}, if any, as a {@code sibling}.\n+     *\n+     * @param location a package-oriented location\n+     * @param className the name of a class\n+     * @param kind the kind of file, must be one of {@link\n+     * JavaFileObject.Kind#SOURCE SOURCE} or {@link\n+     * JavaFileObject.Kind#CLASS CLASS}\n+     * @param originatingFiles the files which are contributing to this newly created file\n+     * @return a file object for output\n+     * @throws IllegalArgumentException if sibling is not known to\n+     * this file manager, or if the location is not known to this file\n+     * manager and the file manager does not support unknown\n+     * locations, or if the kind is not valid, or if the location is\n+     * not an output location\n+     * @throws IOException if an I\/O error occurred, or if {@link\n+     * #close} has been called and this file manager cannot be\n+     * reopened\n+     * @throws IllegalStateException {@link #close} has been called\n+     * and this file manager cannot be reopened\n+     * @since 18\n+     * @see Filer#createSourceFile\n+     *\/\n+    default JavaFileObject getJavaFileForOutputForOriginatingFiles(Location location,\n+                                        String className,\n+                                        Kind kind,\n+                                        FileObject... originatingFiles)\n+        throws IOException {\n+        return getJavaFileForOutput(location, className, kind, siblingFrom(originatingFiles));\n+    }\n+\n@@ -433,0 +478,51 @@\n+    \/**\n+     * Returns a {@linkplain FileObject file object} for output\n+     * representing the specified <a href=\"JavaFileManager.html#relative_name\">relative\n+     * name<\/a> in the specified package in the given location.\n+     *\n+     * <p>The provided {@code originatingFiles} represent files that\n+     * were in, an unspecified way, used to create the content of\n+     * the file created by this method. See {@code originatingElements}\n+     * in {@link Filer#createResource}. {@link Elements#getFileObjectOf}\n+     * may be used to convert the {@code Element}s to {@code FileObject}s.\n+     *\n+     * <p>If the returned object represents a {@linkplain\n+     * JavaFileObject.Kind#SOURCE source} or {@linkplain\n+     * JavaFileObject.Kind#CLASS class} file, it must be an instance\n+     * of {@link JavaFileObject}.\n+     *\n+     * <p>Informally, the file object returned by this method is\n+     * located in the concatenation of the location, package name, and\n+     * relative name or in a location inferred from the {@code originatingFiles}.\n+     * See {@link #getFileForInput getFileForInput} for an example.\n+     *\n+     * @implSpec The default implementation calls\n+     * {@link #getFileForOutput(javax.tools.JavaFileManager.Location, java.lang.String, java.lang.String, javax.tools.FileObject) }\n+     * with the first element of the {@code originatingFiles}, if any, as a {@code sibling}.\n+     *\n+     * @param location an output location\n+     * @param packageName a package name\n+     * @param relativeName a relative name\n+     * @param originatingFiles the files which are contributing to this newly created file\n+     * @return a file object\n+     * @throws IllegalArgumentException if sibling is not known to\n+     * this file manager, or if the location is not known to this file\n+     * manager and the file manager does not support unknown\n+     * locations, or if {@code relativeName} is not valid,\n+     * or if the location is not an output location\n+     * @throws IOException if an I\/O error occurred, or if {@link\n+     * #close} has been called and this file manager cannot be\n+     * reopened\n+     * @throws IllegalStateException if {@link #close} has been called\n+     * and this file manager cannot be reopened\n+     * @since 18\n+     * @see Filer#createResource\n+     *\/\n+    default FileObject getFileForOutputForOriginatingFiles(Location location,\n+                                String packageName,\n+                                String relativeName,\n+                                FileObject... originatingFiles)\n+        throws IOException {\n+        return getFileForOutput(location, packageName, relativeName, siblingFrom(originatingFiles));\n+    }\n+\n@@ -597,0 +693,4 @@\n+    private static FileObject siblingFrom(FileObject[] originatingFiles) {\n+        return originatingFiles != null && originatingFiles.length > 0 ? originatingFiles[0] : null;\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/JavaFileManager.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -308,0 +308,11 @@\n+        @Override @DefinedBy(Api.COMPILER)\n+        public JavaFileObject getJavaFileForOutputForOriginatingFiles(Location location, String className, Kind kind, FileObject... originatingFiles) throws IOException {\n+            try {\n+                return wrap(clientJavaFileManager.getJavaFileForOutputForOriginatingFiles(location, className, kind, originatingFiles));\n+            } catch (ClientCodeException e) {\n+                throw e;\n+            } catch (RuntimeException | Error e) {\n+                throw new ClientCodeException(e);\n+            }\n+        }\n+\n@@ -319,0 +330,11 @@\n+        @Override @DefinedBy(Api.COMPILER)\n+        public FileObject getFileForOutputForOriginatingFiles(Location location, String packageName, String relativeName, FileObject... originatingFiles) throws IOException {\n+            try {\n+                return wrap(clientJavaFileManager.getFileForOutputForOriginatingFiles(location, packageName, relativeName, originatingFiles));\n+            } catch (ClientCodeException e) {\n+                throw e;\n+            } catch (RuntimeException | Error e) {\n+                throw new ClientCodeException(e);\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/ClientCodeWrapper.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -118,0 +118,6 @@\n+    @Override\n+    public JavaFileObject getJavaFileForOutputForOriginatingFiles(Location location, String className, Kind kind,\n+                                               FileObject... originatingFiles) throws IOException {\n+        return delegate(location).getJavaFileForOutputForOriginatingFiles(location, className, kind, originatingFiles);\n+    }\n+\n@@ -131,0 +137,6 @@\n+    public FileObject getFileForOutputForOriginatingFiles(Location location, String packageName, String relativeName,\n+                                       FileObject... originatingFiles) throws IOException {\n+        return delegate(location).getFileForOutputForOriginatingFiles(location, packageName, relativeName, originatingFiles);\n+    }\n+\n+    @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/DelegatingJavaFileManager.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import com.sun.tools.javac.code.Symbol;\n@@ -67,0 +68,1 @@\n+import java.util.stream.Collectors;\n@@ -435,1 +437,1 @@\n-        return createSourceOrClassFile(moduleAndClass.fst, true, moduleAndClass.snd);\n+        return createSourceOrClassFile(moduleAndClass.fst, true, moduleAndClass.snd, originatingElements);\n@@ -442,1 +444,1 @@\n-        return createSourceOrClassFile(moduleAndClass.fst, false, moduleAndClass.snd);\n+        return createSourceOrClassFile(moduleAndClass.fst, false, moduleAndClass.snd, originatingElements);\n@@ -486,1 +488,1 @@\n-    private JavaFileObject createSourceOrClassFile(ModuleSymbol mod, boolean isSourceFile, String name) throws IOException {\n+    private JavaFileObject createSourceOrClassFile(ModuleSymbol mod, boolean isSourceFile, String name, Element... originatingElements) throws IOException {\n@@ -509,1 +511,1 @@\n-            fileManager.getJavaFileForOutput(loc, name, kind, null);\n+            fileManager.getJavaFileForOutputForOriginatingFiles(loc, name, kind, originatingFiles(originatingElements));\n@@ -524,0 +526,12 @@\n+    private JavaFileObject[] originatingFiles(Element[] originatingElements) {\n+        if (originatingElements == null) {\n+            return new JavaFileObject[0];\n+        }\n+        JavaFileObject[] originatingFiles = Arrays.asList(originatingElements)\n+                .stream()\n+                .map(elementUtils::getFileObjectOf)\n+                .filter(fo -> fo != null)\n+                .toArray(s -> new JavaFileObject[s]);\n+        return originatingFiles;\n+    }\n+\n@@ -541,2 +555,2 @@\n-            fileManager.getFileForOutput(location, strPkg,\n-                                         relativeName.toString(), null);\n+            fileManager.getFileForOutputForOriginatingFiles(location, strPkg,\n+                                                            relativeName.toString(), originatingFiles(originatingElements));\n@@ -582,1 +596,1 @@\n-            fileObject = fileManager.getFileForOutput(location,\n+            fileObject = fileManager.getFileForOutputForOriginatingFiles(location,\n@@ -584,2 +598,1 @@\n-                    relativeName.toString(),\n-                    null);\n+                    relativeName.toString());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacFiler.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-                        \"close\", \"getJavaFileForInput\", \"getLocationForModule\", \"getServiceLoader\", \"contains\")) {\n+                        \"close\", \"getJavaFileForInput\", \"getLocationForModule\", \"getServiceLoader\",\n+                        \"contains\", \"getFileForOutput\", \"siblingFrom\")) {\n@@ -373,0 +374,6 @@\n+        @Override\n+        public JavaFileObject getJavaFileForOutputForOriginatingFiles(Location location, String className, Kind kind, FileObject... originatingFiles) throws IOException {\n+            throwUserExceptionIfNeeded(fileManagerMethod, \"getJavaFileForOutputForOriginatingFiles\");\n+            return wrap(super.getJavaFileForOutputForOriginatingFiles(location, className, kind, originatingFiles));\n+        }\n+\n@@ -385,0 +392,6 @@\n+        @Override\n+        public FileObject getFileForOutputForOriginatingFiles(Location location, String packageName, String relativeName, FileObject... originatingFiles) throws IOException {\n+            throwUserExceptionIfNeeded(fileManagerMethod, \"getFileForOutputForOriginatingFiles\");\n+            return wrap(super.getFileForOutputForOriginatingFiles(location, packageName, relativeName, originatingFiles));\n+        }\n+\n","filename":"test\/langtools\/tools\/javac\/api\/TestClientCodeWrapper.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8272234\n+ * @summary Verify proper handling of originating elements in javac's Filer.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.TestRunner toolbox.ToolBox TestOriginatingElements\n+ * @run main TestOriginatingElements\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Iterator;\n+import javax.annotation.processing.Filer;\n+import javax.annotation.processing.SupportedOptions;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaFileManager;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.StandardLocation;\n+import toolbox.JavacTask;\n+import toolbox.TestRunner;\n+import toolbox.TestRunner.Test;\n+import toolbox.ToolBox;\n+import toolbox.ToolBox.MemoryFileManager;\n+\n+public class TestOriginatingElements extends TestRunner {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestOriginatingElements().runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+    private final ToolBox tb = new ToolBox();\n+\n+    public TestOriginatingElements() {\n+        super(System.err);\n+    }\n+\n+    @Test\n+    public void testOriginatingElements(Path outerBase) throws Exception {\n+        Path libSrc = outerBase.resolve(\"lib-src\");\n+        tb.writeJavaFiles(libSrc,\n+                          \"\"\"\n+                          module lib { exports lib1; exports lib2; }\n+                          \"\"\",\n+                          \"\"\"\n+                          package lib1;\n+                          public @interface A {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package lib2;\n+                          public class Lib {\n+                          }\n+                          \"\"\");\n+        tb.writeFile(libSrc.resolve(\"lib1\/package-info.java\"), \"@A package lib1;\");\n+        Path libClasses = outerBase.resolve(\"lib-classes\");\n+        Path libClassesModule = libClasses.resolve(\"lib\");\n+        Files.createDirectories(libClassesModule);\n+\n+        new JavacTask(tb)\n+                .files(tb.findJavaFiles(libSrc))\n+                .outdir(libClassesModule)\n+                .run();\n+\n+        Path src = outerBase.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module m {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package t;\n+                          public class T1 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package t;\n+                          public class T2 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package t;\n+                          public class T3 {\n+                          }\n+                          \"\"\");\n+        tb.writeFile(src.resolve(\"p\/package-info.java\"), \"package p;\");\n+        Path classes = outerBase.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        try (StandardJavaFileManager sjfm = compiler.getStandardFileManager(null, null, null)) {\n+            List<String> testOutput = new ArrayList<>();\n+            JavaFileManager fm = new ForwardingJavaFileManager<JavaFileManager>(sjfm) {\n+                @Override\n+                public JavaFileObject getJavaFileForOutputForOriginatingFiles(Location location,\n+                                                                              String className,\n+                                                                              JavaFileObject.Kind kind,\n+                                                                              FileObject... originatingFiles) throws IOException {\n+                    List.of(originatingFiles)\n+                        .stream()\n+                        .map(fo -> getInfo(fo))\n+                        .forEach(testOutput::add);\n+                    return super.getJavaFileForOutputForOriginatingFiles(location, className, kind, originatingFiles);\n+                }\n+                @Override\n+                public FileObject getFileForOutputForOriginatingFiles(Location location,\n+                                                                      String packageName,\n+                                                                      String relativeName,\n+                                                                      FileObject... originatingFiles) throws IOException {\n+                    List.of(originatingFiles)\n+                        .stream()\n+                        .map(fo -> getInfo(fo))\n+                        .forEach(testOutput::add);\n+                    return super.getFileForOutputForOriginatingFiles(location, packageName, relativeName, originatingFiles);\n+                }\n+                private String getInfo(FileObject fo) {\n+                    try {\n+                        JavaFileObject jfo = (JavaFileObject) fo; \/\/the test only expects JavaFileObjects here:\n+                        JavaFileManager.Location location = jfo.getKind() == JavaFileObject.Kind.SOURCE\n+                                ? StandardLocation.SOURCE_PATH\n+                                : sjfm.getLocationForModule(StandardLocation.SYSTEM_MODULES, \"java.base\");\n+                        String binaryName = inferBinaryName(location, jfo);\n+                        return binaryName + \"(\" + jfo.getKind() + \")\";\n+                    } catch (IOException ex) {\n+                        throw new AssertionError(ex);\n+                    }\n+                }\n+            };\n+            try {\n+                String generatedData;\n+                try (MemoryFileManager mfm = new MemoryFileManager(sjfm)) {\n+                    compiler.getTask(null, mfm, null, null, null,\n+                                     List.of(new ToolBox.JavaSource(\"package test; public class Generated2 {}\")))\n+                            .call();\n+                    generatedData =\n+                            Base64.getEncoder().encodeToString(mfm.getFileBytes(StandardLocation.CLASS_OUTPUT, \"test.Generated2\"));\n+                }\n+                List<String> options = List.of(\"-sourcepath\", src.toString(),\n+                                               \"-processor\", \"TestOriginatingElements$P\",\n+                                               \"-processorpath\", System.getProperty(\"test.classes\"),\n+                                               \"--module-path\", libClasses.toString(),\n+                                               \"--add-modules\", \"lib\",\n+                                               \"-d\", classes.toString(),\n+                                               \"-AgeneratedData=\" + generatedData);\n+                ToolProvider.getSystemJavaCompiler()\n+                            .getTask(null, fm, null, options, null, sjfm.getJavaFileObjects(tb.findJavaFiles(src)))\n+                            .call();\n+                List<String> expectedOriginatingFiles = List.of(\"t.T1(SOURCE)\",\n+                                                                \"java.lang.String(CLASS)\",\n+                                                                \"p.package-info(SOURCE)\",\n+                                                                \"lib1.package-info(CLASS)\",\n+                                                                \"module-info(SOURCE)\",\n+                                                                \"module-info(CLASS)\",\n+                                                                \"t.T2(SOURCE)\",\n+                                                                \"java.lang.CharSequence(CLASS)\",\n+                                                                \"p.package-info(SOURCE)\",\n+                                                                \"lib1.package-info(CLASS)\",\n+                                                                \"module-info(SOURCE)\",\n+                                                                \"module-info(CLASS)\",\n+                                                                \"t.T3(SOURCE)\",\n+                                                                \"java.lang.Exception(CLASS)\",\n+                                                                \"p.package-info(SOURCE)\",\n+                                                                \"lib1.package-info(CLASS)\",\n+                                                                \"module-info(SOURCE)\",\n+                                                                \"module-info(CLASS)\");\n+                assertEquals(expectedOriginatingFiles, testOutput);\n+            } catch (IOException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"generatedData\")\n+    public static class P extends AbstractProcessor {\n+        int round;\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (round++ == 0) {\n+                ModuleElement mdl = processingEnv.getElementUtils().getModuleElement(\"m\");\n+                ModuleElement java_base = processingEnv.getElementUtils().getModuleElement(\"java.base\");\n+                PackageElement pack = processingEnv.getElementUtils().getPackageElement(\"p\");\n+                PackageElement lib1Pack = processingEnv.getElementUtils().getPackageElement(\"lib1\");\n+                PackageElement lib2Pack = processingEnv.getElementUtils().getPackageElement(\"lib2\");\n+                Filer filer = processingEnv.getFiler();\n+                try {\n+                    filer.createSourceFile(\"test.Generated1\",\n+                                           element(\"t.T1\"),\n+                                           element(\"java.lang.String\"),\n+                                           pack,\n+                                           lib1Pack,\n+                                           lib2Pack,\n+                                           mdl,\n+                                           java_base).openOutputStream().close();\n+                    try (OutputStream out = filer.createClassFile(\"test.Generated2\",\n+                                                                  element(\"t.T2\"),\n+                                                                  element(\"java.lang.CharSequence\"),\n+                                                                  pack,\n+                                                                  lib1Pack,\n+                                                                  lib2Pack,\n+                                                                  mdl,\n+                                                                  java_base).openOutputStream()) {\n+                        out.write(Base64.getDecoder().decode(processingEnv.getOptions().get(\"generatedData\")));\n+                    }\n+                    filer.createResource(StandardLocation.CLASS_OUTPUT,\n+                                         \"test\",\n+                                         \"Generated3.txt\",\n+                                         element(\"t.T3\"),\n+                                         element(\"java.lang.Exception\"),\n+                                         pack,\n+                                         lib1Pack,\n+                                         lib2Pack,\n+                                         mdl,\n+                                         java_base).openOutputStream().close();\n+                } catch (IOException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private Element element(String type) {\n+            return processingEnv.getElementUtils().getTypeElement(type);\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latest();\n+        }\n+    }\n+\n+    @Test\n+    public void testVacuousJavaFileManager(Path outerBase) throws Exception {\n+        List<String> log = new ArrayList<>();\n+        JavaFileObject expectedOut = new SimpleJavaFileObject(new URI(\"Out.java\"), JavaFileObject.Kind.SOURCE) {};\n+        JavaFileManager fm = new MinimalJavaFileManager() {\n+            @Override\n+            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {\n+                log.add(\"getJavaFileForOutput(\" + location + \", \" + className + \", \" + kind + \", \" + sibling);\n+                return expectedOut;\n+            }\n+            @Override\n+            public FileObject getFileForOutput(JavaFileManager.Location location, String packageName, String relativeName, FileObject sibling) throws IOException {\n+                log.add(\"getFileForOutput(\" + location + \", \" + packageName + \", \" + relativeName  + \", \" + sibling);\n+                return expectedOut;\n+            }\n+        };\n+\n+        FileObject fo1 = new SimpleJavaFileObject(new URI(\"Test1.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public String toString() {\n+                return \"Test1 - FO\";\n+            }\n+        };\n+        FileObject fo2 = new SimpleJavaFileObject(new URI(\"Test2.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public String toString() {\n+                return \"Test2 - FO\";\n+            }\n+        };\n+\n+        assertEquals(expectedOut,\n+                     fm.getJavaFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test.Test\", JavaFileObject.Kind.SOURCE, fo1, fo2));\n+        assertEquals(List.of(\"getJavaFileForOutput(CLASS_OUTPUT, test.Test, SOURCE, Test1 - FO\"), log); log.clear();\n+\n+        assertEquals(expectedOut,\n+                     fm.getJavaFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test.Test\", JavaFileObject.Kind.SOURCE));\n+        assertEquals(List.of(\"getJavaFileForOutput(CLASS_OUTPUT, test.Test, SOURCE, null\"), log); log.clear();\n+\n+        assertEquals(expectedOut,\n+                     fm.getFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test\", \"Test.java\", fo1, fo2));\n+        assertEquals(List.of(\"getFileForOutput(CLASS_OUTPUT, test, Test.java, Test1 - FO\"), log); log.clear();\n+        assertEquals(expectedOut,\n+                     fm.getFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test\", \"Test.java\"));\n+        assertEquals(List.of(\"getFileForOutput(CLASS_OUTPUT, test, Test.java, null\"), log); log.clear();\n+    }\n+\n+    @Test\n+    public void testForwardingJavaFileManager(Path outerBase) throws Exception {\n+        List<String> log = new ArrayList<>();\n+        JavaFileObject expectedOut = new SimpleJavaFileObject(new URI(\"Out.java\"), JavaFileObject.Kind.SOURCE) {};\n+\n+        FileObject fo1 = new SimpleJavaFileObject(new URI(\"Test1.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public String toString() {\n+                return \"Test1 - FO\";\n+            }\n+        };\n+        FileObject fo2 = new SimpleJavaFileObject(new URI(\"Test2.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public String toString() {\n+                return \"Test2 - FO\";\n+            }\n+        };\n+\n+        JavaFileManager forwardingWithOverride = new ForwardingJavaFileManager<>(new MinimalJavaFileManager() {\n+            @Override\n+            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {\n+                log.add(\"getJavaFileForOutput(\" + location + \", \" + className + \", \" + kind + \", \" + sibling);\n+                return expectedOut;\n+            }\n+            @Override\n+            public JavaFileObject getJavaFileForOutputForOriginatingFiles(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject... originatingFiles) throws IOException {\n+                throw new AssertionError(\"Should not be called.\");\n+            }\n+            @Override\n+            public FileObject getFileForOutput(JavaFileManager.Location location, String packageName, String relativeName, FileObject sibling) throws IOException {\n+                log.add(\"getFileForOutput(\" + location + \", \" + packageName + \", \" + relativeName  + \", \" + sibling);\n+                return expectedOut;\n+            }\n+            @Override\n+            public FileObject getFileForOutputForOriginatingFiles(JavaFileManager.Location location, String packageName, String relativeName, FileObject... originatingFiles) throws IOException {\n+                throw new AssertionError(\"Should not be called.\");\n+            }\n+        }) {\n+            @Override\n+            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {\n+                return super.getJavaFileForOutput(location, className, kind, sibling);\n+            }\n+            @Override\n+            public FileObject getFileForOutput(JavaFileManager.Location location, String packageName, String relativeName, FileObject sibling) throws IOException {\n+                return super.getFileForOutput(location, packageName, relativeName, sibling);\n+            }\n+        };\n+\n+        assertEquals(expectedOut,\n+                     forwardingWithOverride.getJavaFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test.Test\", JavaFileObject.Kind.SOURCE, fo1, fo2));\n+        assertEquals(List.of(\"getJavaFileForOutput(CLASS_OUTPUT, test.Test, SOURCE, Test1 - FO\"), log); log.clear();\n+\n+        assertEquals(expectedOut,\n+                     forwardingWithOverride.getJavaFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test.Test\", JavaFileObject.Kind.SOURCE));\n+        assertEquals(List.of(\"getJavaFileForOutput(CLASS_OUTPUT, test.Test, SOURCE, null\"), log); log.clear();\n+\n+        assertEquals(expectedOut,\n+                     forwardingWithOverride.getFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test\", \"Test.java\", fo1, fo2));\n+        assertEquals(List.of(\"getFileForOutput(CLASS_OUTPUT, test, Test.java, Test1 - FO\"), log); log.clear();\n+        assertEquals(expectedOut,\n+                     forwardingWithOverride.getFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test\", \"Test.java\"));\n+        assertEquals(List.of(\"getFileForOutput(CLASS_OUTPUT, test, Test.java, null\"), log); log.clear();\n+\n+        JavaFileManager forwardingWithOutOverride = new ForwardingJavaFileManager<>(new MinimalJavaFileManager() {\n+            @Override\n+            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {\n+                throw new AssertionError(\"Should not be called.\");\n+            }\n+            @Override\n+            public JavaFileObject getJavaFileForOutputForOriginatingFiles(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject... originatingFiles) throws IOException {\n+                log.add(\"getJavaFileForOutputForOriginatingFiles(\" + location + \", \" + className + \", \" + kind + \", \" + List.of(originatingFiles));\n+                return expectedOut;\n+            }\n+            @Override\n+            public FileObject getFileForOutput(JavaFileManager.Location location, String packageName, String relativeName, FileObject sibling) throws IOException {\n+                throw new AssertionError(\"Should not be called.\");\n+            }\n+            @Override\n+            public FileObject getFileForOutputForOriginatingFiles(JavaFileManager.Location location, String packageName, String relativeName, FileObject... originatingFiles) throws IOException {\n+                log.add(\"getFileForOutputForOriginatingFiles(\" + location + \", \" + packageName + \", \" + relativeName  + \", \" + List.of(originatingFiles));\n+                return expectedOut;\n+            }\n+        }) {};\n+\n+        assertEquals(expectedOut,\n+                     forwardingWithOutOverride.getJavaFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test.Test\", JavaFileObject.Kind.SOURCE, fo1, fo2));\n+        assertEquals(List.of(\"getJavaFileForOutputForOriginatingFiles(CLASS_OUTPUT, test.Test, SOURCE, [Test1 - FO, Test2 - FO]\"), log); log.clear();\n+\n+        assertEquals(expectedOut,\n+                     forwardingWithOutOverride.getJavaFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test.Test\", JavaFileObject.Kind.SOURCE));\n+        assertEquals(List.of(\"getJavaFileForOutputForOriginatingFiles(CLASS_OUTPUT, test.Test, SOURCE, []\"), log); log.clear();\n+\n+        assertEquals(expectedOut,\n+                     forwardingWithOutOverride.getFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test\", \"Test.java\", fo1, fo2));\n+        assertEquals(List.of(\"getFileForOutputForOriginatingFiles(CLASS_OUTPUT, test, Test.java, [Test1 - FO, Test2 - FO]\"), log); log.clear();\n+        assertEquals(expectedOut,\n+                     forwardingWithOutOverride.getFileForOutputForOriginatingFiles(StandardLocation.CLASS_OUTPUT, \"test\", \"Test.java\"));\n+        assertEquals(List.of(\"getFileForOutputForOriginatingFiles(CLASS_OUTPUT, test, Test.java, []\"), log); log.clear();\n+    }\n+\n+    class MinimalJavaFileManager implements JavaFileManager {\n+            @Override\n+            public ClassLoader getClassLoader(JavaFileManager.Location location) {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public Iterable<JavaFileObject> list(JavaFileManager.Location location, String packageName, Set<JavaFileObject.Kind> kinds, boolean recurse) throws IOException {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public String inferBinaryName(JavaFileManager.Location location, JavaFileObject file) {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public boolean isSameFile(FileObject a, FileObject b) {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public boolean handleOption(String current, Iterator<String> remaining) {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public boolean hasLocation(JavaFileManager.Location location) {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public JavaFileObject getJavaFileForInput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind) throws IOException {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public FileObject getFileForInput(JavaFileManager.Location location, String packageName, String relativeName) throws IOException {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public FileObject getFileForOutput(JavaFileManager.Location location, String packageName, String relativeName, FileObject sibling) throws IOException {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public void flush() throws IOException {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public void close() throws IOException {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+            @Override\n+            public int isSupportedOption(String option) {\n+                throw new UnsupportedOperationException(\"Not supported.\");\n+            }\n+        };\n+\n+    private void assertEquals(Object expected, Object actual) throws AssertionError {\n+        if (!expected.equals(actual)) {\n+            throw new AssertionError(\"Unexpected  output: \" + actual + \", expected: \" + expected);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/filer\/TestOriginatingElements.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"}]}