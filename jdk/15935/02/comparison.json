{"files":[{"patch":"@@ -516,1 +516,1 @@\n-            ListFormat [locale: \"%s\", start: \"%s\", middle: \"%s\",  end: \"%s\", two: \"%s\", three: \"%s\"]\n+            ListFormat [locale: \"%s\", start: \"%s\", middle: \"%s\", end: \"%s\", two: \"%s\", three: \"%s\"]\n","filename":"src\/java.base\/share\/classes\/java\/text\/ListFormat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -846,1 +846,1 @@\n-        String cacheKey = LIST_PATTERN + typeStr;\n+        String cacheKey = LIST_PATTERN + typeStr + styleStr;\n@@ -854,2 +854,15 @@\n-            if (lpArray == null) {\n-                cache.put(cacheKey, new ResourceReference(cacheKey, new String[5], referenceQueue));\n+\n+            if (lpArray[0].isEmpty() || lpArray[1].isEmpty() || lpArray[2].isEmpty()) {\n+                var adapter = LocaleProviderAdapter.forType(LocaleProviderAdapter.Type.CLDR);\n+                if (adapter instanceof ResourceBundleBasedAdapter rbba) {\n+                    var candList = rbba.getCandidateLocales(\"\", locale);\n+                    \/\/ make sure there is at least one parent locale\n+                    if (candList.size() >= 2) {\n+                        var parentPatterns = adapter.getLocaleResources(candList.get(1)).getListPatterns(type, style);\n+                        for (int i = 0; i < 3; i++) { \/\/ exclude optional ones, ie, \"two\"\/\"three\"\n+                            if (lpArray[i].isEmpty()) {\n+                                lpArray[i] = parentPatterns[i];\n+                            }\n+                        }\n+                    }\n+                }\n@@ -857,0 +870,1 @@\n+            cache.put(cacheKey, new ResourceReference(cacheKey, lpArray, referenceQueue));\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/LocaleResources.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8041488\n+ * @bug 8041488 8316974\n@@ -203,1 +203,13 @@\n-\n+    static Arguments[] getInstance_3Arg_InheritPatterns() {\n+        return new Arguments[] {\n+                arguments(ListFormat.Type.STANDARD, ListFormat.Style.FULL),\n+                arguments(ListFormat.Type.STANDARD, ListFormat.Style.SHORT),\n+                arguments(ListFormat.Type.STANDARD, ListFormat.Style.NARROW),\n+                arguments(ListFormat.Type.OR, ListFormat.Style.FULL),\n+                arguments(ListFormat.Type.OR, ListFormat.Style.SHORT),\n+                arguments(ListFormat.Type.OR, ListFormat.Style.NARROW),\n+                arguments(ListFormat.Type.UNIT, ListFormat.Style.FULL),\n+                arguments(ListFormat.Type.UNIT, ListFormat.Style.SHORT),\n+                arguments(ListFormat.Type.UNIT, ListFormat.Style.NARROW),\n+        };\n+    }\n@@ -292,0 +304,21 @@\n+    @ParameterizedTest\n+    @MethodSource\n+    void getInstance_3Arg_InheritPatterns(ListFormat.Type type, ListFormat.Style style) {\n+        \/\/ No IAE should be thrown for all locales. Some locales in CLDR\n+        \/\/ have partial patterns (start, middle, end) in it. Lacking ones\n+        \/\/ should be inherited from parent locales.\n+        Locale.availableLocales().forEach(l -> ListFormat.getInstance(l, type, style));\n+    }\n+    @Test\n+    void getInstance_3Arg_InheritanceValidation() {\n+        \/\/ Tests if inheritance works as expected.\n+        \/\/ World English (\"en-001\") has non-Oxford-comma pattern for \"end\", while\n+        \/\/ English (\"en\") has Oxford-comma \"end\" pattern. Thus missing \"standard\"\/\"middle\"\n+        \/\/ should be inherited from \"en\", but \"end\" should stay non-Oxford for \"en-001\"\n+        \/\/ Note that this test depends on a particular version of CLDR data.\n+        assertEquals(\"\"\"\n+            ListFormat [locale: \"English (world)\", start: \"{0}, {1}\", middle: \"{0}, {1}\", end: \"{0} and {1}\", two: \"{0} and {1}\", three: \"{0}, {1} and {2}\"]\n+            \"\"\",\n+            ListFormat.getInstance(Locale.forLanguageTag(\"en-001\"), ListFormat.Type.STANDARD, ListFormat.Style.FULL).toString());\n+    }\n+\n","filename":"test\/jdk\/java\/text\/Format\/ListFormat\/TestListFormat.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"}]}