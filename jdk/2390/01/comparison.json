{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilerThread.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+class CompileTask;\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,1 @@\n+class AbstractCompiler;\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"runtime\/sweeper.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+\/\/ Create a CompilerThread\n+CompilerThread::CompilerThread(CompileQueue* queue,\n+                               CompilerCounters* counters)\n+                               : JavaThread(&CompilerThread::thread_entry) {\n+  _env   = NULL;\n+  _log   = NULL;\n+  _task  = NULL;\n+  _queue = queue;\n+  _counters = counters;\n+  _buffer_blob = NULL;\n+  _compiler = NULL;\n+\n+  \/\/ Compiler uses resource area for compilation, let's bias it to mtCompiler\n+  resource_area()->bias_to(mtCompiler);\n+\n+#ifndef PRODUCT\n+  _ideal_graph_printer = NULL;\n+#endif\n+}\n+\n+CompilerThread::~CompilerThread() {\n+  \/\/ Delete objects which were allocated on heap.\n+  delete _counters;\n+}\n+\n+void CompilerThread::thread_entry(JavaThread* thread, TRAPS) {\n+  assert(thread->is_Compiler_thread(), \"must be compiler thread\");\n+  CompileBroker::compiler_thread_loop();\n+}\n+\n+bool CompilerThread::can_call_java() const {\n+  return _compiler != NULL && _compiler->is_jvmci();\n+}\n+\n+\/\/ Create sweeper thread\n+CodeCacheSweeperThread::CodeCacheSweeperThread()\n+: JavaThread(&CodeCacheSweeperThread::thread_entry) {\n+  _scanned_compiled_method = NULL;\n+}\n+\n+void CodeCacheSweeperThread::thread_entry(JavaThread* thread, TRAPS) {\n+  NMethodSweeper::sweeper_loop();\n+}\n+\n+void CodeCacheSweeperThread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n+  JavaThread::oops_do_no_frames(f, cf);\n+  if (_scanned_compiled_method != NULL && cf != NULL) {\n+    \/\/ Safepoints can occur when the sweeper is scanning an nmethod so\n+    \/\/ process it here to make sure it isn't unloaded in the middle of\n+    \/\/ a scan.\n+    cf->do_code_blob(_scanned_compiled_method);\n+  }\n+}\n+\n+void CodeCacheSweeperThread::nmethods_do(CodeBlobClosure* cf) {\n+  JavaThread::nmethods_do(cf);\n+  if (_scanned_compiled_method != NULL && cf != NULL) {\n+    \/\/ Safepoints can occur when the sweeper is scanning an nmethod so\n+    \/\/ process it here to make sure it isn't unloaded in the middle of\n+    \/\/ a scan.\n+    cf->do_code_blob(_scanned_compiled_method);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILERTHREAD_HPP\n+#define SHARE_COMPILER_COMPILERTHREAD_HPP\n+\n+#include \"runtime\/thread.hpp\"\n+\n+class BufferBlob;\n+class AbstractCompiler;\n+class ciEnv;\n+class CompileThread;\n+class CompileLog;\n+class CompileTask;\n+class CompileQueue;\n+class CompilerCounters;\n+class IdealGraphPrinter;\n+class JVMCIEnv;\n+class JVMCIPrimitiveArray;\n+\n+\/\/ A thread used for Compilation.\n+class CompilerThread : public JavaThread {\n+  friend class VMStructs;\n+ private:\n+  CompilerCounters* _counters;\n+\n+  ciEnv*                _env;\n+  CompileLog*           _log;\n+  CompileTask* volatile _task;  \/\/ print_threads_compiling can read this concurrently.\n+  CompileQueue*         _queue;\n+  BufferBlob*           _buffer_blob;\n+\n+  AbstractCompiler*     _compiler;\n+  TimeStamp             _idle_time;\n+\n+ public:\n+\n+  static CompilerThread* current();\n+\n+  CompilerThread(CompileQueue* queue, CompilerCounters* counters);\n+  ~CompilerThread();\n+\n+  bool is_Compiler_thread() const                { return true; }\n+\n+  virtual bool can_call_java() const;\n+\n+  \/\/ Hide native compiler threads from external view.\n+  bool is_hidden_from_external_view() const      { return !can_call_java(); }\n+\n+  void set_compiler(AbstractCompiler* c)         { _compiler = c; }\n+  AbstractCompiler* compiler() const             { return _compiler; }\n+\n+  CompileQueue* queue()        const             { return _queue; }\n+  CompilerCounters* counters() const             { return _counters; }\n+\n+  \/\/ Get\/set the thread's compilation environment.\n+  ciEnv*        env()                            { return _env; }\n+  void          set_env(ciEnv* env)              { _env = env; }\n+\n+  BufferBlob*   get_buffer_blob() const          { return _buffer_blob; }\n+  void          set_buffer_blob(BufferBlob* b)   { _buffer_blob = b; }\n+\n+  \/\/ Get\/set the thread's logging information\n+  CompileLog*   log()                            { return _log; }\n+  void          init_log(CompileLog* log) {\n+    \/\/ Set once, for good.\n+    assert(_log == NULL, \"set only once\");\n+    _log = log;\n+  }\n+\n+  void start_idle_timer()                        { _idle_time.update(); }\n+  jlong idle_time_millis() {\n+    return TimeHelper::counter_to_millis(_idle_time.ticks_since_update());\n+  }\n+\n+#ifndef PRODUCT\n+ private:\n+  IdealGraphPrinter *_ideal_graph_printer;\n+ public:\n+  IdealGraphPrinter *ideal_graph_printer()           { return _ideal_graph_printer; }\n+  void set_ideal_graph_printer(IdealGraphPrinter *n) { _ideal_graph_printer = n; }\n+#endif\n+\n+  \/\/ Get\/set the thread's current task\n+  CompileTask* task()                      { return _task; }\n+  void         set_task(CompileTask* task) { _task = task; }\n+\n+  static void thread_entry(JavaThread* thread, TRAPS);\n+};\n+\n+inline CompilerThread* JavaThread::as_CompilerThread() {\n+  assert(is_Compiler_thread(), \"just checking\");\n+  return (CompilerThread*)this;\n+}\n+\n+inline CompilerThread* CompilerThread::current() {\n+  return JavaThread::current()->as_CompilerThread();\n+}\n+\n+\/\/ Dedicated thread to sweep the code cache\n+class CodeCacheSweeperThread : public JavaThread {\n+  CompiledMethod*       _scanned_compiled_method; \/\/ nmethod being scanned by the sweeper\n+\n+  static void thread_entry(JavaThread* thread, TRAPS);\n+\n+ public:\n+  CodeCacheSweeperThread();\n+  \/\/ Track the nmethod currently being scanned by the sweeper\n+  void set_scanned_compiled_method(CompiledMethod* cm) {\n+    assert(_scanned_compiled_method == NULL || cm == NULL, \"should reset to NULL before writing a new value\");\n+    _scanned_compiled_method = cm;\n+  }\n+\n+  \/\/ Hide sweeper thread from external view.\n+  bool is_hidden_from_external_view() const { return true; }\n+\n+  bool is_Code_cache_sweeper_thread() const { return true; }\n+\n+  \/\/ Prevent GC from unloading _scanned_compiled_method\n+  void oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf);\n+  void nmethods_do(CodeBlobClosure* cf);\n+};\n+\n+\n+#endif  \/\/ SHARE_COMPILER_COMPILERTHREAD_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/gcId.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class BufferBlob;\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrThreadIterator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"compiler\/compilerThread.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm_io.h\"\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/gcId.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/task.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n+#include \"utilities\/singleWriterSynchronizer.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n+\n+\/\/ List of all NonJavaThreads and safe iteration over that list.\n+\n+class NonJavaThread::List {\n+public:\n+  NonJavaThread* volatile _head;\n+  SingleWriterSynchronizer _protect;\n+\n+  List() : _head(NULL), _protect() {}\n+};\n+\n+NonJavaThread::List NonJavaThread::_the_list;\n+\n+NonJavaThread::Iterator::Iterator() :\n+  _protect_enter(_the_list._protect.enter()),\n+  _current(Atomic::load_acquire(&_the_list._head))\n+{}\n+\n+NonJavaThread::Iterator::~Iterator() {\n+  _the_list._protect.exit(_protect_enter);\n+}\n+\n+void NonJavaThread::Iterator::step() {\n+  assert(!end(), \"precondition\");\n+  _current = Atomic::load_acquire(&_current->_next);\n+}\n+\n+NonJavaThread::NonJavaThread() : Thread(), _next(NULL) {\n+  assert(BarrierSet::barrier_set() != NULL, \"NonJavaThread created too soon!\");\n+}\n+\n+NonJavaThread::~NonJavaThread() { }\n+\n+void NonJavaThread::add_to_the_list() {\n+  MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);\n+  \/\/ Initialize BarrierSet-related data before adding to list.\n+  BarrierSet::barrier_set()->on_thread_attach(this);\n+  Atomic::release_store(&_next, _the_list._head);\n+  Atomic::release_store(&_the_list._head, this);\n+}\n+\n+void NonJavaThread::remove_from_the_list() {\n+  {\n+    MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ Cleanup BarrierSet-related data before removing from list.\n+    BarrierSet::barrier_set()->on_thread_detach(this);\n+    NonJavaThread* volatile* p = &_the_list._head;\n+    for (NonJavaThread* t = *p; t != NULL; p = &t->_next, t = *p) {\n+      if (t == this) {\n+        *p = _next;\n+        break;\n+      }\n+    }\n+  }\n+  \/\/ Wait for any in-progress iterators.  Concurrent synchronize is not\n+  \/\/ allowed, so do it while holding a dedicated lock.  Outside and distinct\n+  \/\/ from NJTList_lock in case an iteration attempts to lock it.\n+  MutexLocker ml(NonJavaThreadsListSync_lock, Mutex::_no_safepoint_check_flag);\n+  _the_list._protect.synchronize();\n+  _next = NULL;                 \/\/ Safe to drop the link now.\n+}\n+\n+void NonJavaThread::pre_run() {\n+  add_to_the_list();\n+\n+  \/\/ This is slightly odd in that NamedThread is a subclass, but\n+  \/\/ in fact name() is defined in Thread\n+  assert(this->name() != NULL, \"thread name was not set before it was started\");\n+  this->set_native_thread_name(this->name());\n+}\n+\n+void NonJavaThread::post_run() {\n+  JFR_ONLY(Jfr::on_thread_exit(this);)\n+  remove_from_the_list();\n+  unregister_thread_stack_with_NMT();\n+  \/\/ Ensure thread-local-storage is cleared before termination.\n+  Thread::clear_thread_current();\n+  osthread()->set_state(ZOMBIE);\n+}\n+\n+\/\/ NamedThread --  non-JavaThread subclasses with multiple\n+\/\/ uniquely named instances should derive from this.\n+NamedThread::NamedThread() :\n+  NonJavaThread(),\n+  _name(NULL),\n+  _processed_thread(NULL),\n+  _gc_id(GCId::undefined())\n+{}\n+\n+NamedThread::~NamedThread() {\n+  FREE_C_HEAP_ARRAY(char, _name);\n+}\n+\n+void NamedThread::set_name(const char* format, ...) {\n+  guarantee(_name == NULL, \"Only get to set name once.\");\n+  _name = NEW_C_HEAP_ARRAY(char, max_name_len, mtThread);\n+  va_list ap;\n+  va_start(ap, format);\n+  jio_vsnprintf(_name, max_name_len, format, ap);\n+  va_end(ap);\n+}\n+\n+void NamedThread::print_on(outputStream* st) const {\n+  st->print(\"\\\"%s\\\" \", name());\n+  Thread::print_on(st);\n+  st->cr();\n+}\n+\n+\n+\/\/ ======= WatcherThread ========\n+\n+\/\/ The watcher thread exists to simulate timer interrupts.  It should\n+\/\/ be replaced by an abstraction over whatever native support for\n+\/\/ timer interrupts exists on the platform.\n+\n+WatcherThread* WatcherThread::_watcher_thread   = NULL;\n+bool WatcherThread::_startable = false;\n+volatile bool  WatcherThread::_should_terminate = false;\n+\n+WatcherThread::WatcherThread() : NonJavaThread() {\n+  assert(watcher_thread() == NULL, \"we can only allocate one WatcherThread\");\n+  if (os::create_thread(this, os::watcher_thread)) {\n+    _watcher_thread = this;\n+\n+    \/\/ Set the watcher thread to the highest OS priority which should not be\n+    \/\/ used, unless a Java thread with priority java.lang.Thread.MAX_PRIORITY\n+    \/\/ is created. The only normal thread using this priority is the reference\n+    \/\/ handler thread, which runs for very short intervals only.\n+    \/\/ If the VMThread's priority is not lower than the WatcherThread profiling\n+    \/\/ will be inaccurate.\n+    os::set_priority(this, MaxPriority);\n+    os::start_thread(this);\n+  }\n+}\n+\n+int WatcherThread::sleep() const {\n+  \/\/ The WatcherThread does not participate in the safepoint protocol\n+  \/\/ for the PeriodicTask_lock because it is not a JavaThread.\n+  MonitorLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);\n+\n+  if (_should_terminate) {\n+    \/\/ check for termination before we do any housekeeping or wait\n+    return 0;  \/\/ we did not sleep.\n+  }\n+\n+  \/\/ remaining will be zero if there are no tasks,\n+  \/\/ causing the WatcherThread to sleep until a task is\n+  \/\/ enrolled\n+  int remaining = PeriodicTask::time_to_wait();\n+  int time_slept = 0;\n+\n+  \/\/ we expect this to timeout - we only ever get unparked when\n+  \/\/ we should terminate or when a new task has been enrolled\n+  OSThreadWaitState osts(this->osthread(), false \/* not Object.wait() *\/);\n+\n+  jlong time_before_loop = os::javaTimeNanos();\n+\n+  while (true) {\n+    bool timedout = ml.wait(remaining);\n+    jlong now = os::javaTimeNanos();\n+\n+    if (remaining == 0) {\n+      \/\/ if we didn't have any tasks we could have waited for a long time\n+      \/\/ consider the time_slept zero and reset time_before_loop\n+      time_slept = 0;\n+      time_before_loop = now;\n+    } else {\n+      \/\/ need to recalculate since we might have new tasks in _tasks\n+      time_slept = (int) ((now - time_before_loop) \/ 1000000);\n+    }\n+\n+    \/\/ Change to task list or spurious wakeup of some kind\n+    if (timedout || _should_terminate) {\n+      break;\n+    }\n+\n+    remaining = PeriodicTask::time_to_wait();\n+    if (remaining == 0) {\n+      \/\/ Last task was just disenrolled so loop around and wait until\n+      \/\/ another task gets enrolled\n+      continue;\n+    }\n+\n+    remaining -= time_slept;\n+    if (remaining <= 0) {\n+      break;\n+    }\n+  }\n+\n+  return time_slept;\n+}\n+\n+void WatcherThread::run() {\n+  assert(this == watcher_thread(), \"just checking\");\n+\n+  this->set_active_handles(JNIHandleBlock::allocate_block());\n+  while (true) {\n+    assert(watcher_thread() == Thread::current(), \"thread consistency check\");\n+    assert(watcher_thread() == this, \"thread consistency check\");\n+\n+    \/\/ Calculate how long it'll be until the next PeriodicTask work\n+    \/\/ should be done, and sleep that amount of time.\n+    int time_waited = sleep();\n+\n+    if (VMError::is_error_reported()) {\n+      \/\/ A fatal error has happened, the error handler(VMError::report_and_die)\n+      \/\/ should abort JVM after creating an error log file. However in some\n+      \/\/ rare cases, the error handler itself might deadlock. Here periodically\n+      \/\/ check for error reporting timeouts, and if it happens, just proceed to\n+      \/\/ abort the VM.\n+\n+      \/\/ This code is in WatcherThread because WatcherThread wakes up\n+      \/\/ periodically so the fatal error handler doesn't need to do anything;\n+      \/\/ also because the WatcherThread is less likely to crash than other\n+      \/\/ threads.\n+\n+      for (;;) {\n+        \/\/ Note: we use naked sleep in this loop because we want to avoid using\n+        \/\/ any kind of VM infrastructure which may be broken at this point.\n+        if (VMError::check_timeout()) {\n+          \/\/ We hit error reporting timeout. Error reporting was interrupted and\n+          \/\/ will be wrapping things up now (closing files etc). Give it some more\n+          \/\/ time, then quit the VM.\n+          os::naked_short_sleep(200);\n+          \/\/ Print a message to stderr.\n+          fdStream err(defaultStream::output_fd());\n+          err.print_raw_cr(\"# [ timer expired, abort... ]\");\n+          \/\/ skip atexit\/vm_exit\/vm_abort hooks\n+          os::die();\n+        }\n+\n+        \/\/ Wait a second, then recheck for timeout.\n+        os::naked_short_sleep(999);\n+      }\n+    }\n+\n+    if (_should_terminate) {\n+      \/\/ check for termination before posting the next tick\n+      break;\n+    }\n+\n+    PeriodicTask::real_time_tick(time_waited);\n+  }\n+\n+  \/\/ Signal that it is terminated\n+  {\n+    MutexLocker mu(Terminator_lock, Mutex::_no_safepoint_check_flag);\n+    _watcher_thread = NULL;\n+    Terminator_lock->notify_all();\n+  }\n+}\n+\n+void WatcherThread::start() {\n+  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n+\n+  if (watcher_thread() == NULL && _startable) {\n+    _should_terminate = false;\n+    \/\/ Create the single instance of WatcherThread\n+    new WatcherThread();\n+  }\n+}\n+\n+void WatcherThread::make_startable() {\n+  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n+  _startable = true;\n+}\n+\n+void WatcherThread::stop() {\n+  {\n+    \/\/ Follow normal safepoint aware lock enter protocol since the\n+    \/\/ WatcherThread is stopped by another JavaThread.\n+    MutexLocker ml(PeriodicTask_lock);\n+    _should_terminate = true;\n+\n+    WatcherThread* watcher = watcher_thread();\n+    if (watcher != NULL) {\n+      \/\/ unpark the WatcherThread so it can see that it should terminate\n+      watcher->unpark();\n+    }\n+  }\n+\n+  MonitorLocker mu(Terminator_lock);\n+\n+  while (watcher_thread() != NULL) {\n+    \/\/ This wait should make safepoint checks, wait without a timeout,\n+    \/\/ and wait as a suspend-equivalent condition.\n+    mu.wait(0, Mutex::_as_suspend_equivalent_flag);\n+  }\n+}\n+\n+void WatcherThread::unpark() {\n+  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n+  PeriodicTask_lock->notify();\n+}\n+\n+void WatcherThread::print_on(outputStream* st) const {\n+  st->print(\"\\\"%s\\\" \", name());\n+  Thread::print_on(st);\n+  st->cr();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_NONJAVATHREAD_HPP\n+#define SHARE_RUNTIME_NONJAVATHREAD_HPP\n+\n+#include \"runtime\/thread.hpp\"\n+\n+class NonJavaThread: public Thread {\n+  friend class VMStructs;\n+\n+  NonJavaThread* volatile _next;\n+\n+  class List;\n+  static List _the_list;\n+\n+  void add_to_the_list();\n+  void remove_from_the_list();\n+\n+ protected:\n+  virtual void pre_run();\n+  virtual void post_run();\n+\n+ public:\n+  NonJavaThread();\n+  ~NonJavaThread();\n+\n+  class Iterator;\n+};\n+\n+\/\/ Provides iteration over the list of NonJavaThreads.\n+\/\/ List addition occurs in pre_run(), and removal occurs in post_run(),\n+\/\/ so that only live fully-initialized threads can be found in the list.\n+\/\/ Threads created after an iterator is constructed will not be visited\n+\/\/ by the iterator. The scope of an iterator is a critical section; there\n+\/\/ must be no safepoint checks in that scope.\n+class NonJavaThread::Iterator : public StackObj {\n+  uint _protect_enter;\n+  NonJavaThread* _current;\n+\n+  NONCOPYABLE(Iterator);\n+\n+public:\n+  Iterator();\n+  ~Iterator();\n+\n+  bool end() const { return _current == NULL; }\n+  NonJavaThread* current() const { return _current; }\n+  void step();\n+};\n+\n+\/\/ Name support for threads.  non-JavaThread subclasses with multiple\n+\/\/ uniquely named instances should derive from this.\n+class NamedThread: public NonJavaThread {\n+  friend class VMStructs;\n+  enum {\n+    max_name_len = 64\n+  };\n+ private:\n+  char* _name;\n+  \/\/ log Thread being processed by oops_do\n+  Thread* _processed_thread;\n+  uint _gc_id; \/\/ The current GC id when a thread takes part in GC\n+\n+ public:\n+  NamedThread();\n+  ~NamedThread();\n+  \/\/ May only be called once per thread.\n+  void set_name(const char* format, ...)  ATTRIBUTE_PRINTF(2, 3);\n+  virtual bool is_Named_thread() const { return true; }\n+  virtual char* name() const { return _name == NULL ? (char*)\"Unknown Thread\" : _name; }\n+  Thread *processed_thread() { return _processed_thread; }\n+  void set_processed_thread(Thread *thread) { _processed_thread = thread; }\n+  virtual void print_on(outputStream* st) const;\n+\n+  void set_gc_id(uint gc_id) { _gc_id = gc_id; }\n+  uint gc_id() { return _gc_id; }\n+};\n+\n+\/\/ Worker threads are named and have an id of an assigned work.\n+class WorkerThread: public NamedThread {\n+ private:\n+  uint _id;\n+ public:\n+  WorkerThread() : _id(0)               { }\n+  virtual bool is_Worker_thread() const { return true; }\n+\n+  virtual WorkerThread* as_Worker_thread() const {\n+    assert(is_Worker_thread(), \"Dubious cast to WorkerThread*?\");\n+    return (WorkerThread*) this;\n+  }\n+\n+  void set_id(uint work_id)             { _id = work_id; }\n+  uint id() const                       { return _id; }\n+};\n+\n+\/\/ A single WatcherThread is used for simulating timer interrupts.\n+class WatcherThread: public NonJavaThread {\n+  friend class VMStructs;\n+ protected:\n+  virtual void run();\n+\n+ private:\n+  static WatcherThread* _watcher_thread;\n+\n+  static bool _startable;\n+  \/\/ volatile due to at least one lock-free read\n+  volatile static bool _should_terminate;\n+ public:\n+  enum SomeConstants {\n+    delay_interval = 10                          \/\/ interrupt delay in milliseconds\n+  };\n+\n+  \/\/ Constructor\n+  WatcherThread();\n+\n+  \/\/ No destruction allowed\n+  ~WatcherThread() {\n+    guarantee(false, \"WatcherThread deletion must fix the race with VM termination\");\n+  }\n+\n+  \/\/ Tester\n+  bool is_Watcher_thread() const                 { return true; }\n+\n+  \/\/ Printing\n+  char* name() const { return (char*)\"VM Periodic Task Thread\"; }\n+  void print_on(outputStream* st) const;\n+  void unpark();\n+\n+  \/\/ Returns the single instance of WatcherThread\n+  static WatcherThread* watcher_thread()         { return _watcher_thread; }\n+\n+  \/\/ Create and start the single instance of WatcherThread, or stop it on shutdown\n+  static void start();\n+  static void stop();\n+  \/\/ Only allow start once the VM is sufficiently initialized\n+  \/\/ Otherwise the first task to enroll will trigger the start\n+  static void make_startable();\n+ private:\n+  int sleep() const;\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_NONJAVATHREAD_HPP\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/task.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"classfile\/moduleEntry.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"compiler\/compilerThread.hpp\"\n@@ -47,1 +47,0 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n@@ -93,0 +92,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n@@ -104,2 +104,0 @@\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"runtime\/sweeper.hpp\"\n@@ -130,1 +128,0 @@\n-#include \"utilities\/singleWriterSynchronizer.hpp\"\n@@ -1109,300 +1106,0 @@\n-\/\/ List of all NonJavaThreads and safe iteration over that list.\n-\n-class NonJavaThread::List {\n-public:\n-  NonJavaThread* volatile _head;\n-  SingleWriterSynchronizer _protect;\n-\n-  List() : _head(NULL), _protect() {}\n-};\n-\n-NonJavaThread::List NonJavaThread::_the_list;\n-\n-NonJavaThread::Iterator::Iterator() :\n-  _protect_enter(_the_list._protect.enter()),\n-  _current(Atomic::load_acquire(&_the_list._head))\n-{}\n-\n-NonJavaThread::Iterator::~Iterator() {\n-  _the_list._protect.exit(_protect_enter);\n-}\n-\n-void NonJavaThread::Iterator::step() {\n-  assert(!end(), \"precondition\");\n-  _current = Atomic::load_acquire(&_current->_next);\n-}\n-\n-NonJavaThread::NonJavaThread() : Thread(), _next(NULL) {\n-  assert(BarrierSet::barrier_set() != NULL, \"NonJavaThread created too soon!\");\n-}\n-\n-NonJavaThread::~NonJavaThread() { }\n-\n-void NonJavaThread::add_to_the_list() {\n-  MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);\n-  \/\/ Initialize BarrierSet-related data before adding to list.\n-  BarrierSet::barrier_set()->on_thread_attach(this);\n-  Atomic::release_store(&_next, _the_list._head);\n-  Atomic::release_store(&_the_list._head, this);\n-}\n-\n-void NonJavaThread::remove_from_the_list() {\n-  {\n-    MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);\n-    \/\/ Cleanup BarrierSet-related data before removing from list.\n-    BarrierSet::barrier_set()->on_thread_detach(this);\n-    NonJavaThread* volatile* p = &_the_list._head;\n-    for (NonJavaThread* t = *p; t != NULL; p = &t->_next, t = *p) {\n-      if (t == this) {\n-        *p = _next;\n-        break;\n-      }\n-    }\n-  }\n-  \/\/ Wait for any in-progress iterators.  Concurrent synchronize is not\n-  \/\/ allowed, so do it while holding a dedicated lock.  Outside and distinct\n-  \/\/ from NJTList_lock in case an iteration attempts to lock it.\n-  MutexLocker ml(NonJavaThreadsListSync_lock, Mutex::_no_safepoint_check_flag);\n-  _the_list._protect.synchronize();\n-  _next = NULL;                 \/\/ Safe to drop the link now.\n-}\n-\n-void NonJavaThread::pre_run() {\n-  add_to_the_list();\n-\n-  \/\/ This is slightly odd in that NamedThread is a subclass, but\n-  \/\/ in fact name() is defined in Thread\n-  assert(this->name() != NULL, \"thread name was not set before it was started\");\n-  this->set_native_thread_name(this->name());\n-}\n-\n-void NonJavaThread::post_run() {\n-  JFR_ONLY(Jfr::on_thread_exit(this);)\n-  remove_from_the_list();\n-  unregister_thread_stack_with_NMT();\n-  \/\/ Ensure thread-local-storage is cleared before termination.\n-  Thread::clear_thread_current();\n-  osthread()->set_state(ZOMBIE);\n-}\n-\n-\/\/ NamedThread --  non-JavaThread subclasses with multiple\n-\/\/ uniquely named instances should derive from this.\n-NamedThread::NamedThread() :\n-  NonJavaThread(),\n-  _name(NULL),\n-  _processed_thread(NULL),\n-  _gc_id(GCId::undefined())\n-{}\n-\n-NamedThread::~NamedThread() {\n-  FREE_C_HEAP_ARRAY(char, _name);\n-}\n-\n-void NamedThread::set_name(const char* format, ...) {\n-  guarantee(_name == NULL, \"Only get to set name once.\");\n-  _name = NEW_C_HEAP_ARRAY(char, max_name_len, mtThread);\n-  va_list ap;\n-  va_start(ap, format);\n-  jio_vsnprintf(_name, max_name_len, format, ap);\n-  va_end(ap);\n-}\n-\n-void NamedThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n-\n-\/\/ ======= WatcherThread ========\n-\n-\/\/ The watcher thread exists to simulate timer interrupts.  It should\n-\/\/ be replaced by an abstraction over whatever native support for\n-\/\/ timer interrupts exists on the platform.\n-\n-WatcherThread* WatcherThread::_watcher_thread   = NULL;\n-bool WatcherThread::_startable = false;\n-volatile bool  WatcherThread::_should_terminate = false;\n-\n-WatcherThread::WatcherThread() : NonJavaThread() {\n-  assert(watcher_thread() == NULL, \"we can only allocate one WatcherThread\");\n-  if (os::create_thread(this, os::watcher_thread)) {\n-    _watcher_thread = this;\n-\n-    \/\/ Set the watcher thread to the highest OS priority which should not be\n-    \/\/ used, unless a Java thread with priority java.lang.Thread.MAX_PRIORITY\n-    \/\/ is created. The only normal thread using this priority is the reference\n-    \/\/ handler thread, which runs for very short intervals only.\n-    \/\/ If the VMThread's priority is not lower than the WatcherThread profiling\n-    \/\/ will be inaccurate.\n-    os::set_priority(this, MaxPriority);\n-    os::start_thread(this);\n-  }\n-}\n-\n-int WatcherThread::sleep() const {\n-  \/\/ The WatcherThread does not participate in the safepoint protocol\n-  \/\/ for the PeriodicTask_lock because it is not a JavaThread.\n-  MonitorLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);\n-\n-  if (_should_terminate) {\n-    \/\/ check for termination before we do any housekeeping or wait\n-    return 0;  \/\/ we did not sleep.\n-  }\n-\n-  \/\/ remaining will be zero if there are no tasks,\n-  \/\/ causing the WatcherThread to sleep until a task is\n-  \/\/ enrolled\n-  int remaining = PeriodicTask::time_to_wait();\n-  int time_slept = 0;\n-\n-  \/\/ we expect this to timeout - we only ever get unparked when\n-  \/\/ we should terminate or when a new task has been enrolled\n-  OSThreadWaitState osts(this->osthread(), false \/* not Object.wait() *\/);\n-\n-  jlong time_before_loop = os::javaTimeNanos();\n-\n-  while (true) {\n-    bool timedout = ml.wait(remaining);\n-    jlong now = os::javaTimeNanos();\n-\n-    if (remaining == 0) {\n-      \/\/ if we didn't have any tasks we could have waited for a long time\n-      \/\/ consider the time_slept zero and reset time_before_loop\n-      time_slept = 0;\n-      time_before_loop = now;\n-    } else {\n-      \/\/ need to recalculate since we might have new tasks in _tasks\n-      time_slept = (int) ((now - time_before_loop) \/ 1000000);\n-    }\n-\n-    \/\/ Change to task list or spurious wakeup of some kind\n-    if (timedout || _should_terminate) {\n-      break;\n-    }\n-\n-    remaining = PeriodicTask::time_to_wait();\n-    if (remaining == 0) {\n-      \/\/ Last task was just disenrolled so loop around and wait until\n-      \/\/ another task gets enrolled\n-      continue;\n-    }\n-\n-    remaining -= time_slept;\n-    if (remaining <= 0) {\n-      break;\n-    }\n-  }\n-\n-  return time_slept;\n-}\n-\n-void WatcherThread::run() {\n-  assert(this == watcher_thread(), \"just checking\");\n-\n-  this->set_active_handles(JNIHandleBlock::allocate_block());\n-  while (true) {\n-    assert(watcher_thread() == Thread::current(), \"thread consistency check\");\n-    assert(watcher_thread() == this, \"thread consistency check\");\n-\n-    \/\/ Calculate how long it'll be until the next PeriodicTask work\n-    \/\/ should be done, and sleep that amount of time.\n-    int time_waited = sleep();\n-\n-    if (VMError::is_error_reported()) {\n-      \/\/ A fatal error has happened, the error handler(VMError::report_and_die)\n-      \/\/ should abort JVM after creating an error log file. However in some\n-      \/\/ rare cases, the error handler itself might deadlock. Here periodically\n-      \/\/ check for error reporting timeouts, and if it happens, just proceed to\n-      \/\/ abort the VM.\n-\n-      \/\/ This code is in WatcherThread because WatcherThread wakes up\n-      \/\/ periodically so the fatal error handler doesn't need to do anything;\n-      \/\/ also because the WatcherThread is less likely to crash than other\n-      \/\/ threads.\n-\n-      for (;;) {\n-        \/\/ Note: we use naked sleep in this loop because we want to avoid using\n-        \/\/ any kind of VM infrastructure which may be broken at this point.\n-        if (VMError::check_timeout()) {\n-          \/\/ We hit error reporting timeout. Error reporting was interrupted and\n-          \/\/ will be wrapping things up now (closing files etc). Give it some more\n-          \/\/ time, then quit the VM.\n-          os::naked_short_sleep(200);\n-          \/\/ Print a message to stderr.\n-          fdStream err(defaultStream::output_fd());\n-          err.print_raw_cr(\"# [ timer expired, abort... ]\");\n-          \/\/ skip atexit\/vm_exit\/vm_abort hooks\n-          os::die();\n-        }\n-\n-        \/\/ Wait a second, then recheck for timeout.\n-        os::naked_short_sleep(999);\n-      }\n-    }\n-\n-    if (_should_terminate) {\n-      \/\/ check for termination before posting the next tick\n-      break;\n-    }\n-\n-    PeriodicTask::real_time_tick(time_waited);\n-  }\n-\n-  \/\/ Signal that it is terminated\n-  {\n-    MutexLocker mu(Terminator_lock, Mutex::_no_safepoint_check_flag);\n-    _watcher_thread = NULL;\n-    Terminator_lock->notify_all();\n-  }\n-}\n-\n-void WatcherThread::start() {\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-\n-  if (watcher_thread() == NULL && _startable) {\n-    _should_terminate = false;\n-    \/\/ Create the single instance of WatcherThread\n-    new WatcherThread();\n-  }\n-}\n-\n-void WatcherThread::make_startable() {\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-  _startable = true;\n-}\n-\n-void WatcherThread::stop() {\n-  {\n-    \/\/ Follow normal safepoint aware lock enter protocol since the\n-    \/\/ WatcherThread is stopped by another JavaThread.\n-    MutexLocker ml(PeriodicTask_lock);\n-    _should_terminate = true;\n-\n-    WatcherThread* watcher = watcher_thread();\n-    if (watcher != NULL) {\n-      \/\/ unpark the WatcherThread so it can see that it should terminate\n-      watcher->unpark();\n-    }\n-  }\n-\n-  MonitorLocker mu(Terminator_lock);\n-\n-  while (watcher_thread() != NULL) {\n-    \/\/ This wait should make safepoint checks, wait without a timeout,\n-    \/\/ and wait as a suspend-equivalent condition.\n-    mu.wait(0, Mutex::_as_suspend_equivalent_flag);\n-  }\n-}\n-\n-void WatcherThread::unpark() {\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-  PeriodicTask_lock->notify();\n-}\n-\n-void WatcherThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n@@ -1677,5 +1374,0 @@\n-\n-\/\/ Remove this ifdef when C1 is ported to the compiler interface.\n-static void compiler_thread_entry(JavaThread* thread, TRAPS);\n-static void sweeper_thread_entry(JavaThread* thread, TRAPS);\n-\n@@ -1688,2 +1380,2 @@\n-  thr_type = entry_point == &compiler_thread_entry ? os::compiler_thread :\n-                                                     os::java_thread;\n+  thr_type = entry_point == &CompilerThread::thread_entry ? os::compiler_thread :\n+                                                            os::java_thread;\n@@ -3142,64 +2834,0 @@\n-static void compiler_thread_entry(JavaThread* thread, TRAPS) {\n-  assert(thread->is_Compiler_thread(), \"must be compiler thread\");\n-  CompileBroker::compiler_thread_loop();\n-}\n-\n-static void sweeper_thread_entry(JavaThread* thread, TRAPS) {\n-  NMethodSweeper::sweeper_loop();\n-}\n-\n-\/\/ Create a CompilerThread\n-CompilerThread::CompilerThread(CompileQueue* queue,\n-                               CompilerCounters* counters)\n-                               : JavaThread(&compiler_thread_entry) {\n-  _env   = NULL;\n-  _log   = NULL;\n-  _task  = NULL;\n-  _queue = queue;\n-  _counters = counters;\n-  _buffer_blob = NULL;\n-  _compiler = NULL;\n-\n-  \/\/ Compiler uses resource area for compilation, let's bias it to mtCompiler\n-  resource_area()->bias_to(mtCompiler);\n-\n-#ifndef PRODUCT\n-  _ideal_graph_printer = NULL;\n-#endif\n-}\n-\n-CompilerThread::~CompilerThread() {\n-  \/\/ Delete objects which were allocated on heap.\n-  delete _counters;\n-}\n-\n-bool CompilerThread::can_call_java() const {\n-  return _compiler != NULL && _compiler->is_jvmci();\n-}\n-\n-\/\/ Create sweeper thread\n-CodeCacheSweeperThread::CodeCacheSweeperThread()\n-: JavaThread(&sweeper_thread_entry) {\n-  _scanned_compiled_method = NULL;\n-}\n-\n-void CodeCacheSweeperThread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n-  JavaThread::oops_do_no_frames(f, cf);\n-  if (_scanned_compiled_method != NULL && cf != NULL) {\n-    \/\/ Safepoints can occur when the sweeper is scanning an nmethod so\n-    \/\/ process it here to make sure it isn't unloaded in the middle of\n-    \/\/ a scan.\n-    cf->do_code_blob(_scanned_compiled_method);\n-  }\n-}\n-\n-void CodeCacheSweeperThread::nmethods_do(CodeBlobClosure* cf) {\n-  JavaThread::nmethods_do(cf);\n-  if (_scanned_compiled_method != NULL && cf != NULL) {\n-    \/\/ Safepoints can occur when the sweeper is scanning an nmethod so\n-    \/\/ process it here to make sure it isn't unloaded in the middle of\n-    \/\/ a scan.\n-    cf->do_code_blob(_scanned_compiled_method);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":376,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -72,9 +72,0 @@\n-class BufferBlob;\n-class AbstractCompiler;\n-class ciEnv;\n-class CompileThread;\n-class CompileLog;\n-class CompileTask;\n-class CompileQueue;\n-class CompilerCounters;\n-\n@@ -90,4 +81,0 @@\n-class IdealGraphPrinter;\n-\n-class JVMCIEnv;\n-class JVMCIPrimitiveArray;\n@@ -867,135 +854,0 @@\n-class NonJavaThread: public Thread {\n-  friend class VMStructs;\n-\n-  NonJavaThread* volatile _next;\n-\n-  class List;\n-  static List _the_list;\n-\n-  void add_to_the_list();\n-  void remove_from_the_list();\n-\n- protected:\n-  virtual void pre_run();\n-  virtual void post_run();\n-\n- public:\n-  NonJavaThread();\n-  ~NonJavaThread();\n-\n-  class Iterator;\n-};\n-\n-\/\/ Provides iteration over the list of NonJavaThreads.\n-\/\/ List addition occurs in pre_run(), and removal occurs in post_run(),\n-\/\/ so that only live fully-initialized threads can be found in the list.\n-\/\/ Threads created after an iterator is constructed will not be visited\n-\/\/ by the iterator. The scope of an iterator is a critical section; there\n-\/\/ must be no safepoint checks in that scope.\n-class NonJavaThread::Iterator : public StackObj {\n-  uint _protect_enter;\n-  NonJavaThread* _current;\n-\n-  NONCOPYABLE(Iterator);\n-\n-public:\n-  Iterator();\n-  ~Iterator();\n-\n-  bool end() const { return _current == NULL; }\n-  NonJavaThread* current() const { return _current; }\n-  void step();\n-};\n-\n-\/\/ Name support for threads.  non-JavaThread subclasses with multiple\n-\/\/ uniquely named instances should derive from this.\n-class NamedThread: public NonJavaThread {\n-  friend class VMStructs;\n-  enum {\n-    max_name_len = 64\n-  };\n- private:\n-  char* _name;\n-  \/\/ log Thread being processed by oops_do\n-  Thread* _processed_thread;\n-  uint _gc_id; \/\/ The current GC id when a thread takes part in GC\n-\n- public:\n-  NamedThread();\n-  ~NamedThread();\n-  \/\/ May only be called once per thread.\n-  void set_name(const char* format, ...)  ATTRIBUTE_PRINTF(2, 3);\n-  virtual bool is_Named_thread() const { return true; }\n-  virtual char* name() const { return _name == NULL ? (char*)\"Unknown Thread\" : _name; }\n-  Thread *processed_thread() { return _processed_thread; }\n-  void set_processed_thread(Thread *thread) { _processed_thread = thread; }\n-  virtual void print_on(outputStream* st) const;\n-\n-  void set_gc_id(uint gc_id) { _gc_id = gc_id; }\n-  uint gc_id() { return _gc_id; }\n-};\n-\n-\/\/ Worker threads are named and have an id of an assigned work.\n-class WorkerThread: public NamedThread {\n- private:\n-  uint _id;\n- public:\n-  WorkerThread() : _id(0)               { }\n-  virtual bool is_Worker_thread() const { return true; }\n-\n-  virtual WorkerThread* as_Worker_thread() const {\n-    assert(is_Worker_thread(), \"Dubious cast to WorkerThread*?\");\n-    return (WorkerThread*) this;\n-  }\n-\n-  void set_id(uint work_id)             { _id = work_id; }\n-  uint id() const                       { return _id; }\n-};\n-\n-\/\/ A single WatcherThread is used for simulating timer interrupts.\n-class WatcherThread: public NonJavaThread {\n-  friend class VMStructs;\n- protected:\n-  virtual void run();\n-\n- private:\n-  static WatcherThread* _watcher_thread;\n-\n-  static bool _startable;\n-  \/\/ volatile due to at least one lock-free read\n-  volatile static bool _should_terminate;\n- public:\n-  enum SomeConstants {\n-    delay_interval = 10                          \/\/ interrupt delay in milliseconds\n-  };\n-\n-  \/\/ Constructor\n-  WatcherThread();\n-\n-  \/\/ No destruction allowed\n-  ~WatcherThread() {\n-    guarantee(false, \"WatcherThread deletion must fix the race with VM termination\");\n-  }\n-\n-  \/\/ Tester\n-  bool is_Watcher_thread() const                 { return true; }\n-\n-  \/\/ Printing\n-  char* name() const { return (char*)\"VM Periodic Task Thread\"; }\n-  void print_on(outputStream* st) const;\n-  void unpark();\n-\n-  \/\/ Returns the single instance of WatcherThread\n-  static WatcherThread* watcher_thread()         { return _watcher_thread; }\n-\n-  \/\/ Create and start the single instance of WatcherThread, or stop it on shutdown\n-  static void start();\n-  static void stop();\n-  \/\/ Only allow start once the VM is sufficiently initialized\n-  \/\/ Otherwise the first task to enroll will trigger the start\n-  static void make_startable();\n- private:\n-  int sleep() const;\n-};\n-\n-\n@@ -1900,94 +1752,0 @@\n-inline CompilerThread* JavaThread::as_CompilerThread() {\n-  assert(is_Compiler_thread(), \"just checking\");\n-  return (CompilerThread*)this;\n-}\n-\n-\/\/ Dedicated thread to sweep the code cache\n-class CodeCacheSweeperThread : public JavaThread {\n-  CompiledMethod*       _scanned_compiled_method; \/\/ nmethod being scanned by the sweeper\n- public:\n-  CodeCacheSweeperThread();\n-  \/\/ Track the nmethod currently being scanned by the sweeper\n-  void set_scanned_compiled_method(CompiledMethod* cm) {\n-    assert(_scanned_compiled_method == NULL || cm == NULL, \"should reset to NULL before writing a new value\");\n-    _scanned_compiled_method = cm;\n-  }\n-\n-  \/\/ Hide sweeper thread from external view.\n-  bool is_hidden_from_external_view() const { return true; }\n-\n-  bool is_Code_cache_sweeper_thread() const { return true; }\n-\n-  \/\/ Prevent GC from unloading _scanned_compiled_method\n-  void oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf);\n-  void nmethods_do(CodeBlobClosure* cf);\n-};\n-\n-\/\/ A thread used for Compilation.\n-class CompilerThread : public JavaThread {\n-  friend class VMStructs;\n- private:\n-  CompilerCounters* _counters;\n-\n-  ciEnv*                _env;\n-  CompileLog*           _log;\n-  CompileTask* volatile _task;  \/\/ print_threads_compiling can read this concurrently.\n-  CompileQueue*         _queue;\n-  BufferBlob*           _buffer_blob;\n-\n-  AbstractCompiler*     _compiler;\n-  TimeStamp             _idle_time;\n-\n- public:\n-\n-  static CompilerThread* current();\n-\n-  CompilerThread(CompileQueue* queue, CompilerCounters* counters);\n-  ~CompilerThread();\n-\n-  bool is_Compiler_thread() const                { return true; }\n-\n-  virtual bool can_call_java() const;\n-\n-  \/\/ Hide native compiler threads from external view.\n-  bool is_hidden_from_external_view() const      { return !can_call_java(); }\n-\n-  void set_compiler(AbstractCompiler* c)         { _compiler = c; }\n-  AbstractCompiler* compiler() const             { return _compiler; }\n-\n-  CompileQueue* queue()        const             { return _queue; }\n-  CompilerCounters* counters() const             { return _counters; }\n-\n-  \/\/ Get\/set the thread's compilation environment.\n-  ciEnv*        env()                            { return _env; }\n-  void          set_env(ciEnv* env)              { _env = env; }\n-\n-  BufferBlob*   get_buffer_blob() const          { return _buffer_blob; }\n-  void          set_buffer_blob(BufferBlob* b)   { _buffer_blob = b; }\n-\n-  \/\/ Get\/set the thread's logging information\n-  CompileLog*   log()                            { return _log; }\n-  void          init_log(CompileLog* log) {\n-    \/\/ Set once, for good.\n-    assert(_log == NULL, \"set only once\");\n-    _log = log;\n-  }\n-\n-  void start_idle_timer()                        { _idle_time.update(); }\n-  jlong idle_time_millis() {\n-    return TimeHelper::counter_to_millis(_idle_time.ticks_since_update());\n-  }\n-\n-#ifndef PRODUCT\n- private:\n-  IdealGraphPrinter *_ideal_graph_printer;\n- public:\n-  IdealGraphPrinter *ideal_graph_printer()           { return _ideal_graph_printer; }\n-  void set_ideal_graph_printer(IdealGraphPrinter *n) { _ideal_graph_printer = n; }\n-#endif\n-\n-  \/\/ Get\/set the thread's current task\n-  CompileTask* task()                      { return _task; }\n-  void         set_task(CompileTask* task) { _task = task; }\n-};\n-\n@@ -2004,4 +1762,0 @@\n-inline CompilerThread* CompilerThread::current() {\n-  return JavaThread::current()->as_CompilerThread();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":246,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}