{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,2 +68,2 @@\n-    final Class<?>[] interfaces;              \/\/ Additional interfaces to be implemented\n-    final MethodType[] bridges;               \/\/ Signatures of additional methods to bridge\n+    final Class<?>[] altInterfaces;           \/\/ Additional interfaces to be implemented\n+    final MethodType[] altMethods;            \/\/ Signatures of additional methods to bridge\n@@ -102,4 +102,4 @@\n-     * @param interfaces Additional interfaces which the lambda object\n-     *                   should implement.\n-     * @param bridges Method types for additional signatures to be\n-     *                bridged to the implementation method\n+     * @param altInterfaces Additional interfaces which the lambda object\n+     *                      should implement.\n+     * @param altMethods Method types for additional signatures to be\n+     *                   implemented by invoking the implementation method\n@@ -119,2 +119,2 @@\n-                                        Class<?>[] interfaces,\n-                                        MethodType[] bridges)\n+                                        Class<?>[] altInterfaces,\n+                                        MethodType[] altMethods)\n@@ -122,1 +122,1 @@\n-        if ((caller.lookupModes() & MethodHandles.Lookup.PRIVATE) == 0) {\n+        if (!caller.hasFullPrivilegeAccess()) {\n@@ -183,2 +183,2 @@\n-        this.interfaces = interfaces;\n-        this.bridges = bridges;\n+        this.altInterfaces = altInterfaces;\n+        this.altMethods = altMethods;\n@@ -204,1 +204,1 @@\n-        for (Class<?> c : interfaces) {\n+        for (Class<?> c : altInterfaces) {\n@@ -245,1 +245,1 @@\n-        for (MethodType bridgeMT : bridges) {\n+        for (MethodType bridgeMT : altMethods) {\n@@ -316,1 +316,1 @@\n-        for (MethodType bridgeMT : bridges) {\n+        for (MethodType bridgeMT : altMethods) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -155,4 +155,4 @@\n-     * @param interfaces Additional interfaces which the lambda object\n-     *                   should implement.\n-     * @param bridges Method types for additional signatures to be\n-     *                bridged to the implementation method\n+     * @param altInterfaces Additional interfaces which the lambda object\n+     *                      should implement.\n+     * @param altMethods Method types for additional signatures to be\n+     *                   implemented by invoking the implementation method\n@@ -172,2 +172,2 @@\n-                                       Class<?>[] interfaces,\n-                                       MethodType[] bridges)\n+                                       Class<?>[] altInterfaces,\n+                                       MethodType[] altMethods)\n@@ -177,1 +177,1 @@\n-              isSerializable, interfaces, bridges);\n+              isSerializable, altInterfaces, altMethods);\n@@ -290,2 +290,2 @@\n-                                                 interfaces,\n-                                                 bridges,\n+                                                 altInterfaces,\n+                                                 altMethods,\n@@ -304,2 +304,2 @@\n-                                                               interfaces,\n-                                                               bridges);\n+                                                               altInterfaces,\n+                                                               altMethods);\n@@ -324,1 +324,1 @@\n-        if (interfaces.length == 0) {\n+        if (altInterfaces.length == 0) {\n@@ -328,1 +328,1 @@\n-            Set<String> itfs = new LinkedHashSet<>(interfaces.length + 1);\n+            Set<String> itfs = new LinkedHashSet<>(altInterfaces.length + 1);\n@@ -330,1 +330,1 @@\n-            for (Class<?> i : interfaces) {\n+            for (Class<?> i : altInterfaces) {\n@@ -361,3 +361,3 @@\n-        \/\/ Forward the bridges\n-        if (bridges != null) {\n-            for (MethodType mt : bridges) {\n+        \/\/ Forward the altMethods\n+        if (altMethods != null) {\n+            for (MethodType mt : altMethods) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n- *     <li><em>Bridging.<\/em>  It is sometimes useful to implement multiple\n+ *     <li><em>Multiple methods.<\/em>  It is sometimes useful to implement multiple\n@@ -250,1 +250,1 @@\n-     * additional bridge methods\n+     * additional methods that invoke the {@code implementation}\n@@ -312,2 +312,2 @@\n-     * @throws LambdaConversionException If {@code caller} does not have private\n-     *         access privileges, or if {@code interfaceMethodName} is not a valid JVM\n+     * @throws LambdaConversionException If {@code caller} does not have full privilege\n+     *         access, or if {@code interfaceMethodName} is not a valid JVM\n@@ -381,4 +381,4 @@\n-     *                          int interfaceCount,        \/\/ IF flags has MARKERS set\n-     *                          Class... interfaces,       \/\/ IF flags has MARKERS set\n-     *                          int bridgeCount,           \/\/ IF flags has BRIDGES set\n-     *                          MethodType... bridges      \/\/ IF flags has BRIDGES set\n+     *                          int altInterfaceCount,        \/\/ IF flags has MARKERS set\n+     *                          Class... altInterfaces,       \/\/ IF flags has MARKERS set\n+     *                          int altMethodCount,           \/\/ IF flags has BRIDGES set\n+     *                          MethodType... altMethods      \/\/ IF flags has BRIDGES set\n@@ -396,1 +396,1 @@\n-     *     <li>{@code interfaceCount} is the number of additional interfaces\n+     *     <li>{@code altInterfaceCount} is the number of additional interfaces\n@@ -399,2 +399,2 @@\n-     *     <li>{@code interfaces} is a variable-length list of additional\n-     *     interfaces to implement, whose length equals {@code interfaceCount},\n+     *     <li>{@code altInterfaces} is a variable-length list of additional\n+     *     interfaces to implement, whose length equals {@code altInterfaceCount},\n@@ -402,1 +402,1 @@\n-     *     <li>{@code bridgeCount} is the number of additional method signatures\n+     *     <li>{@code altMethodCount} is the number of additional method signatures\n@@ -405,2 +405,2 @@\n-     *     <li>{@code bridges} is a variable-length list of additional\n-     *     methods signatures to implement, whose length equals {@code bridgeCount},\n+     *     <li>{@code altMethods} is a variable-length list of additional\n+     *     methods signatures to implement, whose length equals {@code altMethodCount},\n@@ -410,1 +410,1 @@\n-     * <p>Each class named by {@code interfaces} is subject to the same\n+     * <p>Each class named by {@code altInterfaces} is subject to the same\n@@ -413,1 +413,1 @@\n-     * named by {@code bridges} is subject to the same restrictions as\n+     * named by {@code altMethods} is subject to the same restrictions as\n@@ -427,1 +427,1 @@\n-     *     of {@code factoryType} and any interfaces named by {@code interfaces}<\/li>\n+     *     of {@code factoryType} and any interfaces named by {@code altInterfaces}<\/li>\n@@ -430,1 +430,1 @@\n-     *     given by {@code bridges}<\/li>\n+     *     given by {@code altMethods}<\/li>\n@@ -457,2 +457,2 @@\n-     * @throws LambdaConversionException If {@code caller} does not have private\n-     *         access privileges, or if {@code interfaceMethodName} is not a valid JVM\n+     * @throws LambdaConversionException If {@code caller} does not have full privilege\n+     *         access, or if {@code interfaceMethodName} is not a valid JVM\n@@ -460,1 +460,1 @@\n-     *         an interface, or if any of {@code interfaces} is not an\n+     *         an interface, or if any of {@code altInterfaces} is not an\n@@ -468,1 +468,1 @@\n-     *         {@code interfaceCount} or {@code bridgeCount} are negative\n+     *         {@code altInterfaceCount} or {@code altMethodCount} are negative\n@@ -488,2 +488,2 @@\n-        Class<?>[] interfaces = EMPTY_CLASS_ARRAY;\n-        MethodType[] bridges = EMPTY_MT_ARRAY;\n+        Class<?>[] altInterfaces = EMPTY_CLASS_ARRAY;\n+        MethodType[] altMethods = EMPTY_MT_ARRAY;\n@@ -491,2 +491,2 @@\n-            int interfaceCount = extractArg(args, argIndex++, Integer.class);\n-            if (interfaceCount < 0) {\n+            int altInterfaceCount = extractArg(args, argIndex++, Integer.class);\n+            if (altInterfaceCount < 0) {\n@@ -495,3 +495,3 @@\n-            if (interfaceCount > 0) {\n-                interfaces = extractArgs(args, argIndex, Class.class, interfaceCount);\n-                argIndex += interfaceCount;\n+            if (altInterfaceCount > 0) {\n+                altInterfaces = extractArgs(args, argIndex, Class.class, altInterfaceCount);\n+                argIndex += altInterfaceCount;\n@@ -501,2 +501,2 @@\n-            int bridgeCount = extractArg(args, argIndex++, Integer.class);\n-            if (bridgeCount < 0) {\n+            int altMethodCount = extractArg(args, argIndex++, Integer.class);\n+            if (altMethodCount < 0) {\n@@ -505,3 +505,3 @@\n-            if (bridgeCount > 0) {\n-                bridges = extractArgs(args, argIndex, MethodType.class, bridgeCount);\n-                argIndex += bridgeCount;\n+            if (altMethodCount > 0) {\n+                altMethods = extractArgs(args, argIndex, MethodType.class, altMethodCount);\n+                argIndex += altMethodCount;\n@@ -517,1 +517,1 @@\n-            for (Class<?> c : interfaces)\n+            for (Class<?> c : altInterfaces)\n@@ -520,2 +520,2 @@\n-                interfaces = Arrays.copyOf(interfaces, interfaces.length + 1);\n-                interfaces[interfaces.length-1] = Serializable.class;\n+                altInterfaces = Arrays.copyOf(altInterfaces, altInterfaces.length + 1);\n+                altInterfaces[altInterfaces.length-1] = Serializable.class;\n@@ -533,2 +533,2 @@\n-                                                  interfaces,\n-                                                  bridges);\n+                                                  altInterfaces,\n+                                                  altMethods);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/MetafactoryArgValidationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}