{"files":[{"patch":"@@ -56,6 +56,6 @@\n-    final MethodType invokedType;             \/\/ The type of the invoked method \"(CC)II\"\n-    final Class<?> samBase;                   \/\/ The type of the returned instance \"interface JJ\"\n-    final String samMethodName;               \/\/ Name of the SAM method \"foo\"\n-    final MethodType samMethodType;           \/\/ Type of the SAM method \"(Object)Object\"\n-    final MethodHandle implMethod;            \/\/ Raw method handle for the implementation method\n-    final MethodType implMethodType;          \/\/ Type of the implMethod MethodHandle \"(CC,int)String\"\n+    final MethodType factoryType;             \/\/ The type of the invoked method \"(CC)II\"\n+    final Class<?> interfaceClass;            \/\/ The type of the returned instance \"interface JJ\"\n+    final String interfaceMethodName;         \/\/ Name of the method to implement \"foo\"\n+    final MethodType interfaceMethodType;     \/\/ Type of the method to implement \"(Object)Object\"\n+    final MethodHandle implementation;        \/\/ Raw method handle for the implementation method\n+    final MethodType implMethodType;          \/\/ Type of the implementation MethodHandle \"(CC,int)String\"\n@@ -66,1 +66,1 @@\n-    final MethodType instantiatedMethodType;  \/\/ Instantiated erased functional interface method type \"(Integer)Object\"\n+    final MethodType dynamicMethodType;       \/\/ Dynamically checked method type \"(Integer)Object\"\n@@ -68,2 +68,2 @@\n-    final Class<?>[] markerInterfaces;        \/\/ Additional marker interfaces to be implemented\n-    final MethodType[] additionalBridges;     \/\/ Signatures of additional methods to bridge\n+    final Class<?>[] interfaces;              \/\/ Additional interfaces to be implemented\n+    final MethodType[] bridges;               \/\/ Signatures of additional methods to bridge\n@@ -77,1 +77,1 @@\n-     * @param invokedType Stacked automatically by VM; the signature of the\n+     * @param factoryType Stacked automatically by VM; the signature of the\n@@ -84,15 +84,15 @@\n-     * @param samMethodName Name of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a String.\n-     * @param samMethodType Type of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a MethodType.\n-     * @param implMethod The implementation method which should be called\n-     *                   (with suitable adaptation of argument types, return\n-     *                   types, and adjustment for captured arguments) when\n-     *                   methods of the resulting functional interface instance\n-     *                   are invoked.\n-     * @param instantiatedMethodType The signature of the primary functional\n-     *                               interface method after type variables are\n-     *                               substituted with their instantiation from\n-     *                               the capture site\n+     * @param interfaceMethodName Name of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a String.\n+     * @param interfaceMethodType Type of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a MethodType.\n+     * @param implementation The implementation method which should be called\n+     *                       (with suitable adaptation of argument types, return\n+     *                       types, and adjustment for captured arguments) when\n+     *                       methods of the resulting functional interface instance\n+     *                       are invoked.\n+     * @param dynamicMethodType The signature of the primary functional\n+     *                          interface method after type variables are\n+     *                          substituted with their instantiation from\n+     *                          the capture site\n@@ -102,4 +102,4 @@\n-     * @param markerInterfaces Additional interfaces which the lambda object\n-     *                       should implement.\n-     * @param additionalBridges Method types for additional signatures to be\n-     *                          bridged to the implementation method\n+     * @param interfaces Additional interfaces which the lambda object\n+     *                   should implement.\n+     * @param bridges Method types for additional signatures to be\n+     *                bridged to the implementation method\n@@ -107,1 +107,4 @@\n-     * invariants are violated\n+     *         invariants are violated\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -110,8 +113,8 @@\n-                                       MethodType invokedType,\n-                                       String samMethodName,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType,\n-                                       boolean isSerializable,\n-                                       Class<?>[] markerInterfaces,\n-                                       MethodType[] additionalBridges)\n+                                        MethodType factoryType,\n+                                        String interfaceMethodName,\n+                                        MethodType interfaceMethodType,\n+                                        MethodHandle implementation,\n+                                        MethodType dynamicMethodType,\n+                                        boolean isSerializable,\n+                                        Class<?>[] interfaces,\n+                                        MethodType[] bridges)\n@@ -126,1 +129,1 @@\n-        this.invokedType = invokedType;\n+        this.factoryType = factoryType;\n@@ -128,1 +131,1 @@\n-        this.samBase = invokedType.returnType();\n+        this.interfaceClass = factoryType.returnType();\n@@ -130,2 +133,2 @@\n-        this.samMethodName = samMethodName;\n-        this.samMethodType  = samMethodType;\n+        this.interfaceMethodName = interfaceMethodName;\n+        this.interfaceMethodType  = interfaceMethodType;\n@@ -133,3 +136,7 @@\n-        this.implMethod = implMethod;\n-        this.implMethodType = implMethod.type();\n-        this.implInfo = caller.revealDirect(implMethod);\n+        this.implementation = implementation;\n+        this.implMethodType = implementation.type();\n+        try {\n+            this.implInfo = caller.revealDirect(implementation); \/\/ may throw SecurityException\n+        } catch (IllegalArgumentException e) {\n+            throw new LambdaConversionException(implementation + \" is not direct or cannot be cracked\");\n+        }\n@@ -174,1 +181,1 @@\n-        this.instantiatedMethodType = instantiatedMethodType;\n+        this.dynamicMethodType = dynamicMethodType;\n@@ -176,2 +183,2 @@\n-        this.markerInterfaces = markerInterfaces;\n-        this.additionalBridges = additionalBridges;\n+        this.interfaces = interfaces;\n+        this.bridges = bridges;\n@@ -179,7 +186,7 @@\n-        if (samMethodName.isEmpty() ||\n-                samMethodName.indexOf('.') >= 0 ||\n-                samMethodName.indexOf(';') >= 0 ||\n-                samMethodName.indexOf('[') >= 0 ||\n-                samMethodName.indexOf('\/') >= 0 ||\n-                samMethodName.indexOf('<') >= 0 ||\n-                samMethodName.indexOf('>') >= 0) {\n+        if (interfaceMethodName.isEmpty() ||\n+                interfaceMethodName.indexOf('.') >= 0 ||\n+                interfaceMethodName.indexOf(';') >= 0 ||\n+                interfaceMethodName.indexOf('[') >= 0 ||\n+                interfaceMethodName.indexOf('\/') >= 0 ||\n+                interfaceMethodName.indexOf('<') >= 0 ||\n+                interfaceMethodName.indexOf('>') >= 0) {\n@@ -188,1 +195,1 @@\n-                    samMethodName));\n+                    interfaceMethodName));\n@@ -191,1 +198,1 @@\n-        if (!samBase.isInterface()) {\n+        if (!interfaceClass.isInterface()) {\n@@ -193,2 +200,2 @@\n-                    \"Functional interface %s is not an interface\",\n-                    samBase.getName()));\n+                    \"%s is not an interface\",\n+                    interfaceClass.getName()));\n@@ -197,1 +204,1 @@\n-        for (Class<?> c : markerInterfaces) {\n+        for (Class<?> c : interfaces) {\n@@ -200,1 +207,1 @@\n-                        \"Marker interface %s is not an interface\",\n+                        \"%s is not an interface\",\n@@ -223,3 +230,3 @@\n-        final int capturedArity = invokedType.parameterCount();\n-        final int samArity = samMethodType.parameterCount();\n-        final int instantiatedArity = instantiatedMethodType.parameterCount();\n+        final int capturedArity = factoryType.parameterCount();\n+        final int samArity = interfaceMethodType.parameterCount();\n+        final int dynamicArity = dynamicMethodType.parameterCount();\n@@ -232,1 +239,1 @@\n-        if (instantiatedArity != samArity) {\n+        if (dynamicArity != samArity) {\n@@ -234,1 +241,1 @@\n-                    String.format(\"Incorrect number of parameters for %s method %s; %d instantiated parameters, %d functional interface method parameters\",\n+                    String.format(\"Incorrect number of parameters for %s method %s; %d dynamic parameters, %d functional interface method parameters\",\n@@ -236,1 +243,1 @@\n-                                  instantiatedArity, samArity));\n+                                  dynamicArity, samArity));\n@@ -238,1 +245,1 @@\n-        for (MethodType bridgeMT : additionalBridges) {\n+        for (MethodType bridgeMT : bridges) {\n@@ -242,1 +249,1 @@\n-                                      bridgeMT, samMethodType));\n+                                      bridgeMT, interfaceMethodType));\n@@ -257,1 +264,1 @@\n-                receiverClass = instantiatedMethodType.parameterType(0);\n+                receiverClass = dynamicMethodType.parameterType(0);\n@@ -262,1 +269,1 @@\n-                receiverClass = invokedType.parameterType(0);\n+                receiverClass = factoryType.parameterType(0);\n@@ -280,1 +287,1 @@\n-            Class<?> capturedParamType = invokedType.parameterType(i);\n+            Class<?> capturedParamType = factoryType.parameterType(i);\n@@ -290,2 +297,2 @@\n-            Class<?> instantiatedParamType = instantiatedMethodType.parameterType(i - capturedArity);\n-            if (!isAdaptableTo(instantiatedParamType, implParamType, true)) {\n+            Class<?> dynamicParamType = dynamicMethodType.parameterType(i - capturedArity);\n+            if (!isAdaptableTo(dynamicParamType, implParamType, true)) {\n@@ -294,1 +301,1 @@\n-                                      i, instantiatedParamType, implParamType));\n+                                      i, dynamicParamType, implParamType));\n@@ -299,1 +306,1 @@\n-        Class<?> expectedType = instantiatedMethodType.returnType();\n+        Class<?> expectedType = dynamicMethodType.returnType();\n@@ -308,2 +315,2 @@\n-        checkDescriptor(samMethodType);\n-        for (MethodType bridgeMT : additionalBridges) {\n+        checkDescriptor(interfaceMethodType);\n+        for (MethodType bridgeMT : bridges) {\n@@ -314,1 +321,1 @@\n-    \/** Validate that the given descriptor's types are compatible with {@code instantiatedMethodType} **\/\n+    \/** Validate that the given descriptor's types are compatible with {@code dynamicMethodType} **\/\n@@ -316,2 +323,2 @@\n-        for (int i = 0; i < instantiatedMethodType.parameterCount(); i++) {\n-            Class<?> instantiatedParamType = instantiatedMethodType.parameterType(i);\n+        for (int i = 0; i < dynamicMethodType.parameterCount(); i++) {\n+            Class<?> dynamicParamType = dynamicMethodType.parameterType(i);\n@@ -319,3 +326,3 @@\n-            if (!descriptorParamType.isAssignableFrom(instantiatedParamType)) {\n-                String msg = String.format(\"Type mismatch for instantiated parameter %d: %s is not a subtype of %s\",\n-                                           i, instantiatedParamType, descriptorParamType);\n+            if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {\n+                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not a subtype of %s\",\n+                                           i, dynamicParamType, descriptorParamType);\n@@ -326,1 +333,1 @@\n-        Class<?> instantiatedReturnType = instantiatedMethodType.returnType();\n+        Class<?> dynamicReturnType = dynamicMethodType.returnType();\n@@ -328,1 +335,1 @@\n-        if (!isAdaptableToAsReturnStrict(instantiatedReturnType, descriptorReturnType)) {\n+        if (!isAdaptableToAsReturnStrict(dynamicReturnType, descriptorReturnType)) {\n@@ -330,1 +337,1 @@\n-                                       instantiatedReturnType, descriptorReturnType);\n+                                       dynamicReturnType, descriptorReturnType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":94,"deletions":87,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-     * @param invokedType Stacked automatically by VM; the signature of the\n+     * @param factoryType Stacked automatically by VM; the signature of the\n@@ -138,14 +138,14 @@\n-     * @param samMethodName Name of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a String.\n-     * @param samMethodType Type of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a MethodType.\n-     * @param implMethod The implementation method which should be called (with\n-     *                   suitable adaptation of argument types, return types,\n-     *                   and adjustment for captured arguments) when methods of\n-     *                   the resulting functional interface instance are invoked.\n-     * @param instantiatedMethodType The signature of the primary functional\n-     *                               interface method after type variables are\n-     *                               substituted with their instantiation from\n-     *                               the capture site\n+     * @param interfaceMethodName Name of the method in the functional interface to\n+     *                   which the lambda or method reference is being\n+     *                   converted, represented as a String.\n+     * @param interfaceMethodType Type of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a MethodType.\n+     * @param implementation The implementation method which should be called (with\n+     *                       suitable adaptation of argument types, return types,\n+     *                       and adjustment for captured arguments) when methods of\n+     *                       the resulting functional interface instance are invoked.\n+     * @param dynamicMethodType The signature of the primary functional\n+     *                          interface method after type variables are\n+     *                          substituted with their instantiation from\n+     *                          the capture site\n@@ -155,4 +155,4 @@\n-     * @param markerInterfaces Additional interfaces which the lambda object\n-     *                       should implement.\n-     * @param additionalBridges Method types for additional signatures to be\n-     *                          bridged to the implementation method\n+     * @param interfaces Additional interfaces which the lambda object\n+     *                   should implement.\n+     * @param bridges Method types for additional signatures to be\n+     *                bridged to the implementation method\n@@ -160,1 +160,4 @@\n-     * invariants are violated\n+     *         invariants are violated\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -163,5 +166,5 @@\n-                                       MethodType invokedType,\n-                                       String samMethodName,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType,\n+                                       MethodType factoryType,\n+                                       String interfaceMethodName,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType,\n@@ -169,2 +172,2 @@\n-                                       Class<?>[] markerInterfaces,\n-                                       MethodType[] additionalBridges)\n+                                       Class<?>[] interfaces,\n+                                       MethodType[] bridges)\n@@ -172,3 +175,3 @@\n-        super(caller, invokedType, samMethodName, samMethodType,\n-              implMethod, instantiatedMethodType,\n-              isSerializable, markerInterfaces, additionalBridges);\n+        super(caller, factoryType, interfaceMethodName, interfaceMethodType,\n+              implementation, dynamicMethodType,\n+              isSerializable, interfaces, bridges);\n@@ -178,1 +181,1 @@\n-        constructorType = invokedType.changeReturnType(Void.TYPE);\n+        constructorType = factoryType.changeReturnType(Void.TYPE);\n@@ -183,1 +186,1 @@\n-        int parameterCount = invokedType.parameterCount();\n+        int parameterCount = factoryType.parameterCount();\n@@ -189,1 +192,1 @@\n-                argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));\n+                argDescs[i] = BytecodeDescriptor.unparse(factoryType.parameterType(i));\n@@ -219,1 +222,1 @@\n-        if (invokedType.parameterCount() == 0) {\n+        if (factoryType.parameterCount() == 0) {\n@@ -225,1 +228,1 @@\n-                            invokedType.returnType()));\n+                            factoryType.returnType()));\n@@ -252,1 +255,1 @@\n-                    return new ConstantCallSite(MethodHandles.constant(samBase, inst));\n+                    return new ConstantCallSite(MethodHandles.constant(interfaceClass, inst));\n@@ -259,2 +262,2 @@\n-                MethodHandle mh = caller.findConstructor(innerClass, invokedType.changeReturnType(void.class));\n-                return new ConstantCallSite(mh.asType(invokedType));\n+                MethodHandle mh = caller.findConstructor(innerClass, constructorType);\n+                return new ConstantCallSite(mh.asType(factoryType));\n@@ -281,5 +284,5 @@\n-                                                 samMethodName,\n-                                                 invokedType,\n-                                                 samMethodType,\n-                                                 implMethod,\n-                                                 instantiatedMethodType,\n+                                                 interfaceMethodName,\n+                                                 factoryType,\n+                                                 interfaceMethodType,\n+                                                 implementation,\n+                                                 dynamicMethodType,\n@@ -287,2 +290,2 @@\n-                                                 markerInterfaces,\n-                                                 additionalBridges,\n+                                                 interfaces,\n+                                                 bridges,\n@@ -295,5 +298,5 @@\n-                                                               samMethodName,\n-                                                               invokedType,\n-                                                               samMethodType,\n-                                                               implMethod,\n-                                                               instantiatedMethodType,\n+                                                               interfaceMethodName,\n+                                                               factoryType,\n+                                                               interfaceMethodType,\n+                                                               implementation,\n+                                                               dynamicMethodType,\n@@ -301,2 +304,2 @@\n-                                                               markerInterfaces,\n-                                                               additionalBridges);\n+                                                               interfaces,\n+                                                               bridges);\n@@ -312,7 +315,0 @@\n-     * @implNote The class that is generated does not include signature\n-     * information for exceptions that may be present on the SAM method.\n-     * This is to reduce classfile size, and is harmless as checked exceptions\n-     * are erased anyway, no one will ever compile against this classfile,\n-     * and we make no guarantees about the reflective properties of lambda\n-     * objects.\n-     *\n@@ -325,5 +321,5 @@\n-        String[] interfaces;\n-        String samIntf = samBase.getName().replace('.', '\/');\n-        boolean accidentallySerializable = !isSerializable && Serializable.class.isAssignableFrom(samBase);\n-        if (markerInterfaces.length == 0) {\n-            interfaces = new String[]{samIntf};\n+        String[] interfaceNames;\n+        String interfaceName = interfaceClass.getName().replace('.', '\/');\n+        boolean accidentallySerializable = !isSerializable && Serializable.class.isAssignableFrom(interfaceClass);\n+        if (interfaces.length == 0) {\n+            interfaceNames = new String[]{interfaceName};\n@@ -332,5 +328,5 @@\n-            Set<String> itfs = new LinkedHashSet<>(markerInterfaces.length + 1);\n-            itfs.add(samIntf);\n-            for (Class<?> markerInterface : markerInterfaces) {\n-                itfs.add(markerInterface.getName().replace('.', '\/'));\n-                accidentallySerializable |= !isSerializable && Serializable.class.isAssignableFrom(markerInterface);\n+            Set<String> itfs = new LinkedHashSet<>(interfaces.length + 1);\n+            itfs.add(interfaceName);\n+            for (Class<?> i : interfaces) {\n+                itfs.add(i.getName().replace('.', '\/'));\n+                accidentallySerializable |= !isSerializable && Serializable.class.isAssignableFrom(i);\n@@ -338,1 +334,1 @@\n-            interfaces = itfs.toArray(new String[itfs.size()]);\n+            interfaceNames = itfs.toArray(new String[itfs.size()]);\n@@ -343,1 +339,1 @@\n-                 JAVA_LANG_OBJECT, interfaces);\n+                 JAVA_LANG_OBJECT, interfaceNames);\n@@ -356,1 +352,1 @@\n-        if (invokedType.parameterCount() == 0 && disableEagerInitialization) {\n+        if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n@@ -361,3 +357,3 @@\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,\n-                                          samMethodType.toMethodDescriptorString(), null, null);\n-        new ForwardingMethodGenerator(mv).generate(samMethodType);\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n+                                          interfaceMethodType.toMethodDescriptorString(), null, null);\n+        new ForwardingMethodGenerator(mv).generate(interfaceMethodType);\n@@ -366,3 +362,3 @@\n-        if (additionalBridges != null) {\n-            for (MethodType mt : additionalBridges) {\n-                mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,\n+        if (bridges != null) {\n+            for (MethodType mt : bridges) {\n+                mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n@@ -406,1 +402,1 @@\n-                \/\/ So this workaround by passing the live implMethod method handle\n+                \/\/ So this workaround by passing the live implementation method handle\n@@ -408,1 +404,1 @@\n-                lookup = caller.defineHiddenClassWithClassData(classBytes, implMethod, !disableEagerInitialization,\n+                lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n@@ -425,1 +421,1 @@\n-        String lambdaTypeDescriptor = invokedType.returnType().descriptorString();\n+        String lambdaTypeDescriptor = factoryType.returnType().descriptorString();\n@@ -438,1 +434,1 @@\n-        assert invokedType.parameterCount() == 0;\n+        assert factoryType.parameterCount() == 0;\n@@ -458,1 +454,1 @@\n-        int parameterCount = invokedType.parameterCount();\n+        int parameterCount = factoryType.parameterCount();\n@@ -461,1 +457,1 @@\n-            Class<?> argType = invokedType.parameterType(i);\n+            Class<?> argType = factoryType.parameterType(i);\n@@ -486,3 +482,3 @@\n-        mv.visitLdcInsn(invokedType.returnType().getName().replace('.', '\/'));\n-        mv.visitLdcInsn(samMethodName);\n-        mv.visitLdcInsn(samMethodType.toMethodDescriptorString());\n+        mv.visitLdcInsn(factoryType.returnType().getName().replace('.', '\/'));\n+        mv.visitLdcInsn(interfaceMethodName);\n+        mv.visitLdcInsn(interfaceMethodType.toMethodDescriptorString());\n@@ -493,1 +489,1 @@\n-        mv.visitLdcInsn(instantiatedMethodType.toMethodDescriptorString());\n+        mv.visitLdcInsn(dynamicMethodType.toMethodDescriptorString());\n@@ -595,1 +591,1 @@\n-            int captureArity = invokedType.parameterCount();\n+            int captureArity = factoryType.parameterCount();\n@@ -600,1 +596,1 @@\n-                convertType(argType, implMethodType.parameterType(captureArity + i), instantiatedMethodType.parameterType(i));\n+                convertType(argType, implMethodType.parameterType(captureArity + i), dynamicMethodType.parameterType(i));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":86,"deletions":90,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.lang.reflect.Array;\n+import java.util.Objects;\n@@ -42,1 +44,1 @@\n- *     <li><em>Linkage<\/em> occurs when the methods in this class are invoked.\n+ *     <li><p><em>Linkage<\/em> occurs when the methods in this class are invoked.\n@@ -46,7 +48,4 @@\n- *     method handle describing the desired implementation behavior\n- *     for that method, and possibly other additional metadata, and produce a\n- *     {@link CallSite} whose target can be used to create suitable function\n- *     objects.  Linkage may involve dynamically loading a new class that\n- *     implements the target interface. The {@code CallSite} can be considered a\n- *     \"factory\" for function objects and so these linkage methods are referred\n- *     to as \"metafactories\".<\/li>\n+ *     {@linkplain MethodHandleInfo direct method handle} describing the desired\n+ *     implementation behavior for that method, and possibly other additional\n+ *     metadata, and produce a {@link CallSite} whose target can be used to\n+ *     create suitable function objects.\n@@ -54,1 +53,8 @@\n- *     <li><em>Capture<\/em> occurs when the {@code CallSite}'s target is\n+ *     <p>Linkage may involve dynamically loading a new class that implements\n+ *     the target interface, or re-using a suitable existing class.\n+ *\n+ *     <p>The {@code CallSite} can be considered a \"factory\" for function\n+ *     objects and so these linkage methods are referred to as\n+ *     \"metafactories\".<\/li>\n+ *\n+ *     <li><p><em>Capture<\/em> occurs when the {@code CallSite}'s target is\n@@ -56,15 +62,8 @@\n- *     producing a function object.  This may occur many times for\n- *     a single factory {@code CallSite}.  Capture may involve allocation of a\n- *     new function object, or may return an existing function object.  The\n- *     behavior {@code MethodHandle} may have additional parameters beyond those\n- *     of the specified interface method; these are referred to as <em>captured\n- *     parameters<\/em>, which must be provided as arguments to the\n- *     {@code CallSite} target, and which may be early-bound to the behavior\n- *     {@code MethodHandle}.  The number of captured parameters and their types\n- *     are determined during linkage.\n- *     The identity of a function object produced by invoking the\n- *     {@code CallSite}'s target is unpredictable, and therefore\n- *     identity-sensitive operations (such as reference equality, object\n- *     locking, and {@code System.identityHashCode()} may produce different\n- *     results in different implementations, or even upon different invocations\n- *     in the same implementation.<\/li>\n+ *     producing a function object. This may occur many times for\n+ *     a single factory {@code CallSite}.\n+ *\n+ *     <p>If the behavior {@code MethodHandle} has additional parameters beyond\n+ *     those of the specified interface method, these are referred to as\n+ *     <em>captured parameters<\/em>, which must be provided as arguments to the\n+ *     {@code CallSite} target. The expected number and types of captured\n+ *     parameters are determined during linkage.\n@@ -72,5 +71,14 @@\n- *     <li><em>Invocation<\/em> occurs when an implemented interface method\n- *     is invoked on a function object.  This may occur many times for a single\n- *     function object.  The method referenced by the behavior {@code MethodHandle}\n- *     is invoked with the captured arguments and any additional arguments\n- *     provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.<\/li>\n+ *     <p>Capture may involve allocation of a new function object, or may return\n+ *     a suitable existing function object. The identity of a function object\n+ *     produced by capture is unpredictable, and therefore identity-sensitive\n+ *     operations (such as reference equality, object locking, and {@code\n+ *     System.identityHashCode()}) may produce different results in different\n+ *     implementations, or even upon different invocations in the same\n+ *     implementation.<\/li>\n+ *\n+ *     <li><p><em>Invocation<\/em> occurs when an implemented interface method is\n+ *     invoked on a function object. This may occur many times for a single\n+ *     function object. The method referenced by the implementation\n+ *     {@code MethodHandle} is invoked, passing to it the captured arguments and\n+ *     the invocation arguments. The result of the method is returned.\n+ *     <\/li>\n@@ -84,1 +92,1 @@\n- * \"instantiated\" method type; on invocation, the arguments and eventual result\n+ * \"dynamic\" method type; on invocation, the arguments and eventual result\n@@ -124,1 +132,1 @@\n- *      <li>{@code invokedType} (describing the {@code CallSite} signature) has\n+ *      <li>{@code factoryType} (describing the {@code CallSite} signature) has\n@@ -126,1 +134,1 @@\n- *      <li>{@code samMethodType} (describing the implemented method type) has N\n+ *      <li>{@code interfaceMethodType} (describing the implemented method type) has N\n@@ -128,2 +136,2 @@\n- *      <li>{@code implMethod} (the {@code MethodHandle} providing the\n- *      implementation has M parameters, of types (A1..Am) and return type Ra\n+ *      <li>{@code implementation} (the {@code MethodHandle} providing the\n+ *      implementation) has M parameters, of types (A1..Am) and return type Ra\n@@ -133,1 +141,1 @@\n- *      <li>{@code instantiatedMethodType} (allowing restrictions on invocation)\n+ *      <li>{@code dynamicMethodType} (allowing restrictions on invocation)\n@@ -139,3 +147,1 @@\n- *     <li>Rd is an interface<\/li>\n- *     <li>{@code implMethod} is a <em>direct method handle<\/em><\/li>\n- *     <li>{@code samMethodType} and {@code instantiatedMethodType} have the same\n+ *     <li>{@code interfaceMethodType} and {@code dynamicMethodType} have the same\n@@ -153,1 +159,1 @@\n- * <p>Further, at capture time, if {@code implMethod} corresponds to an instance\n+ * <p>Further, at capture time, if {@code implementation} corresponds to an instance\n@@ -221,4 +227,5 @@\n- * @implNote The implementation method is described with a method handle. In\n- * theory, any method handle could be used. Currently supported are direct method\n- * handles representing invocation of virtual, interface, constructor and static\n- * methods.\n+ * <p>The implementation method is described with a direct method handle\n+ * referencing a method or constructor. In theory, any method handle could be\n+ * used, but this is not compatible with some implementation techniques and\n+ * would complicate the work implementations must do.\n+ *\n@@ -231,1 +238,1 @@\n-    \/** Flag for alternate metafactories indicating the lambda object\n+    \/** Flag for {@link #altMetafactory} indicating the lambda object\n@@ -236,3 +243,2 @@\n-     * Flag for alternate metafactories indicating the lambda object implements\n-     * other marker interfaces\n-     * besides Serializable\n+     * Flag for {@link #altMetafactory} indicating the lambda object implements\n+     * other interfaces besides {@code Serializable}\n@@ -252,1 +258,1 @@\n-    \/\/ special cased in java.lang.invokeBootstrapMethodInvoker to ensure\n+    \/\/ special cased in java.lang.invoke.BootstrapMethodInvoker to ensure\n@@ -272,3 +278,3 @@\n-     * implements the interface named by the return type of {@code invokedType},\n-     * declares a method with the name given by {@code invokedName} and the\n-     * signature given by {@code samMethodType}.  It may also override additional\n+     * implements the interface named by the return type of {@code factoryType},\n+     * declares a method with the name given by {@code interfaceMethodName} and the\n+     * signature given by {@code interfaceMethodType}.  It may also override additional\n@@ -283,5 +289,5 @@\n-     * @param invokedName The name of the method to implement.  When used with\n-     *                    {@code invokedynamic}, this is provided by the\n-     *                    {@code NameAndType} of the {@code InvokeDynamic}\n-     *                    structure and is stacked automatically by the VM.\n-     * @param invokedType The expected signature of the {@code CallSite}.  The\n+     * @param interfaceMethodName The name of the method to implement.  When used with\n+     *                            {@code invokedynamic}, this is provided by the\n+     *                            {@code NameAndType} of the {@code InvokeDynamic}\n+     *                            structure and is stacked automatically by the VM.\n+     * @param factoryType The expected signature of the {@code CallSite}.  The\n@@ -293,15 +299,11 @@\n-     *                    In the event that the implementation method is an\n-     *                    instance method and this signature has any parameters,\n-     *                    the first parameter in the invocation signature must\n-     *                    correspond to the receiver.\n-     * @param samMethodType Signature and return type of method to be implemented\n-     *                      by the function object.\n-     * @param implMethod A direct method handle describing the implementation\n-     *                   method which should be called (with suitable adaptation\n-     *                   of argument types, return types, and with captured\n-     *                   arguments prepended to the invocation arguments) at\n-     *                   invocation time.\n-     * @param instantiatedMethodType The signature and return type that should\n-     *                               be enforced dynamically at invocation time.\n-     *                               This may be the same as {@code samMethodType},\n-     *                               or may be a specialization of it.\n+     * @param interfaceMethodType Signature and return type of method to be\n+     *                            implemented by the function object.\n+     * @param implementation A direct method handle describing the implementation\n+     *                       method which should be called (with suitable adaptation\n+     *                       of argument types and return types, and with captured\n+     *                       arguments prepended to the invocation arguments) at\n+     *                       invocation time.\n+     * @param dynamicMethodType The signature and return type that should\n+     *                          be enforced dynamically at invocation time.\n+     *                          In simple use cases this is the same as\n+     *                          {@code interfaceMethodType}.\n@@ -309,5 +311,11 @@\n-     *         instances of the interface named by {@code invokedType}\n-     * @throws LambdaConversionException If any of the linkage invariants\n-     *                                   described {@link LambdaMetafactory above}\n-     *                                   are violated, or the lookup context\n-     *                                   does not have private access privileges.\n+     *         instances of the interface named by {@code factoryType}\n+     * @throws LambdaConversionException If {@code caller} does not have private\n+     *         access privileges, or if {@code interfaceMethodName} is not a valid JVM\n+     *         method name, or if the return type of {@code factoryType} is not\n+     *         an interface, or if {@code implementation} is not a direct method\n+     *         handle referencing a method or constructor, or if the linkage\n+     *         invariants are violated, as defined {@link LambdaMetafactory above}.\n+     * @throws NullPointerException If any argument is {@code null}.\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -316,5 +324,5 @@\n-                                       String invokedName,\n-                                       MethodType invokedType,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType)\n+                                       String interfaceMethodName,\n+                                       MethodType factoryType,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType)\n@@ -323,4 +331,9 @@\n-        mf = new InnerClassLambdaMetafactory(caller, invokedType,\n-                                             invokedName, samMethodType,\n-                                             implMethod, instantiatedMethodType,\n-                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);\n+        mf = new InnerClassLambdaMetafactory(Objects.requireNonNull(caller),\n+                                             Objects.requireNonNull(factoryType),\n+                                             Objects.requireNonNull(interfaceMethodName),\n+                                             Objects.requireNonNull(interfaceMethodType),\n+                                             Objects.requireNonNull(implementation),\n+                                             Objects.requireNonNull(dynamicMethodType),\n+                                             false,\n+                                             EMPTY_CLASS_ARRAY,\n+                                             EMPTY_MT_ARRAY);\n@@ -353,2 +366,2 @@\n-     *                          String invokedName,\n-     *                          MethodType invokedType,\n+     *                          String interfaceMethodName,\n+     *                          MethodType factoryType,\n@@ -362,5 +375,5 @@\n-     *                          String invokedName,\n-     *                          MethodType invokedType,\n-     *                          MethodType samMethodType,\n-     *                          MethodHandle implMethod,\n-     *                          MethodType instantiatedMethodType,\n+     *                          String interfaceMethodName,\n+     *                          MethodType factoryType,\n+     *                          MethodType interfaceMethodType,\n+     *                          MethodHandle implementation,\n+     *                          MethodType dynamicMethodType,\n@@ -368,2 +381,2 @@\n-     *                          int markerInterfaceCount,  \/\/ IF flags has MARKERS set\n-     *                          Class... markerInterfaces, \/\/ IF flags has MARKERS set\n+     *                          int interfaceCount,        \/\/ IF flags has MARKERS set\n+     *                          Class... interfaces,       \/\/ IF flags has MARKERS set\n@@ -383,1 +396,1 @@\n-     *     <li>{@code markerInterfaceCount} is the number of additional interfaces\n+     *     <li>{@code interfaceCount} is the number of additional interfaces\n@@ -386,2 +399,2 @@\n-     *     <li>{@code markerInterfaces} is a variable-length list of additional\n-     *     interfaces to implement, whose length equals {@code markerInterfaceCount},\n+     *     <li>{@code interfaces} is a variable-length list of additional\n+     *     interfaces to implement, whose length equals {@code interfaceCount},\n@@ -397,2 +410,2 @@\n-     * <p>Each class named by {@code markerInterfaces} is subject to the same\n-     * restrictions as {@code Rd}, the return type of {@code invokedType},\n+     * <p>Each class named by {@code interfaces} is subject to the same\n+     * restrictions as {@code Rd}, the return type of {@code factoryType},\n@@ -401,1 +414,1 @@\n-     * {@code samMethodType}, as described {@link LambdaMetafactory above}.\n+     * {@code interfaceMethodType}, as described {@link LambdaMetafactory above}.\n@@ -414,3 +427,3 @@\n-     *     of {@code invokedType} and any interfaces named by {@code markerInterfaces}<\/li>\n-     *     <li>The class declares methods with the name given by {@code invokedName},\n-     *     and the signature given by {@code samMethodType} and additional signatures\n+     *     of {@code factoryType} and any interfaces named by {@code interfaces}<\/li>\n+     *     <li>The class declares methods with the name given by {@code interfaceMethodName},\n+     *     and the signature given by {@code interfaceMethodType} and additional signatures\n@@ -428,5 +441,5 @@\n-     * @param invokedName The name of the method to implement.  When used with\n-     *                    {@code invokedynamic}, this is provided by the\n-     *                    {@code NameAndType} of the {@code InvokeDynamic}\n-     *                    structure and is stacked automatically by the VM.\n-     * @param invokedType The expected signature of the {@code CallSite}.  The\n+     * @param interfaceMethodName The name of the method to implement.  When used with\n+     *                            {@code invokedynamic}, this is provided by the\n+     *                            {@code NameAndType} of the {@code InvokeDynamic}\n+     *                            structure and is stacked automatically by the VM.\n+     * @param factoryType The expected signature of the {@code CallSite}.  The\n@@ -438,9 +451,4 @@\n-     *                    In the event that the implementation method is an\n-     *                    instance method and this signature has any parameters,\n-     *                    the first parameter in the invocation signature must\n-     *                    correspond to the receiver.\n-     * @param  args       An {@code Object[]} array containing the required\n-     *                    arguments {@code samMethodType}, {@code implMethod},\n-     *                    {@code instantiatedMethodType}, {@code flags}, and any\n-     *                    optional arguments, as described\n-     *                    {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)} above}\n+     * @param  args An array of {@code Object} containing the required\n+     *              arguments {@code interfaceMethodType}, {@code implementation},\n+     *              {@code dynamicMethodType}, {@code flags}, and any\n+     *              optional arguments, as described above\n@@ -448,5 +456,17 @@\n-     *         instances of the interface named by {@code invokedType}\n-     * @throws LambdaConversionException If any of the linkage invariants\n-     *                                   described {@link LambdaMetafactory above}\n-     *                                   are violated, or the lookup context\n-     *                                   does not have private access privileges.\n+     *         instances of the interface named by {@code factoryType}\n+     * @throws LambdaConversionException If {@code caller} does not have private\n+     *         access privileges, or if {@code interfaceMethodName} is not a valid JVM\n+     *         method name, or if the return type of {@code factoryType} is not\n+     *         an interface, or if any of {@code interfaces} is not an\n+     *         interface, or if {@code implementation} is not a direct method\n+     *         handle referencing a method or constructor, or if the linkage\n+     *         invariants are violated, as defined {@link LambdaMetafactory above}.\n+     * @throws NullPointerException If any argument, or any component of {@code args},\n+     *         is {@code null}.\n+     * @throws IllegalArgumentException If the number or types of the components\n+     *         of {@code args} do not follow the above rules, or if\n+     *         {@code interfaceCount} or {@code bridgeCount} are negative\n+     *         integers.\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -455,2 +475,2 @@\n-                                          String invokedName,\n-                                          MethodType invokedType,\n+                                          String interfaceMethodName,\n+                                          MethodType factoryType,\n@@ -459,7 +479,11 @@\n-        MethodType samMethodType = (MethodType)args[0];\n-        MethodHandle implMethod = (MethodHandle)args[1];\n-        MethodType instantiatedMethodType = (MethodType)args[2];\n-        int flags = (Integer) args[3];\n-        Class<?>[] markerInterfaces;\n-        MethodType[] bridges;\n-        int argIndex = 4;\n+        Objects.requireNonNull(caller);\n+        Objects.requireNonNull(interfaceMethodName);\n+        Objects.requireNonNull(factoryType);\n+        Objects.requireNonNull(args);\n+        int argIndex = 0;\n+        MethodType interfaceMethodType = extractArg(args, argIndex++, MethodType.class);\n+        MethodHandle implementation = extractArg(args, argIndex++, MethodHandle.class);\n+        MethodType dynamicMethodType = extractArg(args, argIndex++, MethodType.class);\n+        int flags = extractArg(args, argIndex++, Integer.class);\n+        Class<?>[] interfaces = EMPTY_CLASS_ARRAY;\n+        MethodType[] bridges = EMPTY_MT_ARRAY;\n@@ -467,4 +491,8 @@\n-            int markerCount = (Integer) args[argIndex++];\n-            markerInterfaces = new Class<?>[markerCount];\n-            System.arraycopy(args, argIndex, markerInterfaces, 0, markerCount);\n-            argIndex += markerCount;\n+            int interfaceCount = extractArg(args, argIndex++, Integer.class);\n+            if (interfaceCount < 0) {\n+                throw new IllegalArgumentException(\"negative argument count\");\n+            }\n+            if (interfaceCount > 0) {\n+                interfaces = extractArgs(args, argIndex, Class.class, interfaceCount);\n+                argIndex += interfaceCount;\n+            }\n@@ -472,2 +500,0 @@\n-        else\n-            markerInterfaces = EMPTY_CLASS_ARRAY;\n@@ -475,4 +501,11 @@\n-            int bridgeCount = (Integer) args[argIndex++];\n-            bridges = new MethodType[bridgeCount];\n-            System.arraycopy(args, argIndex, bridges, 0, bridgeCount);\n-            argIndex += bridgeCount;\n+            int bridgeCount = extractArg(args, argIndex++, Integer.class);\n+            if (bridgeCount < 0) {\n+                throw new IllegalArgumentException(\"negative argument count\");\n+            }\n+            if (bridgeCount > 0) {\n+                bridges = extractArgs(args, argIndex, MethodType.class, bridgeCount);\n+                argIndex += bridgeCount;\n+            }\n+        }\n+        if (argIndex < args.length) {\n+            throw new IllegalArgumentException(\"too many arguments\");\n@@ -480,2 +513,0 @@\n-        else\n-            bridges = EMPTY_MT_ARRAY;\n@@ -485,2 +516,2 @@\n-            boolean foundSerializableSupertype = Serializable.class.isAssignableFrom(invokedType.returnType());\n-            for (Class<?> c : markerInterfaces)\n+            boolean foundSerializableSupertype = Serializable.class.isAssignableFrom(factoryType.returnType());\n+            for (Class<?> c : interfaces)\n@@ -489,2 +520,2 @@\n-                markerInterfaces = Arrays.copyOf(markerInterfaces, markerInterfaces.length + 1);\n-                markerInterfaces[markerInterfaces.length-1] = Serializable.class;\n+                interfaces = Arrays.copyOf(interfaces, interfaces.length + 1);\n+                interfaces[interfaces.length-1] = Serializable.class;\n@@ -495,4 +526,6 @@\n-                = new InnerClassLambdaMetafactory(caller, invokedType,\n-                                                  invokedName, samMethodType,\n-                                                  implMethod,\n-                                                  instantiatedMethodType,\n+                = new InnerClassLambdaMetafactory(caller,\n+                                                  factoryType,\n+                                                  interfaceMethodName,\n+                                                  interfaceMethodType,\n+                                                  implementation,\n+                                                  dynamicMethodType,\n@@ -500,1 +533,2 @@\n-                                                  markerInterfaces, bridges);\n+                                                  interfaces,\n+                                                  bridges);\n@@ -504,0 +538,21 @@\n+\n+    private static <T> T extractArg(Object[] args, int index, Class<T> type) {\n+        if (index >= args.length) {\n+            throw new IllegalArgumentException(\"missing argument\");\n+        }\n+        Object result = Objects.requireNonNull(args[index]);\n+        if (!type.isInstance(result)) {\n+            throw new IllegalArgumentException(\"argument has wrong type\");\n+        }\n+        return type.cast(result);\n+    }\n+\n+    private static <T> T[] extractArgs(Object[] args, int index, Class<T> type, int count) {\n+        @SuppressWarnings(\"unchecked\")\n+        T[] result = (T[]) Array.newInstance(type, count);\n+        for (int i = 0; i < count; i++) {\n+            result[i] = extractArg(args, index + i, type);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":207,"deletions":152,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8174222\n+ * @summary Validation of LambdaMetafactory arguments\n+ *\/\n+import java.lang.invoke.*;\n+import java.util.*;\n+\n+public class MetafactoryArgValidationTest {\n+\n+    public static void main(String... args) {\n+        \/\/testNPE();\n+        \/\/testIAE();\n+        testLCE();\n+    }\n+\n+    public static void testNPE() {\n+        MethodType toI = mt(I.class);\n+        MethodType toVoid = mt(void.class);\n+        MethodType toC = mt(C.class);\n+        MethodHandle impl = C.invokeStaticMH();\n+        MethodHandle impl2 = C.newInvokeSpecialMH();\n+        int flagSer = LambdaMetafactory.FLAG_SERIALIZABLE;\n+        int flagMark = LambdaMetafactory.FLAG_MARKERS;\n+        int flagBridge = LambdaMetafactory.FLAG_BRIDGES;\n+\n+        mfFail(NullPointerException.class, null, \"m\", toI, toVoid, impl, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, null, toI, toVoid, impl, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, \"m\", null, toVoid, impl, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, \"m\", toI, null, impl, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, \"m\", toI, toVoid, null, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, \"m\", toI, toVoid, impl, null);\n+\n+        amfFail(NullPointerException.class, null, \"m\", toI, arr(toVoid, impl, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, null, toI, arr(toVoid, impl, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", null, arr(toVoid, impl, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, null);\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(null, impl, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, null, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, null, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 2, Runnable.class, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 1, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 1, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 2, mt(Object.class), null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, 1, Runnable.class, 2, mt(Object.class), null));\n+    }\n+\n+    public static void testIAE() {\n+        MethodType toI = mt(I.class);\n+        MethodType toVoid = mt(void.class);\n+        MethodType toC = mt(C.class);\n+        MethodHandle impl = C.invokeStaticMH();\n+        MethodHandle impl2 = C.newInvokeSpecialMH();\n+        int flagSer = LambdaMetafactory.FLAG_SERIALIZABLE;\n+        int flagMark = LambdaMetafactory.FLAG_MARKERS;\n+        int flagBridge = LambdaMetafactory.FLAG_BRIDGES;\n+\n+        \/\/ missing arguments\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr());\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid));\n+        amfSucceed(C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, 0));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 2, Runnable.class));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 1));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 2, mt(Object.class)));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, 1, Runnable.class, 2, mt(Object.class)));\n+\n+        \/\/ too many arguments\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, 0, 1));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagMark|flagSer, 1, Runnable.class, 1, mt(Object.class)));\n+\n+        \/\/ wrong argument types\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(impl, impl, toVoid, flagSer));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, toVoid, toVoid, flagSer));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, impl, flagSer));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, \"hi\"));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, Runnable.class));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagBridge, 1, Runnable.class));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1, toVoid));\n+\n+        \/\/ negative count\n+        amfSucceed(C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, 0, 0));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, -1, 0));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, 0, -1));\n+    }\n+\n+    public static void testLCE() {\n+        MethodType toI = mt(I.class);\n+        MethodType toC = mt(C.class);\n+        MethodType toVoid = mt(void.class);\n+        MethodType cToVoid = mt(void.class, C.class);\n+        MethodType ccToVoid = mt(void.class, C.class, C.class);\n+        MethodType cToC = mt(C.class, C.class);\n+        MethodType cToString = mt(String.class, C.class);\n+        MethodHandle impl = C.invokeStaticMH();\n+        int flagSer = LambdaMetafactory.FLAG_SERIALIZABLE;\n+        int flagMark = LambdaMetafactory.FLAG_MARKERS;\n+\n+        \/\/ non-interface\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", mt(Object.class), toVoid, impl, toVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", mt(Object.class), arr(toVoid, impl, toVoid, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", mt(int.class), toVoid, impl, toVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", mt(int.class), arr(toVoid, impl, toVoid, flagSer));\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1, Object.class));\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1, int.class));\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 2, Runnable.class, Object.class));\n+\n+        \/\/ lookup without private access\n+        mfFail(LambdaConversionException.class, MethodHandles.publicLookup(), \"m\", toI, toVoid, impl, toVoid);\n+        amfFail(LambdaConversionException.class, MethodHandles.publicLookup(), \"m\", toI, arr(toVoid, impl, toVoid, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup.dropLookupMode(MethodHandles.Lookup.PRIVATE), \"m\", toI, toVoid, impl, toVoid);\n+        amfFail(LambdaConversionException.class, C.lookup.dropLookupMode(MethodHandles.Lookup.PRIVATE), \"m\", toI, arr(toVoid, impl, toVoid, flagSer));\n+\n+        \/\/ unsupported MethodHandle\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, cToC, C.getFieldMH(), cToC);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(cToC, C.getFieldMH(), cToC, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, toC, C.getStaticMH(), toC);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toC, C.getStaticMH(), toC, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, ccToVoid, C.putFieldMH(), ccToVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(ccToVoid, C.putFieldMH(), ccToVoid, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, cToVoid, C.putStaticMH(), cToVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(cToVoid, C.putStaticMH(), cToVoid, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, cToVoid, C.invokeVirtualMH(), cToVoid);\n+        amfSucceed(C.lookup, \"m\", toI, arr(cToVoid, C.invokeVirtualMH(), cToVoid, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, toVoid, C.invokeStaticMH(), toVoid);\n+        amfSucceed(C.lookup, \"m\", toI, arr(toVoid, C.invokeStaticMH(), toVoid, flagSer));\n+        \/\/ 8268192: these fail with a VerifyError, need to fix\n+        \/\/mfSucceed(C.lookup, \"m\", toI, cToString, C.invokeSpecialMH(), cToString);\n+        \/\/amfSucceed(C.lookup, \"m\", toI, arr(cToString, C.invokeSpecialMH(), cToString, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, toC, C.newInvokeSpecialMH(), toC);\n+        amfSucceed(C.lookup, \"m\", toI, arr(toC, C.newInvokeSpecialMH(), toC, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, cToVoid, C.invokeInterfaceMH(), cToVoid);\n+        amfSucceed(C.lookup, \"m\", toI, arr(cToVoid, C.invokeInterfaceMH(), cToVoid, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, toVoid, MethodHandles.empty(toVoid), toVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toVoid, MethodHandles.empty(toVoid), toVoid, flagSer));\n+    }\n+\n+    static MethodType mt(Class<?> ret, Class<?>... params) {\n+        return MethodType.methodType(ret, params);\n+    }\n+\n+    static Object[] arr(Object... args) {\n+        return args;\n+    }\n+\n+    public static class C implements Runnable {\n+\n+        public static MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+        public static MethodHandle getFieldMH() {\n+            try { return lookup.findGetter(C.class, \"iv\", C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle getStaticMH() {\n+            try { return lookup.findStaticGetter(C.class, \"sv\", C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle putFieldMH() {\n+            try { return lookup.findSetter(C.class, \"iv\", C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle putStaticMH() {\n+            try { return lookup.findStaticSetter(C.class, \"sv\", C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle invokeVirtualMH() {\n+            try { return lookup.findVirtual(C.class, \"im\", mt(void.class)); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle invokeStaticMH() {\n+            try { return lookup.findStatic(C.class, \"sm\", mt(void.class)); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle invokeSpecialMH() {\n+            try { return lookup.findSpecial(Object.class, \"toString\", mt(String.class), C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle newInvokeSpecialMH() {\n+            try { return lookup.findConstructor(C.class, mt(void.class)); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle invokeInterfaceMH() {\n+            try { return lookup.findVirtual(Runnable.class, \"run\", mt(void.class)); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static C sv;\n+        public C iv;\n+        public static void sm() {}\n+        public void im() {}\n+        public C() {}\n+        public void run() {}\n+    }\n+\n+    public interface I {}\n+\n+    static CallSite mfSucceed(MethodHandles.Lookup lookup,\n+                              String name,\n+                              MethodType capType,\n+                              MethodType desc,\n+                              MethodHandle impl,\n+                              MethodType checked) {\n+        try {\n+            return LambdaMetafactory.metafactory(lookup, name, capType, desc, impl, checked);\n+        } catch (Throwable t) {\n+            String msg = String.format(\"Unexpected exception during linkage for metafactory(%s, %s, %s, %s, %s, %s)\",\n+                    lookup, name, capType, desc, impl, checked);\n+            throw new AssertionError(msg, t);\n+        }\n+    }\n+\n+    static void mfFail(Class<?> exceptionType,\n+                       MethodHandles.Lookup lookup,\n+                       String name,\n+                       MethodType capType,\n+                       MethodType desc,\n+                       MethodHandle impl,\n+                       MethodType checked) {\n+        try {\n+            LambdaMetafactory.metafactory(lookup, name, capType, desc, impl, checked);\n+        } catch (Throwable t) {\n+            if (exceptionType.isInstance(t)) {\n+                return;\n+            } else {\n+                String msg = String.format(\"Unexpected exception: expected %s during linkage for metafactory(%s, %s, %s, %s, %s, %s)\",\n+                                           exceptionType.getName(), lookup, name, capType, desc, impl, checked);\n+                throw new AssertionError(msg, t);\n+            }\n+        }\n+        String msg = String.format(\"Unexpected success: expected %s during linkage for metafactory(%s, %s, %s, %s, %s, %s)\",\n+                                   exceptionType.getName(), lookup, name, capType, desc, impl, checked);\n+        throw new AssertionError(msg);\n+    }\n+\n+    static CallSite amfSucceed(MethodHandles.Lookup lookup,\n+                               String name,\n+                               MethodType capType,\n+                               Object[] args) {\n+        try {\n+            return LambdaMetafactory.altMetafactory(lookup, name, capType, args);\n+        } catch (Throwable t) {\n+            String msg = String.format(\"Unexpected exception during linkage for altMetafactory(%s, %s, %s, %s)\",\n+                                       lookup, name, capType, Arrays.asList(args));\n+            throw new AssertionError(msg, t);\n+        }\n+    }\n+\n+    static void amfFail(Class<?> exceptionType,\n+                        MethodHandles.Lookup lookup,\n+                        String name,\n+                        MethodType capType,\n+                        Object[] args) {\n+        try {\n+            LambdaMetafactory.altMetafactory(lookup, name, capType, args);\n+        } catch (Throwable t) {\n+            if (exceptionType.isInstance(t)) {\n+                return;\n+            } else {\n+                String msg = String.format(\"Unexpected exception: expected %s during linkage for altMetafactory(%s, %s, %s, %s)\",\n+                                           exceptionType.getName(), lookup, name, capType, Arrays.asList(args));\n+                throw new AssertionError(msg, t);\n+            }\n+        }\n+        String msg = String.format(\"Unexpected success: expected %s during linkage for altMetafactory(%s, %s, %s, %s)\",\n+                                   exceptionType.getName(), lookup, name, capType, Arrays.asList(args));\n+        throw new AssertionError(msg);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/MetafactoryArgValidationTest.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"}]}