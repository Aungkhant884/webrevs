{"files":[{"patch":"@@ -30,1 +30,1 @@\n-#include \"memory\/dynamicArchive.hpp\"\n+#include \"memory\/archiveBuilder.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n@@ -77,1 +76,1 @@\n-  size_t bucket_bytes = MetaspaceShared::ro_array_bytesize<u4>(num_buckets + 1);\n+  size_t bucket_bytes = ArchiveBuilder::ro_array_bytesize<u4>(num_buckets + 1);\n@@ -81,1 +80,1 @@\n-  size_t entry_bytes = MetaspaceShared::ro_array_bytesize<u4>(entries_space);\n+  size_t entry_bytes = ArchiveBuilder::ro_array_bytesize<u4>(entries_space);\n@@ -112,2 +111,2 @@\n-  _compact_buckets = MetaspaceShared::new_ro_array<u4>(_num_buckets + 1);\n-  _compact_entries = MetaspaceShared::new_ro_array<u4>(entries_space);\n+  _compact_buckets = ArchiveBuilder::new_ro_array<u4>(_num_buckets + 1);\n+  _compact_entries = ArchiveBuilder::new_ro_array<u4>(entries_space);\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,4 @@\n+\n+  CompactHashtableStats() :\n+    hashentry_count(0), hashentry_bytes(0),\n+    bucket_count(0), bucket_bytes(0) {}\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n@@ -388,1 +387,1 @@\n-  ModuleEntry* archived_entry = (ModuleEntry*)MetaspaceShared::read_write_space_alloc(sizeof(ModuleEntry));\n+  ModuleEntry* archived_entry = (ModuleEntry*)ArchiveBuilder::rw_region_alloc(sizeof(ModuleEntry));\n@@ -413,1 +412,1 @@\n-    archived_array = MetaspaceShared::new_ro_array<ModuleEntry*>(length);\n+    archived_array = ArchiveBuilder::new_ro_array<ModuleEntry*>(length);\n@@ -521,1 +520,1 @@\n-  Array<ModuleEntry*>* archived_modules = MetaspaceShared::new_rw_array<ModuleEntry*>(number_of_entries());\n+  Array<ModuleEntry*>* archived_modules = ArchiveBuilder::new_rw_array<ModuleEntry*>(number_of_entries());\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n@@ -212,1 +211,1 @@\n-  PackageEntry* archived_entry = (PackageEntry*)MetaspaceShared::read_write_space_alloc(sizeof(PackageEntry));\n+  PackageEntry* archived_entry = (PackageEntry*)ArchiveBuilder::rw_region_alloc(sizeof(PackageEntry));\n@@ -282,1 +281,1 @@\n-  Array<PackageEntry*>* archived_packages = MetaspaceShared::new_rw_array<PackageEntry*>(n);\n+  Array<PackageEntry*>* archived_packages = ArchiveBuilder::new_rw_array<PackageEntry*>(n);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"memory\/filemap.hpp\"\n+#include \"memory\/archiveBuilder.hpp\"\n@@ -763,1 +763,1 @@\n-  CompactHashtableWriter writer(_items_count, &MetaspaceShared::stats()->string);\n+  CompactHashtableWriter writer(_items_count, ArchiveBuilder::string_stats());\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n@@ -605,2 +604,1 @@\n-  CompactHashtableWriter writer(int(_items_count),\n-                                &MetaspaceShared::stats()->symbol);\n+  CompactHashtableWriter writer(int(_items_count), ArchiveBuilder::symbol_stats());\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2041,1 +2041,1 @@\n-        (RunTimeLambdaProxyClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);\n+        (RunTimeLambdaProxyClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n@@ -2089,1 +2089,1 @@\n-      record = (RunTimeSharedClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);\n+      record = (RunTimeSharedClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"memory\/metaspaceShared.hpp\"\n+#include \"memory\/metaspace.hpp\"\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"interpreter\/abstractInterpreter.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -72,1 +74,1 @@\n-  char* newtop = ArchiveBuilder::current()->_ro_region->top();\n+  char* newtop = ArchiveBuilder::current()->_ro_region.top();\n@@ -162,5 +164,28 @@\n-ArchiveBuilder::ArchiveBuilder(DumpRegion* mc_region, DumpRegion* rw_region, DumpRegion* ro_region)\n-  : _rw_src_objs(), _ro_src_objs(), _src_obj_table(INITIAL_TABLE_SIZE) {\n-  assert(_current == NULL, \"must be\");\n-  _current = this;\n-\n+ArchiveBuilder::ArchiveBuilder() :\n+  _current_dump_space(NULL),\n+  _buffer_bottom(NULL),\n+  _last_verified_top(NULL),\n+  _num_dump_regions_used(0),\n+  _other_region_used_bytes(0),\n+  _requested_static_archive_bottom(NULL),\n+  _requested_static_archive_top(NULL),\n+  _requested_dynamic_archive_bottom(NULL),\n+  _requested_dynamic_archive_top(NULL),\n+  _mapped_static_archive_bottom(NULL),\n+  _mapped_static_archive_top(NULL),\n+  _buffer_to_requested_delta(0),\n+  _mc_region(\"mc\", MAX_SHARED_DELTA),\n+  _rw_region(\"rw\", MAX_SHARED_DELTA),\n+  _ro_region(\"ro\", MAX_SHARED_DELTA),\n+  _rw_src_objs(),\n+  _ro_src_objs(),\n+  _src_obj_table(INITIAL_TABLE_SIZE),\n+  _num_instance_klasses(0),\n+  _num_obj_array_klasses(0),\n+  _num_type_array_klasses(0),\n+  _total_closed_heap_region_size(0),\n+  _total_open_heap_region_size(0),\n+  _estimated_metaspaceobj_bytes(0),\n+  _estimated_hashtable_bytes(0),\n+  _estimated_trampoline_bytes(0)\n+{\n@@ -171,22 +196,2 @@\n-  _num_instance_klasses = 0;\n-  _num_obj_array_klasses = 0;\n-  _num_type_array_klasses = 0;\n-  _alloc_stats = new (ResourceObj::C_HEAP, mtClassShared) DumpAllocStats;\n-\n-  _mc_region = mc_region;\n-  _rw_region = rw_region;\n-  _ro_region = ro_region;\n-\n-  _num_dump_regions_used = 0;\n-\n-  _estimated_metaspaceobj_bytes = 0;\n-  _estimated_hashtable_bytes = 0;\n-  _estimated_trampoline_bytes = 0;\n-\n-  _requested_static_archive_bottom = NULL;\n-  _requested_static_archive_top = NULL;\n-  _mapped_static_archive_bottom = NULL;\n-  _mapped_static_archive_top = NULL;\n-  _requested_dynamic_archive_bottom = NULL;\n-  _requested_dynamic_archive_top = NULL;\n-  _buffer_to_requested_delta = 0;\n+  assert(_current == NULL, \"must be\");\n+  _current = this;\n@@ -208,1 +213,4 @@\n-  delete _alloc_stats;\n+}\n+\n+bool ArchiveBuilder::is_dumping_full_module_graph() {\n+  return DumpSharedSpaces && MetaspaceShared::use_full_module_graph();\n@@ -264,1 +272,1 @@\n-  if (DumpSharedSpaces && MetaspaceShared::use_full_module_graph()) {\n+  if (is_dumping_full_module_graph()) {\n@@ -338,1 +346,1 @@\n-  _estimated_trampoline_bytes = allocate_method_trampoline_info();\n+  _estimated_trampoline_bytes = collect_method_trampolines();\n@@ -369,1 +377,1 @@\n-  log_info(cds)(\"Reserved output buffer space at    : \" PTR_FORMAT \" [\" SIZE_FORMAT \" bytes]\",\n+  log_info(cds)(\"Reserved output buffer space at \" PTR_FORMAT \" [\" SIZE_FORMAT \" bytes]\",\n@@ -371,1 +379,1 @@\n-  MetaspaceShared::set_shared_rs(rs);\n+  _shared_rs = rs;\n@@ -373,1 +381,0 @@\n-  MetaspaceShared::init_shared_dump_space(_mc_region);\n@@ -376,1 +383,1 @@\n-  _current_dump_space = _mc_region;\n+  _current_dump_space = &_mc_region;\n@@ -379,0 +386,1 @@\n+  _current_dump_space->init(&_shared_rs, &_shared_vs);\n@@ -380,1 +388,1 @@\n-  ArchivePtrMarker::initialize(&_ptrmap, (address*)_mc_region->base(), (address*)_mc_region->top());\n+  ArchivePtrMarker::initialize(&_ptrmap, &_shared_vs);\n@@ -523,0 +531,1 @@\n+  gather_klasses_and_symbols();\n@@ -568,0 +577,25 @@\n+void ArchiveBuilder::start_dump_space(DumpRegion* next) {\n+  address bottom = _last_verified_top;\n+  address top = (address)(current_dump_space()->top());\n+  _other_region_used_bytes += size_t(top - bottom);\n+\n+  current_dump_space()->pack(next);\n+  _current_dump_space = next;\n+  _num_dump_regions_used ++;\n+\n+  _last_verified_top = (address)(current_dump_space()->top());\n+}\n+\n+void ArchiveBuilder::verify_estimate_size(size_t estimate, const char* which) {\n+  address bottom = _last_verified_top;\n+  address top = (address)(current_dump_space()->top());\n+  size_t used = size_t(top - bottom) + _other_region_used_bytes;\n+  int diff = int(estimate) - int(used);\n+\n+  log_info(cds)(\"%s estimate = \" SIZE_FORMAT \" used = \" SIZE_FORMAT \"; diff = %d bytes\", which, estimate, used, diff);\n+  assert(diff >= 0, \"Estimate is too small\");\n+\n+  _last_verified_top = top;\n+  _other_region_used_bytes = 0;\n+}\n+\n@@ -571,1 +605,11 @@\n-  make_shallow_copies(_rw_region, &_rw_src_objs);\n+  start_dump_space(&_rw_region);\n+  make_shallow_copies(&_rw_region, &_rw_src_objs);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (is_dumping_full_module_graph()) {\n+    \/\/ Archive the ModuleEntry's and PackageEntry's of the 3 built-in loaders\n+    char* start = rw_region()->top();\n+    ClassLoaderDataShared::allocate_archived_tables();\n+    alloc_stats()->record_modules(rw_region()->top() - start, \/*read_only*\/false);\n+  }\n+#endif\n@@ -577,1 +621,11 @@\n-  make_shallow_copies(_ro_region, &_ro_src_objs);\n+\n+  start_dump_space(&_ro_region);\n+  make_shallow_copies(&_ro_region, &_ro_src_objs);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (is_dumping_full_module_graph()) {\n+    char* start = ro_region()->top();\n+    ClassLoaderDataShared::init_archived_tables();\n+    alloc_stats()->record_modules(ro_region()->top() - start, \/*read_only*\/true);\n+  }\n+#endif\n@@ -622,1 +676,1 @@\n-  _alloc_stats->record(ref->msotype(), int(newtop - oldtop), src_info->read_only());\n+  _alloc_stats.record(ref->msotype(), int(newtop - oldtop), src_info->read_only());\n@@ -824,0 +878,2 @@\n+  ro_region()->pack();\n+\n@@ -992,3 +1048,3 @@\n-    DumpRegion* mc_region = builder->_mc_region;\n-    DumpRegion* rw_region = builder->_rw_region;\n-    DumpRegion* ro_region = builder->_ro_region;\n+    DumpRegion* mc_region = &builder->_mc_region;\n+    DumpRegion* rw_region = &builder->_rw_region;\n+    DumpRegion* ro_region = &builder->_ro_region;\n@@ -1022,12 +1078,2 @@\n-void ArchiveBuilder::write_cds_map_to_log(FileMapInfo* mapinfo,\n-                                          GrowableArray<MemRegion> *closed_heap_regions,\n-                                          GrowableArray<MemRegion> *open_heap_regions,\n-                                          char* bitmap, size_t bitmap_size_in_bytes) {\n-  if (log_is_enabled(Info, cds, map)) {\n-    CDSMapLogger::write(this, mapinfo, closed_heap_regions, open_heap_regions,\n-                        bitmap, bitmap_size_in_bytes);\n-  }\n-}\n-\n-void ArchiveBuilder::print_stats(int ro_all, int rw_all, int mc_all) {\n-  _alloc_stats->print_stats(ro_all, rw_all, mc_all);\n+void ArchiveBuilder::print_stats() {\n+  _alloc_stats.print_stats(int(_ro_region.used()), int(_rw_region.used()), int(_mc_region.used()));\n@@ -1041,0 +1087,14 @@\n+void ArchiveBuilder::init_mc_region() {\n+  if (DumpSharedSpaces) { \/\/ these are needed only for static archive\n+    \/\/ We don't want any valid object to be at the very bottom of the archive.\n+    \/\/ See ArchivePtrMarker::mark_pointer().\n+    mc_region()->allocate(16);\n+\n+    size_t trampoline_size = SharedRuntime::trampoline_size();\n+    size_t buf_size = (size_t)AbstractInterpreter::number_of_method_entries * trampoline_size;\n+    MetaspaceShared::set_i2i_entry_code_buffers((address)mc_region()->allocate(buf_size));\n+  }\n+\n+  allocate_method_trampolines();\n+}\n+\n@@ -1051,1 +1111,1 @@\n-          (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size()));\n+          (address)mc_region()->allocate(SharedRuntime::trampoline_size()));\n@@ -1053,1 +1113,1 @@\n-          (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*)));\n+          (AdapterHandlerEntry**)mc_region()->allocate(sizeof(AdapterHandlerEntry*)));\n@@ -1072,1 +1132,1 @@\n-size_t ArchiveBuilder::allocate_method_trampoline_info() {\n+size_t ArchiveBuilder::collect_method_trampolines() {\n@@ -1127,0 +1187,117 @@\n+void ArchiveBuilder::write_archive(FileMapInfo* mapinfo,\n+                                   GrowableArray<MemRegion>* closed_heap_regions,\n+                                   GrowableArray<MemRegion>* open_heap_regions,\n+                                   GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n+                                   GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps) {\n+  \/\/ Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with\n+  \/\/ MetaspaceShared::n_regions (internal to hotspot).\n+  assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, \"sanity\");\n+\n+  \/\/ mc contains the trampoline code for method entries, which are patched at run time,\n+  \/\/ so it needs to be read\/write.\n+  write_region(mapinfo, MetaspaceShared::mc, &_mc_region, \/*read_only=*\/false,\/*allow_exec=*\/true);\n+  write_region(mapinfo, MetaspaceShared::rw, &_rw_region, \/*read_only=*\/false,\/*allow_exec=*\/false);\n+  write_region(mapinfo, MetaspaceShared::ro, &_ro_region, \/*read_only=*\/true, \/*allow_exec=*\/false);\n+\n+  size_t bitmap_size_in_bytes;\n+  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_oopmaps, open_heap_oopmaps,\n+                                              bitmap_size_in_bytes);\n+\n+  if (closed_heap_regions != NULL) {\n+    _total_closed_heap_region_size = mapinfo->write_archive_heap_regions(\n+                                        closed_heap_regions,\n+                                        closed_heap_oopmaps,\n+                                        MetaspaceShared::first_closed_archive_heap_region,\n+                                        MetaspaceShared::max_closed_archive_heap_region);\n+    _total_open_heap_region_size = mapinfo->write_archive_heap_regions(\n+                                        open_heap_regions,\n+                                        open_heap_oopmaps,\n+                                        MetaspaceShared::first_open_archive_heap_region,\n+                                        MetaspaceShared::max_open_archive_heap_region);\n+  }\n+\n+  print_region_stats(mapinfo, closed_heap_regions, open_heap_regions);\n+\n+  mapinfo->set_requested_base((char*)MetaspaceShared::requested_base_address());\n+  mapinfo->set_header_crc(mapinfo->compute_header_crc());\n+  mapinfo->write_header();\n+  mapinfo->close();\n+\n+  if (log_is_enabled(Info, cds)) {\n+    print_stats();\n+  }\n+\n+  if (log_is_enabled(Info, cds, map)) {\n+    CDSMapLogger::write(this, mapinfo, closed_heap_regions, open_heap_regions,\n+                        bitmap, bitmap_size_in_bytes);\n+  }\n+  FREE_C_HEAP_ARRAY(char, bitmap);\n+}\n+\n+void ArchiveBuilder::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {\n+  mapinfo->write_region(region_idx, dump_region->base(), dump_region->used(), read_only, allow_exec);\n+}\n+\n+void ArchiveBuilder::print_region_stats(FileMapInfo *mapinfo,\n+                                        GrowableArray<MemRegion>* closed_heap_regions,\n+                                        GrowableArray<MemRegion>* open_heap_regions) {\n+  \/\/ Print statistics of all the regions\n+  const size_t bitmap_used = mapinfo->space_at(MetaspaceShared::bm)->used();\n+  const size_t bitmap_reserved = mapinfo->space_at(MetaspaceShared::bm)->used_aligned();\n+  const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +\n+                                _mc_region.reserved()  +\n+                                bitmap_reserved +\n+                                _total_closed_heap_region_size +\n+                                _total_open_heap_region_size;\n+  const size_t total_bytes = _ro_region.used()  + _rw_region.used() +\n+                             _mc_region.used()  +\n+                             bitmap_used +\n+                             _total_closed_heap_region_size +\n+                             _total_open_heap_region_size;\n+  const double total_u_perc = percent_of(total_bytes, total_reserved);\n+\n+  _mc_region.print(total_reserved);\n+  _rw_region.print(total_reserved);\n+  _ro_region.print(total_reserved);\n+\n+  print_bitmap_region_stats(bitmap_used, total_reserved);\n+\n+  if (closed_heap_regions != NULL) {\n+    print_heap_region_stats(closed_heap_regions, \"ca\", total_reserved);\n+    print_heap_region_stats(open_heap_regions, \"oa\", total_reserved);\n+  }\n+\n+  log_debug(cds)(\"total    : \" SIZE_FORMAT_W(9) \" [100.0%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used]\",\n+                 total_bytes, total_reserved, total_u_perc);\n+}\n+\n+void ArchiveBuilder::print_bitmap_region_stats(size_t size, size_t total_size) {\n+  log_debug(cds)(\"bm  space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used]\",\n+                 size, size\/double(total_size)*100.0, size);\n+}\n+\n+void ArchiveBuilder::print_heap_region_stats(GrowableArray<MemRegion> *heap_mem,\n+                                             const char *name, size_t total_size) {\n+  int arr_len = heap_mem == NULL ? 0 : heap_mem->length();\n+  for (int i = 0; i < arr_len; i++) {\n+      char* start = (char*)heap_mem->at(i).start();\n+      size_t size = heap_mem->at(i).byte_size();\n+      char* top = start + size;\n+      log_debug(cds)(\"%s%d space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used] at \" INTPTR_FORMAT,\n+                     name, i, size, size\/double(total_size)*100.0, size, p2i(start));\n+  }\n+}\n+\n+void ArchiveBuilder::report_out_of_space(const char* name, size_t needed_bytes) {\n+  \/\/ This is highly unlikely to happen on 64-bits because we have reserved a 4GB space.\n+  \/\/ On 32-bit we reserve only 256MB so you could run out of space with 100,000 classes\n+  \/\/ or so.\n+  _mc_region.print_out_of_space_msg(name, needed_bytes);\n+  _rw_region.print_out_of_space_msg(name, needed_bytes);\n+  _ro_region.print_out_of_space_msg(name, needed_bytes);\n+\n+  vm_exit_during_initialization(err_msg(\"Unable to allocate from '%s' region\", name),\n+                                \"Please reduce the number of shared classes.\");\n+}\n+\n+\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":234,"deletions":57,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/dumpAllocStats.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"oops\/array.hpp\"\n@@ -37,0 +39,1 @@\n+struct ArchiveHeapOopmapInfo;\n@@ -38,1 +41,0 @@\n-class DumpAllocStats;\n@@ -44,0 +46,4 @@\n+\/\/ Metaspace::allocate() requires that all blocks must be aligned with KlassAlignmentInBytes.\n+\/\/ We enforce the same alignment rule in blocks allocated from the shared space.\n+const int SharedSpaceObjectAlignment = KlassAlignmentInBytes;\n+\n@@ -189,3 +195,6 @@\n-  DumpRegion* _mc_region;\n-  DumpRegion* _rw_region;\n-  DumpRegion* _ro_region;\n+  ReservedSpace _shared_rs;\n+  VirtualSpace _shared_vs;\n+\n+  DumpRegion _mc_region;\n+  DumpRegion _rw_region;\n+  DumpRegion _ro_region;\n@@ -205,1 +214,10 @@\n-  DumpAllocStats* _alloc_stats;\n+  DumpAllocStats _alloc_stats;\n+  size_t _total_closed_heap_region_size;\n+  size_t _total_open_heap_region_size;\n+\n+  void print_region_stats(FileMapInfo *map_info,\n+                          GrowableArray<MemRegion>* closed_heap_regions,\n+                          GrowableArray<MemRegion>* open_heap_regions);\n+  void print_bitmap_region_stats(size_t size, size_t total_size);\n+  void print_heap_region_stats(GrowableArray<MemRegion> *heap_mem,\n+                               const char *name, size_t total_size);\n@@ -218,1 +236,1 @@\n-      _oldtop = _current->_ro_region->top();\n+      _oldtop = _current->_ro_region.top();\n@@ -224,0 +242,1 @@\n+  bool is_dumping_full_module_graph();\n@@ -257,0 +276,3 @@\n+  void start_dump_space(DumpRegion* next);\n+  void verify_estimate_size(size_t estimate, const char* which);\n+\n@@ -258,1 +280,0 @@\n-  void set_current_dump_space(DumpRegion* r) { _current_dump_space = r; }\n@@ -320,1 +341,1 @@\n-  ArchiveBuilder(DumpRegion* mc_region, DumpRegion* rw_region, DumpRegion* ro_region);\n+  ArchiveBuilder();\n@@ -330,0 +351,37 @@\n+  DumpRegion* mc_region() { return &_mc_region; }\n+  DumpRegion* rw_region() { return &_rw_region; }\n+  DumpRegion* ro_region() { return &_ro_region; }\n+\n+  static char* mc_region_alloc(size_t num_bytes) {\n+    return current()->mc_region()->allocate(num_bytes);\n+  }\n+  static char* rw_region_alloc(size_t num_bytes) {\n+    return current()->rw_region()->allocate(num_bytes);\n+  }\n+  static char* ro_region_alloc(size_t num_bytes) {\n+    return current()->ro_region()->allocate(num_bytes);\n+  }\n+\n+  template <typename T>\n+  static Array<T>* new_ro_array(int length) {\n+    size_t byte_size = Array<T>::byte_sizeof(length, sizeof(T));\n+    Array<T>* array = (Array<T>*)ro_region_alloc(byte_size);\n+    array->initialize(length);\n+    return array;\n+  }\n+\n+  template <typename T>\n+  static Array<T>* new_rw_array(int length) {\n+    size_t byte_size = Array<T>::byte_sizeof(length, sizeof(T));\n+    Array<T>* array = (Array<T>*)rw_region_alloc(byte_size);\n+    array->initialize(length);\n+    return array;\n+  }\n+\n+  template <typename T>\n+  static size_t ro_array_bytesize(int length) {\n+    size_t byte_size = Array<T>::byte_sizeof(length, sizeof(T));\n+    return align_up(byte_size, SharedSpaceObjectAlignment);\n+  }\n+\n+  void init_mc_region();\n@@ -337,4 +395,7 @@\n-  void write_cds_map_to_log(FileMapInfo* mapinfo,\n-                            GrowableArray<MemRegion> *closed_heap_regions,\n-                            GrowableArray<MemRegion> *open_heap_regions,\n-                            char* bitmap, size_t bitmap_size_in_bytes);\n+  void write_archive(FileMapInfo* mapinfo,\n+                     GrowableArray<MemRegion>* closed_heap_regions,\n+                     GrowableArray<MemRegion>* open_heap_regions,\n+                     GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n+                     GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps);\n+  void write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region,\n+                    bool read_only,  bool allow_exec);\n@@ -359,1 +420,9 @@\n-    return current()->_alloc_stats;\n+    return &(current()->_alloc_stats);\n+  }\n+\n+  static CompactHashtableStats* symbol_stats() {\n+    return alloc_stats()->symbol_stats();\n+  }\n+\n+  static CompactHashtableStats* string_stats() {\n+    return alloc_stats()->string_stats();\n@@ -374,1 +443,2 @@\n-  void print_stats(int ro_all, int rw_all, int mc_all);\n+  void print_stats();\n+  void report_out_of_space(const char* name, size_t needed_bytes);\n@@ -377,0 +447,1 @@\n+  size_t collect_method_trampolines();\n@@ -379,1 +450,0 @@\n-  size_t allocate_method_trampoline_info();\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":85,"deletions":15,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-address* ArchivePtrMarker::_ptr_base;\n-address* ArchivePtrMarker::_ptr_end;\n+VirtualSpace* ArchivePtrMarker::_vs;\n+\n@@ -47,1 +47,1 @@\n-void ArchivePtrMarker::initialize(CHeapBitMap* ptrmap, address* ptr_base, address* ptr_end) {\n+void ArchivePtrMarker::initialize(CHeapBitMap* ptrmap, VirtualSpace* vs) {\n@@ -49,2 +49,1 @@\n-  _ptr_base = ptr_base;\n-  _ptr_end = ptr_end;\n+  _vs = vs;\n@@ -69,1 +68,1 @@\n-  if (_ptr_base <= ptr_loc && ptr_loc < _ptr_end) {\n+  if (ptr_base() <= ptr_loc && ptr_loc < ptr_end()) {\n@@ -75,1 +74,1 @@\n-    assert(value != (address)_ptr_base, \"don't point to the bottom of the archive\");\n+    assert(value != (address)ptr_base(), \"don't point to the bottom of the archive\");\n@@ -79,1 +78,1 @@\n-      size_t idx = ptr_loc - _ptr_base;\n+      size_t idx = ptr_loc - ptr_base();\n@@ -94,1 +93,1 @@\n-  assert(_ptr_base <= ptr_loc && ptr_loc < _ptr_end, \"must be\");\n+  assert(ptr_base() <= ptr_loc && ptr_loc < ptr_end(), \"must be\");\n@@ -96,1 +95,1 @@\n-  size_t idx = ptr_loc - _ptr_base;\n+  size_t idx = ptr_loc - ptr_base();\n@@ -135,1 +134,1 @@\n-  ArchivePtrBitmapCleaner cleaner(_ptrmap, _ptr_base, relocatable_base, relocatable_end);\n+  ArchivePtrBitmapCleaner cleaner(_ptrmap, ptr_base(), relocatable_base, relocatable_end);\n@@ -150,1 +149,1 @@\n-    MetaspaceShared::report_out_of_space(_name, newtop - _top);\n+    ArchiveBuilder::current()->report_out_of_space(_name, newtop - _top);\n@@ -154,1 +153,1 @@\n-  MetaspaceShared::commit_to(_rs, _vs, newtop);\n+  commit_to(newtop);\n@@ -157,1 +156,1 @@\n-  if (_rs == MetaspaceShared::shared_rs()) {\n+  if (_max_delta > 0) {\n@@ -159,1 +158,1 @@\n-    if (delta > ArchiveBuilder::MAX_SHARED_DELTA) {\n+    if (delta > _max_delta) {\n@@ -171,0 +170,33 @@\n+void DumpRegion::commit_to(char* newtop) {\n+  Arguments::assert_is_dumping_archive();\n+  char* base = _rs->base();\n+  size_t need_committed_size = newtop - base;\n+  size_t has_committed_size = _vs->committed_size();\n+  if (need_committed_size < has_committed_size) {\n+    return;\n+  }\n+\n+  size_t min_bytes = need_committed_size - has_committed_size;\n+  size_t preferred_bytes = 1 * M;\n+  size_t uncommitted = _vs->reserved_size() - has_committed_size;\n+\n+  size_t commit = MAX2(min_bytes, preferred_bytes);\n+  commit = MIN2(commit, uncommitted);\n+  assert(commit <= uncommitted, \"sanity\");\n+\n+  if (!_vs->expand_by(commit, false)) {\n+    vm_exit_during_initialization(err_msg(\"Failed to expand shared space to \" SIZE_FORMAT \" bytes\",\n+                                          need_committed_size));\n+  }\n+\n+  const char* which;\n+  if (_rs->base() == (char*)MetaspaceShared::symbol_rs_base()) {\n+    which = \"symbol\";\n+  } else {\n+    which = \"shared\";\n+  }\n+  log_debug(cds)(\"Expanding %s spaces by \" SIZE_FORMAT_W(7) \" bytes [total \" SIZE_FORMAT_W(9)  \" bytes ending at %p]\",\n+                 which, commit, _vs->actual_committed_size(), _vs->high());\n+}\n+\n+\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.cpp","additions":47,"deletions":15,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/virtualspace.hpp\"\n@@ -42,3 +43,2 @@\n-  static CHeapBitMap* _ptrmap;\n-  static address*     _ptr_base;\n-  static address*     _ptr_end;\n+  static CHeapBitMap*  _ptrmap;\n+  static VirtualSpace* _vs;\n@@ -49,0 +49,4 @@\n+\n+  static address* ptr_base() { return (address*)_vs->low();  } \/\/ committed lower bound (inclusive)\n+  static address* ptr_end()  { return (address*)_vs->high(); } \/\/ committed upper bound (exclusive)\n+\n@@ -50,1 +54,1 @@\n-  static void initialize(CHeapBitMap* ptrmap, address* ptr_base, address* ptr_end);\n+  static void initialize(CHeapBitMap* ptrmap, VirtualSpace* vs);\n@@ -67,5 +71,0 @@\n-  static void expand_ptr_end(address *new_ptr_end) {\n-    assert(_ptr_end <= new_ptr_end, \"must be\");\n-    _ptr_end = new_ptr_end;\n-  }\n-\n@@ -131,0 +130,1 @@\n+  uintx _max_delta;\n@@ -135,0 +135,2 @@\n+  void commit_to(char* newtop);\n+\n@@ -136,1 +138,3 @@\n-  DumpRegion(const char* name) : _name(name), _base(NULL), _top(NULL), _end(NULL), _is_packed(false) {}\n+  DumpRegion(const char* name, uintx max_delta = 0)\n+    : _name(name), _base(NULL), _top(NULL), _end(NULL),\n+      _max_delta(max_delta), _is_packed(false) {}\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.hpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"memory\/archiveBuilder.hpp\"\n@@ -103,1 +104,1 @@\n-      (CppVtableInfo*)MetaspaceShared::misc_code_dump_space()->allocate(CppVtableInfo::byte_size(n));\n+      (CppVtableInfo*)ArchiveBuilder::current()->mc_region()->allocate(CppVtableInfo::byte_size(n));\n@@ -217,1 +218,1 @@\n-  _index = (CppVtableInfo**)MetaspaceShared::misc_code_dump_space()->allocate(vtptrs_bytes);\n+  _index = (CppVtableInfo**)ArchiveBuilder::current()->mc_region()->allocate(vtptrs_bytes);\n","filename":"src\/hotspot\/share\/memory\/cppVtables.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n@@ -32,3 +31,0 @@\n-  \/\/ Calculate size of data that was not allocated by Metaspace::allocate()\n-  MetaspaceSharedStats *stats = MetaspaceShared::stats();\n-\n@@ -36,2 +32,2 @@\n-  _counts[RO][SymbolHashentryType] = stats->symbol.hashentry_count;\n-  _bytes [RO][SymbolHashentryType] = stats->symbol.hashentry_bytes;\n+  _counts[RO][SymbolHashentryType] = _symbol_stats.hashentry_count;\n+  _bytes [RO][SymbolHashentryType] = _symbol_stats.hashentry_bytes;\n@@ -39,2 +35,2 @@\n-  _counts[RO][SymbolBucketType] = stats->symbol.bucket_count;\n-  _bytes [RO][SymbolBucketType] = stats->symbol.bucket_bytes;\n+  _counts[RO][SymbolBucketType] = _symbol_stats.bucket_count;\n+  _bytes [RO][SymbolBucketType] = _symbol_stats.bucket_bytes;\n@@ -43,2 +39,2 @@\n-  _counts[RO][StringHashentryType] = stats->string.hashentry_count;\n-  _bytes [RO][StringHashentryType] = stats->string.hashentry_bytes;\n+  _counts[RO][StringHashentryType] = _string_stats.hashentry_count;\n+  _bytes [RO][StringHashentryType] = _string_stats.hashentry_bytes;\n@@ -46,2 +42,2 @@\n-  _counts[RO][StringBucketType] = stats->string.bucket_count;\n-  _bytes [RO][StringBucketType] = stats->string.bucket_bytes;\n+  _counts[RO][StringBucketType] = _string_stats.bucket_count;\n+  _bytes [RO][StringBucketType] = _string_stats.bucket_bytes;\n@@ -73,1 +69,1 @@\n-  msg.debug(\"Detailed metadata info (excluding st regions; rw stats include mc regions):\");\n+  msg.debug(\"Detailed metadata info (excluding heap regions; rw stats include mc regions):\");\n","filename":"src\/hotspot\/share\/memory\/dumpAllocStats.cpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/compactHashtable.hpp\"\n@@ -60,2 +61,2 @@\n-public:\n-  enum { RO = 0, RW = 1 };\n+  CompactHashtableStats _symbol_stats;\n+  CompactHashtableStats _string_stats;\n@@ -66,0 +67,3 @@\n+public:\n+  enum { RO = 0, RW = 1 };\n+\n@@ -71,0 +75,3 @@\n+  CompactHashtableStats* symbol_stats() { return &_symbol_stats; }\n+  CompactHashtableStats* string_stats() { return &_string_stats; }\n+\n","filename":"src\/hotspot\/share\/memory\/dumpAllocStats.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -95,29 +95,1 @@\n-  DynamicArchiveBuilder() : ArchiveBuilder(MetaspaceShared::misc_code_dump_space(),\n-                                           MetaspaceShared::read_write_dump_space(),\n-                                           MetaspaceShared::read_only_dump_space()) {\n-  }\n-\n-  void start_dump_space(DumpRegion* next) {\n-    address bottom = _last_verified_top;\n-    address top = (address)(current_dump_space()->top());\n-    _other_region_used_bytes += size_t(top - bottom);\n-\n-    MetaspaceShared::pack_dump_space(current_dump_space(), next, MetaspaceShared::shared_rs());\n-    _current_dump_space = next;\n-    _num_dump_regions_used ++;\n-\n-    _last_verified_top = (address)(current_dump_space()->top());\n-  }\n-\n-  void verify_estimate_size(size_t estimate, const char* which) {\n-    address bottom = _last_verified_top;\n-    address top = (address)(current_dump_space()->top());\n-    size_t used = size_t(top - bottom) + _other_region_used_bytes;\n-    int diff = int(estimate) - int(used);\n-\n-    log_info(cds)(\"%s estimate = \" SIZE_FORMAT \" used = \" SIZE_FORMAT \"; diff = %d bytes\", which, estimate, used, diff);\n-    assert(diff >= 0, \"Estimate is too small\");\n-\n-    _last_verified_top = top;\n-    _other_region_used_bytes = 0;\n-  }\n+  DynamicArchiveBuilder() : ArchiveBuilder() { }\n@@ -143,4 +115,0 @@\n-    gather_klasses_and_symbols();\n-\n-    \/\/ mc space starts ...\n-    reserve_buffer();\n@@ -148,0 +116,2 @@\n+    gather_source_objs();\n+    reserve_buffer();\n@@ -149,1 +119,1 @@\n-    allocate_method_trampolines();\n+    init_mc_region();\n@@ -152,4 +122,0 @@\n-    gather_source_objs();\n-    \/\/ rw space starts ...\n-    start_dump_space(MetaspaceShared::read_write_dump_space());\n-\n@@ -158,1 +124,0 @@\n-\n@@ -160,4 +125,0 @@\n-\n-    \/\/ ro space starts ...\n-    DumpRegion* ro_space = MetaspaceShared::read_only_dump_space();\n-    start_dump_space(ro_space);\n@@ -176,1 +137,1 @@\n-      assert(current_dump_space() == ro_space, \"Must be RO space\");\n+      assert(current_dump_space() == ro_region(), \"Must be RO space\");\n@@ -178,0 +139,2 @@\n+\n+      ArchiveBuilder::OtherROAllocMark mark;\n@@ -180,2 +143,2 @@\n-      serialized_data = ro_space->top();\n-      WriteClosure wc(ro_space);\n+      serialized_data = ro_region()->top();\n+      WriteClosure wc(ro_region());\n@@ -336,3 +299,0 @@\n-  int num_klasses = klasses()->length();\n-  int num_symbols = symbols()->length();\n-\n@@ -347,13 +307,2 @@\n-  \/\/ Now write the archived data including the file offsets.\n-  const char* archive_name = Arguments::GetSharedDynamicArchivePath();\n-  dynamic_info->open_for_write(archive_name);\n-  size_t bitmap_size_in_bytes;\n-  char* bitmap = MetaspaceShared::write_core_archive_regions(dynamic_info, NULL, NULL, bitmap_size_in_bytes);\n-  dynamic_info->set_requested_base((char*)MetaspaceShared::requested_base_address());\n-  dynamic_info->set_header_crc(dynamic_info->compute_header_crc());\n-  dynamic_info->write_header();\n-  dynamic_info->close();\n-\n-  write_cds_map_to_log(dynamic_info, NULL, NULL,\n-                       bitmap, bitmap_size_in_bytes);\n-  FREE_C_HEAP_ARRAY(char, bitmap);\n+  dynamic_info->open_for_write(Arguments::GetSharedDynamicArchivePath());\n+  ArchiveBuilder::write_archive(dynamic_info, NULL, NULL, NULL, NULL);\n@@ -369,1 +318,1 @@\n-  log_info(cds, dynamic)(\"%d klasses; %d symbols\", num_klasses, num_symbols);\n+  log_info(cds, dynamic)(\"%d klasses; %d symbols\", klasses()->length(), symbols()->length());\n@@ -373,1 +322,1 @@\n-  DynamicArchiveBuilder* _builder;\n+  DynamicArchiveBuilder builder;\n@@ -375,1 +324,1 @@\n-  VM_PopulateDynamicDumpSharedSpace(DynamicArchiveBuilder* builder) : VM_GC_Sync_Operation(), _builder(builder) {}\n+  VM_PopulateDynamicDumpSharedSpace() : VM_GC_Sync_Operation() {}\n@@ -389,1 +338,1 @@\n-    _builder->doit();\n+    builder.doit();\n@@ -400,2 +349,1 @@\n-  DynamicArchiveBuilder builder;\n-  VM_PopulateDynamicDumpSharedSpace op(&builder);\n+  VM_PopulateDynamicDumpSharedSpace op;\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":16,"deletions":68,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-  GrowableArray<Klass*>* klasses = MetaspaceShared::collected_klasses();\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n@@ -576,1 +576,1 @@\n-      MetaspaceShared::new_ro_array<int>(num_entry_fields);\n+      ArchiveBuilder::new_ro_array<int>(num_entry_fields);\n@@ -587,1 +587,1 @@\n-      MetaspaceShared::new_ro_array<Klass*>(num_subgraphs_klasses);\n+      ArchiveBuilder::new_ro_array<Klass*>(num_subgraphs_klasses);\n@@ -613,1 +613,1 @@\n-        (ArchivedKlassSubGraphInfoRecord*)MetaspaceShared::read_only_space_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));\n+        (ArchivedKlassSubGraphInfoRecord*)ArchiveBuilder::ro_region_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/printMetaspaceInfoKlassClosure.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"interpreter\/abstractInterpreter.hpp\"\n@@ -49,1 +48,0 @@\n-#include \"memory\/archiveUtils.inline.hpp\"\n@@ -52,1 +50,0 @@\n-#include \"memory\/dynamicArchive.hpp\"\n@@ -54,1 +51,1 @@\n-#include \"memory\/heapShared.inline.hpp\"\n+#include \"memory\/heapShared.hpp\"\n@@ -78,1 +75,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -83,2 +79,0 @@\n-ReservedSpace MetaspaceShared::_shared_rs;\n-VirtualSpace MetaspaceShared::_shared_vs;\n@@ -87,1 +81,0 @@\n-MetaspaceSharedStats MetaspaceShared::_stats;\n@@ -108,3 +101,4 @@\n-\/\/ The mc, rw, and ro regions are linearly allocated, starting from\n-\/\/ SharedBaseAddress, in the order of mc->rw->ro. The size of these 3 regions\n-\/\/ are page-aligned, and there's no gap between any consecutive regions.\n+\/\/     bm  - bitmap for relocating the above 7 regions.\n+\/\/\n+\/\/ The mc, rw, and ro regions are linearly allocated, in the order of mc->rw->ro.\n+\/\/ These regions are aligned with MetaspaceShared::reserved_space_alignment().\n@@ -113,4 +107,4 @@\n-\/\/ [1] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are\n-\/\/     temporarily allocated outside of the shared regions. Only the method entry\n-\/\/     trampolines are written into the mc region.\n-\/\/ [2] C++ vtables are copied into the mc region.\n+\/\/ [0] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are\n+\/\/     temporarily allocated outside of the shared regions.\n+\/\/ [1] We enter a safepoint and allocate a buffer for the mc\/rw\/ro regions.\n+\/\/ [2] C++ vtables and method trampolines are copied into the mc region.\n@@ -122,5 +116,2 @@\n-\/\/ The s0\/s1 and oa0\/oa1 regions are populated inside HeapShared::archive_java_heap_objects.\n-\/\/ Their layout is independent of the other 4 regions.\n-\n-static DumpRegion _mc_region(\"mc\"), _ro_region(\"ro\"), _rw_region(\"rw\"), _symbol_region(\"symbols\");\n-static size_t _total_closed_archive_region_size = 0, _total_open_archive_region_size = 0;\n+\/\/ The ca0\/ca1 and oa0\/oa1 regions are populated inside HeapShared::archive_java_heap_objects.\n+\/\/ Their layout is independent of the mc\/rw\/ro regions.\n@@ -128,20 +119,1 @@\n-void MetaspaceShared::init_shared_dump_space(DumpRegion* first_space) {\n-  first_space->init(&_shared_rs, &_shared_vs);\n-}\n-\n-DumpRegion* MetaspaceShared::misc_code_dump_space() {\n-  return &_mc_region;\n-}\n-\n-DumpRegion* MetaspaceShared::read_write_dump_space() {\n-  return &_rw_region;\n-}\n-\n-DumpRegion* MetaspaceShared::read_only_dump_space() {\n-  return &_ro_region;\n-}\n-\n-void MetaspaceShared::pack_dump_space(DumpRegion* current, DumpRegion* next,\n-                                      ReservedSpace* rs) {\n-  current->pack(next);\n-}\n+static DumpRegion _symbol_region(\"symbols\");\n@@ -153,12 +125,0 @@\n-char* MetaspaceShared::misc_code_space_alloc(size_t num_bytes) {\n-  return _mc_region.allocate(num_bytes);\n-}\n-\n-char* MetaspaceShared::read_only_space_alloc(size_t num_bytes) {\n-  return _ro_region.allocate(num_bytes);\n-}\n-\n-char* MetaspaceShared::read_write_space_alloc(size_t num_bytes) {\n-  return _rw_region.allocate(num_bytes);\n-}\n-\n@@ -319,33 +279,0 @@\n-void MetaspaceShared::commit_to(ReservedSpace* rs, VirtualSpace* vs, char* newtop) {\n-  Arguments::assert_is_dumping_archive();\n-  char* base = rs->base();\n-  size_t need_committed_size = newtop - base;\n-  size_t has_committed_size = vs->committed_size();\n-  if (need_committed_size < has_committed_size) {\n-    return;\n-  }\n-\n-  size_t min_bytes = need_committed_size - has_committed_size;\n-  size_t preferred_bytes = 1 * M;\n-  size_t uncommitted = vs->reserved_size() - has_committed_size;\n-\n-  size_t commit =MAX2(min_bytes, preferred_bytes);\n-  commit = MIN2(commit, uncommitted);\n-  assert(commit <= uncommitted, \"sanity\");\n-\n-  bool result = vs->expand_by(commit, false);\n-  if (rs == &_shared_rs) {\n-    ArchivePtrMarker::expand_ptr_end((address*)vs->high());\n-  }\n-\n-  if (!result) {\n-    vm_exit_during_initialization(err_msg(\"Failed to expand shared space to \" SIZE_FORMAT \" bytes\",\n-                                          need_committed_size));\n-  }\n-\n-  assert(rs == &_shared_rs || rs == &_symbol_rs, \"must be\");\n-  const char* which = (rs == &_shared_rs) ? \"shared\" : \"symbol\";\n-  log_debug(cds)(\"Expanding %s spaces by \" SIZE_FORMAT_W(7) \" bytes [total \" SIZE_FORMAT_W(9)  \" bytes ending at %p]\",\n-                 which, commit, vs->actual_committed_size(), vs->high());\n-}\n-\n@@ -398,8 +325,4 @@\n-void MetaspaceShared::init_misc_code_space() {\n-  \/\/ We don't want any valid object to be at the very bottom of the archive.\n-  \/\/ See ArchivePtrMarker::mark_pointer().\n-  MetaspaceShared::misc_code_space_alloc(16);\n-\n-  size_t trampoline_size = SharedRuntime::trampoline_size();\n-  size_t buf_size = (size_t)AbstractInterpreter::number_of_method_entries * trampoline_size;\n-  _i2i_entry_code_buffers = (address)misc_code_space_alloc(buf_size);\n+void MetaspaceShared::set_i2i_entry_code_buffers(address b) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  assert(_i2i_entry_code_buffers == NULL, \"initialize only once\");\n+  _i2i_entry_code_buffers = b;\n@@ -414,8 +337,0 @@\n-\/\/ Global object for holding classes that have been loaded.  Since this\n-\/\/ is run at a safepoint just before exit, this is the entire set of classes.\n-static GrowableArray<Klass*>* _global_klass_objects;\n-\n-GrowableArray<Klass*>* MetaspaceShared::collected_klasses() {\n-  return _global_klass_objects;\n-}\n-\n@@ -462,1 +377,1 @@\n-  void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;\n+  void dump_java_heap_objects(GrowableArray<Klass*>* klasses) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -471,4 +386,0 @@\n-  void print_region_stats(FileMapInfo* map_info);\n-  void print_bitmap_region_stats(size_t size, size_t total_size);\n-  void print_heap_region_stats(GrowableArray<MemRegion> *heap_mem,\n-                               const char *name, size_t total_size);\n@@ -491,2 +402,1 @@\n-  StaticArchiveBuilder(DumpRegion* mc_region, DumpRegion* rw_region, DumpRegion* ro_region)\n-    : ArchiveBuilder(mc_region, rw_region, ro_region) {}\n+  StaticArchiveBuilder() : ArchiveBuilder() {}\n@@ -519,2 +429,3 @@\n-  char* start = _ro_region.top();\n-  WriteClosure wc(&_ro_region);\n+  DumpRegion* ro_region = ArchiveBuilder::current()->ro_region();\n+  char* start = ro_region->top();\n+  WriteClosure wc(ro_region);\n@@ -560,5 +471,1 @@\n-  StaticArchiveBuilder builder(&_mc_region, &_rw_region, &_ro_region);\n-  builder.gather_klasses_and_symbols();\n-  builder.reserve_buffer();\n-  _global_klass_objects = builder.klasses();\n-\n+  StaticArchiveBuilder builder;\n@@ -566,0 +473,1 @@\n+  builder.reserve_buffer();\n@@ -567,4 +475,1 @@\n-  MetaspaceShared::init_misc_code_space();\n-  builder.allocate_method_trampoline_info();\n-  builder.allocate_method_trampolines();\n-\n+  builder.init_mc_region();\n@@ -573,25 +478,2 @@\n-  {\n-    _mc_region.pack(&_rw_region);\n-    builder.set_current_dump_space(&_rw_region);\n-    builder.dump_rw_region();\n-#if INCLUDE_CDS_JAVA_HEAP\n-    if (MetaspaceShared::use_full_module_graph()) {\n-      \/\/ Archive the ModuleEntry's and PackageEntry's of the 3 built-in loaders\n-      char* start = _rw_region.top();\n-      ClassLoaderDataShared::allocate_archived_tables();\n-      ArchiveBuilder::alloc_stats()->record_modules(_rw_region.top() - start, \/*read_only*\/false);\n-    }\n-#endif\n-  }\n-  {\n-    _rw_region.pack(&_ro_region);\n-    builder.set_current_dump_space(&_ro_region);\n-    builder.dump_ro_region();\n-#if INCLUDE_CDS_JAVA_HEAP\n-    if (MetaspaceShared::use_full_module_graph()) {\n-      char* start = _ro_region.top();\n-      ClassLoaderDataShared::init_archived_tables();\n-      ArchiveBuilder::alloc_stats()->record_modules(_ro_region.top() - start, \/*read_only*\/true);\n-    }\n-#endif\n-  }\n+  builder.dump_rw_region();\n+  builder.dump_ro_region();\n@@ -603,1 +485,1 @@\n-  dump_java_heap_objects();\n+  dump_java_heap_objects(builder.klasses());\n@@ -617,1 +499,0 @@\n-  _ro_region.pack();\n@@ -629,2 +510,1 @@\n-  \/\/ Create and write the archive file that maps the shared spaces.\n-\n+  \/\/ Write the archive file\n@@ -637,28 +517,5 @@\n-  size_t bitmap_size_in_bytes;\n-  char* bitmap = MetaspaceShared::write_core_archive_regions(mapinfo, _closed_archive_heap_oopmaps,\n-                                                             _open_archive_heap_oopmaps,\n-                                                             bitmap_size_in_bytes);\n-  _total_closed_archive_region_size = mapinfo->write_archive_heap_regions(\n-                                        _closed_archive_heap_regions,\n-                                        _closed_archive_heap_oopmaps,\n-                                        MetaspaceShared::first_closed_archive_heap_region,\n-                                        MetaspaceShared::max_closed_archive_heap_region);\n-  _total_open_archive_region_size = mapinfo->write_archive_heap_regions(\n-                                        _open_archive_heap_regions,\n-                                        _open_archive_heap_oopmaps,\n-                                        MetaspaceShared::first_open_archive_heap_region,\n-                                        MetaspaceShared::max_open_archive_heap_region);\n-\n-  mapinfo->set_requested_base((char*)MetaspaceShared::requested_base_address());\n-  mapinfo->set_header_crc(mapinfo->compute_header_crc());\n-  mapinfo->write_header();\n-  print_region_stats(mapinfo);\n-  mapinfo->close();\n-\n-  builder.write_cds_map_to_log(mapinfo, _closed_archive_heap_regions, _open_archive_heap_regions,\n-                               bitmap, bitmap_size_in_bytes);\n-  FREE_C_HEAP_ARRAY(char, bitmap);\n-\n-  if (log_is_enabled(Info, cds)) {\n-    builder.print_stats(int(_ro_region.used()), int(_rw_region.used()), int(_mc_region.used()));\n-  }\n+  builder.write_archive(mapinfo,\n+                        _closed_archive_heap_regions,\n+                        _open_archive_heap_regions,\n+                        _closed_archive_heap_oopmaps,\n+                        _open_archive_heap_oopmaps);\n@@ -681,67 +538,0 @@\n-void VM_PopulateDumpSharedSpace::print_region_stats(FileMapInfo *map_info) {\n-  \/\/ Print statistics of all the regions\n-  const size_t bitmap_used = map_info->space_at(MetaspaceShared::bm)->used();\n-  const size_t bitmap_reserved = map_info->space_at(MetaspaceShared::bm)->used_aligned();\n-  const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +\n-                                _mc_region.reserved()  +\n-                                bitmap_reserved +\n-                                _total_closed_archive_region_size +\n-                                _total_open_archive_region_size;\n-  const size_t total_bytes = _ro_region.used()  + _rw_region.used() +\n-                             _mc_region.used()  +\n-                             bitmap_used +\n-                             _total_closed_archive_region_size +\n-                             _total_open_archive_region_size;\n-  const double total_u_perc = percent_of(total_bytes, total_reserved);\n-\n-  _mc_region.print(total_reserved);\n-  _rw_region.print(total_reserved);\n-  _ro_region.print(total_reserved);\n-  print_bitmap_region_stats(bitmap_used, total_reserved);\n-  print_heap_region_stats(_closed_archive_heap_regions, \"ca\", total_reserved);\n-  print_heap_region_stats(_open_archive_heap_regions, \"oa\", total_reserved);\n-\n-  log_debug(cds)(\"total    : \" SIZE_FORMAT_W(9) \" [100.0%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [%5.1f%% used]\",\n-                 total_bytes, total_reserved, total_u_perc);\n-}\n-\n-void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {\n-  log_debug(cds)(\"bm  space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used]\",\n-                 size, size\/double(total_size)*100.0, size);\n-}\n-\n-void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray<MemRegion> *heap_mem,\n-                                                         const char *name, size_t total_size) {\n-  int arr_len = heap_mem == NULL ? 0 : heap_mem->length();\n-  for (int i = 0; i < arr_len; i++) {\n-      char* start = (char*)heap_mem->at(i).start();\n-      size_t size = heap_mem->at(i).byte_size();\n-      char* top = start + size;\n-      log_debug(cds)(\"%s%d space: \" SIZE_FORMAT_W(9) \" [ %4.1f%% of total] out of \" SIZE_FORMAT_W(9) \" bytes [100.0%% used] at \" INTPTR_FORMAT,\n-                     name, i, size, size\/double(total_size)*100.0, size, p2i(start));\n-\n-  }\n-}\n-\n-char* MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo,\n-                                                  GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,\n-                                                  GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps,\n-                                                  size_t& bitmap_size_in_bytes) {\n-  \/\/ Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with\n-  \/\/ MetaspaceShared::n_regions (internal to hotspot).\n-  assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, \"sanity\");\n-\n-  \/\/ mc contains the trampoline code for method entries, which are patched at run time,\n-  \/\/ so it needs to be read\/write.\n-  write_region(mapinfo, mc, &_mc_region, \/*read_only=*\/false,\/*allow_exec=*\/true);\n-  write_region(mapinfo, rw, &_rw_region, \/*read_only=*\/false,\/*allow_exec=*\/false);\n-  write_region(mapinfo, ro, &_ro_region, \/*read_only=*\/true, \/*allow_exec=*\/false);\n-\n-  return mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_oopmaps, open_oopmaps,\n-                                      bitmap_size_in_bytes);\n-}\n-\n-void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {\n-  mapinfo->write_region(region_idx, dump_region->base(), dump_region->used(), read_only, allow_exec);\n-}\n-\n@@ -990,1 +780,1 @@\n-void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {\n+void VM_PopulateDumpSharedSpace::dump_java_heap_objects(GrowableArray<Klass*>* klasses) {\n@@ -1002,2 +792,2 @@\n-  for (i = 0; i < _global_klass_objects->length(); i++) {\n-    Klass* k = _global_klass_objects->at(i);\n+  for (i = 0; i < klasses->length(); i++) {\n+    Klass* k = klasses->at(i);\n@@ -1643,12 +1433,0 @@\n-void MetaspaceShared::report_out_of_space(const char* name, size_t needed_bytes) {\n-  \/\/ This is highly unlikely to happen on 64-bits because we have reserved a 4GB space.\n-  \/\/ On 32-bit we reserve only 256MB so you could run out of space with 100,000 classes\n-  \/\/ or so.\n-  _mc_region.print_out_of_space_msg(name, needed_bytes);\n-  _rw_region.print_out_of_space_msg(name, needed_bytes);\n-  _ro_region.print_out_of_space_msg(name, needed_bytes);\n-\n-  vm_exit_during_initialization(err_msg(\"Unable to allocate from '%s' region\", name),\n-                                \"Please reduce the number of shared classes.\");\n-}\n-\n@@ -1672,1 +1450,1 @@\n-  if (UseSharedSpaces || DumpSharedSpaces) {\n+  if (UseSharedSpaces) {\n@@ -1674,12 +1452,4 @@\n-    address base;\n-    address top;\n-    if (UseSharedSpaces) { \/\/ Runtime\n-      base = (address)MetaspaceObj::shared_metaspace_base();\n-      address static_top = (address)_shared_metaspace_static_top;\n-      top = (address)MetaspaceObj::shared_metaspace_top();\n-      st->print(\"[\" PTR_FORMAT \"-\" PTR_FORMAT \"-\" PTR_FORMAT \"), \", p2i(base), p2i(static_top), p2i(top));\n-    } else if (DumpSharedSpaces) { \/\/ Dump Time\n-      base = (address)_shared_rs.base();\n-      top = (address)_shared_rs.end();\n-      st->print(\"[\" PTR_FORMAT \"-\" PTR_FORMAT \"), \", p2i(base), p2i(top));\n-    }\n+    address base = (address)MetaspaceObj::shared_metaspace_base();\n+    address static_top = (address)_shared_metaspace_static_top;\n+    address top = (address)MetaspaceObj::shared_metaspace_top();\n+    st->print(\"[\" PTR_FORMAT \"-\" PTR_FORMAT \"-\" PTR_FORMAT \"), \", p2i(base), p2i(static_top), p2i(top));\n@@ -1689,1 +1459,1 @@\n-    st->print(\"CDS disabled.\");\n+    st->print(\"CDS archive(s) not mapped\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":42,"deletions":272,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/compactHashtable.hpp\"\n@@ -36,6 +35,0 @@\n-\/\/ Metaspace::allocate() requires that all blocks must be aligned with KlassAlignmentInBytes.\n-\/\/ We enforce the same alignment rule in blocks allocated from the shared space.\n-const int SharedSpaceObjectAlignment = KlassAlignmentInBytes;\n-\n-class outputStream;\n-class CHeapBitMap;\n@@ -43,2 +36,3 @@\n-class DumpRegion;\n-struct ArchiveHeapOopmapInfo;\n+class outputStream;\n+\n+template<class E> class GrowableArray;\n@@ -52,9 +46,0 @@\n-class MetaspaceSharedStats {\n-public:\n-  MetaspaceSharedStats() {\n-    memset(this, 0, sizeof(*this));\n-  }\n-  CompactHashtableStats symbol;\n-  CompactHashtableStats string;\n-};\n-\n@@ -63,10 +48,2 @@\n-\n-  \/\/ CDS support\n-\n-  \/\/ Note: _shared_rs and _symbol_rs are only used at dump time.\n-  static ReservedSpace _shared_rs;\n-  static VirtualSpace _shared_vs;\n-  static ReservedSpace _symbol_rs;\n-  static VirtualSpace _symbol_vs;\n-  static int _max_alignment;\n-  static MetaspaceSharedStats _stats;\n+  static ReservedSpace _symbol_rs;  \/\/ used only during -Xshare:dump\n+  static VirtualSpace _symbol_vs;   \/\/ used only during -Xshare:dump\n@@ -77,1 +54,0 @@\n-  static size_t  _core_spaces_size;\n@@ -110,7 +86,0 @@\n-  static GrowableArray<Klass*>* collected_klasses();\n-\n-  static ReservedSpace* shared_rs() {\n-    CDS_ONLY(return &_shared_rs);\n-    NOT_CDS(return NULL);\n-  }\n-\n@@ -121,5 +90,0 @@\n-  static void set_shared_rs(ReservedSpace rs) {\n-    CDS_ONLY(_shared_rs = rs);\n-  }\n-\n-  static void commit_to(ReservedSpace* rs, VirtualSpace* vs, char* newtop) NOT_CDS_RETURN;\n@@ -135,4 +99,0 @@\n-  static bool is_in_output_space(void* ptr) {\n-    assert(DumpSharedSpaces, \"must be\");\n-    return shared_rs()->contains(ptr);\n-  }\n@@ -164,6 +124,0 @@\n-  static MetaspaceSharedStats* stats() {\n-    return &_stats;\n-  }\n-\n-  static void report_out_of_space(const char* name, size_t needed_bytes);\n-\n@@ -187,7 +141,0 @@\n-  static void init_shared_dump_space(DumpRegion* first_space);\n-  static DumpRegion* misc_code_dump_space();\n-  static DumpRegion* read_write_dump_space();\n-  static DumpRegion* read_only_dump_space();\n-  static void pack_dump_space(DumpRegion* current, DumpRegion* next,\n-                              ReservedSpace* rs);\n-\n@@ -200,27 +147,0 @@\n-  \/\/ Allocate a block of memory from the \"mc\" or \"ro\" regions.\n-  static char* misc_code_space_alloc(size_t num_bytes);\n-  static char* read_only_space_alloc(size_t num_bytes);\n-  static char* read_write_space_alloc(size_t num_bytes);\n-\n-  template <typename T>\n-  static Array<T>* new_ro_array(int length) {\n-    size_t byte_size = Array<T>::byte_sizeof(length, sizeof(T));\n-    Array<T>* array = (Array<T>*)read_only_space_alloc(byte_size);\n-    array->initialize(length);\n-    return array;\n-  }\n-\n-  template <typename T>\n-  static Array<T>* new_rw_array(int length) {\n-    size_t byte_size = Array<T>::byte_sizeof(length, sizeof(T));\n-    Array<T>* array = (Array<T>*)read_write_space_alloc(byte_size);\n-    array->initialize(length);\n-    return array;\n-  }\n-\n-  template <typename T>\n-  static size_t ro_array_bytesize(int length) {\n-    size_t byte_size = Array<T>::byte_sizeof(length, sizeof(T));\n-    return align_up(byte_size, SharedSpaceObjectAlignment);\n-  }\n-\n@@ -229,2 +149,1 @@\n-\n-  static void initialize_ptr_marker(CHeapBitMap* ptrmap);\n+  static void set_i2i_entry_code_buffers(address b);\n@@ -257,7 +176,0 @@\n-  \/\/ Returns the bitmap region which is allocated from C heap.\n-  \/\/ Caller must free it with FREE_C_HEAP_ARRAY()\n-  static char* write_core_archive_regions(FileMapInfo* mapinfo,\n-                                          GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,\n-                                          GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps,\n-                                          size_t& bitmap_size_in_bytes);\n-\n@@ -273,4 +185,0 @@\n-#if INCLUDE_CDS\n-  static void write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region,\n-                           bool read_only,  bool allow_exec);\n-#endif\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":6,"deletions":98,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_MEMORY_METASPACESHARED_INLINE_HPP\n-#define SHARE_MEMORY_METASPACESHARED_INLINE_HPP\n-\n-#include \"memory\/metaspaceShared.hpp\"\n-#if INCLUDE_G1GC\n-#include \"gc\/g1\/g1Allocator.inline.hpp\"\n-#endif\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-bool MetaspaceShared::is_archive_object(oop p) {\n-  return (p == NULL) ? false : G1ArchiveAllocator::is_archive_object(p);\n-}\n-#endif\n-\n-#endif \/\/ SHARE_MEMORY_METASPACESHARED_INLINE_HPP\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.inline.hpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+  friend class ArchiveBuilder;\n@@ -39,1 +40,0 @@\n-  friend class MetaspaceShared;\n","filename":"src\/hotspot\/share\/oops\/array.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        opts.addSuffix(\"-Xlog:gc+region=trace\");\n+        opts.addSuffix(\"-Xlog:cds=debug\");  \/\/ test detailed metadata info printing\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfClasses.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,2 @@\n-             \"-Xlog:cds,cds+dynamic\",\n+             \"-Xlog:cds=debug\", \/\/ test detailed metadata info printing\n+             \"-Xlog:cds+dynamic=info\",\n@@ -82,3 +83,2 @@\n-             .assertNormalExit(output -> {\n-                 output.shouldContain(\"Written dynamic archive 0x\");\n-             });\n+            .assertNormalExit(\"Written dynamic archive 0x\",\n+                              \"Detailed metadata info\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicLotsOfClasses.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}