{"files":[{"patch":"@@ -1352,1 +1352,1 @@\n-  __ align(4);\n+  __ align(NativeInstruction::instruction_size);\n@@ -1375,1 +1375,1 @@\n-  assert((__ offset() % 4) == 0, \"bad alignment\");\n+  __ assert_alignment(call_pc, NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"nativeInst_riscv.hpp\"\n@@ -326,1 +327,1 @@\n-\n+  assert_alignment(NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-  assert(offset() % 4 == 0, \"bad alignment\");\n+  assert_alignment(NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"nativeInst_riscv.hpp\"\n@@ -265,1 +266,1 @@\n-    assert(__ offset() % 4 == 0, \"bad alignment\");\n+    __ assert_alignment(NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,0 +94,8 @@\n+void MacroAssembler::assert_alignment(int alignment) {\n+  assert_alignment(pc(), alignment);\n+}\n+\n+void MacroAssembler::assert_alignment(address pc, int alignment) {\n+  assert(is_aligned(pc, alignment), \"bad alignment\");\n+}\n+\n@@ -2842,0 +2850,1 @@\n+  assert(entry.rspec().type() == relocInfo::runtime_call_type || is_aligned(call_pc, 4), \"bad alignment for patchable calls\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+  static void assert_alignment(address pc, int alignment);\n+  void assert_alignment(int alignment);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,0 +268,7 @@\n+  \/\/ Patching to not_entrant can happen while activations of the method are\n+  \/\/ in use. The patching in that instance must happen only when certain\n+  \/\/ alignment restrictions are true. These guarantees check those\n+  \/\/ conditions.\n+\n+  \/\/ Must be 4 byte aligned\n+  MacroAssembler::assert_alignment(verified_entry, NativeInstruction::instruction_size);\n@@ -358,0 +365,2 @@\n+  check_verified_entry_alignment(entry, verified_entry);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1321,0 +1321,1 @@\n+  __ assert_alignment(NativeInstruction::instruction_size);\n@@ -1738,0 +1739,4 @@\n+\n+  \/\/ These NOPs are critical so that verified entry point is properly\n+  \/\/ 4 bytes aligned for patching by NativeJump::patch_verified_entry()\n+  __ align(NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1143,0 +1143,1 @@\n+    __ assert_alignment(NativeInstruction::instruction_size);\n@@ -1294,0 +1295,1 @@\n+  __ assert_alignment(NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}