{"files":[{"patch":"@@ -1352,1 +1352,1 @@\n-  __ align(4);\n+  __ align(NativeInstruction::instruction_size);\n@@ -1375,1 +1375,1 @@\n-  assert((__ offset() % 4) == 0, \"bad alignment\");\n+  __ assert_alignment(call_pc);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-\n+  assert_alignment(pc());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-  assert(offset() % 4 == 0, \"bad alignment\");\n+  assert_alignment(pc());\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-    assert(__ offset() % 4 == 0, \"bad alignment\");\n+    __ assert_alignment(__ pc());\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2842,0 +2842,1 @@\n+  assert(entry.rspec().type() == relocInfo::runtime_call_type || is_aligned(call_pc, NativeInstruction::instruction_size), \"bad alignment for patchable calls\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"nativeInst_riscv.hpp\"\n@@ -51,0 +52,3 @@\n+  static inline void assert_alignment(address pc, int alignment = NativeInstruction::instruction_size) {\n+    assert(is_aligned(pc, alignment), \"bad alignment\");\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -268,0 +268,7 @@\n+  \/\/ Patching to not_entrant can happen while activations of the method are\n+  \/\/ in use. The patching in that instance must happen only when certain\n+  \/\/ alignment restrictions are true. These guarantees check those\n+  \/\/ conditions.\n+\n+  \/\/ Must be 4 bytes aligned\n+  MacroAssembler::assert_alignment(verified_entry);\n@@ -358,0 +365,2 @@\n+  check_verified_entry_alignment(entry, verified_entry);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1321,0 +1321,1 @@\n+  __ assert_alignment(__ pc());\n@@ -1738,0 +1739,4 @@\n+\n+  \/\/ These NOPs are critical so that verified entry point is properly\n+  \/\/ 4 bytes aligned for patching by NativeJump::patch_verified_entry()\n+  __ align(NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1143,0 +1143,1 @@\n+    __ assert_alignment(__ pc());\n@@ -1294,0 +1295,1 @@\n+  __ assert_alignment(__ pc());\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}