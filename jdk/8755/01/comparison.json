{"files":[{"patch":"@@ -803,9 +803,0 @@\n-void MacroAssembler::_assert_asm(Assembler::Condition cc, const char* msg) {\n-#ifdef ASSERT\n-  Label OK;\n-  jcc(cc, OK);\n-  stop(msg);\n-  bind(OK);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -677,4 +677,0 @@\n-  void _assert_asm(Condition cc, const char* msg);\n-#define assert_asm0(cc, msg) _assert_asm(cc, FILE_AND_LINE \": \" msg)\n-#define assert_asm(masm, command, cc, msg) DEBUG_ONLY((masm)->command; (masm)->_assert_asm(cc, FILE_AND_LINE \": \" #command \" \" #cc \": \" msg))\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7432,2 +7432,0 @@\n-    const char *name = \"cont_doYield\";\n-\n@@ -7441,1 +7439,0 @@\n-    \/\/ assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n@@ -7443,6 +7440,2 @@\n-    int insts_size = 512;\n-    int locs_size  = 64;\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n+    CodeBuffer code(\"cont_doYield\", 512, 64);\n+    MacroAssembler* _masm = new MacroAssembler(&code);\n@@ -7451,1 +7444,0 @@\n-\n@@ -7453,4 +7445,0 @@\n-\n-    __ movptr(c_rarg1, rsp);\n-\n-    int frame_complete = __ pc() - start;\n@@ -7459,1 +7447,9 @@\n-    __ post_call_nop(); \/\/ this must be exactly after the pc value that is pushed into the frame info, we use this nop for fast CodeBlob lookup\n+    int frame_complete = the_pc - start;\n+\n+    \/\/ This nop must be exactly at the PC we push into the frame info.\n+    \/\/ We use this nop for fast CodeBlob lookup, associate the OopMap\n+    \/\/ with it right away.\n+    __ post_call_nop();\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(framesize, 1);\n+    oop_maps->add_gc_map(the_pc - start, map);\n@@ -7461,1 +7457,0 @@\n-    __ movptr(c_rarg0, r15_thread);\n@@ -7463,0 +7458,2 @@\n+    __ movptr(c_rarg0, r15_thread);\n+    __ movptr(c_rarg1, rsp);\n@@ -7466,1 +7463,1 @@\n-    Label pinned;\n+    Label L_pinned;\n@@ -7468,2 +7465,2 @@\n-    __ testq(rax, rax);\n-    __ jcc(Assembler::notZero, pinned);\n+    __ testptr(rax, rax);\n+    __ jcc(Assembler::notZero, L_pinned);\n@@ -7472,1 +7469,1 @@\n-    continuation_enter_cleanup(masm);\n+    continuation_enter_cleanup(_masm);\n@@ -7476,1 +7473,1 @@\n-    __ bind(pinned); \/\/ pinned -- return to caller\n+    __ bind(L_pinned);\n@@ -7478,0 +7475,1 @@\n+    \/\/ Pinned, return to caller\n@@ -7481,9 +7479,7 @@\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub::new_runtime_stub(name,\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps, false);\n+    RuntimeStub* stub =\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code,\n+                                    frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps,\n+                                    false);\n@@ -7493,1 +7489,3 @@\n-  address generate_cont_thaw(Continuation::thaw_kind kind) {\n+  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n+    if (!Continuations::enabled()) return nullptr;\n+\n@@ -7497,0 +7495,1 @@\n+    StubCodeMark mark(this, \"StubRoutines\", label);\n@@ -7502,1 +7501,3 @@\n-      __ pop(c_rarg3); \/\/ pop return address. if we don't do this, we get a drift, where the bottom-most frozen frame continuously grows\n+      \/\/ Pop return address. If we don't do this, we get a drift,\n+      \/\/ where the bottom-most frozen frame continuously grows.\n+      __ pop(c_rarg3);\n@@ -7506,1 +7507,10 @@\n-    assert_asm(_masm, cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset())), Assembler::equal, \"incorrect rsp\");\n+\n+#ifdef ASSERT\n+    {\n+      Label L_good_sp;\n+      __ cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n+      __ jcc(Assembler::equal, L_good_sp);\n+      __ stop(\"Incorrect rsp at thaw entry\");\n+      __ BIND(L_good_sp);\n+    }\n+#endif\n@@ -7509,1 +7519,3 @@\n-      __ push(rax); __ push_d(xmm0); \/\/ preserve possible return value from a method returning to the return barrier\n+      \/\/ Preserve possible return value from a method returning to the return barrier.\n+      __ push(rax);\n+      __ push_d(xmm0);\n@@ -7512,3 +7524,4 @@\n-    __ movl(c_rarg1, (return_barrier ? 1 : 0));\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, Continuation::prepare_thaw), r15_thread, c_rarg1);\n-    __ movptr(rbx, rax); \/\/ rax contains the size of the frames to thaw, 0 if overflow or no more frames\n+    __ movptr(c_rarg0, r15_thread);\n+    __ movptr(c_rarg1, (return_barrier ? 1 : 0));\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, Continuation::prepare_thaw), 2);\n+    __ movptr(rbx, rax);\n@@ -7517,1 +7530,4 @@\n-      __ pop_d(xmm0); __ pop(rax); \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n+      \/\/ Restore return value from a method returning to the return barrier.\n+      \/\/ No safepoint in the call to thaw, so even an oop return value should be OK.\n+      __ pop_d(xmm0);\n+      __ pop(rax);\n@@ -7519,1 +7535,0 @@\n-    assert_asm(_masm, cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset())), Assembler::equal, \"incorrect rsp\");\n@@ -7521,3 +7536,14 @@\n-    Label thaw_success;\n-    __ testq(rbx, rbx);           \/\/ rbx contains the size of the frames to thaw, 0 if overflow or no more frames\n-    __ jcc(Assembler::notZero, thaw_success);\n+#ifdef ASSERT\n+    {\n+      Label L_good_sp;\n+      __ cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n+      __ jcc(Assembler::equal, L_good_sp);\n+      __ stop(\"Incorrect rsp after prepare thaw\");\n+      __ BIND(L_good_sp);\n+    }\n+#endif\n+\n+    \/\/ rbx contains the size of the frames to thaw, 0 if overflow or no more frames\n+    Label L_thaw_success;\n+    __ testptr(rbx, rbx);\n+    __ jccb(Assembler::notZero, L_thaw_success);\n@@ -7525,1 +7551,1 @@\n-    __ bind(thaw_success);\n+    __ bind(L_thaw_success);\n@@ -7527,2 +7553,3 @@\n-    __ subq(rsp, rbx);             \/\/ make room for the thawed frames\n-    __ andptr(rsp, -16);           \/\/ align\n+    \/\/ Make room for the thawed frames and align the stack.\n+    __ subptr(rsp, rbx);\n+    __ andptr(rsp, -StackAlignmentInBytes);\n@@ -7531,1 +7558,3 @@\n-      __ push(rax); __ push_d(xmm0); \/\/ save original return value -- again\n+      \/\/ Preserve possible return value from a method returning to the return barrier. (Again.)\n+      __ push(rax);\n+      __ push_d(xmm0);\n@@ -7534,5 +7563,5 @@\n-    \/\/ If we want, we can templatize thaw by kind, and have three different entries\n-    __ movl(c_rarg1, (int32_t) kind);\n-\n-    __ call_VM_leaf(Continuation::thaw_entry(), r15_thread, c_rarg1);\n-    __ movptr(rbx, rax); \/\/ rax is the sp of the yielding frame\n+    \/\/ If we want, we can templatize thaw by kind, and have three different entries.\n+    __ movptr(c_rarg0, r15_thread);\n+    __ movptr(c_rarg1, kind);\n+    __ call_VM_leaf(Continuation::thaw_entry(), 2);\n+    __ movptr(rbx, rax);\n@@ -7541,1 +7570,4 @@\n-      __ pop_d(xmm0); __ pop(rax); \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n+      \/\/ Restore return value from a method returning to the return barrier. (Again.)\n+      \/\/ No safepoint in the call to thaw, so even an oop return value should be OK.\n+      __ pop_d(xmm0);\n+      __ pop(rax);\n@@ -7543,1 +7575,2 @@\n-      __ movl(rax, 0); \/\/ return 0 (success) from doYield\n+      \/\/ Return 0 (success) from doYield.\n+      __ xorptr(rax, rax);\n@@ -7546,2 +7579,4 @@\n-    __ movptr(rsp, rbx); \/\/ we're now on the yield frame (which is in an address above us b\/c rsp has been pushed down)\n-    __ subptr(rsp, 2*wordSize); \/\/ now pointing to rbp spill\n+    \/\/ After thawing, rbx is the SP of the yielding frame.\n+    \/\/ Move there, and then to saved RBP slot.\n+    __ movptr(rsp, rbx);\n+    __ subptr(rsp, 2*wordSize);\n@@ -7550,0 +7585,1 @@\n+      __ movptr(c_rarg0, r15_thread);\n@@ -7551,4 +7587,10 @@\n-      __ push(rax); \/\/ save return value contaning the exception oop\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), r15_thread, c_rarg1);\n-      __ movptr(rbx, rax); \/\/ the exception handler\n-      __ pop(rax); \/\/ restore return value contaning the exception oop\n+\n+      \/\/ rax still holds the original exception oop, save it before the call\n+      __ push(rax);\n+\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), 2);\n+      __ movptr(rbx, rax);\n+\n+      \/\/ rbx now holds the exception handler.\n+      \/\/ Prepare for its invocation; see OptoRuntime::generate_exception_blob.\n+      __ pop(rax); \/\/ exception oop\n@@ -7556,2 +7598,2 @@\n-      __ pop(rdx); \/\/ rdx must contain the original pc in the case of exception; see OptoRuntime::generate_exception_blob\n-      __ jmp(rbx); \/\/ the exception handler\n+      __ pop(rdx); \/\/ exception pc\n+      __ jmp(rbx);\n@@ -7560,1 +7602,1 @@\n-    \/\/ We're \"returning\" into the topmost thawed frame; see Thaw::push_return_frame\n+    \/\/ We are \"returning\" into the topmost thawed frame; see Thaw::push_return_frame\n@@ -7568,6 +7610,1 @@\n-    if (!Continuations::enabled()) return nullptr;\n-\n-    StubCodeMark mark(this, \"StubRoutines\", \"Cont thaw\");\n-    address start = __ pc();\n-    generate_cont_thaw(Continuation::thaw_top);\n-    return start;\n+    return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n@@ -7576,8 +7613,1 @@\n-  address generate_cont_returnBarrier() {\n-    if (!Continuations::enabled()) return nullptr;\n-\n-    \/\/ TODO: will probably need multiple return barriers depending on return type\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier\");\n-    address start = __ pc();\n-\n-    generate_cont_thaw(Continuation::thaw_return_barrier);\n+  \/\/ TODO: will probably need multiple return barriers depending on return type\n@@ -7585,1 +7615,2 @@\n-    return start;\n+  address generate_cont_returnBarrier() {\n+    return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n@@ -7589,8 +7620,1 @@\n-    if (!Continuations::enabled()) return nullptr;\n-\n-    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier exception handler\");\n-    address start = __ pc();\n-\n-    generate_cont_thaw(Continuation::thaw_return_barrier_exception);\n-\n-    return start;\n+    return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n@@ -7601,17 +7625,0 @@\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm) {\n-    __ set_last_Java_frame(rsp, rbp, the_pc);\n-    __ movptr(c_rarg0, r15_thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-    Label null_jobject;\n-    __ testq(rax, rax);\n-    __ jcc(Assembler::zero, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, rax, Address(rax, 0), c_rarg0, r15_thread);\n-    __ bind(null_jobject);\n-  }\n-\n@@ -7630,6 +7637,2 @@\n-    int insts_size = 512;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n+    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+    MacroAssembler* _masm = new MacroAssembler(&code);\n@@ -7639,1 +7642,0 @@\n-    int frame_complete = __ pc() - start;\n@@ -7641,1 +7643,5 @@\n-    jfr_prologue(the_pc, _masm);\n+\n+    int frame_complete = the_pc - start;\n+\n+    __ set_last_Java_frame(rsp, rbp, the_pc);\n+    __ movptr(c_rarg0, r15_thread);\n@@ -7643,1 +7649,12 @@\n-    jfr_epilogue(_masm);\n+    __ reset_last_Java_frame(true);\n+\n+    \/\/ rax is jobject handle result, unpack and process it through a barrier.\n+    Label L_null_jobject;\n+    __ testptr(rax, rax);\n+    __ jcc(Assembler::zero, L_null_jobject);\n+\n+    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs->load_at(_masm, ACCESS_READ | IN_NATIVE, T_OBJECT, rax, Address(rax, 0), c_rarg0, r15_thread);\n+\n+    __ bind(L_null_jobject);\n+\n@@ -7647,0 +7664,1 @@\n+    OopMapSet* oop_maps = new OopMapSet();\n@@ -7650,2 +7668,4 @@\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+    RuntimeStub* stub =\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code,\n+                                    frame_complete,\n@@ -7653,1 +7673,2 @@\n-                                    oop_maps, false);\n+                                    oop_maps,\n+                                    false);\n@@ -8177,2 +8198,11 @@\n-\/\/ on exit, rsp points to the ContinuationEntry\n-\/\/ kills rax\n+\/\/---------------------------- continuation_enter_setup ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   None.\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to blank ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   rax\n+\/\/\n@@ -8184,2 +8214,2 @@\n-  stack_slots += (int)ContinuationEntry::size()\/wordSize;\n-  __ subptr(rsp, (int32_t)ContinuationEntry::size()); \/\/ place Continuation metadata\n+  stack_slots += checked_cast<int>(ContinuationEntry::size()) \/ wordSize;\n+  __ subptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n@@ -8187,1 +8217,2 @@\n-  OopMap* map = new OopMap(((int)ContinuationEntry::size() + wordSize)\/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n+  int frame_size = (checked_cast<int>(ContinuationEntry::size()) + wordSize) \/ VMRegImpl::stack_slot_size;\n+  OopMap* map = new OopMap(frame_size, 0);\n@@ -8197,4 +8228,13 @@\n-\/\/ on entry c_rarg1 points to the continuation\n-\/\/          rsp points to ContinuationEntry\n-\/\/          c_rarg3 -- isVirtualThread\n-\/\/ kills rax\n+\/\/---------------------------- fill_continuation_entry ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   rsp: pointer to blank Continuation entry\n+\/\/   c_rarg1: pointer to the continuation\n+\/\/   c_rarg3: flags\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to filled out ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   rax\n+\/\/\n@@ -8206,3 +8246,3 @@\n-  __ movptr(Address(rsp, ContinuationEntry::chunk_offset()), (int32_t)0);\n-  __ movl(Address(rsp, ContinuationEntry::argsize_offset()), (int32_t)0);\n-  __ movl(Address(rsp, ContinuationEntry::pin_count_offset()), (int32_t)0);\n+  __ movptr(Address(rsp, ContinuationEntry::chunk_offset()), 0);\n+  __ movl(Address(rsp, ContinuationEntry::argsize_offset()), 0);\n+  __ movl(Address(rsp, ContinuationEntry::pin_count_offset()), 0);\n@@ -8219,3 +8259,11 @@\n-\/\/ on entry, rsp points to the ContinuationEntry\n-\/\/ on exit, rsp points to the spilled rbp in the entry frame\n-\/\/ kills rbx, rcx\n+\/\/---------------------------- continuation_enter_cleanup ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   rsp: pointer to the ContinuationEntry\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to the spilled rbp in the entry frame\n+\/\/\n+\/\/ Kills:\n+\/\/   rbx\n+\/\/\n@@ -8223,2 +8271,2 @@\n-#ifndef PRODUCT\n-  Label OK;\n+#ifdef ASSERT\n+  Label L_good_sp;\n@@ -8226,3 +8274,3 @@\n-  __ jcc(Assembler::equal, OK);\n-  __ stop(\"incorrect rsp1\");\n-  __ bind(OK);\n+  __ jcc(Assembler::equal, L_good_sp);\n+  __ stop(\"Incorrect rsp at continuation_enter_cleanup\");\n+  __ bind(L_good_sp);\n@@ -8236,2 +8284,2 @@\n-  __ movptr(rcx, Address(rsp, ContinuationEntry::parent_offset()));\n-  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rcx);\n+  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_offset()));\n+  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rbx);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":184,"deletions":136,"binary":false,"changes":320,"status":"modified"}]}