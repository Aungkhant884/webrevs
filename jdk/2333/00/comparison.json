{"files":[{"patch":"@@ -101,1 +101,1 @@\n-  old_gen()->younger_refs_iterate(old_gen_closure, 0);\n+  old_gen()->younger_refs_iterate(old_gen_closure);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-void CardGeneration::younger_refs_iterate(OopIterateClosure* blk, uint n_threads) {\n+void CardGeneration::younger_refs_iterate(OopIterateClosure* blk) {\n@@ -318,1 +318,1 @@\n-  _rs->younger_refs_in_space_iterate(space(), gen_boundary, blk, n_threads);\n+  _rs->younger_refs_in_space_iterate(space(), gen_boundary, blk);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  void younger_refs_iterate(OopIterateClosure* blk, uint n_threads);\n+  void younger_refs_iterate(OopIterateClosure* blk);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,45 +82,0 @@\n-  if (_is_par) {\n-    return clear_card_parallel(entry);\n-  } else {\n-    return clear_card_serial(entry);\n-  }\n-}\n-\n-inline bool ClearNoncleanCardWrapper::clear_card_parallel(CardValue* entry) {\n-  while (true) {\n-    \/\/ In the parallel case, we may have to do this several times.\n-    CardValue entry_val = *entry;\n-    assert(entry_val != CardTableRS::clean_card_val(),\n-           \"We shouldn't be looking at clean cards, and this should \"\n-           \"be the only place they get cleaned.\");\n-    if (CardTableRS::card_is_dirty_wrt_gen_iter(entry_val)\n-        || _ct->is_prev_youngergen_card_val(entry_val)) {\n-      CardValue res =\n-        Atomic::cmpxchg(entry, entry_val, CardTableRS::clean_card_val());\n-      if (res == entry_val) {\n-        break;\n-      } else {\n-        assert(res == CardTableRS::cur_youngergen_and_prev_nonclean_card,\n-               \"The CAS above should only fail if another thread did \"\n-               \"a GC write barrier.\");\n-      }\n-    } else if (entry_val ==\n-               CardTableRS::cur_youngergen_and_prev_nonclean_card) {\n-      \/\/ Parallelism shouldn't matter in this case.  Only the thread\n-      \/\/ assigned to scan the card should change this value.\n-      *entry = _ct->cur_youngergen_card_val();\n-      break;\n-    } else {\n-      assert(entry_val == _ct->cur_youngergen_card_val(),\n-             \"Should be the only possibility.\");\n-      \/\/ In this case, the card was clean before, and become\n-      \/\/ cur_youngergen only because of processing of a promoted object.\n-      \/\/ We don't have to look at the card.\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-\n-inline bool ClearNoncleanCardWrapper::clear_card_serial(CardValue* entry) {\n@@ -138,2 +93,2 @@\n-  DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct, bool is_par) :\n-    _dirty_card_closure(dirty_card_closure), _ct(ct), _is_par(is_par) {\n+  DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct) :\n+    _dirty_card_closure(dirty_card_closure), _ct(ct) {\n@@ -206,2 +161,1 @@\n-                                                OopIterateClosure* cl,\n-                                                uint n_threads) {\n+                                                OopIterateClosure* cl) {\n@@ -211,1 +165,1 @@\n-  non_clean_card_iterate_possibly_parallel(sp, gen_boundary, urasm, cl, this, n_threads);\n+  non_clean_card_iterate(sp, gen_boundary, urasm, cl, this);\n@@ -583,7 +537,5 @@\n-void CardTableRS::non_clean_card_iterate_possibly_parallel(\n-  Space* sp,\n-  HeapWord* gen_boundary,\n-  MemRegion mr,\n-  OopIterateClosure* cl,\n-  CardTableRS* ct,\n-  uint n_threads)\n+void CardTableRS::non_clean_card_iterate(Space* sp,\n+                                         HeapWord* gen_boundary,\n+                                         MemRegion mr,\n+                                         OopIterateClosure* cl,\n+                                         CardTableRS* ct)\n@@ -591,14 +543,2 @@\n-  if (!mr.is_empty()) {\n-    if (n_threads > 0) {\n-      non_clean_card_iterate_parallel_work(sp, mr, cl, ct, n_threads);\n-    } else {\n-      \/\/ clear_cl finds contiguous dirty ranges of cards to process and clear.\n-\n-      \/\/ This is the single-threaded version used by DefNew.\n-      const bool parallel = false;\n-\n-      DirtyCardToOopClosure* dcto_cl = sp->new_dcto_cl(cl, precision(), gen_boundary, parallel);\n-      ClearNoncleanCardWrapper clear_cl(dcto_cl, ct, parallel);\n-\n-      clear_cl.do_MemRegion(mr);\n-    }\n+  if (mr.is_empty()) {\n+    return;\n@@ -606,1 +546,4 @@\n-}\n+  \/\/ clear_cl finds contiguous dirty ranges of cards to process and clear.\n+\n+  DirtyCardToOopClosure* dcto_cl = sp->new_dcto_cl(cl, precision(), gen_boundary);\n+  ClearNoncleanCardWrapper clear_cl(dcto_cl, ct);\n@@ -608,4 +551,1 @@\n-void CardTableRS::non_clean_card_iterate_parallel_work(Space* sp, MemRegion mr,\n-                                                       OopIterateClosure* cl, CardTableRS* ct,\n-                                                       uint n_threads) {\n-  fatal(\"Parallel gc not supported here.\");\n+  clear_cl.do_MemRegion(mr);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","additions":16,"deletions":76,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  void younger_refs_in_space_iterate(Space* sp, HeapWord* gen_boundary, OopIterateClosure* cl, uint n_threads);\n+  void younger_refs_in_space_iterate(Space* sp, HeapWord* gen_boundary, OopIterateClosure* cl);\n@@ -150,9 +150,5 @@\n-  void non_clean_card_iterate_possibly_parallel(Space* sp, HeapWord* gen_boundary,\n-                                                MemRegion mr, OopIterateClosure* cl,\n-                                                CardTableRS* ct, uint n_threads);\n-\n-  \/\/ Work method used to implement non_clean_card_iterate_possibly_parallel()\n-  \/\/ above in the parallel case.\n-  virtual void non_clean_card_iterate_parallel_work(Space* sp, MemRegion mr,\n-                                                    OopIterateClosure* cl, CardTableRS* ct,\n-                                                    uint n_threads);\n+  void non_clean_card_iterate(Space* sp,\n+                              HeapWord* gen_boundary,\n+                              MemRegion mr,\n+                              OopIterateClosure* cl,\n+                              CardTableRS* ct);\n@@ -178,1 +174,0 @@\n-  bool _is_par;\n@@ -194,1 +189,1 @@\n-  ClearNoncleanCardWrapper(DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct, bool is_par);\n+  ClearNoncleanCardWrapper(DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.hpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -166,2 +166,1 @@\n-                                          HeapWord* boundary,\n-                                          bool parallel) {\n+                                          HeapWord* boundary) {\n@@ -246,2 +245,1 @@\n-                             HeapWord* boundary,\n-                             bool parallel) {\n+                             HeapWord* boundary) {\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-                                             HeapWord* boundary,\n-                                             bool parallel);\n+                                             HeapWord* boundary);\n@@ -591,2 +590,1 @@\n-                                     HeapWord* boundary,\n-                                     bool parallel);\n+                                     HeapWord* boundary);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}