{"files":[{"patch":"@@ -3070,2 +3070,6 @@\n-      These functions allow an agent to force a method\n-      to return at any point during its execution.\n+      These functions allow an agent to force a return from the current frame.\n+      The specified thread must be suspended or must be the current thread.\n+      These functions may be used to force a return from the current frame\n+      of a virtual thread when it is suspended at an event.\n+      An implementation may support forcing a return from the current frame\n+      of a suspended virtual thread in other cases.\n@@ -3079,1 +3083,0 @@\n-      The specified thread must be suspended or must be the current thread.\n@@ -3135,1 +3138,1 @@\n-          The thread is a virtual thread and the implementation is\n+          The thread is a suspended virtual thread and the implementation was\n@@ -3187,1 +3190,1 @@\n-          The thread is a virtual thread and the implementation is\n+          The thread is a suspended virtual thread and the implementation was\n@@ -3235,1 +3238,1 @@\n-          The thread is a virtual thread and the implementation is\n+          The thread is a suspended virtual thread and the implementation was\n@@ -3280,1 +3283,1 @@\n-          The thread is a virtual thread and the implementation is\n+          The thread is a suspended virtual thread and the implementation was\n@@ -3325,1 +3328,1 @@\n-          The thread is a virtual thread and the implementation is\n+          The thread is a suspended virtual thread and the implementation was\n@@ -3364,1 +3367,1 @@\n-          The thread is a virtual thread and the implementation is\n+          The thread is a suspended virtual thread and the implementation was\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2039,4 +2039,0 @@\n-  if (thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass())) {\n-    \/\/ No support for virtual threads (yet).\n-    return JVMTI_ERROR_OPAQUE_FRAME;\n-  }\n@@ -2046,0 +2042,17 @@\n+  bool is_virtual = thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass());\n+\n+  if (is_virtual) {\n+    if (!is_JavaThread_current(java_thread, thread_obj)) {\n+      if (!is_vthread_suspended(thread_obj, java_thread)) {\n+        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      }\n+      if (java_thread == nullptr) { \/\/ unmounted virtual thread\n+        return JVMTI_ERROR_OPAQUE_FRAME;\n+      }\n+    }\n+  } else { \/\/ platform thread\n+    if (java_thread != current_thread && !java_thread->is_suspended() &&\n+        !java_thread->is_carrier_thread_suspended()) {\n+      return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    }\n+  }\n@@ -2078,6 +2091,0 @@\n-  if (!self) {\n-    if (!java_thread->is_suspended()) {\n-      _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-      return;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -122,4 +122,0 @@\n-  LOG(\"Testing ForceEarlyReturnVoid\\n\");\n-  err = jvmti->ForceEarlyReturnVoid(vthread);\n-  check_jvmti_error_opaque_frame(jni, \"ForceEarlyReturnVoid\", err);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/BoundVThreadTest\/libBoundVThreadTest.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Verifies JVMTI ForceEarlyReturn support for virtual threads.\n+ * @requires vm.continuations\n+ * @run main\/othervm\/native -agentlib:ForceEarlyReturnTest ForceEarlyReturnTest\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @summary Verifies JVMTI ForceEarlyReturn support for bound virtual threads.\n+ * @run main\/othervm\/native -agentlib:ForceEarlyReturnTest -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations ForceEarlyReturnTest\n+ *\/\n+\n+\/*\n+ * @test id=platform\n+ * @summary Verifies JVMTI ForceEarlyReturn support for platform threads.\n+ * @run main\/othervm\/native -agentlib:ForceEarlyReturnTest ForceEarlyReturnTest platform\n+ *\/\n+\n+import java.lang.AssertionError;\n+\n+\/*\n+ *     The test exercises the JVMTI function ForceEarlyReturn.\n+ *     The test creates a new virtual or platform thread.\n+ *     Its method run() invokes the following methods:\n+ *      - method A() that is blocked on a monitor\n+ *      - method B() that is stopped at a breakpoint\n+ *      - method C() that forces agent to call ForceEarlyReturn on its own thread\n+ *     JVMTI ForceEarlyReturn is called in all cases.\n+ *\/\n+public class ForceEarlyReturnTest {\n+    private static final String agentLib = \"ForceEarlyReturnTest\";\n+    static final int JVMTI_ERROR_NONE = 0;\n+    static final int THREAD_NOT_SUSPENDED = 13;\n+    static final int OPAQUE_FRAME = 32;\n+    static final int PASSED = 0;\n+    static final int FAILED = 2;\n+    static final int expValA1 = 111;\n+    static final int expValA2 = 222;\n+    static final String expValB1 = \"B1\";\n+    static final String expValB2 = \"B2\";\n+    static final String expValB3 = \"B3\";\n+\n+    static void log(String str) { System.out.println(str); }\n+\n+    static native void prepareAgent(Class taskClass);\n+    static native void suspendThread(Thread thread);\n+    static native void resumeThread(Thread thread);\n+    static native void ensureAtBreakpoint();\n+    static native void notifyAtBreakpoint();\n+    static native int  forceEarlyReturnV(Thread thread);\n+    static native int  forceEarlyReturnI(Thread thread, int val);\n+    static native int  forceEarlyReturnO(Thread thread, Object obj);\n+\n+    static int status = PASSED;\n+    static boolean is_virtual = true;\n+\n+    static void setFailed(String msg) {\n+        log(\"\\nFAILED: \" + msg);\n+        status = FAILED;\n+    }\n+\n+    static void throwFailed(String msg) {\n+        log(\"\\nFAILED: \" + msg);\n+        throw new RuntimeException(\"ForceEarlyReturnTest failed!\");\n+    }\n+\n+    public static void main(String args[]) {\n+        is_virtual = !(args.length > 0 && args[0].equals(\"platform\"));\n+        run();\n+        if (status == FAILED) {\n+            throwFailed(\"ForceEarlyReturnTest!\");\n+        }\n+        log(\"\\nForceEarlyReturnTest passed\");\n+    }\n+\n+    public static void run() {\n+        TestTask testTask = new TestTask();\n+        Thread testTaskThread = null;\n+        int errCode;\n+\n+        prepareAgent(TestTask.class);\n+\n+        log(\"\\nMain #A: method A() must be blocked on entering a synchronized statement\");\n+        if (is_virtual) {\n+            testTaskThread = Thread.ofVirtual().name(\"TestTaskThread\").start(testTask);\n+        } else {\n+            testTaskThread = Thread.ofPlatform().name(\"TestTaskThread\").start(testTask);\n+        }\n+\n+        {\n+            TestTask.ensureAtPointA();\n+\n+            log(\"\\nMain #A.1: unsuspended\");\n+            errCode = forceEarlyReturnI(testTaskThread, expValA1);\n+            if (errCode != THREAD_NOT_SUSPENDED) {\n+                throwFailed(\"Main #A.1: expected THREAD_NOT_SUSPENDED instead of: \" + errCode);\n+            } else {\n+                log(\"Main #A.1: got expected THREAD_NOT_SUSPENDED\");\n+            }\n+\n+            log(\"\\nMain #A.2: suspended\");\n+            suspendThread(testTaskThread);\n+            errCode = forceEarlyReturnI(testTaskThread, expValA2);\n+            if (errCode != JVMTI_ERROR_NONE) {\n+                throwFailed(\"Main #A.2: expected JVMTI_ERROR_NONE instead of: \" + errCode);\n+            } else {\n+                log(\"Main #A.2: got expected JVMTI_ERROR_NONE\");\n+            }\n+            resumeThread(testTaskThread);\n+            TestTask.clearDoLoop();\n+            TestTask.sleep(5);\n+        }\n+\n+        log(\"\\nMain #B: method B() must be blocked in a breakpoint event handler\");\n+        {\n+            ensureAtBreakpoint();\n+\n+            log(\"\\nMain #B.1: unsuspended\");\n+            errCode = forceEarlyReturnO(testTaskThread, expValB1);\n+            if (errCode != THREAD_NOT_SUSPENDED) {\n+                throwFailed(\"Main #B.1: expected THREAD_NOT_SUSPENDED instead of: \" + errCode);\n+            }\n+            log(\"Main #B.1: got expected THREAD_NOT_SUSPENDED\");\n+\n+            log(\"\\nMain #B.2: suspended\");\n+            suspendThread(testTaskThread);\n+            errCode = forceEarlyReturnO(testTaskThread, expValB2);\n+            if (errCode != JVMTI_ERROR_NONE) {\n+                throwFailed(\"Main #B.2: expected JVMTI_ERROR_NONE\");\n+            }\n+            log(\"Main #B.2: got expected JVMTI_ERROR_NONE\");\n+            resumeThread(testTaskThread);\n+            notifyAtBreakpoint();\n+            TestTask.sleep(5);\n+\n+            log(\"\\nMain #B.3: unsuspended, call ForceEarlyReturn on own thread\");\n+            ensureAtBreakpoint();\n+            notifyAtBreakpoint();\n+            TestTask.sleep(5);\n+        }\n+\n+        log(\"\\nMain #C: method C() calls ForceEarlyReturn on its own thread\");\n+        {\n+            \/\/ ForceEarlyReturn is called from the test task (own thread) and expected to succeed.\n+            \/\/ No suspension of the test task thread is required or can be done in this case.\n+            TestTask.ensureFinished();\n+        }\n+\n+        try {\n+            testTaskThread.join();\n+        } catch (InterruptedException ex) {\n+            throwFailed(\"Unexpected \" + ex);\n+        }\n+    }\n+\n+\n+    static class TestTask implements Runnable {\n+        static void log(String str) { System.out.println(str); }\n+\n+        static volatile boolean doLoop = true;\n+        static volatile boolean atPointA = false;\n+        static volatile boolean finished = false;\n+\n+        static void sleep(long millis) {\n+            try {\n+                Thread.sleep(millis);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Interruption in TestTask.sleep: \\n\\t\" + e);\n+            }\n+        }\n+\n+        \/\/ Ensure thread is ready.\n+        static void ensureAtPointA() {\n+            while (!atPointA) {\n+                sleep(1);\n+            }\n+        }\n+\n+        \/\/ Ensure thread is finished.\n+        static void ensureFinished() {\n+            while (!finished) {\n+                sleep(1);\n+            }\n+        }\n+\n+        static void clearDoLoop() {\n+            doLoop = false;\n+        }\n+\n+        public void run() {\n+            log(\"TestTask.run: started\");\n+\n+            int valA2 = A();\n+            if (valA2 != expValA2) {\n+                setFailed(\"TestTask.A: expValA2: \" + expValA2 + \"got: \" + valA2);\n+            }\n+            sleep(1); \/\/ to cause yield\n+\n+            String valB2 = B(false, expValB2); \/\/ false: do not force early return in breakpoint\n+            if (!valB2.equals(expValB2)) {\n+                setFailed(\"TestTask.B.2: expValB2: \" + expValB2 + \"got: \" + valB2);\n+            }\n+            sleep(1); \/\/ to cause yield\n+\n+            String valB3 = B(true, expValB3); \/\/ true: force early return in breakpoint\n+            if (!valB3.equals(expValB3)) {\n+                setFailed(\"TestTask.B.3: expected valB3: \" + expValB3 + \"got: \" + valB3);\n+            }\n+            sleep(1); \/\/ to cause yield\n+\n+            C();\n+            finished = true;\n+        }\n+\n+        \/\/ Method is busy in a while loop.\n+        \/\/ ForceEarlyReturn is used two times:\n+        \/\/  - when not suspended: THREAD_NOT_SUSPENDED is expected\n+        \/\/  - when suspended: JVMTI_ERROR_NONE is expected\n+        static int A() {\n+            log(\"TestTask.A: started\");\n+            atPointA = true;\n+            while (doLoop) {\n+            }\n+            log(\"TestTask.A: finished\");\n+            return 0;\n+        }\n+\n+        \/\/ A breakpoint is set at start of this method.\n+        \/\/ ForceEarlyReturn is used two times:\n+        \/\/  - when not suspended: THREAD_NOT_SUSPENDED is expected\n+        \/\/  - when suspended: expected to succeed\n+        static String B(boolean forceRet, String retObj) {\n+            log(\"TestTask.B: started\");\n+            return \"00\";\n+        }\n+\n+        \/\/ This method uses ForceEarlyReturn on its own thread. It is expected to return OPAQUE_FRAME.\n+        static void C() {\n+            log(\"TestTask.C: started\");\n+            int errCode = ForceEarlyReturnTest.forceEarlyReturnV(Thread.currentThread());\n+            if (errCode == OPAQUE_FRAME) {\n+                log(\"TestTask.C: got expected OPAQUE_FRAME\");\n+            } else {\n+                setFailed(\"TestTask.C: expected OPAQUE_FRAME from ForceEarlyReturn instead of: \" + errCode);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ForceEarlyReturnTest\/ForceEarlyReturnTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jmethodID mid_B = NULL;\n+static jrawMonitorID monitor = NULL;\n+static volatile bool bp_sync_reached = false;\n+\n+static void JNICALL\n+Breakpoint(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread,\n+           jmethodID method, jlocation location) {\n+  jvmtiError err;\n+\n+  if (method != mid_B) {\n+    fatal(jni, \"Breakpoint: Failed with wrong location: expected in method TestTask.B()\");\n+  }\n+\n+  LOG(\"Breakpoint: In method TestTask.B() before sync section\\n\");\n+  {\n+    RawMonitorLocker rml(jvmti, jni, monitor);\n+    bp_sync_reached = true;\n+    rml.wait(0);\n+  }\n+  LOG(\"Breakpoint: In method TestTask.B() after sync section\\n\");\n+\n+  jint force_return = 0;\n+  err = jvmti->GetLocalInt(thread, 0 \/* top frame *\/, 0 \/* slot #0 *\/, &force_return);\n+  check_jvmti_status(jni, err, \"Breakpoint: Failed in JVMTI GetLocalInt\");\n+\n+  if (force_return != 0) {\n+    jobject ret_obj = NULL;\n+\n+    err = jvmti->ClearBreakpoint(mid_B, 0);\n+    check_jvmti_status(jni, err, \"Breakpoint: Failed in JVMTI ClearBreakpoint\");\n+\n+    err = jvmti->GetLocalObject(thread, 0 \/* top frame *\/, 1 \/* slot #1 *\/, &ret_obj);\n+    check_jvmti_status(jni, err, \"Breakpoint: Failed in JVMTI GetLocalObject\");\n+\n+    LOG(\"Breakpoint: Self early return from method TestTask.B()\\n\");\n+    err = jvmti->ForceEarlyReturnObject(thread, ret_obj);\n+    LOG(\"Breakpoint: ForceEarlyReturnObject returned code: %s (%d)\\n\", TranslateError(err), err);\n+    check_jvmti_status(jni, err, \"Breakpoint: Failed in ForceEarlyReturnObject\");\n+  }\n+  LOG(\"Breakpoint: In method TestTask.B() finished\\n\");\n+}\n+\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  static jvmtiCapabilities caps;\n+  static jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  LOG(\"Agent init\\n\");\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    LOG(\"Agent init: Failed in GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in GetPotentialCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in GetCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  if (!caps.can_generate_breakpoint_events) {\n+    LOG(\"Agent init: Failed: Breakpoint event is not implemented\\n\");\n+    return JNI_ERR;\n+  }\n+  callbacks.Breakpoint = &Breakpoint;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in SetEventCallbacks: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  monitor = create_raw_monitor(jvmti, \"Raw monitor to test\");\n+  return JNI_OK;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ForceEarlyReturnTest_prepareAgent(JNIEnv *jni, jclass cls, jclass task_clazz) {\n+  jvmtiError err;\n+\n+  LOG(\"Main: prepareAgent started\\n\");\n+\n+  if (jvmti == NULL) {\n+    fatal(jni, \"prepareAgent: Failed as JVMTI client was not properly loaded!\\n\");\n+  }\n+  mid_B = jni->GetStaticMethodID(task_clazz, \"B\", \"(ZLjava\/lang\/String;)Ljava\/lang\/String;\");\n+  if (mid_B == NULL) {\n+    fatal(jni, \"prepareAgent: Failed to find Method ID for method: TestTask.B()\\n\");\n+  }\n+  err = jvmti->SetBreakpoint(mid_B, 0); \/\/ location: 0\n+  check_jvmti_status(jni, err, \"prepareAgent: Failed in JVMTI SetBreakpoint\");\n+\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+\n+  LOG(\"Main: prepareAgent finished\\n\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ForceEarlyReturnTest_suspendThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  LOG(\"Main: suspendThread\\n\");\n+  suspend_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ForceEarlyReturnTest_resumeThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  LOG(\"Main: resumeThread\\n\");\n+  resume_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ForceEarlyReturnTest_forceEarlyReturnV(JNIEnv *jni, jclass cls, jthread thread) {\n+  jvmtiError err = jvmti->ForceEarlyReturnVoid(thread);\n+  LOG(\"Main: forceEarlyReturn: ForceEarlyReturnVoid returned code: %s (%d)\\n\", TranslateError(err), err);\n+  return (jint)err;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ForceEarlyReturnTest_forceEarlyReturnI(JNIEnv *jni, jclass cls, jthread thread, jint val) {\n+  jvmtiError err = jvmti->ForceEarlyReturnInt(thread, val);\n+  LOG(\"Main: forceEarlyReturn: ForceEarlyReturnInt returned code: %s (%d)\\n\", TranslateError(err), err);\n+  return (jint)err;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ForceEarlyReturnTest_forceEarlyReturnO(JNIEnv *jni, jclass cls, jthread thread, jobject obj) {\n+  jvmtiError err = jvmti->ForceEarlyReturnObject(thread, obj);\n+  LOG(\"Main: forceEarlyReturn: ForceEarlyReturnObject returned code: %s (%d)\\n\", TranslateError(err), err);\n+  return (jint)err;\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_ForceEarlyReturnTest_ensureAtBreakpoint(JNIEnv *jni, jclass cls) {\n+  bool need_stop = false;\n+\n+  LOG(\"Main: ensureAtBreakpoint\\n\");\n+  while (!need_stop) {\n+    RawMonitorLocker rml(jvmti, jni, monitor);\n+    need_stop = bp_sync_reached;\n+    sleep_ms(1); \/\/ 1 millisecond\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ForceEarlyReturnTest_notifyAtBreakpoint(JNIEnv *jni, jclass cls) {\n+  LOG(\"Main: notifyAtBreakpoint\\n\");\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+  bp_sync_reached = false;\n+  rml.notify_all();\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ForceEarlyReturnTest\/libForceEarlyReturnTest.cpp","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -94,4 +94,0 @@\n-  LOG(\"Testing ForceEarlyReturnVoid\\n\");\n-  err = jvmti->ForceEarlyReturnVoid(vthread);\n-  check_jvmti_error_opaque_frame(jni, \"ForceEarlyReturnVoid\", err);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadUnsupportedTest\/libVThreadUnsupportedTest.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}