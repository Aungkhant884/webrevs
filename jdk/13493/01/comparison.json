{"files":[{"patch":"@@ -5995,43 +5995,0 @@\n-\/\/ ------------------------- Vector conditional move --------------------------\n-\n-instruct vcmove_neon(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd) %{\n-  predicate(UseSVE == 0 ||\n-            (VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) &&\n-             n->in(1)->in(2)->get_int() != BoolTest::ne));\n-  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n-  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n-  effect(TEMP_DEF dst);\n-  format %{ \"vcmove_neon.$copnd $dst, $src1, $src2\\t# vector conditional move fp\" %}\n-  ins_encode %{\n-    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n-    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n-                    $src2$$FloatRegister, condition, \/* isQ *\/ length_in_bytes == 16);\n-    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-           $src2$$FloatRegister, $src1$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmove_sve(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd, pRegGov pgtmp) %{\n-  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) ||\n-            (UseSVE > 0 && n->in(1)->in(2)->get_int() == BoolTest::ne));\n-  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n-  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n-  effect(TEMP pgtmp);\n-  format %{ \"vcmove_sve.$copnd $dst, $src1, $src2\\t# vector conditional move fp. KILL $pgtmp\" %}\n-  ins_encode %{\n-    assert(UseSVE > 0, \"must be sve\");\n-    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    __ sve_compare($pgtmp$$PRegister, bt, ptrue, $src1$$FloatRegister,\n-                   $src2$$FloatRegister, condition);\n-    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n-               $pgtmp$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -4261,43 +4261,0 @@\n-\/\/ ------------------------- Vector conditional move --------------------------\n-\n-instruct vcmove_neon(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd) %{\n-  predicate(UseSVE == 0 ||\n-            (VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) &&\n-             n->in(1)->in(2)->get_int() != BoolTest::ne));\n-  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n-  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n-  effect(TEMP_DEF dst);\n-  format %{ \"vcmove_neon.$copnd $dst, $src1, $src2\\t# vector conditional move fp\" %}\n-  ins_encode %{\n-    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n-    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n-                    $src2$$FloatRegister, condition, \/* isQ *\/ length_in_bytes == 16);\n-    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-           $src2$$FloatRegister, $src1$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmove_sve(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd, pRegGov pgtmp) %{\n-  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) ||\n-            (UseSVE > 0 && n->in(1)->in(2)->get_int() == BoolTest::ne));\n-  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n-  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n-  effect(TEMP pgtmp);\n-  format %{ \"vcmove_sve.$copnd $dst, $src1, $src2\\t# vector conditional move fp. KILL $pgtmp\" %}\n-  ins_encode %{\n-    assert(UseSVE > 0, \"must be sve\");\n-    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    __ sve_compare($pgtmp$$PRegister, bt, ptrue, $src1$$FloatRegister,\n-                   $src2$$FloatRegister, condition);\n-    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n-               $pgtmp$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1507,6 +1507,0 @@\n-    case Op_CMoveVF:\n-    case Op_CMoveVD:\n-      if (UseAVX < 1) { \/\/ enabled for AVX only\n-        return false;\n-      }\n-      break;\n@@ -1743,5 +1737,0 @@\n-    case Op_CMoveVF:\n-      if (vlen != 8) {\n-        return false; \/\/ implementation limitation (only vcmov8F_reg is present)\n-      }\n-      break;\n@@ -1775,5 +1764,0 @@\n-    case Op_CMoveVD:\n-      if (vlen != 4) {\n-        return false; \/\/ implementation limitation (only vcmov4D_reg is present)\n-      }\n-      break;\n@@ -2950,23 +2934,0 @@\n-\/\/ Comparison Code for FP conditional move\n-operand cmpOp_vcmppd() %{\n-  match(Bool);\n-\n-  predicate(n->as_Bool()->_test._test != BoolTest::overflow &&\n-            n->as_Bool()->_test._test != BoolTest::no_overflow);\n-  format %{ \"\" %}\n-  interface(COND_INTER) %{\n-    equal        (0x0, \"eq\");\n-    less         (0x1, \"lt\");\n-    less_equal   (0x2, \"le\");\n-    not_equal    (0xC, \"ne\");\n-    greater_equal(0xD, \"ge\");\n-    greater      (0xE, \"gt\");\n-    \/\/TODO cannot compile (adlc breaks) without two next lines with error:\n-    \/\/ x86_64.ad(13987) Syntax Error: :In operand cmpOp_vcmppd: Do not support this encode constant: ' %{\n-    \/\/ equal' for overflow.\n-    overflow     (0x20, \"o\");  \/\/ not really supported by the instruction\n-    no_overflow  (0x21, \"no\"); \/\/ not really supported by the instruction\n-  %}\n-%}\n-\n-\n@@ -5986,36 +5947,0 @@\n-instruct vcmov8F_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{\n-  predicate(Matcher::vector_length(n) == 8);\n-  match(Set dst (CMoveVF (Binary copnd cop) (Binary src1 src2)));\n-  effect(TEMP dst, USE src1, USE src2);\n-  format %{ \"cmpps.$copnd  $dst, $src1, $src2  ! vcmovevf, cond=$cop\\n\\t\"\n-            \"blendvps $dst,$src1,$src2,$dst ! vcmovevf\\n\\t\"\n-         %}\n-  ins_encode %{\n-    assert(UseAVX > 0, \"required\");\n-\n-    int vlen_enc = Assembler::AVX_256bit;\n-    int cond = (Assembler::Condition)($copnd$$cmpcode);\n-    __ vcmpps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vlen_enc);\n-    __ vblendvps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vcmov4D_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{\n-  predicate(Matcher::vector_length(n) == 4);\n-  match(Set dst (CMoveVD (Binary copnd cop) (Binary src1 src2)));\n-  effect(TEMP dst, USE src1, USE src2);\n-  format %{ \"cmppd.$copnd  $dst, $src1, $src2  ! vcmovevd, cond=$cop\\n\\t\"\n-            \"vblendvpd $dst,$src1,$src2,$dst ! vcmovevd\\n\\t\"\n-         %}\n-  ins_encode %{\n-    assert(UseAVX > 0, \"required\");\n-\n-    int vlen_enc = Assembler::AVX_256bit;\n-    int cond = (Assembler::Condition)($copnd$$cmpcode);\n-    __ vcmppd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vlen_enc);\n-    __ vblendvpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -4206,1 +4206,0 @@\n-    \"CMoveVD\", \"CMoveVF\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-macro(CMoveVD)\n@@ -86,1 +85,0 @@\n-macro(CMoveVF)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2388,14 +2388,0 @@\n-    case Op_CMoveVF:\n-    case Op_CMoveVD: {\n-      \/\/ Restructure into a binary tree for Matching:\n-      \/\/ CMoveVF (Binary bool mask) (Binary src1 src2)\n-      Node* in_cc = n->in(1);\n-      assert(in_cc->is_Con(), \"The condition input of cmove vector node must be a constant.\");\n-      Node* bol = new BoolNode(in_cc, (BoolTest::mask)in_cc->get_int());\n-      Node* pair1 = new BinaryNode(bol, in_cc);\n-      n->set_req(1, pair1);\n-      Node* pair2 = new BinaryNode(n->in(2), n->in(3));\n-      n->set_req(2, pair2);\n-      n->del_req(3);\n-      break;\n-    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-  _cmovev_kit(_arena, this),                                \/\/ map to facilitate CMoveV creation\n@@ -664,3 +663,0 @@\n-    if (UseVectorCmov) {\n-      merge_packs_to_cmove();\n-    }\n@@ -1625,12 +1621,0 @@\n-  Node* use = nullptr; \/\/test if the node is a candidate for CMoveV optimization, then return the size of CMov\n-  if (UseVectorCmov) {\n-    use = _cmovev_kit.is_Bool_candidate(s);\n-    if (use != nullptr) {\n-      return data_size(use);\n-    }\n-    use = _cmovev_kit.is_Cmp_candidate(s);\n-    if (use != nullptr) {\n-      return data_size(use);\n-    }\n-  }\n-\n@@ -2097,207 +2081,0 @@\n-\/\/------------------------------merge_packs_to_cmove---------------------------\n-\/\/ Merge qualified CMove into new vector-nodes\n-\/\/ We want to catch this pattern and subsume Cmp and Bool into CMove\n-\/\/\n-\/\/                   Sub              Con\n-\/\/                  \/  |               \/\n-\/\/                 \/   |           \/   \/\n-\/\/                \/    |       \/      \/\n-\/\/               \/     |   \/         \/\n-\/\/              \/      \/            \/\n-\/\/             \/    \/  |           \/\n-\/\/            v \/      |          \/\n-\/\/         Cmp         |         \/\n-\/\/          |          |        \/\n-\/\/          v          |       \/\n-\/\/         Bool        |      \/\n-\/\/           \\         |     \/\n-\/\/             \\       |    \/\n-\/\/               \\     |   \/\n-\/\/                 \\   |  \/\n-\/\/                   \\ v \/\n-\/\/                   CMove\n-\/\/\n-\n-void SuperWord::merge_packs_to_cmove() {\n-  for (int i = _packset.length() - 1; i >= 0; i--) {\n-    Node_List* pk = _packset.at(i);\n-    if (_cmovev_kit.can_merge_cmove_pack(pk)) {\n-      _cmovev_kit.make_cmove_pack(pk);\n-    }\n-  }\n-\n-  #ifndef PRODUCT\n-    if (TraceSuperWord) {\n-      tty->print_cr(\"\\nSuperWord::merge_packs_to_cmove(): After merge\");\n-      print_packset();\n-      tty->cr();\n-    }\n-  #endif\n-}\n-\n-Node* CMoveKit::is_Bool_candidate(Node* def) const {\n-  Node* use = nullptr;\n-  if (!def->is_Bool() || def->in(0) != nullptr || def->outcnt() != 1) {\n-    return nullptr;\n-  }\n-  for (DUIterator_Fast jmax, j = def->fast_outs(jmax); j < jmax; j++) {\n-    use = def->fast_out(j);\n-    if (!_sw->same_generation(def, use) || !use->is_CMove()) {\n-      return nullptr;\n-    }\n-  }\n-  return use;\n-}\n-\n-Node* CMoveKit::is_Cmp_candidate(Node* def) const {\n-  Node* use = nullptr;\n-  if (!def->is_Cmp() || def->in(0) != nullptr || def->outcnt() != 1) {\n-    return nullptr;\n-  }\n-  for (DUIterator_Fast jmax, j = def->fast_outs(jmax); j < jmax; j++) {\n-    use = def->fast_out(j);\n-    if (!_sw->same_generation(def, use) || (use = is_Bool_candidate(use)) == nullptr || !_sw->same_generation(def, use)) {\n-      return nullptr;\n-    }\n-  }\n-  return use;\n-}\n-\n-\/\/ Determine if the current pack is an ideal cmove pack, and if its related packs,\n-\/\/ i.e. bool node pack and cmp node pack, can be successfully merged for vectorization.\n-bool CMoveKit::can_merge_cmove_pack(Node_List* cmove_pk) {\n-  Node* cmove = cmove_pk->at(0);\n-\n-  if (!SuperWord::is_cmove_fp_opcode(cmove->Opcode()) ||\n-      pack(cmove) != nullptr \/* already in the cmove pack *\/) {\n-    return false;\n-  }\n-\n-  if (cmove->in(0) != nullptr) {\n-    NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::can_merge_cmove_pack: CMove %d has control flow, escaping...\", cmove->_idx); cmove->dump();})\n-    return false;\n-  }\n-\n-  Node* bol = cmove->as_CMove()->in(CMoveNode::Condition);\n-  if (!bol->is_Bool() ||\n-      bol->outcnt() != 1 ||\n-      !_sw->same_generation(bol, cmove) ||\n-      bol->in(0) != nullptr || \/\/ Bool node has control flow!!\n-      _sw->my_pack(bol) == nullptr) {\n-      NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::can_merge_cmove_pack: Bool %d does not fit CMove %d for building vector, escaping...\", bol->_idx, cmove->_idx); bol->dump();})\n-    return false;\n-  }\n-  Node_List* bool_pk = _sw->my_pack(bol);\n-  if (bool_pk->size() != cmove_pk->size() ) {\n-    return false;\n-  }\n-\n-  Node* cmp = bol->in(1);\n-  if (!cmp->is_Cmp() ||\n-      cmp->outcnt() != 1 ||\n-      !_sw->same_generation(cmp, cmove) ||\n-      cmp->in(0) != nullptr || \/\/ Cmp node has control flow!!\n-      _sw->my_pack(cmp) == nullptr) {\n-      NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::can_merge_cmove_pack: Cmp %d does not fit CMove %d for building vector, escaping...\", cmp->_idx, cmove->_idx); cmp->dump();})\n-    return false;\n-  }\n-  Node_List* cmp_pk = _sw->my_pack(cmp);\n-  if (cmp_pk->size() != cmove_pk->size() ) {\n-    return false;\n-  }\n-\n-  if (!test_cmp_pack(cmp_pk, cmove_pk)) {\n-    NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::can_merge_cmove_pack: cmp pack for Cmp %d failed vectorization test\", cmp->_idx); cmp->dump();})\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n-\/\/ Create a new cmove pack to substitute the old one, map all info to the\n-\/\/ new pack and delete the old cmove pack and related packs from the packset.\n-void CMoveKit::make_cmove_pack(Node_List* cmove_pk) {\n-  Node* cmove = cmove_pk->at(0);\n-  Node* bol = cmove->as_CMove()->in(CMoveNode::Condition);\n-  Node_List* bool_pk = _sw->my_pack(bol);\n-  Node* cmp = bol->in(1);\n-  Node_List* cmp_pk = _sw->my_pack(cmp);\n-\n-  Node_List* new_cmove_pk = new Node_List();\n-  uint sz = cmove_pk->size() - 1;\n-  for (uint i = 0; i <= sz; ++i) {\n-    Node* cmov = cmove_pk->at(i);\n-    Node* bol  = bool_pk->at(i);\n-    Node* cmp  = cmp_pk->at(i);\n-\n-    new_cmove_pk->insert(i, cmov);\n-\n-    map(cmov, new_cmove_pk);\n-    map(bol, new_cmove_pk);\n-    map(cmp, new_cmove_pk);\n-\n-    _sw->set_my_pack(cmov, new_cmove_pk); \/\/ and keep old packs for cmp and bool\n-  }\n-  _sw->_packset.remove(cmove_pk);\n-  _sw->_packset.remove(bool_pk);\n-  _sw->_packset.remove(cmp_pk);\n-  _sw->_packset.append(new_cmove_pk);\n-  NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print_cr(\"CMoveKit::make_cmove_pack: added syntactic CMove pack\"); _sw->print_pack(new_cmove_pk);})\n-}\n-\n-bool CMoveKit::test_cmp_pack(Node_List* cmp_pk, Node_List* cmove_pk) {\n-  Node* cmp0 = cmp_pk->at(0);\n-  assert(cmp0->is_Cmp(), \"CMoveKit::test_cmp_pack: should be Cmp Node\");\n-  assert(cmove_pk->at(0)->is_CMove(), \"CMoveKit::test_cmp_pack: should be CMove\");\n-  assert(cmp_pk->size() == cmove_pk->size(), \"CMoveKit::test_cmp_pack: should be same size\");\n-  Node* in1 = cmp0->in(1);\n-  Node* in2 = cmp0->in(2);\n-  Node_List* in1_pk = _sw->my_pack(in1);\n-  Node_List* in2_pk = _sw->my_pack(in2);\n-\n-  if (  (in1_pk != nullptr && in1_pk->size() != cmp_pk->size())\n-     || (in2_pk != nullptr && in2_pk->size() != cmp_pk->size()) ) {\n-    return false;\n-  }\n-\n-  \/\/ test if \"all\" in1 are in the same pack or the same node\n-  if (in1_pk == nullptr) {\n-    for (uint j = 1; j < cmp_pk->size(); j++) {\n-      if (cmp_pk->at(j)->in(1) != in1) {\n-        return false;\n-      }\n-    }\/\/for: in1_pk is not pack but all Cmp nodes in the pack have the same in(1)\n-  }\n-  \/\/ test if \"all\" in2 are in the same pack or the same node\n-  if (in2_pk == nullptr) {\n-    for (uint j = 1; j < cmp_pk->size(); j++) {\n-      if (cmp_pk->at(j)->in(2) != in2) {\n-        return false;\n-      }\n-    }\/\/for: in2_pk is not pack but all Cmp nodes in the pack have the same in(2)\n-  }\n-  \/\/now check if cmp_pk may be subsumed in vector built for cmove_pk\n-  int cmove_ind1, cmove_ind2;\n-  if (cmp_pk->at(0)->in(1) == cmove_pk->at(0)->as_CMove()->in(CMoveNode::IfFalse)\n-   && cmp_pk->at(0)->in(2) == cmove_pk->at(0)->as_CMove()->in(CMoveNode::IfTrue)) {\n-      cmove_ind1 = CMoveNode::IfFalse;\n-      cmove_ind2 = CMoveNode::IfTrue;\n-  } else if (cmp_pk->at(0)->in(2) == cmove_pk->at(0)->as_CMove()->in(CMoveNode::IfFalse)\n-          && cmp_pk->at(0)->in(1) == cmove_pk->at(0)->as_CMove()->in(CMoveNode::IfTrue)) {\n-      cmove_ind2 = CMoveNode::IfFalse;\n-      cmove_ind1 = CMoveNode::IfTrue;\n-  }\n-  else {\n-    return false;\n-  }\n-\n-  for (uint j = 1; j < cmp_pk->size(); j++) {\n-    if (cmp_pk->at(j)->in(1) != cmove_pk->at(j)->as_CMove()->in(cmove_ind1)\n-        || cmp_pk->at(j)->in(2) != cmove_pk->at(j)->as_CMove()->in(cmove_ind2)) {\n-        return false;\n-    }\/\/if\n-  }\n-  NOT_PRODUCT(if(_sw->is_trace_cmov()) { tty->print(\"CMoveKit::test_cmp_pack: cmp pack for 1st Cmp %d is OK for vectorization: \", cmp0->_idx); cmp0->dump(); })\n-  return true;\n-}\n-\n@@ -2328,3 +2105,3 @@\n-    } else if (is_cmove_fp_opcode(opc)) {\n-      retValue = is_cmov_pack(p) && VectorNode::implemented(opc, size, velt_basic_type(p0));\n-      NOT_PRODUCT(if(retValue && is_trace_cmov()) {tty->print_cr(\"SWPointer::implemented: found cmove pack\"); print_pack(p);})\n+    } else if (p0->is_Cmp()) {\n+      \/\/ Cmp -> Bool -> Cmove\n+      retValue = UseVectorCmov;\n@@ -2353,4 +2130,0 @@\n-bool SuperWord::is_cmov_pack(Node_List* p) {\n-  return _cmovev_kit.pack(p->at(0)) != nullptr;\n-}\n-\n@@ -2430,3 +2203,0 @@\n-      if (is_cmov_pack_internal_node(p, def)) {\n-        continue;\n-      }\n@@ -2453,0 +2223,18 @@\n+  if (p0->is_Cmp()) {\n+    \/\/ Verify that Cmp pack only has Bool pack uses\n+    for (DUIterator_Fast jmax, j = p0->fast_outs(jmax); j < jmax; j++) {\n+      Node* bol = p0->fast_out(j);\n+      if (!bol->is_Bool() || bol->in(0) != nullptr || !is_vector_use(bol, 1)) {\n+        return false;\n+      }\n+    }\n+  }\n+  if (p0->is_Bool()) {\n+    \/\/ Verify that Bool pack only has CMove pack uses\n+    for (DUIterator_Fast jmax, j = p0->fast_outs(jmax); j < jmax; j++) {\n+      Node* cmove = p0->fast_out(j);\n+      if (!cmove->is_CMove() || cmove->in(0) != nullptr || !is_vector_use(cmove, 1)) {\n+        return false;\n+      }\n+    }\n+  }\n@@ -2458,0 +2246,1 @@\n+  \/\/ Verify independence at pack level.\n@@ -2476,0 +2265,21 @@\n+\n+  \/\/ Verify all nodes in packset have my_pack set correctly.\n+  Unique_Node_List processed;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    for (uint k = 0; k < p->size(); k++) {\n+      Node* n = p->at(k);\n+      assert(in_bb(n), \"only nodes in bb can be in packset\");\n+      assert(!processed.member(n), \"node should only occur once in packset\");\n+      assert(my_pack(n) == p, \"n has consisten packset info\");\n+      processed.push(n);\n+    }\n+  }\n+\n+  \/\/ Check that no other node has my_pack set.\n+  for (int i = 0; i < _block.length(); i++) {\n+    Node* n = _block.at(i);\n+    if (!processed.member(n)) {\n+      assert(my_pack(n) == nullptr, \"should not have pack if not in packset\");\n+    }\n+  }\n@@ -2580,1 +2390,1 @@\n-        assert(_slp->my_pack(n) == nullptr || UseVectorCmov, \"no packset\");\n+        assert(_slp->my_pack(n) == nullptr, \"no packset\");\n@@ -2998,1 +2808,83 @@\n-      } else if (n->req() == 3 && !is_cmov_pack(p)) {\n+      } else if (n->is_Cmp()) {\n+        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n+        continue;\n+      } else if (n->is_Bool()) {\n+        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n+        continue;\n+      } else if (n->is_CMove()) {\n+        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n+\n+        BoolNode* bol = n->in(1)->as_Bool();\n+        assert(bol != nullptr, \"must have Bool above CMove\");\n+        BoolTest::mask bol_test = bol->_test._test;\n+        assert(bol_test == BoolTest::eq ||\n+               bol_test == BoolTest::ne ||\n+               bol_test == BoolTest::ge ||\n+               bol_test == BoolTest::gt ||\n+               bol_test == BoolTest::lt ||\n+               bol_test == BoolTest::le,\n+               \"CMove bool should be one of: eq,ne,ge,ge,lt,le\");\n+        Node_List* p_bol = my_pack(bol);\n+        assert(p_bol != nullptr, \"CMove must have matching Bool pack\");\n+\n+        CmpNode* cmp = bol->in(1)->as_Cmp();\n+        assert(cmp != nullptr, \"must have cmp above CMove\");\n+        Node_List* p_cmp = my_pack(cmp);\n+        assert(p_cmp != nullptr, \"Bool must have matching Cmp pack\");\n+\n+        Node* cmp_in1 = vector_opd(p_cmp, 1);\n+        Node* cmp_in2 = vector_opd(p_cmp, 2);\n+\n+        Node* blend_in1 = vector_opd(p, 2);\n+        Node* blend_in2 = vector_opd(p, 3);\n+\n+        if (cmp->Opcode() == Op_CmpF || cmp->Opcode() == Op_CmpD) {\n+          \/\/ If we have a Float or Double comparison, we must be careful with\n+          \/\/ handling NaN's correctly. CmpF and CmpD have a return code, as\n+          \/\/ they are based on the java bytecodes fcmpl\/dcmpl:\n+          \/\/ -1: cmp_in1 <  cmp_in2, or at least one of the two is a NaN\n+          \/\/  0: cmp_in1 == cmp_in2  (no NaN)\n+          \/\/  1: cmp_in1 >  cmp_in2  (no NaN)\n+          \/\/\n+          \/\/ The \"bol_test\" selects which of the [-1, 0, 1] cases lead to \"true\".\n+          \/\/\n+          \/\/ Note: ordered   (O) comparison returns \"false\" if either input is NaN.\n+          \/\/       unordered (U) comparison returns \"true\"  if either input is NaN.\n+          \/\/\n+          \/\/ The VectorMaskCmpNode does a comparison directly on in1 and in2, in the java\n+          \/\/ standard way (all comparisons are ordered, except NEQ is unordered).\n+          \/\/\n+          \/\/ In the following, \"bol_test\" already matches the cmp code for VectorMaskCmpNode:\n+          \/\/   BoolTest::eq:  Case 0     -> EQ_O\n+          \/\/   BoolTest::ne:  Case -1, 1 -> NEQ_U\n+          \/\/   BoolTest::ge:  Case 0, 1  -> GE_O\n+          \/\/   BoolTest::gt:  Case 1     -> GT_O\n+          \/\/\n+          \/\/ But the lt and le comparisons must be converted from unordered to ordered:\n+          \/\/   BoolTest::lt:  Case -1    -> LT_U -> VectorMaskCmp would interpret lt as LT_O\n+          \/\/   BoolTest::le:  Case -1, 0 -> LE_U -> VectorMaskCmp would interpret le as LE_O\n+          \/\/\n+          if (bol_test == BoolTest::lt || bol_test == BoolTest::le) {\n+            \/\/ Negating the bol_test and swapping the blend-inputs leaves all non-NaN cases equal,\n+            \/\/ but converts the unordered (U) to an ordered (O) comparison.\n+            \/\/      VectorBlend(VectorMaskCmp(LT_U, in1_cmp, in2_cmp), in1_blend, in2_blend)\n+            \/\/ <==> VectorBlend(VectorMaskCmp(GE_O, in1_cmp, in2_cmp), in2_blend, in1_blend)\n+            \/\/      VectorBlend(VectorMaskCmp(LE_U, in1_cmp, in2_cmp), in1_blend, in2_blend)\n+            \/\/ <==> VectorBlend(VectorMaskCmp(GT_O, in1_cmp, in2_cmp), in2_blend, in1_blend)\n+            bol_test = bol->_test.negate();\n+            swap(blend_in1, blend_in2);\n+          }\n+        }\n+\n+        \/\/ VectorMaskCmp\n+        ConINode* bol_test_node  = _igvn.intcon((int)bol_test);\n+        BasicType bt = velt_basic_type(cmp);\n+        const TypeVect* vt = TypeVect::make(bt, vlen);\n+        VectorNode* mask = new VectorMaskCmpNode(bol_test, cmp_in1, cmp_in2, bol_test_node, vt);\n+        _igvn.register_new_node_with_optimizer(mask);\n+        _phase->set_ctrl(mask, _phase->get_ctrl(p->at(0)));\n+        _igvn._worklist.push(mask);\n+\n+        \/\/ VectorBlend\n+        vn = new VectorBlendNode(blend_in1, blend_in2, mask);\n+      } else if (n->req() == 3) {\n@@ -3082,79 +2974,0 @@\n-      } else if (is_cmov_pack(p)) {\n-        if (cl->is_rce_post_loop()) {\n-          \/\/ do not refactor of flow in post loop context\n-          return false;\n-        }\n-        if (!n->is_CMove()) {\n-          continue;\n-        }\n-        \/\/ place here CMoveVDNode\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"SWPointer::output: print before CMove vectorization\"); print_loop(false);})\n-        Node* bol = n->in(CMoveNode::Condition);\n-        if (!bol->is_Bool() && bol->Opcode() == Op_ExtractI && bol->req() > 1 ) {\n-          NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"SWPointer::output: %d is not Bool node, trying its in(1) node %d\", bol->_idx, bol->in(1)->_idx); bol->dump(); bol->in(1)->dump();})\n-          bol = bol->in(1); \/\/may be ExtractNode\n-        }\n-\n-        assert(bol->is_Bool(), \"should be BoolNode - too late to bail out!\");\n-        if (!bol->is_Bool()) {\n-          if (do_reserve_copy()) {\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: expected %d bool node, exiting SuperWord\", bol->_idx); bol->dump();})\n-            return false; \/\/and reverse to backup IG\n-          }\n-          ShouldNotReachHere();\n-        }\n-\n-        BoolTest boltest = bol->as_Bool()->_test;\n-        BoolTest::mask cond = boltest._test;\n-        Node* cmp = bol->in(1);\n-        \/\/ When the src order of cmp node and cmove node are the same:\n-        \/\/   cmp: CmpD src1 src2\n-        \/\/   bool: Bool cmp mask\n-        \/\/   cmove: CMoveD bool scr1 src2\n-        \/\/ =====> vectorized, equivalent to\n-        \/\/   cmovev: CMoveVD mask src_vector1 src_vector2\n-        \/\/\n-        \/\/ When the src order of cmp node and cmove node are different:\n-        \/\/   cmp: CmpD src2 src1\n-        \/\/   bool: Bool cmp mask\n-        \/\/   cmove: CMoveD bool scr1 src2\n-        \/\/ =====> equivalent to\n-        \/\/   cmp: CmpD src1 src2\n-        \/\/   bool: Bool cmp negate(mask)\n-        \/\/   cmove: CMoveD bool scr1 src2\n-        \/\/ (Note: when mask is ne or eq, we don't need to negate it even after swapping.)\n-        \/\/ =====> vectorized, equivalent to\n-        \/\/   cmovev: CMoveVD negate(mask) src_vector1 src_vector2\n-        if (cmp->in(2) == n->in(CMoveNode::IfFalse) && cond != BoolTest::ne && cond != BoolTest::eq) {\n-          assert(cmp->in(1) == n->in(CMoveNode::IfTrue), \"cmpnode and cmovenode don't share the same inputs.\");\n-          cond = boltest.negate();\n-        }\n-        Node* cc  = _igvn.intcon((int)cond);\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created intcon in_cc node %d\", cc->_idx); cc->dump();})\n-\n-        Node* src1 = vector_opd(p, 2); \/\/2=CMoveNode::IfFalse\n-        if (src1 == nullptr) {\n-          if (do_reserve_copy()) {\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: src1 should not be null, exiting SuperWord\");})\n-            return false; \/\/and reverse to backup IG\n-          }\n-          ShouldNotReachHere();\n-        }\n-        Node* src2 = vector_opd(p, 3); \/\/3=CMoveNode::IfTrue\n-        if (src2 == nullptr) {\n-          if (do_reserve_copy()) {\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: src2 should not be null, exiting SuperWord\");})\n-            return false; \/\/and reverse to backup IG\n-          }\n-          ShouldNotReachHere();\n-        }\n-        BasicType bt = velt_basic_type(n);\n-        const TypeVect* vt = TypeVect::make(bt, vlen);\n-        assert(bt == T_FLOAT || bt == T_DOUBLE, \"Only vectorization for FP cmovs is supported\");\n-        if (bt == T_FLOAT) {\n-          vn = new CMoveVFNode(cc, src1, src2, vt);\n-        } else {\n-          assert(bt == T_DOUBLE, \"Expected double\");\n-          vn = new CMoveVDNode(cc, src1, src2, vt);\n-        }\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created new CMove node %d: \", vn->_idx); vn->dump();})\n@@ -3519,1 +3332,1 @@\n-          if ((u_pk == nullptr || !is_cmov_pack(u_pk) || use->is_CMove()) && !is_vector_use(use, k)) {\n+          if ((u_pk == nullptr || use->is_CMove()) && !is_vector_use(use, k)) {\n@@ -3969,0 +3782,12 @@\n+  for (int i = 0; i < _block.length(); i++) {\n+    Node* n = _block.at(i);\n+    Node* nn = n;\n+    if (nn->is_Bool() && nn->in(0) == nullptr) {\n+      nn = nn->in(1);\n+      assert(nn->is_Cmp(), \"always have Cmp above Bool\");\n+    }\n+    if (nn->is_Cmp() && nn->in(0) == nullptr) {\n+      nn = nn->in(1);\n+      set_velt_type(n, velt_type(nn));\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":140,"deletions":315,"binary":false,"changes":455,"status":"modified"},{"patch":"@@ -206,18 +206,0 @@\n-class CMoveKit {\n- friend class SuperWord;\n- private:\n-  SuperWord* _sw;\n-  Dict* _dict;\n-  CMoveKit(Arena* a, SuperWord* sw) : _sw(sw)  {_dict = new Dict(cmpkey, hashkey, a);}\n-  void*     _2p(Node* key)        const  { return (void*)(intptr_t)key; } \/\/ 2 conversion functions to make gcc happy\n-  Dict*     dict()                const  { return _dict; }\n-  void map(Node* key, Node_List* val)    { assert(_dict->operator[](_2p(key)) == nullptr, \"key existed\"); _dict->Insert(_2p(key), (void*)val); }\n-  void unmap(Node* key)                  { _dict->Delete(_2p(key)); }\n-  Node_List* pack(Node* key)      const  { return (Node_List*)_dict->operator[](_2p(key)); }\n-  Node* is_Bool_candidate(Node* nd) const; \/\/ if it is the right candidate return corresponding CMove* ,\n-  Node* is_Cmp_candidate(Node* nd) const; \/\/ otherwise return null\n-  \/\/ Determine if the current pack is a cmove candidate that can be vectorized.\n-  bool can_merge_cmove_pack(Node_List* cmove_pk);\n-  void make_cmove_pack(Node_List* cmove_pk);\n-  bool test_cmp_pack(Node_List* cmp_pk, Node_List* cmove_pk);\n-};\/\/class CMoveKit\n@@ -314,1 +296,0 @@\n-  CMoveKit             _cmovev_kit;      \/\/ support for vectorization of CMov\n@@ -466,3 +447,0 @@\n-  bool is_cmov_pack(Node_List* p);\n-  bool is_cmov_pack_internal_node(Node_List* p, Node* nd) { return is_cmov_pack(p) && !nd->is_CMove(); }\n-  static bool is_cmove_fp_opcode(int opc) { return (opc == Op_CMoveF || opc == Op_CMoveD); }\n@@ -619,3 +597,2 @@\n-  \/\/ Merge CMove into new vector-nodes\n-  void merge_packs_to_cmove();\n-  \/\/ Verify that for every pack, all nodes are mutually independent\n+  \/\/ Verify that for every pack, all nodes are mutually independent.\n+  \/\/ Also verify that packset and my_pack are consistent.\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    return (bt == T_FLOAT ? Op_CMoveVF : 0);\n+    return (bt == T_FLOAT ? Op_VectorBlend : 0);\n@@ -87,1 +87,3 @@\n-    return (bt == T_DOUBLE ? Op_CMoveVD : 0);\n+    return (bt == T_DOUBLE ? Op_VectorBlend : 0);\n+  case Op_Bool:\n+    return Op_VectorMaskCmp;\n@@ -575,4 +577,0 @@\n-  case Op_CMoveI:  case Op_CMoveL:  case Op_CMoveF:  case Op_CMoveD:\n-    *start = 2;\n-    *end   = n->req();\n-    break;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -371,16 +371,0 @@\n-\/\/------------------------------CMoveVFNode--------------------------------------\n-\/\/ Vector float conditional move\n-class CMoveVFNode : public VectorNode {\n-public:\n-  CMoveVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------CMoveVDNode--------------------------------------\n-\/\/ Vector double conditional move\n-class CMoveVDNode : public VectorNode {\n-public:\n-  CMoveVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1767,2 +1767,0 @@\n-  declare_c2_type(CMoveVFNode, VectorNode)                                \\\n-  declare_c2_type(CMoveVDNode, VectorNode)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 8289422\n+ * @bug 8289422 8306088\n@@ -35,2 +35,1 @@\n- * @summary Auto-vectorization enhancement to support vector conditional move on AArch64\n- * @requires os.arch==\"aarch64\"\n+ * @summary Auto-vectorization enhancement to support vector conditional move.\n@@ -42,1 +41,1 @@\n-    final private static int SIZE = 3000;\n+    final private static int SIZE = 1024;\n@@ -45,7 +44,0 @@\n-    private static float[] floata = new float[SIZE];\n-    private static float[] floatb = new float[SIZE];\n-    private static float[] floatc = new float[SIZE];\n-    private static double[] doublea = new double[SIZE];\n-    private static double[] doubleb = new double[SIZE];\n-    private static double[] doublec = new double[SIZE];\n-\n@@ -53,2 +45,4 @@\n-        TestFramework.runWithFlags(\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseCMoveUnconditionally\",\n-                                   \"-XX:+UseVectorCmov\", \"-XX:CompileCommand=exclude,*.cmove*\");\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                   \"-XX:+UseCMoveUnconditionally\",\n+                                   \"-XX:+UseVectorCmov\",\n+                                   \"-XX:CompileCommand=compileonly,*.TestVectorConditionalMove.test*\");\n@@ -57,0 +51,1 @@\n+    \/\/ Compare 2 values, and pick one of them\n@@ -97,0 +92,115 @@\n+    \/\/ Extensions: compare 2 values, and pick from 2 consts\n+    private float cmoveFGTforFConst(float a, float b) {\n+        return (a > b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFGEforFConst(float a, float b) {\n+        return (a >= b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFLTforFConst(float a, float b) {\n+        return (a < b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFLEforFConst(float a, float b) {\n+        return (a <= b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFEQforFConst(float a, float b) {\n+        return (a == b) ? 0.1f : -0.1f;\n+    }\n+\n+    private float cmoveFNEQforFConst(float a, float b) {\n+        return (a != b) ? 0.1f : -0.1f;\n+    }\n+\n+    private double cmoveDGTforDConst(double a, double b) {\n+        return (a > b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDGEforDConst(double a, double b) {\n+        return (a >= b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDLTforDConst(double a, double b) {\n+        return (a < b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDLEforDConst(double a, double b) {\n+        return (a <= b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDEQforDConst(double a, double b) {\n+        return (a == b) ? 0.1 : -0.1;\n+    }\n+\n+    private double cmoveDNEQforDConst(double a, double b) {\n+        return (a != b) ? 0.1 : -0.1;\n+    }\n+\n+    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n+    private int cmoveIGTforI(int a, int b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveIGTforL(int a, int b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveIGTforF(int a, int b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveIGTforD(int a, int b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private int cmoveLGTforI(long a, long b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveLGTforL(long a, long b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveLGTforF(long a, long b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveLGTforD(long a, long b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private int cmoveFGTforI(float a, float b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveFGTforL(float a, float b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveFGTforF(float a, float b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveFGTforD(float a, float b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private int cmoveDGTforI(double a, double b, int c, int d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private long cmoveDGTforL(double a, double b, long c, long d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private float cmoveDGTforF(double a, double b, float c, float d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    private double cmoveDGTforD(double a, double b, double c, double d) {\n+        return (a > b) ? c : d;\n+    }\n+\n+    \/\/ Compare 2 values, and pick one of them\n@@ -98,1 +208,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -106,1 +217,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -114,1 +226,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -122,1 +235,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -130,1 +244,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -138,1 +253,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -146,1 +262,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -154,1 +271,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -162,1 +280,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -170,1 +289,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n@@ -177,0 +297,171 @@\n+    \/\/ Extensions: compare 2 values, and pick from 2 consts\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFGTforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFGEforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFLTforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFLEforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFEQforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFNEQforFConst(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDGTforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDGEforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDLTforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDLEforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDEQforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDNEQforDConst(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    \/\/ Extension: Compare 2 ILFD values, and pick from 2 ILFD values\n+    \/\/ Note:\n+    \/\/   To guarantee that CMove is introduced, I need to perform the loads before the branch. To ensure they\n+    \/\/   do not float down into the branches, I compute a value, and store it to r2 (same as r, except that the\n+    \/\/   compilation does not know that).\n+    \/\/   So far, vectorization only works for CMoveF\/D, with same data-width comparison (F\/I for F, D\/L for D).\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n@@ -178,1 +469,126 @@\n-    @IR(failOn = {IRNode.CMOVE_VD})\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveFGTforI(float[] a, float[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveFGTforL(float[] a, float[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFGTforF(float[] a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveFGTforD(float[] a, float[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveDGTforI(double[] a, double[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveDGTforL(double[] a, double[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n+    private static void testCMoveDGTforF(double[] a, double[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDGTforD(double[] a, double[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.VECTOR_MASK_CMP, IRNode.VECTOR_BLEND})\n@@ -180,0 +596,1 @@\n+        double[] doublec = new double[SIZE];\n@@ -186,0 +603,1 @@\n+    @Warmup(0)\n@@ -187,1 +605,5 @@\n-                 \"testCMoveVFGTSwap\", \"testCMoveVFLTSwap\",\"testCMoveVDLESwap\", \"testCMoveVDGESwap\"})\n+                 \"testCMoveVFGTSwap\", \"testCMoveVFLTSwap\",\"testCMoveVDLESwap\", \"testCMoveVDGESwap\",\n+                 \"testCMoveFGTforFConst\", \"testCMoveFGEforFConst\", \"testCMoveFLTforFConst\",\n+                 \"testCMoveFLEforFConst\", \"testCMoveFEQforFConst\", \"testCMoveFNEQforFConst\",\n+                 \"testCMoveDGTforDConst\", \"testCMoveDGEforDConst\", \"testCMoveDLTforDConst\",\n+                 \"testCMoveDLEforDConst\", \"testCMoveDEQforDConst\", \"testCMoveDNEQforDConst\"})\n@@ -189,6 +611,11 @@\n-        for (int i = 0; i < SIZE; i++) {\n-            floata[i] = RANDOM.nextFloat();\n-            floatb[i] = RANDOM.nextFloat();\n-            doublea[i] = RANDOM.nextDouble();\n-            doubleb[i] = RANDOM.nextDouble();\n-        }\n+        float[] floata = new float[SIZE];\n+        float[] floatb = new float[SIZE];\n+        float[] floatc = new float[SIZE];\n+        double[] doublea = new double[SIZE];\n+        double[] doubleb = new double[SIZE];\n+        double[] doublec = new double[SIZE];\n+\n+        init(floata);\n+        init(floatb);\n+        init(doublea);\n+        init(doubleb);\n@@ -210,0 +637,1 @@\n+        \/\/ Ensure we frequently have equals\n@@ -237,0 +665,210 @@\n+\n+        \/\/ Extensions: compare 2 values, and pick from 2 consts\n+        testCMoveFGTforFConst(floata, floatb, floatc);\n+        testCMoveDGTforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFGTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDGTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFGEforFConst(floata, floatb, floatc);\n+        testCMoveDGEforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFGEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDGEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLTforFConst(floata, floatb, floatc);\n+        testCMoveDLTforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLEforFConst(floata, floatb, floatc);\n+        testCMoveDLEforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFEQforFConst(floata, floatb, floatc);\n+        testCMoveDEQforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFEQforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDEQforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFNEQforFConst(floata, floatb, floatc);\n+        testCMoveDNEQforDConst(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFNEQforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDNEQforDConst(doublea[i], doubleb[i]));\n+        }\n+    }\n+\n+    @Warmup(0)\n+    @Run(test = {\"testCMoveIGTforI\",\n+                 \"testCMoveIGTforL\",\n+                 \"testCMoveIGTforF\",\n+                 \"testCMoveIGTforD\",\n+                 \"testCMoveLGTforI\",\n+                 \"testCMoveLGTforL\",\n+                 \"testCMoveLGTforF\",\n+                 \"testCMoveLGTforD\",\n+                 \"testCMoveFGTforI\",\n+                 \"testCMoveFGTforL\",\n+                 \"testCMoveFGTforF\",\n+                 \"testCMoveFGTforD\",\n+                 \"testCMoveDGTforI\",\n+                 \"testCMoveDGTforL\",\n+                 \"testCMoveDGTforF\",\n+                 \"testCMoveDGTforD\"})\n+    private void testCMove_runner_two() {\n+        int[] aI = new int[SIZE];\n+        int[] bI = new int[SIZE];\n+        int[] cI = new int[SIZE];\n+        int[] dI = new int[SIZE];\n+        int[] rI = new int[SIZE];\n+        long[] aL = new long[SIZE];\n+        long[] bL = new long[SIZE];\n+        long[] cL = new long[SIZE];\n+        long[] dL = new long[SIZE];\n+        long[] rL = new long[SIZE];\n+        float[] aF = new float[SIZE];\n+        float[] bF = new float[SIZE];\n+        float[] cF = new float[SIZE];\n+        float[] dF = new float[SIZE];\n+        float[] rF = new float[SIZE];\n+        double[] aD = new double[SIZE];\n+        double[] bD = new double[SIZE];\n+        double[] cD = new double[SIZE];\n+        double[] dD = new double[SIZE];\n+        double[] rD = new double[SIZE];\n+\n+        init(aI);\n+        init(bI);\n+        init(cI);\n+        init(dI);\n+        init(aL);\n+        init(bL);\n+        init(cL);\n+        init(dL);\n+        init(aF);\n+        init(bF);\n+        init(cF);\n+        init(dF);\n+        init(aD);\n+        init(bD);\n+        init(cD);\n+        init(dD);\n+\n+        testCMoveIGTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIGTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveIGTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIGTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveIGTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIGTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveIGTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIGTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLGTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLGTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLGTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLGTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLGTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLGTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLGTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLGTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveFGTforI(aF, bF, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveFGTforI(aF[i], bF[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveFGTforL(aF, bF, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveFGTforL(aF[i], bF[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveFGTforF(aF, bF, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveFGTforD(aF, bF, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveFGTforD(aF[i], bF[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveDGTforI(aD, bD, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveDGTforI(aD[i], bD[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveDGTforL(aD, bD, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveDGTforL(aD[i], bD[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveDGTforF(aD, bD, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveDGTforF(aD[i], bD[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveDGTforD(aD, bD, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveDGTforD(aD[i], bD[i], cD[i], dD[i]));\n+        }\n+    }\n+\n+    private static void init(int[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    private static void init(long[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+    }\n+\n+    private static void init(float[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextFloat();\n+            if (RANDOM.nextInt() % 20 == 0) {\n+                a[i] = Float.NaN;\n+            }\n+        }\n+    }\n+\n+    private static void init(double[] a) {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = RANDOM.nextDouble();\n+            if (RANDOM.nextInt() % 20 == 0) {\n+                a[i] = Double.NaN;\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":669,"deletions":31,"binary":false,"changes":700,"status":"modified"},{"patch":"@@ -307,10 +307,0 @@\n-    public static final String CMOVE_VD = PREFIX + \"CMOVE_VD\" + POSTFIX;\n-    static {\n-        superWordNodes(CMOVE_VD, \"CMoveVD\");\n-    }\n-\n-    public static final String CMOVE_VF = PREFIX + \"CMOVE_VF\" + POSTFIX;\n-    static {\n-        superWordNodes(CMOVE_VF, \"CMoveVF\");\n-    }\n-\n@@ -1281,0 +1271,5 @@\n+    public static final String VECTOR_MASK_CMP = PREFIX + \"VECTOR_MASK_CMP\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_CMP, \"VectorMaskCmp\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"}]}