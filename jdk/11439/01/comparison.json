{"files":[{"patch":"@@ -199,5 +199,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  intptr_t* fp = _cont.entryFP();\n-  *(intptr_t**)(sp - frame::sender_sp_offset) = fp;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,6 +79,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  assert_is_interpreted_and_frame_type_mixed();\n-  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,4 +90,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,6 +70,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/stackChunkFrameStream_arm.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,6 +83,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -202,5 +202,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  intptr_t* fp = _cont.entryFP();\n-  *(intptr_t**)(sp - 2) = fp;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,6 +79,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  assert_is_interpreted_and_frame_type_mixed();\n-  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,4 +90,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,6 +70,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/stackChunkFrameStream_s390.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -202,5 +202,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  intptr_t* fp = _cont.entryFP();\n-  *(intptr_t**)(sp - frame::sender_sp_offset) = fp;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,6 +79,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  assert_is_interpreted_and_frame_type_mixed();\n-  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,4 +90,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,6 +70,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/stackChunkFrameStream_zero.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    StubRoutines::_atomic_xchg_long_entry    = ShouldNotCallThisStub();\n@@ -196,1 +195,0 @@\n-    StubRoutines::_atomic_cmpxchg_byte_entry = ShouldNotCallThisStub();\n@@ -199,1 +197,0 @@\n-    StubRoutines::_atomic_add_long_entry     = ShouldNotCallThisStub();\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -609,3 +609,0 @@\n-  \/\/ !important! make sure all to call thread->set_in_asgct(false) before every return\n-  thread->set_in_asgct(true);\n-\n@@ -669,1 +666,0 @@\n-  thread->set_in_asgct(false);\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,7 +164,0 @@\n-\/\/ NOTE: do *not* use stringStream. this function is called by\n-\/\/       fatal error handlers. if the crash is in native thread,\n-\/\/       stringStream cannot get resource allocated and will SEGV.\n-const char* Abstract_VM_Version::jre_release_version() {\n-  return VERSION_STRING;\n-}\n-\n@@ -284,4 +277,0 @@\n-const char *Abstract_VM_Version::vm_build_user() {\n-  return HOTSPOT_BUILD_USER;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  static const char* vm_build_user();\n@@ -118,1 +117,0 @@\n-  static const char* jre_release_version();\n@@ -169,6 +167,0 @@\n-  \/\/ Number of page sizes efficiently supported by the hardware.  Most chips now\n-  \/\/ support two sizes, thus this default implementation.  Processor-specific\n-  \/\/ subclasses should define new versions to hide this one as needed.  Note\n-  \/\/ that the O\/S may support more sizes, but at most this many are used.\n-  static uint page_size_count() { return 2; }\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4166,32 +4166,0 @@\n-const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {\n-  int count = 0;\n-  const char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->key();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n-char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {\n-  int count = 0;\n-  char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->value();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-  inline void set_path(const char* path) { _path->set_value(path); }\n@@ -177,1 +176,0 @@\n-  void set_invalid()                        { _state = agent_invalid; }\n@@ -595,2 +593,0 @@\n-  static const char* PropertyList_get_key_at(SystemProperty* pl,int index);\n-  static char* PropertyList_get_value_at(SystemProperty* pl,int index);\n@@ -621,1 +617,0 @@\n-  static char* get_jdk_boot_class_path_append() { return _jdk_boot_class_path_append->value(); }\n@@ -626,1 +621,0 @@\n-  static char* get_ext_dirs()     { return _ext_dirs;  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,2 +106,0 @@\n-  static CompiledMethod* enter_special() { return _enter_special; }\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,0 @@\n-  void freeze_fast_init_cont_data(intptr_t* frame_sp);\n@@ -1724,1 +1723,0 @@\n-  void patch_chunk_pd(intptr_t* sp); \/\/ TODO remove\n@@ -1806,2 +1804,0 @@\n-  int thaw_size() const { return _thaw_size; }\n-  int argsize() const { return _argsize; }\n@@ -1868,1 +1864,0 @@\n-  \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -78,4 +78,0 @@\n-\n-  static char* method_name(Method* m) { return m != nullptr ? m->name_and_sig_as_C_string() : nullptr; }\n-  static Method* top_java_frame_method(const frame& f);\n-  static Method* bottom_java_frame_method(const frame& f)  { return frame_method(f); }\n@@ -100,1 +96,0 @@\n-  static int size(const frame& f, InterpreterOopMap* mask);\n@@ -121,1 +116,0 @@\n-  static inline int num_oops(const frame& f);\n@@ -131,2 +125,0 @@\n-  static inline int num_oops(const frame& f);\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,15 +64,0 @@\n-inline Method* ContinuationHelper::Frame::top_java_frame_method(const frame& f) {\n-  Method* m = nullptr;\n-  if (f.is_interpreted_frame()) {\n-    m = f.interpreter_frame_method();\n-  } else if (f.is_compiled_frame()) {\n-    CompiledMethod* cm = f.cb()->as_compiled_method();\n-    ScopeDesc* scope = cm->scope_desc_at(f.pc());\n-    m = scope->method();\n-  } else if (f.is_native_frame()) {\n-    m = f.cb()->as_nmethod()->method();\n-  }\n-\n-  return m;\n-}\n-\n@@ -134,4 +119,0 @@\n-inline int ContinuationHelper::InterpretedFrame::size(const frame&f, InterpreterOopMap* mask) {\n-  return InterpretedFrame::frame_bottom(f) - InterpretedFrame::frame_top(f, mask);\n-}\n-\n@@ -159,5 +140,0 @@\n-inline int ContinuationHelper::NonInterpretedFrame::num_oops(const frame& f) {\n-  assert(!f.is_interpreted_frame(), \"\");\n-  return f.num_oops();\n-}\n-\n@@ -168,5 +144,0 @@\n-inline int ContinuationHelper::CompiledFrame::num_oops(const frame& f) {\n-  assert(CompiledFrame::is_instance(f), \"Not a compiled frame\");\n-  return f.num_oops() + 1;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-\n-  static inline oop name(oop ref);\n@@ -66,1 +64,0 @@\n-  static inline oop target(oop continuation);\n@@ -68,2 +65,0 @@\n-  static inline oop yieldInfo(oop continuation);\n-  static inline void set_yieldInfo(oop continuation, oop value);\n@@ -72,1 +67,0 @@\n-  static inline bool on_local_stack(oop continuation, address adr);\n@@ -133,6 +127,6 @@\n-   static inline oop cont(oop chunk);\n-   static inline void set_cont(oop chunk, oop value);\n-   template<typename P>\n-   static inline void set_cont_raw(oop chunk, oop value);\n-   template<DecoratorSet decorators>\n-   static inline void set_cont_access(oop chunk, oop value);\n+  static inline oop cont(oop chunk);\n+  static inline void set_cont(oop chunk, oop value);\n+  template<typename P>\n+  static inline void set_cont_raw(oop chunk, oop value);\n+  template<DecoratorSet decorators>\n+  static inline void set_cont_access(oop chunk, oop value);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,4 +36,0 @@\n-inline oop jdk_internal_vm_ContinuationScope::name(oop ref) {\n-  return ref->obj_field(_name_offset);\n-}\n-\n@@ -44,4 +40,0 @@\n-inline oop jdk_internal_vm_Continuation::target(oop continuation) {\n-  return continuation->obj_field(_target_offset);\n-}\n-\n@@ -52,8 +44,0 @@\n-inline oop jdk_internal_vm_Continuation::yieldInfo(oop continuation) {\n-  return continuation->obj_field(_yieldInfo_offset);\n-}\n-\n-inline void jdk_internal_vm_Continuation::set_yieldInfo(oop continuation, oop value) {\n-  continuation->obj_field_put(_yieldInfo_offset, value);\n-}\n-\n@@ -101,1 +85,1 @@\n-  return chunk->obj_field(_cont_offset);\n+    return chunk->obj_field(_cont_offset);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-  inline oop parent();\n@@ -116,1 +115,0 @@\n-  inline void set_preempted(bool value);\n@@ -165,4 +163,0 @@\n-inline oop ContinuationWrapper::parent() {\n-  return jdk_internal_vm_Continuation::parent(_continuation);\n-}\n-\n@@ -173,4 +167,0 @@\n-inline void ContinuationWrapper::set_preempted(bool value) {\n-  jdk_internal_vm_Continuation::set_preempted(_continuation, value);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,2 +101,0 @@\n-bool DeoptimizationMarker::_is_active = false;\n-\n@@ -129,1 +127,0 @@\n-\n@@ -136,8 +133,0 @@\n-\n-intptr_t* Deoptimization::UnrollBlock::value_addr_at(int register_number) const {\n-  assert(register_number < RegisterMap::reg_count, \"checking register number\");\n-  return &_register_block[register_number * 2];\n-}\n-\n-\n-\n@@ -153,1 +142,0 @@\n-\n@@ -167,1 +155,0 @@\n-\n@@ -936,1 +923,0 @@\n-  DeoptimizationMarker dm;\n@@ -1658,1 +1644,0 @@\n-  DeoptimizationMarker dm;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -230,3 +230,0 @@\n-    \/\/ Returns where a register is located.\n-    intptr_t* value_addr_at(int register_number) const;\n-\n@@ -236,2 +233,0 @@\n-    address*  frame_pcs()   const { return _frame_pcs ; }\n-    int  unpack_kind()   const { return _unpack_kind; }\n@@ -253,2 +248,0 @@\n-    static int register_block_offset_in_bytes()            { return offset_of(UnrollBlock, _register_block);            }\n-    static int return_type_offset_in_bytes()               { return offset_of(UnrollBlock, _return_type);               }\n@@ -476,9 +469,0 @@\n-\n-class DeoptimizationMarker : StackObj {  \/\/ for profiling\n-  static bool _is_active;\n-public:\n-  DeoptimizationMarker()  { _is_active = true; }\n-  ~DeoptimizationMarker() { _is_active = false; }\n-  static bool is_active() { return _is_active; }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-  static bool deoptimizing_objects_for_all_threads() { return _deoptimizing_objects_for_all_threads; }\n-\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,5 +38,0 @@\n-\n-oop fieldDescriptor::loader() const {\n-  return _cp->pool_holder()->class_loader();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  oop loader()                    const;\n@@ -86,1 +85,0 @@\n-  bool is_public()                const    { return access_flags().is_public(); }\n@@ -89,1 +87,0 @@\n-  bool is_package_private()       const    { return !is_public() && !is_private() && !is_protected(); }\n@@ -94,2 +91,0 @@\n-  bool is_volatile()              const    { return access_flags().is_volatile(); }\n-  bool is_transient()             const    { return access_flags().is_transient(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -776,2 +776,0 @@\n-\n-  int max_locals()  { return _max_locals; }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,3 +213,0 @@\n-  \/\/ the number of oops in the frame for non-interpreted frames\n-  inline int num_oops() const;\n-\n@@ -238,1 +235,0 @@\n-  frame sender_for_native_frame(RegisterMap* map) const;\n@@ -258,14 +254,0 @@\n-  \/\/ accessors for locals\n-  oop obj_at(int offset) const                   { return *obj_at_addr(offset);  }\n-  void obj_at_put(int offset, oop value)         { *obj_at_addr(offset) = value; }\n-\n-  jint int_at(int offset) const                  { return *int_at_addr(offset);  }\n-  void int_at_put(int offset, jint value)        { *int_at_addr(offset) = value; }\n-\n-  oop*      obj_at_addr(int offset) const        { return (oop*)     addr_at(offset); }\n-\n-  oop*      adjusted_obj_at_addr(Method* method, int index) { return obj_at_addr(adjust_offset(method, index)); }\n-\n- private:\n-  jint*    int_at_addr(int offset) const         { return (jint*)    addr_at(offset); }\n-\n@@ -468,1 +450,0 @@\n-  int adjust_offset(Method* method, int index); \/\/ helper for above fn\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -107,7 +107,0 @@\n-inline int frame::num_oops() const {\n-  assert(!is_interpreted_frame(), \"interpreted\");\n-  assert(oop_map() != NULL, \"\");\n-  return oop_map()->num_oops() ;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -216,3 +216,0 @@\n-  \/\/ Number of handles in use\n-  size_t used() const     { return Arena::used() \/ oopSize; }\n-\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,9 +129,0 @@\n-  \/**\n-   * Performs comparison using only the major version, returning negative\n-   * if the major version of 'this' is less than the parameter, 0 if it is\n-   * equal, and a positive value if it is greater.\n-   *\/\n-  int compare_major(int version) const {\n-      return major_version() - version;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  JavaThread*      thread() const           { return _thread; }\n@@ -68,1 +67,0 @@\n-  oop              receiver()               { return _receiver; }\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,1 +386,0 @@\n-  _in_asgct(false),\n@@ -984,24 +983,0 @@\n-bool JavaThread::is_lock_owned_current(address adr) const {\n-  address stack_end = _stack_base - _stack_size;\n-  const ContinuationEntry* ce = vthread_continuation();\n-  address stack_base = ce != nullptr ? (address)ce->entry_sp() : _stack_base;\n-  if (stack_base > adr && adr >= stack_end) {\n-    return true;\n-  }\n-\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-    if (chunk->contains(adr)) {\n-      return true;\n-    }\n-  }\n-\n-  return false;\n-}\n-\n-bool JavaThread::is_lock_owned_carrier(address adr) const {\n-  assert(is_vthread_mounted(), \"\");\n-  address stack_end = _stack_base - _stack_size;\n-  address stack_base = (address)vthread_continuation()->entry_sp();\n-  return stack_base > adr && adr >= stack_end;\n-}\n-\n@@ -1474,4 +1449,0 @@\n-const char* JavaThread::thread_state_name() const {\n-  return _get_thread_state_name(_thread_state);\n-}\n-\n@@ -1912,5 +1883,0 @@\n-oop JavaThread::get_continuation() const {\n-  assert(threadObj() != nullptr, \"must be set\");\n-  return java_lang_Thread::continuation(threadObj());\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-  bool           _in_asgct;                      \/\/ Is set when this JavaThread is handling ASGCT call\n@@ -472,5 +471,0 @@\n- public:\n-  jlong _extentLocal_hash_table_shift;\n-\n-  void allocate_extentLocal_hash_table(int count);\n-\n@@ -598,1 +592,0 @@\n-  oop get_continuation() const;\n@@ -673,2 +666,0 @@\n-  bool is_lock_owned_current(address adr) const; \/\/ virtual if mounted, otherwise whole thread\n-  bool is_lock_owned_carrier(address adr) const;\n@@ -700,1 +691,1 @@\n-  void set_callee_target  (Method* x)          { _callee_target   = x; }\n+  void set_callee_target  (Method* x)            { _callee_target   = x; }\n@@ -706,2 +697,1 @@\n-  Metadata*    vm_result_2() const               { return _vm_result_2; }\n-  void set_vm_result_2  (Metadata* x)          { _vm_result_2   = x; }\n+  void set_vm_result_2  (Metadata* x)            { _vm_result_2   = x; }\n@@ -713,1 +703,0 @@\n-  int  pending_deoptimization() const             { return _pending_deoptimization; }\n@@ -715,1 +704,0 @@\n-  bool has_pending_monitorenter() const           { return _pending_monitorenter; }\n@@ -736,2 +724,0 @@\n-  address  exception_handler_pc() const          { return _exception_handler_pc; }\n-  bool     is_method_handle_return() const       { return _is_method_handle_return == 1; }\n@@ -790,1 +776,0 @@\n-  static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }\n@@ -926,1 +911,0 @@\n-  const char* thread_state_name() const;\n@@ -1047,1 +1031,0 @@\n-  void clear_popframe_forcing_deopt_reexecution()     { _popframe_condition &= ~popframe_force_deopt_reexecution_bit; }\n@@ -1099,1 +1082,0 @@\n-  int   should_post_on_exceptions_flag()  { return _should_post_on_exceptions_flag; }\n@@ -1174,4 +1156,0 @@\n-  \/\/ AsyncGetCallTrace support\n-  inline bool in_asgct(void) {return _in_asgct;}\n-  inline void set_in_asgct(bool value) {_in_asgct = value;}\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":24,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -255,9 +255,0 @@\n-size_t JNIHandles::global_handle_memory_usage() {\n-  return global_handles()->total_memory_usage();\n-}\n-\n-size_t JNIHandles::weak_global_handle_memory_usage() {\n-  return weak_global_handles()->total_memory_usage();\n-}\n-\n-\n@@ -542,15 +533,0 @@\n-\n-\n-size_t JNIHandleBlock::length() const {\n-  size_t result = 1;\n-  for (JNIHandleBlock* current = _next; current != NULL; current = current->_next) {\n-    result++;\n-  }\n-  return result;\n-}\n-\n-\/\/ This method is not thread-safe, i.e., must be called while holding a lock on the\n-\/\/ structure.\n-size_t JNIHandleBlock::memory_usage() const {\n-  return length() * sizeof(JNIHandleBlock);\n-}\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -111,2 +111,0 @@\n-  static size_t global_handle_memory_usage();\n-  static size_t weak_global_handle_memory_usage();\n@@ -183,2 +181,0 @@\n-  size_t length() const;                        \/\/ Length of chain starting with this block\n-  size_t memory_usage() const;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-     static void engage();\n-     static void disengage();\n@@ -41,1 +39,0 @@\n-\n@@ -59,19 +56,0 @@\n-\n-\n-\/*\n- * the disengage() method is responsible for deactivating the periodic\n- * task. This  method is called from before_exit() in java.cpp and is only called\n- * after the WatcherThread has been stopped.\n- *\/\n-void JniPeriodicChecker::disengage() {\n-  if (CheckJNICalls && is_active()) {\n-    \/\/ remove JniPeriodicChecker\n-    _task->disenroll();\n-    delete _task;\n-    _task = NULL;\n-  }\n-}\n-\n-void jniPeriodicChecker_exit() {\n-  if (!CheckJNICalls) return;\n-}\n","filename":"src\/hotspot\/share\/runtime\/jniPeriodicChecker.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-    static void disengage();\n-\n@@ -50,3 +48,0 @@\n-\n-    static void initialize();\n-    static void destroy();\n@@ -55,2 +50,0 @@\n-void jniPeriodicChecker_exit();\n-\n","filename":"src\/hotspot\/share\/runtime\/jniPeriodicChecker.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,16 +61,0 @@\n-\n-#ifdef ASSERT\n-bool KeepStackGCProcessedMark::stack_is_kept_gc_processed(JavaThread* jt) {\n-  if (!Thread::current()->is_Java_thread()) {\n-    assert(SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread(),\n-           \"must be either Java thread or VM thread in a safepoint\");\n-    return true;\n-  }\n-  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n-  if (our_watermark == nullptr) {\n-    return true;\n-  }\n-  StackWatermark* their_watermark = StackWatermarkSet::get(jt, StackWatermarkKind::gc);\n-  return our_watermark->linked_watermark() == their_watermark;\n-}\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\n-  static bool stack_is_kept_gc_processed(JavaThread* jt) NOT_DEBUG({ return true; }) ;\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,3 +51,0 @@\n-  \/\/ Tells whether the monitor chunk is linked into the JavaThread\n-  bool is_linked() const                    { return next() != NULL; }\n-\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  bool is_monitor_deflation_thread() const { return true; }\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-  void   set_next(Mutex *next) { _next = next; }\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,5 +196,0 @@\n-\n-void assert_locked_or_safepoint_or_handshake(const Mutex* lock, const JavaThread* thread) {\n-  if (thread->is_handshake_safe_for(Thread::current())) return;\n-  assert_locked_or_safepoint(lock);\n-}\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -179,2 +179,0 @@\n-char *lock_name(Mutex *mutex);\n-\n@@ -186,1 +184,0 @@\n-void assert_locked_or_safepoint_or_handshake(const Mutex* lock, const JavaThread* thread);\n@@ -191,1 +188,0 @@\n-#define assert_locked_or_safepoint_or_handshake(lock, thread)\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,2 +207,0 @@\n-  static int header_offset_in_bytes()      { return offset_of(ObjectMonitor, _header); }\n-  static int object_offset_in_bytes()      { return offset_of(ObjectMonitor, _object); }\n@@ -270,2 +268,0 @@\n-  \/\/ Get _next_om field with acquire semantics.\n-  ObjectMonitor* next_om_acquire() const;\n@@ -274,6 +270,0 @@\n-  \/\/ Set _next_om field to new_value with release semantics.\n-  void release_set_next_om(ObjectMonitor* new_value);\n-  \/\/ Try to set _next_om field to new_value if the current value matches\n-  \/\/ old_value, using Atomic::cmpxchg(). Otherwise, does not change the\n-  \/\/ _next_om field. Returns the prior value of the _next_om field.\n-  ObjectMonitor* try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -163,5 +163,0 @@\n-\/\/ Get _next_om field with acquire semantics.\n-inline ObjectMonitor* ObjectMonitor::next_om_acquire() const {\n-  return Atomic::load_acquire(&_next_om);\n-}\n-\n@@ -173,12 +168,0 @@\n-\/\/ Set _next_om field to new_value with release semantics.\n-inline void ObjectMonitor::release_set_next_om(ObjectMonitor* new_value) {\n-  Atomic::release_store(&_next_om, new_value);\n-}\n-\n-\/\/ Try to set _next_om field to new_value if the current value matches\n-\/\/ old_value. Otherwise, does not change the _next_om field. Returns\n-\/\/ the prior value of the _next_om field.\n-inline ObjectMonitor* ObjectMonitor::try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value) {\n-  return Atomic::cmpxchg(&_next_om, old_value, new_value);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -587,2 +587,0 @@\n-  static int pd_self_suspend_thread(Thread* thread);\n-\n@@ -1006,1 +1004,0 @@\n-  static void print_statistics();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,23 +34,0 @@\n-class EnvironmentVariable : public CHeapObj<mtInternal> {\n- public:\n-  char* _key;\n-  char* _value;\n-\n-  EnvironmentVariable() {\n-    _key = NULL;\n-    _value = NULL;\n-  }\n-\n-  ~EnvironmentVariable() {\n-    FREE_C_HEAP_ARRAY(char, _key);\n-    FREE_C_HEAP_ARRAY(char, _value);\n-  }\n-\n-  EnvironmentVariable(char* key, char* value) {\n-    _key = key;\n-    _value = value;\n-  }\n-\n-};\n-\n-\n@@ -132,8 +109,0 @@\n-  SystemProcess(int pid, char* name, char* path, char* command_line, SystemProcess* next) {\n-    _pid = pid;\n-    _name = name;\n-    _path = path;\n-    _command_line = command_line;\n-    _next = next;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/os_perf.hpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -193,4 +193,0 @@\n-int PerfLong::format(char* buffer, int length) {\n-  return jio_snprintf(buffer, length, JLONG_FORMAT, *(jlong*)_valuep);\n-}\n-\n@@ -236,4 +232,0 @@\n-int PerfString::format(char* buffer, int length) {\n-  return jio_snprintf(buffer, length, \"%s\", (char*)_valuep);\n-}\n-\n@@ -328,11 +320,0 @@\n-PerfDataList* PerfDataManager::all() {\n-\n-  MutexLocker ml(PerfDataManager_lock);\n-\n-  if (_all == NULL)\n-    return NULL;\n-\n-  PerfDataList* clone = _all->clone();\n-  return clone;\n-}\n-\n@@ -350,11 +331,0 @@\n-PerfDataList* PerfDataManager::constants() {\n-\n-  MutexLocker ml(PerfDataManager_lock);\n-\n-  if (_constants == NULL)\n-    return NULL;\n-\n-  PerfDataList* clone = _constants->clone();\n-  return clone;\n-}\n-\n@@ -461,21 +431,0 @@\n-PerfLongVariable* PerfDataManager::create_long_variable(CounterNS ns,\n-                                                        const char* name,\n-                                                        PerfData::Units u,\n-                                                        jlong* sp, TRAPS) {\n-\n-  \/\/ Sampled counters not supported if UsePerfData is false\n-  if (!UsePerfData) return NULL;\n-\n-  PerfLongVariable* p = new PerfLongVariable(ns, name, u, sp);\n-\n-  if (!p->is_valid()) {\n-    \/\/ allocation of native resources failed.\n-    delete p;\n-    THROW_0(vmSymbols::java_lang_OutOfMemoryError());\n-  }\n-\n-  add_item(p, true);\n-\n-  return p;\n-}\n-\n@@ -522,21 +471,0 @@\n-PerfLongCounter* PerfDataManager::create_long_counter(CounterNS ns,\n-                                                      const char* name,\n-                                                      PerfData::Units u,\n-                                                      jlong* sp, TRAPS) {\n-\n-  \/\/ Sampled counters not supported if UsePerfData is false\n-  if (!UsePerfData) return NULL;\n-\n-  PerfLongCounter* p = new PerfLongCounter(ns, name, u, sp);\n-\n-  if (!p->is_valid()) {\n-    \/\/ allocation of native resources failed.\n-    delete p;\n-    THROW_0(vmSymbols::java_lang_OutOfMemoryError());\n-  }\n-\n-  add_item(p, true);\n-\n-  return p;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -336,4 +336,0 @@\n-\n-    \/\/ returns the value of the data portion of the item in the\n-    \/\/ PerfData memory region formatted as a string.\n-    virtual int format(char* cp, int length) = 0;\n@@ -365,2 +361,0 @@\n-    int format(char* buffer, int length);\n-\n@@ -426,1 +420,0 @@\n-    inline void add(jlong val) { (*(jlong*)_valuep) += val; }\n@@ -513,3 +506,0 @@\n-  public:\n-\n-    int format(char* buffer, int length);\n@@ -630,8 +620,0 @@\n-    \/\/ remove the given PerfData item from this list. When called\n-    \/\/ while iterating over the list, this method will result in a\n-    \/\/ change in the length of the container. The at(int index)\n-    \/\/ method is also impacted by this method as elements with an\n-    \/\/ index greater than the index of the element removed by this\n-    \/\/ method will be shifted down by one.\n-    inline void remove(PerfData *p);\n-\n@@ -671,3 +653,0 @@\n-    \/\/ return the list of all known PerfData items\n-    static PerfDataList* all();\n-    static inline int count();\n@@ -679,4 +658,0 @@\n-    \/\/ return the list of all known PerfData items that have a\n-    \/\/ variability classification of type Constant\n-    static PerfDataList* constants();\n-\n@@ -757,6 +732,0 @@\n-    static PerfStringVariable* create_string_variable(CounterNS ns,\n-                                                      const char* name,\n-                                                      const char *s, TRAPS) {\n-      return create_string_variable(ns, name, 0, s, THREAD);\n-    };\n-\n@@ -774,4 +743,0 @@\n-    static PerfLongVariable* create_long_variable(CounterNS, const char* name,\n-                                                  PerfData::Units u,\n-                                                  jlong* sp, TRAPS);\n-\n@@ -790,9 +755,0 @@\n-    static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,\n-                                                PerfData::Units u, TRAPS) {\n-      return create_long_counter(ns, name, u, (jlong)0, THREAD);\n-    };\n-\n-    static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,\n-                                                PerfData::Units u, jlong* sp,\n-                                                TRAPS);\n-\n@@ -823,5 +779,0 @@\n-    static PerfVariable* create_variable(CounterNS ns, const char* name,\n-                                         PerfData::Units u, jlong* sp, TRAPS) {\n-      return create_long_variable(ns, name, u, sp, THREAD);\n-    }\n-\n@@ -834,5 +785,0 @@\n-    static PerfCounter* create_counter(CounterNS ns, const char* name,\n-                                       PerfData::Units u, jlong ival, TRAPS) {\n-      return create_long_counter(ns, name, u, ival, THREAD);\n-    }\n-\n@@ -844,5 +790,0 @@\n-    static PerfCounter* create_counter(CounterNS ns, const char* name,\n-                                       PerfData::Units u, jlong* sp, TRAPS) {\n-      return create_long_counter(ns, name, u, sp, THREAD);\n-    }\n-\n@@ -903,3 +844,0 @@\n-    inline void suspend() { if (!UsePerfData) return; _t.stop(); }\n-    inline void resume() { if (!UsePerfData) return; _t.start(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -41,4 +41,0 @@\n-inline void PerfDataList::remove(PerfData *p) {\n-  _set->remove(p);\n-}\n-\n@@ -49,4 +45,0 @@\n-inline int PerfDataManager::count() {\n-  return _all->length();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  InstanceKlass* klass() const      { return _klass; }\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,10 +123,0 @@\n-  address trusted_location(VMReg reg) const {\n-    return (address) _location[reg->value()];\n-  }\n-\n-  void verify(RegisterMap& other) {\n-    for (int i = 0; i < reg_count; ++i) {\n-      assert(_location[i] == other._location[i], \"\");\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-   virtual bool is_widen()      { return false; }\n-   virtual bool is_jump_widen() { return false; }\n@@ -76,2 +74,0 @@\n-  bool is_widen()              { return true; }\n-\n@@ -89,2 +85,0 @@\n-  bool is_jump_widen()         { return true; }\n-\n","filename":"src\/hotspot\/share\/runtime\/relocator.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  RelocatorListener() {};\n","filename":"src\/hotspot\/share\/runtime\/relocator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,2 +100,0 @@\n-  uintx* abort_count_addr()               { return &_abort_count; }\n-  uintx* abortX_count_addr()              { return &_abortX_count[0]; }\n","filename":"src\/hotspot\/share\/runtime\/rtmLocking.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,3 +168,0 @@\n-  \/\/ Assembly support\n-  static address address_of_state()             { return (address)&_state; }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-    inline uintptr_t get_polling_page();\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,6 +40,0 @@\n-\/\/ The acquire makes sure reading of polling page is done before\n-\/\/ the reading the handshake operation or the global state\n-inline uintptr_t SafepointMechanism::ThreadData::get_polling_page() {\n-  return Atomic::load_acquire(&_polling_page);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -146,1 +146,0 @@\n-int64_t SharedRuntime::_nof_optimized_calls = 0;\n@@ -152,1 +151,0 @@\n-int64_t SharedRuntime::_nof_optimized_interface_calls = 0;\n@@ -154,1 +152,0 @@\n-int64_t SharedRuntime::_nof_megamorphic_interface_calls = 0;\n@@ -683,11 +680,0 @@\n-\n-oop SharedRuntime::retrieve_receiver( Symbol* sig, frame caller ) {\n-  assert(caller.is_interpreted_frame(), \"\");\n-  int args_size = ArgumentSizeComputer(sig).size() + 1;\n-  assert(args_size <= caller.interpreter_frame_expression_stack_size(), \"receiver must be on interpreter stack\");\n-  oop result = cast_to_oop(*caller.interpreter_frame_tos_at(args_size - 1));\n-  assert(Universe::heap()->is_in(result) && oopDesc::is_oop(result), \"receiver must be an oop\");\n-  return result;\n-}\n-\n-\n@@ -2382,4 +2368,0 @@\n-inline double percent(int x, int y) {\n-  return 100.0 * x \/ MAX2(y, 1);\n-}\n-\n@@ -2473,2 +2455,2 @@\n-  int64_t mono_c = _nof_normal_calls - _nof_optimized_calls - _nof_megamorphic_calls;\n-  int64_t mono_i = _nof_interface_calls - _nof_optimized_interface_calls - _nof_megamorphic_interface_calls;\n+  int64_t mono_c = _nof_normal_calls - _nof_megamorphic_calls;\n+  int64_t mono_i = _nof_interface_calls;\n@@ -2478,1 +2460,0 @@\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- optimized        \", _nof_optimized_calls, percent(_nof_optimized_calls, _nof_normal_calls));\n@@ -2483,1 +2464,0 @@\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- optimized        \", _nof_optimized_interface_calls, percent(_nof_optimized_interface_calls, _nof_interface_calls));\n@@ -2485,1 +2465,0 @@\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- megamorphic      \", _nof_megamorphic_interface_calls, percent(_nof_megamorphic_interface_calls, _nof_interface_calls));\n@@ -2753,4 +2732,0 @@\n-extern \"C\" void unexpected_adapter_call() {\n-  ShouldNotCallThis();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -275,2 +275,0 @@\n-  static oop retrieve_receiver(Symbol* sig, frame caller);\n-\n@@ -559,1 +557,0 @@\n-  static int64_t _nof_optimized_calls;            \/\/ total # of statically-bound calls\n@@ -565,1 +562,0 @@\n-  static int64_t _nof_optimized_interface_calls;  \/\/ total # of statically-bound interface calls\n@@ -567,1 +563,0 @@\n-  static int64_t _nof_megamorphic_interface_calls;\/\/ total # of megamorphic interface calls\n@@ -571,1 +566,0 @@\n-  static address nof_optimized_calls_addr()             { return (address)&_nof_optimized_calls; }\n@@ -576,1 +570,0 @@\n-  static address nof_optimized_interface_calls_addr()   { return (address)&_nof_optimized_interface_calls; }\n@@ -578,1 +571,0 @@\n-  static address nof_megamorphic_interface_calls_addr() { return (address)&_nof_megamorphic_interface_calls; }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -572,6 +572,0 @@\n-ResolvingSignatureStream::ResolvingSignatureStream(fieldDescriptor& field)\n-  : SignatureStream(field.signature(), false)\n-{\n-  initialize_load_origin(field.field_holder());\n-}\n-\n@@ -585,11 +579,0 @@\n-Klass* ResolvingSignatureStream::as_klass_if_loaded(TRAPS) {\n-  Klass* klass = as_klass(CachedOrNull, THREAD);\n-  \/\/ SD::find does not trigger loading, so there should be no throws\n-  \/\/ Still, bad things can happen, so we CHECK_NULL and ask callers\n-  \/\/ to do likewise.\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-  return klass;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -100,8 +100,0 @@\n-  \/\/ Assuming it is either a class name or signature,\n-  \/\/ determine if it in fact cannot be a class name.\n-  \/\/ This means it either starts with '[' or ends with ';'\n-  static bool not_class_name(const Symbol* signature) {\n-    return (signature->starts_with(JVM_SIGNATURE_ARRAY) ||\n-            signature->ends_with(JVM_SIGNATURE_ENDCLASS));\n-  }\n-\n@@ -233,4 +225,0 @@\n-  static bool fp_is_static(fingerprint_t fingerprint) {\n-    assert(fp_is_valid(fingerprint), \"invalid fingerprint\");\n-    return fingerprint & fp_is_static_bit;\n-  }\n@@ -512,1 +500,0 @@\n-  bool is_primitive() const { return is_java_primitive(_type); }\n@@ -605,5 +592,0 @@\n-  ResolvingSignatureStream(fieldDescriptor& field);\n-\n-  Klass* load_origin()       { return _load_origin; }\n-  Handle class_loader()      { need_handles(); return _class_loader; }\n-  Handle protection_domain() { need_handles(); return _protection_domain; }\n@@ -611,1 +593,0 @@\n-  Klass* as_klass_if_loaded(TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -66,4 +66,0 @@\n-  bool is_last() const { return next_sp() >= _end; }\n-\n-  intptr_t* end() { return _end; }\n-  void set_end(intptr_t* end) { _end = end; }\n@@ -72,2 +68,0 @@\n-  intptr_t* end() const { return _end; }\n-\n@@ -78,1 +72,0 @@\n-  NOT_PRODUCT(int index() { return _index; })\n@@ -97,2 +90,0 @@\n-  inline int to_offset(stackChunkOop chunk) const;\n-\n@@ -103,1 +94,0 @@\n-  bool is_deoptimized() const;\n@@ -113,1 +103,0 @@\n-  inline intptr_t* next_sp() const;\n@@ -118,1 +107,0 @@\n-  inline intptr_t* next_sp_for_interpreter_frame() const;\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -239,5 +239,0 @@\n-template <ChunkFrames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::next_sp() const {\n-  return is_interpreted() ? next_sp_for_interpreter_frame() : unextended_sp() + cb()->frame_size();\n-}\n-\n@@ -337,14 +332,0 @@\n-template <ChunkFrames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::to_offset(stackChunkOop chunk) const {\n-  assert(!is_done(), \"\");\n-  return _sp - chunk->start_address();\n-}\n-\n-#ifdef ASSERT\n-template <ChunkFrames frame_kind>\n-bool StackChunkFrameStream<frame_kind>::is_deoptimized() const {\n-  address pc1 = pc();\n-  return is_compiled() && CodeCache::find_oopmap_slot_fast(pc1) < 0 && cb()->as_compiled_method()->is_deopt_pc(pc1);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -217,14 +217,0 @@\n-void StackOverflow::enable_stack_red_zone() {\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  address base = stack_red_zone_base() - stack_red_zone_size();\n-\n-  guarantee(base < stack_base(), \"Error calculating stack red zone\");\n-  guarantee(base < os::current_stack_pointer(), \"Error calculating stack red zone\");\n-\n-  if (!os::guard_memory((char *) base, stack_red_zone_size())) {\n-    warning(\"Attempt to guard stack red zone failed.\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -303,1 +303,0 @@\n-  void enable_stack_red_zone();\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-  StackValueCollection()            { _values = new GrowableArray<StackValue*>(); }\n","filename":"src\/hotspot\/share\/runtime\/stackValueCollection.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -133,1 +133,0 @@\n-  DEBUG_ONLY(StackWatermark* linked_watermark() const { return _linked_watermark; })\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,6 +49,0 @@\n-const char* StubCodeDesc::name_for(address pc) {\n-  StubCodeDesc* p = desc_for(pc);\n-  return p == NULL ? NULL : p->name();\n-}\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-  static const char*   name_for(address pc);     \/\/ returns the name of the code containing pc or NULL\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-address StubRoutines::_atomic_xchg_long_entry                   = NULL;\n-address StubRoutines::_atomic_store_entry                       = NULL;\n@@ -73,1 +71,0 @@\n-address StubRoutines::_atomic_cmpxchg_byte_entry                = NULL;\n@@ -76,1 +73,0 @@\n-address StubRoutines::_atomic_add_long_entry                    = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-  static address _atomic_xchg_long_entry;\n-  static address _atomic_store_entry;\n@@ -149,1 +147,0 @@\n-  static address _atomic_cmpxchg_byte_entry;\n@@ -152,1 +149,0 @@\n-  static address _atomic_add_long_entry;\n@@ -317,2 +313,0 @@\n-  static address atomic_xchg_long_entry()                  { return _atomic_xchg_long_entry; }\n-  static address atomic_store_entry()                      { return _atomic_store_entry; }\n@@ -320,1 +314,0 @@\n-  static address atomic_cmpxchg_byte_entry()               { return _atomic_cmpxchg_byte_entry; }\n@@ -323,1 +316,0 @@\n-  static address atomic_add_long_entry()                   { return _atomic_add_long_entry; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  bool is_done() { return _done; }\n","filename":"src\/hotspot\/share\/runtime\/suspendedThreadTask.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -697,10 +697,0 @@\n-\/\/ No exception are possible in this case as we only use this internally when locking is\n-\/\/ correct and we have to wait until notified - so no interrupts or timeouts.\n-void ObjectSynchronizer::wait_uninterruptibly(Handle obj, JavaThread* current) {\n-  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-  \/\/ field is incremented before ownership is dropped and decremented\n-  \/\/ after ownership is regained.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n-  monitor->wait(0 \/* wait-forever *\/, false \/* not interruptible *\/, current);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,5 +82,0 @@\n-  bool has_entry(void* key) {\n-    PtrList** listpp = _ptrs->get(key);\n-    return listpp != nullptr && *listpp != nullptr;\n-  }\n-\n@@ -162,5 +157,0 @@\n-  \/\/ Special internal-use-only method for use by JVM infrastructure\n-  \/\/ that needs to wait() on a java-level object but must not respond\n-  \/\/ to interrupt requests and doesn't timeout.\n-  static void wait_uninterruptibly(Handle obj, JavaThread* current);\n-\n@@ -269,1 +259,0 @@\n-  void wait_uninterruptibly(JavaThread* current) { ObjectSynchronizer::wait_uninterruptibly(_obj, current); }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -371,8 +371,0 @@\n-ThreadPriority Thread::get_priority(const Thread* const thread) {\n-  ThreadPriority priority;\n-  \/\/ Can return an error!\n-  (void)os::get_priority(thread, priority);\n-  assert(MinPriority <= priority && priority <= MaxPriority, \"non-Java priority found\");\n-  return priority;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,4 +122,0 @@\n-  int nmethod_disarm_value() {\n-    return (int)(uint32_t)_nmethod_disarm_value;\n-  }\n-\n@@ -327,1 +323,0 @@\n-  virtual bool is_monitor_deflation_thread() const   { return false; }\n@@ -366,1 +361,0 @@\n-  static ThreadPriority get_priority(const Thread* const thread);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  void set_bytes_until_sample(size_t bytes)      { _bytes_until_sample = bytes;  }\n","filename":"src\/hotspot\/share\/runtime\/threadHeapSampler.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,2 +125,0 @@\n-  static ThreadsList *acquire_stable_list_fast_path(Thread *self);\n-  static ThreadsList *acquire_stable_list_nested_path(Thread *self);\n@@ -142,1 +140,0 @@\n-  static void verify_hazard_ptr_scanned(Thread *self, ThreadsList *threads);\n@@ -277,11 +274,0 @@\n-  \/\/ Constructor that transfers ownership of the pointer.\n-  SafeThreadsListPtr(SafeThreadsListPtr& other) :\n-    _previous(other._previous),\n-    _thread(other._thread),\n-    _list(other._list),\n-    _has_ref_count(other._has_ref_count),\n-    _needs_release(other._needs_release)\n-  {\n-    other._needs_release = false;\n-  }\n-\n@@ -335,5 +321,0 @@\n-  template <class T>\n-  void threads_do(T *cl) const {\n-    return list()->threads_do(cl);\n-  }\n-\n@@ -381,4 +362,0 @@\n-  ThreadsList *list() const {\n-    return _list;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  void     setDefineClassCount(uint64_t defineClassCount) { _define_class_count = defineClassCount; }\n","filename":"src\/hotspot\/share\/runtime\/threadStatisticalInfo.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -249,6 +249,0 @@\n-void Threads::java_threads_and_vm_thread_do(ThreadClosure* tc) {\n-  assert_locked_or_safepoint(Threads_lock);\n-  java_threads_do(tc);\n-  tc->do_thread(VMThread::vm_thread());\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  static void java_threads_and_vm_thread_do(ThreadClosure* tc);\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  void clear() { _counter = 0; }\n","filename":"src\/hotspot\/share\/runtime\/timer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,8 +70,0 @@\n-\n-  \/\/ Accessors\n-  void set_verbose(bool verbose)  { _verbose = verbose; }\n-  bool verbose() const            { return _verbose;    }\n-\n-  \/\/ Activation\n-  void suspend()  { if (_active) _t.stop();  }\n-  void resume()   { if (_active) _t.start(); }\n","filename":"src\/hotspot\/share\/runtime\/timerTrace.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,19 +65,0 @@\n-vframe::vframe(const frame* fr, JavaThread* thread)\n-: _reg_map(thread,\n-           RegisterMap::UpdateMap::include,\n-           RegisterMap::ProcessFrames::include,\n-           RegisterMap::WalkContinuation::skip),\n-  _thread(thread), _chunk() {\n-  assert(fr != NULL, \"must have frame\");\n-  _fr = *fr;\n-  assert(!_reg_map.in_cont(), \"\");\n-}\n-\n-vframe* vframe::new_vframe(StackFrameStream& fst, JavaThread* thread) {\n-  if (fst.current()->is_runtime_frame()) {\n-    fst.next();\n-  }\n-  guarantee(!fst.is_done(), \"missing caller\");\n-  return new_vframe(fst.current(), fst.register_map(), thread);\n-}\n-\n@@ -129,7 +110,0 @@\n-vframe* vframe::top() const {\n-  vframe* vf = (vframe*) this;\n-  while (!vf->is_top()) vf = vf->sender();\n-  return vf;\n-}\n-\n-\n@@ -298,5 +272,0 @@\n-void interpretedVFrame::set_bcp(u_char* bcp) {\n-  assert(stack_chunk() == NULL, \"Not supported for heap frames\"); \/\/ unsupported for now because seems to be unused\n-  fr().interpreter_frame_set_bcp(bcp);\n-}\n-\n@@ -309,1 +278,0 @@\n-\n@@ -523,16 +491,0 @@\n-\/\/ top-frame will be skipped\n-vframeStream::vframeStream(JavaThread* thread, frame top_frame,\n-                          bool stop_at_java_call_stub) :\n-    vframeStreamCommon(RegisterMap(thread,\n-                                   RegisterMap::UpdateMap::include,\n-                                   RegisterMap::ProcessFrames::include,\n-                                   RegisterMap::WalkContinuation::include)) {\n-  _stop_at_java_call_stub = stop_at_java_call_stub;\n-\n-  \/\/ skip top frame, as it may not be at safepoint\n-  _frame  = top_frame.sender(&_reg_map);\n-  while (!fill_from_frame()) {\n-    _frame = _frame.sender(&_reg_map);\n-  }\n-}\n-\n@@ -770,34 +722,0 @@\n-\n-bool javaVFrame::structural_compare(javaVFrame* other) {\n-  \/\/ Check static part\n-  if (method() != other->method()) return false;\n-  if (bci()    != other->bci())    return false;\n-\n-  \/\/ Check locals\n-  StackValueCollection *locs = locals();\n-  StackValueCollection *other_locs = other->locals();\n-  assert(locs->size() == other_locs->size(), \"sanity check\");\n-  int i;\n-  for(i = 0; i < locs->size(); i++) {\n-    \/\/ it might happen the compiler reports a conflict and\n-    \/\/ the interpreter reports a bogus int.\n-    if (       is_compiled_frame() &&       locs->at(i)->type() == T_CONFLICT) continue;\n-    if (other->is_compiled_frame() && other_locs->at(i)->type() == T_CONFLICT) continue;\n-\n-    if (!locs->at(i)->equal(other_locs->at(i)))\n-      return false;\n-  }\n-\n-  \/\/ Check expressions\n-  StackValueCollection* exprs = expressions();\n-  StackValueCollection* other_exprs = other->expressions();\n-  assert(exprs->size() == other_exprs->size(), \"sanity check\");\n-  for(i = 0; i < exprs->size(); i++) {\n-    if (!exprs->at(i)->equal(other_exprs->at(i)))\n-      return false;\n-  }\n-\n-  return true;\n-}\n-\n-\n@@ -816,9 +734,0 @@\n-\n-void javaVFrame::verify() const {\n-}\n-\n-\n-void interpretedVFrame::verify() const {\n-}\n-\n-\n@@ -831,1 +740,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":0,"deletions":92,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  vframe(const frame* fr, JavaThread* thread);\n@@ -71,1 +70,0 @@\n-  static vframe* new_vframe(StackFrameStream& fst, JavaThread* thread);\n@@ -76,4 +74,0 @@\n-  CompiledMethod*   nm() const {\n-      assert( cb() != NULL && cb()->is_compiled(), \"usage\");\n-      return (CompiledMethod*) cb();\n-  }\n@@ -100,3 +94,0 @@\n-  \/\/ Returns top vframe within same frame (see is_top())\n-  virtual vframe* top() const;\n-\n@@ -138,1 +129,0 @@\n-  javaVFrame(const frame* fr, JavaThread* thread) : vframe(fr, thread) {}\n@@ -161,6 +151,0 @@\n-\n-  \/\/ verify operations\n-  virtual void verify() const;\n-\n-  \/\/ Structural compare\n-  bool structural_compare(javaVFrame* other);\n@@ -191,1 +175,0 @@\n-  void set_bcp(u_char* bcp);\n@@ -203,2 +186,0 @@\n-  \/\/ returns where the parameters starts relative to the frame pointer\n-  int start_of_parameters() const;\n@@ -206,5 +187,0 @@\n-#ifndef PRODUCT\n- public:\n-  \/\/ verify operations\n-  void verify() const;\n-#endif\n@@ -235,7 +211,0 @@\n- public:\n-  \/\/ casting\n-  static entryVFrame* cast(vframe* vf) {\n-    assert(vf == NULL || vf->is_entry_frame(), \"must be entry frame\");\n-    return (entryVFrame*) vf;\n-  }\n-\n@@ -333,1 +302,0 @@\n-  void dont_walk_cont() { _reg_map.set_walk_cont(false); }\n@@ -339,1 +307,0 @@\n-  inline bool is_entry_frame() const;\n@@ -359,3 +326,0 @@\n-  \/\/ top_frame may not be at safepoint, start with sender\n-  vframeStream(JavaThread* thread, frame top_frame, bool stop_at_java_call_stub = false);\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-inline bool vframeStreamCommon::is_entry_frame() const       { return _frame.is_entry_frame(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -550,4 +550,1 @@\n-      if (src == NULL) {\n-        set_location_valid(i, false);\n-      } else {\n-        set_location_valid(i, true);\n+      if (src != NULL) {\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -144,1 +144,0 @@\n-  vframeArray*                 _next;\n@@ -155,1 +154,0 @@\n-  unsigned char                _valid[RegisterMap::reg_count];\n@@ -159,5 +157,0 @@\n-  void fill_in_element(int index, compiledVFrame* vf);\n-\n-  bool is_location_valid(int i) const        { return _valid[i] != 0; }\n-  void set_location_valid(int i, bool valid) { _valid[i] = valid; }\n-\n@@ -186,4 +179,0 @@\n-  \/\/ Accessors for next\n-  vframeArray* next() const                  { return _next; }\n-  void set_next(vframeArray* value)          { _next = value; }\n-\n@@ -195,2 +184,0 @@\n-  address original_pc() const                { return _original.pc(); }\n-\n@@ -199,2 +186,0 @@\n-  frame caller() const                       { return _caller; }\n-\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -538,7 +538,0 @@\n-\n-\n-#ifndef PRODUCT\n-void compiledVFrame::verify() const {\n-  Unimplemented();\n-}\n-#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,5 +101,0 @@\n-\n-#ifndef PRODUCT\n- public:\n-  void verify() const;\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  DeoptimizationMarker dm;\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1074,1 +1074,0 @@\n-  nonstatic_field(vframeArray,                 _next,                                         vframeArray*)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}