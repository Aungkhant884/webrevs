{"files":[{"patch":"@@ -34,0 +34,5 @@\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+\n+import org.testng.Assert;\n@@ -152,0 +157,6 @@\n+    static final List<List<IntFunction<boolean[]>>>\n+        BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS =\n+            Stream.of(BOOLEAN_MASK_GENERATORS.get(0)).\n+                flatMap(fa -> BOOLEAN_MASK_GENERATORS.stream().skip(1).map(\n+                                      fb -> List.of(fa, fb))).collect(Collectors.toList());\n+\n@@ -158,0 +169,35 @@\n+    interface RangeIntOp {\n+        int apply(int i, int min, int max);\n+    }\n+\n+    static int[] fillRangeInts(int s, int min, int max, RangeIntOp f) {\n+        return fillRangeInts(new int[s], min, max, f);\n+    }\n+\n+    static int[] fillRangeInts(int[] a, int min, int max, RangeIntOp f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i, min, max);\n+        }\n+        return a;\n+    }\n+\n+    static final List<List<BiFunction<Integer, Integer, int[]>>>\n+       INT_SHUFFLE_COMPARE_GENERATOR_PAIRS = List.of(\n+           List.of(\n+               withToStringBi(\"shuffle[i]\", (Integer l, Integer m) -> {\n+                   return fillRangeInts(l, 0, m,  (i, _min, _max) -> (i % _max));\n+               }),\n+               withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                   return RAND.ints(l, 0, m).toArray();\n+               })\n+           ),\n+           List.of(\n+               withToStringBi(\"shuffle[i]\", (Integer l, Integer m) -> {\n+                   return fillRangeInts(l, 0, m,  (i, _min, _max) -> (i % _max));\n+               }),\n+               withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                   return RAND.ints(l, 0, m).toArray();\n+               })\n+           )\n+    );\n+\n@@ -190,0 +236,28 @@\n+\n+    public static int[] expectedShuffle(int length, IntUnaryOperator fn) {\n+        int [] a = new int[length];\n+        for (int i = 0; i < length; i++) {\n+            int elem = fn.applyAsInt(i);\n+            int wrapElem = Math.floorMod(elem, length);\n+            if (elem != wrapElem) {\n+                elem = wrapElem - length;\n+            }\n+            a[i] = elem;\n+        }\n+        return a;\n+    }\n+\n+    interface FBooleanBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] a, boolean[] b, boolean[] r, FBooleanBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -45,1 +46,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -167,0 +168,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -939,0 +947,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,47 @@\n+\n+    static void assertArraysEquals(byte[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+    static void assertArraysEquals(byte[] a, byte[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +933,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1074,9 @@\n+    @DataProvider\n+    public Object[][] byteTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1047,0 +1132,1 @@\n+\n@@ -1946,0 +2032,49 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ANDByte128VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Byte128VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void andByte128VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Byte128VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ANDByte128VectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Byte128VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1980,0 +2115,31 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ADDByte128VectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Byte128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ADDByte128VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Byte128VectorTests::ADD);\n+    }\n+\n@@ -3102,0 +3268,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedByte128VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3123,0 +3306,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedByte128VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4609,0 +4809,104 @@\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void ltByte128VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void eqByte128VectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toIntArrayByte128VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toLongArrayByte128VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toDoubleArrayByte128VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toStringByte128VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void hashCodeByte128VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void reinterpretAsBytesByte128VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.reinterpretAsBytes().intoArray(r, i);\n+        }\n+        assertArraysEquals(a, r, 0);\n+    }\n+\n@@ -4688,0 +4992,30 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BroadcastLongByte128VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void blendByte128VectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Byte128VectorTests::blend);\n+    }\n+\n+\n@@ -4723,0 +5057,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousByte128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringByte128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsByte128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Byte128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByte128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByte128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4724,1 +5244,1 @@\n-    static void ElementSizeByte128VectorTests() {\n+    static void ElementSizeByte128VectorTestsSmokeTest() {\n@@ -4731,1 +5251,1 @@\n-    static void VectorShapeByte128VectorTests() {\n+    static void VectorShapeByte128VectorTestsSmokeTest() {\n@@ -4736,0 +5256,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesByte128VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeByte128VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementType() == byte.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeByte128VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Byte.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeByte128VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesByte128VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeByte128VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":563,"deletions":2,"binary":false,"changes":565,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -45,1 +46,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -167,0 +168,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -939,0 +947,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,47 @@\n+\n+    static void assertArraysEquals(byte[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+    static void assertArraysEquals(byte[] a, byte[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +933,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1074,9 @@\n+    @DataProvider\n+    public Object[][] byteTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1047,0 +1132,1 @@\n+\n@@ -1946,0 +2032,49 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ANDByte256VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Byte256VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void andByte256VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Byte256VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ANDByte256VectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Byte256VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1980,0 +2115,31 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ADDByte256VectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Byte256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ADDByte256VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Byte256VectorTests::ADD);\n+    }\n+\n@@ -3102,0 +3268,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedByte256VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3123,0 +3306,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedByte256VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4609,0 +4809,104 @@\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void ltByte256VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void eqByte256VectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toIntArrayByte256VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toLongArrayByte256VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toDoubleArrayByte256VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toStringByte256VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void hashCodeByte256VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void reinterpretAsBytesByte256VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.reinterpretAsBytes().intoArray(r, i);\n+        }\n+        assertArraysEquals(a, r, 0);\n+    }\n+\n@@ -4688,0 +4992,30 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BroadcastLongByte256VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void blendByte256VectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Byte256VectorTests::blend);\n+    }\n+\n+\n@@ -4723,0 +5057,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousByte256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringByte256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsByte256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Byte256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByte256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByte256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4724,1 +5244,1 @@\n-    static void ElementSizeByte256VectorTests() {\n+    static void ElementSizeByte256VectorTestsSmokeTest() {\n@@ -4731,1 +5251,1 @@\n-    static void VectorShapeByte256VectorTests() {\n+    static void VectorShapeByte256VectorTestsSmokeTest() {\n@@ -4736,0 +5256,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesByte256VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeByte256VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementType() == byte.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeByte256VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Byte.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeByte256VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesByte256VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeByte256VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":563,"deletions":2,"binary":false,"changes":565,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -45,1 +46,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -167,0 +168,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -939,0 +947,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,47 @@\n+\n+    static void assertArraysEquals(byte[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+    static void assertArraysEquals(byte[] a, byte[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +933,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1074,9 @@\n+    @DataProvider\n+    public Object[][] byteTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1047,0 +1132,1 @@\n+\n@@ -1946,0 +2032,49 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ANDByte512VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Byte512VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void andByte512VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Byte512VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ANDByte512VectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Byte512VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1980,0 +2115,31 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ADDByte512VectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Byte512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ADDByte512VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Byte512VectorTests::ADD);\n+    }\n+\n@@ -3102,0 +3268,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedByte512VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3123,0 +3306,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedByte512VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4609,0 +4809,104 @@\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void ltByte512VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void eqByte512VectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toIntArrayByte512VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toLongArrayByte512VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toDoubleArrayByte512VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toStringByte512VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void hashCodeByte512VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void reinterpretAsBytesByte512VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.reinterpretAsBytes().intoArray(r, i);\n+        }\n+        assertArraysEquals(a, r, 0);\n+    }\n+\n@@ -4688,0 +4992,30 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BroadcastLongByte512VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void blendByte512VectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Byte512VectorTests::blend);\n+    }\n+\n+\n@@ -4723,0 +5057,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousByte512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringByte512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsByte512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Byte512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByte512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByte512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4724,1 +5244,1 @@\n-    static void ElementSizeByte512VectorTests() {\n+    static void ElementSizeByte512VectorTestsSmokeTest() {\n@@ -4731,1 +5251,1 @@\n-    static void VectorShapeByte512VectorTests() {\n+    static void VectorShapeByte512VectorTestsSmokeTest() {\n@@ -4736,0 +5256,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesByte512VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeByte512VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementType() == byte.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeByte512VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Byte.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeByte512VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesByte512VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeByte512VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":563,"deletions":2,"binary":false,"changes":565,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -45,1 +46,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -167,0 +168,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -939,0 +947,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,47 @@\n+\n+    static void assertArraysEquals(byte[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+    static void assertArraysEquals(byte[] a, byte[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +933,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1074,9 @@\n+    @DataProvider\n+    public Object[][] byteTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1047,0 +1132,1 @@\n+\n@@ -1946,0 +2032,49 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ANDByte64VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Byte64VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void andByte64VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Byte64VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ANDByte64VectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Byte64VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1980,0 +2115,31 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ADDByte64VectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Byte64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ADDByte64VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Byte64VectorTests::ADD);\n+    }\n+\n@@ -3102,0 +3268,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedByte64VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3123,0 +3306,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedByte64VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4609,0 +4809,104 @@\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void ltByte64VectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void eqByte64VectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toIntArrayByte64VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toLongArrayByte64VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toDoubleArrayByte64VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toStringByte64VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void hashCodeByte64VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void reinterpretAsBytesByte64VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.reinterpretAsBytes().intoArray(r, i);\n+        }\n+        assertArraysEquals(a, r, 0);\n+    }\n+\n@@ -4688,0 +4992,30 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BroadcastLongByte64VectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void blendByte64VectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Byte64VectorTests::blend);\n+    }\n+\n+\n@@ -4723,0 +5057,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousByte64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringByte64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsByte64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Byte64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByte64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByte64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4724,1 +5244,1 @@\n-    static void ElementSizeByte64VectorTests() {\n+    static void ElementSizeByte64VectorTestsSmokeTest() {\n@@ -4731,1 +5251,1 @@\n-    static void VectorShapeByte64VectorTests() {\n+    static void VectorShapeByte64VectorTestsSmokeTest() {\n@@ -4736,0 +5256,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesByte64VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeByte64VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementType() == byte.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeByte64VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Byte.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeByte64VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesByte64VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeByte64VectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":563,"deletions":2,"binary":false,"changes":565,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -49,1 +50,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -176,0 +177,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -948,0 +956,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -796,0 +797,47 @@\n+\n+    static void assertArraysEquals(byte[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+    static void assertArraysEquals(byte[] a, byte[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(byte[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -890,0 +938,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1079,9 @@\n+    @DataProvider\n+    public Object[][] byteTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1052,0 +1137,1 @@\n+\n@@ -1951,0 +2037,49 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ANDByteMaxVectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, ByteMaxVectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void andByteMaxVectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, ByteMaxVectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ANDByteMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, ByteMaxVectorTests::AND);\n+    }\n+\n+\n+\n@@ -1985,0 +2120,31 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ADDByteMaxVectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, ByteMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ADDByteMaxVectorTestsBroadcastMaskedLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, ByteMaxVectorTests::ADD);\n+    }\n+\n@@ -3107,0 +3273,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3128,0 +3311,17 @@\n+    @Test(dataProvider = \"byteTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4614,0 +4814,104 @@\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void ltByteMaxVectorTestsBroadcastSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void eqByteMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            VectorMask<Byte> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toIntArrayByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toLongArrayByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toDoubleArrayByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void toStringByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void hashCodeByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            byte subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void reinterpretAsBytesByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+            av.reinterpretAsBytes().intoArray(r, i);\n+        }\n+        assertArraysEquals(a, r, 0);\n+    }\n+\n@@ -4693,0 +4997,30 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BroadcastLongByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ByteVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void blendByteMaxVectorTestsBroadcastLongSmokeTest(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, ByteMaxVectorTests::blend);\n+    }\n+\n+\n@@ -4728,0 +5062,170 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousByteMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringByteMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsByteMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, ByteMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByteMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByteMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4729,1 +5233,1 @@\n-    static void ElementSizeByteMaxVectorTests() {\n+    static void ElementSizeByteMaxVectorTestsSmokeTest() {\n@@ -4736,1 +5240,1 @@\n-    static void VectorShapeByteMaxVectorTests() {\n+    static void VectorShapeByteMaxVectorTestsSmokeTest() {\n@@ -4741,0 +5245,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesByteMaxVectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeByteMaxVectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementType() == byte.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeByteMaxVectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Byte.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeByteMaxVectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesByteMaxVectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(byte.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeByteMaxVectorTestsSmokeTest() {\n+        ByteVector av = ByteVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":547,"deletions":2,"binary":false,"changes":549,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Double> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -354,0 +355,11 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -388,0 +400,17 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -837,0 +866,93 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> INT_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(double[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(double[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n@@ -931,0 +1053,40 @@\n+    @DataProvider\n+    public Object[][] doubletoIntUnaryOpProvider() {\n+        return INT_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubletoLongUnaryOpProvider() {\n+        return LONG_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1044,0 +1206,9 @@\n+    @DataProvider\n+    public Object[][] doubleTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1097,0 +1268,1 @@\n+\n@@ -1704,0 +1876,33 @@\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void ADDDouble128VectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Double128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void ADDDouble128VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Double128VectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2263,0 +2468,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2284,0 +2506,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2306,0 +2545,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_FINITEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2329,0 +2585,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NANMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2352,0 +2625,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4286,0 +4576,83 @@\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void ltDouble128VectorTestsBroadcastSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void eqDouble128VectorTestsBroadcastMaskedSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoIntUnaryOpProvider\")\n+    static void toIntArrayDouble128VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void toLongArrayDouble128VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void toStringDouble128VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void hashCodeDouble128VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4365,0 +4738,30 @@\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void BroadcastLongDouble128VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void blendDouble128VectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Double128VectorTests::blend);\n+    }\n+\n+\n@@ -4400,0 +4803,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousDouble128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringDouble128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsDouble128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Double128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDouble128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDouble128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4401,1 +4990,1 @@\n-    static void ElementSizeDouble128VectorTests() {\n+    static void ElementSizeDouble128VectorTestsSmokeTest() {\n@@ -4408,1 +4997,1 @@\n-    static void VectorShapeDouble128VectorTests() {\n+    static void VectorShapeDouble128VectorTestsSmokeTest() {\n@@ -4413,0 +5002,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesDouble128VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeDouble128VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementType() == double.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeDouble128VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Double.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeDouble128VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesDouble128VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeDouble128VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":632,"deletions":2,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Double> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -354,0 +355,11 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -388,0 +400,17 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -837,0 +866,93 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> INT_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(double[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(double[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n@@ -931,0 +1053,40 @@\n+    @DataProvider\n+    public Object[][] doubletoIntUnaryOpProvider() {\n+        return INT_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubletoLongUnaryOpProvider() {\n+        return LONG_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1044,0 +1206,9 @@\n+    @DataProvider\n+    public Object[][] doubleTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1097,0 +1268,1 @@\n+\n@@ -1704,0 +1876,33 @@\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void ADDDouble256VectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Double256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void ADDDouble256VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Double256VectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2263,0 +2468,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2284,0 +2506,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2306,0 +2545,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_FINITEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2329,0 +2585,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NANMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2352,0 +2625,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4286,0 +4576,83 @@\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void ltDouble256VectorTestsBroadcastSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void eqDouble256VectorTestsBroadcastMaskedSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoIntUnaryOpProvider\")\n+    static void toIntArrayDouble256VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void toLongArrayDouble256VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void toStringDouble256VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void hashCodeDouble256VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4365,0 +4738,30 @@\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void BroadcastLongDouble256VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void blendDouble256VectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Double256VectorTests::blend);\n+    }\n+\n+\n@@ -4400,0 +4803,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousDouble256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringDouble256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsDouble256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Double256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDouble256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDouble256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4401,1 +4990,1 @@\n-    static void ElementSizeDouble256VectorTests() {\n+    static void ElementSizeDouble256VectorTestsSmokeTest() {\n@@ -4408,1 +4997,1 @@\n-    static void VectorShapeDouble256VectorTests() {\n+    static void VectorShapeDouble256VectorTestsSmokeTest() {\n@@ -4413,0 +5002,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesDouble256VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeDouble256VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementType() == double.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeDouble256VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Double.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeDouble256VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesDouble256VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeDouble256VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":632,"deletions":2,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Double> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -354,0 +355,11 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -388,0 +400,17 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -837,0 +866,93 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> INT_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(double[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(double[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n@@ -931,0 +1053,40 @@\n+    @DataProvider\n+    public Object[][] doubletoIntUnaryOpProvider() {\n+        return INT_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubletoLongUnaryOpProvider() {\n+        return LONG_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1044,0 +1206,9 @@\n+    @DataProvider\n+    public Object[][] doubleTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1097,0 +1268,1 @@\n+\n@@ -1704,0 +1876,33 @@\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void ADDDouble512VectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Double512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void ADDDouble512VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Double512VectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2263,0 +2468,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2284,0 +2506,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2306,0 +2545,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_FINITEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2329,0 +2585,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NANMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2352,0 +2625,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4286,0 +4576,83 @@\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void ltDouble512VectorTestsBroadcastSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void eqDouble512VectorTestsBroadcastMaskedSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoIntUnaryOpProvider\")\n+    static void toIntArrayDouble512VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void toLongArrayDouble512VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void toStringDouble512VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void hashCodeDouble512VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4365,0 +4738,30 @@\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void BroadcastLongDouble512VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void blendDouble512VectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Double512VectorTests::blend);\n+    }\n+\n+\n@@ -4400,0 +4803,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousDouble512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringDouble512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsDouble512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Double512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDouble512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDouble512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4401,1 +4990,1 @@\n-    static void ElementSizeDouble512VectorTests() {\n+    static void ElementSizeDouble512VectorTestsSmokeTest() {\n@@ -4408,1 +4997,1 @@\n-    static void VectorShapeDouble512VectorTests() {\n+    static void VectorShapeDouble512VectorTestsSmokeTest() {\n@@ -4413,0 +5002,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesDouble512VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeDouble512VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementType() == double.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeDouble512VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Double.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeDouble512VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesDouble512VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeDouble512VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":632,"deletions":2,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Double> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -354,0 +355,11 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -388,0 +400,17 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -837,0 +866,93 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> INT_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(double[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(double[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n@@ -931,0 +1053,40 @@\n+    @DataProvider\n+    public Object[][] doubletoIntUnaryOpProvider() {\n+        return INT_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubletoLongUnaryOpProvider() {\n+        return LONG_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1044,0 +1206,9 @@\n+    @DataProvider\n+    public Object[][] doubleTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1097,0 +1268,1 @@\n+\n@@ -1704,0 +1876,33 @@\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void ADDDouble64VectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Double64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void ADDDouble64VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Double64VectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2263,0 +2468,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2284,0 +2506,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2306,0 +2545,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_FINITEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2329,0 +2585,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NANMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2352,0 +2625,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4286,0 +4576,83 @@\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void ltDouble64VectorTestsBroadcastSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void eqDouble64VectorTestsBroadcastMaskedSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoIntUnaryOpProvider\")\n+    static void toIntArrayDouble64VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void toLongArrayDouble64VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void toStringDouble64VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void hashCodeDouble64VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4365,0 +4738,30 @@\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void BroadcastLongDouble64VectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void blendDouble64VectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Double64VectorTests::blend);\n+    }\n+\n+\n@@ -4400,0 +4803,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousDouble64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringDouble64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsDouble64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Double64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDouble64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDouble64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4401,1 +4990,1 @@\n-    static void ElementSizeDouble64VectorTests() {\n+    static void ElementSizeDouble64VectorTestsSmokeTest() {\n@@ -4408,1 +4997,1 @@\n-    static void VectorShapeDouble64VectorTests() {\n+    static void VectorShapeDouble64VectorTestsSmokeTest() {\n@@ -4413,0 +5002,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesDouble64VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeDouble64VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementType() == double.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeDouble64VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Double.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeDouble64VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesDouble64VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeDouble64VectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":632,"deletions":2,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -50,1 +51,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -187,0 +188,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -959,0 +967,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Double> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -359,0 +360,11 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -393,0 +405,17 @@\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(double[] a, double[] b, double[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -842,0 +871,93 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> INT_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(double[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<double[]>> LONG_DOUBLE_GENERATORS = List.of(\n+            withToString(\"double[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(-i * 5));\n+            }),\n+            withToString(\"double[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i * 5));\n+            }),\n+            withToString(\"double[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+            }),\n+            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(double[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n@@ -936,0 +1058,40 @@\n+    @DataProvider\n+    public Object[][] doubletoIntUnaryOpProvider() {\n+        return INT_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubletoLongUnaryOpProvider() {\n+        return LONG_DOUBLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1049,0 +1211,9 @@\n+    @DataProvider\n+    public Object[][] doubleTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1102,0 +1273,1 @@\n+\n@@ -1709,0 +1881,33 @@\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void ADDDoubleMaxVectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, DoubleMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void ADDDoubleMaxVectorTestsBroadcastMaskedLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, DoubleMaxVectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2268,0 +2473,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2289,0 +2511,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2311,0 +2550,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_FINITEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2334,0 +2590,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_NANMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2357,0 +2630,17 @@\n+    @Test(dataProvider = \"doubleTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4291,0 +4581,83 @@\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void ltDoubleMaxVectorTestsBroadcastSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleCompareOpProvider\")\n+    static void eqDoubleMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            VectorMask<Double> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoIntUnaryOpProvider\")\n+    static void toIntArrayDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void toLongArrayDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void toStringDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void hashCodeDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            double subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4370,0 +4743,30 @@\n+    @Test(dataProvider = \"doubletoLongUnaryOpProvider\")\n+    static void BroadcastLongDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            DoubleVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void blendDoubleMaxVectorTestsBroadcastLongSmokeTest(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, DoubleMaxVectorTests::blend);\n+    }\n+\n+\n@@ -4405,0 +4808,170 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousDoubleMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringDoubleMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsDoubleMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, DoubleMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDoubleMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDoubleMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4406,1 +4979,1 @@\n-    static void ElementSizeDoubleMaxVectorTests() {\n+    static void ElementSizeDoubleMaxVectorTestsSmokeTest() {\n@@ -4413,1 +4986,1 @@\n-    static void VectorShapeDoubleMaxVectorTests() {\n+    static void VectorShapeDoubleMaxVectorTestsSmokeTest() {\n@@ -4418,0 +4991,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesDoubleMaxVectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeDoubleMaxVectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementType() == double.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeDoubleMaxVectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Double.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeDoubleMaxVectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesDoubleMaxVectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(double.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeDoubleMaxVectorTestsSmokeTest() {\n+        DoubleVector av = DoubleVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":616,"deletions":2,"binary":false,"changes":618,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -354,0 +355,11 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -388,0 +400,17 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -837,0 +866,103 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> INT_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(float[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(float[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(float[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -931,0 +1063,40 @@\n+    @DataProvider\n+    public Object[][] floattoIntUnaryOpProvider() {\n+        return INT_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floattoLongUnaryOpProvider() {\n+        return LONG_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1044,0 +1216,9 @@\n+    @DataProvider\n+    public Object[][] floatTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1097,0 +1278,1 @@\n+\n@@ -1704,0 +1886,33 @@\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void ADDFloat128VectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Float128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void ADDFloat128VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Float128VectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2263,0 +2478,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2284,0 +2516,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2306,0 +2555,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_FINITEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2329,0 +2595,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NANMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2352,0 +2635,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4244,0 +4544,93 @@\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void ltFloat128VectorTestsBroadcastSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void eqFloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoIntUnaryOpProvider\")\n+    static void toIntArrayFloat128VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void toLongArrayFloat128VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toDoubleArrayFloat128VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toStringFloat128VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void hashCodeFloat128VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4323,0 +4716,30 @@\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void BroadcastLongFloat128VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void blendFloat128VectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Float128VectorTests::blend);\n+    }\n+\n+\n@@ -4358,0 +4781,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousFloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringFloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsFloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Float128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloat128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloat128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4359,1 +4968,1 @@\n-    static void ElementSizeFloat128VectorTests() {\n+    static void ElementSizeFloat128VectorTestsSmokeTest() {\n@@ -4366,1 +4975,1 @@\n-    static void VectorShapeFloat128VectorTests() {\n+    static void VectorShapeFloat128VectorTestsSmokeTest() {\n@@ -4371,0 +4980,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesFloat128VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeFloat128VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == float.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeFloat128VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeFloat128VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesFloat128VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeFloat128VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":652,"deletions":2,"binary":false,"changes":654,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -354,0 +355,11 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -388,0 +400,17 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -837,0 +866,103 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> INT_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(float[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(float[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(float[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -931,0 +1063,40 @@\n+    @DataProvider\n+    public Object[][] floattoIntUnaryOpProvider() {\n+        return INT_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floattoLongUnaryOpProvider() {\n+        return LONG_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1044,0 +1216,9 @@\n+    @DataProvider\n+    public Object[][] floatTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1097,0 +1278,1 @@\n+\n@@ -1704,0 +1886,33 @@\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void ADDFloat256VectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Float256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void ADDFloat256VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Float256VectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2263,0 +2478,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2284,0 +2516,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2306,0 +2555,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_FINITEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2329,0 +2595,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NANMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2352,0 +2635,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4244,0 +4544,93 @@\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void ltFloat256VectorTestsBroadcastSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void eqFloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoIntUnaryOpProvider\")\n+    static void toIntArrayFloat256VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void toLongArrayFloat256VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toDoubleArrayFloat256VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toStringFloat256VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void hashCodeFloat256VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4323,0 +4716,30 @@\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void BroadcastLongFloat256VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void blendFloat256VectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Float256VectorTests::blend);\n+    }\n+\n+\n@@ -4358,0 +4781,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousFloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringFloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsFloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Float256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloat256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloat256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4359,1 +4968,1 @@\n-    static void ElementSizeFloat256VectorTests() {\n+    static void ElementSizeFloat256VectorTestsSmokeTest() {\n@@ -4366,1 +4975,1 @@\n-    static void VectorShapeFloat256VectorTests() {\n+    static void VectorShapeFloat256VectorTestsSmokeTest() {\n@@ -4371,0 +4980,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesFloat256VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeFloat256VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == float.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeFloat256VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeFloat256VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesFloat256VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeFloat256VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":652,"deletions":2,"binary":false,"changes":654,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -354,0 +355,11 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -388,0 +400,17 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -837,0 +866,103 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> INT_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(float[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(float[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(float[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -931,0 +1063,40 @@\n+    @DataProvider\n+    public Object[][] floattoIntUnaryOpProvider() {\n+        return INT_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floattoLongUnaryOpProvider() {\n+        return LONG_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1044,0 +1216,9 @@\n+    @DataProvider\n+    public Object[][] floatTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1097,0 +1278,1 @@\n+\n@@ -1704,0 +1886,33 @@\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void ADDFloat512VectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Float512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void ADDFloat512VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Float512VectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2263,0 +2478,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2284,0 +2516,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2306,0 +2555,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_FINITEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2329,0 +2595,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NANMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2352,0 +2635,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4244,0 +4544,93 @@\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void ltFloat512VectorTestsBroadcastSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void eqFloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoIntUnaryOpProvider\")\n+    static void toIntArrayFloat512VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void toLongArrayFloat512VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toDoubleArrayFloat512VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toStringFloat512VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void hashCodeFloat512VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4323,0 +4716,30 @@\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void BroadcastLongFloat512VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void blendFloat512VectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Float512VectorTests::blend);\n+    }\n+\n+\n@@ -4358,0 +4781,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousFloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringFloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsFloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Float512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloat512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloat512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4359,1 +4968,1 @@\n-    static void ElementSizeFloat512VectorTests() {\n+    static void ElementSizeFloat512VectorTestsSmokeTest() {\n@@ -4366,1 +4975,1 @@\n-    static void VectorShapeFloat512VectorTests() {\n+    static void VectorShapeFloat512VectorTestsSmokeTest() {\n@@ -4371,0 +4980,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesFloat512VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeFloat512VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == float.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeFloat512VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeFloat512VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesFloat512VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeFloat512VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":652,"deletions":2,"binary":false,"changes":654,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -354,0 +355,11 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -388,0 +400,17 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -837,0 +866,103 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> INT_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(float[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(float[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(float[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -931,0 +1063,40 @@\n+    @DataProvider\n+    public Object[][] floattoIntUnaryOpProvider() {\n+        return INT_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floattoLongUnaryOpProvider() {\n+        return LONG_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1044,0 +1216,9 @@\n+    @DataProvider\n+    public Object[][] floatTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1097,0 +1278,1 @@\n+\n@@ -1704,0 +1886,33 @@\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void ADDFloat64VectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Float64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void ADDFloat64VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Float64VectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2263,0 +2478,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2284,0 +2516,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2306,0 +2555,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_FINITEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2329,0 +2595,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NANMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2352,0 +2635,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4244,0 +4544,93 @@\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void ltFloat64VectorTestsBroadcastSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void eqFloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoIntUnaryOpProvider\")\n+    static void toIntArrayFloat64VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void toLongArrayFloat64VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toDoubleArrayFloat64VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toStringFloat64VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void hashCodeFloat64VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4323,0 +4716,30 @@\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void BroadcastLongFloat64VectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void blendFloat64VectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Float64VectorTests::blend);\n+    }\n+\n+\n@@ -4358,0 +4781,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousFloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringFloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsFloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Float64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloat64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloat64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4359,1 +4968,1 @@\n-    static void ElementSizeFloat64VectorTests() {\n+    static void ElementSizeFloat64VectorTestsSmokeTest() {\n@@ -4366,1 +4975,1 @@\n-    static void VectorShapeFloat64VectorTests() {\n+    static void VectorShapeFloat64VectorTestsSmokeTest() {\n@@ -4371,0 +4980,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesFloat64VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeFloat64VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == float.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeFloat64VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeFloat64VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesFloat64VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeFloat64VectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":652,"deletions":2,"binary":false,"changes":654,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -50,1 +51,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -187,0 +188,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -959,0 +967,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -359,0 +360,11 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n@@ -393,0 +405,17 @@\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(float[] a, float[] b, float[] r, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n@@ -842,0 +871,103 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> INT_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(float[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<float[]>> LONG_FLOAT_GENERATORS = List.of(\n+            withToString(\"float[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(-i * 5));\n+            }),\n+            withToString(\"float[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i * 5));\n+            }),\n+            withToString(\"float[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+            }),\n+            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(float[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(float[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -936,0 +1068,40 @@\n+    @DataProvider\n+    public Object[][] floattoIntUnaryOpProvider() {\n+        return INT_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floattoLongUnaryOpProvider() {\n+        return LONG_FLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1049,0 +1221,9 @@\n+    @DataProvider\n+    public Object[][] floatTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1102,0 +1283,1 @@\n+\n@@ -1709,0 +1891,33 @@\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void ADDFloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, FloatMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void ADDFloatMaxVectorTestsBroadcastMaskedLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FloatMaxVectorTests::ADD);\n+    }\n+\n+\n+\n@@ -2268,0 +2483,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2289,0 +2521,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2311,0 +2560,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_FINITEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2334,0 +2600,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_NANMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+            }\n+        }\n+    }\n@@ -2357,0 +2640,17 @@\n+    @Test(dataProvider = \"floatTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4249,0 +4549,93 @@\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void ltFloatMaxVectorTestsBroadcastSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatCompareOpProvider\")\n+    static void eqFloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoIntUnaryOpProvider\")\n+    static void toIntArrayFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void toLongArrayFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toDoubleArrayFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void toStringFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void hashCodeFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            float subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4328,0 +4721,30 @@\n+    @Test(dataProvider = \"floattoLongUnaryOpProvider\")\n+    static void BroadcastLongFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            FloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void blendFloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, FloatMaxVectorTests::blend);\n+    }\n+\n+\n@@ -4363,0 +4786,170 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousFloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringFloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsFloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, FloatMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloatMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloatMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4364,1 +4957,1 @@\n-    static void ElementSizeFloatMaxVectorTests() {\n+    static void ElementSizeFloatMaxVectorTestsSmokeTest() {\n@@ -4371,1 +4964,1 @@\n-    static void VectorShapeFloatMaxVectorTests() {\n+    static void VectorShapeFloatMaxVectorTestsSmokeTest() {\n@@ -4376,0 +4969,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesFloatMaxVectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeFloatMaxVectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == float.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeFloatMaxVectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeFloatMaxVectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesFloatMaxVectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(float.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeFloatMaxVectorTestsSmokeTest() {\n+        FloatVector av = FloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":636,"deletions":2,"binary":false,"changes":638,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,37 @@\n+\n+    static void assertArraysEquals(int[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(int[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(int[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +923,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -969,0 +1035,9 @@\n+    @DataProvider\n+    public Object[][] intTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1018,0 +1093,1 @@\n+\n@@ -1922,0 +1998,49 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ANDInt128VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Int128VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void andInt128VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Int128VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ANDInt128VectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Int128VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1956,0 +2081,31 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ADDInt128VectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Int128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ADDInt128VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Int128VectorTests::ADD);\n+    }\n+\n@@ -3078,0 +3234,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedInt128VectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3099,0 +3272,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedInt128VectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4585,0 +4775,93 @@\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void ltInt128VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void eqInt128VectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toIntArrayInt128VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toLongArrayInt128VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toDoubleArrayInt128VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toStringInt128VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void hashCodeInt128VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4664,0 +4947,30 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BroadcastLongInt128VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void blendInt128VectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Int128VectorTests::blend);\n+    }\n+\n+\n@@ -4699,0 +5012,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousInt128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringInt128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsInt128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Int128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeInt128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundInt128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4700,1 +5199,1 @@\n-    static void ElementSizeInt128VectorTests() {\n+    static void ElementSizeInt128VectorTestsSmokeTest() {\n@@ -4707,1 +5206,1 @@\n-    static void VectorShapeInt128VectorTests() {\n+    static void VectorShapeInt128VectorTestsSmokeTest() {\n@@ -4712,0 +5211,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesInt128VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeInt128VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementType() == int.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeInt128VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Integer.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeInt128VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesInt128VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeInt128VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":542,"deletions":2,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,37 @@\n+\n+    static void assertArraysEquals(int[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(int[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(int[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +923,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -969,0 +1035,9 @@\n+    @DataProvider\n+    public Object[][] intTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1018,0 +1093,1 @@\n+\n@@ -1922,0 +1998,49 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ANDInt256VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Int256VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void andInt256VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Int256VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ANDInt256VectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Int256VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1956,0 +2081,31 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ADDInt256VectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Int256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ADDInt256VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Int256VectorTests::ADD);\n+    }\n+\n@@ -3078,0 +3234,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedInt256VectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3099,0 +3272,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedInt256VectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4585,0 +4775,93 @@\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void ltInt256VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void eqInt256VectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toIntArrayInt256VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toLongArrayInt256VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toDoubleArrayInt256VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toStringInt256VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void hashCodeInt256VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4664,0 +4947,30 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BroadcastLongInt256VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void blendInt256VectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Int256VectorTests::blend);\n+    }\n+\n+\n@@ -4699,0 +5012,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousInt256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringInt256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsInt256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Int256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeInt256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundInt256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4700,1 +5199,1 @@\n-    static void ElementSizeInt256VectorTests() {\n+    static void ElementSizeInt256VectorTestsSmokeTest() {\n@@ -4707,1 +5206,1 @@\n-    static void VectorShapeInt256VectorTests() {\n+    static void VectorShapeInt256VectorTestsSmokeTest() {\n@@ -4712,0 +5211,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesInt256VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeInt256VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementType() == int.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeInt256VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Integer.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeInt256VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesInt256VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeInt256VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":542,"deletions":2,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,37 @@\n+\n+    static void assertArraysEquals(int[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(int[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(int[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +923,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -969,0 +1035,9 @@\n+    @DataProvider\n+    public Object[][] intTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1018,0 +1093,1 @@\n+\n@@ -1922,0 +1998,49 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ANDInt512VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Int512VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void andInt512VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Int512VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ANDInt512VectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Int512VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1956,0 +2081,31 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ADDInt512VectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Int512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ADDInt512VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Int512VectorTests::ADD);\n+    }\n+\n@@ -3078,0 +3234,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedInt512VectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3099,0 +3272,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedInt512VectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4585,0 +4775,93 @@\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void ltInt512VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void eqInt512VectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toIntArrayInt512VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toLongArrayInt512VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toDoubleArrayInt512VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toStringInt512VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void hashCodeInt512VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4664,0 +4947,30 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BroadcastLongInt512VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void blendInt512VectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Int512VectorTests::blend);\n+    }\n+\n+\n@@ -4699,0 +5012,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousInt512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringInt512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsInt512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Int512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeInt512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundInt512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4700,1 +5199,1 @@\n-    static void ElementSizeInt512VectorTests() {\n+    static void ElementSizeInt512VectorTestsSmokeTest() {\n@@ -4707,1 +5206,1 @@\n-    static void VectorShapeInt512VectorTests() {\n+    static void VectorShapeInt512VectorTestsSmokeTest() {\n@@ -4712,0 +5211,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesInt512VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeInt512VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementType() == int.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeInt512VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Integer.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeInt512VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesInt512VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeInt512VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":542,"deletions":2,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,37 @@\n+\n+    static void assertArraysEquals(int[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(int[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(int[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +923,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -969,0 +1035,9 @@\n+    @DataProvider\n+    public Object[][] intTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1018,0 +1093,1 @@\n+\n@@ -1922,0 +1998,49 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ANDInt64VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Int64VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void andInt64VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Int64VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ANDInt64VectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Int64VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1956,0 +2081,31 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ADDInt64VectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Int64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ADDInt64VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Int64VectorTests::ADD);\n+    }\n+\n@@ -3078,0 +3234,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedInt64VectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3099,0 +3272,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedInt64VectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4585,0 +4775,93 @@\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void ltInt64VectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void eqInt64VectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toIntArrayInt64VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toLongArrayInt64VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toDoubleArrayInt64VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toStringInt64VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void hashCodeInt64VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4664,0 +4947,30 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BroadcastLongInt64VectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void blendInt64VectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Int64VectorTests::blend);\n+    }\n+\n+\n@@ -4699,0 +5012,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousInt64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringInt64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsInt64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Int64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeInt64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundInt64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4700,1 +5199,1 @@\n-    static void ElementSizeInt64VectorTests() {\n+    static void ElementSizeInt64VectorTestsSmokeTest() {\n@@ -4707,1 +5206,1 @@\n-    static void VectorShapeInt64VectorTests() {\n+    static void VectorShapeInt64VectorTestsSmokeTest() {\n@@ -4712,0 +5211,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesInt64VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeInt64VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementType() == int.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeInt64VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Integer.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeInt64VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesInt64VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeInt64VectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":542,"deletions":2,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -50,1 +51,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -187,0 +188,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -959,0 +967,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -796,0 +797,37 @@\n+\n+    static void assertArraysEquals(int[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(int[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(int[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -890,0 +928,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -974,0 +1040,9 @@\n+    @DataProvider\n+    public Object[][] intTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1023,0 +1098,1 @@\n+\n@@ -1927,0 +2003,49 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ANDIntMaxVectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, IntMaxVectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void andIntMaxVectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, IntMaxVectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ANDIntMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, IntMaxVectorTests::AND);\n+    }\n+\n+\n+\n@@ -1961,0 +2086,31 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ADDIntMaxVectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, IntMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ADDIntMaxVectorTestsBroadcastMaskedLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, IntMaxVectorTests::ADD);\n+    }\n+\n@@ -3083,0 +3239,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3104,0 +3277,17 @@\n+    @Test(dataProvider = \"intTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4590,0 +4780,93 @@\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void ltIntMaxVectorTestsBroadcastSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void eqIntMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            VectorMask<Integer> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toIntArrayIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toLongArrayIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toDoubleArrayIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void toStringIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void hashCodeIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4669,0 +4952,30 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BroadcastLongIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            IntVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void blendIntMaxVectorTestsBroadcastLongSmokeTest(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, IntMaxVectorTests::blend);\n+    }\n+\n+\n@@ -4704,0 +5017,170 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousIntMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringIntMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsIntMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, IntMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeIntMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundIntMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4705,1 +5188,1 @@\n-    static void ElementSizeIntMaxVectorTests() {\n+    static void ElementSizeIntMaxVectorTestsSmokeTest() {\n@@ -4712,1 +5195,1 @@\n-    static void VectorShapeIntMaxVectorTests() {\n+    static void VectorShapeIntMaxVectorTestsSmokeTest() {\n@@ -4717,0 +5200,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesIntMaxVectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeIntMaxVectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementType() == int.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeIntMaxVectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Integer.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeIntMaxVectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesIntMaxVectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(int.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeIntMaxVectorTestsSmokeTest() {\n+        IntVector av = IntVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":526,"deletions":2,"binary":false,"changes":528,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -748,0 +749,70 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<long[]>> INT_LONG_GENERATORS = List.of(\n+            withToString(\"long[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-i * 5));\n+            }),\n+            withToString(\"long[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i * 5));\n+            }),\n+            withToString(\"long[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+            }),\n+            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(long[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(long[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(long[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -842,0 +913,34 @@\n+    @DataProvider\n+    public Object[][] longtoIntUnaryOpProvider() {\n+        return INT_LONG_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -955,0 +1060,9 @@\n+    @DataProvider\n+    public Object[][] longTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1004,0 +1118,1 @@\n+\n@@ -1904,0 +2019,49 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ANDLong128VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Long128VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void andLong128VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Long128VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ANDLong128VectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Long128VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1938,0 +2102,31 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ADDLong128VectorTestsBroadcastLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Long128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ADDLong128VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Long128VectorTests::ADD);\n+    }\n+\n@@ -3060,0 +3255,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedLong128VectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3081,0 +3293,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedLong128VectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4495,0 +4724,136 @@\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void ltLong128VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void eqLong128VectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longtoIntUnaryOpProvider\")\n+    static void toIntArrayLong128VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toLongArrayLong128VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toDoubleArrayLong128VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toStringLong128VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void hashCodeLong128VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceLongLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEquals(a, r, ra,\n+                Long128VectorTests::ADDReduce, Long128VectorTests::ADDReduceAll);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ADDReduceLongLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEqualsMasked(a, r, ra, mask,\n+                Long128VectorTests::ADDReduceMasked, Long128VectorTests::ADDReduceAllMasked);\n+    }\n+\n@@ -4530,0 +4895,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousLong128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringLong128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsLong128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Long128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4531,1 +5082,1 @@\n-    static void ElementSizeLong128VectorTests() {\n+    static void ElementSizeLong128VectorTestsSmokeTest() {\n@@ -4538,1 +5089,1 @@\n-    static void VectorShapeLong128VectorTests() {\n+    static void VectorShapeLong128VectorTestsSmokeTest() {\n@@ -4543,0 +5094,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesLong128VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeLong128VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementType() == long.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeLong128VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Long.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeLong128VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesLong128VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeLong128VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":594,"deletions":2,"binary":false,"changes":596,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -748,0 +749,70 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<long[]>> INT_LONG_GENERATORS = List.of(\n+            withToString(\"long[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-i * 5));\n+            }),\n+            withToString(\"long[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i * 5));\n+            }),\n+            withToString(\"long[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+            }),\n+            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(long[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(long[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(long[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -842,0 +913,34 @@\n+    @DataProvider\n+    public Object[][] longtoIntUnaryOpProvider() {\n+        return INT_LONG_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -955,0 +1060,9 @@\n+    @DataProvider\n+    public Object[][] longTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1004,0 +1118,1 @@\n+\n@@ -1904,0 +2019,49 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ANDLong256VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Long256VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void andLong256VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Long256VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ANDLong256VectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Long256VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1938,0 +2102,31 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ADDLong256VectorTestsBroadcastLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Long256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ADDLong256VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Long256VectorTests::ADD);\n+    }\n+\n@@ -3060,0 +3255,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedLong256VectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3081,0 +3293,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedLong256VectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4495,0 +4724,136 @@\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void ltLong256VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void eqLong256VectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longtoIntUnaryOpProvider\")\n+    static void toIntArrayLong256VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toLongArrayLong256VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toDoubleArrayLong256VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toStringLong256VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void hashCodeLong256VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceLongLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEquals(a, r, ra,\n+                Long256VectorTests::ADDReduce, Long256VectorTests::ADDReduceAll);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ADDReduceLongLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEqualsMasked(a, r, ra, mask,\n+                Long256VectorTests::ADDReduceMasked, Long256VectorTests::ADDReduceAllMasked);\n+    }\n+\n@@ -4530,0 +4895,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousLong256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringLong256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsLong256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Long256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4531,1 +5082,1 @@\n-    static void ElementSizeLong256VectorTests() {\n+    static void ElementSizeLong256VectorTestsSmokeTest() {\n@@ -4538,1 +5089,1 @@\n-    static void VectorShapeLong256VectorTests() {\n+    static void VectorShapeLong256VectorTestsSmokeTest() {\n@@ -4543,0 +5094,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesLong256VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeLong256VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementType() == long.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeLong256VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Long.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeLong256VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesLong256VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeLong256VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":594,"deletions":2,"binary":false,"changes":596,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -748,0 +749,70 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<long[]>> INT_LONG_GENERATORS = List.of(\n+            withToString(\"long[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-i * 5));\n+            }),\n+            withToString(\"long[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i * 5));\n+            }),\n+            withToString(\"long[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+            }),\n+            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(long[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(long[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(long[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -842,0 +913,34 @@\n+    @DataProvider\n+    public Object[][] longtoIntUnaryOpProvider() {\n+        return INT_LONG_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -955,0 +1060,9 @@\n+    @DataProvider\n+    public Object[][] longTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1004,0 +1118,1 @@\n+\n@@ -1904,0 +2019,49 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ANDLong512VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Long512VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void andLong512VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Long512VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ANDLong512VectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Long512VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1938,0 +2102,31 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ADDLong512VectorTestsBroadcastLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Long512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ADDLong512VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Long512VectorTests::ADD);\n+    }\n+\n@@ -3060,0 +3255,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedLong512VectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3081,0 +3293,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedLong512VectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4495,0 +4724,136 @@\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void ltLong512VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void eqLong512VectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longtoIntUnaryOpProvider\")\n+    static void toIntArrayLong512VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toLongArrayLong512VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toDoubleArrayLong512VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toStringLong512VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void hashCodeLong512VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceLongLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEquals(a, r, ra,\n+                Long512VectorTests::ADDReduce, Long512VectorTests::ADDReduceAll);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ADDReduceLongLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEqualsMasked(a, r, ra, mask,\n+                Long512VectorTests::ADDReduceMasked, Long512VectorTests::ADDReduceAllMasked);\n+    }\n+\n@@ -4530,0 +4895,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousLong512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringLong512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsLong512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Long512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4531,1 +5082,1 @@\n-    static void ElementSizeLong512VectorTests() {\n+    static void ElementSizeLong512VectorTestsSmokeTest() {\n@@ -4538,1 +5089,1 @@\n-    static void VectorShapeLong512VectorTests() {\n+    static void VectorShapeLong512VectorTestsSmokeTest() {\n@@ -4543,0 +5094,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesLong512VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeLong512VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementType() == long.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeLong512VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Long.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeLong512VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesLong512VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeLong512VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":594,"deletions":2,"binary":false,"changes":596,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -748,0 +749,70 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<long[]>> INT_LONG_GENERATORS = List.of(\n+            withToString(\"long[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-i * 5));\n+            }),\n+            withToString(\"long[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i * 5));\n+            }),\n+            withToString(\"long[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+            }),\n+            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(long[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(long[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(long[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -842,0 +913,34 @@\n+    @DataProvider\n+    public Object[][] longtoIntUnaryOpProvider() {\n+        return INT_LONG_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -955,0 +1060,9 @@\n+    @DataProvider\n+    public Object[][] longTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1004,0 +1118,1 @@\n+\n@@ -1904,0 +2019,49 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ANDLong64VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Long64VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void andLong64VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Long64VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ANDLong64VectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Long64VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1938,0 +2102,31 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ADDLong64VectorTestsBroadcastLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Long64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ADDLong64VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Long64VectorTests::ADD);\n+    }\n+\n@@ -3060,0 +3255,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedLong64VectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3081,0 +3293,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedLong64VectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4495,0 +4724,136 @@\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void ltLong64VectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void eqLong64VectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longtoIntUnaryOpProvider\")\n+    static void toIntArrayLong64VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toLongArrayLong64VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toDoubleArrayLong64VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toStringLong64VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void hashCodeLong64VectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceLongLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEquals(a, r, ra,\n+                Long64VectorTests::ADDReduce, Long64VectorTests::ADDReduceAll);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ADDReduceLongLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEqualsMasked(a, r, ra, mask,\n+                Long64VectorTests::ADDReduceMasked, Long64VectorTests::ADDReduceAllMasked);\n+    }\n+\n@@ -4530,0 +4895,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousLong64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringLong64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsLong64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Long64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4531,1 +5082,1 @@\n-    static void ElementSizeLong64VectorTests() {\n+    static void ElementSizeLong64VectorTestsSmokeTest() {\n@@ -4538,1 +5089,1 @@\n-    static void VectorShapeLong64VectorTests() {\n+    static void VectorShapeLong64VectorTestsSmokeTest() {\n@@ -4543,0 +5094,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesLong64VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeLong64VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementType() == long.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeLong64VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Long.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeLong64VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesLong64VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeLong64VectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":594,"deletions":2,"binary":false,"changes":596,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -50,1 +51,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -187,0 +188,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -959,0 +967,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -753,0 +754,70 @@\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<long[]>> INT_LONG_GENERATORS = List.of(\n+            withToString(\"long[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-i * 5));\n+            }),\n+            withToString(\"long[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i * 5));\n+            }),\n+            withToString(\"long[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+            }),\n+            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(long[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(long[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(long[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -847,0 +918,34 @@\n+    @DataProvider\n+    public Object[][] longtoIntUnaryOpProvider() {\n+        return INT_LONG_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -960,0 +1065,9 @@\n+    @DataProvider\n+    public Object[][] longTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1009,0 +1123,1 @@\n+\n@@ -1909,0 +2024,49 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ANDLongMaxVectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, LongMaxVectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void andLongMaxVectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, LongMaxVectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ANDLongMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, LongMaxVectorTests::AND);\n+    }\n+\n+\n+\n@@ -1943,0 +2107,31 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ADDLongMaxVectorTestsBroadcastLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, LongMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ADDLongMaxVectorTestsBroadcastMaskedLongSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, LongMaxVectorTests::ADD);\n+    }\n+\n@@ -3065,0 +3260,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3086,0 +3298,17 @@\n+    @Test(dataProvider = \"longTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4500,0 +4729,136 @@\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void ltLongMaxVectorTestsBroadcastSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void eqLongMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            VectorMask<Long> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longtoIntUnaryOpProvider\")\n+    static void toIntArrayLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toLongArrayLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toDoubleArrayLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void toStringLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void hashCodeLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            long subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceLongLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEquals(a, r, ra,\n+                LongMaxVectorTests::ADDReduce, LongMaxVectorTests::ADDReduceAll);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ADDReduceLongLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEqualsMasked(a, r, ra, mask,\n+                LongMaxVectorTests::ADDReduceMasked, LongMaxVectorTests::ADDReduceAllMasked);\n+    }\n+\n@@ -4535,0 +4900,170 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousLongMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringLongMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsLongMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, LongMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4536,1 +5071,1 @@\n-    static void ElementSizeLongMaxVectorTests() {\n+    static void ElementSizeLongMaxVectorTestsSmokeTest() {\n@@ -4543,1 +5078,1 @@\n-    static void VectorShapeLongMaxVectorTests() {\n+    static void VectorShapeLongMaxVectorTestsSmokeTest() {\n@@ -4548,0 +5083,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesLongMaxVectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeLongMaxVectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementType() == long.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeLongMaxVectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Long.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeLongMaxVectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesLongMaxVectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(long.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeLongMaxVectorTestsSmokeTest() {\n+        LongVector av = LongVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":578,"deletions":2,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,34 @@\n+\n+    @Test(dataProvider = \"classesProvider\")\n+    void testVectorShape(Class<?> c) {\n+        VectorSpecies<?> species = null;\n+        int elemSize = 0;\n+        if (c == byte.class) {\n+            species = ByteVector.SPECIES_PREFERRED;\n+            elemSize = Byte.SIZE;\n+        } else if (c == short.class) {\n+            species = ShortVector.SPECIES_PREFERRED;\n+            elemSize = Short.SIZE;\n+        } else if (c == int.class) {\n+            species = IntVector.SPECIES_PREFERRED;\n+            elemSize = Integer.SIZE;\n+        } else if (c == long.class) {\n+            species = LongVector.SPECIES_PREFERRED;\n+            elemSize = Long.SIZE;\n+        } else if (c == float.class) {\n+            species = FloatVector.SPECIES_PREFERRED;\n+            elemSize = Float.SIZE;\n+        } else if (c == double.class) {\n+            species = DoubleVector.SPECIES_PREFERRED;\n+            elemSize = Double.SIZE;\n+        } else {\n+            throw new IllegalArgumentException(\"Bad vector element type: \" + c.getName());\n+        }\n+        VectorSpecies largestSpecies = VectorSpecies.ofLargestShape(c);\n+        VectorShape largestShape = VectorShape.forBitSize(VectorSupport.getMaxLaneCount(c) * elemSize);\n+\n+        System.out.println(\"class = \"+c+\"; largest species = \"+largestSpecies+\"; maxSize=\"+VectorSupport.getMaxLaneCount(c));\n+        Assert.assertEquals(largestSpecies.vectorShape(), largestShape);\n+        Assert.assertEquals(largestSpecies.length(), VectorSupport.getMaxLaneCount(c));\n+        Assert.assertEquals(largestSpecies.length(), Math.max(species.length(), VectorSupport.getMaxLaneCount(c)));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/PreferredSpeciesTest.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,37 @@\n+\n+    static void assertArraysEquals(short[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(short[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +923,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1064,9 @@\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1047,0 +1122,1 @@\n+\n@@ -1946,0 +2022,49 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ANDShort128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Short128VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void andShort128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Short128VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ANDShort128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Short128VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1980,0 +2105,31 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDShort128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Short128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDShort128VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Short128VectorTests::ADD);\n+    }\n+\n@@ -3102,0 +3258,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedShort128VectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3123,0 +3296,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedShort128VectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4609,0 +4799,93 @@\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltShort128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqShort128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toIntArrayShort128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toLongArrayShort128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayShort128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringShort128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeShort128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4688,0 +4971,30 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastLongShort128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendShort128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Short128VectorTests::blend);\n+    }\n+\n+\n@@ -4723,0 +5036,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousShort128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringShort128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsShort128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Short128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShort128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShort128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4724,1 +5223,1 @@\n-    static void ElementSizeShort128VectorTests() {\n+    static void ElementSizeShort128VectorTestsSmokeTest() {\n@@ -4731,1 +5230,1 @@\n-    static void VectorShapeShort128VectorTests() {\n+    static void VectorShapeShort128VectorTestsSmokeTest() {\n@@ -4736,0 +5235,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesShort128VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeShort128VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementType() == short.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeShort128VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Short.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeShort128VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesShort128VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeShort128VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":542,"deletions":2,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,37 @@\n+\n+    static void assertArraysEquals(short[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(short[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +923,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1064,9 @@\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1047,0 +1122,1 @@\n+\n@@ -1946,0 +2022,49 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ANDShort256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Short256VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void andShort256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Short256VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ANDShort256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Short256VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1980,0 +2105,31 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDShort256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Short256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDShort256VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Short256VectorTests::ADD);\n+    }\n+\n@@ -3102,0 +3258,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedShort256VectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3123,0 +3296,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedShort256VectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4609,0 +4799,93 @@\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltShort256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqShort256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toIntArrayShort256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toLongArrayShort256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayShort256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringShort256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeShort256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4688,0 +4971,30 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastLongShort256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendShort256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Short256VectorTests::blend);\n+    }\n+\n+\n@@ -4723,0 +5036,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousShort256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringShort256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsShort256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Short256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShort256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShort256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4724,1 +5223,1 @@\n-    static void ElementSizeShort256VectorTests() {\n+    static void ElementSizeShort256VectorTestsSmokeTest() {\n@@ -4731,1 +5230,1 @@\n-    static void VectorShapeShort256VectorTests() {\n+    static void VectorShapeShort256VectorTestsSmokeTest() {\n@@ -4736,0 +5235,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesShort256VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeShort256VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementType() == short.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeShort256VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Short.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeShort256VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesShort256VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeShort256VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":542,"deletions":2,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,37 @@\n+\n+    static void assertArraysEquals(short[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(short[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +923,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1064,9 @@\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1047,0 +1122,1 @@\n+\n@@ -1946,0 +2022,49 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ANDShort512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Short512VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void andShort512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Short512VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ANDShort512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Short512VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1980,0 +2105,31 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDShort512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Short512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDShort512VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Short512VectorTests::ADD);\n+    }\n+\n@@ -3102,0 +3258,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedShort512VectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3123,0 +3296,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedShort512VectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4609,0 +4799,93 @@\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltShort512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqShort512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toIntArrayShort512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toLongArrayShort512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayShort512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringShort512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeShort512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4688,0 +4971,30 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastLongShort512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendShort512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Short512VectorTests::blend);\n+    }\n+\n+\n@@ -4723,0 +5036,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousShort512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringShort512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsShort512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Short512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShort512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShort512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4724,1 +5223,1 @@\n-    static void ElementSizeShort512VectorTests() {\n+    static void ElementSizeShort512VectorTestsSmokeTest() {\n@@ -4731,1 +5230,1 @@\n-    static void VectorShapeShort512VectorTests() {\n+    static void VectorShapeShort512VectorTestsSmokeTest() {\n@@ -4736,0 +5235,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesShort512VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeShort512VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementType() == short.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeShort512VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Short.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeShort512VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesShort512VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeShort512VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":542,"deletions":2,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -46,1 +47,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -178,0 +179,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -950,0 +958,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -791,0 +792,37 @@\n+\n+    static void assertArraysEquals(short[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(short[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -885,0 +923,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1064,9 @@\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1047,0 +1122,1 @@\n+\n@@ -1946,0 +2022,49 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ANDShort64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Short64VectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void andShort64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, Short64VectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ANDShort64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, Short64VectorTests::AND);\n+    }\n+\n+\n+\n@@ -1980,0 +2105,31 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDShort64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, Short64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDShort64VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Short64VectorTests::ADD);\n+    }\n+\n@@ -3102,0 +3258,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedShort64VectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3123,0 +3296,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedShort64VectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4609,0 +4799,93 @@\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltShort64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqShort64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toIntArrayShort64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toLongArrayShort64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayShort64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringShort64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeShort64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4688,0 +4971,30 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastLongShort64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendShort64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, Short64VectorTests::blend);\n+    }\n+\n+\n@@ -4723,0 +5036,186 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousShort64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringShort64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsShort64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Short64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShort64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShort64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4724,1 +5223,1 @@\n-    static void ElementSizeShort64VectorTests() {\n+    static void ElementSizeShort64VectorTestsSmokeTest() {\n@@ -4731,1 +5230,1 @@\n-    static void VectorShapeShort64VectorTests() {\n+    static void VectorShapeShort64VectorTestsSmokeTest() {\n@@ -4736,0 +5235,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesShort64VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeShort64VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementType() == short.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeShort64VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Short.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeShort64VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesShort64VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeShort64VectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":542,"deletions":2,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -50,1 +51,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -187,0 +188,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -959,0 +967,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -796,0 +797,37 @@\n+\n+    static void assertArraysEquals(short[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n+\n+    static void assertArraysEquals(short[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+\n@@ -890,0 +928,28 @@\n+\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1069,9 @@\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1052,0 +1127,1 @@\n+\n@@ -1951,0 +2027,49 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ANDShortMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, ShortMaxVectorTests::AND);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void andShortMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, ShortMaxVectorTests::and);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ANDShortMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(a, b, r, mask, ShortMaxVectorTests::AND);\n+    }\n+\n+\n+\n@@ -1985,0 +2110,31 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDShortMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, ShortMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDShortMaxVectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(a, b, r, mask, ShortMaxVectorTests::ADD);\n+    }\n+\n@@ -3107,0 +3263,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+            }\n+        }\n+    }\n@@ -3128,0 +3301,17 @@\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+            }\n+        }\n+    }\n@@ -4614,0 +4804,93 @@\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltShortMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqShortMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            VectorMask<Short> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toIntArrayShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toLongArrayShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n@@ -4693,0 +4976,30 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastLongShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            ShortVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendShortMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, ShortMaxVectorTests::blend);\n+    }\n+\n+\n@@ -4728,0 +5041,170 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousShortMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringShortMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsShortMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, ShortMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShortMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShortMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -4729,1 +5212,1 @@\n-    static void ElementSizeShortMaxVectorTests() {\n+    static void ElementSizeShortMaxVectorTestsSmokeTest() {\n@@ -4736,1 +5219,1 @@\n-    static void VectorShapeShortMaxVectorTests() {\n+    static void VectorShapeShortMaxVectorTestsSmokeTest() {\n@@ -4741,0 +5224,41 @@\n+\n+    @Test\n+    static void ShapeWithLanesShortMaxVectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeShortMaxVectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementType() == short.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeShortMaxVectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Short.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeShortMaxVectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesShortMaxVectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(short.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeShortMaxVectorTestsSmokeTest() {\n+        ShortVector av = ShortVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":526,"deletions":2,"binary":false,"changes":528,"status":"modified"},{"patch":"@@ -429,1 +429,3 @@\n-gen_binary_alu_bcst_long_op \"OR\"    \"a | b\"   \"BITWISE\"\n+gen_binary_alu_bcst_op \"AND+and\"    \"a \\& b\"   \"BITWISE\"\n+gen_binary_alu_bcst_long_op \"OR\"     \"a | b\"   \"BITWISE\"\n+gen_binary_alu_bcst_long_op \"ADD\"    \"a + b\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-#if[!Long]\n@@ -3,0 +2,121 @@\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void lt$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void eq$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+#if[byteOrShort]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+#else[byteOrShort]\n+#if[Int]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+#else[Int]\n+    @Test(dataProvider = \"$type$toIntUnaryOpProvider\")\n+#end[Int]\n+#end[byteOrShort]\n+    static void toIntArray$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            int [] r = av.toIntArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+#if[FP]\n+    @Test(dataProvider = \"$type$toLongUnaryOpProvider\")\n+#else[FP]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+#end[FP]\n+    static void toLongArray$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            long [] r = av.toLongArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+\n+#if[!Double]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void toDoubleArray$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            double [] r = av.toDoubleArray();\n+            assertArraysEquals(a, r, i);\n+        }\n+    }\n+#end[!Double]\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void toString$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            $type$ subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void hashCode$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            $type$ subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+#if[byte]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void reinterpretAsBytes$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.reinterpretAsBytes().intoArray(r, i);\n+        }\n+        assertArraysEquals(a, r, 0);\n+    }\n+#end[byte]\n+\n+#if[!Long]\n@@ -81,0 +201,33 @@\n+\n+#if[FP]\n+    @Test(dataProvider = \"$type$toLongUnaryOpProvider\")\n+#else[FP]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+#end[FP]\n+    static void BroadcastLong$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void blend$vectorteststype$BroadcastLongSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(a, b, r, mask, $vectorteststype$::blend);\n+    }\n@@ -83,0 +236,44 @@\n+#if[Long]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ADDReduceLong$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEquals(a, r, ra,\n+                $vectorteststype$::ADDReduce, $vectorteststype$::ADDReduceAll);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void ADDReduceLong$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEqualsMasked(a, r, ra, mask,\n+                $vectorteststype$::ADDReduceMasked, $vectorteststype$::ADDReduceAllMasked);\n+    }\n+#end[Long]\n+\n@@ -126,0 +323,188 @@\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneous$vectorteststype$SmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToString$vectorteststype$SmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEquals$vectorteststype$SmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEquals$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEq$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, $vectorteststype$::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCode$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCount$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrue$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+#if[!MaxBit]\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLong$vectorteststype$SmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+    }\n+#end[!MaxBit]\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRange$vectorteststype$SmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBound$vectorteststype$SmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -127,1 +512,1 @@\n-    static void ElementSize$vectorteststype$() {\n+    static void ElementSize$vectorteststype$SmokeTest() {\n@@ -134,1 +519,1 @@\n-    static void VectorShape$vectorteststype$() {\n+    static void VectorShape$vectorteststype$SmokeTest() {\n@@ -139,0 +524,41 @@\n+\n+    @Test\n+    static void ShapeWithLanes$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes($type$.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementType$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        assert(av.species().elementType() == $type$.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSize$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        assert(av.species().elementSize() == $Wideboxtype$.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorType$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanes$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes($type$.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShape$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":429,"deletions":3,"binary":false,"changes":432,"status":"modified"},{"patch":"@@ -22,0 +22,17 @@\n+    @Test(dataProvider = \"$type$TestOpMaskProvider\")\n+    static void [[TEST]]Masked$vectorteststype$SmokeTest(IntFunction<$type$[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.[[TEST]], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Test.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import java.util.Objects;\n@@ -385,1 +386,0 @@\n-#if[!FP]\n@@ -397,1 +397,0 @@\n-#end[!FP]\n@@ -432,1 +431,0 @@\n-#if[!FP]\n@@ -450,1 +448,0 @@\n-#end[!FP]\n@@ -902,0 +899,125 @@\n+#if[!Int]\n+#if[!byteOrShort]\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<$type$[]>> INT_$TYPE$_GENERATORS = List.of(\n+            withToString(\"$type$[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(-i * 5));\n+            }),\n+            withToString(\"$type$[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i * 5));\n+            }),\n+            withToString(\"$type$[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+            }),\n+            withToString(\"$type$[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)intCornerCaseValue(i));\n+            })\n+    );\n+#end[!byteOrShort]\n+#end[!Int]\n+\n+    static void assertArraysEquals($type$[] a, int[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+#if[!Long]\n+#if[FP]\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<$type$[]>> LONG_$TYPE$_GENERATORS = List.of(\n+            withToString(\"$type$[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(-i * 5));\n+            }),\n+            withToString(\"$type$[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i * 5));\n+            }),\n+            withToString(\"$type$[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+            }),\n+            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)longCornerCaseValue(i));\n+            })\n+    );\n+#end[FP]\n+#end[!Long]\n+\n+#if[byte]\n+    static void assertArraysEquals($type$[] a, $type$[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+#end[byte]\n+\n+    static void assertArraysEquals($type$[] a, long[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+#if[!Double]\n+    static void assertArraysEquals($type$[] a, double[] r, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+#end[!Double]\n+\n+\n@@ -996,0 +1118,46 @@\n+#if[!Int]\n+#if[!byteOrShort]\n+    @DataProvider\n+    public Object[][] $type$toIntUnaryOpProvider() {\n+        return INT_$TYPE$_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+#end[!byteOrShort]\n+#end[!Int]\n+\n+#if[FP]\n+    @DataProvider\n+    public Object[][] $type$toLongUnaryOpProvider() {\n+        return LONG_$TYPE$_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+#end[FP]\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1111,0 +1279,9 @@\n+    @DataProvider\n+    public Object[][] $type$TestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1179,0 +1356,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":182,"deletions":4,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.incubator.vector.VectorShuffle;\n@@ -60,1 +61,1 @@\n-import java.util.function.IntFunction;\n+import java.util.function.*;\n@@ -206,0 +207,7 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -982,0 +990,26 @@\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<$Boxtype$> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(a, r);\n+       }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"}]}