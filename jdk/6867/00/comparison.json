{"files":[{"patch":"@@ -2960,0 +2960,5 @@\n+void G1CollectedHeap::clear_region_bitmap(HeapRegion* hr) {\n+  MemRegion mr(hr->bottom(), hr->end());\n+  concurrent_mark()->clear_range_in_prev_bitmap(mr);\n+}\n+\n@@ -2966,2 +2971,1 @@\n-    MemRegion mr(hr->bottom(), hr->end());\n-    concurrent_mark()->clear_range_in_prev_bitmap(mr);\n+    clear_region_bitmap(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -625,0 +625,2 @@\n+  void clear_region_bitmap(HeapRegion* hr);\n+\n@@ -1255,0 +1257,3 @@\n+  \/\/ Mark the live object that failed evacuation in the correct bitmap(s).\n+  inline void mark_evac_failure_object(const oop obj, uint worker_id) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n@@ -250,0 +251,7 @@\n+inline void G1CollectedHeap::mark_evac_failure_object(const oop obj, uint worker_id) const {\n+    \/\/ All objects failing evacuation are live. What we'll do is\n+    \/\/ that we'll update the prev marking info so that they are\n+    \/\/ all under PTAMS and explicitly marked.\n+    _cm->par_mark_in_prev_bitmap(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -566,1 +566,1 @@\n-  inline void mark_in_prev_bitmap(oop p);\n+  inline void par_mark_in_prev_bitmap(oop p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,3 +271,2 @@\n-inline void G1ConcurrentMark::mark_in_prev_bitmap(oop p) {\n-  assert(!_prev_mark_bitmap->is_marked(p), \"sanity\");\n- _prev_mark_bitmap->mark(p);\n+inline void G1ConcurrentMark::par_mark_in_prev_bitmap(oop p) {\n+  _prev_mark_bitmap->par_mark(p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-class RemoveSelfForwardPtrObjClosure: public ObjectClosure {\n+class RemoveSelfForwardPtrObjClosure {\n@@ -63,1 +63,1 @@\n-  \/\/ Iterate over the live objects in the region to find self-forwarded objects\n+  \/\/ Handle the marked objects in the region. These are self-forwarded objects\n@@ -69,1 +69,1 @@\n-  void do_object(oop obj) {\n+  size_t apply(oop obj) {\n@@ -78,6 +78,3 @@\n-    \/\/ We consider all objects that we find self-forwarded to be\n-    \/\/ live. What we'll do is that we'll update the prev marking\n-    \/\/ info so that they are all under PTAMS and explicitly marked.\n-    if (!_cm->is_marked_in_prev_bitmap(obj)) {\n-      _cm->mark_in_prev_bitmap(obj);\n-    }\n+\n+    \/\/ Zapping clears the bitmap, make sure it didn't clear to much.\n+    assert(_cm->is_marked_in_prev_bitmap(obj), \"should be correctly marked\");\n@@ -95,1 +92,1 @@\n-      _cm->mark_in_next_bitmap(_worker_id, _hr, obj);\n+      _cm->mark_in_next_bitmap(_worker_id, obj);\n@@ -105,0 +102,1 @@\n+    return obj_size;\n@@ -164,2 +162,4 @@\n-    \/\/ Iterates evac failure objs which are recorded during evacuation.\n-    hr->process_and_drop_evac_failure_objs(&rspc);\n+\n+    \/\/ All objects that failed evacuation has been marked in the prev bitmap.\n+    \/\/ Use the bitmap to apply the above closure to all failing objects.\n+    hr->apply_to_marked_objects(const_cast<G1CMBitMap*>(_g1h->concurrent_mark()->prev_mark_bitmap()), &rspc);\n@@ -184,1 +184,0 @@\n-      _g1h->verifier()->check_bitmaps(\"Self-Forwarding Ptr Removal\", hr);\n@@ -194,0 +193,1 @@\n+      _g1h->verifier()->check_bitmaps(\"Self-Forwarding Ptr Removal\", hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"utilities\/quickSort.hpp\"\n-\n-\n-const G1SegmentedArrayAllocOptions G1EvacFailureObjectsSet::_alloc_options =\n-  G1SegmentedArrayAllocOptions((uint)sizeof(OffsetInRegion), SegmentLength, UINT_MAX, Alignment);\n-\n-G1SegmentedArrayFreeList<mtGC> G1EvacFailureObjectsSet::_free_segment_list;\n-\n-#ifdef ASSERT\n-void G1EvacFailureObjectsSet::assert_is_valid_offset(size_t offset) const {\n-  const uint max_offset = 1u << (HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n-  assert(offset < max_offset, \"must be, but is \" SIZE_FORMAT, offset);\n-}\n-#endif\n-\n-oop G1EvacFailureObjectsSet::from_offset(OffsetInRegion offset) const {\n-  assert_is_valid_offset(offset);\n-  return cast_to_oop(_bottom + offset);\n-}\n-\n-G1EvacFailureObjectsSet::OffsetInRegion G1EvacFailureObjectsSet::to_offset(oop obj) const {\n-  const HeapWord* o = cast_from_oop<const HeapWord*>(obj);\n-  size_t offset = pointer_delta(o, _bottom);\n-  assert(obj == from_offset(static_cast<OffsetInRegion>(offset)), \"must be\");\n-  return static_cast<OffsetInRegion>(offset);\n-}\n-\n-G1EvacFailureObjectsSet::G1EvacFailureObjectsSet(uint region_idx, HeapWord* bottom) :\n-  DEBUG_ONLY(_region_idx(region_idx) COMMA)\n-  _bottom(bottom),\n-  _offsets(&_alloc_options, &_free_segment_list)  {\n-  assert(HeapRegion::LogOfHRGrainBytes < 32, \"must be\");\n-}\n-\n-\/\/ Helper class to join, sort and iterate over the previously collected segmented\n-\/\/ array of objects that failed evacuation.\n-class G1EvacFailureObjectsIterationHelper {\n-  typedef G1EvacFailureObjectsSet::OffsetInRegion OffsetInRegion;\n-\n-  G1EvacFailureObjectsSet* _objects_set;\n-  const G1SegmentedArray<OffsetInRegion, mtGC>* _segments;\n-  OffsetInRegion* _offset_array;\n-  uint _array_length;\n-\n-  static int order_oop(OffsetInRegion a, OffsetInRegion b) {\n-    return static_cast<int>(a-b);\n-  }\n-\n-  void join_and_sort() {\n-    _segments->iterate_segments(*this);\n-\n-    QuickSort::sort(_offset_array, _array_length, order_oop, true);\n-  }\n-\n-  void iterate(ObjectClosure* closure) {\n-    for (uint i = 0; i < _array_length; i++) {\n-      oop cur = _objects_set->from_offset(_offset_array[i]);\n-      closure->do_object(cur);\n-    }\n-  }\n-\n-public:\n-  G1EvacFailureObjectsIterationHelper(G1EvacFailureObjectsSet* collector) :\n-    _objects_set(collector),\n-    _segments(&_objects_set->_offsets),\n-    _offset_array(nullptr),\n-    _array_length(0) { }\n-\n-  void process_and_drop(ObjectClosure* closure) {\n-    uint num = _segments->num_allocated_slots();\n-    _offset_array = NEW_C_HEAP_ARRAY(OffsetInRegion, num, mtGC);\n-\n-    join_and_sort();\n-    assert(_array_length == num, \"must be %u, %u\", _array_length, num);\n-    iterate(closure);\n-\n-    FREE_C_HEAP_ARRAY(OffsetInRegion, _offset_array);\n-  }\n-\n-  \/\/ Callback of G1SegmentedArray::iterate_segments\n-  void do_segment(G1SegmentedArraySegment<mtGC>* segment, uint length) {\n-    segment->copy_to(&_offset_array[_array_length]);\n-    _array_length += length;\n-  }\n-};\n-\n-void G1EvacFailureObjectsSet::process_and_drop(ObjectClosure* closure) {\n-  assert_at_safepoint();\n-\n-  G1EvacFailureObjectsIterationHelper helper(this);\n-  helper.process_and_drop(closure);\n-\n-  _offsets.drop_all();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.cpp","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n-#define SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n-\n-#include \"gc\/g1\/g1SegmentedArray.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"oops\/oop.hpp\"\n-\n-class G1EvacFailureObjectsIterationHelper;\n-\n-\/\/ This class collects addresses of objects that failed evacuation in a specific\n-\/\/ heap region.\n-\/\/ Provides sorted iteration of these objects for processing during the remove\n-\/\/ self forwards phase.\n-class G1EvacFailureObjectsSet {\n-  friend class G1EvacFailureObjectsIterationHelper;\n-\n-public:\n-  \/\/ Storage type of an object that failed evacuation within a region. Given\n-  \/\/ heap region size and possible object locations within a region, it is\n-  \/\/ sufficient to use an uint here to save some space instead of full pointers.\n-  typedef uint OffsetInRegion;\n-\n-private:\n-  static const uint SegmentLength = 256;\n-  static const uint Alignment = 4;\n-\n-  static const G1SegmentedArrayAllocOptions _alloc_options;\n-\n-  \/\/ This free list is shared among evacuation failure process in all regions.\n-  static G1SegmentedArrayFreeList<mtGC> _free_segment_list;\n-\n-  DEBUG_ONLY(const uint _region_idx;)\n-\n-  \/\/ Region bottom\n-  const HeapWord* _bottom;\n-\n-  \/\/ Offsets within region containing objects that failed evacuation.\n-  G1SegmentedArray<OffsetInRegion, mtGC> _offsets;\n-\n-  void assert_is_valid_offset(size_t offset) const NOT_DEBUG_RETURN;\n-  \/\/ Converts between an offset within a region and an oop address.\n-  oop from_offset(OffsetInRegion offset) const;\n-  OffsetInRegion to_offset(oop obj) const;\n-\n-public:\n-  G1EvacFailureObjectsSet(uint region_idx, HeapWord* bottom);\n-\n-  \/\/ Record an object that failed evacuation.\n-  inline void record(oop obj);\n-\n-  \/\/ Apply the given ObjectClosure to all objects that failed evacuation and\n-  \/\/ empties the list after processing.\n-  \/\/ Objects are passed in increasing address order.\n-  void process_and_drop(ObjectClosure* closure);\n-};\n-\n-\n-#endif \/\/SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.hpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n-#define SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n-\n-#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-\n-void G1EvacFailureObjectsSet::record(oop obj) {\n-  assert(obj != NULL, \"must be\");\n-  assert(_region_idx == G1CollectedHeap::heap()->heap_region_containing(obj)->hrm_index(), \"must be\");\n-  OffsetInRegion* e = _offsets.allocate();\n-  *e = to_offset(obj);\n-}\n-\n-#endif \/\/SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.inline.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -61,0 +61,5 @@\n+void G1FullGCCompactTask::G1CompactRegionClosure::clear_bitmap(oop obj) {\n+  assert(_bitmap->is_marked(obj), \"Should only compact marked objects\");\n+  _bitmap->clear(obj);\n+}\n+\n@@ -65,0 +70,1 @@\n+    clear_bitmap(obj);\n@@ -77,0 +83,1 @@\n+  clear_bitmap(obj);\n@@ -85,0 +92,4 @@\n+    \/\/ The compaction closure not only copies the object to the new\n+    \/\/ location, but also clears the bitmap for it. This is needed\n+    \/\/ for bitmap verification as well as for being able to use the\n+    \/\/ prev_bitmap for evacuation failures.\n@@ -87,5 +98,0 @@\n-    \/\/ Clear the liveness information for this region if necessary i.e. if we actually look at it\n-    \/\/ for bitmap verification. Otherwise it is sufficient that we move the TAMS to bottom().\n-    if (G1VerifyBitmaps) {\n-      collector()->mark_bitmap()->clear_region(hr);\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-\n+    void clear_bitmap(oop object);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -619,3 +619,5 @@\n-    \/\/ Records evac failure objs, this will help speed up iteration\n-    \/\/ of these objs later in *remove self forward* phase of post evacuation.\n-    r->record_evac_failure_obj(old);\n+\n+    \/\/ Objects failing evacuation will turn in to old objects since the regions\n+    \/\/ is relabeled as such. We mark the failing objects in the prev bitmap and\n+    \/\/ later use it to handle all failed objects.\n+    _g1h->mark_evac_failure_object(old, _worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1262,0 +1262,33 @@\n+  \/\/ Closure to clear the prev bitmap for any old region in the CSet. This is\n+  \/\/ needed to be able to use the bitmap for evacuation failure handling.\n+  class G1ClearBitmapClosure : public HeapRegionClosure {\n+    G1CollectedHeap* _g1h;\n+  public:\n+    G1ClearBitmapClosure(G1CollectedHeap* g1h) : _g1h(g1h) { }\n+\n+    bool do_heap_region(HeapRegion* hr) {\n+      assert(_g1h->is_in_cset(hr), \"Should only be used iterating the collection set\");\n+      \/\/ Young regions should always have cleared bitmaps, so only clear old.\n+      if (hr->is_old()) {\n+        _g1h->clear_region_bitmap(hr);\n+      }\n+      return false;\n+    }\n+  };\n+\n+  \/\/ Helper to allow multiple closure to be applied when\n+  \/\/ iterating through the collection set.\n+  class G1CombinedClosure : public HeapRegionClosure {\n+    HeapRegionClosure* _closure1;\n+    HeapRegionClosure* _closure2;\n+  public:\n+    G1CombinedClosure(HeapRegionClosure* cl1, HeapRegionClosure* cl2) :\n+      _closure1(cl1),\n+      _closure2(cl2) { }\n+\n+    bool do_heap_region(HeapRegion* hr) {\n+      return _closure1->do_heap_region(hr) ||\n+             _closure2->do_heap_region(hr);\n+    }\n+  };\n+\n@@ -1429,3 +1462,6 @@\n-        G1MergeCardSetClosure cl(_scan_state);\n-        g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n-        stats = cl.stats();\n+        G1MergeCardSetClosure merge(_scan_state);\n+        G1ClearBitmapClosure clear(g1h);\n+        G1CombinedClosure combined(&merge, &clear);\n+\n+        g1h->collection_set_iterate_increment_from(&combined, &_hr_claimer, worker_id);\n+        stats = merge.stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -110,4 +110,0 @@\n-void HeapRegion::process_and_drop_evac_failure_objs(ObjectClosure* closure) {\n-  _evac_failure_objs.process_and_drop(closure);\n-}\n-\n@@ -249,2 +245,1 @@\n-  _node_index(G1NUMA::UnknownNodeIndex),\n-  _evac_failure_objs(hrm_index, _bottom)\n+  _node_index(G1NUMA::UnknownNodeIndex)\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n@@ -271,2 +270,0 @@\n-  G1EvacFailureObjectsSet _evac_failure_objs;\n-\n@@ -569,5 +566,0 @@\n-  \/\/ Record an object that failed evacuation within this region.\n-  void record_evac_failure_obj(oop obj);\n-  \/\/ Applies the given closure to all previously recorded objects\n-  \/\/ that failed evacuation in ascending address order.\n-  void process_and_drop_evac_failure_objs(ObjectClosure* closure);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/g1\/g1EvacFailureObjectsSet.inline.hpp\"\n@@ -442,4 +441,0 @@\n-inline void HeapRegion::record_evac_failure_obj(oop obj) {\n-  _evac_failure_objs.record(obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}