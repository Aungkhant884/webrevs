{"files":[{"patch":"@@ -119,0 +119,1 @@\n+      cdsProtectionDomain.cpp \\\n@@ -121,0 +122,3 @@\n+      dumpTimeSharedClassInfo.cpp \\\n+      lambdaProxyClassDictionary.cpp \\\n+      runTimeSharedClassInfo.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-    \/\/ See RunTimeSharedClassInfo::get_for()\n+    \/\/ See RunTimeClassInfo::get_for()\n@@ -322,1 +322,1 @@\n-  \/\/ size of the symbol table and two dictionaries, plus the RunTimeSharedClassInfo's\n+  \/\/ size of the symbol table and two dictionaries, plus the RunTimeClassInfo's\n@@ -635,2 +635,2 @@\n-    \/\/ we can do a quick lookup from InstanceKlass* -> RunTimeSharedClassInfo*\n-    \/\/ without building another hashtable. See RunTimeSharedClassInfo::get_for()\n+    \/\/ we can do a quick lookup from InstanceKlass* -> RunTimeClassInfo*\n+    \/\/ without building another hashtable. See RunTimeClassInfo::get_for()\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/cdsProtectionDomain.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderExt.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+\n+OopHandle CDSProtectionDomain::_shared_protection_domains;\n+OopHandle CDSProtectionDomain::_shared_jar_urls;\n+OopHandle CDSProtectionDomain::_shared_jar_manifests;\n+\n+\/\/ Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with\n+\/\/ the given InstanceKlass.\n+\/\/ Returns the ProtectionDomain for the InstanceKlass.\n+Handle CDSProtectionDomain::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {\n+  Handle pd;\n+\n+  if (ik != NULL) {\n+    int index = ik->shared_classpath_index();\n+    assert(index >= 0, \"Sanity\");\n+    SharedClassPathEntry* ent = FileMapInfo::shared_path(index);\n+    Symbol* class_name = ik->name();\n+\n+    if (ent->is_modules_image()) {\n+      \/\/ For shared app\/platform classes originated from the run-time image:\n+      \/\/   The ProtectionDomains are cached in the corresponding ModuleEntries\n+      \/\/   for fast access by the VM.\n+      \/\/ all packages from module image are already created during VM bootstrap in\n+      \/\/ Modules::define_module().\n+      assert(pkg_entry != NULL, \"archived class in module image cannot be from unnamed package\");\n+      ModuleEntry* mod_entry = pkg_entry->module();\n+      pd = get_shared_protection_domain(class_loader, mod_entry, CHECK_(pd));\n+    } else {\n+      \/\/ For shared app\/platform classes originated from JAR files on the class path:\n+      \/\/   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length\n+      \/\/   as the shared classpath table in the shared archive (see\n+      \/\/   FileMap::_shared_path_table in filemap.hpp for details).\n+      \/\/\n+      \/\/   If a shared InstanceKlass k is loaded from the class path, let\n+      \/\/\n+      \/\/     index = k->shared_classpath_index():\n+      \/\/\n+      \/\/   FileMap::_shared_path_table[index] identifies the JAR file that contains k.\n+      \/\/\n+      \/\/   k's protection domain is:\n+      \/\/\n+      \/\/     ProtectionDomain pd = _shared_protection_domains[index];\n+      \/\/\n+      \/\/   and k's Package is initialized using\n+      \/\/\n+      \/\/     manifest = _shared_jar_manifests[index];\n+      \/\/     url = _shared_jar_urls[index];\n+      \/\/     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+      \/\/\n+      \/\/   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by\n+      \/\/   the corresponding SystemDictionaryShared::get_shared_xxx() function.\n+      Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));\n+      Handle url = get_shared_jar_url(index, CHECK_(pd));\n+      int index_offset = index - ClassLoaderExt::app_class_paths_start_index();\n+      if (index_offset < PackageEntry::max_index_for_defined_in_class_path()) {\n+        if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n+          \/\/ define_shared_package only needs to be called once for each package in a jar specified\n+          \/\/ in the shared class path.\n+          define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+          if (pkg_entry != NULL) {\n+            pkg_entry->set_defined_by_cds_in_class_path(index_offset);\n+          }\n+        }\n+      } else {\n+        define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+      }\n+      pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));\n+    }\n+  }\n+  return pd;\n+}\n+\n+Handle CDSProtectionDomain::get_package_name(Symbol* class_name, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Handle pkgname_string;\n+  TempNewSymbol pkg = ClassLoader::package_from_class_name(class_name);\n+  if (pkg != NULL) { \/\/ Package prefix found\n+    const char* pkgname = pkg->as_klass_external_name();\n+    pkgname_string = java_lang_String::create_from_str(pkgname,\n+                                                       CHECK_(pkgname_string));\n+  }\n+  return pkgname_string;\n+}\n+\n+PackageEntry* CDSProtectionDomain::get_package_entry_from_class(InstanceKlass* ik, Handle class_loader) {\n+  PackageEntry* pkg_entry = ik->package();\n+  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != NULL) {\n+    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n+    assert(!ik->is_shared_unregistered_class(), \"unexpected archived package entry for an unregistered class\");\n+    assert(ik->module()->is_named(), \"unexpected archived package entry for a class in an unnamed module\");\n+    return pkg_entry;\n+  }\n+  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(ik->name());\n+  if (pkg_name != NULL) {\n+    pkg_entry = SystemDictionaryShared::class_loader_data(class_loader)->packages()->lookup_only(pkg_name);\n+  } else {\n+    pkg_entry = NULL;\n+  }\n+  return pkg_entry;\n+}\n+\n+\/\/ Define Package for shared app classes from JAR file and also checks for\n+\/\/ package sealing (all done in Java code)\n+\/\/ See http:\/\/docs.oracle.com\/javase\/tutorial\/deployment\/jar\/sealman.html\n+void CDSProtectionDomain::define_shared_package(Symbol*  class_name,\n+                                                   Handle class_loader,\n+                                                   Handle manifest,\n+                                                   Handle url,\n+                                                   TRAPS) {\n+  assert(SystemDictionary::is_system_class_loader(class_loader()), \"unexpected class loader\");\n+  \/\/ get_package_name() returns a NULL handle if the class is in unnamed package\n+  Handle pkgname_string = get_package_name(class_name, CHECK);\n+  if (pkgname_string.not_null()) {\n+    Klass* app_classLoader_klass = vmClasses::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();\n+    JavaValue result(T_OBJECT);\n+    JavaCallArguments args(3);\n+    args.set_receiver(class_loader);\n+    args.push_oop(pkgname_string);\n+    args.push_oop(manifest);\n+    args.push_oop(url);\n+    JavaCalls::call_virtual(&result, app_classLoader_klass,\n+                            vmSymbols::defineOrCheckPackage_name(),\n+                            vmSymbols::defineOrCheckPackage_signature(),\n+                            &args,\n+                            CHECK);\n+  }\n+}\n+\n+Handle CDSProtectionDomain::create_jar_manifest(const char* manifest_chars, size_t size, TRAPS) {\n+  typeArrayOop buf = oopFactory::new_byteArray((int)size, CHECK_NH);\n+  typeArrayHandle bufhandle(THREAD, buf);\n+  ArrayAccess<>::arraycopy_from_native(reinterpret_cast<const jbyte*>(manifest_chars),\n+                                         buf, typeArrayOopDesc::element_offset<jbyte>(0), size);\n+  Handle bais = JavaCalls::construct_new_instance(vmClasses::ByteArrayInputStream_klass(),\n+                      vmSymbols::byte_array_void_signature(),\n+                      bufhandle, CHECK_NH);\n+  \/\/ manifest = new Manifest(ByteArrayInputStream)\n+  Handle manifest = JavaCalls::construct_new_instance(vmClasses::Jar_Manifest_klass(),\n+                      vmSymbols::input_stream_void_signature(),\n+                      bais, CHECK_NH);\n+  return manifest;\n+}\n+\n+Handle CDSProtectionDomain::get_shared_jar_manifest(int shared_path_index, TRAPS) {\n+  Handle manifest;\n+  if (shared_jar_manifest(shared_path_index) == NULL) {\n+    SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);\n+    size_t size = (size_t)ent->manifest_size();\n+    if (size == 0) {\n+      return Handle();\n+    }\n+\n+    \/\/ ByteArrayInputStream bais = new ByteArrayInputStream(buf);\n+    const char* src = ent->manifest();\n+    assert(src != NULL, \"No Manifest data\");\n+    manifest = create_jar_manifest(src, size, CHECK_NH);\n+    atomic_set_shared_jar_manifest(shared_path_index, manifest());\n+  }\n+  manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));\n+  assert(manifest.not_null(), \"sanity\");\n+  return manifest;\n+}\n+\n+Handle CDSProtectionDomain::get_shared_jar_url(int shared_path_index, TRAPS) {\n+  Handle url_h;\n+  if (shared_jar_url(shared_path_index) == NULL) {\n+    JavaValue result(T_OBJECT);\n+    const char* path = FileMapInfo::shared_path_name(shared_path_index);\n+    Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));\n+    Klass* classLoaders_klass =\n+        vmClasses::jdk_internal_loader_ClassLoaders_klass();\n+    JavaCalls::call_static(&result, classLoaders_klass,\n+                           vmSymbols::toFileURL_name(),\n+                           vmSymbols::toFileURL_signature(),\n+                           path_string, CHECK_(url_h));\n+\n+    atomic_set_shared_jar_url(shared_path_index, result.get_oop());\n+  }\n+\n+  url_h = Handle(THREAD, shared_jar_url(shared_path_index));\n+  assert(url_h.not_null(), \"sanity\");\n+  return url_h;\n+}\n+\n+\/\/ Get the ProtectionDomain associated with the CodeSource from the classloader.\n+Handle CDSProtectionDomain::get_protection_domain_from_classloader(Handle class_loader,\n+                                                                      Handle url, TRAPS) {\n+  \/\/ CodeSource cs = new CodeSource(url, null);\n+  Handle cs = JavaCalls::construct_new_instance(vmClasses::CodeSource_klass(),\n+                  vmSymbols::url_code_signer_array_void_signature(),\n+                  url, Handle(), CHECK_NH);\n+\n+  \/\/ protection_domain = SecureClassLoader.getProtectionDomain(cs);\n+  Klass* secureClassLoader_klass = vmClasses::SecureClassLoader_klass();\n+  JavaValue obj_result(T_OBJECT);\n+  JavaCalls::call_virtual(&obj_result, class_loader, secureClassLoader_klass,\n+                          vmSymbols::getProtectionDomain_name(),\n+                          vmSymbols::getProtectionDomain_signature(),\n+                          cs, CHECK_NH);\n+  return Handle(THREAD, obj_result.get_oop());\n+}\n+\n+\/\/ Returns the ProtectionDomain associated with the JAR file identified by the url.\n+Handle CDSProtectionDomain::get_shared_protection_domain(Handle class_loader,\n+                                                            int shared_path_index,\n+                                                            Handle url,\n+                                                            TRAPS) {\n+  Handle protection_domain;\n+  if (shared_protection_domain(shared_path_index) == NULL) {\n+    Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);\n+    atomic_set_shared_protection_domain(shared_path_index, pd());\n+  }\n+\n+  \/\/ Acquire from the cache because if another thread beats the current one to\n+  \/\/ set the shared protection_domain and the atomic_set fails, the current thread\n+  \/\/ needs to get the updated protection_domain from the cache.\n+  protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));\n+  assert(protection_domain.not_null(), \"sanity\");\n+  return protection_domain;\n+}\n+\n+\/\/ Returns the ProtectionDomain associated with the moduleEntry.\n+Handle CDSProtectionDomain::get_shared_protection_domain(Handle class_loader,\n+                                                         ModuleEntry* mod, TRAPS) {\n+  ClassLoaderData *loader_data = mod->loader_data();\n+  if (mod->shared_protection_domain() == NULL) {\n+    Symbol* location = mod->location();\n+    if (location != NULL) {\n+      Handle location_string = java_lang_String::create_from_symbol(\n+                                     location, CHECK_NH);\n+      Handle url;\n+      JavaValue result(T_OBJECT);\n+      if (location->starts_with(\"jrt:\/\")) {\n+        url = JavaCalls::construct_new_instance(vmClasses::URL_klass(),\n+                                                vmSymbols::string_void_signature(),\n+                                                location_string, CHECK_NH);\n+      } else {\n+        Klass* classLoaders_klass =\n+          vmClasses::jdk_internal_loader_ClassLoaders_klass();\n+        JavaCalls::call_static(&result, classLoaders_klass, vmSymbols::toFileURL_name(),\n+                               vmSymbols::toFileURL_signature(),\n+                               location_string, CHECK_NH);\n+        url = Handle(THREAD, result.get_oop());\n+      }\n+\n+      Handle pd = get_protection_domain_from_classloader(class_loader, url,\n+                                                         CHECK_NH);\n+      mod->set_shared_protection_domain(loader_data, pd);\n+    }\n+  }\n+\n+  Handle protection_domain(THREAD, mod->shared_protection_domain());\n+  assert(protection_domain.not_null(), \"sanity\");\n+  return protection_domain;\n+}\n+\n+void CDSProtectionDomain::atomic_set_array_index(OopHandle array, int index, oop o) {\n+  \/\/ Benign race condition:  array.obj_at(index) may already be filled in.\n+  \/\/ The important thing here is that all threads pick up the same result.\n+  \/\/ It doesn't matter which racing thread wins, as long as only one\n+  \/\/ result is used by all threads, and all future queries.\n+  ((objArrayOop)array.resolve())->atomic_compare_exchange_oop(index, o, NULL);\n+}\n+\n+oop CDSProtectionDomain::shared_protection_domain(int index) {\n+  return ((objArrayOop)_shared_protection_domains.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_protection_domain_array(int size, TRAPS) {\n+  if (_shared_protection_domains.resolve() == NULL) {\n+    oop spd = oopFactory::new_objArray(\n+        vmClasses::ProtectionDomain_klass(), size, CHECK);\n+    _shared_protection_domains = OopHandle(Universe::vm_global(), spd);\n+  }\n+}\n+\n+oop CDSProtectionDomain::shared_jar_url(int index) {\n+  return ((objArrayOop)_shared_jar_urls.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_jar_url_array(int size, TRAPS) {\n+  if (_shared_jar_urls.resolve() == NULL) {\n+    oop sju = oopFactory::new_objArray(\n+        vmClasses::URL_klass(), size, CHECK);\n+    _shared_jar_urls = OopHandle(Universe::vm_global(), sju);\n+  }\n+}\n+\n+oop CDSProtectionDomain::shared_jar_manifest(int index) {\n+  return ((objArrayOop)_shared_jar_manifests.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_jar_manifest_array(int size, TRAPS) {\n+  if (_shared_jar_manifests.resolve() == NULL) {\n+    oop sjm = oopFactory::new_objArray(\n+        vmClasses::Jar_Manifest_klass(), size, CHECK);\n+    _shared_jar_manifests = OopHandle(Universe::vm_global(), sjm);\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n+#define SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+\n+class InstanceKlass;\n+class Symbol;\n+class PackageEntry;\n+class ModuleEntry;\n+\n+\/\/ CDS security\n+class CDSProtectionDomain : AllStatic {\n+  \/\/ See init_security_info for more info.\n+  static OopHandle _shared_protection_domains;\n+  static OopHandle _shared_jar_urls;\n+  static OopHandle _shared_jar_manifests;\n+\n+public:\n+  \/\/ Package handling:\n+  \/\/\n+  \/\/ 1. For named modules in the runtime image\n+  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces\n+  \/\/                  to get packages in named modules for shared classes.\n+  \/\/                  Package for non-shared classes in named module is also\n+  \/\/                  handled using JVM_GetSystemPackage(s).\n+  \/\/\n+  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::definePackage(String, Module)\n+  \/\/                  to define package for shared app classes from named\n+  \/\/                  modules.\n+  \/\/\n+  \/\/    PLATFORM  classes: VM calls ClassLoaders.PlatformClassLoader::definePackage(String, Module)\n+  \/\/                  to define package for shared platform classes from named\n+  \/\/                  modules.\n+  \/\/\n+  \/\/ 2. For unnamed modules\n+  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces to\n+  \/\/                  get packages for shared boot classes in unnamed modules.\n+  \/\/\n+  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::defineOrCheckPackage()\n+  \/\/                  with with the manifest and url from archived data.\n+  \/\/\n+  \/\/    PLATFORM  classes: No package is defined.\n+  \/\/\n+  \/\/ The following two define_shared_package() functions are used to define\n+  \/\/ package for shared APP and PLATFORM classes.\n+  static Handle        get_package_name(Symbol*  class_name, TRAPS);\n+  static PackageEntry* get_package_entry_from_class(InstanceKlass* ik, Handle class_loader);\n+  static void define_shared_package(Symbol*  class_name,\n+                                    Handle class_loader,\n+                                    Handle manifest,\n+                                    Handle url,\n+                                    TRAPS);\n+  static Handle create_jar_manifest(const char* man, size_t size, TRAPS);\n+  static Handle get_shared_jar_manifest(int shared_path_index, TRAPS);\n+  static Handle get_shared_jar_url(int shared_path_index, TRAPS);\n+  static Handle get_protection_domain_from_classloader(Handle class_loader,\n+                                                       Handle url, TRAPS);\n+  static Handle get_shared_protection_domain(Handle class_loader,\n+                                             int shared_path_index,\n+                                             Handle url,\n+                                             TRAPS);\n+  static Handle get_shared_protection_domain(Handle class_loader,\n+                                             ModuleEntry* mod, TRAPS);\n+  static void atomic_set_array_index(OopHandle array, int index, oop o);\n+  static oop shared_protection_domain(int index);\n+  static void allocate_shared_protection_domain_array(int size, TRAPS);\n+  static oop shared_jar_url(int index);\n+  static void allocate_shared_jar_url_array(int size, TRAPS);\n+  static oop shared_jar_manifest(int index);\n+  static void allocate_shared_jar_manifest_array(int size, TRAPS);\n+  static Handle init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS);\n+\n+  static void allocate_shared_data_arrays(int size, TRAPS) {\n+    allocate_shared_protection_domain_array(size, CHECK);\n+    allocate_shared_jar_url_array(size, CHECK);\n+    allocate_shared_jar_manifest_array(size, CHECK);\n+  }\n+  static void atomic_set_shared_protection_domain(int index, oop pd) {\n+    atomic_set_array_index(_shared_protection_domains, index, pd);\n+  }\n+  static void atomic_set_shared_jar_url(int index, oop url) {\n+    atomic_set_array_index(_shared_jar_urls, index, url);\n+  }\n+  static void atomic_set_shared_jar_manifest(int index, oop man) {\n+    atomic_set_array_index(_shared_jar_manifests, index, man);\n+  }\n+};\n+\n+#endif \/\/ SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+\n+void DumpTimeClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n+         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {\n+  if (_verifier_constraints == NULL) {\n+    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n+  }\n+  if (_verifier_constraint_flags == NULL) {\n+    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n+  }\n+  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n+  for (int i = 0; i < vc_array->length(); i++) {\n+    DTVerifierConstraint* p = vc_array->adr_at(i);\n+    if (name == p->_name && from_name == p->_from_name) {\n+      return;\n+    }\n+  }\n+  DTVerifierConstraint cons(name, from_name);\n+  vc_array->append(cons);\n+\n+  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n+  char c = 0;\n+  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n+  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n+  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n+  vcflags_array->append(c);\n+\n+  if (log_is_enabled(Trace, cds, verification)) {\n+    ResourceMark rm;\n+    log_trace(cds, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n+                                 k->external_name(), from_name->as_klass_external_name(),\n+                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+  }\n+}\n+\n+static char get_loader_type_by(oop  loader) {\n+  assert(SystemDictionary::is_builtin_class_loader(loader), \"Must be built-in loader\");\n+  if (SystemDictionary::is_boot_class_loader(loader)) {\n+    return (char)ClassLoader::BOOT_LOADER;\n+  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+    return (char)ClassLoader::PLATFORM_LOADER;\n+  } else {\n+    assert(SystemDictionary::is_system_class_loader(loader), \"Class loader mismatch\");\n+    return (char)ClassLoader::APP_LOADER;\n+  }\n+}\n+\n+void DumpTimeClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {\n+  assert(loader1 != loader2, \"sanity\");\n+  LogTarget(Info, class, loader, constraints) log;\n+  if (_loader_constraints == NULL) {\n+    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n+  }\n+  char lt1 = get_loader_type_by(loader1());\n+  char lt2 = get_loader_type_by(loader2());\n+  DTLoaderConstraint lc(name, lt1, lt2);\n+  for (int i = 0; i < _loader_constraints->length(); i++) {\n+    DTLoaderConstraint dt = _loader_constraints->at(i);\n+    if (lc.equals(dt)) {\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n+        log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]\",\n+                  _klass->external_name(), name->as_C_string(),\n+                  ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n+                  ClassLoaderData::class_loader_data(loader2())->loader_name_and_id());\n+      }\n+      return;\n+    }\n+  }\n+  _loader_constraints->append(lc);\n+  if (log.is_enabled()) {\n+    ResourceMark rm;\n+    \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n+    log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]\",\n+              _klass->external_name(), name->as_C_string(),\n+              ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n+              ClassLoaderData::class_loader_data(loader2())->loader_name_and_id(),\n+              _loader_constraints->length());\n+  }\n+}\n+\n+bool DumpTimeClassInfo::is_builtin() {\n+  return SystemDictionaryShared::is_builtin(_klass);\n+}\n+\n+DumpTimeClassInfo* DumpTimeSharedClassTable::find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress) {\n+  bool created = false;\n+  DumpTimeClassInfo* p;\n+  if (!dump_in_progress) {\n+    p = put_if_absent(k, &created);\n+  } else {\n+    p = get(k);\n+  }\n+  if (created) {\n+    assert(!SystemDictionaryShared::no_class_loading_should_happen(),\n+           \"no new classes can be loaded while dumping archive\");\n+    p->_klass = k;\n+  } else {\n+    if (!dump_in_progress) {\n+      assert(p->_klass == k, \"Sanity\");\n+    }\n+  }\n+  return p;\n+}\n+\n+class CountClassByCategory : StackObj {\n+  DumpTimeSharedClassTable* _table;\n+public:\n+  CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!info.is_excluded()) {\n+      if (info.is_builtin()) {\n+        _table->inc_builtin_count();\n+      } else {\n+        _table->inc_unregistered_count();\n+      }\n+    }\n+    return true; \/\/ keep on iterating\n+  }\n+};\n+\n+void DumpTimeSharedClassTable::update_counts() {\n+  _builtin_count = 0;\n+  _unregistered_count = 0;\n+  CountClassByCategory counter(this);\n+  iterate(&counter);\n+}\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n+#define SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/compactHashtable.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class Method;\n+class Symbol;\n+\n+class DumpTimeClassInfo: public CHeapObj<mtClass> {\n+  bool                         _excluded;\n+  bool                         _is_early_klass;\n+  bool                         _has_checked_exclusion;\n+public:\n+  struct DTLoaderConstraint {\n+    Symbol* _name;\n+    char _loader_type1;\n+    char _loader_type2;\n+    DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {\n+      _name->increment_refcount();\n+    }\n+    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n+    bool equals(const DTLoaderConstraint& t) {\n+      return t._name == _name &&\n+             ((t._loader_type1 == _loader_type1 && t._loader_type2 == _loader_type2) ||\n+              (t._loader_type2 == _loader_type1 && t._loader_type1 == _loader_type2));\n+    }\n+  };\n+\n+  struct DTVerifierConstraint {\n+    Symbol* _name;\n+    Symbol* _from_name;\n+    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n+    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n+      _name->increment_refcount();\n+      _from_name->increment_refcount();\n+    }\n+  };\n+\n+  InstanceKlass*               _klass;\n+  InstanceKlass*               _nest_host;\n+  bool                         _failed_verification;\n+  bool                         _is_archived_lambda_proxy;\n+  int                          _id;\n+  int                          _clsfile_size;\n+  int                          _clsfile_crc32;\n+  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n+  GrowableArray<char>*                 _verifier_constraint_flags;\n+  GrowableArray<DTLoaderConstraint>*   _loader_constraints;\n+\n+  DumpTimeClassInfo() {\n+    _klass = NULL;\n+    _nest_host = NULL;\n+    _failed_verification = false;\n+    _is_archived_lambda_proxy = false;\n+    _has_checked_exclusion = false;\n+    _id = -1;\n+    _clsfile_size = -1;\n+    _clsfile_crc32 = -1;\n+    _excluded = false;\n+    _is_early_klass = JvmtiExport::is_early_phase();\n+    _verifier_constraints = NULL;\n+    _verifier_constraint_flags = NULL;\n+    _loader_constraints = NULL;\n+  }\n+\n+  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n+         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n+  void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);\n+\n+  bool is_builtin();\n+\n+  int num_verifier_constraints() {\n+    if (_verifier_constraint_flags != NULL) {\n+      return _verifier_constraint_flags->length();\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  int num_loader_constraints() {\n+    if (_loader_constraints != NULL) {\n+      return _loader_constraints->length();\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_klass);\n+    it->push(&_nest_host);\n+    if (_verifier_constraints != NULL) {\n+      for (int i = 0; i < _verifier_constraints->length(); i++) {\n+        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n+        it->push(&cons->_name);\n+        it->push(&cons->_from_name);\n+      }\n+    }\n+    if (_loader_constraints != NULL) {\n+      for (int i = 0; i < _loader_constraints->length(); i++) {\n+        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n+        it->push(&lc->_name);\n+      }\n+    }\n+  }\n+\n+  bool is_excluded() {\n+    \/\/ _klass may become NULL due to DynamicArchiveBuilder::set_to_null\n+    return _excluded || _failed_verification || _klass == NULL;\n+  }\n+\n+  \/\/ Was this class loaded while JvmtiExport::is_early_phase()==true\n+  bool is_early_klass() {\n+    return _is_early_klass;\n+  }\n+\n+  \/\/ simple accessors\n+  void set_excluded()                               { _excluded = true; }\n+  bool has_checked_exclusion() const                { return _has_checked_exclusion; }\n+  void set_has_checked_exclusion()                  { _has_checked_exclusion = true; }\n+  bool failed_verification() const                  { return _failed_verification; }\n+  void set_failed_verification()                    { _failed_verification = true; }\n+  InstanceKlass* nest_host() const                  { return _nest_host; }\n+  void set_nest_host(InstanceKlass* nest_host)      { _nest_host = nest_host; }\n+};\n+\n+\n+inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n+  if (DumpSharedSpaces) {\n+    \/\/ Deterministic archive contents\n+    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n+    return primitive_hash<uintx>(delta);\n+  } else {\n+    \/\/ Deterministic archive is not possible because classes can be loaded\n+    \/\/ in multiple threads.\n+    return primitive_hash<InstanceKlass*>(k);\n+  }\n+}\n+\n+class DumpTimeSharedClassTable: public ResourceHashtable<\n+  InstanceKlass*,\n+  DumpTimeClassInfo,\n+  &DumpTimeSharedClassTable_hash,\n+  primitive_equals<InstanceKlass*>,\n+  15889, \/\/ prime number\n+  ResourceObj::C_HEAP>\n+{\n+  int _builtin_count;\n+  int _unregistered_count;\n+public:\n+  DumpTimeClassInfo* find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress);\n+  void inc_builtin_count()      { _builtin_count++; }\n+  void inc_unregistered_count() { _unregistered_count++; }\n+  void update_counts();\n+  int count_of(bool is_builtin) const {\n+    if (is_builtin) {\n+      return _builtin_count;\n+    } else {\n+      return _unregistered_count;\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -322,1 +322,1 @@\n-    if (SystemDictionaryShared::empty_dumptime_table()) {\n+    if (SystemDictionaryShared::is_dumptime_table_empty()) {\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+\n+void LambdaProxyClassKey::mark_pointers() {\n+  ArchivePtrMarker::mark_pointer(&_caller_ik);\n+  ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n+  ArchivePtrMarker::mark_pointer(&_invoked_name);\n+  ArchivePtrMarker::mark_pointer(&_invoked_type);\n+  ArchivePtrMarker::mark_pointer(&_member_method);\n+  ArchivePtrMarker::mark_pointer(&_method_type);\n+}\n+\n+unsigned int LambdaProxyClassKey::hash() const {\n+  return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n+}\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n+#define SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+class Symbol;\n+\n+class LambdaProxyClassKey {\n+  InstanceKlass* _caller_ik;\n+  Symbol*        _invoked_name;\n+  Symbol*        _invoked_type;\n+  Symbol*        _method_type;\n+  Method*        _member_method;\n+  Symbol*        _instantiated_method_type;\n+\n+public:\n+  LambdaProxyClassKey(InstanceKlass* caller_ik,\n+                      Symbol*        invoked_name,\n+                      Symbol*        invoked_type,\n+                      Symbol*        method_type,\n+                      Method*        member_method,\n+                      Symbol*        instantiated_method_type) :\n+    _caller_ik(caller_ik),\n+    _invoked_name(invoked_name),\n+    _invoked_type(invoked_type),\n+    _method_type(method_type),\n+    _member_method(member_method),\n+    _instantiated_method_type(instantiated_method_type) {}\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_caller_ik);\n+    it->push(&_invoked_name);\n+    it->push(&_invoked_type);\n+    it->push(&_method_type);\n+    it->push(&_member_method);\n+    it->push(&_instantiated_method_type);\n+  }\n+\n+  bool equals(LambdaProxyClassKey const& other) const {\n+    return _caller_ik == other._caller_ik &&\n+           _invoked_name == other._invoked_name &&\n+           _invoked_type == other._invoked_type &&\n+           _method_type == other._method_type &&\n+           _member_method == other._member_method &&\n+           _instantiated_method_type == other._instantiated_method_type;\n+  }\n+\n+  void mark_pointers();\n+  unsigned int hash() const;\n+\n+  static unsigned int dumptime_hash(Symbol* sym)  {\n+    if (sym == NULL) {\n+      \/\/ _invoked_name maybe NULL\n+      return 0;\n+    }\n+    return java_lang_String::hash_code((const jbyte*)sym->bytes(), sym->utf8_length());\n+  }\n+\n+  unsigned int dumptime_hash() const {\n+    return dumptime_hash(_caller_ik->name()) +\n+           dumptime_hash(_invoked_name) +\n+           dumptime_hash(_invoked_type) +\n+           dumptime_hash(_method_type) +\n+           dumptime_hash(_instantiated_method_type);\n+  }\n+\n+  static inline unsigned int DUMPTIME_HASH(LambdaProxyClassKey const& key) {\n+    return (key.dumptime_hash());\n+  }\n+\n+  static inline bool DUMPTIME_EQUALS(\n+      LambdaProxyClassKey const& k1, LambdaProxyClassKey const& k2) {\n+    return (k1.equals(k2));\n+  }\n+\n+  InstanceKlass* caller_ik() const { return _caller_ik; }\n+};\n+\n+class DumpTimeLambdaProxyClassInfo {\n+public:\n+  GrowableArray<InstanceKlass*>* _proxy_klasses;\n+  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}\n+  void add_proxy_klass(InstanceKlass* proxy_klass) {\n+    if (_proxy_klasses == NULL) {\n+      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<InstanceKlass*>(5, mtClassShared);\n+    }\n+    assert(_proxy_klasses != NULL, \"sanity\");\n+    _proxy_klasses->append(proxy_klass);\n+  }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    for (int i=0; i<_proxy_klasses->length(); i++) {\n+      it->push(_proxy_klasses->adr_at(i));\n+    }\n+  }\n+};\n+\n+class RunTimeLambdaProxyClassInfo {\n+  LambdaProxyClassKey _key;\n+  InstanceKlass* _proxy_klass_head;\n+public:\n+  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n+    _key(key), _proxy_klass_head(proxy_klass_head) {}\n+\n+  InstanceKlass* proxy_klass_head() const { return _proxy_klass_head; }\n+\n+  \/\/ Used by LambdaProxyClassDictionary to implement OffsetCompactHashtable::EQUALS\n+  static inline bool EQUALS(\n+       const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {\n+    return (value->_key.equals(*key));\n+  }\n+  void init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    _key = key;\n+    _key.mark_pointers();\n+    _proxy_klass_head = info._proxy_klasses->at(0);\n+    ArchivePtrMarker::mark_pointer(&_proxy_klass_head);\n+  }\n+\n+  unsigned int hash() const {\n+    return _key.hash();\n+  }\n+  LambdaProxyClassKey key() const {\n+    return _key;\n+  }\n+};\n+\n+class DumpTimeLambdaProxyClassDictionary\n+  : public ResourceHashtable<LambdaProxyClassKey,\n+                             DumpTimeLambdaProxyClassInfo,\n+                             LambdaProxyClassKey::DUMPTIME_HASH,\n+                             LambdaProxyClassKey::DUMPTIME_EQUALS,\n+                             137, \/\/ prime number\n+                             ResourceObj::C_HEAP> {\n+public:\n+  int _count;\n+};\n+\n+class LambdaProxyClassDictionary : public OffsetCompactHashtable<\n+  LambdaProxyClassKey*,\n+  const RunTimeLambdaProxyClassInfo*,\n+  RunTimeLambdaProxyClassInfo::EQUALS> {};\n+\n+#endif \/\/ SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsProtectionDomain.hpp\"\n@@ -249,1 +250,1 @@\n-      SystemDictionaryShared::allocate_shared_data_arrays(size, CHECK);\n+      CDSProtectionDomain::allocate_shared_data_arrays(size, CHECK);\n@@ -703,1 +704,1 @@\n-  SystemDictionaryShared::create_jar_manifest(dummy, strlen(dummy), CHECK);\n+  CDSProtectionDomain::create_jar_manifest(dummy, strlen(dummy), CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/runTimeClassInfo.hpp\"\n+\n+void RunTimeClassInfo::init(DumpTimeClassInfo& info) {\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+  assert(builder->is_in_buffer_space(info._klass), \"must be\");\n+  _klass = info._klass;\n+  if (!SystemDictionaryShared::is_builtin(_klass)) {\n+    CrcInfo* c = crc();\n+    c->_clsfile_size = info._clsfile_size;\n+    c->_clsfile_crc32 = info._clsfile_crc32;\n+  }\n+  _num_verifier_constraints = info.num_verifier_constraints();\n+  _num_loader_constraints   = info.num_loader_constraints();\n+  int i;\n+  if (_num_verifier_constraints > 0) {\n+    RTVerifierConstraint* vf_constraints = verifier_constraints();\n+    char* flags = verifier_constraint_flags();\n+    for (i = 0; i < _num_verifier_constraints; i++) {\n+      vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n+      vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n+    }\n+    for (i = 0; i < _num_verifier_constraints; i++) {\n+      flags[i] = info._verifier_constraint_flags->at(i);\n+    }\n+  }\n+\n+  if (_num_loader_constraints > 0) {\n+    RTLoaderConstraint* ld_constraints = loader_constraints();\n+    for (i = 0; i < _num_loader_constraints; i++) {\n+      ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n+      ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n+      ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n+    }\n+  }\n+\n+  if (_klass->is_hidden()) {\n+    InstanceKlass* n_h = info.nest_host();\n+    set_nest_host(n_h);\n+  }\n+  ArchivePtrMarker::mark_pointer(&_klass);\n+}\n+\n+size_t RunTimeClassInfo::crc_size(InstanceKlass* klass) {\n+  if (!SystemDictionaryShared::is_builtin(klass)) {\n+    return sizeof(CrcInfo);\n+  } else {\n+    return 0;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_SHAREDCLASSINFO_HPP\n+#define SHARED_CDS_SHAREDCLASSINFO_HPP\n+#include \"classfile\/compactHashtable.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class Method;\n+class Symbol;\n+\n+class RunTimeClassInfo {\n+public:\n+  struct CrcInfo {\n+    int _clsfile_size;\n+    int _clsfile_crc32;\n+  };\n+\n+  \/\/ This is different than  DumpTimeClassInfo::DTVerifierConstraint. We use\n+  \/\/ u4 instead of Symbol* to save space on 64-bit CPU.\n+  struct RTVerifierConstraint {\n+    u4 _name;\n+    u4 _from_name;\n+    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n+    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n+  };\n+\n+  struct RTLoaderConstraint {\n+    u4   _name;\n+    char _loader_type1;\n+    char _loader_type2;\n+    Symbol* constraint_name() {\n+      return (Symbol*)(SharedBaseAddress + _name);\n+    }\n+  };\n+\n+  InstanceKlass* _klass;\n+  int _num_verifier_constraints;\n+  int _num_loader_constraints;\n+\n+  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n+  \/\/ optional InstanceKlass*       _nest_host\n+  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n+  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n+  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n+\n+private:\n+  static size_t header_size_size() {\n+    return sizeof(RunTimeClassInfo);\n+  }\n+  static size_t verifier_constraints_size(int num_verifier_constraints) {\n+    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n+  }\n+  static size_t verifier_constraint_flags_size(int num_verifier_constraints) {\n+    return sizeof(char) * num_verifier_constraints;\n+  }\n+  static size_t loader_constraints_size(int num_loader_constraints) {\n+    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n+  }\n+  static size_t nest_host_size(InstanceKlass* klass) {\n+    if (klass->is_hidden()) {\n+      return sizeof(InstanceKlass*);\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  static size_t crc_size(InstanceKlass* klass);\n+public:\n+  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n+    return header_size_size() +\n+           crc_size(klass) +\n+           nest_host_size(klass) +\n+           loader_constraints_size(num_loader_constraints) +\n+           verifier_constraints_size(num_verifier_constraints) +\n+           verifier_constraint_flags_size(num_verifier_constraints);\n+  }\n+\n+private:\n+  size_t crc_offset() const {\n+    return header_size_size();\n+  }\n+\n+  size_t nest_host_offset() const {\n+      return crc_offset() + crc_size(_klass);\n+  }\n+\n+  size_t loader_constraints_offset() const  {\n+    return nest_host_offset() + nest_host_size(_klass);\n+  }\n+  size_t verifier_constraints_offset() const {\n+    return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);\n+  }\n+  size_t verifier_constraint_flags_offset() const {\n+    return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);\n+  }\n+\n+  void check_verifier_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_verifier_constraints, \"sanity\");\n+  }\n+\n+  void check_loader_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_loader_constraints, \"sanity\");\n+  }\n+\n+public:\n+  CrcInfo* crc() const {\n+    assert(crc_size(_klass) > 0, \"must be\");\n+    return (CrcInfo*)(address(this) + crc_offset());\n+  }\n+  RTVerifierConstraint* verifier_constraints() {\n+    assert(_num_verifier_constraints > 0, \"sanity\");\n+    return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());\n+  }\n+  RTVerifierConstraint* verifier_constraint_at(int i) {\n+    check_verifier_constraint_offset(i);\n+    return verifier_constraints() + i;\n+  }\n+\n+  char* verifier_constraint_flags() {\n+    assert(_num_verifier_constraints > 0, \"sanity\");\n+    return (char*)(address(this) + verifier_constraint_flags_offset());\n+  }\n+\n+  InstanceKlass** nest_host_addr() {\n+    assert(_klass->is_hidden(), \"sanity\");\n+    return (InstanceKlass**)(address(this) + nest_host_offset());\n+  }\n+  InstanceKlass* nest_host() {\n+    return *nest_host_addr();\n+  }\n+  void set_nest_host(InstanceKlass* k) {\n+    *nest_host_addr() = k;\n+    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n+  }\n+\n+  RTLoaderConstraint* loader_constraints() {\n+    assert(_num_loader_constraints > 0, \"sanity\");\n+    return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());\n+  }\n+\n+  RTLoaderConstraint* loader_constraint_at(int i) {\n+    check_loader_constraint_offset(i);\n+    return loader_constraints() + i;\n+  }\n+\n+  void init(DumpTimeClassInfo& info);\n+\n+  bool matches(int clsfile_size, int clsfile_crc32) const {\n+    return crc()->_clsfile_size  == clsfile_size &&\n+           crc()->_clsfile_crc32 == clsfile_crc32;\n+  }\n+\n+  char verifier_constraint_flag(int i) {\n+    check_verifier_constraint_offset(i);\n+    return verifier_constraint_flags()[i];\n+  }\n+\n+private:\n+  \/\/ ArchiveBuilder::make_shallow_copy() has reserved a pointer immediately\n+  \/\/ before archived InstanceKlasses. We can use this slot to do a quick\n+  \/\/ lookup of InstanceKlass* -> RunTimeClassInfo* without\n+  \/\/ building a new hashtable.\n+  \/\/\n+  \/\/  info_pointer_addr(klass) --> 0x0100   RunTimeClassInfo*\n+  \/\/  InstanceKlass* klass     --> 0x0108   <C++ vtbl>\n+  \/\/                               0x0110   fields from Klass ...\n+  static RunTimeClassInfo** info_pointer_addr(InstanceKlass* klass) {\n+    return &((RunTimeClassInfo**)klass)[-1];\n+  }\n+\n+public:\n+  static RunTimeClassInfo* get_for(InstanceKlass* klass) {\n+    assert(klass->is_shared(), \"don't call for non-shared class\");\n+    return *info_pointer_addr(klass);\n+  }\n+  static void set_for(InstanceKlass* klass, RunTimeClassInfo* record) {\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n+    *info_pointer_addr(klass) = record;\n+    ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));\n+  }\n+\n+  \/\/ Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS\n+  static inline bool EQUALS(\n+       const RunTimeClassInfo* value, Symbol* key, int len_unused) {\n+    return (value->_klass->name() == key);\n+  }\n+};\n+\n+class RunTimeSharedDictionary : public OffsetCompactHashtable<\n+  Symbol*,\n+  const RunTimeClassInfo*,\n+  RunTimeClassInfo::EQUALS> {};\n+#endif \/\/ SHARED_CDS_SHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -205,5 +205,0 @@\n-protected:\n-  \/\/ Returns the class loader data to be used when looking up\/updating the\n-  \/\/ system dictionary.\n-  static ClassLoaderData *class_loader_data(Handle class_loader);\n-\n@@ -214,0 +209,4 @@\n+  \/\/ Returns the class loader data to be used when looking up\/updating the\n+  \/\/ system dictionary.\n+  static ClassLoaderData *class_loader_data(Handle class_loader);\n+\n@@ -223,1 +222,0 @@\n-public:\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/cdsProtectionDomain.hpp\"\n@@ -63,1 +64,0 @@\n-#include \"prims\/jvmtiExport.hpp\"\n@@ -73,0 +73,11 @@\n+DumpTimeSharedClassTable* SystemDictionaryShared::_dumptime_table = NULL;\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_dumptime_lambda_proxy_class_dictionary = NULL;\n+\/\/ SystemDictionaries in the base layer static archive\n+RunTimeSharedDictionary SystemDictionaryShared::_builtin_dictionary;\n+RunTimeSharedDictionary SystemDictionaryShared::_unregistered_dictionary;\n+\/\/ SystemDictionaries in the top layer dynamic archive\n+RunTimeSharedDictionary SystemDictionaryShared::_dynamic_builtin_dictionary;\n+RunTimeSharedDictionary SystemDictionaryShared::_dynamic_unregistered_dictionary;\n+\n+LambdaProxyClassDictionary SystemDictionaryShared::_lambda_proxy_class_dictionary;\n+LambdaProxyClassDictionary SystemDictionaryShared::_dynamic_lambda_proxy_class_dictionary;\n@@ -74,3 +85,0 @@\n-OopHandle SystemDictionaryShared::_shared_protection_domains;\n-OopHandle SystemDictionaryShared::_shared_jar_urls;\n-OopHandle SystemDictionaryShared::_shared_jar_manifests;\n@@ -80,80 +88,4 @@\n-class DumpTimeSharedClassInfo: public CHeapObj<mtClass> {\n-  bool                         _excluded;\n-  bool                         _is_early_klass;\n-  bool                         _has_checked_exclusion;\n-public:\n-  struct DTLoaderConstraint {\n-    Symbol* _name;\n-    char _loader_type1;\n-    char _loader_type2;\n-    DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {\n-      _name->increment_refcount();\n-    }\n-    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n-    bool equals(const DTLoaderConstraint& t) {\n-      return t._name == _name &&\n-             ((t._loader_type1 == _loader_type1 && t._loader_type2 == _loader_type2) ||\n-              (t._loader_type2 == _loader_type1 && t._loader_type1 == _loader_type2));\n-    }\n-  };\n-\n-  struct DTVerifierConstraint {\n-    Symbol* _name;\n-    Symbol* _from_name;\n-    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n-    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n-      _name->increment_refcount();\n-      _from_name->increment_refcount();\n-    }\n-  };\n-\n-  InstanceKlass*               _klass;\n-  InstanceKlass*               _nest_host;\n-  bool                         _failed_verification;\n-  bool                         _is_archived_lambda_proxy;\n-  int                          _id;\n-  int                          _clsfile_size;\n-  int                          _clsfile_crc32;\n-  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n-  GrowableArray<char>*                 _verifier_constraint_flags;\n-  GrowableArray<DTLoaderConstraint>* _loader_constraints;\n-\n-  DumpTimeSharedClassInfo() {\n-    _klass = NULL;\n-    _nest_host = NULL;\n-    _failed_verification = false;\n-    _is_archived_lambda_proxy = false;\n-    _has_checked_exclusion = false;\n-    _id = -1;\n-    _clsfile_size = -1;\n-    _clsfile_crc32 = -1;\n-    _excluded = false;\n-    _is_early_klass = JvmtiExport::is_early_phase();\n-    _verifier_constraints = NULL;\n-    _verifier_constraint_flags = NULL;\n-    _loader_constraints = NULL;\n-  }\n-\n-  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n-  void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);\n-\n-  bool is_builtin() {\n-    return SystemDictionaryShared::is_builtin(_klass);\n-  }\n-\n-  int num_verifier_constraints() {\n-    if (_verifier_constraint_flags != NULL) {\n-      return _verifier_constraint_flags->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n-\n-  int num_loader_constraints() {\n-    if (_loader_constraints != NULL) {\n-      return _loader_constraints->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n+InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(\n+                 Symbol* class_name, Handle class_loader, TRAPS) {\n+  assert(UseSharedSpaces, \"must be\");\n+  InstanceKlass* ik = find_builtin_class(class_name);\n@@ -161,15 +93,8 @@\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    it->push(&_klass);\n-    it->push(&_nest_host);\n-    if (_verifier_constraints != NULL) {\n-      for (int i = 0; i < _verifier_constraints->length(); i++) {\n-        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n-        it->push(&cons->_name);\n-        it->push(&cons->_from_name);\n-      }\n-    }\n-    if (_loader_constraints != NULL) {\n-      for (int i = 0; i < _loader_constraints->length(); i++) {\n-        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n-        it->push(&lc->_name);\n-      }\n+  if (ik != NULL && !ik->shared_loading_failed()) {\n+    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n+        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n+      SharedClassLoadingMark slm(THREAD, ik);\n+      PackageEntry* pkg_entry = CDSProtectionDomain::get_package_entry_from_class(ik, class_loader);\n+      Handle protection_domain =\n+        CDSProtectionDomain::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);\n+      return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);\n@@ -178,31 +103,1 @@\n-\n-  bool is_excluded() {\n-    \/\/ _klass may become NULL due to DynamicArchiveBuilder::set_to_null\n-    return _excluded || _failed_verification || _klass == NULL;\n-  }\n-\n-  \/\/ Was this class loaded while JvmtiExport::is_early_phase()==true\n-  bool is_early_klass() {\n-    return _is_early_klass;\n-  }\n-\n-  \/\/ simple accessors\n-  void set_excluded()                               { _excluded = true; }\n-  bool has_checked_exclusion() const                { return _has_checked_exclusion; }\n-  void set_has_checked_exclusion()                  { _has_checked_exclusion = true; }\n-  bool failed_verification() const                  { return _failed_verification; }\n-  void set_failed_verification()                    { _failed_verification = true; }\n-  InstanceKlass* nest_host() const                  { return _nest_host; }\n-  void set_nest_host(InstanceKlass* nest_host)      { _nest_host = nest_host; }\n-};\n-\n-inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n-  if (DumpSharedSpaces) {\n-    \/\/ Deterministic archive contents\n-    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n-    return primitive_hash<uintx>(delta);\n-  } else {\n-    \/\/ Deterministic archive is not possible because classes can be loaded\n-    \/\/ in multiple threads.\n-    return primitive_hash<InstanceKlass*>(k);\n-  }\n+  return NULL;\n@@ -211,52 +106,8 @@\n-class DumpTimeSharedClassTable: public ResourceHashtable<\n-  InstanceKlass*,\n-  DumpTimeSharedClassInfo,\n-  &DumpTimeSharedClassTable_hash,\n-  primitive_equals<InstanceKlass*>,\n-  15889, \/\/ prime number\n-  ResourceObj::C_HEAP>\n-{\n-  int _builtin_count;\n-  int _unregistered_count;\n-public:\n-  DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress) {\n-    bool created = false;\n-    DumpTimeSharedClassInfo* p;\n-    if (!dump_in_progress) {\n-      p = put_if_absent(k, &created);\n-    } else {\n-      p = get(k);\n-    }\n-    if (created) {\n-      assert(!SystemDictionaryShared::no_class_loading_should_happen(),\n-             \"no new classes can be loaded while dumping archive\");\n-      p->_klass = k;\n-    } else {\n-      if (!dump_in_progress) {\n-        assert(p->_klass == k, \"Sanity\");\n-      }\n-    }\n-    return p;\n-  }\n-\n-  class CountClassByCategory : StackObj {\n-    DumpTimeSharedClassTable* _table;\n-  public:\n-    CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}\n-    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n-      if (!info.is_excluded()) {\n-        if (info.is_builtin()) {\n-          ++ _table->_builtin_count;\n-        } else {\n-          ++ _table->_unregistered_count;\n-        }\n-      }\n-      return true; \/\/ keep on iterating\n-    }\n-  };\n-\n-  void update_counts() {\n-    _builtin_count = 0;\n-    _unregistered_count = 0;\n-    CountClassByCategory counter(this);\n-    iterate(&counter);\n+\/\/ This function is called for loading only UNREGISTERED classes\n+InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,\n+                                                          Handle class_loader,\n+                                                          Handle protection_domain,\n+                                                          const ClassFileStream* cfs,\n+                                                          TRAPS) {\n+  if (!UseSharedSpaces) {\n+    return NULL;\n@@ -264,7 +115,2 @@\n-\n-  int count_of(bool is_builtin) const {\n-    if (is_builtin) {\n-      return _builtin_count;\n-    } else {\n-      return _unregistered_count;\n-    }\n+  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n+    return NULL;\n@@ -272,65 +118,5 @@\n-};\n-\n-class LambdaProxyClassKey {\n-  InstanceKlass* _caller_ik;\n-  Symbol*        _invoked_name;\n-  Symbol*        _invoked_type;\n-  Symbol*        _method_type;\n-  Method*        _member_method;\n-  Symbol*        _instantiated_method_type;\n-\n-public:\n-  LambdaProxyClassKey(InstanceKlass* caller_ik,\n-                      Symbol*        invoked_name,\n-                      Symbol*        invoked_type,\n-                      Symbol*        method_type,\n-                      Method*        member_method,\n-                      Symbol*        instantiated_method_type) :\n-    _caller_ik(caller_ik),\n-    _invoked_name(invoked_name),\n-    _invoked_type(invoked_type),\n-    _method_type(method_type),\n-    _member_method(member_method),\n-    _instantiated_method_type(instantiated_method_type) {}\n-\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    it->push(&_caller_ik);\n-    it->push(&_invoked_name);\n-    it->push(&_invoked_type);\n-    it->push(&_method_type);\n-    it->push(&_member_method);\n-    it->push(&_instantiated_method_type);\n-  }\n-\n-  void mark_pointers() {\n-    ArchivePtrMarker::mark_pointer(&_caller_ik);\n-    ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n-    ArchivePtrMarker::mark_pointer(&_invoked_name);\n-    ArchivePtrMarker::mark_pointer(&_invoked_type);\n-    ArchivePtrMarker::mark_pointer(&_member_method);\n-    ArchivePtrMarker::mark_pointer(&_method_type);\n-  }\n-\n-  bool equals(LambdaProxyClassKey const& other) const {\n-    return _caller_ik == other._caller_ik &&\n-           _invoked_name == other._invoked_name &&\n-           _invoked_type == other._invoked_type &&\n-           _method_type == other._method_type &&\n-           _member_method == other._member_method &&\n-           _instantiated_method_type == other._instantiated_method_type;\n-  }\n-\n-  unsigned int hash() const {\n-    return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n-  }\n-\n-  static unsigned int dumptime_hash(Symbol* sym)  {\n-    if (sym == NULL) {\n-      \/\/ _invoked_name maybe NULL\n-      return 0;\n-    }\n-    return java_lang_String::hash_code((const jbyte*)sym->bytes(), sym->utf8_length());\n+  if (class_loader.is_null() ||\n+      SystemDictionary::is_system_class_loader(class_loader()) ||\n+      SystemDictionary::is_platform_class_loader(class_loader())) {\n+    \/\/ Do nothing for the BUILTIN loaders.\n+    return NULL;\n@@ -339,6 +125,3 @@\n-  unsigned int dumptime_hash() const {\n-    return dumptime_hash(_caller_ik->name()) +\n-           dumptime_hash(_invoked_name) +\n-           dumptime_hash(_invoked_type) +\n-           dumptime_hash(_method_type) +\n-           dumptime_hash(_instantiated_method_type);\n+  const RunTimeClassInfo* record = find_record(&_unregistered_dictionary, &_dynamic_unregistered_dictionary, class_name);\n+  if (record == NULL) {\n+    return NULL;\n@@ -347,3 +130,2 @@\n-  static inline unsigned int DUMPTIME_HASH(LambdaProxyClassKey const& key) {\n-    return (key.dumptime_hash());\n-  }\n+  int clsfile_size  = cfs->length();\n+  int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs->buffer(), cfs->length());\n@@ -351,3 +133,2 @@\n-  static inline bool DUMPTIME_EQUALS(\n-      LambdaProxyClassKey const& k1, LambdaProxyClassKey const& k2) {\n-    return (k1.equals(k2));\n+  if (!record->matches(clsfile_size, clsfile_crc32)) {\n+    return NULL;\n@@ -356,2 +137,4 @@\n-  InstanceKlass* caller_ik() const { return _caller_ik; }\n-};\n+  return acquire_class_for_current_thread(record->_klass, class_loader,\n+                                          protection_domain, cfs,\n+                                          THREAD);\n+}\n@@ -359,0 +142,7 @@\n+InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(\n+                   InstanceKlass *ik,\n+                   Handle class_loader,\n+                   Handle protection_domain,\n+                   const ClassFileStream *cfs,\n+                   TRAPS) {\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n@@ -360,7 +150,6 @@\n-class DumpTimeLambdaProxyClassInfo {\n-public:\n-  GrowableArray<InstanceKlass*>* _proxy_klasses;\n-  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}\n-  void add_proxy_klass(InstanceKlass* proxy_klass) {\n-    if (_proxy_klasses == NULL) {\n-      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<InstanceKlass*>(5, mtClassShared);\n+  {\n+    MutexLocker mu(THREAD, SharedDictionary_lock);\n+    if (ik->class_loader_data() != NULL) {\n+      \/\/    ik is already loaded (by this loader or by a different loader)\n+      \/\/ or ik is being loaded by a different thread (by this loader or by a different loader)\n+      return NULL;\n@@ -368,3 +157,0 @@\n-    assert(_proxy_klasses != NULL, \"sanity\");\n-    _proxy_klasses->append(proxy_klass);\n-  }\n@@ -372,4 +158,2 @@\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    for (int i=0; i<_proxy_klasses->length(); i++) {\n-      it->push(_proxy_klasses->adr_at(i));\n-    }\n+    \/\/ No other thread has acquired this yet, so give it to *this thread*\n+    ik->set_class_loader_data(loader_data);\n@@ -377,1 +161,0 @@\n-};\n@@ -379,8 +162,3 @@\n-class RunTimeLambdaProxyClassInfo {\n-  LambdaProxyClassKey _key;\n-  InstanceKlass* _proxy_klass_head;\n-public:\n-  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n-    _key(key), _proxy_klass_head(proxy_klass_head) {}\n-\n-  InstanceKlass* proxy_klass_head() const { return _proxy_klass_head; }\n+  \/\/ No longer holding SharedDictionary_lock\n+  \/\/ No need to lock, as <ik> can be held only by a single thread.\n+  loader_data->add_class(ik);\n@@ -388,11 +166,2 @@\n-  \/\/ Used by LambdaProxyClassDictionary to implement OffsetCompactHashtable::EQUALS\n-  static inline bool EQUALS(\n-       const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {\n-    return (value->_key.equals(*key));\n-  }\n-  void init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    _key = key;\n-    _key.mark_pointers();\n-    _proxy_klass_head = info._proxy_klasses->at(0);\n-    ArchivePtrMarker::mark_pointer(&_proxy_klass_head);\n-  }\n+  \/\/ Get the package entry.\n+  PackageEntry* pkg_entry = CDSProtectionDomain::get_package_entry_from_class(ik, class_loader);\n@@ -400,5 +169,6 @@\n-  unsigned int hash() const {\n-    return _key.hash();\n-  }\n-  LambdaProxyClassKey key() const {\n-    return _key;\n+  \/\/ Load and check super\/interfaces, restore unsharable info\n+  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,\n+                                                  cfs, pkg_entry, THREAD);\n+  if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {\n+    \/\/ TODO: clean up <ik> so it can be used again\n+    return NULL;\n@@ -406,6 +176,0 @@\n-};\n-\n-class LambdaProxyClassDictionary : public OffsetCompactHashtable<\n-  LambdaProxyClassKey*,\n-  const RunTimeLambdaProxyClassInfo*,\n-  RunTimeLambdaProxyClassInfo::EQUALS> {};\n@@ -413,3 +177,2 @@\n-LambdaProxyClassDictionary _lambda_proxy_class_dictionary;\n-\n-LambdaProxyClassDictionary _dynamic_lambda_proxy_class_dictionary;\n+  return shared_klass;\n+}\n@@ -417,10 +180,4 @@\n-class DumpTimeLambdaProxyClassDictionary\n-  : public ResourceHashtable<LambdaProxyClassKey,\n-                             DumpTimeLambdaProxyClassInfo,\n-                             LambdaProxyClassKey::DUMPTIME_HASH,\n-                             LambdaProxyClassKey::DUMPTIME_EQUALS,\n-                             137, \/\/ prime number\n-                             ResourceObj::C_HEAP> {\n-public:\n-  int _count;\n-};\n+void SystemDictionaryShared::start_dumping() {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  _dump_in_progress = true;\n+}\n@@ -428,1 +185,4 @@\n-DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary = NULL;\n+DumpTimeClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  return find_or_allocate_info_for_locked(k);\n+}\n@@ -430,2 +190,1 @@\n-static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey key,\n-                                                           InstanceKlass* proxy_klass) {\n+DumpTimeClassInfo* SystemDictionaryShared::find_or_allocate_info_for_locked(InstanceKlass* k) {\n@@ -433,14 +192,2 @@\n-  if (_dumptime_lambda_proxy_class_dictionary == NULL) {\n-    _dumptime_lambda_proxy_class_dictionary =\n-      new (ResourceObj::C_HEAP, mtClass)DumpTimeLambdaProxyClassDictionary();\n-  }\n-  DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n-  if (lambda_info == NULL) {\n-    DumpTimeLambdaProxyClassInfo info;\n-    info.add_proxy_klass(proxy_klass);\n-    _dumptime_lambda_proxy_class_dictionary->put(key, info);\n-    \/\/lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n-    \/\/assert(lambda_info->_proxy_klass == proxy_klass, \"must be\"); \/\/ debug only -- remove\n-    ++_dumptime_lambda_proxy_class_dictionary->_count;\n-  } else {\n-    lambda_info->add_proxy_klass(proxy_klass);\n+  if (_dumptime_table == NULL) {\n+    _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();\n@@ -448,0 +195,1 @@\n+  return _dumptime_table->find_or_allocate_info_for(k, _dump_in_progress);\n@@ -450,61 +198,6 @@\n-class RunTimeSharedClassInfo {\n-public:\n-  struct CrcInfo {\n-    int _clsfile_size;\n-    int _clsfile_crc32;\n-  };\n-\n-  \/\/ This is different than  DumpTimeSharedClassInfo::DTVerifierConstraint. We use\n-  \/\/ u4 instead of Symbol* to save space on 64-bit CPU.\n-  struct RTVerifierConstraint {\n-    u4 _name;\n-    u4 _from_name;\n-    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n-    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n-  };\n-\n-  struct RTLoaderConstraint {\n-    u4   _name;\n-    char _loader_type1;\n-    char _loader_type2;\n-    Symbol* constraint_name() {\n-      return (Symbol*)(SharedBaseAddress + _name);\n-    }\n-  };\n-\n-  InstanceKlass* _klass;\n-  int _num_verifier_constraints;\n-  int _num_loader_constraints;\n-\n-  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n-  \/\/ optional InstanceKlass*       _nest_host\n-  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n-  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n-  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n-\n-private:\n-  static size_t header_size_size() {\n-    return sizeof(RunTimeSharedClassInfo);\n-  }\n-  static size_t crc_size(InstanceKlass* klass) {\n-    if (!SystemDictionaryShared::is_builtin(klass)) {\n-      return sizeof(CrcInfo);\n-    } else {\n-      return 0;\n-    }\n-  }\n-  static size_t verifier_constraints_size(int num_verifier_constraints) {\n-    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n-  }\n-  static size_t verifier_constraint_flags_size(int num_verifier_constraints) {\n-    return sizeof(char) * num_verifier_constraints;\n-  }\n-  static size_t loader_constraints_size(int num_loader_constraints) {\n-    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n-  }\n-  static size_t nest_host_size(InstanceKlass* klass) {\n-    if (klass->is_hidden()) {\n-      return sizeof(InstanceKlass*);\n-    } else {\n-      return 0;\n-    }\n+bool SystemDictionaryShared::check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info) {\n+  if (MetaspaceShared::is_in_shared_metaspace(k)) {\n+    \/\/ We have reached a super type that's already in the base archive. Treat it\n+    \/\/ as \"not excluded\".\n+    assert(DynamicDumpSharedSpaces, \"must be\");\n+    return false;\n@@ -513,8 +206,3 @@\n-public:\n-  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n-    return header_size_size() +\n-           crc_size(klass) +\n-           nest_host_size(klass) +\n-           loader_constraints_size(num_loader_constraints) +\n-           verifier_constraints_size(num_verifier_constraints) +\n-           verifier_constraint_flags_size(num_verifier_constraints);\n+  if (info == NULL) {\n+    info = _dumptime_table->get(k);\n+    assert(info != NULL, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n@@ -523,3 +211,5 @@\n-private:\n-  size_t crc_offset() const {\n-    return header_size_size();\n+  if (!info->has_checked_exclusion()) {\n+    if (check_for_exclusion_impl(k)) {\n+      info->set_excluded();\n+    }\n+    info->set_has_checked_exclusion();\n@@ -528,3 +218,2 @@\n-  size_t nest_host_offset() const {\n-      return crc_offset() + crc_size(_klass);\n-  }\n+  return info->is_excluded();\n+}\n@@ -532,9 +221,6 @@\n-  size_t loader_constraints_offset() const  {\n-    return nest_host_offset() + nest_host_size(_klass);\n-  }\n-  size_t verifier_constraints_offset() const {\n-    return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);\n-  }\n-  size_t verifier_constraint_flags_offset() const {\n-    return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);\n-  }\n+\/\/ Returns true so the caller can do:    return warn_excluded(\".....\");\n+bool SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {\n+  ResourceMark rm;\n+  log_warning(cds)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n+  return true;\n+}\n@@ -542,2 +228,6 @@\n-  void check_verifier_constraint_offset(int i) const {\n-    assert(0 <= i && i < _num_verifier_constraints, \"sanity\");\n+bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {\n+  while (k) {\n+    if (k->name()->equals(\"jdk\/internal\/event\/Event\")) {\n+      return true;\n+    }\n+    k = k->java_super();\n@@ -545,0 +235,2 @@\n+  return false;\n+}\n@@ -546,3 +238,4 @@\n-  void check_loader_constraint_offset(int i) const {\n-    assert(0 <= i && i < _num_loader_constraints, \"sanity\");\n-  }\n+bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {\n+  DumpTimeClassInfo* info = _dumptime_table->get(ik);\n+  return (info != NULL) ? info->_is_archived_lambda_proxy : false;\n+}\n@@ -550,13 +243,4 @@\n-public:\n-  CrcInfo* crc() const {\n-    assert(crc_size(_klass) > 0, \"must be\");\n-    return (CrcInfo*)(address(this) + crc_offset());\n-  }\n-  RTVerifierConstraint* verifier_constraints() {\n-    assert(_num_verifier_constraints > 0, \"sanity\");\n-    return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());\n-  }\n-  RTVerifierConstraint* verifier_constraint_at(int i) {\n-    check_verifier_constraint_offset(i);\n-    return verifier_constraints() + i;\n-  }\n+bool SystemDictionaryShared::is_early_klass(InstanceKlass* ik) {\n+  DumpTimeClassInfo* info = _dumptime_table->get(ik);\n+  return (info != NULL) ? info->is_early_klass() : false;\n+}\n@@ -564,3 +248,6 @@\n-  char* verifier_constraint_flags() {\n-    assert(_num_verifier_constraints > 0, \"sanity\");\n-    return (char*)(address(this) + verifier_constraint_flags_offset());\n+bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {\n+  assert(ik->is_shared(), \"applicable to only a shared class\");\n+  if (ik->is_hidden()) {\n+    return true;\n+  } else {\n+    return false;\n@@ -568,0 +255,1 @@\n+}\n@@ -569,3 +257,3 @@\n-  InstanceKlass** nest_host_addr() {\n-    assert(_klass->is_hidden(), \"sanity\");\n-    return (InstanceKlass**)(address(this) + nest_host_offset());\n+bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {\n+  if (k->is_in_error_state()) {\n+    return warn_excluded(k, \"In error state\");\n@@ -573,2 +261,2 @@\n-  InstanceKlass* nest_host() {\n-    return *nest_host_addr();\n+  if (has_been_redefined(k)) {\n+    return warn_excluded(k, \"Has been redefined\");\n@@ -576,3 +264,4 @@\n-  void set_nest_host(InstanceKlass* k) {\n-    *nest_host_addr() = k;\n-    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n+  if (!k->is_hidden() && k->shared_classpath_index() < 0 && is_builtin(k)) {\n+    \/\/ These are classes loaded from unsupported locations (such as those loaded by JVMTI native\n+    \/\/ agent during dump time).\n+    return warn_excluded(k, \"Unsupported location\");\n@@ -580,4 +269,5 @@\n-\n-  RTLoaderConstraint* loader_constraints() {\n-    assert(_num_loader_constraints > 0, \"sanity\");\n-    return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());\n+  if (k->signers() != NULL) {\n+    \/\/ We cannot include signed classes in the archive because the certificates\n+    \/\/ used during dump time may be different than those used during\n+    \/\/ runtime (due to expiration, etc).\n+    return warn_excluded(k, \"Signed JAR\");\n@@ -585,4 +275,6 @@\n-\n-  RTLoaderConstraint* loader_constraint_at(int i) {\n-    check_loader_constraint_offset(i);\n-    return loader_constraints() + i;\n+  if (is_jfr_event_class(k)) {\n+    \/\/ We cannot include JFR event classes because they need runtime-specific\n+    \/\/ instrumentation in order to work with -XX:FlightRecorderOptions:retransform=false.\n+    \/\/ There are only a small number of these classes, so it's not worthwhile to\n+    \/\/ support them and make CDS more complicated.\n+    return warn_excluded(k, \"JFR event class\");\n@@ -590,0 +282,4 @@\n+  if (k->init_state() < InstanceKlass::linked) {\n+    \/\/ In CDS dumping, we will attempt to link all classes. Those that fail to link will\n+    \/\/ be recorded in DumpTimeClassInfo.\n+    Arguments::assert_is_dumping_archive();\n@@ -591,30 +287,11 @@\n-  void init(DumpTimeSharedClassInfo& info) {\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    assert(builder->is_in_buffer_space(info._klass), \"must be\");\n-    _klass = info._klass;\n-    if (!SystemDictionaryShared::is_builtin(_klass)) {\n-      CrcInfo* c = crc();\n-      c->_clsfile_size = info._clsfile_size;\n-      c->_clsfile_crc32 = info._clsfile_crc32;\n-    }\n-    _num_verifier_constraints = info.num_verifier_constraints();\n-    _num_loader_constraints   = info.num_loader_constraints();\n-    int i;\n-    if (_num_verifier_constraints > 0) {\n-      RTVerifierConstraint* vf_constraints = verifier_constraints();\n-      char* flags = verifier_constraint_flags();\n-      for (i = 0; i < _num_verifier_constraints; i++) {\n-        vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n-        vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n-      }\n-      for (i = 0; i < _num_verifier_constraints; i++) {\n-        flags[i] = info._verifier_constraint_flags->at(i);\n-      }\n-    }\n-\n-    if (_num_loader_constraints > 0) {\n-      RTLoaderConstraint* ld_constraints = loader_constraints();\n-      for (i = 0; i < _num_loader_constraints; i++) {\n-        ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n-        ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n-        ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n+    \/\/ TODO -- rethink how this can be handled.\n+    \/\/ We should try to link ik, however, we can't do it here because\n+    \/\/ 1. We are at VM exit\n+    \/\/ 2. linking a class may cause other classes to be loaded, which means\n+    \/\/    a custom ClassLoader.loadClass() may be called, at a point where the\n+    \/\/    class loader doesn't expect it.\n+    if (has_class_failed_verification(k)) {\n+      return warn_excluded(k, \"Failed verification\");\n+    } else {\n+      if (k->can_be_verified_at_dumptime()) {\n+        return warn_excluded(k, \"Not linked\");\n@@ -623,47 +300,0 @@\n-\n-    if (_klass->is_hidden()) {\n-      InstanceKlass* n_h = info.nest_host();\n-      set_nest_host(n_h);\n-    }\n-    ArchivePtrMarker::mark_pointer(&_klass);\n-  }\n-\n-  bool matches(int clsfile_size, int clsfile_crc32) const {\n-    return crc()->_clsfile_size  == clsfile_size &&\n-           crc()->_clsfile_crc32 == clsfile_crc32;\n-  }\n-\n-  char verifier_constraint_flag(int i) {\n-    check_verifier_constraint_offset(i);\n-    return verifier_constraint_flags()[i];\n-  }\n-\n-private:\n-  \/\/ ArchiveBuilder::make_shallow_copy() has reserved a pointer immediately\n-  \/\/ before archived InstanceKlasses. We can use this slot to do a quick\n-  \/\/ lookup of InstanceKlass* -> RunTimeSharedClassInfo* without\n-  \/\/ building a new hashtable.\n-  \/\/\n-  \/\/  info_pointer_addr(klass) --> 0x0100   RunTimeSharedClassInfo*\n-  \/\/  InstanceKlass* klass     --> 0x0108   <C++ vtbl>\n-  \/\/                               0x0110   fields from Klass ...\n-  static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {\n-    return &((RunTimeSharedClassInfo**)klass)[-1];\n-  }\n-\n-public:\n-  static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {\n-    assert(klass->is_shared(), \"don't call for non-shared class\");\n-    return *info_pointer_addr(klass);\n-  }\n-  static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {\n-    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n-    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n-    *info_pointer_addr(klass) = record;\n-    ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));\n-  }\n-\n-  \/\/ Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS\n-  static inline bool EQUALS(\n-       const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {\n-    return (value->_klass->name() == key);\n@@ -671,64 +301,7 @@\n-};\n-\n-class RunTimeSharedDictionary : public OffsetCompactHashtable<\n-  Symbol*,\n-  const RunTimeSharedClassInfo*,\n-  RunTimeSharedClassInfo::EQUALS> {};\n-\n-static DumpTimeSharedClassTable* _dumptime_table = NULL;\n-\/\/ SystemDictionaries in the base layer static archive\n-static RunTimeSharedDictionary _builtin_dictionary;\n-static RunTimeSharedDictionary _unregistered_dictionary;\n-\/\/ SystemDictionaries in the top layer dynamic archive\n-static RunTimeSharedDictionary _dynamic_builtin_dictionary;\n-static RunTimeSharedDictionary _dynamic_unregistered_dictionary;\n-\n-void SystemDictionaryShared::atomic_set_array_index(OopHandle array, int index, oop o) {\n-  \/\/ Benign race condition:  array.obj_at(index) may already be filled in.\n-  \/\/ The important thing here is that all threads pick up the same result.\n-  \/\/ It doesn't matter which racing thread wins, as long as only one\n-  \/\/ result is used by all threads, and all future queries.\n-  ((objArrayOop)array.resolve())->atomic_compare_exchange_oop(index, o, NULL);\n-}\n-\n-Handle SystemDictionaryShared::create_jar_manifest(const char* manifest_chars, size_t size, TRAPS) {\n-  typeArrayOop buf = oopFactory::new_byteArray((int)size, CHECK_NH);\n-  typeArrayHandle bufhandle(THREAD, buf);\n-  ArrayAccess<>::arraycopy_from_native(reinterpret_cast<const jbyte*>(manifest_chars),\n-                                         buf, typeArrayOopDesc::element_offset<jbyte>(0), size);\n-  Handle bais = JavaCalls::construct_new_instance(vmClasses::ByteArrayInputStream_klass(),\n-                      vmSymbols::byte_array_void_signature(),\n-                      bufhandle, CHECK_NH);\n-  \/\/ manifest = new Manifest(ByteArrayInputStream)\n-  Handle manifest = JavaCalls::construct_new_instance(vmClasses::Jar_Manifest_klass(),\n-                      vmSymbols::input_stream_void_signature(),\n-                      bais, CHECK_NH);\n-  return manifest;\n-}\n-\n-oop SystemDictionaryShared::shared_protection_domain(int index) {\n-  return ((objArrayOop)_shared_protection_domains.resolve())->obj_at(index);\n-}\n-\n-oop SystemDictionaryShared::shared_jar_url(int index) {\n-  return ((objArrayOop)_shared_jar_urls.resolve())->obj_at(index);\n-}\n-\n-oop SystemDictionaryShared::shared_jar_manifest(int index) {\n-  return ((objArrayOop)_shared_jar_manifests.resolve())->obj_at(index);\n-}\n-\n-Handle SystemDictionaryShared::get_shared_jar_manifest(int shared_path_index, TRAPS) {\n-  Handle manifest ;\n-  if (shared_jar_manifest(shared_path_index) == NULL) {\n-    SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);\n-    size_t size = (size_t)ent->manifest_size();\n-    if (size == 0) {\n-      return Handle();\n-    }\n-\n-    \/\/ ByteArrayInputStream bais = new ByteArrayInputStream(buf);\n-    const char* src = ent->manifest();\n-    assert(src != NULL, \"No Manifest data\");\n-    manifest = create_jar_manifest(src, size, CHECK_NH);\n-    atomic_set_shared_jar_manifest(shared_path_index, manifest());\n+  if (DynamicDumpSharedSpaces && k->major_version() < 50 \/*JAVA_6_VERSION*\/) {\n+    \/\/ In order to support old classes during dynamic dump, class rewriting needs to\n+    \/\/ be reverted. This would result in more complex code and testing but not much gain.\n+    ResourceMark rm;\n+    log_warning(cds)(\"Pre JDK 6 class not supported by CDS: %u.%u %s\",\n+                     k->major_version(),  k->minor_version(), k->name()->as_C_string());\n+    return true;\n@@ -736,25 +309,0 @@\n-  manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));\n-  assert(manifest.not_null(), \"sanity\");\n-  return manifest;\n-}\n-\n-Handle SystemDictionaryShared::get_shared_jar_url(int shared_path_index, TRAPS) {\n-  Handle url_h;\n-  if (shared_jar_url(shared_path_index) == NULL) {\n-    JavaValue result(T_OBJECT);\n-    const char* path = FileMapInfo::shared_path_name(shared_path_index);\n-    Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));\n-    Klass* classLoaders_klass =\n-        vmClasses::jdk_internal_loader_ClassLoaders_klass();\n-    JavaCalls::call_static(&result, classLoaders_klass,\n-                           vmSymbols::toFileURL_name(),\n-                           vmSymbols::toFileURL_signature(),\n-                           path_string, CHECK_(url_h));\n-\n-    atomic_set_shared_jar_url(shared_path_index, result.get_oop());\n-  }\n-\n-  url_h = Handle(THREAD, shared_jar_url(shared_path_index));\n-  assert(url_h.not_null(), \"sanity\");\n-  return url_h;\n-}\n@@ -762,8 +310,2 @@\n-Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  Handle pkgname_string;\n-  TempNewSymbol pkg = ClassLoader::package_from_class_name(class_name);\n-  if (pkg != NULL) { \/\/ Package prefix found\n-    const char* pkgname = pkg->as_klass_external_name();\n-    pkgname_string = java_lang_String::create_from_str(pkgname,\n-                                                       CHECK_(pkgname_string));\n+  if (!k->can_be_verified_at_dumptime() && k->is_linked()) {\n+    return warn_excluded(k, \"Old class has been linked\");\n@@ -771,2 +313,0 @@\n-  return pkgname_string;\n-}\n@@ -774,24 +314,4 @@\n-\/\/ Define Package for shared app classes from JAR file and also checks for\n-\/\/ package sealing (all done in Java code)\n-\/\/ See http:\/\/docs.oracle.com\/javase\/tutorial\/deployment\/jar\/sealman.html\n-void SystemDictionaryShared::define_shared_package(Symbol*  class_name,\n-                                                   Handle class_loader,\n-                                                   Handle manifest,\n-                                                   Handle url,\n-                                                   TRAPS) {\n-  assert(SystemDictionary::is_system_class_loader(class_loader()), \"unexpected class loader\");\n-  \/\/ get_package_name() returns a NULL handle if the class is in unnamed package\n-  Handle pkgname_string = get_package_name(class_name, CHECK);\n-  if (pkgname_string.not_null()) {\n-    Klass* app_classLoader_klass = vmClasses::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();\n-    JavaValue result(T_OBJECT);\n-    JavaCallArguments args(3);\n-    args.set_receiver(class_loader);\n-    args.push_oop(pkgname_string);\n-    args.push_oop(manifest);\n-    args.push_oop(url);\n-    JavaCalls::call_virtual(&result, app_classLoader_klass,\n-                            vmSymbols::defineOrCheckPackage_name(),\n-                            vmSymbols::defineOrCheckPackage_signature(),\n-                            &args,\n-                            CHECK);\n+  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n+    ResourceMark rm;\n+    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n+    return true;\n@@ -799,19 +319,0 @@\n-}\n-\n-\/\/ Get the ProtectionDomain associated with the CodeSource from the classloader.\n-Handle SystemDictionaryShared::get_protection_domain_from_classloader(Handle class_loader,\n-                                                                      Handle url, TRAPS) {\n-  \/\/ CodeSource cs = new CodeSource(url, null);\n-  Handle cs = JavaCalls::construct_new_instance(vmClasses::CodeSource_klass(),\n-                  vmSymbols::url_code_signer_array_void_signature(),\n-                  url, Handle(), CHECK_NH);\n-\n-  \/\/ protection_domain = SecureClassLoader.getProtectionDomain(cs);\n-  Klass* secureClassLoader_klass = vmClasses::SecureClassLoader_klass();\n-  JavaValue obj_result(T_OBJECT);\n-  JavaCalls::call_virtual(&obj_result, class_loader, secureClassLoader_klass,\n-                          vmSymbols::getProtectionDomain_name(),\n-                          vmSymbols::getProtectionDomain_signature(),\n-                          cs, CHECK_NH);\n-  return Handle(THREAD, obj_result.get_oop());\n-}\n@@ -819,9 +320,5 @@\n-\/\/ Returns the ProtectionDomain associated with the JAR file identified by the url.\n-Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,\n-                                                            int shared_path_index,\n-                                                            Handle url,\n-                                                            TRAPS) {\n-  Handle protection_domain;\n-  if (shared_protection_domain(shared_path_index) == NULL) {\n-    Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);\n-    atomic_set_shared_protection_domain(shared_path_index, pd());\n+  InstanceKlass* super = k->java_super();\n+  if (super != NULL && check_for_exclusion(super, NULL)) {\n+    ResourceMark rm;\n+    log_warning(cds)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n+    return true;\n@@ -830,35 +327,7 @@\n-  \/\/ Acquire from the cache because if another thread beats the current one to\n-  \/\/ set the shared protection_domain and the atomic_set fails, the current thread\n-  \/\/ needs to get the updated protection_domain from the cache.\n-  protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));\n-  assert(protection_domain.not_null(), \"sanity\");\n-  return protection_domain;\n-}\n-\n-\/\/ Returns the ProtectionDomain associated with the moduleEntry.\n-Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,\n-                                                            ModuleEntry* mod, TRAPS) {\n-  ClassLoaderData *loader_data = mod->loader_data();\n-  if (mod->shared_protection_domain() == NULL) {\n-    Symbol* location = mod->location();\n-    if (location != NULL) {\n-      Handle location_string = java_lang_String::create_from_symbol(\n-                                     location, CHECK_NH);\n-      Handle url;\n-      JavaValue result(T_OBJECT);\n-      if (location->starts_with(\"jrt:\/\")) {\n-        url = JavaCalls::construct_new_instance(vmClasses::URL_klass(),\n-                                                vmSymbols::string_void_signature(),\n-                                                location_string, CHECK_NH);\n-      } else {\n-        Klass* classLoaders_klass =\n-          vmClasses::jdk_internal_loader_ClassLoaders_klass();\n-        JavaCalls::call_static(&result, classLoaders_klass, vmSymbols::toFileURL_name(),\n-                               vmSymbols::toFileURL_signature(),\n-                               location_string, CHECK_NH);\n-        url = Handle(THREAD, result.get_oop());\n-      }\n-\n-      Handle pd = get_protection_domain_from_classloader(class_loader, url,\n-                                                         CHECK_NH);\n-      mod->set_shared_protection_domain(loader_data, pd);\n+  Array<InstanceKlass*>* interfaces = k->local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = interfaces->at(i);\n+    if (check_for_exclusion(intf, NULL)) {\n+      log_warning(cds)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n+      return true;\n@@ -868,69 +337,1 @@\n-  Handle protection_domain(THREAD, mod->shared_protection_domain());\n-  assert(protection_domain.not_null(), \"sanity\");\n-  return protection_domain;\n-}\n-\n-\/\/ Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with\n-\/\/ the given InstanceKlass.\n-\/\/ Returns the ProtectionDomain for the InstanceKlass.\n-Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {\n-  Handle pd;\n-\n-  if (ik != NULL) {\n-    int index = ik->shared_classpath_index();\n-    assert(index >= 0, \"Sanity\");\n-    SharedClassPathEntry* ent = FileMapInfo::shared_path(index);\n-    Symbol* class_name = ik->name();\n-\n-    if (ent->is_modules_image()) {\n-      \/\/ For shared app\/platform classes originated from the run-time image:\n-      \/\/   The ProtectionDomains are cached in the corresponding ModuleEntries\n-      \/\/   for fast access by the VM.\n-      \/\/ all packages from module image are already created during VM bootstrap in\n-      \/\/ Modules::define_module().\n-      assert(pkg_entry != NULL, \"archived class in module image cannot be from unnamed package\");\n-      ModuleEntry* mod_entry = pkg_entry->module();\n-      pd = get_shared_protection_domain(class_loader, mod_entry, CHECK_(pd));\n-    } else {\n-      \/\/ For shared app\/platform classes originated from JAR files on the class path:\n-      \/\/   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length\n-      \/\/   as the shared classpath table in the shared archive (see\n-      \/\/   FileMap::_shared_path_table in filemap.hpp for details).\n-      \/\/\n-      \/\/   If a shared InstanceKlass k is loaded from the class path, let\n-      \/\/\n-      \/\/     index = k->shared_classpath_index():\n-      \/\/\n-      \/\/   FileMap::_shared_path_table[index] identifies the JAR file that contains k.\n-      \/\/\n-      \/\/   k's protection domain is:\n-      \/\/\n-      \/\/     ProtectionDomain pd = _shared_protection_domains[index];\n-      \/\/\n-      \/\/   and k's Package is initialized using\n-      \/\/\n-      \/\/     manifest = _shared_jar_manifests[index];\n-      \/\/     url = _shared_jar_urls[index];\n-      \/\/     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-      \/\/\n-      \/\/   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by\n-      \/\/   the corresponding SystemDictionaryShared::get_shared_xxx() function.\n-      Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));\n-      Handle url = get_shared_jar_url(index, CHECK_(pd));\n-      int index_offset = index - ClassLoaderExt::app_class_paths_start_index();\n-      if (index_offset < PackageEntry::max_index_for_defined_in_class_path()) {\n-        if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n-          \/\/ define_shared_package only needs to be called once for each package in a jar specified\n-          \/\/ in the shared class path.\n-          define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-          if (pkg_entry != NULL) {\n-            pkg_entry->set_defined_by_cds_in_class_path(index_offset);\n-          }\n-        }\n-      } else {\n-        define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-      }\n-      pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));\n-    }\n-  }\n-  return pd;\n+  return false; \/\/ false == k should NOT be excluded\n@@ -993,150 +394,2 @@\n-  if (UseSharedSpaces) {\n-    if (!has_platform_or_app_classes()) {\n-      return NULL;\n-    }\n-\n-    if (SystemDictionary::is_system_class_loader(class_loader()) ||\n-        SystemDictionary::is_platform_class_loader(class_loader())) {\n-      \/\/ Fix for 4474172; see evaluation for more details\n-      class_loader = Handle(\n-        THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n-      ClassLoaderData *loader_data = register_loader(class_loader);\n-      Dictionary* dictionary = loader_data->dictionary();\n-      unsigned int d_hash = dictionary->compute_hash(name);\n-\n-      \/\/ Note: currently, find_or_load_shared_class is called only from\n-      \/\/ JVM_FindLoadedClass and used for PlatformClassLoader and AppClassLoader,\n-      \/\/ which are parallel-capable loaders, so a lock here is NOT taken.\n-      assert(get_loader_lock_or_null(class_loader) == NULL, \"ObjectLocker not required\");\n-      {\n-        MutexLocker mu(THREAD, SystemDictionary_lock);\n-        InstanceKlass* check = dictionary->find_class(d_hash, name);\n-        if (check != NULL) {\n-          return check;\n-        }\n-      }\n-\n-      k = load_shared_class_for_builtin_loader(name, class_loader, THREAD);\n-      if (k != NULL) {\n-        SharedClassLoadingMark slm(THREAD, k);\n-        k = find_or_define_instance_class(name, class_loader, k, CHECK_NULL);\n-      }\n-    }\n-  }\n-  return k;\n-}\n-\n-PackageEntry* SystemDictionaryShared::get_package_entry_from_class(InstanceKlass* ik, Handle class_loader) {\n-  PackageEntry* pkg_entry = ik->package();\n-  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != NULL) {\n-    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n-    assert(!ik->is_shared_unregistered_class(), \"unexpected archived package entry for an unregistered class\");\n-    assert(ik->module()->is_named(), \"unexpected archived package entry for a class in an unnamed module\");\n-    return pkg_entry;\n-  }\n-  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(ik->name());\n-  if (pkg_name != NULL) {\n-    pkg_entry = class_loader_data(class_loader)->packages()->lookup_only(pkg_name);\n-  } else {\n-    pkg_entry = NULL;\n-  }\n-  return pkg_entry;\n-}\n-\n-InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(\n-                 Symbol* class_name, Handle class_loader, TRAPS) {\n-  assert(UseSharedSpaces, \"must be\");\n-  InstanceKlass* ik = find_builtin_class(class_name);\n-\n-  if (ik != NULL && !ik->shared_loading_failed()) {\n-    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n-        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n-      SharedClassLoadingMark slm(THREAD, ik);\n-      PackageEntry* pkg_entry = get_package_entry_from_class(ik, class_loader);\n-      Handle protection_domain =\n-        SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);\n-      return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);\n-    }\n-  }\n-  return NULL;\n-}\n-\n-void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {\n-  if (_shared_protection_domains.resolve() == NULL) {\n-    oop spd = oopFactory::new_objArray(\n-        vmClasses::ProtectionDomain_klass(), size, CHECK);\n-    _shared_protection_domains = OopHandle(Universe::vm_global(), spd);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {\n-  if (_shared_jar_urls.resolve() == NULL) {\n-    oop sju = oopFactory::new_objArray(\n-        vmClasses::URL_klass(), size, CHECK);\n-    _shared_jar_urls = OopHandle(Universe::vm_global(), sju);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {\n-  if (_shared_jar_manifests.resolve() == NULL) {\n-    oop sjm = oopFactory::new_objArray(\n-        vmClasses::Jar_Manifest_klass(), size, CHECK);\n-    _shared_jar_manifests = OopHandle(Universe::vm_global(), sjm);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {\n-  allocate_shared_protection_domain_array(size, CHECK);\n-  allocate_shared_jar_url_array(size, CHECK);\n-  allocate_shared_jar_manifest_array(size, CHECK);\n-}\n-\n-\/\/ This function is called for loading only UNREGISTERED classes\n-InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,\n-                                                          Handle class_loader,\n-                                                          Handle protection_domain,\n-                                                          const ClassFileStream* cfs,\n-                                                          TRAPS) {\n-  if (!UseSharedSpaces) {\n-    return NULL;\n-  }\n-  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n-    return NULL;\n-  }\n-  if (class_loader.is_null() ||\n-      SystemDictionary::is_system_class_loader(class_loader()) ||\n-      SystemDictionary::is_platform_class_loader(class_loader())) {\n-    \/\/ Do nothing for the BUILTIN loaders.\n-    return NULL;\n-  }\n-\n-  const RunTimeSharedClassInfo* record = find_record(&_unregistered_dictionary, &_dynamic_unregistered_dictionary, class_name);\n-  if (record == NULL) {\n-    return NULL;\n-  }\n-\n-  int clsfile_size  = cfs->length();\n-  int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs->buffer(), cfs->length());\n-\n-  if (!record->matches(clsfile_size, clsfile_crc32)) {\n-    return NULL;\n-  }\n-\n-  return acquire_class_for_current_thread(record->_klass, class_loader,\n-                                          protection_domain, cfs,\n-                                          THREAD);\n-}\n-\n-InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(\n-                   InstanceKlass *ik,\n-                   Handle class_loader,\n-                   Handle protection_domain,\n-                   const ClassFileStream *cfs,\n-                   TRAPS) {\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n-\n-  {\n-    MutexLocker mu(THREAD, SharedDictionary_lock);\n-    if (ik->class_loader_data() != NULL) {\n-      \/\/    ik is already loaded (by this loader or by a different loader)\n-      \/\/ or ik is being loaded by a different thread (by this loader or by a different loader)\n+  if (UseSharedSpaces) {\n+    if (!has_platform_or_app_classes()) {\n@@ -1146,7 +399,8 @@\n-    \/\/ No other thread has acquired this yet, so give it to *this thread*\n-    ik->set_class_loader_data(loader_data);\n-  }\n-\n-  \/\/ No longer holding SharedDictionary_lock\n-  \/\/ No need to lock, as <ik> can be held only by a single thread.\n-  loader_data->add_class(ik);\n+    if (SystemDictionary::is_system_class_loader(class_loader()) ||\n+        SystemDictionary::is_platform_class_loader(class_loader())) {\n+      \/\/ Fix for 4474172; see evaluation for more details\n+      class_loader = Handle(\n+        THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n+      ClassLoaderData *loader_data = register_loader(class_loader);\n+      Dictionary* dictionary = loader_data->dictionary();\n+      unsigned int d_hash = dictionary->compute_hash(name);\n@@ -1154,2 +408,11 @@\n-  \/\/ Get the package entry.\n-  PackageEntry* pkg_entry = get_package_entry_from_class(ik, class_loader);\n+      \/\/ Note: currently, find_or_load_shared_class is called only from\n+      \/\/ JVM_FindLoadedClass and used for PlatformClassLoader and AppClassLoader,\n+      \/\/ which are parallel-capable loaders, so a lock here is NOT taken.\n+      assert(get_loader_lock_or_null(class_loader) == NULL, \"ObjectLocker not required\");\n+      {\n+        MutexLocker mu(THREAD, SystemDictionary_lock);\n+        InstanceKlass* check = dictionary->find_class(d_hash, name);\n+        if (check != NULL) {\n+          return check;\n+        }\n+      }\n@@ -1157,6 +420,6 @@\n-  \/\/ Load and check super\/interfaces, restore unsharable info\n-  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,\n-                                                  cfs, pkg_entry, THREAD);\n-  if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {\n-    \/\/ TODO: clean up <ik> so it can be used again\n-    return NULL;\n+      k = load_shared_class_for_builtin_loader(name, class_loader, THREAD);\n+      if (k != NULL) {\n+        SharedClassLoadingMark slm(THREAD, k);\n+        k = find_or_define_instance_class(name, class_loader, k, CHECK_NULL);\n+      }\n+    }\n@@ -1164,2 +427,1 @@\n-\n-  return shared_klass;\n+  return k;\n@@ -1246,18 +508,0 @@\n-void SystemDictionaryShared::start_dumping() {\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-  _dump_in_progress = true;\n-}\n-\n-DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-  return find_or_allocate_info_for_locked(k);\n-}\n-\n-DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for_locked(InstanceKlass* k) {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  if (_dumptime_table == NULL) {\n-    _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();\n-  }\n-  return _dumptime_table->find_or_allocate_info_for(k, _dump_in_progress);\n-}\n-\n@@ -1267,1 +511,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1280,1 +524,1 @@\n-  DumpTimeSharedClassInfo* p = _dumptime_table->get(k);\n+  DumpTimeClassInfo* p = _dumptime_table->get(k);\n@@ -1286,1 +530,1 @@\n-      DumpTimeSharedClassInfo::DTVerifierConstraint constraint = p->_verifier_constraints->at(i);\n+      DumpTimeClassInfo::DTVerifierConstraint constraint = p->_verifier_constraints->at(i);\n@@ -1294,1 +538,1 @@\n-    FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTVerifierConstraint, p->_verifier_constraints);\n+    FREE_C_HEAP_ARRAY(DumpTimeClassInfo::DTVerifierConstraint, p->_verifier_constraints);\n@@ -1301,1 +545,1 @@\n-      DumpTimeSharedClassInfo::DTLoaderConstraint ld =  p->_loader_constraints->at(i);\n+      DumpTimeClassInfo::DTLoaderConstraint ld =  p->_loader_constraints->at(i);\n@@ -1306,1 +550,1 @@\n-    FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTLoaderConstraint, p->_loader_constraints);\n+    FREE_C_HEAP_ARRAY(DumpTimeClassInfo::DTLoaderConstraint, p->_loader_constraints);\n@@ -1327,59 +571,0 @@\n-bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {\n-  while (k) {\n-    if (k->name()->equals(\"jdk\/internal\/event\/Event\")) {\n-      return true;\n-    }\n-    k = k->java_super();\n-  }\n-  return false;\n-}\n-\n-bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(ik);\n-  return (info != NULL) ? info->_is_archived_lambda_proxy : false;\n-}\n-\n-bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {\n-  assert(ik->is_shared(), \"applicable to only a shared class\");\n-  if (ik->is_hidden()) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-bool SystemDictionaryShared::is_early_klass(InstanceKlass* ik) {\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(ik);\n-  return (info != NULL) ? info->is_early_klass() : false;\n-}\n-\n-\/\/ Returns true so the caller can do:    return warn_excluded(\".....\");\n-bool SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {\n-  ResourceMark rm;\n-  log_warning(cds)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n-  return true;\n-}\n-\n-bool SystemDictionaryShared::check_for_exclusion(InstanceKlass* k, DumpTimeSharedClassInfo* info) {\n-  if (MetaspaceShared::is_in_shared_metaspace(k)) {\n-    \/\/ We have reached a super type that's already in the base archive. Treat it\n-    \/\/ as \"not excluded\".\n-    assert(DynamicDumpSharedSpaces, \"must be\");\n-    return false;\n-  }\n-\n-  if (info == NULL) {\n-    info = _dumptime_table->get(k);\n-    assert(info != NULL, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n-  }\n-\n-  if (!info->has_checked_exclusion()) {\n-    if (check_for_exclusion_impl(k)) {\n-      info->set_excluded();\n-    }\n-    info->set_has_checked_exclusion();\n-  }\n-\n-  return info->is_excluded();\n-}\n-\n@@ -1404,83 +589,0 @@\n-bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {\n-  if (k->is_in_error_state()) {\n-    return warn_excluded(k, \"In error state\");\n-  }\n-  if (has_been_redefined(k)) {\n-    return warn_excluded(k, \"Has been redefined\");\n-  }\n-  if (!k->is_hidden() && k->shared_classpath_index() < 0 && is_builtin(k)) {\n-    \/\/ These are classes loaded from unsupported locations (such as those loaded by JVMTI native\n-    \/\/ agent during dump time).\n-    return warn_excluded(k, \"Unsupported location\");\n-  }\n-  if (k->signers() != NULL) {\n-    \/\/ We cannot include signed classes in the archive because the certificates\n-    \/\/ used during dump time may be different than those used during\n-    \/\/ runtime (due to expiration, etc).\n-    return warn_excluded(k, \"Signed JAR\");\n-  }\n-  if (is_jfr_event_class(k)) {\n-    \/\/ We cannot include JFR event classes because they need runtime-specific\n-    \/\/ instrumentation in order to work with -XX:FlightRecorderOptions:retransform=false.\n-    \/\/ There are only a small number of these classes, so it's not worthwhile to\n-    \/\/ support them and make CDS more complicated.\n-    return warn_excluded(k, \"JFR event class\");\n-  }\n-  if (k->init_state() < InstanceKlass::linked) {\n-    \/\/ In CDS dumping, we will attempt to link all classes. Those that fail to link will\n-    \/\/ be recorded in DumpTimeSharedClassInfo.\n-    Arguments::assert_is_dumping_archive();\n-\n-    \/\/ TODO -- rethink how this can be handled.\n-    \/\/ We should try to link ik, however, we can't do it here because\n-    \/\/ 1. We are at VM exit\n-    \/\/ 2. linking a class may cause other classes to be loaded, which means\n-    \/\/    a custom ClassLoader.loadClass() may be called, at a point where the\n-    \/\/    class loader doesn't expect it.\n-    if (has_class_failed_verification(k)) {\n-      return warn_excluded(k, \"Failed verification\");\n-    } else {\n-      if (k->can_be_verified_at_dumptime()) {\n-        return warn_excluded(k, \"Not linked\");\n-      }\n-    }\n-  }\n-  if (DynamicDumpSharedSpaces && k->major_version() < 50 \/*JAVA_6_VERSION*\/) {\n-    \/\/ In order to support old classes during dynamic dump, class rewriting needs to\n-    \/\/ be reverted. This would result in more complex code and testing but not much gain.\n-    ResourceMark rm;\n-    log_warning(cds)(\"Pre JDK 6 class not supported by CDS: %u.%u %s\",\n-                     k->major_version(),  k->minor_version(), k->name()->as_C_string());\n-    return true;\n-  }\n-\n-  if (!k->can_be_verified_at_dumptime() && k->is_linked()) {\n-    return warn_excluded(k, \"Old class has been linked\");\n-  }\n-\n-  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n-    ResourceMark rm;\n-    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n-    return true;\n-  }\n-\n-  InstanceKlass* super = k->java_super();\n-  if (super != NULL && check_for_exclusion(super, NULL)) {\n-    ResourceMark rm;\n-    log_warning(cds)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n-    return true;\n-  }\n-\n-  Array<InstanceKlass*>* interfaces = k->local_interfaces();\n-  int len = interfaces->length();\n-  for (int i = 0; i < len; i++) {\n-    InstanceKlass* intf = interfaces->at(i);\n-    if (check_for_exclusion(intf, NULL)) {\n-      log_warning(cds)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n-      return true;\n-    }\n-  }\n-\n-  return false; \/\/ false == k should NOT be excluded\n-}\n-\n@@ -1491,1 +593,1 @@\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(k);\n+  DumpTimeClassInfo* info = _dumptime_table->get(k);\n@@ -1514,1 +616,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1552,1 +654,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1580,1 +682,1 @@\n-  DumpTimeSharedClassInfo* p = find_or_allocate_info_for_locked(k);\n+  DumpTimeClassInfo* p = find_or_allocate_info_for_locked(k);\n@@ -1587,1 +689,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for_locked(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for_locked(k);\n@@ -1595,1 +697,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1603,1 +705,1 @@\n-  DumpTimeSharedClassInfo* p = find_or_allocate_info_for(ik);\n+  DumpTimeClassInfo* p = find_or_allocate_info_for(ik);\n@@ -1616,1 +718,1 @@\n-  DumpTimeSharedClassInfo* p = _dumptime_table->get(ik);\n+  DumpTimeClassInfo* p = _dumptime_table->get(ik);\n@@ -1625,1 +727,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1662,1 +764,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1688,14 +790,6 @@\n-void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {\n-  if (_verifier_constraints == NULL) {\n-    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n-  }\n-  if (_verifier_constraint_flags == NULL) {\n-    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n-  }\n-  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n-  for (int i = 0; i < vc_array->length(); i++) {\n-    DTVerifierConstraint* p = vc_array->adr_at(i);\n-    if (name == p->_name && from_name == p->_from_name) {\n-      return;\n-    }\n+void SystemDictionaryShared::add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey& key,\n+                                                           InstanceKlass* proxy_klass) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  if (_dumptime_lambda_proxy_class_dictionary == NULL) {\n+    _dumptime_lambda_proxy_class_dictionary =\n+      new (ResourceObj::C_HEAP, mtClass)DumpTimeLambdaProxyClassDictionary();\n@@ -1703,15 +797,10 @@\n-  DTVerifierConstraint cons(name, from_name);\n-  vc_array->append(cons);\n-\n-  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n-  char c = 0;\n-  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n-  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n-  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n-  vcflags_array->append(c);\n-\n-  if (log_is_enabled(Trace, cds, verification)) {\n-    ResourceMark rm;\n-    log_trace(cds, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n-                                 k->external_name(), from_name->as_klass_external_name(),\n-                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+  DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n+  if (lambda_info == NULL) {\n+    DumpTimeLambdaProxyClassInfo info;\n+    info.add_proxy_klass(proxy_klass);\n+    _dumptime_lambda_proxy_class_dictionary->put(key, info);\n+    \/\/lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n+    \/\/assert(lambda_info->_proxy_klass == proxy_klass, \"must be\"); \/\/ debug only -- remove\n+    ++_dumptime_lambda_proxy_class_dictionary->_count;\n+  } else {\n+    lambda_info->add_proxy_klass(proxy_klass);\n@@ -1741,1 +830,1 @@\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(lambda_ik);\n+  DumpTimeClassInfo* info = _dumptime_table->get(lambda_ik);\n@@ -1745,1 +834,1 @@\n-    \/\/ Set _is_archived_lambda_proxy in DumpTimeSharedClassInfo so that the lambda_ik\n+    \/\/ Set _is_archived_lambda_proxy in DumpTimeClassInfo so that the lambda_ik\n@@ -1806,1 +895,1 @@\n-  RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(lambda_ik);\n+  RunTimeClassInfo* record = RunTimeClassInfo::get_for(lambda_ik);\n@@ -1816,1 +905,1 @@\n-    protection_domain = SystemDictionaryShared::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);\n+    protection_domain = CDSProtectionDomain::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);\n@@ -1856,58 +945,0 @@\n-static char get_loader_type_by(oop  loader) {\n-  assert(SystemDictionary::is_builtin_class_loader(loader), \"Must be built-in loader\");\n-  if (SystemDictionary::is_boot_class_loader(loader)) {\n-    return (char)ClassLoader::BOOT_LOADER;\n-  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-    return (char)ClassLoader::PLATFORM_LOADER;\n-  } else {\n-    assert(SystemDictionary::is_system_class_loader(loader), \"Class loader mismatch\");\n-    return (char)ClassLoader::APP_LOADER;\n-  }\n-}\n-\n-static oop get_class_loader_by(char type) {\n-  if (type == (char)ClassLoader::BOOT_LOADER) {\n-    return (oop)NULL;\n-  } else if (type == (char)ClassLoader::PLATFORM_LOADER) {\n-    return SystemDictionary::java_platform_loader();\n-  } else {\n-    assert (type == (char)ClassLoader::APP_LOADER, \"Sanity\");\n-    return SystemDictionary::java_system_loader();\n-  }\n-}\n-\n-void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {\n-  assert(loader1 != loader2, \"sanity\");\n-  LogTarget(Info, class, loader, constraints) log;\n-  if (_loader_constraints == NULL) {\n-    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n-  }\n-  char lt1 = get_loader_type_by(loader1());\n-  char lt2 = get_loader_type_by(loader2());\n-  DTLoaderConstraint lc(name, lt1, lt2);\n-  for (int i = 0; i < _loader_constraints->length(); i++) {\n-    DTLoaderConstraint dt = _loader_constraints->at(i);\n-    if (lc.equals(dt)) {\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n-        log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]\",\n-                  _klass->external_name(), name->as_C_string(),\n-                  ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n-                  ClassLoaderData::class_loader_data(loader2())->loader_name_and_id());\n-      }\n-      return;\n-    }\n-  }\n-  _loader_constraints->append(lc);\n-  if (log.is_enabled()) {\n-    ResourceMark rm;\n-    \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n-    log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]\",\n-              _klass->external_name(), name->as_C_string(),\n-              ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n-              ClassLoaderData::class_loader_data(loader2())->loader_name_and_id(),\n-              _loader_constraints->length());\n-  }\n-}\n-\n@@ -1917,1 +948,1 @@\n-  RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(klass);\n+  RunTimeClassInfo* record = RunTimeClassInfo::get_for(klass);\n@@ -1922,1 +953,1 @@\n-      RunTimeSharedClassInfo::RTVerifierConstraint* vc = record->verifier_constraint_at(i);\n+      RunTimeClassInfo::RTVerifierConstraint* vc = record->verifier_constraint_at(i);\n@@ -1955,0 +986,11 @@\n+static oop get_class_loader_by(char type) {\n+  if (type == (char)ClassLoader::BOOT_LOADER) {\n+    return (oop)NULL;\n+  } else if (type == (char)ClassLoader::PLATFORM_LOADER) {\n+    return SystemDictionary::java_platform_loader();\n+  } else {\n+    assert (type == (char)ClassLoader::APP_LOADER, \"Sanity\");\n+    return SystemDictionary::java_system_loader();\n+  }\n+}\n+\n@@ -2015,1 +1057,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(klass);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(klass);\n@@ -2031,1 +1073,1 @@\n-    RunTimeSharedClassInfo* info = RunTimeSharedClassInfo::get_for(klass);\n+    RunTimeClassInfo* info = RunTimeClassInfo::get_for(klass);\n@@ -2036,1 +1078,1 @@\n-        RunTimeSharedClassInfo::RTLoaderConstraint* lc = info->loader_constraint_at(i);\n+        RunTimeClassInfo::RTLoaderConstraint* lc = info->loader_constraint_at(i);\n@@ -2127,1 +1169,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -2129,1 +1171,1 @@\n-      size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n@@ -2236,1 +1278,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -2238,3 +1280,3 @@\n-      size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n-      RunTimeSharedClassInfo* record;\n-      record = (RunTimeSharedClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n+      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      RunTimeClassInfo* record;\n+      record = (RunTimeClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n@@ -2257,2 +1299,2 @@\n-      \/\/ Save this for quick runtime lookup of InstanceKlass* -> RunTimeSharedClassInfo*\n-      RunTimeSharedClassInfo::set_for(info._klass, record);\n+      \/\/ Save this for quick runtime lookup of InstanceKlass* -> RunTimeClassInfo*\n+      RunTimeClassInfo::set_for(info._klass, record);\n@@ -2330,1 +1372,1 @@\n-const RunTimeSharedClassInfo*\n+const RunTimeClassInfo*\n@@ -2338,1 +1380,1 @@\n-  const RunTimeSharedClassInfo* record = NULL;\n+  const RunTimeClassInfo* record = NULL;\n@@ -2366,1 +1408,1 @@\n-  const RunTimeSharedClassInfo* record = find_record(&_builtin_dictionary, &_dynamic_builtin_dictionary, name);\n+  const RunTimeClassInfo* record = find_record(&_builtin_dictionary, &_dynamic_builtin_dictionary, name);\n@@ -2378,1 +1420,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -2406,1 +1448,1 @@\n-  void do_value(const RunTimeSharedClassInfo* record) {\n+  void do_value(const RunTimeClassInfo* record) {\n@@ -2487,1 +1529,1 @@\n-bool SystemDictionaryShared::empty_dumptime_table() {\n+bool SystemDictionaryShared::is_dumptime_table_empty() {\n@@ -2519,1 +1561,1 @@\n-  void do_value(const RunTimeSharedClassInfo* info) {\n+  void do_value(const RunTimeClassInfo* info) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":292,"deletions":1250,"binary":false,"changes":1542,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"cds\/runTimeClassInfo.hpp\"\n@@ -109,1 +112,1 @@\n-class DumpTimeSharedClassInfo;\n+class DumpTimeClassInfo;\n@@ -112,1 +115,1 @@\n-class RunTimeSharedClassInfo;\n+class RunTimeClassInfo;\n@@ -114,0 +117,2 @@\n+class DumpTimeLambdaProxyClassDictionary;\n+class LambdaProxyClassKey;\n@@ -142,7 +147,11 @@\n-  \/\/ These _shared_xxxs arrays are used to initialize the java.lang.Package and\n-  \/\/ java.security.ProtectionDomain objects associated with each shared class.\n-  \/\/\n-  \/\/ See SystemDictionaryShared::init_security_info for more info.\n-  static OopHandle _shared_protection_domains;\n-  static OopHandle _shared_jar_urls;\n-  static OopHandle _shared_jar_manifests;\n+\n+  static DumpTimeSharedClassTable* _dumptime_table;\n+  static DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary;\n+  \/\/ SystemDictionaries in the base layer static archive\n+  static RunTimeSharedDictionary _builtin_dictionary;\n+  static RunTimeSharedDictionary _unregistered_dictionary;\n+  static LambdaProxyClassDictionary _lambda_proxy_class_dictionary;\n+  \/\/ SystemDictionaries in the top layer dynamic archive\n+  static RunTimeSharedDictionary _dynamic_builtin_dictionary;\n+  static RunTimeSharedDictionary _dynamic_unregistered_dictionary;\n+  static LambdaProxyClassDictionary _dynamic_lambda_proxy_class_dictionary;\n@@ -154,66 +163,0 @@\n-  static Handle get_package_name(Symbol*  class_name, TRAPS);\n-\n-  static PackageEntry* get_package_entry_from_class(InstanceKlass* ik, Handle class_loader);\n-\n-\n-  \/\/ Package handling:\n-  \/\/\n-  \/\/ 1. For named modules in the runtime image\n-  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces\n-  \/\/                  to get packages in named modules for shared classes.\n-  \/\/                  Package for non-shared classes in named module is also\n-  \/\/                  handled using JVM_GetSystemPackage(s).\n-  \/\/\n-  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::definePackage(String, Module)\n-  \/\/                  to define package for shared app classes from named\n-  \/\/                  modules.\n-  \/\/\n-  \/\/    PLATFORM  classes: VM calls ClassLoaders.PlatformClassLoader::definePackage(String, Module)\n-  \/\/                  to define package for shared platform classes from named\n-  \/\/                  modules.\n-  \/\/\n-  \/\/ 2. For unnamed modules\n-  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces to\n-  \/\/                  get packages for shared boot classes in unnamed modules.\n-  \/\/\n-  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::defineOrCheckPackage()\n-  \/\/                  with with the manifest and url from archived data.\n-  \/\/\n-  \/\/    PLATFORM  classes: No package is defined.\n-  \/\/\n-  \/\/ The following two define_shared_package() functions are used to define\n-  \/\/ package for shared APP and PLATFORM classes.\n-  static void define_shared_package(Symbol*  class_name,\n-                                    Handle class_loader,\n-                                    Handle manifest,\n-                                    Handle url,\n-                                    TRAPS);\n-\n-  static Handle get_shared_jar_manifest(int shared_path_index, TRAPS);\n-  static Handle get_shared_jar_url(int shared_path_index, TRAPS);\n-  static Handle get_protection_domain_from_classloader(Handle class_loader,\n-                                                       Handle url, TRAPS);\n-  static Handle get_shared_protection_domain(Handle class_loader,\n-                                             int shared_path_index,\n-                                             Handle url,\n-                                             TRAPS);\n-  static Handle get_shared_protection_domain(Handle class_loader,\n-                                             ModuleEntry* mod, TRAPS);\n-\n-  static void atomic_set_array_index(OopHandle array, int index, oop o);\n-\n-  static oop shared_protection_domain(int index);\n-  static void atomic_set_shared_protection_domain(int index, oop pd) {\n-    atomic_set_array_index(_shared_protection_domains, index, pd);\n-  }\n-  static void allocate_shared_protection_domain_array(int size, TRAPS);\n-  static oop shared_jar_url(int index);\n-  static void atomic_set_shared_jar_url(int index, oop url) {\n-    atomic_set_array_index(_shared_jar_urls, index, url);\n-  }\n-  static void allocate_shared_jar_url_array(int size, TRAPS);\n-  static oop shared_jar_manifest(int index);\n-  static void atomic_set_shared_jar_manifest(int index, oop man) {\n-    atomic_set_array_index(_shared_jar_manifests, index, man);\n-  }\n-  static void allocate_shared_jar_manifest_array(int size, TRAPS);\n@@ -226,2 +169,2 @@\n-  static DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k);\n-  static DumpTimeSharedClassInfo* find_or_allocate_info_for_locked(InstanceKlass* k);\n+  static DumpTimeClassInfo* find_or_allocate_info_for(InstanceKlass* k);\n+  static DumpTimeClassInfo* find_or_allocate_info_for_locked(InstanceKlass* k);\n@@ -248,1 +191,0 @@\n-  static Handle init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS);\n@@ -251,1 +193,1 @@\n-  static const RunTimeSharedClassInfo* find_record(RunTimeSharedDictionary* static_dict,\n+  static const RunTimeClassInfo* find_record(RunTimeSharedDictionary* static_dict,\n@@ -310,0 +252,2 @@\n+  static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey& key,\n+                                                             InstanceKlass* proxy_klass) NOT_CDS_RETURN;\n@@ -327,1 +271,1 @@\n-  static bool check_for_exclusion(InstanceKlass* k, DumpTimeSharedClassInfo* info);\n+  static bool check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info);\n@@ -344,1 +288,1 @@\n-  static bool empty_dumptime_table() NOT_CDS_RETURN_(true);\n+  static bool is_dumptime_table_empty() NOT_CDS_RETURN_(true);\n@@ -346,1 +290,0 @@\n-  static Handle create_jar_manifest(const char* man, size_t size, TRAPS) NOT_CDS_RETURN_(Handle());\n@@ -348,1 +291,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":25,"deletions":83,"binary":false,"changes":108,"status":"modified"}]}