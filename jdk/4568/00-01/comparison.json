{"files":[{"patch":"@@ -122,1 +122,3 @@\n-      sharedClassInfo.cpp \\\n+      dumpTimeSharedClassInfo.cpp \\\n+      lambdaProxyClassDictionary.cpp \\\n+      runTimeSharedClassInfo.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/dumpTimeSharedClassInfo.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+\n+void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n+         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {\n+  if (_verifier_constraints == NULL) {\n+    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n+  }\n+  if (_verifier_constraint_flags == NULL) {\n+    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n+  }\n+  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n+  for (int i = 0; i < vc_array->length(); i++) {\n+    DTVerifierConstraint* p = vc_array->adr_at(i);\n+    if (name == p->_name && from_name == p->_from_name) {\n+      return;\n+    }\n+  }\n+  DTVerifierConstraint cons(name, from_name);\n+  vc_array->append(cons);\n+\n+  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n+  char c = 0;\n+  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n+  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n+  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n+  vcflags_array->append(c);\n+\n+  if (log_is_enabled(Trace, cds, verification)) {\n+    ResourceMark rm;\n+    log_trace(cds, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n+                                 k->external_name(), from_name->as_klass_external_name(),\n+                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+  }\n+}\n+\n+static char get_loader_type_by(oop  loader) {\n+  assert(SystemDictionary::is_builtin_class_loader(loader), \"Must be built-in loader\");\n+  if (SystemDictionary::is_boot_class_loader(loader)) {\n+    return (char)ClassLoader::BOOT_LOADER;\n+  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+    return (char)ClassLoader::PLATFORM_LOADER;\n+  } else {\n+    assert(SystemDictionary::is_system_class_loader(loader), \"Class loader mismatch\");\n+    return (char)ClassLoader::APP_LOADER;\n+  }\n+}\n+\n+void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {\n+  assert(loader1 != loader2, \"sanity\");\n+  LogTarget(Info, class, loader, constraints) log;\n+  if (_loader_constraints == NULL) {\n+    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n+  }\n+  char lt1 = get_loader_type_by(loader1());\n+  char lt2 = get_loader_type_by(loader2());\n+  DTLoaderConstraint lc(name, lt1, lt2);\n+  for (int i = 0; i < _loader_constraints->length(); i++) {\n+    DTLoaderConstraint dt = _loader_constraints->at(i);\n+    if (lc.equals(dt)) {\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n+        log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]\",\n+                  _klass->external_name(), name->as_C_string(),\n+                  ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n+                  ClassLoaderData::class_loader_data(loader2())->loader_name_and_id());\n+      }\n+      return;\n+    }\n+  }\n+  _loader_constraints->append(lc);\n+  if (log.is_enabled()) {\n+    ResourceMark rm;\n+    \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n+    log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]\",\n+              _klass->external_name(), name->as_C_string(),\n+              ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n+              ClassLoaderData::class_loader_data(loader2())->loader_name_and_id(),\n+              _loader_constraints->length());\n+  }\n+}\n+\n+bool DumpTimeSharedClassInfo::is_builtin() {\n+  return SystemDictionaryShared::is_builtin(_klass);\n+}\n+\n+DumpTimeSharedClassInfo* DumpTimeSharedClassTable::find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress) {\n+  bool created = false;\n+  DumpTimeSharedClassInfo* p;\n+  if (!dump_in_progress) {\n+    p = put_if_absent(k, &created);\n+  } else {\n+    p = get(k);\n+  }\n+  if (created) {\n+    assert(!SystemDictionaryShared::no_class_loading_should_happen(),\n+           \"no new classes can be loaded while dumping archive\");\n+    p->_klass = k;\n+  } else {\n+    if (!dump_in_progress) {\n+      assert(p->_klass == k, \"Sanity\");\n+    }\n+  }\n+  return p;\n+}\n+\n+class CountClassByCategory : StackObj {\n+  DumpTimeSharedClassTable* _table;\n+public:\n+  CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}\n+  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+    if (!info.is_excluded()) {\n+      if (info.is_builtin()) {\n+        _table->inc_builtin_count();\n+      } else {\n+        _table->inc_unregistered_count();\n+      }\n+    }\n+    return true; \/\/ keep on iterating\n+  }\n+};\n+\n+void DumpTimeSharedClassTable::update_counts() {\n+  _builtin_count = 0;\n+  _unregistered_count = 0;\n+  CountClassByCategory counter(this);\n+  iterate(&counter);\n+}\n","filename":"src\/hotspot\/share\/cds\/dumpTimeSharedClassInfo.cpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n+#define SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n+#include \"classfile\/compactHashtable.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+class Symbol;\n+\n+class DumpTimeSharedClassInfo: public CHeapObj<mtClass> {\n+  bool                         _excluded;\n+  bool                         _is_early_klass;\n+  bool                         _has_checked_exclusion;\n+public:\n+  struct DTLoaderConstraint {\n+    Symbol* _name;\n+    char _loader_type1;\n+    char _loader_type2;\n+    DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {\n+      _name->increment_refcount();\n+    }\n+    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n+    bool equals(const DTLoaderConstraint& t) {\n+      return t._name == _name &&\n+             ((t._loader_type1 == _loader_type1 && t._loader_type2 == _loader_type2) ||\n+              (t._loader_type2 == _loader_type1 && t._loader_type1 == _loader_type2));\n+    }\n+  };\n+\n+  struct DTVerifierConstraint {\n+    Symbol* _name;\n+    Symbol* _from_name;\n+    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n+    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n+      _name->increment_refcount();\n+      _from_name->increment_refcount();\n+    }\n+  };\n+\n+  InstanceKlass*               _klass;\n+  InstanceKlass*               _nest_host;\n+  bool                         _failed_verification;\n+  bool                         _is_archived_lambda_proxy;\n+  int                          _id;\n+  int                          _clsfile_size;\n+  int                          _clsfile_crc32;\n+  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n+  GrowableArray<char>*                 _verifier_constraint_flags;\n+  GrowableArray<DTLoaderConstraint>*   _loader_constraints;\n+\n+  DumpTimeSharedClassInfo() {\n+    _klass = NULL;\n+    _nest_host = NULL;\n+    _failed_verification = false;\n+    _is_archived_lambda_proxy = false;\n+    _has_checked_exclusion = false;\n+    _id = -1;\n+    _clsfile_size = -1;\n+    _clsfile_crc32 = -1;\n+    _excluded = false;\n+    _is_early_klass = JvmtiExport::is_early_phase();\n+    _verifier_constraints = NULL;\n+    _verifier_constraint_flags = NULL;\n+    _loader_constraints = NULL;\n+  }\n+\n+  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n+         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n+  void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);\n+\n+  bool is_builtin();\n+\n+  int num_verifier_constraints() {\n+    if (_verifier_constraint_flags != NULL) {\n+      return _verifier_constraint_flags->length();\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  int num_loader_constraints() {\n+    if (_loader_constraints != NULL) {\n+      return _loader_constraints->length();\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_klass);\n+    it->push(&_nest_host);\n+    if (_verifier_constraints != NULL) {\n+      for (int i = 0; i < _verifier_constraints->length(); i++) {\n+        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n+        it->push(&cons->_name);\n+        it->push(&cons->_from_name);\n+      }\n+    }\n+    if (_loader_constraints != NULL) {\n+      for (int i = 0; i < _loader_constraints->length(); i++) {\n+        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n+        it->push(&lc->_name);\n+      }\n+    }\n+  }\n+\n+  bool is_excluded() {\n+    \/\/ _klass may become NULL due to DynamicArchiveBuilder::set_to_null\n+    return _excluded || _failed_verification || _klass == NULL;\n+  }\n+\n+  \/\/ Was this class loaded while JvmtiExport::is_early_phase()==true\n+  bool is_early_klass() {\n+    return _is_early_klass;\n+  }\n+\n+  \/\/ simple accessors\n+  void set_excluded()                               { _excluded = true; }\n+  bool has_checked_exclusion() const                { return _has_checked_exclusion; }\n+  void set_has_checked_exclusion()                  { _has_checked_exclusion = true; }\n+  bool failed_verification() const                  { return _failed_verification; }\n+  void set_failed_verification()                    { _failed_verification = true; }\n+  InstanceKlass* nest_host() const                  { return _nest_host; }\n+  void set_nest_host(InstanceKlass* nest_host)      { _nest_host = nest_host; }\n+};\n+\n+\n+inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n+  if (DumpSharedSpaces) {\n+    \/\/ Deterministic archive contents\n+    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n+    return primitive_hash<uintx>(delta);\n+  } else {\n+    \/\/ Deterministic archive is not possible because classes can be loaded\n+    \/\/ in multiple threads.\n+    return primitive_hash<InstanceKlass*>(k);\n+  }\n+}\n+\n+class DumpTimeSharedClassTable: public ResourceHashtable<\n+  InstanceKlass*,\n+  DumpTimeSharedClassInfo,\n+  &DumpTimeSharedClassTable_hash,\n+  primitive_equals<InstanceKlass*>,\n+  15889, \/\/ prime number\n+  ResourceObj::C_HEAP>\n+{\n+  int _builtin_count;\n+  int _unregistered_count;\n+public:\n+  DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress);\n+  void inc_builtin_count()      { _builtin_count++; }\n+  void inc_unregistered_count() { _unregistered_count++; }\n+  void update_counts();\n+  int count_of(bool is_builtin) const {\n+    if (is_builtin) {\n+      return _builtin_count;\n+    } else {\n+      return _unregistered_count;\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/dumpTimeSharedClassInfo.hpp","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+\n+void LambdaProxyClassKey::mark_pointers() {\n+  ArchivePtrMarker::mark_pointer(&_caller_ik);\n+  ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n+  ArchivePtrMarker::mark_pointer(&_invoked_name);\n+  ArchivePtrMarker::mark_pointer(&_invoked_type);\n+  ArchivePtrMarker::mark_pointer(&_member_method);\n+  ArchivePtrMarker::mark_pointer(&_method_type);\n+}\n+\n+unsigned int LambdaProxyClassKey::hash() const {\n+  return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n+}\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -27,2 +27,1 @@\n-#include \"cds\/sharedClassInfo.hpp\"\n-#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -30,0 +29,5 @@\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+class Symbol;\n@@ -150,5 +154,0 @@\n-class LambdaProxyClassDictionary : public OffsetCompactHashtable<\n-  LambdaProxyClassKey*,\n-  const RunTimeLambdaProxyClassInfo*,\n-  RunTimeLambdaProxyClassInfo::EQUALS> {};\n-\n@@ -166,0 +165,5 @@\n+class LambdaProxyClassDictionary : public OffsetCompactHashtable<\n+  LambdaProxyClassKey*,\n+  const RunTimeLambdaProxyClassInfo*,\n+  RunTimeLambdaProxyClassInfo::EQUALS> {};\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"previous_filename":"src\/hotspot\/share\/cds\/lambdaProxyClassInfo.hpp","status":"renamed"},{"patch":"@@ -0,0 +1,76 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/runTimeSharedClassInfo.hpp\"\n+\n+void RunTimeSharedClassInfo::init(DumpTimeSharedClassInfo& info) {\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+  assert(builder->is_in_buffer_space(info._klass), \"must be\");\n+  _klass = info._klass;\n+  if (!SystemDictionaryShared::is_builtin(_klass)) {\n+    CrcInfo* c = crc();\n+    c->_clsfile_size = info._clsfile_size;\n+    c->_clsfile_crc32 = info._clsfile_crc32;\n+  }\n+  _num_verifier_constraints = info.num_verifier_constraints();\n+  _num_loader_constraints   = info.num_loader_constraints();\n+  int i;\n+  if (_num_verifier_constraints > 0) {\n+    RTVerifierConstraint* vf_constraints = verifier_constraints();\n+    char* flags = verifier_constraint_flags();\n+    for (i = 0; i < _num_verifier_constraints; i++) {\n+      vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n+      vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n+    }\n+    for (i = 0; i < _num_verifier_constraints; i++) {\n+      flags[i] = info._verifier_constraint_flags->at(i);\n+    }\n+  }\n+\n+  if (_num_loader_constraints > 0) {\n+    RTLoaderConstraint* ld_constraints = loader_constraints();\n+    for (i = 0; i < _num_loader_constraints; i++) {\n+      ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n+      ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n+      ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n+    }\n+  }\n+\n+  if (_klass->is_hidden()) {\n+    InstanceKlass* n_h = info.nest_host();\n+    set_nest_host(n_h);\n+  }\n+  ArchivePtrMarker::mark_pointer(&_klass);\n+}\n+\n+size_t RunTimeSharedClassInfo::crc_size(InstanceKlass* klass) {\n+  if (!SystemDictionaryShared::is_builtin(klass)) {\n+    return sizeof(CrcInfo);\n+  } else {\n+    return 0;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/runTimeSharedClassInfo.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_SHAREDCLASSINFO_HPP\n+#define SHARED_CDS_SHAREDCLASSINFO_HPP\n+#include \"classfile\/compactHashtable.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class Method;\n+class Symbol;\n+\n+class RunTimeSharedClassInfo {\n+public:\n+  struct CrcInfo {\n+    int _clsfile_size;\n+    int _clsfile_crc32;\n+  };\n+\n+  \/\/ This is different than  DumpTimeSharedClassInfo::DTVerifierConstraint. We use\n+  \/\/ u4 instead of Symbol* to save space on 64-bit CPU.\n+  struct RTVerifierConstraint {\n+    u4 _name;\n+    u4 _from_name;\n+    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n+    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n+  };\n+\n+  struct RTLoaderConstraint {\n+    u4   _name;\n+    char _loader_type1;\n+    char _loader_type2;\n+    Symbol* constraint_name() {\n+      return (Symbol*)(SharedBaseAddress + _name);\n+    }\n+  };\n+\n+  InstanceKlass* _klass;\n+  int _num_verifier_constraints;\n+  int _num_loader_constraints;\n+\n+  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n+  \/\/ optional InstanceKlass*       _nest_host\n+  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n+  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n+  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n+\n+private:\n+  static size_t header_size_size() {\n+    return sizeof(RunTimeSharedClassInfo);\n+  }\n+  static size_t verifier_constraints_size(int num_verifier_constraints) {\n+    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n+  }\n+  static size_t verifier_constraint_flags_size(int num_verifier_constraints) {\n+    return sizeof(char) * num_verifier_constraints;\n+  }\n+  static size_t loader_constraints_size(int num_loader_constraints) {\n+    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n+  }\n+  static size_t nest_host_size(InstanceKlass* klass) {\n+    if (klass->is_hidden()) {\n+      return sizeof(InstanceKlass*);\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  static size_t crc_size(InstanceKlass* klass);\n+public:\n+  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n+    return header_size_size() +\n+           crc_size(klass) +\n+           nest_host_size(klass) +\n+           loader_constraints_size(num_loader_constraints) +\n+           verifier_constraints_size(num_verifier_constraints) +\n+           verifier_constraint_flags_size(num_verifier_constraints);\n+  }\n+\n+private:\n+  size_t crc_offset() const {\n+    return header_size_size();\n+  }\n+\n+  size_t nest_host_offset() const {\n+      return crc_offset() + crc_size(_klass);\n+  }\n+\n+  size_t loader_constraints_offset() const  {\n+    return nest_host_offset() + nest_host_size(_klass);\n+  }\n+  size_t verifier_constraints_offset() const {\n+    return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);\n+  }\n+  size_t verifier_constraint_flags_offset() const {\n+    return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);\n+  }\n+\n+  void check_verifier_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_verifier_constraints, \"sanity\");\n+  }\n+\n+  void check_loader_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_loader_constraints, \"sanity\");\n+  }\n+\n+public:\n+  CrcInfo* crc() const {\n+    assert(crc_size(_klass) > 0, \"must be\");\n+    return (CrcInfo*)(address(this) + crc_offset());\n+  }\n+  RTVerifierConstraint* verifier_constraints() {\n+    assert(_num_verifier_constraints > 0, \"sanity\");\n+    return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());\n+  }\n+  RTVerifierConstraint* verifier_constraint_at(int i) {\n+    check_verifier_constraint_offset(i);\n+    return verifier_constraints() + i;\n+  }\n+\n+  char* verifier_constraint_flags() {\n+    assert(_num_verifier_constraints > 0, \"sanity\");\n+    return (char*)(address(this) + verifier_constraint_flags_offset());\n+  }\n+\n+  InstanceKlass** nest_host_addr() {\n+    assert(_klass->is_hidden(), \"sanity\");\n+    return (InstanceKlass**)(address(this) + nest_host_offset());\n+  }\n+  InstanceKlass* nest_host() {\n+    return *nest_host_addr();\n+  }\n+  void set_nest_host(InstanceKlass* k) {\n+    *nest_host_addr() = k;\n+    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n+  }\n+\n+  RTLoaderConstraint* loader_constraints() {\n+    assert(_num_loader_constraints > 0, \"sanity\");\n+    return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());\n+  }\n+\n+  RTLoaderConstraint* loader_constraint_at(int i) {\n+    check_loader_constraint_offset(i);\n+    return loader_constraints() + i;\n+  }\n+\n+  void init(DumpTimeSharedClassInfo& info);\n+\n+  bool matches(int clsfile_size, int clsfile_crc32) const {\n+    return crc()->_clsfile_size  == clsfile_size &&\n+           crc()->_clsfile_crc32 == clsfile_crc32;\n+  }\n+\n+  char verifier_constraint_flag(int i) {\n+    check_verifier_constraint_offset(i);\n+    return verifier_constraint_flags()[i];\n+  }\n+\n+private:\n+  \/\/ ArchiveBuilder::make_shallow_copy() has reserved a pointer immediately\n+  \/\/ before archived InstanceKlasses. We can use this slot to do a quick\n+  \/\/ lookup of InstanceKlass* -> RunTimeSharedClassInfo* without\n+  \/\/ building a new hashtable.\n+  \/\/\n+  \/\/  info_pointer_addr(klass) --> 0x0100   RunTimeSharedClassInfo*\n+  \/\/  InstanceKlass* klass     --> 0x0108   <C++ vtbl>\n+  \/\/                               0x0110   fields from Klass ...\n+  static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {\n+    return &((RunTimeSharedClassInfo**)klass)[-1];\n+  }\n+\n+public:\n+  static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {\n+    assert(klass->is_shared(), \"don't call for non-shared class\");\n+    return *info_pointer_addr(klass);\n+  }\n+  static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n+    *info_pointer_addr(klass) = record;\n+    ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));\n+  }\n+\n+  \/\/ Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS\n+  static inline bool EQUALS(\n+       const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {\n+    return (value->_klass->name() == key);\n+  }\n+};\n+\n+class RunTimeSharedDictionary : public OffsetCompactHashtable<\n+  Symbol*,\n+  const RunTimeSharedClassInfo*,\n+  RunTimeSharedClassInfo::EQUALS> {};\n+#endif \/\/ SHARED_CDS_SHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/runTimeSharedClassInfo.hpp","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -1,224 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"cds\/archiveBuilder.hpp\"\n-#include \"cds\/sharedClassInfo.hpp\"\n-#include \"cds\/lambdaProxyClassInfo.hpp\"\n-#include \"classfile\/classLoader.hpp\"\n-#include \"classfile\/classLoaderData.inline.hpp\"\n-#include \"classfile\/systemDictionaryShared.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-\n-void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {\n-  if (_verifier_constraints == NULL) {\n-    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n-  }\n-  if (_verifier_constraint_flags == NULL) {\n-    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n-  }\n-  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n-  for (int i = 0; i < vc_array->length(); i++) {\n-    DTVerifierConstraint* p = vc_array->adr_at(i);\n-    if (name == p->_name && from_name == p->_from_name) {\n-      return;\n-    }\n-  }\n-  DTVerifierConstraint cons(name, from_name);\n-  vc_array->append(cons);\n-\n-  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n-  char c = 0;\n-  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n-  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n-  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n-  vcflags_array->append(c);\n-\n-  if (log_is_enabled(Trace, cds, verification)) {\n-    ResourceMark rm;\n-    log_trace(cds, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n-                                 k->external_name(), from_name->as_klass_external_name(),\n-                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n-  }\n-}\n-\n-static char get_loader_type_by(oop  loader) {\n-  assert(SystemDictionary::is_builtin_class_loader(loader), \"Must be built-in loader\");\n-  if (SystemDictionary::is_boot_class_loader(loader)) {\n-    return (char)ClassLoader::BOOT_LOADER;\n-  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-    return (char)ClassLoader::PLATFORM_LOADER;\n-  } else {\n-    assert(SystemDictionary::is_system_class_loader(loader), \"Class loader mismatch\");\n-    return (char)ClassLoader::APP_LOADER;\n-  }\n-}\n-\n-void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {\n-  assert(loader1 != loader2, \"sanity\");\n-  LogTarget(Info, class, loader, constraints) log;\n-  if (_loader_constraints == NULL) {\n-    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n-  }\n-  char lt1 = get_loader_type_by(loader1());\n-  char lt2 = get_loader_type_by(loader2());\n-  DTLoaderConstraint lc(name, lt1, lt2);\n-  for (int i = 0; i < _loader_constraints->length(); i++) {\n-    DTLoaderConstraint dt = _loader_constraints->at(i);\n-    if (lc.equals(dt)) {\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n-        log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]\",\n-                  _klass->external_name(), name->as_C_string(),\n-                  ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n-                  ClassLoaderData::class_loader_data(loader2())->loader_name_and_id());\n-      }\n-      return;\n-    }\n-  }\n-  _loader_constraints->append(lc);\n-  if (log.is_enabled()) {\n-    ResourceMark rm;\n-    \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n-    log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]\",\n-              _klass->external_name(), name->as_C_string(),\n-              ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n-              ClassLoaderData::class_loader_data(loader2())->loader_name_and_id(),\n-              _loader_constraints->length());\n-  }\n-}\n-\n-bool DumpTimeSharedClassInfo::is_builtin() {\n-  return SystemDictionaryShared::is_builtin(_klass);\n-}\n-\n-DumpTimeSharedClassInfo* DumpTimeSharedClassTable::find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress) {\n-  bool created = false;\n-  DumpTimeSharedClassInfo* p;\n-  if (!dump_in_progress) {\n-    p = put_if_absent(k, &created);\n-  } else {\n-    p = get(k);\n-  }\n-  if (created) {\n-    assert(!SystemDictionaryShared::no_class_loading_should_happen(),\n-           \"no new classes can be loaded while dumping archive\");\n-    p->_klass = k;\n-  } else {\n-    if (!dump_in_progress) {\n-      assert(p->_klass == k, \"Sanity\");\n-    }\n-  }\n-  return p;\n-}\n-\n-class CountClassByCategory : StackObj {\n-  DumpTimeSharedClassTable* _table;\n-public:\n-  CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n-    if (!info.is_excluded()) {\n-      if (info.is_builtin()) {\n-        _table->inc_builtin_count();\n-      } else {\n-        _table->inc_unregistered_count();\n-      }\n-    }\n-    return true; \/\/ keep on iterating\n-  }\n-};\n-\n-void DumpTimeSharedClassTable::update_counts() {\n-  _builtin_count = 0;\n-  _unregistered_count = 0;\n-  CountClassByCategory counter(this);\n-  iterate(&counter);\n-}\n-\n-size_t RunTimeSharedClassInfo::crc_size(InstanceKlass* klass) {\n-  if (!SystemDictionaryShared::is_builtin(klass)) {\n-    return sizeof(CrcInfo);\n-  } else {\n-    return 0;\n-  }\n-}\n-\n-void RunTimeSharedClassInfo::init(DumpTimeSharedClassInfo& info) {\n-  ArchiveBuilder* builder = ArchiveBuilder::current();\n-  assert(builder->is_in_buffer_space(info._klass), \"must be\");\n-  _klass = info._klass;\n-  if (!SystemDictionaryShared::is_builtin(_klass)) {\n-    CrcInfo* c = crc();\n-    c->_clsfile_size = info._clsfile_size;\n-    c->_clsfile_crc32 = info._clsfile_crc32;\n-  }\n-  _num_verifier_constraints = info.num_verifier_constraints();\n-  _num_loader_constraints   = info.num_loader_constraints();\n-  int i;\n-  if (_num_verifier_constraints > 0) {\n-    RTVerifierConstraint* vf_constraints = verifier_constraints();\n-    char* flags = verifier_constraint_flags();\n-    for (i = 0; i < _num_verifier_constraints; i++) {\n-      vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n-      vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n-    }\n-    for (i = 0; i < _num_verifier_constraints; i++) {\n-      flags[i] = info._verifier_constraint_flags->at(i);\n-    }\n-  }\n-\n-  if (_num_loader_constraints > 0) {\n-    RTLoaderConstraint* ld_constraints = loader_constraints();\n-    for (i = 0; i < _num_loader_constraints; i++) {\n-      ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n-      ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n-      ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n-    }\n-  }\n-\n-  if (_klass->is_hidden()) {\n-    InstanceKlass* n_h = info.nest_host();\n-    set_nest_host(n_h);\n-  }\n-  ArchivePtrMarker::mark_pointer(&_klass);\n-}\n-\n-void LambdaProxyClassKey::mark_pointers() {\n-  ArchivePtrMarker::mark_pointer(&_caller_ik);\n-  ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n-  ArchivePtrMarker::mark_pointer(&_invoked_name);\n-  ArchivePtrMarker::mark_pointer(&_invoked_type);\n-  ArchivePtrMarker::mark_pointer(&_member_method);\n-  ArchivePtrMarker::mark_pointer(&_method_type);\n-}\n-\n-unsigned int LambdaProxyClassKey::hash() const {\n-  return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n-         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n-         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n-         SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n-         SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n-}\n","filename":"src\/hotspot\/share\/cds\/sharedClassInfo.cpp","additions":0,"deletions":224,"binary":false,"changes":224,"status":"deleted"},{"patch":"@@ -1,379 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARED_CDS_SHAREDCLASSINFO_HPP\n-#define SHARED_CDS_SHAREDCLASSINFO_HPP\n-#include \"classfile\/compactHashtable.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/systemDictionaryShared.hpp\"\n-#include \"cds\/archiveBuilder.hpp\"\n-#include \"cds\/archiveUtils.hpp\"\n-#include \"cds\/metaspaceShared.hpp\"\n-#include \"memory\/metaspaceClosure.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"prims\/jvmtiExport.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n-\n-class Method;\n-class Symbol;\n-\n-class DumpTimeSharedClassInfo: public CHeapObj<mtClass> {\n-  bool                         _excluded;\n-  bool                         _is_early_klass;\n-  bool                         _has_checked_exclusion;\n-public:\n-  struct DTLoaderConstraint {\n-    Symbol* _name;\n-    char _loader_type1;\n-    char _loader_type2;\n-    DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {\n-      _name->increment_refcount();\n-    }\n-    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n-    bool equals(const DTLoaderConstraint& t) {\n-      return t._name == _name &&\n-             ((t._loader_type1 == _loader_type1 && t._loader_type2 == _loader_type2) ||\n-              (t._loader_type2 == _loader_type1 && t._loader_type1 == _loader_type2));\n-    }\n-  };\n-\n-  struct DTVerifierConstraint {\n-    Symbol* _name;\n-    Symbol* _from_name;\n-    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n-    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n-      _name->increment_refcount();\n-      _from_name->increment_refcount();\n-    }\n-  };\n-\n-  InstanceKlass*               _klass;\n-  InstanceKlass*               _nest_host;\n-  bool                         _failed_verification;\n-  bool                         _is_archived_lambda_proxy;\n-  int                          _id;\n-  int                          _clsfile_size;\n-  int                          _clsfile_crc32;\n-  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n-  GrowableArray<char>*                 _verifier_constraint_flags;\n-  GrowableArray<DTLoaderConstraint>*   _loader_constraints;\n-\n-  DumpTimeSharedClassInfo() {\n-    _klass = NULL;\n-    _nest_host = NULL;\n-    _failed_verification = false;\n-    _is_archived_lambda_proxy = false;\n-    _has_checked_exclusion = false;\n-    _id = -1;\n-    _clsfile_size = -1;\n-    _clsfile_crc32 = -1;\n-    _excluded = false;\n-    _is_early_klass = JvmtiExport::is_early_phase();\n-    _verifier_constraints = NULL;\n-    _verifier_constraint_flags = NULL;\n-    _loader_constraints = NULL;\n-  }\n-\n-  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n-  void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);\n-\n-  bool is_builtin();\n-\n-  int num_verifier_constraints() {\n-    if (_verifier_constraint_flags != NULL) {\n-      return _verifier_constraint_flags->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n-\n-  int num_loader_constraints() {\n-    if (_loader_constraints != NULL) {\n-      return _loader_constraints->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n-\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    it->push(&_klass);\n-    it->push(&_nest_host);\n-    if (_verifier_constraints != NULL) {\n-      for (int i = 0; i < _verifier_constraints->length(); i++) {\n-        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n-        it->push(&cons->_name);\n-        it->push(&cons->_from_name);\n-      }\n-    }\n-    if (_loader_constraints != NULL) {\n-      for (int i = 0; i < _loader_constraints->length(); i++) {\n-        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n-        it->push(&lc->_name);\n-      }\n-    }\n-  }\n-\n-  bool is_excluded() {\n-    \/\/ _klass may become NULL due to DynamicArchiveBuilder::set_to_null\n-    return _excluded || _failed_verification || _klass == NULL;\n-  }\n-\n-  \/\/ Was this class loaded while JvmtiExport::is_early_phase()==true\n-  bool is_early_klass() {\n-    return _is_early_klass;\n-  }\n-\n-  \/\/ simple accessors\n-  void set_excluded()                               { _excluded = true; }\n-  bool has_checked_exclusion() const                { return _has_checked_exclusion; }\n-  void set_has_checked_exclusion()                  { _has_checked_exclusion = true; }\n-  bool failed_verification() const                  { return _failed_verification; }\n-  void set_failed_verification()                    { _failed_verification = true; }\n-  InstanceKlass* nest_host() const                  { return _nest_host; }\n-  void set_nest_host(InstanceKlass* nest_host)      { _nest_host = nest_host; }\n-};\n-\n-\n-inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n-  if (DumpSharedSpaces) {\n-    \/\/ Deterministic archive contents\n-    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n-    return primitive_hash<uintx>(delta);\n-  } else {\n-    \/\/ Deterministic archive is not possible because classes can be loaded\n-    \/\/ in multiple threads.\n-    return primitive_hash<InstanceKlass*>(k);\n-  }\n-}\n-\n-class DumpTimeSharedClassTable: public ResourceHashtable<\n-  InstanceKlass*,\n-  DumpTimeSharedClassInfo,\n-  &DumpTimeSharedClassTable_hash,\n-  primitive_equals<InstanceKlass*>,\n-  15889, \/\/ prime number\n-  ResourceObj::C_HEAP>\n-{\n-  int _builtin_count;\n-  int _unregistered_count;\n-public:\n-  DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress);\n-  void inc_builtin_count()      { _builtin_count++; }\n-  void inc_unregistered_count() { _unregistered_count++; }\n-  void update_counts();\n-  int count_of(bool is_builtin) const {\n-    if (is_builtin) {\n-      return _builtin_count;\n-    } else {\n-      return _unregistered_count;\n-    }\n-  }\n-};\n-\n-class RunTimeSharedClassInfo {\n-public:\n-  struct CrcInfo {\n-    int _clsfile_size;\n-    int _clsfile_crc32;\n-  };\n-\n-  \/\/ This is different than  DumpTimeSharedClassInfo::DTVerifierConstraint. We use\n-  \/\/ u4 instead of Symbol* to save space on 64-bit CPU.\n-  struct RTVerifierConstraint {\n-    u4 _name;\n-    u4 _from_name;\n-    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n-    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n-  };\n-\n-  struct RTLoaderConstraint {\n-    u4   _name;\n-    char _loader_type1;\n-    char _loader_type2;\n-    Symbol* constraint_name() {\n-      return (Symbol*)(SharedBaseAddress + _name);\n-    }\n-  };\n-\n-  InstanceKlass* _klass;\n-  int _num_verifier_constraints;\n-  int _num_loader_constraints;\n-\n-  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n-  \/\/ optional InstanceKlass*       _nest_host\n-  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n-  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n-  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n-\n-private:\n-  static size_t header_size_size() {\n-    return sizeof(RunTimeSharedClassInfo);\n-  }\n-  static size_t verifier_constraints_size(int num_verifier_constraints) {\n-    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n-  }\n-  static size_t verifier_constraint_flags_size(int num_verifier_constraints) {\n-    return sizeof(char) * num_verifier_constraints;\n-  }\n-  static size_t loader_constraints_size(int num_loader_constraints) {\n-    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n-  }\n-  static size_t nest_host_size(InstanceKlass* klass) {\n-    if (klass->is_hidden()) {\n-      return sizeof(InstanceKlass*);\n-    } else {\n-      return 0;\n-    }\n-  }\n-\n-  static size_t crc_size(InstanceKlass* klass);\n-public:\n-  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n-    return header_size_size() +\n-           crc_size(klass) +\n-           nest_host_size(klass) +\n-           loader_constraints_size(num_loader_constraints) +\n-           verifier_constraints_size(num_verifier_constraints) +\n-           verifier_constraint_flags_size(num_verifier_constraints);\n-  }\n-\n-private:\n-  size_t crc_offset() const {\n-    return header_size_size();\n-  }\n-\n-  size_t nest_host_offset() const {\n-      return crc_offset() + crc_size(_klass);\n-  }\n-\n-  size_t loader_constraints_offset() const  {\n-    return nest_host_offset() + nest_host_size(_klass);\n-  }\n-  size_t verifier_constraints_offset() const {\n-    return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);\n-  }\n-  size_t verifier_constraint_flags_offset() const {\n-    return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);\n-  }\n-\n-  void check_verifier_constraint_offset(int i) const {\n-    assert(0 <= i && i < _num_verifier_constraints, \"sanity\");\n-  }\n-\n-  void check_loader_constraint_offset(int i) const {\n-    assert(0 <= i && i < _num_loader_constraints, \"sanity\");\n-  }\n-\n-public:\n-  CrcInfo* crc() const {\n-    assert(crc_size(_klass) > 0, \"must be\");\n-    return (CrcInfo*)(address(this) + crc_offset());\n-  }\n-  RTVerifierConstraint* verifier_constraints() {\n-    assert(_num_verifier_constraints > 0, \"sanity\");\n-    return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());\n-  }\n-  RTVerifierConstraint* verifier_constraint_at(int i) {\n-    check_verifier_constraint_offset(i);\n-    return verifier_constraints() + i;\n-  }\n-\n-  char* verifier_constraint_flags() {\n-    assert(_num_verifier_constraints > 0, \"sanity\");\n-    return (char*)(address(this) + verifier_constraint_flags_offset());\n-  }\n-\n-  InstanceKlass** nest_host_addr() {\n-    assert(_klass->is_hidden(), \"sanity\");\n-    return (InstanceKlass**)(address(this) + nest_host_offset());\n-  }\n-  InstanceKlass* nest_host() {\n-    return *nest_host_addr();\n-  }\n-  void set_nest_host(InstanceKlass* k) {\n-    *nest_host_addr() = k;\n-    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n-  }\n-\n-  RTLoaderConstraint* loader_constraints() {\n-    assert(_num_loader_constraints > 0, \"sanity\");\n-    return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());\n-  }\n-\n-  RTLoaderConstraint* loader_constraint_at(int i) {\n-    check_loader_constraint_offset(i);\n-    return loader_constraints() + i;\n-  }\n-\n-  void init(DumpTimeSharedClassInfo& info);\n-\n-  bool matches(int clsfile_size, int clsfile_crc32) const {\n-    return crc()->_clsfile_size  == clsfile_size &&\n-           crc()->_clsfile_crc32 == clsfile_crc32;\n-  }\n-\n-  char verifier_constraint_flag(int i) {\n-    check_verifier_constraint_offset(i);\n-    return verifier_constraint_flags()[i];\n-  }\n-\n-private:\n-  \/\/ ArchiveBuilder::make_shallow_copy() has reserved a pointer immediately\n-  \/\/ before archived InstanceKlasses. We can use this slot to do a quick\n-  \/\/ lookup of InstanceKlass* -> RunTimeSharedClassInfo* without\n-  \/\/ building a new hashtable.\n-  \/\/\n-  \/\/  info_pointer_addr(klass) --> 0x0100   RunTimeSharedClassInfo*\n-  \/\/  InstanceKlass* klass     --> 0x0108   <C++ vtbl>\n-  \/\/                               0x0110   fields from Klass ...\n-  static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {\n-    return &((RunTimeSharedClassInfo**)klass)[-1];\n-  }\n-\n-public:\n-  static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {\n-    assert(klass->is_shared(), \"don't call for non-shared class\");\n-    return *info_pointer_addr(klass);\n-  }\n-  static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {\n-    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n-    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n-    *info_pointer_addr(klass) = record;\n-    ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));\n-  }\n-\n-  \/\/ Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS\n-  static inline bool EQUALS(\n-       const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {\n-    return (value->_klass->name() == key);\n-  }\n-};\n-\n-class RunTimeSharedDictionary : public OffsetCompactHashtable<\n-  Symbol*,\n-  const RunTimeSharedClassInfo*,\n-  RunTimeSharedClassInfo::EQUALS> {};\n-#endif \/\/ SHARED_CDS_SHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/sharedClassInfo.hpp","additions":0,"deletions":379,"binary":false,"changes":379,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"cds\/lambdaProxyClassInfo.hpp\"\n@@ -35,1 +34,0 @@\n-#include \"cds\/sharedClassInfo.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,3 @@\n-#include \"cds\/sharedClassInfo.hpp\"\n-#include \"cds\/lambdaProxyClassInfo.hpp\"\n+#include \"cds\/dumpTimeSharedClassInfo.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"cds\/runTimeSharedClassInfo.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}