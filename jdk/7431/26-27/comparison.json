{"files":[{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.IntStream;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-\n-import static java.util.stream.Collectors.toMap;\n-import static org.junit.Assert.assertEquals;\n-\n-\/*\n- * @test\n- * @bug 8210280\n- * @summary White box tests for HashMap internals around table resize\n- *\n- * @run junit\/othervm\/timeout=1000\n- *      --add-opens java.base\/java.lang=ALL-UNNAMED\n- *      --add-opens java.base\/java.util=ALL-UNNAMED\n- *      WhiteBoxHashMapDefaultConstructorCapacityTest\n- *\/\n-@RunWith(Parameterized.class)\n-public class WhiteBoxHashMapDefaultConstructorCapacityTest<T extends Map> {\n-\n-    @Parameterized.Parameters\n-    public static List<Object[]> testFunctionsList() {\n-        return List.of(\n-                new Object[]{WhiteBoxHashMapTestUtil.HASH_MAP_TEST_SUITE},\n-                new Object[]{WhiteBoxHashMapTestUtil.LINKED_HASH_MAP_TEST_SUITE}\n-        );\n-    }\n-\n-    private final WhiteBoxHashMapTestUtil.WhiteBoxHashMapTestSuite<T> whiteBoxHashMapTestSuite;\n-\n-    public WhiteBoxHashMapDefaultConstructorCapacityTest(\n-            WhiteBoxHashMapTestUtil.WhiteBoxHashMapTestSuite<T> whiteBoxHashMapTestSuite\n-    ) {\n-        this.whiteBoxHashMapTestSuite = whiteBoxHashMapTestSuite;\n-    }\n-\n-    @Test\n-    public void capacityTestDefaultConstructor() {\n-        T map = whiteBoxHashMapTestSuite.getCreateNewMap().get();\n-        assertEquals(-1, (int) whiteBoxHashMapTestSuite.getGetArrayLength().apply(map));\n-\n-        map.put(1, 1);\n-        assertEquals(16, (int) whiteBoxHashMapTestSuite.getGetArrayLength().apply(map)); \/\/ default initial capacity\n-\n-        map.putAll(IntStream.range(0, 64).boxed().collect(toMap(i -> i, i -> i)));\n-        assertEquals(128, (int) whiteBoxHashMapTestSuite.getGetArrayLength().apply(map));\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxHashMapDefaultConstructorCapacityTest.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.ThreadLocalRandom;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-\n-import static org.junit.Assert.assertEquals;\n-\n-\/*\n- * @test\n- * @bug 8210280\n- * @summary White box tests for hashMap Initial capacity\n- *\n- * @run junit\/othervm\/timeout=1000\n- *      --add-opens java.base\/java.lang=ALL-UNNAMED\n- *      --add-opens java.base\/java.util=ALL-UNNAMED\n- *      WhiteBoxHashMapInitialCapacityTest\n- *\/\n-@RunWith(Parameterized.class)\n-public class WhiteBoxHashMapInitialCapacityTest<T extends Map> {\n-\n-    @Parameterized.Parameters\n-    public static List<Object[]> testFunctionsList() {\n-        return List.of(\n-                new Object[]{WhiteBoxHashMapTestUtil.HASH_MAP_TEST_SUITE},\n-                new Object[]{WhiteBoxHashMapTestUtil.LINKED_HASH_MAP_TEST_SUITE}\n-        );\n-    }\n-\n-    private final WhiteBoxHashMapTestUtil.WhiteBoxHashMapTestSuite<T> whiteBoxHashMapTestSuite;\n-\n-    public WhiteBoxHashMapInitialCapacityTest(\n-            WhiteBoxHashMapTestUtil.WhiteBoxHashMapTestSuite<T> whiteBoxHashMapTestSuite\n-    ) {\n-        this.whiteBoxHashMapTestSuite = whiteBoxHashMapTestSuite;\n-    }\n-\n-    @Test\n-    public void capacityTestInitialCapacity() {\n-        int initialCapacity = ThreadLocalRandom.current().nextInt(2, 128);\n-        capacityTestInitialCapacitySingleMap(\n-                whiteBoxHashMapTestSuite.getCreateNewMapWithCapacity().apply(initialCapacity),\n-                initialCapacity\n-        );\n-        capacityTestInitialCapacitySingleMap(\n-                whiteBoxHashMapTestSuite.getCreateNewMapWithCapacityAndFactor().apply(initialCapacity, 0.75F),\n-                initialCapacity\n-        );\n-    }\n-\n-    public void capacityTestInitialCapacitySingleMap(\n-            T map,\n-            int initialCapacity\n-    ) {\n-        assertEquals(-1, (int) whiteBoxHashMapTestSuite.getGetArrayLength().apply(map));\n-        map.put(1, 1);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(initialCapacity), (int) whiteBoxHashMapTestSuite.getGetArrayLength().apply(map));\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxHashMapInitialCapacityTest.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-\/*\n- * @test\n- * @bug 8210280\n- * @modules java.base\/java.util:open\n- * @summary White box test for HashMap tableSizeFor function\n- * @run testng WhiteBoxHashMapTableSizeForTest\n- *\/\n-public class WhiteBoxHashMapTableSizeForTest {\n-\n-    @Test\n-    public void testTableSizeFor() {\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(0), 1);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(1), 1);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(2), 2);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(3), 4);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(15), 16);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(16), 16);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(17), 32);\n-        int maxSize = 1 << 30;\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(maxSize - 1), maxSize);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(maxSize), maxSize);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(maxSize + 1), maxSize);\n-        assertEquals(WhiteBoxHashMapTestUtil.tableSizeFor(Integer.MAX_VALUE), maxSize);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxHashMapTableSizeForTest.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.WeakHashMap;\n-import java.util.function.BiFunction;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-\n-public class WhiteBoxHashMapTestUtil {\n-\n-    private static final MethodHandle TABLE_SIZE_FOR;\n-\n-    static {\n-        try {\n-            Class<?> mClass = HashMap.class;\n-            MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(mClass, MethodHandles.lookup());\n-            TABLE_SIZE_FOR = lookup.findStatic(\n-                    mClass, \"tableSizeFor\",\n-                    MethodType.methodType(int.class, int.class));\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"WhiteBoxHashMapTableSizeForTest init failed\", e);\n-        }\n-    }\n-\n-    static int tableSizeFor(int n) {\n-        try {\n-            return (int) TABLE_SIZE_FOR.invoke(n);\n-        } catch (Throwable t) {\n-            throw new AssertionError(t);\n-        }\n-    }\n-\n-    static int getArrayLength(Map<?, ?> map) {\n-        Field field = null;\n-        Class<?> mapClass = map.getClass();\n-        while (!Map.class.equals(mapClass)) {\n-            try {\n-                field = mapClass.getDeclaredField(\"table\");\n-                break;\n-            } catch (NoSuchFieldException ignored) {\n-            }\n-            mapClass = mapClass.getSuperclass();\n-        }\n-        Objects.requireNonNull(field);\n-        field.setAccessible(true);\n-        Object table = null;\n-        try {\n-            table = field.get(map);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(\"cannot get table for map \" + map.getClass().getName(), e);\n-        }\n-        if (table == null) {\n-            return -1;\n-        }\n-        return Array.getLength(table);\n-    }\n-\n-    static class WhiteBoxHashMapTestSuite<T extends Map> {\n-\n-        private final Class<T> mapClass;\n-\n-        private final Function<T, Integer> getArrayLength;\n-\n-        private final Supplier<T> createNewMap;\n-\n-        private final Function<Integer, T> createNewMapWithCapacity;\n-\n-        private final BiFunction<Integer, Float, T> createNewMapWithCapacityAndFactor;\n-\n-        private final Function<Map, T> createNewMapWithMap;\n-\n-        public WhiteBoxHashMapTestSuite(\n-                Class<T> mapClass,\n-                Function<T, Integer> getArrayLength,\n-                Supplier<T> createNewMap,\n-                BiFunction<Integer, Float, T> createNewMapWithCapacityAndFactor,\n-                Function<Integer, T> createNewMapWithCapacity,\n-                Function<Map, T> createNewMapWithMap\n-        ) {\n-            this.mapClass = mapClass;\n-            this.getArrayLength = getArrayLength;\n-            this.createNewMap = createNewMap;\n-            this.createNewMapWithCapacityAndFactor = createNewMapWithCapacityAndFactor;\n-            this.createNewMapWithCapacity = createNewMapWithCapacity;\n-            this.createNewMapWithMap = createNewMapWithMap;\n-        }\n-\n-        public Class<T> getMapClass() {\n-            return mapClass;\n-        }\n-\n-        public Function<T, Integer> getGetArrayLength() {\n-            return getArrayLength;\n-        }\n-\n-        public Supplier<T> getCreateNewMap() {\n-            return createNewMap;\n-        }\n-\n-        public Function<Integer, T> getCreateNewMapWithCapacity() {\n-            return createNewMapWithCapacity;\n-        }\n-\n-        public BiFunction<Integer, Float, T> getCreateNewMapWithCapacityAndFactor() {\n-            return createNewMapWithCapacityAndFactor;\n-        }\n-\n-        public Function<Map, T> getCreateNewMapWithMap() {\n-            return createNewMapWithMap;\n-        }\n-\n-    }\n-\n-    static WhiteBoxHashMapTestSuite<HashMap> HASH_MAP_TEST_SUITE = new WhiteBoxHashMapTestSuite<>(\n-            HashMap.class,\n-            WhiteBoxHashMapTestUtil::getArrayLength,\n-            HashMap::new,\n-            HashMap::new,\n-            HashMap::new,\n-            HashMap::new\n-    );\n-\n-    static WhiteBoxHashMapTestSuite<LinkedHashMap> LINKED_HASH_MAP_TEST_SUITE = new WhiteBoxHashMapTestSuite<>(\n-            LinkedHashMap.class,\n-            WhiteBoxHashMapTestUtil::getArrayLength,\n-            LinkedHashMap::new,\n-            LinkedHashMap::new,\n-            LinkedHashMap::new,\n-            LinkedHashMap::new\n-    );\n-\n-    static WhiteBoxHashMapTestSuite<WeakHashMap> WEAK_HASH_MAP_TEST_SUITE = new WhiteBoxHashMapTestSuite<>(\n-            WeakHashMap.class,\n-            WhiteBoxHashMapTestUtil::getArrayLength,\n-            WeakHashMap::new,\n-            WeakHashMap::new,\n-            WeakHashMap::new,\n-            WeakHashMap::new\n-    );\n-\n-}\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxHashMapTestUtil.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-\n-\/*\n- * @test\n- * @bug 8281631\n- * @summary HashMap copy constructor and putAll can over-allocate table\n- * @author  Xeno Amess\n- *\n- * @run junit\/othervm\/timeout=1000\n- *      --add-opens java.base\/java.lang=ALL-UNNAMED\n- *      --add-opens java.base\/java.util=ALL-UNNAMED\n- *      WhiteBoxHashMapsPutAllOverAllocateTableTest\n- *\/\n-@RunWith(Parameterized.class)\n-public class WhiteBoxHashMapsPutAllOverAllocateTableTest<T extends Map> {\n-\n-    private static final int TEST_SIZE = 128;\n-    private static final Integer[] INTEGER_ARRAY = new Integer[TEST_SIZE];\n-\n-    static {\n-        for (int i = 0; i < TEST_SIZE; ++i) {\n-            INTEGER_ARRAY[i] = i;\n-        }\n-    }\n-\n-    private static <T extends Map> Object[] testCase(\n-            WhiteBoxHashMapTestUtil.WhiteBoxHashMapTestSuite<T> whiteBoxHashMapTestSuite,\n-            int mapSize\n-    ) {\n-        return new Object[]{\n-                whiteBoxHashMapTestSuite,\n-                mapSize\n-        };\n-    }\n-\n-    @Parameterized.Parameters\n-    public static List<Object[]> testFunctionsList() {\n-        List<Object[]> testParameters = new ArrayList<>(TEST_SIZE * 3);\n-        for (int i = 0; i <= TEST_SIZE; ++i) {\n-            testParameters.add(\n-                    testCase(\n-                            WhiteBoxHashMapTestUtil.HASH_MAP_TEST_SUITE,\n-                            i\n-                    )\n-            );\n-            testParameters.add(\n-                    testCase(\n-                            WhiteBoxHashMapTestUtil.LINKED_HASH_MAP_TEST_SUITE,\n-                            i\n-                    )\n-            );\n-            testParameters.add(\n-                    testCase(\n-                            WhiteBoxHashMapTestUtil.WEAK_HASH_MAP_TEST_SUITE,\n-                            i\n-                    )\n-            );\n-        }\n-        return testParameters;\n-    }\n-\n-    private final WhiteBoxHashMapTestUtil.WhiteBoxHashMapTestSuite<T> whiteBoxHashMapTestSuite;\n-\n-    private final int mapSize;\n-\n-    private final String testName;\n-\n-    public WhiteBoxHashMapsPutAllOverAllocateTableTest(\n-            WhiteBoxHashMapTestUtil.WhiteBoxHashMapTestSuite<T> whiteBoxHashMapTestSuite,\n-            int mapSize\n-    ) {\n-        this.whiteBoxHashMapTestSuite = whiteBoxHashMapTestSuite;\n-        this.mapSize = mapSize;\n-        this.testName = this.whiteBoxHashMapTestSuite.getMapClass().getName();\n-    }\n-\n-    public static void fillN(int mapSize, Map<Object, Object> map) {\n-        for (int i = 0; i < mapSize; i++) {\n-            map.put(INTEGER_ARRAY[i], INTEGER_ARRAY[i]);\n-        }\n-    }\n-\n-    @Test\n-    public void test() throws IllegalAccessException {\n-\n-        T a = whiteBoxHashMapTestSuite.getCreateNewMap().get();\n-        fillN(mapSize, a);\n-        int lengthA = whiteBoxHashMapTestSuite.getGetArrayLength().apply(a);\n-        {\n-            T b = whiteBoxHashMapTestSuite.getCreateNewMapWithCapacity().apply(mapSize);\n-            fillN(mapSize, b);\n-            int length = whiteBoxHashMapTestSuite.getGetArrayLength().apply(b);\n-            Assert.assertTrue(\n-                    testName + \" : \" + \"length b larger than length a!\",\n-                    length <= lengthA\n-            );\n-        }\n-\n-        {\n-            T c = whiteBoxHashMapTestSuite.getCreateNewMapWithMap().apply(a);\n-            int length = whiteBoxHashMapTestSuite.getGetArrayLength().apply(c);\n-            Assert.assertTrue(\n-                    testName + \" : \" + \"length c larger than length a!\",\n-                    length <= lengthA\n-            );\n-        }\n-\n-        {\n-            T d = whiteBoxHashMapTestSuite.getCreateNewMap().get();\n-            d.putAll(a);\n-            int length = whiteBoxHashMapTestSuite.getGetArrayLength().apply(d);\n-            Assert.assertTrue(\n-                    testName + \" : \" + \"length d larger than length a!\",\n-                    length <= lengthA\n-            );\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxHashMapsPutAllOverAllocateTableTest.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8210280 8281631\n+ * @modules java.base\/java.util:open\n+ * @summary White box tests for HashMap-related internals around table sizing\n+ * @run testng WhiteBoxResizeTest\n+ *\/\n+public class WhiteBoxResizeTest {\n+    final MethodHandle TABLE_SIZE_FOR;\n+    final VarHandle HM_TABLE;\n+    final VarHandle WHM_TABLE;\n+\n+    public WhiteBoxResizeTest() throws ReflectiveOperationException {\n+        MethodHandles.Lookup hmlookup = MethodHandles.privateLookupIn(HashMap.class, MethodHandles.lookup());\n+        TABLE_SIZE_FOR = hmlookup.findStatic(\n+            HashMap.class, \"tableSizeFor\", MethodType.methodType(int.class, int.class));\n+        HM_TABLE = hmlookup.unreflectVarHandle(HashMap.class.getDeclaredField(\"table\"));\n+\n+        MethodHandles.Lookup whmlookup = MethodHandles.privateLookupIn(WeakHashMap.class, MethodHandles.lookup());\n+        WHM_TABLE = whmlookup.unreflectVarHandle(WeakHashMap.class.getDeclaredField(\"table\"));\n+    }\n+\n+    \/*\n+     * utility methods\n+     *\/\n+\n+    int tableSizeFor(int n) {\n+        try {\n+            return (int) TABLE_SIZE_FOR.invoke(n);\n+        } catch (Throwable t) { throw new AssertionError(t); }\n+    }\n+\n+    Object[] table(Map<?,?> map) {\n+        try {\n+            VarHandle vh = map instanceof WeakHashMap ? WHM_TABLE : HM_TABLE;\n+            return (Object[]) vh.get(map);\n+        } catch (Throwable t) { throw new AssertionError(t); }\n+    }\n+\n+    int capacity(Map<?,?> map) {\n+        return table(map).length;\n+    }\n+\n+    \/\/ creates a map with size mappings\n+    Map<Integer, Integer> makeMap(int size) {\n+        return IntStream.range(0, size)\n+                        .boxed()\n+                        .collect(Collectors.toUnmodifiableMap(i -> i, i -> i));\n+    }\n+\n+    \/\/ creates a \"fake\" map: size() returns the given size, but\n+    \/\/ the entrySet iterator returns only one entry\n+    Map<Integer, Integer> fakeMap(int size) {\n+        return new AbstractMap<>() {\n+            public Set<Map.Entry<Integer,Integer>> entrySet() {\n+                return new AbstractSet<Map.Entry<Integer,Integer>>() {\n+                    public int size() { return size; }\n+                    public Iterator<Map.Entry<Integer,Integer>> iterator() {\n+                        return Set.of(Map.entry(1, 1)).iterator();\n+                    }\n+                };\n+            }\n+        };\n+    }\n+\n+    void putN(Map<Integer, Integer> map, int n) {\n+        for (int i = 0; i < n; i++)\n+            map.put(i, i);\n+    }\n+\n+    \/*\n+     * tests of tableSizeFor\n+     *\/\n+\n+    @DataProvider(name=\"tableSizeFor\")\n+    public Object[][] tableSizeForCases() {\n+        final int MAX = 1 << 30;\n+        return new Object[][] {\n+            \/\/ tableSizeFor(arg), expected\n+            { 0,                   1 },\n+            { 1,                   1 },\n+            { 2,                   2 },\n+            { 3,                   4 },\n+            { 4,                   4 },\n+            { 5,                   8 },\n+            { 15,                 16 },\n+            { 16,                 16 },\n+            { 17,                 32 },\n+            { MAX-1,             MAX },\n+            { MAX,               MAX },\n+            { MAX+1,             MAX },\n+            { Integer.MAX_VALUE, MAX }\n+        };\n+    }\n+\n+    @Test(dataProvider=\"tableSizeFor\")\n+    public void tableSizeFor(int arg, int expected) {\n+        assertEquals(tableSizeFor(arg), expected);\n+    }\n+\n+    \/*\n+     * tests for lazy table allocation\n+     *\/\n+\n+    @DataProvider(name=\"lazy\")\n+    public Object[][] lazyTableAllocationCases() {\n+        return new Object[][] {\n+            { new HashMap<>() },\n+         \/\/ { new WeakHashMap<>() }, \/\/ WHM doesn't allocate lazily\n+            { new LinkedHashMap<>() }\n+        };\n+    }\n+\n+    @Test(dataProvider=\"lazy\")\n+    public void lazyTableAllocation(Map<?,?> map) {\n+        assertNull(table(map));\n+    }\n+\n+    \/*\n+     * tests for default capacity (no-arg constructor)\n+     *\/\n+\n+    @DataProvider(name=\"defaultCapacity\")\n+    public Object[][] defaultCapacityCases() {\n+        return new Supplier<?>[][] {\n+            { () -> new HashMap<>() },\n+            { () -> new LinkedHashMap<>() },\n+            { () -> new WeakHashMap<>() }\n+        };\n+    }\n+\n+    @Test(dataProvider=\"defaultCapacity\")\n+    public void defaultCapacity(Supplier<Map<Integer, Integer>> s) {\n+        var map = s.get();\n+        map.put(0, 0);\n+        assertEquals(capacity(map), 16);\n+    }\n+\n+    \/*\n+     * tests for requested capacity (int and int+float constructors)\n+     *\/\n+\n+    @DataProvider(name=\"requestedCapacity\")\n+    public Iterator<Object[]> requestedCapacityCases() {\n+        var cases = new ArrayList<Object[]>();\n+        for (int i = 2; i < 128; i++) {\n+            int cap = i;\n+            cases.add(new Object[] { \"rhm1\", cap, (Supplier<Map<Integer, Integer>>) () -> new HashMap<>(cap) });\n+            cases.add(new Object[] { \"rhm2\", cap, (Supplier<Map<Integer, Integer>>) () -> new HashMap<>(cap, 0.75f) });\n+            cases.add(new Object[] { \"rlm1\", cap, (Supplier<Map<Integer, Integer>>) () -> new LinkedHashMap<>(cap) });\n+            cases.add(new Object[] { \"rlm2\", cap, (Supplier<Map<Integer, Integer>>) () -> new LinkedHashMap<>(cap, 0.75f) });\n+            cases.add(new Object[] { \"rwm1\", cap, (Supplier<Map<Integer, Integer>>) () -> new WeakHashMap<>(cap) });\n+            cases.add(new Object[] { \"rwm2\", cap, (Supplier<Map<Integer, Integer>>) () -> new WeakHashMap<>(cap, 0.75f) });\n+        }\n+        return cases.iterator();\n+    }\n+\n+    @Test(dataProvider=\"requestedCapacity\")\n+    public void requestedCapacity(String label, int cap, Supplier<Map<Integer, Integer>> s) {\n+        var map = s.get();\n+        map.put(0, 0);\n+        assertEquals(capacity(map), tableSizeFor(cap));\n+    }\n+\n+    \/*\n+     * Tests for capacity after map is populated with a given number N of mappings.\n+     * Maps are populated using a copy constructor on a map with N mappings,\n+     * other constructors followed by N put() calls, and other constructors followed\n+     * by putAll() on a map with N mappings.\n+     *\n+     * String labels encode the test case for ease of diagnosis if one of the test cases fails.\n+     * For example, \"plm2pn\" is \"populated LinkedHashMap, 2-arg constructor, followed by putN\".\n+     *\/\n+\n+    \/\/ helper method for one populated capacity case, to provide target types for lambdas\n+    Object[] pcc(String label,\n+                 int size,\n+                 int expectedCapacity,\n+                 Supplier<Map<Integer,Integer>> supplier,\n+                 Consumer<Map<Integer,Integer>> consumer) {\n+        return new Object[] { label, size, expectedCapacity, supplier, consumer };\n+    }\n+\n+    List<Object[]> genPopulatedCapacityCases(int size, int cap) {\n+        return Arrays.asList(\n+            pcc(\"phmcpy\", size, cap, () -> new HashMap<>(makeMap(size)),       map -> { }),\n+            pcc(\"phm0pn\", size, cap, () -> new HashMap<>(),                    map -> { putN(map, size); }),\n+            pcc(\"phm1pn\", size, cap, () -> new HashMap<>(cap),                 map -> { putN(map, size); }),\n+            pcc(\"phm2pn\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { putN(map, size); }),\n+            pcc(\"phm0pa\", size, cap, () -> new HashMap<>(),                    map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"phm1pa\", size, cap, () -> new HashMap<>(cap),                 map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"phm2pa\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { map.putAll(makeMap(size)); }),\n+\n+            pcc(\"plmcpy\", size, cap, () -> new LinkedHashMap<>(makeMap(size)), map -> { }),\n+            pcc(\"plm0pn\", size, cap, () -> new LinkedHashMap<>(),              map -> { putN(map, size); }),\n+            pcc(\"plm1pn\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { putN(map, size); }),\n+            pcc(\"plm2pn\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { putN(map, size); }),\n+            pcc(\"plm0pa\", size, cap, () -> new LinkedHashMap<>(),              map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"plm1pa\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"plm2pa\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { map.putAll(makeMap(size)); }),\n+\n+            pcc(\"pwmcpy\", size, cap, () -> new WeakHashMap<>(makeMap(size)),   map -> { }),\n+            pcc(\"pwm0pn\", size, cap, () -> new WeakHashMap<>(),                map -> { putN(map, size); }),\n+            pcc(\"pwm1pn\", size, cap, () -> new WeakHashMap<>(cap),             map -> { putN(map, size); }),\n+            pcc(\"pwm2pn\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { putN(map, size); }),\n+            pcc(\"pwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"pwm1pa\", size, cap, () -> new WeakHashMap<>(cap),             map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"pwm2pa\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { map.putAll(makeMap(size)); })\n+        );\n+    }\n+\n+    List<Object[]> genFakePopulatedCapacityCases(int size, int cap) {\n+        return Arrays.asList(\n+            pcc(\"fhmcpy\", size, cap, () -> new HashMap<>(fakeMap(size)),       map -> { }),\n+            pcc(\"fhm0pa\", size, cap, () -> new HashMap<>(),                    map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"fhm1pa\", size, cap, () -> new HashMap<>(cap),                 map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"fhm2pa\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { map.putAll(fakeMap(size)); }),\n+\n+            pcc(\"flmcpy\", size, cap, () -> new LinkedHashMap<>(fakeMap(size)), map -> { }),\n+            pcc(\"flm0pa\", size, cap, () -> new LinkedHashMap<>(),              map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"flm1pa\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"flm2pa\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { map.putAll(fakeMap(size)); }),\n+\n+            pcc(\"fwmcpy\", size, cap, () -> new WeakHashMap<>(fakeMap(size)),   map -> { }),\n+         \/\/ pcc(\"fwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(fakeMap(size)); }), \/\/ see note\n+            pcc(\"fwm1pa\", size, cap, () -> new WeakHashMap<>(cap),             map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"fwm2pa\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { map.putAll(fakeMap(size)); })\n+        );\n+\n+        \/\/ Test case \"fwm0pa\" is commented out because WeakHashMap uses a different allocation\n+        \/\/ policy from the other map implementations: it deliberately under-allocates in this case.\n+    }\n+\n+    @DataProvider(name=\"populatedCapacity\")\n+    public Iterator<Object[]> populatedCapacityCases() {\n+        var cases = new ArrayList<Object[]>();\n+        cases.addAll(genPopulatedCapacityCases(11,  16));\n+        cases.addAll(genPopulatedCapacityCases(12,  16));\n+        cases.addAll(genPopulatedCapacityCases(13,  32));\n+        cases.addAll(genPopulatedCapacityCases(64, 128));\n+\n+        \/\/ numbers in this range are truncated by a float computation with 0.75f\n+        \/\/ but can get an exact result with a double computation with 0.75d\n+        cases.addAll(genFakePopulatedCapacityCases(25165824, 33554432));\n+        cases.addAll(genFakePopulatedCapacityCases(25165825, 67108864));\n+        cases.addAll(genFakePopulatedCapacityCases(25165826, 67108864));\n+\n+        return cases.iterator();\n+    }\n+\n+    @Test(dataProvider=\"populatedCapacity\")\n+    public void populatedCapacity(String label, \/\/ unused, included for diagnostics\n+                                  int size,     \/\/ unused, included for diagnostics\n+                                  int expectedCapacity,\n+                                  Supplier<Map<Integer,Integer>> s,\n+                                  Consumer<Map<Integer,Integer>> c) {\n+        var map = s.get();\n+        c.accept(map);\n+        assertEquals(capacity(map), expectedCapacity);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"}]}