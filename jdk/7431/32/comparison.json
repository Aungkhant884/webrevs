{"files":[{"patch":"@@ -498,3 +498,3 @@\n-                float ft = ((float)s \/ loadFactor) + 1.0F;\n-                int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n-                         (int)ft : MAXIMUM_CAPACITY);\n+                double dt = Math.ceil(s \/ (double)loadFactor);\n+                int t = ((dt < (double)MAXIMUM_CAPACITY) ?\n+                         (int)dt : MAXIMUM_CAPACITY);\n@@ -1530,2 +1530,2 @@\n-            float fc = (float)mappings \/ lf + 1.0f;\n-            int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?\n+            double dc = Math.ceil(mappings \/ (double)lf);\n+            int cap = ((dc < DEFAULT_INITIAL_CAPACITY) ?\n@@ -1533,1 +1533,1 @@\n-                       (fc >= MAXIMUM_CAPACITY) ?\n+                       (dc >= MAXIMUM_CAPACITY) ?\n@@ -1535,1 +1535,1 @@\n-                       tableSizeFor((int)fc));\n+                       tableSizeFor((int)dc));\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -216,3 +216,1 @@\n-        int capacity = 1;\n-        while (capacity < initialCapacity)\n-            capacity <<= 1;\n+        int capacity = HashMap.tableSizeFor(initialCapacity);\n@@ -254,1 +252,1 @@\n-        this(Math.max((int) ((float)m.size() \/ DEFAULT_LOAD_FACTOR + 1.0F),\n+        this(Math.max((int) Math.ceil(m.size() \/ (double)DEFAULT_LOAD_FACTOR),\n@@ -471,1 +469,1 @@\n-        if (++size >= threshold)\n+        if (++size > threshold)\n@@ -560,1 +558,1 @@\n-            int targetCapacity = (int)(numKeysToBeAdded \/ loadFactor + 1);\n+            int targetCapacity = (int)Math.ceil(numKeysToBeAdded \/ (double)loadFactor);\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -545,0 +545,1 @@\n+java\/lang\/Enum\/ConstantDirectoryOptimalCapacity.java            8282120 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +25,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -30,0 +32,4 @@\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -31,0 +37,1 @@\n+import java.util.Iterator;\n@@ -34,1 +41,3 @@\n-import java.util.concurrent.ThreadLocalRandom;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+import java.util.function.Consumer;\n@@ -36,1 +45,0 @@\n-import java.util.stream.IntStream;\n@@ -38,1 +46,0 @@\n-import static java.util.stream.Collectors.toMap;\n@@ -44,1 +51,1 @@\n- * @bug 8210280\n+ * @bug 8210280 8281631\n@@ -46,1 +53,1 @@\n- * @summary White box tests for HashMap internals around table resize\n+ * @summary White box tests for HashMap-related internals around table sizing\n@@ -48,1 +55,0 @@\n- * @key randomness\n@@ -51,1 +57,6 @@\n-    final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+    private static void putMap(Map<String, String> map, int i) {\n+        String String = Integer.toString(i);\n+        map.put(String, String);\n+    }\n+\n@@ -53,2 +64,2 @@\n-    final VarHandle THRESHOLD;\n-    final VarHandle TABLE;\n+    final VarHandle HM_TABLE;\n+    final VarHandle WHM_TABLE;\n@@ -57,9 +68,7 @@\n-        Class<?> mClass = HashMap.class;\n-        String nodeClassName = mClass.getName() + \"$Node\";\n-        Class<?> nodeArrayClass = Class.forName(\"[L\" + nodeClassName + \";\");\n-        MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(mClass, MethodHandles.lookup());\n-        TABLE = lookup.findVarHandle(mClass, \"table\", nodeArrayClass);\n-        this.TABLE_SIZE_FOR = lookup.findStatic(\n-                mClass, \"tableSizeFor\",\n-                MethodType.methodType(int.class, int.class));\n-        this.THRESHOLD = lookup.findVarHandle(mClass, \"threshold\", int.class);\n+        MethodHandles.Lookup hmlookup = MethodHandles.privateLookupIn(HashMap.class, MethodHandles.lookup());\n+        TABLE_SIZE_FOR = hmlookup.findStatic(\n+                HashMap.class, \"tableSizeFor\", MethodType.methodType(int.class, int.class));\n+        HM_TABLE = hmlookup.unreflectVarHandle(HashMap.class.getDeclaredField(\"table\"));\n+\n+        MethodHandles.Lookup whmlookup = MethodHandles.privateLookupIn(WeakHashMap.class, MethodHandles.lookup());\n+        WHM_TABLE = whmlookup.unreflectVarHandle(WeakHashMap.class.getDeclaredField(\"table\"));\n@@ -68,0 +77,4 @@\n+    \/*\n+     * utility methods\n+     *\/\n+\n@@ -71,1 +84,3 @@\n-        } catch (Throwable t) { throw new AssertionError(t); }\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n@@ -74,1 +89,1 @@\n-    Object[] table(HashMap map) {\n+    Object[] table(Map<?, ?> map) {\n@@ -76,2 +91,5 @@\n-            return (Object[]) TABLE.get(map);\n-        } catch (Throwable t) { throw new AssertionError(t); }\n+            VarHandle vh = map instanceof WeakHashMap ? WHM_TABLE : HM_TABLE;\n+            return (Object[]) vh.get(map);\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n@@ -80,1 +98,1 @@\n-    int capacity(HashMap map) {\n+    int capacity(Map<?, ?> map) {\n@@ -84,14 +102,7 @@\n-    @Test\n-    public void testTableSizeFor() {\n-        assertEquals(tableSizeFor(0), 1);\n-        assertEquals(tableSizeFor(1), 1);\n-        assertEquals(tableSizeFor(2), 2);\n-        assertEquals(tableSizeFor(3), 4);\n-        assertEquals(tableSizeFor(15), 16);\n-        assertEquals(tableSizeFor(16), 16);\n-        assertEquals(tableSizeFor(17), 32);\n-        int maxSize = 1 << 30;\n-        assertEquals(tableSizeFor(maxSize - 1), maxSize);\n-        assertEquals(tableSizeFor(maxSize), maxSize);\n-        assertEquals(tableSizeFor(maxSize + 1), maxSize);\n-        assertEquals(tableSizeFor(Integer.MAX_VALUE), maxSize);\n+    \/\/ creates a map with size mappings\n+    Map<String, String> makeMap(int size) {\n+        Map<String, String> map = new HashMap<>();\n+        for (int i = 0; i < size; ++i) {\n+            putMap(map, i);\n+        }\n+        return map;\n@@ -100,4 +111,16 @@\n-    @Test\n-    public void capacityTestDefaultConstructor() {\n-        capacityTestDefaultConstructor(new HashMap<>());\n-        capacityTestDefaultConstructor(new LinkedHashMap<>());\n+    \/\/ creates a \"fake\" map: size() returns the given size, but\n+    \/\/ the entrySet iterator returns only one entry\n+    Map<String, String> fakeMap(int size) {\n+        return new AbstractMap<>() {\n+            public Set<Map.Entry<String, String>> entrySet() {\n+                return new AbstractSet<Map.Entry<String, String>>() {\n+                    public int size() {\n+                        return size;\n+                    }\n+\n+                    public Iterator<Map.Entry<String, String>> iterator() {\n+                        return Set.of(Map.entry(\"1\", \"1\")).iterator();\n+                    }\n+                };\n+            }\n+        };\n@@ -106,1 +129,169 @@\n-    void capacityTestDefaultConstructor(HashMap<Integer, Integer> map) {\n+    void putN(Map<String, String> map, int n) {\n+        for (int i = 0; i < n; i++) {\n+            putMap(map, i);\n+        }\n+    }\n+\n+    \/*\n+     * tests of tableSizeFor\n+     *\/\n+\n+    @DataProvider(name = \"tableSizeFor\")\n+    public Object[][] tableSizeForCases() {\n+        final int MAX = 1 << 30;\n+        return new Object[][]{\n+                \/\/ tableSizeFor(arg), expected\n+                {1, 1},\n+                {2, 2},\n+                {3, 4},\n+                {4, 4},\n+                {5, 8},\n+                {6, 8},\n+                {7, 8},\n+                {8, 8},\n+                {9, 16},\n+                {10, 16},\n+                {11, 16},\n+                {12, 16},\n+                {13, 16},\n+                {14, 16},\n+                {15, 16},\n+                {16, 16},\n+                {17, 32},\n+                {18, 32},\n+                {19, 32},\n+                {20, 32},\n+                {21, 32},\n+                {22, 32},\n+                {23, 32},\n+                {24, 32},\n+                {25, 32},\n+                {26, 32},\n+                {27, 32},\n+                {28, 32},\n+                {29, 32},\n+                {30, 32},\n+                {31, 32},\n+                {32, 32},\n+                {33, 64},\n+                {34, 64},\n+                {35, 64},\n+                {36, 64},\n+                {37, 64},\n+                {38, 64},\n+                {39, 64},\n+                {40, 64},\n+                {41, 64},\n+                {42, 64},\n+                {43, 64},\n+                {44, 64},\n+                {45, 64},\n+                {46, 64},\n+                {47, 64},\n+                {48, 64},\n+                {49, 64},\n+                {50, 64},\n+                {51, 64},\n+                {52, 64},\n+                {53, 64},\n+                {54, 64},\n+                {55, 64},\n+                {56, 64},\n+                {57, 64},\n+                {58, 64},\n+                {59, 64},\n+                {60, 64},\n+                {61, 64},\n+                {62, 64},\n+                {63, 64},\n+                {64, 64},\n+                {65, 128},\n+                {66, 128},\n+                {67, 128},\n+                {68, 128},\n+                {69, 128},\n+                {70, 128},\n+                {71, 128},\n+                {72, 128},\n+                {73, 128},\n+                {74, 128},\n+                {75, 128},\n+                {76, 128},\n+                {77, 128},\n+                {78, 128},\n+                {79, 128},\n+                {80, 128},\n+                {81, 128},\n+                {82, 128},\n+                {83, 128},\n+                {84, 128},\n+                {85, 128},\n+                {86, 128},\n+                {87, 128},\n+                {88, 128},\n+                {89, 128},\n+                {90, 128},\n+                {91, 128},\n+                {92, 128},\n+                {93, 128},\n+                {94, 128},\n+                {95, 128},\n+                {96, 128},\n+                {97, 128},\n+                {98, 128},\n+                {99, 128},\n+                {100, 128},\n+                {101, 128},\n+                {102, 128},\n+                {103, 128},\n+                {104, 128},\n+                {105, 128},\n+                {106, 128},\n+                {107, 128},\n+                {108, 128},\n+                {109, 128},\n+                {110, 128},\n+                {111, 128},\n+                {112, 128},\n+                {113, 128},\n+                {114, 128},\n+                {115, 128},\n+                {116, 128},\n+                {117, 128},\n+                {118, 128},\n+                {119, 128},\n+                {120, 128},\n+                {121, 128},\n+                {122, 128},\n+                {123, 128},\n+                {124, 128},\n+                {125, 128},\n+                {126, 128},\n+                {127, 128},\n+                {MAX - 1, MAX},\n+                {MAX, MAX},\n+                {MAX + 1, MAX},\n+                {Integer.MAX_VALUE, MAX}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"tableSizeFor\")\n+    public void tableSizeFor(int arg, int expected) {\n+        assertEquals(tableSizeFor(arg), expected);\n+    }\n+\n+    \/*\n+     * tests for lazy table allocation\n+     *\/\n+\n+    @DataProvider(name = \"lazy\")\n+    public Object[][] lazyTableAllocationCases() {\n+        return new Object[][]{\n+                {new HashMap<>()},\n+                \/\/ { new WeakHashMap<>() }, \/\/ WHM doesn't allocate lazily\n+                {new LinkedHashMap<>()}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lazy\")\n+    public void lazyTableAllocation(Map<?, ?> map) {\n@@ -108,0 +299,1 @@\n+    }\n@@ -109,2 +301,3 @@\n-        map.put(1, 1);\n-        assertEquals(capacity(map), 16); \/\/ default initial capacity\n+    \/*\n+     * tests for default capacity (no-arg constructor)\n+     *\/\n@@ -112,2 +305,7 @@\n-        map.putAll(IntStream.range(0, 64).boxed().collect(toMap(i -> i, i -> i)));\n-        assertEquals(capacity(map), 128);\n+    @DataProvider(name = \"defaultCapacity\")\n+    public Object[][] defaultCapacityCases() {\n+        return new Supplier<?>[][]{\n+                {() -> new HashMap<>()},\n+                {() -> new LinkedHashMap<>()},\n+                {() -> new WeakHashMap<>()}\n+        };\n@@ -116,8 +314,6 @@\n-    @Test\n-    public void capacityTestInitialCapacity() {\n-        int initialCapacity = rnd.nextInt(2, 128);\n-        List<Supplier<HashMap<Integer, Integer>>> suppliers = List.of(\n-            () -> new HashMap<>(initialCapacity),\n-            () -> new HashMap<>(initialCapacity, 0.75f),\n-            () -> new LinkedHashMap<>(initialCapacity),\n-            () -> new LinkedHashMap<>(initialCapacity, 0.75f));\n+    @Test(dataProvider = \"defaultCapacity\")\n+    public void defaultCapacity(Supplier<Map<String, String>> s) {\n+        Map<String, String> map = s.get();\n+        putMap(map, 0);\n+        assertEquals(capacity(map), 16);\n+    }\n@@ -125,3 +321,3 @@\n-        for (Supplier<HashMap<Integer, Integer>> supplier : suppliers) {\n-            HashMap<Integer, Integer> map = supplier.get();\n-            assertNull(table(map));\n+    \/*\n+     * tests for requested capacity (int and int+float constructors)\n+     *\/\n@@ -129,2 +325,11 @@\n-            map.put(1, 1);\n-            assertEquals(capacity(map), tableSizeFor(initialCapacity));\n+    @DataProvider(name = \"requestedCapacity\")\n+    public Iterator<Object[]> requestedCapacityCases() {\n+        ArrayList<Object[]> cases = new ArrayList<>();\n+        for (int i = 2; i < 128; i++) {\n+            int cap = i;\n+            cases.add(new Object[]{\"rhm1\", cap, (Supplier<Map<String, String>>) () -> new HashMap<>(cap)});\n+            cases.add(new Object[]{\"rhm2\", cap, (Supplier<Map<String, String>>) () -> new HashMap<>(cap, 0.75f)});\n+            cases.add(new Object[]{\"rlm1\", cap, (Supplier<Map<String, String>>) () -> new LinkedHashMap<>(cap)});\n+            cases.add(new Object[]{\"rlm2\", cap, (Supplier<Map<String, String>>) () -> new LinkedHashMap<>(cap, 0.75f)});\n+            cases.add(new Object[]{\"rwm1\", cap, (Supplier<Map<String, String>>) () -> new WeakHashMap<>(cap)});\n+            cases.add(new Object[]{\"rwm2\", cap, (Supplier<Map<String, String>>) () -> new WeakHashMap<>(cap, 0.75f)});\n@@ -132,0 +337,271 @@\n+        return cases.iterator();\n+    }\n+\n+    @Test(dataProvider = \"requestedCapacity\")\n+    public void requestedCapacity(String label, int cap, Supplier<Map<String, String>> s) {\n+        Map<String, String> map = s.get();\n+        putMap(map, 0);\n+        assertEquals(capacity(map), tableSizeFor(cap));\n+    }\n+\n+    \/*\n+     * Tests for capacity after map is populated with a given number N of mappings.\n+     * Maps are populated using a copy constructor on a map with N mappings,\n+     * other constructors followed by N put() calls, and other constructors followed\n+     * by putAll() on a map with N mappings.\n+     *\n+     * String labels encode the test case for ease of diagnosis if one of the test cases fails.\n+     * For example, \"plm2pn\" is \"populated LinkedHashMap, 2-arg constructor, followed by putN\".\n+     *\/\n+\n+    \/\/ helper method for one populated capacity case, to provide target types for lambdas\n+    Object[] pcc(String label,\n+                 int size,\n+                 int expectedCapacity,\n+                 Supplier<Map<String, String>> supplier,\n+                 Consumer<Map<String, String>> consumer) {\n+        return new Object[]{label, size, expectedCapacity, supplier, consumer};\n+    }\n+\n+    List<Object[]> genPopulatedCapacityCases(int size, int cap) {\n+        return Arrays.asList(\n+                pcc(\"phmcpy\", size, cap, () -> new HashMap<>(makeMap(size)), map -> {\n+                }),\n+                pcc(\"phm0pn\", size, cap, () -> new HashMap<>(), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"phm1pn\", size, cap, () -> new HashMap<>(cap), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"phm2pn\", size, cap, () -> new HashMap<>(cap, 0.75f), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"phm0pa\", size, cap, () -> new HashMap<>(), map -> {\n+                    map.putAll(makeMap(size));\n+                }),\n+                pcc(\"phm1pa\", size, cap, () -> new HashMap<>(cap), map -> {\n+                    map.putAll(makeMap(size));\n+                }),\n+                pcc(\"phm2pa\", size, cap, () -> new HashMap<>(cap, 0.75f), map -> {\n+                    map.putAll(makeMap(size));\n+                }),\n+\n+                pcc(\"plmcpy\", size, cap, () -> new LinkedHashMap<>(makeMap(size)), map -> {\n+                }),\n+                pcc(\"plm0pn\", size, cap, () -> new LinkedHashMap<>(), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"plm1pn\", size, cap, () -> new LinkedHashMap<>(cap), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"plm2pn\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"plm0pa\", size, cap, () -> new LinkedHashMap<>(), map -> {\n+                    map.putAll(makeMap(size));\n+                }),\n+                pcc(\"plm1pa\", size, cap, () -> new LinkedHashMap<>(cap), map -> {\n+                    map.putAll(makeMap(size));\n+                }),\n+                pcc(\"plm2pa\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f), map -> {\n+                    map.putAll(makeMap(size));\n+                }),\n+\n+                pcc(\"pwmcpy\", size, cap, () -> new WeakHashMap<>(makeMap(size)), map -> {\n+                }),\n+                pcc(\"pwm0pn\", size, cap, () -> new WeakHashMap<>(), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"pwm1pn\", size, cap, () -> new WeakHashMap<>(cap), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"pwm2pn\", size, cap, () -> new WeakHashMap<>(cap, 0.75f), map -> {\n+                    putN(map, size);\n+                }),\n+                pcc(\"pwm0pa\", size, cap, () -> new WeakHashMap<>(), map -> {\n+                    map.putAll(makeMap(size));\n+                }),\n+                pcc(\"pwm1pa\", size, cap, () -> new WeakHashMap<>(cap), map -> {\n+                    map.putAll(makeMap(size));\n+                }),\n+                pcc(\"pwm2pa\", size, cap, () -> new WeakHashMap<>(cap, 0.75f), map -> {\n+                    map.putAll(makeMap(size));\n+                })\n+        );\n+    }\n+\n+    List<Object[]> genFakePopulatedCapacityCases(int size, int cap) {\n+        return Arrays.asList(\n+                pcc(\"fhmcpy\", size, cap, () -> new HashMap<>(fakeMap(size)), map -> {\n+                }),\n+                pcc(\"fhm0pa\", size, cap, () -> new HashMap<>(), map -> {\n+                    map.putAll(fakeMap(size));\n+                }),\n+                pcc(\"fhm1pa\", size, cap, () -> new HashMap<>(cap), map -> {\n+                    map.putAll(fakeMap(size));\n+                }),\n+                pcc(\"fhm2pa\", size, cap, () -> new HashMap<>(cap, 0.75f), map -> {\n+                    map.putAll(fakeMap(size));\n+                }),\n+\n+                pcc(\"flmcpy\", size, cap, () -> new LinkedHashMap<>(fakeMap(size)), map -> {\n+                }),\n+                pcc(\"flm0pa\", size, cap, () -> new LinkedHashMap<>(), map -> {\n+                    map.putAll(fakeMap(size));\n+                }),\n+                pcc(\"flm1pa\", size, cap, () -> new LinkedHashMap<>(cap), map -> {\n+                    map.putAll(fakeMap(size));\n+                }),\n+                pcc(\"flm2pa\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f), map -> {\n+                    map.putAll(fakeMap(size));\n+                }),\n+\n+                pcc(\"fwmcpy\", size, cap, () -> new WeakHashMap<>(fakeMap(size)), map -> {\n+                }),\n+                \/\/ pcc(\"fwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(fakeMap(size)); }), \/\/ see note\n+                pcc(\"fwm1pa\", size, cap, () -> new WeakHashMap<>(cap), map -> {\n+                    map.putAll(fakeMap(size));\n+                }),\n+                pcc(\"fwm2pa\", size, cap, () -> new WeakHashMap<>(cap, 0.75f), map -> {\n+                    map.putAll(fakeMap(size));\n+                })\n+        );\n+\n+        \/\/ Test case \"fwm0pa\" is commented out because WeakHashMap uses a different allocation\n+        \/\/ policy from the other map implementations: it deliberately under-allocates in this case.\n+    }\n+\n+    @DataProvider(name = \"populatedCapacity\")\n+    public Iterator<Object[]> populatedCapacityCases() {\n+        ArrayList<Object[]> cases = new ArrayList<>();\n+        cases.addAll(genPopulatedCapacityCases(16, 32));\n+        cases.addAll(genPopulatedCapacityCases(17, 32));\n+        cases.addAll(genPopulatedCapacityCases(18, 32));\n+        cases.addAll(genPopulatedCapacityCases(19, 32));\n+        cases.addAll(genPopulatedCapacityCases(20, 32));\n+        cases.addAll(genPopulatedCapacityCases(21, 32));\n+        cases.addAll(genPopulatedCapacityCases(22, 32));\n+        cases.addAll(genPopulatedCapacityCases(23, 32));\n+        cases.addAll(genPopulatedCapacityCases(24, 32));\n+        cases.addAll(genPopulatedCapacityCases(25, 64));\n+        cases.addAll(genPopulatedCapacityCases(26, 64));\n+        cases.addAll(genPopulatedCapacityCases(27, 64));\n+        cases.addAll(genPopulatedCapacityCases(28, 64));\n+        cases.addAll(genPopulatedCapacityCases(29, 64));\n+        cases.addAll(genPopulatedCapacityCases(30, 64));\n+        cases.addAll(genPopulatedCapacityCases(31, 64));\n+        cases.addAll(genPopulatedCapacityCases(32, 64));\n+        cases.addAll(genPopulatedCapacityCases(33, 64));\n+        cases.addAll(genPopulatedCapacityCases(34, 64));\n+        cases.addAll(genPopulatedCapacityCases(35, 64));\n+        cases.addAll(genPopulatedCapacityCases(36, 64));\n+        cases.addAll(genPopulatedCapacityCases(37, 64));\n+        cases.addAll(genPopulatedCapacityCases(38, 64));\n+        cases.addAll(genPopulatedCapacityCases(39, 64));\n+        cases.addAll(genPopulatedCapacityCases(40, 64));\n+        cases.addAll(genPopulatedCapacityCases(41, 64));\n+        cases.addAll(genPopulatedCapacityCases(42, 64));\n+        cases.addAll(genPopulatedCapacityCases(43, 64));\n+        cases.addAll(genPopulatedCapacityCases(44, 64));\n+        cases.addAll(genPopulatedCapacityCases(45, 64));\n+        cases.addAll(genPopulatedCapacityCases(46, 64));\n+        cases.addAll(genPopulatedCapacityCases(47, 64));\n+        cases.addAll(genPopulatedCapacityCases(48, 64));\n+        cases.addAll(genPopulatedCapacityCases(49, 128));\n+        cases.addAll(genPopulatedCapacityCases(50, 128));\n+        cases.addAll(genPopulatedCapacityCases(51, 128));\n+        cases.addAll(genPopulatedCapacityCases(52, 128));\n+        cases.addAll(genPopulatedCapacityCases(53, 128));\n+        cases.addAll(genPopulatedCapacityCases(54, 128));\n+        cases.addAll(genPopulatedCapacityCases(55, 128));\n+        cases.addAll(genPopulatedCapacityCases(56, 128));\n+        cases.addAll(genPopulatedCapacityCases(57, 128));\n+        cases.addAll(genPopulatedCapacityCases(58, 128));\n+        cases.addAll(genPopulatedCapacityCases(59, 128));\n+        cases.addAll(genPopulatedCapacityCases(60, 128));\n+        cases.addAll(genPopulatedCapacityCases(61, 128));\n+        cases.addAll(genPopulatedCapacityCases(62, 128));\n+        cases.addAll(genPopulatedCapacityCases(63, 128));\n+        cases.addAll(genPopulatedCapacityCases(64, 128));\n+        cases.addAll(genPopulatedCapacityCases(65, 128));\n+        cases.addAll(genPopulatedCapacityCases(66, 128));\n+        cases.addAll(genPopulatedCapacityCases(67, 128));\n+        cases.addAll(genPopulatedCapacityCases(68, 128));\n+        cases.addAll(genPopulatedCapacityCases(69, 128));\n+        cases.addAll(genPopulatedCapacityCases(70, 128));\n+        cases.addAll(genPopulatedCapacityCases(71, 128));\n+        cases.addAll(genPopulatedCapacityCases(72, 128));\n+        cases.addAll(genPopulatedCapacityCases(73, 128));\n+        cases.addAll(genPopulatedCapacityCases(74, 128));\n+        cases.addAll(genPopulatedCapacityCases(75, 128));\n+        cases.addAll(genPopulatedCapacityCases(76, 128));\n+        cases.addAll(genPopulatedCapacityCases(77, 128));\n+        cases.addAll(genPopulatedCapacityCases(78, 128));\n+        cases.addAll(genPopulatedCapacityCases(79, 128));\n+        cases.addAll(genPopulatedCapacityCases(80, 128));\n+        cases.addAll(genPopulatedCapacityCases(81, 128));\n+        cases.addAll(genPopulatedCapacityCases(82, 128));\n+        cases.addAll(genPopulatedCapacityCases(83, 128));\n+        cases.addAll(genPopulatedCapacityCases(84, 128));\n+        cases.addAll(genPopulatedCapacityCases(85, 128));\n+        cases.addAll(genPopulatedCapacityCases(86, 128));\n+        cases.addAll(genPopulatedCapacityCases(87, 128));\n+        cases.addAll(genPopulatedCapacityCases(88, 128));\n+        cases.addAll(genPopulatedCapacityCases(89, 128));\n+        cases.addAll(genPopulatedCapacityCases(90, 128));\n+        cases.addAll(genPopulatedCapacityCases(91, 128));\n+        cases.addAll(genPopulatedCapacityCases(92, 128));\n+        cases.addAll(genPopulatedCapacityCases(93, 128));\n+        cases.addAll(genPopulatedCapacityCases(94, 128));\n+        cases.addAll(genPopulatedCapacityCases(95, 128));\n+        cases.addAll(genPopulatedCapacityCases(96, 128));\n+        cases.addAll(genPopulatedCapacityCases(97, 256));\n+        cases.addAll(genPopulatedCapacityCases(98, 256));\n+        cases.addAll(genPopulatedCapacityCases(99, 256));\n+        cases.addAll(genPopulatedCapacityCases(100, 256));\n+        cases.addAll(genPopulatedCapacityCases(101, 256));\n+        cases.addAll(genPopulatedCapacityCases(102, 256));\n+        cases.addAll(genPopulatedCapacityCases(103, 256));\n+        cases.addAll(genPopulatedCapacityCases(104, 256));\n+        cases.addAll(genPopulatedCapacityCases(105, 256));\n+        cases.addAll(genPopulatedCapacityCases(106, 256));\n+        cases.addAll(genPopulatedCapacityCases(107, 256));\n+        cases.addAll(genPopulatedCapacityCases(108, 256));\n+        cases.addAll(genPopulatedCapacityCases(109, 256));\n+        cases.addAll(genPopulatedCapacityCases(110, 256));\n+        cases.addAll(genPopulatedCapacityCases(111, 256));\n+        cases.addAll(genPopulatedCapacityCases(112, 256));\n+        cases.addAll(genPopulatedCapacityCases(113, 256));\n+        cases.addAll(genPopulatedCapacityCases(114, 256));\n+        cases.addAll(genPopulatedCapacityCases(115, 256));\n+        cases.addAll(genPopulatedCapacityCases(116, 256));\n+        cases.addAll(genPopulatedCapacityCases(117, 256));\n+        cases.addAll(genPopulatedCapacityCases(118, 256));\n+        cases.addAll(genPopulatedCapacityCases(119, 256));\n+        cases.addAll(genPopulatedCapacityCases(120, 256));\n+        cases.addAll(genPopulatedCapacityCases(121, 256));\n+        cases.addAll(genPopulatedCapacityCases(122, 256));\n+        cases.addAll(genPopulatedCapacityCases(123, 256));\n+        cases.addAll(genPopulatedCapacityCases(124, 256));\n+        cases.addAll(genPopulatedCapacityCases(125, 256));\n+        cases.addAll(genPopulatedCapacityCases(126, 256));\n+        cases.addAll(genPopulatedCapacityCases(127, 256));\n+\n+        \/\/ numbers in this range are truncated by a float computation with 0.75f\n+        \/\/ but can get an exact result with a double computation with 0.75d\n+        cases.addAll(genFakePopulatedCapacityCases(25165824, 33554432));\n+        cases.addAll(genFakePopulatedCapacityCases(25165825, 67108864));\n+        cases.addAll(genFakePopulatedCapacityCases(25165826, 67108864));\n+\n+        return cases.iterator();\n+    }\n+\n+    @Test(dataProvider = \"populatedCapacity\")\n+    public void populatedCapacity(String label, \/\/ unused, included for diagnostics\n+                                  int size,     \/\/ unused, included for diagnostics\n+                                  int expectedCapacity,\n+                                  Supplier<Map<String, String>> s,\n+                                  Consumer<Map<String, String>> c) {\n+        Map<String, String> map = s.get();\n+        c.accept(map);\n+        assertEquals(capacity(map), expectedCapacity);\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":535,"deletions":59,"binary":false,"changes":594,"status":"modified"}]}