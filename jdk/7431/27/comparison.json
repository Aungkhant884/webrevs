{"files":[{"patch":"@@ -498,3 +498,3 @@\n-                float ft = ((float)s \/ loadFactor) + 1.0F;\n-                int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n-                         (int)ft : MAXIMUM_CAPACITY);\n+                double dt = Math.ceil(s \/ (double)loadFactor);\n+                int t = ((dt < (double)MAXIMUM_CAPACITY) ?\n+                         (int)dt : MAXIMUM_CAPACITY);\n@@ -1530,2 +1530,2 @@\n-            float fc = (float)mappings \/ lf + 1.0f;\n-            int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?\n+            double dc = Math.ceil(mappings \/ (double)lf);\n+            int cap = ((dc < DEFAULT_INITIAL_CAPACITY) ?\n@@ -1533,1 +1533,1 @@\n-                       (fc >= MAXIMUM_CAPACITY) ?\n+                       (dc >= MAXIMUM_CAPACITY) ?\n@@ -1535,1 +1535,1 @@\n-                       tableSizeFor((int)fc));\n+                       tableSizeFor((int)dc));\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -216,3 +216,1 @@\n-        int capacity = 1;\n-        while (capacity < initialCapacity)\n-            capacity <<= 1;\n+        int capacity = HashMap.tableSizeFor(initialCapacity);\n@@ -254,1 +252,1 @@\n-        this(Math.max((int) ((float)m.size() \/ DEFAULT_LOAD_FACTOR + 1.0F),\n+        this(Math.max((int) Math.ceil(m.size() \/ (double)DEFAULT_LOAD_FACTOR),\n@@ -471,1 +469,1 @@\n-        if (++size >= threshold)\n+        if (++size > threshold)\n@@ -560,1 +558,1 @@\n-            int targetCapacity = (int)(numKeysToBeAdded \/ loadFactor + 1);\n+            int targetCapacity = (int)Math.ceil(numKeysToBeAdded \/ (double)loadFactor);\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -545,0 +545,1 @@\n+java\/lang\/Enum\/ConstantDirectoryOptimalCapacity.java            8282120 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +25,0 @@\n-import org.testng.annotations.Test;\n-\n@@ -30,0 +29,4 @@\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -31,0 +34,1 @@\n+import java.util.Iterator;\n@@ -34,1 +38,3 @@\n-import java.util.concurrent.ThreadLocalRandom;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+import java.util.function.Consumer;\n@@ -36,0 +42,1 @@\n+import java.util.stream.Collectors;\n@@ -38,1 +45,3 @@\n-import static java.util.stream.Collectors.toMap;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n@@ -44,1 +53,1 @@\n- * @bug 8210280\n+ * @bug 8210280 8281631\n@@ -46,1 +55,1 @@\n- * @summary White box tests for HashMap internals around table resize\n+ * @summary White box tests for HashMap-related internals around table sizing\n@@ -48,1 +57,0 @@\n- * @key randomness\n@@ -51,1 +59,0 @@\n-    final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n@@ -53,2 +60,2 @@\n-    final VarHandle THRESHOLD;\n-    final VarHandle TABLE;\n+    final VarHandle HM_TABLE;\n+    final VarHandle WHM_TABLE;\n@@ -57,9 +64,7 @@\n-        Class<?> mClass = HashMap.class;\n-        String nodeClassName = mClass.getName() + \"$Node\";\n-        Class<?> nodeArrayClass = Class.forName(\"[L\" + nodeClassName + \";\");\n-        MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(mClass, MethodHandles.lookup());\n-        TABLE = lookup.findVarHandle(mClass, \"table\", nodeArrayClass);\n-        this.TABLE_SIZE_FOR = lookup.findStatic(\n-                mClass, \"tableSizeFor\",\n-                MethodType.methodType(int.class, int.class));\n-        this.THRESHOLD = lookup.findVarHandle(mClass, \"threshold\", int.class);\n+        MethodHandles.Lookup hmlookup = MethodHandles.privateLookupIn(HashMap.class, MethodHandles.lookup());\n+        TABLE_SIZE_FOR = hmlookup.findStatic(\n+            HashMap.class, \"tableSizeFor\", MethodType.methodType(int.class, int.class));\n+        HM_TABLE = hmlookup.unreflectVarHandle(HashMap.class.getDeclaredField(\"table\"));\n+\n+        MethodHandles.Lookup whmlookup = MethodHandles.privateLookupIn(WeakHashMap.class, MethodHandles.lookup());\n+        WHM_TABLE = whmlookup.unreflectVarHandle(WeakHashMap.class.getDeclaredField(\"table\"));\n@@ -68,0 +73,4 @@\n+    \/*\n+     * utility methods\n+     *\/\n+\n@@ -74,1 +83,1 @@\n-    Object[] table(HashMap map) {\n+    Object[] table(Map<?,?> map) {\n@@ -76,1 +85,2 @@\n-            return (Object[]) TABLE.get(map);\n+            VarHandle vh = map instanceof WeakHashMap ? WHM_TABLE : HM_TABLE;\n+            return (Object[]) vh.get(map);\n@@ -80,1 +90,1 @@\n-    int capacity(HashMap map) {\n+    int capacity(Map<?,?> map) {\n@@ -84,14 +94,20 @@\n-    @Test\n-    public void testTableSizeFor() {\n-        assertEquals(tableSizeFor(0), 1);\n-        assertEquals(tableSizeFor(1), 1);\n-        assertEquals(tableSizeFor(2), 2);\n-        assertEquals(tableSizeFor(3), 4);\n-        assertEquals(tableSizeFor(15), 16);\n-        assertEquals(tableSizeFor(16), 16);\n-        assertEquals(tableSizeFor(17), 32);\n-        int maxSize = 1 << 30;\n-        assertEquals(tableSizeFor(maxSize - 1), maxSize);\n-        assertEquals(tableSizeFor(maxSize), maxSize);\n-        assertEquals(tableSizeFor(maxSize + 1), maxSize);\n-        assertEquals(tableSizeFor(Integer.MAX_VALUE), maxSize);\n+    \/\/ creates a map with size mappings\n+    Map<Integer, Integer> makeMap(int size) {\n+        return IntStream.range(0, size)\n+                        .boxed()\n+                        .collect(Collectors.toUnmodifiableMap(i -> i, i -> i));\n+    }\n+\n+    \/\/ creates a \"fake\" map: size() returns the given size, but\n+    \/\/ the entrySet iterator returns only one entry\n+    Map<Integer, Integer> fakeMap(int size) {\n+        return new AbstractMap<>() {\n+            public Set<Map.Entry<Integer,Integer>> entrySet() {\n+                return new AbstractSet<Map.Entry<Integer,Integer>>() {\n+                    public int size() { return size; }\n+                    public Iterator<Map.Entry<Integer,Integer>> iterator() {\n+                        return Set.of(Map.entry(1, 1)).iterator();\n+                    }\n+                };\n+            }\n+        };\n@@ -100,4 +116,3 @@\n-    @Test\n-    public void capacityTestDefaultConstructor() {\n-        capacityTestDefaultConstructor(new HashMap<>());\n-        capacityTestDefaultConstructor(new LinkedHashMap<>());\n+    void putN(Map<Integer, Integer> map, int n) {\n+        for (int i = 0; i < n; i++)\n+            map.put(i, i);\n@@ -106,1 +121,45 @@\n-    void capacityTestDefaultConstructor(HashMap<Integer, Integer> map) {\n+    \/*\n+     * tests of tableSizeFor\n+     *\/\n+\n+    @DataProvider(name=\"tableSizeFor\")\n+    public Object[][] tableSizeForCases() {\n+        final int MAX = 1 << 30;\n+        return new Object[][] {\n+            \/\/ tableSizeFor(arg), expected\n+            { 0,                   1 },\n+            { 1,                   1 },\n+            { 2,                   2 },\n+            { 3,                   4 },\n+            { 4,                   4 },\n+            { 5,                   8 },\n+            { 15,                 16 },\n+            { 16,                 16 },\n+            { 17,                 32 },\n+            { MAX-1,             MAX },\n+            { MAX,               MAX },\n+            { MAX+1,             MAX },\n+            { Integer.MAX_VALUE, MAX }\n+        };\n+    }\n+\n+    @Test(dataProvider=\"tableSizeFor\")\n+    public void tableSizeFor(int arg, int expected) {\n+        assertEquals(tableSizeFor(arg), expected);\n+    }\n+\n+    \/*\n+     * tests for lazy table allocation\n+     *\/\n+\n+    @DataProvider(name=\"lazy\")\n+    public Object[][] lazyTableAllocationCases() {\n+        return new Object[][] {\n+            { new HashMap<>() },\n+         \/\/ { new WeakHashMap<>() }, \/\/ WHM doesn't allocate lazily\n+            { new LinkedHashMap<>() }\n+        };\n+    }\n+\n+    @Test(dataProvider=\"lazy\")\n+    public void lazyTableAllocation(Map<?,?> map) {\n@@ -108,0 +167,1 @@\n+    }\n@@ -109,2 +169,3 @@\n-        map.put(1, 1);\n-        assertEquals(capacity(map), 16); \/\/ default initial capacity\n+    \/*\n+     * tests for default capacity (no-arg constructor)\n+     *\/\n@@ -112,2 +173,7 @@\n-        map.putAll(IntStream.range(0, 64).boxed().collect(toMap(i -> i, i -> i)));\n-        assertEquals(capacity(map), 128);\n+    @DataProvider(name=\"defaultCapacity\")\n+    public Object[][] defaultCapacityCases() {\n+        return new Supplier<?>[][] {\n+            { () -> new HashMap<>() },\n+            { () -> new LinkedHashMap<>() },\n+            { () -> new WeakHashMap<>() }\n+        };\n@@ -116,8 +182,6 @@\n-    @Test\n-    public void capacityTestInitialCapacity() {\n-        int initialCapacity = rnd.nextInt(2, 128);\n-        List<Supplier<HashMap<Integer, Integer>>> suppliers = List.of(\n-            () -> new HashMap<>(initialCapacity),\n-            () -> new HashMap<>(initialCapacity, 0.75f),\n-            () -> new LinkedHashMap<>(initialCapacity),\n-            () -> new LinkedHashMap<>(initialCapacity, 0.75f));\n+    @Test(dataProvider=\"defaultCapacity\")\n+    public void defaultCapacity(Supplier<Map<Integer, Integer>> s) {\n+        var map = s.get();\n+        map.put(0, 0);\n+        assertEquals(capacity(map), 16);\n+    }\n@@ -125,3 +189,3 @@\n-        for (Supplier<HashMap<Integer, Integer>> supplier : suppliers) {\n-            HashMap<Integer, Integer> map = supplier.get();\n-            assertNull(table(map));\n+    \/*\n+     * tests for requested capacity (int and int+float constructors)\n+     *\/\n@@ -129,2 +193,11 @@\n-            map.put(1, 1);\n-            assertEquals(capacity(map), tableSizeFor(initialCapacity));\n+    @DataProvider(name=\"requestedCapacity\")\n+    public Iterator<Object[]> requestedCapacityCases() {\n+        var cases = new ArrayList<Object[]>();\n+        for (int i = 2; i < 128; i++) {\n+            int cap = i;\n+            cases.add(new Object[] { \"rhm1\", cap, (Supplier<Map<Integer, Integer>>) () -> new HashMap<>(cap) });\n+            cases.add(new Object[] { \"rhm2\", cap, (Supplier<Map<Integer, Integer>>) () -> new HashMap<>(cap, 0.75f) });\n+            cases.add(new Object[] { \"rlm1\", cap, (Supplier<Map<Integer, Integer>>) () -> new LinkedHashMap<>(cap) });\n+            cases.add(new Object[] { \"rlm2\", cap, (Supplier<Map<Integer, Integer>>) () -> new LinkedHashMap<>(cap, 0.75f) });\n+            cases.add(new Object[] { \"rwm1\", cap, (Supplier<Map<Integer, Integer>>) () -> new WeakHashMap<>(cap) });\n+            cases.add(new Object[] { \"rwm2\", cap, (Supplier<Map<Integer, Integer>>) () -> new WeakHashMap<>(cap, 0.75f) });\n@@ -132,0 +205,105 @@\n+        return cases.iterator();\n+    }\n+\n+    @Test(dataProvider=\"requestedCapacity\")\n+    public void requestedCapacity(String label, int cap, Supplier<Map<Integer, Integer>> s) {\n+        var map = s.get();\n+        map.put(0, 0);\n+        assertEquals(capacity(map), tableSizeFor(cap));\n+    }\n+\n+    \/*\n+     * Tests for capacity after map is populated with a given number N of mappings.\n+     * Maps are populated using a copy constructor on a map with N mappings,\n+     * other constructors followed by N put() calls, and other constructors followed\n+     * by putAll() on a map with N mappings.\n+     *\n+     * String labels encode the test case for ease of diagnosis if one of the test cases fails.\n+     * For example, \"plm2pn\" is \"populated LinkedHashMap, 2-arg constructor, followed by putN\".\n+     *\/\n+\n+    \/\/ helper method for one populated capacity case, to provide target types for lambdas\n+    Object[] pcc(String label,\n+                 int size,\n+                 int expectedCapacity,\n+                 Supplier<Map<Integer,Integer>> supplier,\n+                 Consumer<Map<Integer,Integer>> consumer) {\n+        return new Object[] { label, size, expectedCapacity, supplier, consumer };\n+    }\n+\n+    List<Object[]> genPopulatedCapacityCases(int size, int cap) {\n+        return Arrays.asList(\n+            pcc(\"phmcpy\", size, cap, () -> new HashMap<>(makeMap(size)),       map -> { }),\n+            pcc(\"phm0pn\", size, cap, () -> new HashMap<>(),                    map -> { putN(map, size); }),\n+            pcc(\"phm1pn\", size, cap, () -> new HashMap<>(cap),                 map -> { putN(map, size); }),\n+            pcc(\"phm2pn\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { putN(map, size); }),\n+            pcc(\"phm0pa\", size, cap, () -> new HashMap<>(),                    map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"phm1pa\", size, cap, () -> new HashMap<>(cap),                 map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"phm2pa\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { map.putAll(makeMap(size)); }),\n+\n+            pcc(\"plmcpy\", size, cap, () -> new LinkedHashMap<>(makeMap(size)), map -> { }),\n+            pcc(\"plm0pn\", size, cap, () -> new LinkedHashMap<>(),              map -> { putN(map, size); }),\n+            pcc(\"plm1pn\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { putN(map, size); }),\n+            pcc(\"plm2pn\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { putN(map, size); }),\n+            pcc(\"plm0pa\", size, cap, () -> new LinkedHashMap<>(),              map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"plm1pa\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"plm2pa\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { map.putAll(makeMap(size)); }),\n+\n+            pcc(\"pwmcpy\", size, cap, () -> new WeakHashMap<>(makeMap(size)),   map -> { }),\n+            pcc(\"pwm0pn\", size, cap, () -> new WeakHashMap<>(),                map -> { putN(map, size); }),\n+            pcc(\"pwm1pn\", size, cap, () -> new WeakHashMap<>(cap),             map -> { putN(map, size); }),\n+            pcc(\"pwm2pn\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { putN(map, size); }),\n+            pcc(\"pwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"pwm1pa\", size, cap, () -> new WeakHashMap<>(cap),             map -> { map.putAll(makeMap(size)); }),\n+            pcc(\"pwm2pa\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { map.putAll(makeMap(size)); })\n+        );\n+    }\n+\n+    List<Object[]> genFakePopulatedCapacityCases(int size, int cap) {\n+        return Arrays.asList(\n+            pcc(\"fhmcpy\", size, cap, () -> new HashMap<>(fakeMap(size)),       map -> { }),\n+            pcc(\"fhm0pa\", size, cap, () -> new HashMap<>(),                    map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"fhm1pa\", size, cap, () -> new HashMap<>(cap),                 map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"fhm2pa\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { map.putAll(fakeMap(size)); }),\n+\n+            pcc(\"flmcpy\", size, cap, () -> new LinkedHashMap<>(fakeMap(size)), map -> { }),\n+            pcc(\"flm0pa\", size, cap, () -> new LinkedHashMap<>(),              map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"flm1pa\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"flm2pa\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { map.putAll(fakeMap(size)); }),\n+\n+            pcc(\"fwmcpy\", size, cap, () -> new WeakHashMap<>(fakeMap(size)),   map -> { }),\n+         \/\/ pcc(\"fwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(fakeMap(size)); }), \/\/ see note\n+            pcc(\"fwm1pa\", size, cap, () -> new WeakHashMap<>(cap),             map -> { map.putAll(fakeMap(size)); }),\n+            pcc(\"fwm2pa\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { map.putAll(fakeMap(size)); })\n+        );\n+\n+        \/\/ Test case \"fwm0pa\" is commented out because WeakHashMap uses a different allocation\n+        \/\/ policy from the other map implementations: it deliberately under-allocates in this case.\n+    }\n+\n+    @DataProvider(name=\"populatedCapacity\")\n+    public Iterator<Object[]> populatedCapacityCases() {\n+        var cases = new ArrayList<Object[]>();\n+        cases.addAll(genPopulatedCapacityCases(11,  16));\n+        cases.addAll(genPopulatedCapacityCases(12,  16));\n+        cases.addAll(genPopulatedCapacityCases(13,  32));\n+        cases.addAll(genPopulatedCapacityCases(64, 128));\n+\n+        \/\/ numbers in this range are truncated by a float computation with 0.75f\n+        \/\/ but can get an exact result with a double computation with 0.75d\n+        cases.addAll(genFakePopulatedCapacityCases(25165824, 33554432));\n+        cases.addAll(genFakePopulatedCapacityCases(25165825, 67108864));\n+        cases.addAll(genFakePopulatedCapacityCases(25165826, 67108864));\n+\n+        return cases.iterator();\n+    }\n+\n+    @Test(dataProvider=\"populatedCapacity\")\n+    public void populatedCapacity(String label, \/\/ unused, included for diagnostics\n+                                  int size,     \/\/ unused, included for diagnostics\n+                                  int expectedCapacity,\n+                                  Supplier<Map<Integer,Integer>> s,\n+                                  Consumer<Map<Integer,Integer>> c) {\n+        var map = s.get();\n+        c.accept(map);\n+        assertEquals(capacity(map), expectedCapacity);\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":236,"deletions":58,"binary":false,"changes":294,"status":"modified"}]}