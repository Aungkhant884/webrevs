{"files":[{"patch":"@@ -3051,1 +3051,1 @@\n-     * Add a package name prefix if the name is not absolute Remove leading \"\/\"\n+     * Add a package name prefix if the name is not absolute. Remove leading \"\/\"\n@@ -3056,2 +3056,1 @@\n-            Class<?> c = isArray() ? elementType() : this;\n-            String baseName = c.getPackageName();\n+            String baseName = getPackageName();\n@@ -3059,1 +3058,6 @@\n-                name = baseName.replace('.', '\/') + \"\/\" + name;\n+                int len = baseName.length() + 1 + name.length();\n+                StringBuilder sb = new StringBuilder(len);\n+                name = sb.append(baseName.replace('.', '\/'))\n+                    .append('\/')\n+                    .append(name)\n+                    .toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,8 +252,2 @@\n-    public synchronized ImageLocation findLocation(String module, String name) {\n-        Objects.requireNonNull(module);\n-        Objects.requireNonNull(name);\n-        \/\/ Details of the algorithm used here can be found in\n-        \/\/ jdk.tools.jlink.internal.PerfectHashBuilder.\n-        int count = header.getTableLength();\n-        int index = redirect.get(ImageStringsReader.hashCode(module, name) % count);\n-\n+    public ImageLocation findLocation(String module, String name) {\n+        int index = getLocationIndex(module, name);\n@@ -261,7 +255,0 @@\n-            \/\/ index is twos complement of location attributes index.\n-            index = -index - 1;\n-        } else if (index > 0) {\n-            \/\/ index is hash seed needed to compute location attributes index.\n-            index = ImageStringsReader.hashCode(module, name, index) % count;\n-        } else {\n-            \/\/ No entry.\n@@ -270,1 +257,0 @@\n-\n@@ -272,1 +258,0 @@\n-\n@@ -279,4 +264,24 @@\n-    public synchronized ImageLocation findLocation(String name) {\n-        Objects.requireNonNull(name);\n-        \/\/ Details of the algorithm used here can be found in\n-        \/\/ jdk.tools.jlink.internal.PerfectHashBuilder.\n+    public ImageLocation findLocation(String name) {\n+        int index = getLocationIndex(name);\n+        if (index < 0) {\n+            return null;\n+        }\n+        long[] attributes = getAttributes(offsets.get(index));\n+        if (!ImageLocation.verify(name, attributes, stringsReader)) {\n+            return null;\n+        }\n+        return new ImageLocation(attributes, stringsReader);\n+    }\n+\n+    public boolean verifyLocation(String module, String name) {\n+        int index = getLocationIndex(module, name);\n+        if (index < 0) {\n+            return false;\n+        }\n+        int locationOffset = offsets.get(index);\n+        return ImageLocation.verify(module, name, locations, locationOffset, stringsReader);\n+    }\n+\n+    \/\/ Details of the algorithm used here can be found in\n+    \/\/ jdk.tools.jlink.internal.PerfectHashBuilder.\n+    public int getLocationIndex(String name) {\n@@ -285,1 +290,0 @@\n-\n@@ -288,1 +292,1 @@\n-            index = -index - 1;\n+            return -index - 1;\n@@ -291,1 +295,1 @@\n-            index = ImageStringsReader.hashCode(name, index) % count;\n+            return ImageStringsReader.hashCode(name, index) % count;\n@@ -294,1 +298,1 @@\n-            return null;\n+            return -1;\n@@ -296,0 +300,1 @@\n+    }\n@@ -297,4 +302,12 @@\n-        long[] attributes = getAttributes(offsets.get(index));\n-\n-        if (!ImageLocation.verify(name, attributes, stringsReader)) {\n-            return null;\n+    private int getLocationIndex(String module, String name) {\n+        int count = header.getTableLength();\n+        int index = redirect.get(ImageStringsReader.hashCode(module, name) % count);\n+        if (index < 0) {\n+            \/\/ index is twos complement of location attributes index.\n+            return -index - 1;\n+        } else if (index > 0) {\n+            \/\/ index is hash seed needed to compute location attributes index.\n+            return ImageStringsReader.hashCode(module, name, index) % count;\n+        } else {\n+            \/\/ No entry.\n+            return -1;\n@@ -302,1 +315,0 @@\n-        return new ImageLocation(attributes, stringsReader);\n@@ -323,3 +335,1 @@\n-\n-        ByteBuffer buffer = slice(locations, offset, locations.limit() - offset);\n-        return ImageLocation.decompress(buffer);\n+        return ImageLocation.decompress(locations, offset);\n@@ -332,0 +342,2 @@\n+        return ImageStringsReader.stringFromByteBuffer(strings, offset);\n+    }\n@@ -333,2 +345,5 @@\n-        ByteBuffer buffer = slice(strings, offset, strings.limit() - offset);\n-        return ImageStringsReader.stringFromByteBuffer(buffer);\n+    public int match(int offset, String string, int stringOffset) {\n+        if (offset < 0 || offset >= strings.limit()) {\n+            throw new IndexOutOfBoundsException(\"offset\");\n+        }\n+        return ImageStringsReader.stringFromByteBufferMatches(strings, offset, string, stringOffset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":51,"deletions":36,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    static long[] decompress(ByteBuffer bytes) {\n+    static long[] decompress(ByteBuffer bytes, int offset) {\n@@ -66,28 +66,10 @@\n-        if (bytes != null) {\n-            while (bytes.hasRemaining()) {\n-                int data = bytes.get() & 0xFF;\n-                int kind = data >>> 3;\n-\n-                if (kind == ATTRIBUTE_END) {\n-                    break;\n-                }\n-\n-                if (kind < ATTRIBUTE_END || ATTRIBUTE_COUNT <= kind) {\n-                    throw new InternalError(\n-                        \"Invalid jimage attribute kind: \" + kind);\n-                }\n-\n-                int length = (data & 0x7) + 1;\n-                long value = 0;\n-\n-                for (int j = 0; j < length; j++) {\n-                    value <<= 8;\n-\n-                    if (!bytes.hasRemaining()) {\n-                        throw new InternalError(\"Missing jimage attribute data\");\n-                    }\n-\n-                    value |= bytes.get() & 0xFF;\n-                }\n-\n-                 attributes[kind] = value;\n+        int limit = bytes.limit();\n+        while (offset < limit) {\n+            int data = bytes.get(offset++) & 0xFF;\n+            if (data <= 0x7) { \/\/ ATTRIBUTE_END\n+                break;\n+            }\n+            int kind = data >>> 3;\n+            if (ATTRIBUTE_COUNT <= kind) {\n+                throw new InternalError(\n+                    \"Invalid jimage attribute kind: \" + kind);\n@@ -95,1 +77,0 @@\n-        }\n@@ -97,0 +78,4 @@\n+            int length = (data & 0x7) + 1;\n+            attributes[kind] = readValue(length, bytes, offset, limit);\n+            offset += length;\n+        }\n@@ -129,2 +114,1 @@\n-     * fewer objects. Could possibly be made allocation free by extending\n-     * ImageStrings to test if strings at an offset match the name region.\n+     * fewer objects.\n@@ -137,3 +121,2 @@\n-        if (moduleOffset != 0) {\n-            String module = strings.get(moduleOffset);\n-            final int moduleLen = module.length();\n+        if (moduleOffset != 0 && length >= 1) {\n+            int moduleLen = strings.match(moduleOffset, name, 1);\n@@ -141,1 +124,2 @@\n-            if (length <= index\n+            if (moduleLen < 0\n+                    || length <= index\n@@ -143,1 +127,0 @@\n-                    || !name.regionMatches(1, module, 0, moduleLen)\n@@ -148,0 +131,6 @@\n+        return verifyName(null, name, index, length, 0,\n+                (int) attributes[ATTRIBUTE_PARENT],\n+                (int) attributes[ATTRIBUTE_BASE],\n+                (int) attributes[ATTRIBUTE_EXTENSION],\n+                strings);\n+    }\n@@ -149,1 +138,50 @@\n-        return verifyName(name, index, length, attributes, strings);\n+    static boolean verify(String module, String name, ByteBuffer locations,\n+                          int locationOffset, ImageStrings strings) {\n+        int moduleOffset = 0;\n+        int parentOffset = 0;\n+        int baseOffset = 0;\n+        int extOffset = 0;\n+\n+        int limit = locations.limit();\n+        while (locationOffset < limit) {\n+            int data = locations.get(locationOffset++) & 0xFF;\n+            if (data <= 0x7) { \/\/ ATTRIBUTE_END\n+                break;\n+            }\n+            int kind = data >>> 3;\n+            if (ATTRIBUTE_COUNT <= kind) {\n+                throw new InternalError(\n+                        \"Invalid jimage attribute kind: \" + kind);\n+            }\n+\n+            int length = (data & 0x7) + 1;\n+            switch (kind) {\n+                case ATTRIBUTE_MODULE:\n+                    moduleOffset = (int) readValue(length, locations, locationOffset, limit);\n+                    break;\n+                case ATTRIBUTE_BASE:\n+                    baseOffset = (int) readValue(length, locations, locationOffset, limit);\n+                    break;\n+                case ATTRIBUTE_PARENT:\n+                    parentOffset = (int) readValue(length, locations, locationOffset, limit);\n+                    break;\n+                case ATTRIBUTE_EXTENSION:\n+                    extOffset = (int) readValue(length, locations, locationOffset, limit);\n+                    break;\n+            }\n+            locationOffset += length;\n+        }\n+        return verifyName(module, name, 0, name.length(),\n+                moduleOffset, parentOffset, baseOffset, extOffset, strings);\n+    }\n+\n+    private static long readValue(int length, ByteBuffer buffer, int offset, int limit) {\n+        long value = 0;\n+        for (int j = 0; j < length; j++) {\n+            value <<= 8;\n+            if (offset >= limit) {\n+                throw new InternalError(\"Missing jimage attribute data\");\n+            }\n+            value |= buffer.get(offset++) & 0xFF;\n+        }\n+        return value;\n@@ -156,1 +194,11 @@\n-        int moduleOffset = (int)attributes[ATTRIBUTE_MODULE];\n+        return verifyName(module, name, 0, name.length(),\n+                (int) attributes[ATTRIBUTE_MODULE],\n+                (int) attributes[ATTRIBUTE_PARENT],\n+                (int) attributes[ATTRIBUTE_BASE],\n+                (int) attributes[ATTRIBUTE_EXTENSION],\n+                strings);\n+    }\n+\n+    private static boolean verifyName(String module, String name, int index, int length,\n+            int moduleOffset, int parentOffset, int baseOffset, int extOffset, ImageStrings strings) {\n+\n@@ -158,1 +206,1 @@\n-            if (!module.equals(strings.get(moduleOffset))) {\n+            if (strings.match(moduleOffset, module, 0) != module.length()) {\n@@ -162,8 +210,0 @@\n-\n-        return verifyName(name, 0, name.length(), attributes, strings);\n-    }\n-\n-    private static boolean verifyName(String name, int index, int length,\n-            long[] attributes, ImageStrings strings) {\n-\n-        int parentOffset = (int) attributes[ATTRIBUTE_PARENT];\n@@ -171,3 +211,2 @@\n-            String parent = strings.get(parentOffset);\n-            final int parentLen = parent.length();\n-            if (!name.regionMatches(index, parent, 0, parentLen)) {\n+            int parentLen = strings.match(parentOffset, name, index);\n+            if (parentLen < 0) {\n@@ -181,3 +220,2 @@\n-        String base = strings.get((int) attributes[ATTRIBUTE_BASE]);\n-        final int baseLen = base.length();\n-        if (!name.regionMatches(index, base, 0, baseLen)) {\n+        int baseLen = strings.match(baseOffset, name, index);\n+        if (baseLen < 0) {\n@@ -187,1 +225,0 @@\n-        int extOffset = (int) attributes[ATTRIBUTE_EXTENSION];\n@@ -189,2 +226,0 @@\n-            String extension = strings.get(extOffset);\n-            int extLen = extension.length();\n@@ -192,2 +227,6 @@\n-                    || name.charAt(index++) != '.'\n-                    || !name.regionMatches(index, extension, 0, extLen)) {\n+                    || name.charAt(index++) != '.') {\n+                return false;\n+            }\n+\n+            int extLen = strings.match(extOffset, name, index);\n+            if (extLen < 0) {\n@@ -206,1 +245,0 @@\n-\n@@ -215,1 +253,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageLocation.java","additions":99,"deletions":62,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,5 @@\n+    public boolean verifyLocation(String mn, String rn) {\n+        requireOpen();\n+        return reader.verifyLocation(mn, rn);\n+    }\n+\n@@ -743,1 +748,1 @@\n-            for ( Node child : children ) {\n+            for (Node child : children) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,12 @@\n-    public String get(int offset);\n+    String get(int offset);\n+\n+    int add(final String string);\n+\n+    \/**\n+     * If there's a string at {@code offset} matching in full a substring of\n+     * {@code string} starting at {@code stringOffset}, return the length\n+     * of that string. Otherwise returns -1. Optional operation.\n+     *\/\n+    default int match(int offset, String string, int stringOffset) {\n+        throw new UnsupportedOperationException();\n+    }\n@@ -38,1 +49,0 @@\n-    public int add(final String string);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageStrings.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -54,0 +55,5 @@\n+    @Override\n+    public int match(int offset, String string, int stringOffset) {\n+        return reader.match(offset, string, stringOffset);\n+    }\n+\n@@ -72,1 +78,1 @@\n-        seed = unmaskedHashCode(\"\/\", seed);\n+        seed = (seed * HASH_MULTIPLIER) ^ ('\/');\n@@ -74,1 +80,1 @@\n-        seed = unmaskedHashCode(\"\/\", seed);\n+        seed = (seed * HASH_MULTIPLIER) ^ ('\/');\n@@ -84,2 +90,1 @@\n-            char ch = s.charAt(i);\n-            int uch = ch & 0xFFFF;\n+            int uch = s.charAt(i);\n@@ -186,1 +191,6 @@\n-    static int charsFromByteBufferLength(ByteBuffer buffer) {\n+    \/**\n+     * Calculates the number of characters in the String present at the\n+     * specified offset. As an optimization, the length returned will\n+     * be positive if the characters are all ASCII, and negative otherwise.\n+     *\/\n+    private static int charsFromByteBufferLength(ByteBuffer buffer, int offset) {\n@@ -189,2 +199,4 @@\n-        while(buffer.hasRemaining()) {\n-            byte ch = buffer.get();\n+        int limit = buffer.limit();\n+        boolean asciiOnly = true;\n+        while (offset < limit) {\n+            byte ch = buffer.get(offset++);\n@@ -192,2 +204,4 @@\n-            if (ch == 0) {\n-                return length;\n+            if (ch < 0) {\n+                asciiOnly = false;\n+            } else if (ch == 0) {\n+                return asciiOnly ? length : -length;\n@@ -200,1 +214,0 @@\n-\n@@ -204,1 +217,1 @@\n-    static void charsFromByteBuffer(char[] chars, ByteBuffer buffer) {\n+    private static void charsFromByteBuffer(char[] chars, ByteBuffer buffer, int offset) {\n@@ -207,2 +220,3 @@\n-        while(buffer.hasRemaining()) {\n-            byte ch = buffer.get();\n+        int limit = buffer.limit();\n+        while (offset < limit) {\n+            byte ch = buffer.get(offset++);\n@@ -221,1 +235,1 @@\n-                    ch = buffer.get();\n+                    ch = buffer.get(offset++);\n@@ -245,4 +259,2 @@\n-        int length = charsFromByteBufferLength(buffer);\n-        buffer.rewind();\n-        char[] chars = new char[length];\n-        charsFromByteBuffer(chars, buffer);\n+        return stringFromByteBuffer(buffer, 0);\n+    }\n@@ -250,0 +262,14 @@\n+    \/* package-private *\/\n+    static String stringFromByteBuffer(ByteBuffer buffer, int offset) {\n+        int length = charsFromByteBufferLength(buffer, offset);\n+        if (length > 0) {\n+            byte[] asciiBytes = new byte[length];\n+            \/\/ Ideally we could use buffer.get(offset, asciiBytes, 0, length)\n+            \/\/ here, but that was introduced in JDK 13\n+            for (int i = 0; i < length; i++) {\n+                asciiBytes[i] = buffer.get(offset++);\n+            }\n+            return new String(asciiBytes, StandardCharsets.US_ASCII);\n+        }\n+        char[] chars = new char[-length];\n+        charsFromByteBuffer(chars, buffer, offset);\n@@ -253,0 +279,36 @@\n+    \/* package-private *\/\n+    static int stringFromByteBufferMatches(ByteBuffer buffer, int offset, String string, int stringOffset) {\n+        \/\/ ASCII fast-path\n+        int limit = buffer.limit();\n+        int current = offset;\n+        int slen = string.length();\n+        while (current < limit) {\n+            byte ch = buffer.get(current);\n+            if (ch <= 0) {\n+                if (ch == 0) {\n+                    \/\/ Match\n+                    return current - offset;\n+                }\n+                \/\/ non-ASCII byte, run slow-path from current offset\n+                break;\n+            }\n+            if (slen <= stringOffset || string.charAt(stringOffset) != (char)ch) {\n+                \/\/ No match\n+                return -1;\n+            }\n+            stringOffset++;\n+            current++;\n+        }\n+        \/\/ invariant: remainder of the string starting at current is non-ASCII,\n+        \/\/ so return value from charsFromByteBufferLength will be negative\n+        int length = -charsFromByteBufferLength(buffer, current);\n+        char[] chars = new char[length];\n+        charsFromByteBuffer(chars, buffer, current);\n+        for (int i = 0; i < length; i++) {\n+            if (string.charAt(stringOffset++) != chars[i]) {\n+                return -1;\n+            }\n+        }\n+        return length;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageStringsReader.java","additions":81,"deletions":19,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -435,0 +435,17 @@\n+        \/**\n+         * Returns {@code true} if the given resource exists, {@code false}\n+         * if not found.\n+         *\/\n+        private boolean containsImageLocation(String name) throws IOException {\n+            Objects.requireNonNull(name);\n+            if (closed)\n+                throw new IOException(\"ModuleReader is closed\");\n+            ImageReader imageReader = SystemImage.reader();\n+            if (imageReader != null) {\n+                return imageReader.verifyLocation(module, name);\n+            } else {\n+                \/\/ not an images build\n+                return false;\n+            }\n+        }\n+\n@@ -437,3 +454,2 @@\n-            ImageLocation location = findImageLocation(name);\n-            if (location != null) {\n-                URI u = URI.create(\"jrt:\/\" + module + \"\/\" + name);\n+            if (containsImageLocation(name)) {\n+                URI u = JNUA.create(\"jrt\", \"\/\" + module + \"\/\" + name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.net.URL;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = \"-Xmx1g\")\n+@Warmup(iterations = 5, time = 2)\n+@Measurement(iterations = 5, time = 3)\n+@State(Scope.Thread)\n+public class ClassGetResource {\n+\n+    \/** Calls Class.getResource with the same name *\/\n+    @Benchmark\n+    public URL stringClass() throws ClassNotFoundException {\n+        return String.class.getResource(\"String.class\");\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ClassGetResource.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}