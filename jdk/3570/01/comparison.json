{"files":[{"patch":"@@ -118,5 +118,3 @@\n-\/\/ Helper method.\n-static bool failed_to_reserve_as_requested(char* base, char* requested_address,\n-                                           const size_t size, bool special, bool is_file_mapped = false)\n-{\n-  if (base == requested_address || requested_address == NULL)\n+\/\/ Helper method\n+static bool failed_to_reserve_as_requested(char* base, char* requested_address) {\n+  if (base == requested_address || requested_address == NULL) {\n@@ -124,0 +122,1 @@\n+  }\n@@ -130,8 +129,0 @@\n-    \/\/ OS ignored requested address. Try different address.\n-    if (special) {\n-      if (!os::release_memory_special(base, size)) {\n-        fatal(\"os::release_memory_special failed\");\n-      }\n-    } else {\n-      unmap_or_release_memory(base, size, is_file_mapped);\n-    }\n@@ -142,0 +133,61 @@\n+static bool use_explicit_large_pages(bool large) {\n+  return !os::can_commit_large_page_memory() && large;\n+}\n+\n+static bool large_pages_requested() {\n+  return UseLargePages &&\n+         (!FLAG_IS_DEFAULT(UseLargePages) || !FLAG_IS_DEFAULT(LargePageSizeInBytes));\n+}\n+\n+static char* reserve_memory(char* requested_address, const size_t size,\n+                            const size_t alignment, int fd, bool exec) {\n+  char* base;\n+  \/\/ If the memory was requested at a particular address, use\n+  \/\/ os::attempt_reserve_memory_at() to avoid mapping over something\n+  \/\/ important.  If the reservation fails, return NULL.\n+  if (requested_address != 0) {\n+    assert(is_aligned(requested_address, alignment),\n+           \"Requested address \" PTR_FORMAT \" must be aligned to \" SIZE_FORMAT,\n+           p2i(requested_address), alignment);\n+    base = attempt_map_or_reserve_memory_at(requested_address, size, fd, exec);\n+  } else {\n+    \/\/ Optimistically assume that the OS returns an aligned base pointer.\n+    \/\/ When reserving a large address range, most OSes seem to align to at\n+    \/\/ least 64K.\n+    base = map_or_reserve_memory(size, fd, exec);\n+    \/\/ Check alignment constraints. This is only needed when there is\n+    \/\/ no requested address.\n+    if (!is_aligned(base, alignment)) {\n+      \/\/ Base not aligned, retry.\n+      unmap_or_release_memory(base, size, fd != -1 \/*is_file_mapped*\/);\n+      \/\/ Map using the requested alignment.\n+      base = map_or_reserve_memory_aligned(size, alignment, fd, exec);\n+    }\n+  }\n+\n+  return base;\n+}\n+\n+static char* reserve_memory_special(char* requested_address, const size_t size,\n+                                    const size_t alignment,  bool exec) {\n+\n+  log_trace(pagesize)(\"Attempt special mapping: size: \" SIZE_FORMAT \"%s, \"\n+                      \"alignment: \" SIZE_FORMAT \"%s\",\n+                      byte_size_in_exact_unit(size), exact_unit_for_byte_size(size),\n+                      byte_size_in_exact_unit(alignment), exact_unit_for_byte_size(alignment));\n+\n+  char* base = os::reserve_memory_special(size, alignment, requested_address, exec);\n+  if (base != NULL) {\n+    \/\/ Check alignment constraints.\n+    assert(is_aligned(base, alignment),\n+           \"reserve_memory_special() returned an unaligned address, base: \" PTR_FORMAT\n+           \" alignment: \" SIZE_FORMAT_HEX,\n+           p2i(base), alignment);\n+  } else {\n+   if (large_pages_requested()) {\n+      log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n+    }\n+  }\n+  return base;\n+}\n+\n@@ -156,0 +208,44 @@\n+void ReservedSpace::reserve(size_t size, size_t alignment, bool large,\n+                            char* requested_address,\n+                            bool executable) {\n+  assert(is_aligned(size, alignment), \"Size must be aligned to the requested alignment\");\n+\n+  \/\/ There are basically three different cases that we need to handle below:\n+  \/\/ - Mapping backed by a file\n+  \/\/ - Mapping backed by explicit large pages\n+  \/\/ - Mapping backed by normal pages or transparent huge pages\n+  \/\/ The first two have restrictions that requires the whole mapping to be\n+  \/\/ committed up front. To record this the ReservedSpace is marked 'special'.\n+\n+  if (_fd_for_heap != -1) {\n+    \/\/ When there is a backing file directory for this space then whether\n+    \/\/ large pages are allocated is up to the filesystem of the backing file.\n+    \/\/ So UseLargePages is not taken into account for this reservation.\n+    char* base = reserve_memory(requested_address, size, alignment, _fd_for_heap, executable);\n+    if (base != NULL) {\n+      initialize_members(base, size, alignment, true, executable);\n+    }\n+    \/\/ Always return, not possible to fall back to reservation not using a file.\n+    return;\n+  } else if (use_explicit_large_pages(large)) {\n+    \/\/ System can't commit large pages i.e. use transparent huge pages and\n+    \/\/ the caller requested large pages. To satisfy this request we use\n+    \/\/ explicit large pages and these have to be committed up front to ensure\n+    \/\/ no reservations are lost.\n+\n+    char* base = reserve_memory_special(requested_address, size, alignment, executable);\n+    if (base != NULL) {\n+      \/\/ Successful reservation using large pages.\n+      initialize_members(base, size, alignment, true, executable);\n+      return;\n+    }\n+    \/\/ Failed to reserve explicit large pages, fall back to normal reservation.\n+  }\n+\n+  \/\/ Not a 'special' reservation.\n+  char* base = reserve_memory(requested_address, size, alignment, -1, executable);\n+  if (base != NULL) {\n+    \/\/ Successful mapping.\n+    initialize_members(base, size, alignment, false, executable);\n+  }\n+}\n@@ -174,0 +270,1 @@\n+  \/\/ Adjust alignment to not be 0.\n@@ -176,40 +273,2 @@\n-  \/\/ If OS doesn't support demand paging for large page memory, we need\n-  \/\/ to use reserve_memory_special() to reserve and pin the entire region.\n-  \/\/ If there is a backing file directory for this space then whether\n-  \/\/ large pages are allocated is up to the filesystem of the backing file.\n-  \/\/ So we ignore the UseLargePages flag in this case.\n-  bool special = large && !os::can_commit_large_page_memory();\n-  if (special && _fd_for_heap != -1) {\n-    special = false;\n-    if (UseLargePages && (!FLAG_IS_DEFAULT(UseLargePages) ||\n-      !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {\n-      log_debug(gc, heap)(\"Ignoring UseLargePages since large page support is up to the file system of the backing file for Java heap\");\n-    }\n-  }\n-\n-  char* base = NULL;\n-\n-  if (special) {\n-\n-    base = os::reserve_memory_special(size, alignment, requested_address, executable);\n-\n-    if (base != NULL) {\n-      if (failed_to_reserve_as_requested(base, requested_address, size, true)) {\n-        \/\/ OS ignored requested address. Try different address.\n-        return;\n-      }\n-      \/\/ Check alignment constraints.\n-      assert((uintptr_t) base % alignment == 0,\n-             \"Large pages returned a non-aligned address, base: \"\n-             PTR_FORMAT \" alignment: \" SIZE_FORMAT_HEX,\n-             p2i(base), alignment);\n-    } else {\n-      \/\/ failed; try to reserve regular memory below. Reservation\n-      \/\/ should not be marked as special.\n-      special = false;\n-      if (UseLargePages && (!FLAG_IS_DEFAULT(UseLargePages) ||\n-                            !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {\n-        log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n-      }\n-    }\n-  }\n+  \/\/ Reserve the memory.\n+  reserve(size, alignment, large, requested_address, executable);\n@@ -217,43 +276,5 @@\n-  if (base == NULL) {\n-    \/\/ Optimistically assume that the OS returns an aligned base pointer.\n-    \/\/ When reserving a large address range, most OSes seem to align to at\n-    \/\/ least 64K.\n-\n-    \/\/ If the memory was requested at a particular address, use\n-    \/\/ os::attempt_reserve_memory_at() to avoid over mapping something\n-    \/\/ important.  If available space is not detected, return NULL.\n-\n-    if (requested_address != 0) {\n-      base = attempt_map_or_reserve_memory_at(requested_address, size, _fd_for_heap, executable);\n-      if (failed_to_reserve_as_requested(base, requested_address, size, false, _fd_for_heap != -1)) {\n-        \/\/ OS ignored requested address. Try different address.\n-        base = NULL;\n-      }\n-    } else {\n-      base = map_or_reserve_memory(size, _fd_for_heap, executable);\n-    }\n-\n-    if (base == NULL) return;\n-\n-    \/\/ Check alignment constraints\n-    if ((((size_t)base) & (alignment - 1)) != 0) {\n-      \/\/ Base not aligned, retry\n-      unmap_or_release_memory(base, size, _fd_for_heap != -1 \/*is_file_mapped*\/);\n-\n-      \/\/ Make sure that size is aligned\n-      size = align_up(size, alignment);\n-      base = map_or_reserve_memory_aligned(size, alignment, _fd_for_heap, executable);\n-\n-      if (requested_address != 0 &&\n-          failed_to_reserve_as_requested(base, requested_address, size, false, _fd_for_heap != -1)) {\n-        \/\/ As a result of the alignment constraints, the allocated base differs\n-        \/\/ from the requested address. Return back to the caller who can\n-        \/\/ take remedial action (like try again without a requested address).\n-        assert(_base == NULL, \"should be\");\n-        return;\n-      }\n-    }\n-  }\n-  \/\/ If heap is reserved with a backing file, the entire space has been committed. So set the special flag to true\n-  if (_fd_for_heap != -1) {\n-    special = true;\n+  \/\/ Check that the requested address is used if given.\n+  if (failed_to_reserve_as_requested(_base, requested_address)) {\n+    \/\/ OS ignored the requested address, release the reservation.\n+    release();\n+    return;\n@@ -261,3 +282,0 @@\n-\n-  \/\/ Done\n-  initialize_members(base, size, alignment, special, executable);\n@@ -378,15 +396,1 @@\n-  \/\/ If OS doesn't support demand paging for large page memory, we need\n-  \/\/ to use reserve_memory_special() to reserve and pin the entire region.\n-  \/\/ If there is a backing file directory for this space then whether\n-  \/\/ large pages are allocated is up to the filesystem of the backing file.\n-  \/\/ So we ignore the UseLargePages flag in this case.\n-  bool special = large && !os::can_commit_large_page_memory();\n-  if (special && _fd_for_heap != -1) {\n-    special = false;\n-    if (UseLargePages && (!FLAG_IS_DEFAULT(UseLargePages) ||\n-                          !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {\n-      log_debug(gc, heap)(\"Cannot allocate large pages for Java Heap when AllocateHeapAt option is set.\");\n-    }\n-  }\n-  char* base = NULL;\n-\n+  \/\/ Try to reserve the memory for the heap.\n@@ -398,32 +402,1 @@\n-  if (special) {\n-    base = os::reserve_memory_special(size, alignment, requested_address, false);\n-\n-    if (base != NULL) {\n-      \/\/ Check alignment constraints.\n-      assert((uintptr_t) base % alignment == 0,\n-             \"Large pages returned a non-aligned address, base: \"\n-             PTR_FORMAT \" alignment: \" SIZE_FORMAT_HEX,\n-             p2i(base), alignment);\n-    }\n-  }\n-\n-  if (base == NULL) {\n-    \/\/ Failed; try to reserve regular memory below. Reservation\n-    \/\/ should not be marked as special.\n-    special = false;\n-    if (UseLargePages && (!FLAG_IS_DEFAULT(UseLargePages) ||\n-                          !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {\n-      log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n-    }\n-\n-    if (requested_address != 0) {\n-      base = attempt_map_or_reserve_memory_at(requested_address, size, _fd_for_heap, executable());\n-    } else {\n-      \/\/ Optimistically assume that the OSes returns an aligned base pointer.\n-      \/\/ When reserving a large address range, most OSes seem to align to at\n-      \/\/ least 64K.\n-      \/\/ If the returned memory is not aligned we will release and retry.\n-      base = map_or_reserve_memory(size, _fd_for_heap, executable());\n-    }\n-  }\n-  if (base == NULL) { return; }\n+  reserve(size, alignment, large, requested_address, false);\n@@ -431,10 +404,2 @@\n-  \/\/ If heap is reserved with a backing file, the entire space has been committed. So set the special flag to true\n-  if (_fd_for_heap != -1) {\n-    special = true;\n-  }\n-\n-  \/\/ Done\n-  initialize_members(base, size, alignment, special, false);\n-\n-  \/\/ Check alignment constraints\n-  if (!is_aligned(base, alignment)) {\n+  \/\/ Check alignment constraints.\n+  if (is_reserved() && !is_aligned(_base, _alignment)) {\n@@ -644,0 +609,6 @@\n+    \/\/ When there is a backing file directory for this space then whether\n+    \/\/ large pages are allocated is up to the filesystem of the backing file.\n+    \/\/ If requested, let the user know that explicit large pages can't be used.\n+    if (use_explicit_large_pages(large) && large_pages_requested()) {\n+      log_debug(gc, heap)(\"Cannot allocate explicit large pages for Java Heap when AllocateHeapAt option is set.\");\n+    }\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":127,"deletions":156,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -66,0 +66,3 @@\n+  void reserve(size_t size, size_t alignment, bool large,\n+               char* requested_address,\n+               bool executable);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}