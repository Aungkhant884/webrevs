{"files":[{"patch":"@@ -173,1 +173,1 @@\n-     * {@link DPathConsumer2D} object as it is calculated.\n+     * {@link PathConsumer2D} object as it is calculated.\n@@ -176,0 +176,2 @@\n+     * @param at the transform to be applied to the shape and the\n+     *           stroke attributes\n@@ -178,0 +180,2 @@\n+     * @param thin true if the transformed stroke attributes are smaller\n+     *             than the minimum dropout pen width\n@@ -182,1 +186,1 @@\n-     * @param consumer the {@code DPathConsumer2D} instance to forward\n+     * @param consumer the {@code PathConsumer2D} instance to forward\n@@ -195,0 +199,49 @@\n+        strokeTo(src, at, null, bs, thin, normalize, antialias, consumer);\n+    }\n+\n+    \/**\n+     * Sends the geometry for a widened path as specified by the parameters\n+     * to the specified consumer.\n+     * <p>\n+     * The specified {@code src} {@link Shape} is widened according\n+     * to the parameters specified by the {@link BasicStroke} object.\n+     * Adjustments are made to the path as appropriate for the\n+     * {@link java.awt.RenderingHints#VALUE_STROKE_NORMALIZE} hint if the\n+     * {@code normalize} boolean parameter is true.\n+     * Adjustments are made to the path as appropriate for the\n+     * {@link java.awt.RenderingHints#VALUE_ANTIALIAS_ON} hint if the\n+     * {@code antialias} boolean parameter is true.\n+     * <p>\n+     * The geometry of the widened path is forwarded to the indicated\n+     * {@link PathConsumer2D} object as it is calculated.\n+     *\n+     * @param src the source path to be widened\n+     * @param at the transform to be applied to the shape and the\n+     *           stroke attributes\n+     * @param clip the current clip in effect in device coordinates\n+     * @param bs the {@code BasicSroke} object specifying the\n+     *           decorations to be applied to the widened path\n+     * @param thin true if the transformed stroke attributes are smaller\n+     *             than the minimum dropout pen width\n+     * @param normalize indicates whether stroke normalization should\n+     *                  be applied\n+     * @param antialias indicates whether or not adjustments appropriate\n+     *                  to antialiased rendering should be applied\n+     * @param consumer the {@code PathConsumer2D} instance to forward\n+     *                 the widened geometry to\n+     * @since 17\n+     *\/\n+\/*    @Override (only for 17+) *\/\n+    public void strokeTo(Shape src,\n+                         AffineTransform at,\n+                         Region clip,\n+                         BasicStroke bs,\n+                         boolean thin,\n+                         boolean normalize,\n+                         boolean antialias,\n+                         final PathConsumer2D consumer)\n+    {\n+        \/\/ Test if at is identity:\n+        final AffineTransform _at = (at != null && !at.isIdentity()) ? at\n+                                    : null;\n+\n@@ -201,1 +254,31 @@\n-            strokeTo(rdrCtx, src, at, bs, thin, norm, antialias,\n+            if ((clip != null) &&\n+                    (DO_CLIP || (DO_CLIP_RUNTIME_ENABLE && MarlinProperties.isDoClipAtRuntime()))) {\n+                \/\/ Define the initial clip bounds:\n+                final double[] clipRect = rdrCtx.clipRect;\n+\n+                \/\/ Adjust the clipping rectangle with the renderer offsets\n+                final double rdrOffX = 0.25d; \/\/ LBO: is it correct for AA or non AA cases ?\n+                final double rdrOffY = 0.25d; \/\/ see NearestPixelQuarter (depends on normalization ?)\n+\n+                \/\/ add a small rounding error:\n+                final double margin = 1e-3d;\n+\n+                clipRect[0] = clip.getLoY()\n+                                - margin + rdrOffY;\n+                clipRect[1] = clip.getLoY() + clip.getHeight()\n+                                + margin + rdrOffY;\n+                clipRect[2] = clip.getLoX()\n+                                - margin + rdrOffX;\n+                clipRect[3] = clip.getLoX() + clip.getWidth()\n+                                + margin + rdrOffX;\n+\n+                if (MarlinConst.DO_LOG_CLIP) {\n+                    MarlinUtils.logInfo(\"clipRect (clip): \"\n+                                        + Arrays.toString(rdrCtx.clipRect));\n+                }\n+\n+                \/\/ Enable clipping:\n+                rdrCtx.doClip = true;\n+            }\n+\n+            strokeTo(rdrCtx, src, _at, bs, thin, norm, antialias,\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DMarlinRenderingEngine.java","additions":86,"deletions":3,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -176,0 +176,2 @@\n+     * @param at the transform to be applied to the shape and the\n+     *           stroke attributes\n@@ -178,0 +180,2 @@\n+     * @param thin true if the transformed stroke attributes are smaller\n+     *             than the minimum dropout pen width\n@@ -195,0 +199,49 @@\n+        strokeTo(src, at, null, bs, thin, normalize, antialias, consumer);\n+    }\n+\n+    \/**\n+     * Sends the geometry for a widened path as specified by the parameters\n+     * to the specified consumer.\n+     * <p>\n+     * The specified {@code src} {@link Shape} is widened according\n+     * to the parameters specified by the {@link BasicStroke} object.\n+     * Adjustments are made to the path as appropriate for the\n+     * {@link java.awt.RenderingHints#VALUE_STROKE_NORMALIZE} hint if the\n+     * {@code normalize} boolean parameter is true.\n+     * Adjustments are made to the path as appropriate for the\n+     * {@link java.awt.RenderingHints#VALUE_ANTIALIAS_ON} hint if the\n+     * {@code antialias} boolean parameter is true.\n+     * <p>\n+     * The geometry of the widened path is forwarded to the indicated\n+     * {@link PathConsumer2D} object as it is calculated.\n+     *\n+     * @param src the source path to be widened\n+     * @param at the transform to be applied to the shape and the\n+     *           stroke attributes\n+     * @param clip the current clip in effect in device coordinates\n+     * @param bs the {@code BasicSroke} object specifying the\n+     *           decorations to be applied to the widened path\n+     * @param thin true if the transformed stroke attributes are smaller\n+     *             than the minimum dropout pen width\n+     * @param normalize indicates whether stroke normalization should\n+     *                  be applied\n+     * @param antialias indicates whether or not adjustments appropriate\n+     *                  to antialiased rendering should be applied\n+     * @param consumer the {@code PathConsumer2D} instance to forward\n+     *                 the widened geometry to\n+     * @since 17\n+     *\/\n+\/*    @Override (only for 17+) *\/\n+    public void strokeTo(Shape src,\n+                         AffineTransform at,\n+                         Region clip,\n+                         BasicStroke bs,\n+                         boolean thin,\n+                         boolean normalize,\n+                         boolean antialias,\n+                         final PathConsumer2D consumer)\n+    {\n+        \/\/ Test if at is identity:\n+        final AffineTransform _at = (at != null && !at.isIdentity()) ? at\n+                                    : null;\n+\n@@ -201,1 +254,31 @@\n-            strokeTo(rdrCtx, src, at, bs, thin, norm, antialias, consumer);\n+            if ((clip != null) &&\n+                    (DO_CLIP || (DO_CLIP_RUNTIME_ENABLE && MarlinProperties.isDoClipAtRuntime()))) {\n+                \/\/ Define the initial clip bounds:\n+                final float[] clipRect = rdrCtx.clipRect;\n+\n+                \/\/ Adjust the clipping rectangle with the renderer offsets\n+                final float rdrOffX = 0.25f; \/\/ LBO: is it correct for AA or non AA cases ?\n+                final float rdrOffY = 0.25f; \/\/ see NearestPixelQuarter (depends on normalization ?)\n+\n+                \/\/ add a small rounding error:\n+                final float margin = 1e-3f;\n+\n+                clipRect[0] = clip.getLoY()\n+                                - margin + rdrOffY;\n+                clipRect[1] = clip.getLoY() + clip.getHeight()\n+                                + margin + rdrOffY;\n+                clipRect[2] = clip.getLoX()\n+                                - margin + rdrOffX;\n+                clipRect[3] = clip.getLoX() + clip.getWidth()\n+                                + margin + rdrOffX;\n+\n+                if (MarlinConst.DO_LOG_CLIP) {\n+                    MarlinUtils.logInfo(\"clipRect (clip): \"\n+                                        + Arrays.toString(rdrCtx.clipRect));\n+                }\n+\n+                \/\/ Enable clipping:\n+                rdrCtx.doClip = true;\n+            }\n+\n+            strokeTo(rdrCtx, src, _at, bs, thin, norm, antialias, consumer);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinRenderingEngine.java","additions":84,"deletions":1,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -883,0 +883,1 @@\n+    \/* note: CurveClipSplitter uses double-precision for higher accuracy *\/\n@@ -901,1 +902,1 @@\n-        final float[] clipRectPad = new float[4];\n+        final double[] clipRectPad = new double[4];\n@@ -906,1 +907,1 @@\n-        final float[] middle = new float[MAX_N_CURVES * 8 + 2];\n+        final double[] middle = new double[MAX_N_CURVES * 8 + 2];\n@@ -908,1 +909,1 @@\n-        private final float[] subdivTs = new float[MAX_N_CURVES];\n+        private final double[] subdivTs = new double[MAX_N_CURVES];\n@@ -911,1 +912,1 @@\n-        private final Curve curve;\n+        private final DCurve curve;\n@@ -916,1 +917,1 @@\n-            this.curve = rdrCtx.curve;\n+            this.curve = \/* rdrCtx.curve *\/ new DCurve(); \/\/ double-precision curve\n@@ -938,1 +939,1 @@\n-            final float[] _clipRectPad = clipRectPad;\n+            final double[] _clipRectPad = clipRectPad;\n@@ -964,1 +965,1 @@\n-            final float[] mid = middle;\n+            final double[] mid = middle;\n@@ -985,1 +986,1 @@\n-            final float[] mid = middle;\n+            final double[] mid = middle;\n@@ -1008,1 +1009,1 @@\n-            final float[] mid = middle;\n+            final double[] mid = middle;\n@@ -1020,2 +1021,2 @@\n-            final float[] mid = middle;\n-            final float[] subTs = subdivTs;\n+            final double[] mid = middle;\n+            final double[] subTs = subdivTs;\n@@ -1028,1 +1029,1 @@\n-            final int nSplits = Helpers.findClipPoints(curve, mid, subTs, type,\n+            final int nSplits = DHelpers.findClipPoints(curve, mid, subTs, type,\n@@ -1039,1 +1040,1 @@\n-            float prevT = 0.0f;\n+            double prevT = 0.0d;\n@@ -1042,1 +1043,1 @@\n-                final float t = subTs[i];\n+                final double t = subTs[i];\n@@ -1044,1 +1045,1 @@\n-                Helpers.subdivideAt((t - prevT) \/ (1.0f - prevT),\n+                DHelpers.subdivideAt((t - prevT) \/ (1.0d - prevT),\n@@ -1058,1 +1059,1 @@\n-        static void emitCurrent(final int type, final float[] pts,\n+        static void emitCurrent(final int type, final double[] pts,\n@@ -1063,3 +1064,3 @@\n-                out.curveTo(pts[off + 2], pts[off + 3],\n-                            pts[off + 4], pts[off + 5],\n-                            pts[off + 6], pts[off + 7]);\n+                out.curveTo((float)pts[off + 2], (float)pts[off + 3],\n+                            (float)pts[off + 4], (float)pts[off + 5],\n+                            (float)pts[off + 6], (float)pts[off + 7]);\n@@ -1067,1 +1068,1 @@\n-                out.lineTo(pts[off + 2], pts[off + 3]);\n+                out.lineTo((float)pts[off + 2], (float)pts[off + 3]);\n@@ -1069,2 +1070,2 @@\n-                out.quadTo(pts[off + 2], pts[off + 3],\n-                           pts[off + 4], pts[off + 5]);\n+                out.quadTo((float)pts[off + 2], (float)pts[off + 3],\n+                           (float)pts[off + 4], (float)pts[off + 5]);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/TransformingPathConsumer2D.java","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -264,1 +264,2 @@\n-            sr.setOutputArea(sg2d.getCompClip());\n+            final Region clip = sg2d.getCompClip();\n+            sr.setOutputArea(clip);\n@@ -272,0 +273,2 @@\n+\/\/ No clipping (pre-jdk17)\n+\/*\n@@ -275,0 +278,5 @@\n+*\/\n+\/\/ lbourges: give clip in jdk17+\n+            RenderEngine.strokeTo(s,\n+                                  sg2d.transform, clip, bs,\n+                                  thin, normalize, false, sr);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/LoopPipe.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -203,0 +203,2 @@\n+     * @param at the transform to be applied to the shape and the\n+     *           stroke attributes\n@@ -205,0 +207,2 @@\n+     * @param thin true if the transformed stroke attributes are smaller\n+     *             than the minimum dropout pen width\n@@ -221,0 +225,47 @@\n+    \/**\n+     * Sends the geometry for a widened path as specified by the parameters\n+     * to the specified consumer.\n+     * <p>\n+     * The specified {@code src} {@link Shape} is widened according\n+     * to the parameters specified by the {@link BasicStroke} object.\n+     * The clip region can be optionally given to let the renderer only\n+     * send geometries overlapping the clip region.\n+     * Adjustments are made to the path as appropriate for the\n+     * {@link java.awt.RenderingHints#VALUE_STROKE_NORMALIZE} hint if the\n+     * {@code normalize} boolean parameter is true.\n+     * Adjustments are made to the path as appropriate for the\n+     * {@link java.awt.RenderingHints#VALUE_ANTIALIAS_ON} hint if the\n+     * {@code antialias} boolean parameter is true.\n+     * <p>\n+     * The geometry of the widened path is forwarded to the indicated\n+     * {@link PathConsumer2D} object as it is calculated.\n+     *\n+     * @param src the source path to be widened\n+     * @param at the transform to be applied to the shape and the\n+     *           stroke attributes\n+     * @param clip the current clip in effect in device coordinates\n+     * @param bs the {@code BasicSroke} object specifying the\n+     *           decorations to be applied to the widened path\n+     * @param thin true if the transformed stroke attributes are smaller\n+     *             than the minimum dropout pen width\n+     * @param normalize indicates whether stroke normalization should\n+     *                  be applied\n+     * @param antialias indicates whether or not adjustments appropriate\n+     *                  to antialiased rendering should be applied\n+     * @param consumer the {@code PathConsumer2D} instance to forward\n+     *                 the widened geometry to\n+     * @since 17\n+     *\/\n+    public void strokeTo(Shape src,\n+                         AffineTransform at,\n+                         Region clip,\n+                         BasicStroke bs,\n+                         boolean thin,\n+                         boolean normalize,\n+                         boolean antialias,\n+                         final PathConsumer2D consumer)\n+    {\n+        \/\/ As default implementation, call the strokeTo() method without the clip region.\n+        strokeTo(src, at, bs, thin, normalize, antialias, consumer);\n+    }\n+\n@@ -431,0 +482,22 @@\n+        public void strokeTo(Shape src,\n+                             AffineTransform at,\n+                             Region clip,\n+                             BasicStroke bs,\n+                             boolean thin,\n+                             boolean normalize,\n+                             boolean antialias,\n+                             PathConsumer2D consumer)\n+        {\n+            System.out.println(name+\".strokeTo(\"+\n+                               src.getClass().getName()+\", \"+\n+                               at+\", \"+\n+                               clip+\", \"+\n+                               bs+\", \"+\n+                               (thin ? \"thin\" : \"wide\")+\", \"+\n+                               (normalize ? \"normalized\" : \"pure\")+\", \"+\n+                               (antialias ? \"AA\" : \"non-AA\")+\", \"+\n+                               consumer.getClass().getName()+\")\");\n+            target.strokeTo(src, at, clip, bs, thin, normalize, antialias, consumer);\n+        }\n+\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/RenderingEngine.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-    static final RenderingEngine RenderEngine = RenderingEngine.getInstance();\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/SpanShapeRenderer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BasicStroke;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.Stroke;\n+import java.awt.geom.Line2D;\n+import java.awt.image.BufferedImage;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+\n+\/**\n+ * @test\n+ * @bug 7018932\n+ * @summary fix LoopPipe.getStrokedSpans() performance (clipping enabled by Marlin renderer)\n+ * @run main DrawingTest7018932\n+ * @run main\/othervm\/timeout=10 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine StrokedLinePerf\n+ * @run main\/othervm\/timeout=10 -Dsun.java2d.renderer=sun.java2d.marlin.DMarlinRenderingEngine StrokedLinePerf\n+ *\/\n+public class StrokedLinePerf {\n+\n+    public static void main(String[] unused) {\n+        BufferedImage bi = new BufferedImage(400, 400, TYPE_INT_ARGB_PRE);\n+        test(bi, true);\n+        test(bi, false);\n+    }\n+\n+    private static void test(BufferedImage bi, boolean useAA) {\n+        final long start = System.nanoTime();\n+\n+        final Graphics2D g2d = bi.createGraphics();\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                (useAA) ? RenderingHints.VALUE_ANTIALIAS_ON\n+                        : RenderingHints.VALUE_ANTIALIAS_OFF);\n+\n+        Stroke stroke = new BasicStroke(2.0f, 1, 0, 1.0f, new float[]{0.0f, 4.0f}, 0.0f);\n+        g2d.setStroke(stroke);\n+\n+        \/\/Large values to trigger crash \/ infinite loop.\n+        g2d.draw(new Line2D.Double(4.0, 1.794369841E9, 567.0, -2.147483648E9));\n+\n+        System.out.println(\"StrokedLinePerf(\" + useAA + \"): Test duration= \" + (1e-6 * (System.nanoTime() - start)) + \" ms.\");\n+        g2d.dispose();\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/marlin\/StrokedLinePerf.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}