{"files":[{"patch":"@@ -268,1 +268,1 @@\n-        setTopFile(docEnv);\n+        setTopFile();\n@@ -280,2 +280,0 @@\n-     *\n-     * @param docEnv the doclet environment\n@@ -283,2 +281,2 @@\n-    protected void setTopFile(DocletEnvironment docEnv) {\n-        if (!checkForDeprecation(docEnv)) {\n+    protected void setTopFile() {\n+        if (!checkForDeprecation()) {\n@@ -316,1 +314,1 @@\n-    protected boolean checkForDeprecation(DocletEnvironment docEnv) {\n+    protected boolean checkForDeprecation() {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-                && vmt.getImplementedMethods(method).isEmpty() == false)\n+                && !vmt.getImplementedMethods(method).isEmpty())\n@@ -809,7 +809,0 @@\n-    public boolean isClassLinkable(TypeElement typeElement) {\n-        if (utils.isIncluded(typeElement)) {\n-            return configuration.isGeneratedDoc(typeElement);\n-        }\n-        return configuration.extern.isExternal(typeElement);\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-            if (configuration.isGeneratedDoc(typeElement)) {\n+            if (configuration.isGeneratedDoc(typeElement) && !utils.hasHiddenTag(typeElement)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,14 +152,16 @@\n-                Content link =\n-                        writer.getDocLink(HtmlLinkInfo.Kind.EXECUTABLE_ELEMENT_COPY,\n-                        holder, method,\n-                        utils.isIncluded(holder)\n-                                ? utils.getSimpleName(holder)\n-                                : utils.getFullyQualifiedName(holder));\n-                Content codeLink = HtmlTree.CODE(link);\n-                Content descfrmLabel = HtmlTree.SPAN(HtmlStyle.descfrmTypeLabel,\n-                        utils.isClass(holder)\n-                                ? contents.descfrmClassLabel\n-                                : contents.descfrmInterfaceLabel);\n-                descfrmLabel.add(Entity.NO_BREAK_SPACE);\n-                descfrmLabel.add(codeLink);\n-                methodDocTree.add(HtmlTree.DIV(HtmlStyle.block, descfrmLabel));\n+                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(method)) {\n+                    Content link =\n+                            writer.getDocLink(HtmlLinkInfo.Kind.EXECUTABLE_ELEMENT_COPY,\n+                                    holder, method,\n+                                    utils.isIncluded(holder)\n+                                            ? utils.getSimpleName(holder)\n+                                            : utils.getFullyQualifiedName(holder));\n+                    Content codeLink = HtmlTree.CODE(link);\n+                    Content descfrmLabel = HtmlTree.SPAN(HtmlStyle.descfrmTypeLabel,\n+                            utils.isClass(holder)\n+                                    ? contents.descfrmClassLabel\n+                                    : contents.descfrmInterfaceLabel);\n+                    descfrmLabel.add(Entity.NO_BREAK_SPACE);\n+                    descfrmLabel.add(codeLink);\n+                    methodDocTree.add(HtmlTree.DIV(HtmlStyle.block, descfrmLabel));\n+                }\n@@ -268,0 +270,3 @@\n+        if (utils.hasHiddenTag(holder) || utils.hasHiddenTag(method)) {\n+            return;\n+        }\n@@ -269,28 +274,11 @@\n-        if (method != null) {\n-            Contents contents = writer.contents;\n-            Content label;\n-            HtmlLinkInfo.Kind context;\n-            if (utils.isAbstract(holder) && utils.isAbstract(method)){\n-                \/\/Abstract method is implemented from abstract class,\n-                \/\/not overridden\n-                label = contents.specifiedByLabel;\n-                context = HtmlLinkInfo.Kind.METHOD_SPECIFIED_BY;\n-            } else {\n-                label = contents.overridesLabel;\n-                context = HtmlLinkInfo.Kind.METHOD_OVERRIDES;\n-            }\n-            dl.add(HtmlTree.DT(label));\n-            Content overriddenTypeLink =\n-                    writer.getLink(new HtmlLinkInfo(writer.configuration, context, overriddenType));\n-            Content codeOverriddenTypeLink = HtmlTree.CODE(overriddenTypeLink);\n-            Content methlink = writer.getLink(\n-                    new HtmlLinkInfo(writer.configuration, HtmlLinkInfo.Kind.MEMBER, holder)\n-                            .where(writer.htmlIds.forMember(method).name())\n-                            .label(method.getSimpleName()));\n-            Content codeMethLink = HtmlTree.CODE(methlink);\n-            Content dd = HtmlTree.DD(codeMethLink);\n-            dd.add(Entity.NO_BREAK_SPACE);\n-            dd.add(contents.inClass);\n-            dd.add(Entity.NO_BREAK_SPACE);\n-            dd.add(codeOverriddenTypeLink);\n-            dl.add(dd);\n+        Contents contents = writer.contents;\n+        Content label;\n+        HtmlLinkInfo.Kind context;\n+        if (utils.isAbstract(holder) && utils.isAbstract(method)) {\n+            \/\/Abstract method is implemented from abstract class,\n+            \/\/not overridden\n+            label = contents.specifiedByLabel;\n+            context = HtmlLinkInfo.Kind.METHOD_SPECIFIED_BY;\n+        } else {\n+            label = contents.overridesLabel;\n+            context = HtmlLinkInfo.Kind.METHOD_OVERRIDES;\n@@ -298,0 +286,15 @@\n+        dl.add(HtmlTree.DT(label));\n+        Content overriddenTypeLink =\n+                writer.getLink(new HtmlLinkInfo(writer.configuration, context, overriddenType));\n+        Content codeOverriddenTypeLink = HtmlTree.CODE(overriddenTypeLink);\n+        Content methlink = writer.getLink(\n+                new HtmlLinkInfo(writer.configuration, HtmlLinkInfo.Kind.MEMBER, holder)\n+                        .where(writer.htmlIds.forMember(method).name())\n+                        .label(method.getSimpleName()));\n+        Content codeMethLink = HtmlTree.CODE(methlink);\n+        Content dd = HtmlTree.DD(codeMethLink);\n+        dd.add(Entity.NO_BREAK_SPACE);\n+        dd.add(contents.inClass);\n+        dd.add(Entity.NO_BREAK_SPACE);\n+        dd.add(codeOverriddenTypeLink);\n+        dl.add(dd);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java","additions":45,"deletions":42,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -114,13 +114,15 @@\n-                Content link =\n-                        writer.getDocLink(HtmlLinkInfo.Kind.PROPERTY_COPY,\n-                        holder, property,\n-                        utils.isIncluded(holder)\n-                                ? holder.getSimpleName() : holder.getQualifiedName());\n-                Content codeLink = HtmlTree.CODE(link);\n-                Content descfrmLabel = HtmlTree.SPAN(HtmlStyle.descfrmTypeLabel,\n-                        utils.isClass(holder)\n-                                ? contents.descfrmClassLabel\n-                                : contents.descfrmInterfaceLabel);\n-                descfrmLabel.add(Entity.NO_BREAK_SPACE);\n-                descfrmLabel.add(codeLink);\n-                propertyDocTree.add(HtmlTree.DIV(HtmlStyle.block, descfrmLabel));\n+                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(property)) {\n+                    Content link =\n+                            writer.getDocLink(HtmlLinkInfo.Kind.PROPERTY_COPY,\n+                                    holder, property,\n+                                    utils.isIncluded(holder)\n+                                            ? holder.getSimpleName() : holder.getQualifiedName());\n+                    Content codeLink = HtmlTree.CODE(link);\n+                    Content descfrmLabel = HtmlTree.SPAN(HtmlStyle.descfrmTypeLabel,\n+                            utils.isClass(holder)\n+                                    ? contents.descfrmClassLabel\n+                                    : contents.descfrmInterfaceLabel);\n+                    descfrmLabel.add(Entity.NO_BREAK_SPACE);\n+                    descfrmLabel.add(codeLink);\n+                    propertyDocTree.add(HtmlTree.DIV(HtmlStyle.block, descfrmLabel));\n+                }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriterImpl.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,2 @@\n-        return visibleClasses.contains(typeElement) && configuration.isGeneratedDoc(typeElement);\n+        return visibleClasses.contains(typeElement) && configuration.isGeneratedDoc(typeElement)\n+                && !utils.hasHiddenTag(typeElement);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerializedFormWriterImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,0 +412,3 @@\n+            if (utils.hasHiddenTag(inheritedClass)) {\n+                continue;\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MemberSummaryBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -555,2 +555,0 @@\n-            } else if (utils.isPublic(te) || utils.isProtected(te)) {\n-                return true;\n@@ -558,1 +556,1 @@\n-                return false;\n+                return utils.isPublic(te) || utils.isProtected(te);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/SerializedFormBuilder.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -612,1 +612,2 @@\n-        return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))\n+        return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement)\n+                    || hasHiddenTag(enclosingTypeElement))\n@@ -1160,2 +1161,3 @@\n-            (typeElem != null &&\n-                (isIncluded(typeElem) && configuration.isGeneratedDoc(typeElem))) ||\n+            typeElem != null &&\n+            ((isIncluded(typeElem) && configuration.isGeneratedDoc(typeElem) &&\n+                    !hasHiddenTag(typeElem)) ||\n@@ -1163,1 +1165,1 @@\n-                (isPublic(typeElem) || isProtected(typeElem)));\n+                    (isPublic(typeElem) || isProtected(typeElem))));\n@@ -1186,1 +1188,1 @@\n-        if (isIncluded(elem)) {\n+        if (isIncluded(elem) && !hasHiddenTag(elem)) {\n@@ -1556,1 +1558,1 @@\n-     * Returns true if the element is included, contains &#64;hidden tag,\n+     * Returns true if the element is included or selected, contains &#64;hidden tag,\n@@ -1563,1 +1565,2 @@\n-        \/\/ prevent needless tests on elements which are not included\n+        \/\/ Non-included elements may still be visible via \"transclusion\" from undocumented enclosures,\n+        \/\/ but we don't want to run doclint on them, possibly causing warnings or errors.\n@@ -1565,1 +1568,1 @@\n-            return false;\n+            return hasBlockTagUnchecked(e, HIDDEN);\n@@ -2268,1 +2271,1 @@\n-        if (e.getKind() == ElementKind.PACKAGE)\n+        if (isPackage(e) || isModule(e)) {\n@@ -2270,0 +2273,1 @@\n+        }\n@@ -2271,2 +2275,1 @@\n-        ElementKind kind = encl.getKind();\n-        if (kind == ElementKind.PACKAGE)\n+        if (isPackage(encl)) {\n@@ -2274,0 +2277,2 @@\n+        }\n+        ElementKind kind = encl.getKind();\n@@ -2594,1 +2599,4 @@\n-        DocCommentTree dcTree = getDocCommentTree(element);\n+        return getBlockTags(getDocCommentTree(element));\n+    }\n+\n+    public List<? extends DocTree> getBlockTags(DocCommentTree dcTree) {\n@@ -2644,4 +2652,18 @@\n-            String tname = tagName != null && tagName.startsWith(\"@\")\n-                    ? tagName.substring(1)\n-                    : tagName;\n-            for (DocTree dt : getBlockTags(element, kind)) {\n+            for (DocTree dt : getBlockTags(ch.dcTree)) {\n+                if (dt.getKind() == kind && (tagName == null || ch.getTagName(dt).equals(tagName))) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/*\n+     * Tests whether an element's doc comment contains a block tag without caching it or\n+     * running doclint on it. This is done by using getDocCommentInfo(Element) to retrieve\n+     * the doc comment info.\n+     *\/\n+    boolean hasBlockTagUnchecked(Element element, DocTree.Kind kind) {\n+        DocCommentInfo dcInfo = getDocCommentInfo(element);\n+        if (dcInfo != null && dcInfo.dcTree != null) {\n+            for (DocTree dt : getBlockTags(dcInfo.dcTree)) {\n@@ -2649,3 +2671,1 @@\n-                    if (tname == null || ch.getTagName(dt).equals(tname)) {\n-                        return true;\n-                    }\n+                    return true;\n@@ -2704,1 +2724,1 @@\n-     * @param element\n+     * @param element the element\n@@ -2762,1 +2782,1 @@\n-        if (element.getKind() != ElementKind.OTHER) {\n+        if (!isOverviewElement(element)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    Map<ExecutableElement, OverridingMethodInfo> overriddenMethodTable\n+    Map<ExecutableElement, OverriddenMethodInfo> overriddenMethodTable\n@@ -243,1 +243,1 @@\n-        OverridingMethodInfo found = overriddenMethodTable.get(e);\n+        OverriddenMethodInfo found = overriddenMethodTable.get(e);\n@@ -246,1 +246,1 @@\n-            return found.overrider;\n+            return found.overridden;\n@@ -259,1 +259,1 @@\n-        OverridingMethodInfo found = overriddenMethodTable.get(e);\n+        OverriddenMethodInfo found = overriddenMethodTable.get(e);\n@@ -261,1 +261,1 @@\n-            return found.overrider;\n+            return found.overridden;\n@@ -478,1 +478,1 @@\n-                OverridingMethodInfo p = e.getValue();\n+                OverriddenMethodInfo p = e.getValue();\n@@ -480,1 +480,1 @@\n-                    List<ExecutableElement> list = overriddenByTable.computeIfAbsent(p.overrider,\n+                    List<ExecutableElement> list = overriddenByTable.computeIfAbsent(p.overridden,\n@@ -489,1 +489,1 @@\n-        \/\/ a. cannot override (private instance members)\n+        \/\/ a. cannot be overridden (private instance members)\n@@ -492,1 +492,1 @@\n-        \/\/ see allowInheritedMethods, which performs the above actions\n+        \/\/ see allowInheritedMethod, which performs the above actions\n@@ -494,1 +494,1 @@\n-                .filter(e -> allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))\n+                .filter(e -> allowInheritedMethod((ExecutableElement) e, overriddenByTable, lmt))\n@@ -501,1 +501,1 @@\n-            OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);\n+            OverriddenMethodInfo p = overriddenMethodTable.getOrDefault(m, null);\n@@ -532,3 +532,3 @@\n-    boolean allowInheritedMethods(ExecutableElement inheritedMethod,\n-                                  Map<ExecutableElement, List<ExecutableElement>> inheritedOverriddenTable,\n-                                  LocalMemberTable lmt) {\n+    boolean allowInheritedMethod(ExecutableElement inheritedMethod,\n+                                 Map<ExecutableElement, List<ExecutableElement>> overriddenByTable,\n+                                 LocalMemberTable lmt) {\n@@ -555,1 +555,1 @@\n-            List<ExecutableElement> list = inheritedOverriddenTable.get(inheritedMethod);\n+            List<ExecutableElement> list = overriddenByTable.get(inheritedMethod);\n@@ -589,1 +589,1 @@\n-                            l -> new OverridingMethodInfo(inheritedMethod, false));\n+                            l -> new OverriddenMethodInfo(inheritedMethod, false));\n@@ -594,1 +594,3 @@\n-                \/\/ overriding method if something noteworthy has been added or changed.\n+                \/\/ overriding method if something noteworthy has been added or changed\n+                \/\/ either in the local overriding method or an in-between overriding method\n+                \/\/ (as evidenced by an entry in overriddenByTable).\n@@ -596,1 +598,2 @@\n-                        && !overridingSignatureChanged(lMethod, inheritedMethod);\n+                        && !overridingSignatureChanged(lMethod, inheritedMethod)\n+                        && !overriddenByTable.containsKey(inheritedMethod);\n@@ -598,1 +601,1 @@\n-                        l -> new OverridingMethodInfo(inheritedMethod, simpleOverride));\n+                        l -> new OverriddenMethodInfo(inheritedMethod, simpleOverride));\n@@ -1034,1 +1037,1 @@\n-     * A simple container to encapsulate an overriding method\n+     * A simple container to encapsulate an overridden method\n@@ -1037,2 +1040,2 @@\n-    static class OverridingMethodInfo {\n-        final ExecutableElement overrider;\n+    static class OverriddenMethodInfo {\n+        final ExecutableElement overridden;\n@@ -1041,2 +1044,2 @@\n-        public OverridingMethodInfo(ExecutableElement overrider, boolean simpleOverride) {\n-            this.overrider = overrider;\n+        public OverriddenMethodInfo(ExecutableElement overridden, boolean simpleOverride) {\n+            this.overridden = overridden;\n@@ -1048,1 +1051,1 @@\n-            return \"OverridingMethodInfo[\" + overrider + \",simple:\" + simpleOverride + \"]\";\n+            return \"OverriddenMethodInfo[\" + overridden + \",simple:\" + simpleOverride + \"]\";\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":28,"deletions":25,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8073100 8182765 8196202\n+ * @bug 8073100 8182765 8196202 8261079\n@@ -66,3 +66,2 @@\n-                \"<h3 id=\\\"inVisibleField\\\">\",\n-                \"\"\"\n-                    <h3><span id=\"inVisibleMethod()\">\"\"\");\n+                \"invisibleField\",\n+                \"invisibleMethod()\");\n@@ -85,2 +84,2 @@\n-                \"<a id=\\\"inVisibleField\\\">\",\n-                \"<a id=\\\"inVisibleMethod()\\\">\");\n+                \"invisibleField\",\n+                \"invisibleMethod()\");\n@@ -103,0 +102,47 @@\n+        checkOutput(\"pkg1\/Intf.html\", true,\n+                \"\"\"\n+                    <section class=\"detail\" id=\"visibleDefaultMethod()\">\"\"\",\n+                \"\"\"\n+                    <section class=\"detail\" id=\"visibleInterfaceMethod()\">\"\"\",\n+                \"\"\"\n+                    <dt>All Known Implementing Classes:<\/dt>\n+                    <dd><code><a href=\"Child.html\" title=\"class in pkg1\">Child<\/a><\/code><\/dd>\n+                    <\/dl>\"\"\");\n+\n+        checkOutput(\"pkg1\/Intf.html\", false,\n+                \"InvisibleParent\",\n+                \"invisibleDefaultMethod\",\n+                \"invisibleInterfaceMethod\");\n+\n+        checkOutput(\"pkg1\/Child.html\", true,\n+                \"\"\"\n+                    <a href=\"InvisibleParent.VisibleInner.html\" class=\"type-name-link\" title=\"class \\\n+                    in pkg1\">InvisibleParent.VisibleInner<\/a>\"\"\",\n+                \"\"\"\n+                    <a href=\"#visibleField\" class=\"member-name-link\">visibleField<\/a>\"\"\",\n+                \"\"\"\n+                    <a href=\"#invisibleInterfaceMethod()\" class=\"member-name-link\">invisibleInterfaceMethod<\/a>\"\"\",\n+                \"\"\"\n+                    <a href=\"#visibleInterfaceMethod()\" class=\"member-name-link\">visibleInterfaceMethod<\/a>\"\"\",\n+                \"\"\"\n+                    <a href=\"#visibleMethod(pkg1.InvisibleParent)\" class=\"member-name-link\">visibleMethod<\/a>\"\"\",\n+                \"\"\"\n+                    <a href=\"Intf.html#visibleDefaultMethod()\">visibleDefaultMethod<\/a>\"\"\",\n+                \/\/ Invisible return or parameter types must not be linked\n+                \"\"\"\n+                    <span class=\"return-type\">pkg1.InvisibleParent<\/span>\"\"\",\n+                \"\"\"\n+                    <span class=\"parameters\">(pkg1.InvisibleParent&lt;? extends pkg1.InvisibleParent&gt;&nbsp;p)<\/span>\"\"\");\n+\n+        checkOutput(\"pkg1\/Child.html\", false,\n+                \"InvisibleParent.InvisibleInner\",\n+                \"invisibleField\",\n+                \"invisibleMethod\",\n+                \"invisibleDefaultMethod\");\n+\n+        checkOutput(\"pkg1\/InvisibleParent.VisibleInner.html\", true,\n+                \"\"\"\n+                    <dt>Enclosing class:<\/dt>\n+                    <dd>pkg1.InvisibleParent&lt;T extends pkg1.InvisibleParent&gt;<\/dd>\n+                    <\/dl>\"\"\");\n+\n@@ -107,0 +153,2 @@\n+        checkOutput(\"pkg1\/package-tree.html\", false, \"InvisibleParent.html\");\n+\n@@ -109,1 +157,3 @@\n-                \"pkg1\/A.InvisibleInnerExtendsVisibleInner.html\");\n+                \"pkg1\/A.InvisibleInnerExtendsVisibleInner.html\",\n+                \"pkg1\/InvisibleParent.html\",\n+                \"pkg1\/InvisibleParent.InvisibleInner.html\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/TestHiddenTag.java","additions":58,"deletions":8,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/pkg1\/A.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg1;\n+\n+import pkg2.UndocumentedParent;\n+\n+\/**\n+ * A visible class, extending invisible classes.\n+ *\/\n+public class Child extends UndocumentedParent<Child> {\n+\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/pkg1\/Child.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg1;\n+\n+\/**\n+ * An visible interface\n+ *\/\n+public interface Intf {\n+\n+    \/**\n+     * A visible interface method.\n+     *\/\n+    void visibleInterfaceMethod();\n+\n+    \/**\n+     * An invisible interface method.\n+     * @hidden\n+     *\/\n+    void invisibleInterfaceMethod();\n+\n+    \/**\n+     * A visible default method.\n+     *\/\n+    default void visibleDefaultMethod() {}\n+\n+    \/**\n+     * An invisible default method.\n+     * @hidden\n+     *\/\n+    default void invisibleDefaultMethod() {}\n+\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/pkg1\/Intf.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg1;\n+\n+\/**\n+ * @hidden\n+ * @param <T>\n+ *\/\n+public abstract class InvisibleParent<T extends InvisibleParent> implements Intf {\n+\n+    @Override\n+    public void visibleInterfaceMethod() {}\n+\n+    \/**\n+     * An invisible method made visible in an implementing class.\n+     *\/\n+    @Override\n+    public void invisibleInterfaceMethod() {}\n+\n+    \/**\n+     * A visible inner class.\n+     *\/\n+    public static class VisibleInner {\n+        \/**\n+         * An invisible constructor\n+         * @hidden invisible\n+         *\/\n+        public VisibleInner() {}\n+    }\n+\n+    \/**\n+     * An invisible inner class.\n+     * @hidden\n+     *\/\n+    public static class InvisibleInner {}\n+\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/pkg1\/InvisibleParent.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg2;\n+\n+import pkg1.InvisibleParent;\n+\n+\/**\n+ * @hidden\n+ * @param <T>\n+ *\/\n+public class UndocumentedParent<T extends InvisibleParent> extends InvisibleParent<T> {\n+\n+    \/**\n+     * A visible field.\n+     *\/\n+    public InvisibleParent visibleField;\n+\n+    \/**\n+     * An invisible field.\n+     * @hidden\n+     *\/\n+    public InvisibleParent invisibleField;\n+\n+    \/**\n+     * A visible method with an invisible parameter type.\n+     *\/\n+    public void visibleMethod(InvisibleParent<? extends InvisibleParent> p)  {}\n+\n+    \/**\n+     * An invisible method.\n+     * @hidden\n+     *\/\n+    public void invisibleMethod() {}\n+\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/pkg2\/UndocumentedParent.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}