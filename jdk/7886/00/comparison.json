{"files":[{"patch":"@@ -1376,3 +1376,0 @@\n-    \/\/ Call Thread.exit(). We try 3 times in case we got another Thread.stop during\n-    \/\/ the execution of the method. If that is not enough, then we don't really care. Thread.stop\n-    \/\/ is deprecated anyhow.\n@@ -1380,12 +1377,15 @@\n-      int count = 3;\n-      while (java_lang_Thread::threadGroup(threadObj()) != NULL && (count-- > 0)) {\n-        EXCEPTION_MARK;\n-        JavaValue result(T_VOID);\n-        Klass* thread_klass = vmClasses::Thread_klass();\n-        JavaCalls::call_virtual(&result,\n-                                threadObj, thread_klass,\n-                                vmSymbols::exit_method_name(),\n-                                vmSymbols::void_method_signature(),\n-                                THREAD);\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n+      \/\/ We have finished executing user-defined Java code and now have to do the\n+      \/\/ implementation specific clean-up by calling Thread.exit(). We prevent any\n+      \/\/ further asynchronous exceptions from being delivered to ensure the clean-up\n+      \/\/ is not corrupted.\n+      NoAsyncExceptionDeliveryMark _no_async(this);\n+\n+      EXCEPTION_MARK;\n+      JavaValue result(T_VOID);\n+      Klass* thread_klass = vmClasses::Thread_klass();\n+      JavaCalls::call_virtual(&result,\n+                              threadObj, thread_klass,\n+                              vmSymbols::exit_method_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      CLEAR_PENDING_EXCEPTION;\n@@ -1393,0 +1393,1 @@\n+\n@@ -1595,1 +1596,1 @@\n-    \/\/ ok because the call we a returning from already collides\n+    \/\/ ok because the call we are returning from already collides\n@@ -1616,0 +1617,3 @@\n+    if ((_suspend_flags & _async_delivery_disabled) != 0) {\n+      log_info(exceptions)(\"Async exception delivery is disabled\");\n+    }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -788,3 +788,4 @@\n-    _has_async_exception    = 0x00000001U, \/\/ there is a pending async exception\n-    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n-    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n+    _has_async_exception     = 0x00000001U, \/\/ there is a pending async exception\n+    _async_delivery_disabled = 0x00000002U, \/\/ async exception delivery is disabled\n+    _trace_flag              = 0x00000004U, \/\/ call tracing backend\n+    _obj_deopt               = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n@@ -818,1 +819,2 @@\n-    return (_suspend_flags & _has_async_exception) != 0;\n+    return (_suspend_flags & _has_async_exception) != 0 &&\n+           (_suspend_flags & _async_delivery_disabled) == 0;\n@@ -826,0 +828,7 @@\n+  class NoAsyncExceptionDeliveryMark : public StackObj {\n+    friend JavaThread;\n+    JavaThread *_target;\n+    inline NoAsyncExceptionDeliveryMark(JavaThread *t);\n+    inline ~NoAsyncExceptionDeliveryMark();\n+  };\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -127,1 +127,3 @@\n-  clear_suspend_flag(_has_async_exception);\n+  if (ret) {\n+    clear_suspend_flag(_has_async_exception);\n+  }\n@@ -141,0 +143,9 @@\n+\n+inline JavaThread::NoAsyncExceptionDeliveryMark::NoAsyncExceptionDeliveryMark(JavaThread *t) : _target(t) {\n+  assert((_target->_suspend_flags & _async_delivery_disabled) == 0, \"Nesting is not supported\");\n+  _target->set_suspend_flag(_async_delivery_disabled);\n+}\n+inline JavaThread::NoAsyncExceptionDeliveryMark::~NoAsyncExceptionDeliveryMark() {\n+  _target->clear_suspend_flag(_async_delivery_disabled);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}