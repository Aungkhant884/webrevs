{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import java.io.EOFException;\n-import java.security.AllPermission;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -31,0 +33,2 @@\n+import java.security.AllPermission;\n+import java.security.CodeSource;\n@@ -32,1 +36,0 @@\n-import java.security.SecureClassLoader;\n@@ -34,12 +37,1 @@\n-import java.security.CodeSource;\n-import java.io.InputStream;\n-import java.io.BufferedInputStream;\n-import java.io.IOException;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.security.SecureClassLoader;\n@@ -99,157 +91,0 @@\n-    \/*\n-     * Discover the public methods on public classes\n-     * and interfaces accessible to any caller by calling\n-     * Class.getMethods() and walking towards Object until\n-     * we're done.\n-     *\/\n-     @SuppressWarnings(\"removal\")\n-     public static Method[] getPublicMethods(Class<?> cls) {\n-        \/\/ compatibility for update release\n-        if (System.getSecurityManager() == null) {\n-            return cls.getMethods();\n-        }\n-        Map<Signature, Method> sigs = new HashMap<Signature, Method>();\n-        while (cls != null) {\n-            boolean done = getInternalPublicMethods(cls, sigs);\n-            if (done) {\n-                break;\n-            }\n-            getInterfaceMethods(cls, sigs);\n-            cls = cls.getSuperclass();\n-        }\n-        return sigs.values().toArray(new Method[sigs.size()]);\n-    }\n-\n-    \/*\n-     * Process the immediate interfaces of this class or interface.\n-     *\/\n-    private static void getInterfaceMethods(Class<?> cls,\n-                                            Map<Signature, Method> sigs) {\n-        Class<?>[] intfs = cls.getInterfaces();\n-        for (int i=0; i < intfs.length; i++) {\n-            Class<?> intf = intfs[i];\n-            boolean done = getInternalPublicMethods(intf, sigs);\n-            if (!done) {\n-                getInterfaceMethods(intf, sigs);\n-            }\n-        }\n-    }\n-\n-    \/*\n-     *\n-     * Process the methods in this class or interface\n-     *\/\n-    private static boolean getInternalPublicMethods(Class<?> cls,\n-                                                    Map<Signature, Method> sigs) {\n-        Method[] methods = null;\n-        try {\n-            \/*\n-             * This class or interface is non-public so we\n-             * can't use any of it's methods. Go back and\n-             * try again with a superclass or superinterface.\n-             *\/\n-            if (!Modifier.isPublic(cls.getModifiers())) {\n-                return false;\n-            }\n-            if (!ReflectUtil.isPackageAccessible(cls)) {\n-                return false;\n-            }\n-\n-            methods = cls.getMethods();\n-        } catch (SecurityException se) {\n-            return false;\n-        }\n-\n-        \/*\n-         * Check for inherited methods with non-public\n-         * declaring classes. They might override and hide\n-         * methods from their superclasses or\n-         * superinterfaces.\n-         *\/\n-        boolean done = true;\n-        for (int i=0; i < methods.length; i++) {\n-            Class<?> dc = methods[i].getDeclaringClass();\n-            if (!Modifier.isPublic(dc.getModifiers())) {\n-                done = false;\n-                break;\n-            }\n-        }\n-\n-        if (done) {\n-            \/*\n-             * We're done. Spray all the methods into\n-             * the list and then we're out of here.\n-             *\/\n-            for (int i=0; i < methods.length; i++) {\n-                addMethod(sigs, methods[i]);\n-            }\n-        } else {\n-            \/*\n-             * Simulate cls.getDeclaredMethods() by\n-             * stripping away inherited methods.\n-             *\/\n-            for (int i=0; i < methods.length; i++) {\n-                Class<?> dc = methods[i].getDeclaringClass();\n-                if (cls.equals(dc)) {\n-                    addMethod(sigs, methods[i]);\n-                }\n-            }\n-        }\n-        return done;\n-    }\n-\n-    private static void addMethod(Map<Signature, Method> sigs, Method method) {\n-        Signature signature = new Signature(method);\n-        if (!sigs.containsKey(signature)) {\n-            sigs.put(signature, method);\n-        } else if (!method.getDeclaringClass().isInterface()){\n-            \/*\n-             * Superclasses beat interfaces.\n-             *\/\n-            Method old = sigs.get(signature);\n-            if (old.getDeclaringClass().isInterface()) {\n-                sigs.put(signature, method);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A class that represents the unique elements of a method that will be a\n-     * key in the method cache.\n-     *\/\n-    private static class Signature {\n-        private final String methodName;\n-        private final Class<?>[] argClasses;\n-        private final int hashCode;\n-\n-        Signature(Method m) {\n-            this.methodName = m.getName();\n-            this.argClasses = m.getParameterTypes();\n-            this.hashCode = methodName.hashCode() + Arrays.hashCode(argClasses);\n-        }\n-\n-        @Override public int hashCode() {\n-            return hashCode;\n-        }\n-\n-        @Override public boolean equals(Object o2) {\n-            if (this == o2) {\n-                return true;\n-            }\n-            Signature that = (Signature)o2;\n-            if (!(methodName.equals(that.methodName))) {\n-                return false;\n-            }\n-            if (argClasses.length != that.argClasses.length) {\n-                return false;\n-            }\n-            for (int i = 0; i < argClasses.length; i++) {\n-                if (!(argClasses[i] == that.argClasses[i])) {\n-                  return false;\n-                }\n-            }\n-            return true;\n-        }\n-    }\n-\n-\n@@ -361,2 +196,1 @@\n-    protected PermissionCollection getPermissions(CodeSource codesource)\n-    {\n+    protected PermissionCollection getPermissions(CodeSource codesource) {\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/MethodUtil.java","additions":9,"deletions":175,"binary":false,"changes":184,"status":"modified"}]}