{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -46,3 +45,1 @@\n-    @Stable\n-    private final MethodHandle[] handleMap = new MethodHandle[AccessMode.COUNT];\n-    private @Stable VarHandle directTarget; \/\/ cache, for performance reasons\n+    private final VarHandle directTarget; \/\/ cache, for performance reasons\n@@ -63,0 +60,1 @@\n+        this.directTarget = target.asDirect();\n@@ -74,5 +72,1 @@\n-        var directTarget = this.directTarget;\n-        if (directTarget != null)\n-            return directTarget.isAccessModeSupported(accessMode);\n-\n-        return target.isAccessModeSupported(accessMode);\n+        return directTarget.isAccessModeSupported(accessMode);\n@@ -83,5 +77,1 @@\n-        var directTarget = this.directTarget;\n-        if (directTarget != null)\n-            return directTarget;\n-\n-        return this.directTarget = target.asDirect(); \/\/ may be a lazy method\n+        return this.directTarget;\n@@ -91,6 +81,0 @@\n-    public VarHandle withInvokeExactBehavior() {\n-        return hasInvokeExactBehavior()\n-            ? this\n-            : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, true);\n-    }\n-\n@@ -104,0 +88,7 @@\n+    @Override\n+    public VarHandle withInvokeExactBehavior() {\n+        return hasInvokeExactBehavior()\n+            ? this\n+            : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, true);\n+    }\n+\n@@ -112,8 +103,3 @@\n-    @ForceInline\n-    MethodHandle getMethodHandle(int mode) {\n-        MethodHandle handle = handleMap[mode];\n-        if (handle == null) {\n-            MethodHandle targetHandle = target.getMethodHandle(mode); \/\/ might throw UOE of access mode is not supported, which is ok\n-            handle = handleMap[mode] = handleFactory.apply(AccessMode.values()[mode], targetHandle);\n-        }\n-        return handle;\n+    MethodHandle getMethodHandleUncached(int mode) {\n+        MethodHandle targetHandle = target.getMethodHandle(mode); \/\/ might throw UOE of access mode is not supported, which is ok\n+        return handleFactory.apply(AccessMode.values()[mode], targetHandle);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/IndirectVarHandle.java","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package java.lang.invoke;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Optional;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+import static java.lang.invoke.MethodHandleStatics.uncaughtException;\n+import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;\n+\n+\/**\n+ * A lazy initializing var handle. It lazily initializes the referenced class before\n+ * any invocation of the target var handle to prevent reading uninitialized static\n+ * final field values.\n+ *\/\n+final class LazyInitializingVarHandle extends VarHandle {\n+\n+    private final VarHandle target;\n+    private final Class<?> refc;\n+    private @Stable boolean initialized;\n+\n+    LazyInitializingVarHandle(VarHandle target, Class<?> refc) {\n+        super(target.vform, target.exact);\n+        this.target = target;\n+        this.refc = refc;\n+    }\n+\n+    @Override\n+    MethodType accessModeTypeUncached(AccessType at) {\n+        return target.accessModeTypeUncached(at);\n+    }\n+\n+    @Override\n+    VarHandle asDirect() {\n+        return target;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    boolean checkAccessModeThenIsDirect(AccessDescriptor ad) {\n+        super.checkAccessModeThenIsDirect(ad);\n+        return false;\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeExactBehavior() {\n+        var updatedDelegate = target.withInvokeExactBehavior();\n+        return initialized ? new LazyInitializingVarHandle(updatedDelegate, refc) : updatedDelegate;\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeBehavior() {\n+        var updatedDelegate = target.withInvokeBehavior();\n+        return initialized ? new LazyInitializingVarHandle(updatedDelegate, refc) : updatedDelegate;\n+    }\n+\n+    @Override\n+    public Optional<VarHandleDesc> describeConstable() {\n+        return target.describeConstable();\n+    }\n+\n+    private void ensureInitialized() {\n+        UNSAFE.ensureClassInitialized(refc);\n+        this.initialized = true;\n+    }\n+\n+    @Override\n+    public MethodHandle getMethodHandleUncached(int accessMode) {\n+        var callTarget = target.getMethodHandle(accessMode);\n+        if (initialized)\n+            return callTarget;\n+\n+        final class Holder {\n+            static final MethodHandle MH_ensureInitialized;\n+\n+            static {\n+                try {\n+                    MH_ensureInitialized = IMPL_LOOKUP.findVirtual(LazyInitializingVarHandle.class, \"ensureInitialized\",\n+                            MethodType.methodType(void.class));\n+                } catch (Throwable ex) {\n+                    throw uncaughtException(ex);\n+                }\n+            }\n+        }\n+\n+        return MethodHandles.collectArguments(callTarget, 0, Holder.MH_ensureInitialized)\n+                .bindTo(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LazyInitializingVarHandle.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -1,185 +0,0 @@\n-\/*\n- *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package java.lang.invoke;\n-\n-import jdk.internal.vm.annotation.Stable;\n-\n-import java.util.Optional;\n-\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n-import static java.lang.invoke.MethodHandleStatics.uncaughtException;\n-import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A lazy static field var handle. It lazily initializes the referenced class and the delegate\n- * static field var handle upon invocation. Its var form is that of the static field var handle.\n- *\/\n-final class LazyStaticVarHandle extends VarHandle {\n-\n-    private final Class<?> refc;\n-    private final MemberName field;\n-    private final Class<?> fieldType;\n-    private final boolean writeAllowedOnFinalFields;\n-    private @Stable VarHandle delegate;\n-    private final @Stable MethodHandle[] handleMap = new MethodHandle[AccessMode.COUNT];\n-\n-    private static VarForm findVarForm(MemberName field, boolean writeAllowedOnFinalFields) {\n-        Class<?> type = requireNonNull(field.getFieldType());\n-        boolean readOnly = field.isFinal() && !writeAllowedOnFinalFields;\n-        if (!type.isPrimitive()) {\n-            return readOnly ? VarHandleReferences.FieldStaticReadOnly.FORM : VarHandleReferences.FieldStaticReadWrite.FORM;\n-        }\n-        else if (type == boolean.class) {\n-            return readOnly ? VarHandleBooleans.FieldStaticReadOnly.FORM : VarHandleBooleans.FieldStaticReadWrite.FORM;\n-        }\n-        else if (type == byte.class) {\n-            return readOnly ? VarHandleBytes.FieldStaticReadOnly.FORM : VarHandleBytes.FieldStaticReadWrite.FORM;\n-        }\n-        else if (type == short.class) {\n-            return readOnly ? VarHandleShorts.FieldStaticReadOnly.FORM : VarHandleShorts.FieldStaticReadWrite.FORM;\n-        }\n-        else if (type == char.class) {\n-            return readOnly ? VarHandleChars.FieldStaticReadOnly.FORM : VarHandleChars.FieldStaticReadWrite.FORM;\n-        }\n-        else if (type == int.class) {\n-            return readOnly ? VarHandleInts.FieldStaticReadOnly.FORM : VarHandleInts.FieldStaticReadWrite.FORM;\n-        }\n-        else if (type == long.class) {\n-            return readOnly ? VarHandleLongs.FieldStaticReadOnly.FORM : VarHandleLongs.FieldStaticReadWrite.FORM;\n-        }\n-        else if (type == float.class) {\n-            return readOnly ? VarHandleFloats.FieldStaticReadOnly.FORM : VarHandleFloats.FieldStaticReadWrite.FORM;\n-        }\n-        else if (type == double.class) {\n-            return readOnly ? VarHandleDoubles.FieldStaticReadOnly.FORM : VarHandleDoubles.FieldStaticReadWrite.FORM;\n-        }\n-        else {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    LazyStaticVarHandle(Class<?> refc, MemberName field, boolean writeAllowedOnFinalFields, boolean exact) {\n-        super(findVarForm(field, writeAllowedOnFinalFields), exact);\n-        this.refc = refc;\n-        this.field = field;\n-        this.fieldType = requireNonNull(field.getFieldType());\n-        this.writeAllowedOnFinalFields = writeAllowedOnFinalFields;\n-    }\n-\n-    @Override\n-    VarHandle asDirect() {\n-        return delegate();\n-    }\n-\n-    @Override\n-    boolean checkAccessModeThenIsDirect(AccessDescriptor ad) {\n-        super.checkAccessModeThenIsDirect(ad);\n-        return false;\n-    }\n-\n-    private VarHandle delegate() {\n-        var delegate = this.delegate;\n-        if (delegate != null)\n-            return delegate;\n-\n-        synchronized (this) {\n-            delegate = this.delegate;\n-            if (delegate != null)\n-                return delegate;\n-\n-            UNSAFE.ensureClassInitialized(refc);\n-            Object base = MethodHandleNatives.staticFieldBase(field);\n-            long offset = MethodHandleNatives.staticFieldOffset(field);\n-            return this.delegate = VarHandles.makeInitializedStaticFieldVarHandle(field, refc, base, offset, writeAllowedOnFinalFields);\n-        }\n-    }\n-\n-    @Override\n-    public VarHandle withInvokeExactBehavior() {\n-        var delegate = this.delegate;\n-        return delegate == null ? (hasInvokeExactBehavior() ? this\n-                : new LazyStaticVarHandle(refc, field, writeAllowedOnFinalFields, true))\n-                : delegate.withInvokeExactBehavior();\n-    }\n-\n-    @Override\n-    public VarHandle withInvokeBehavior() {\n-        var delegate = this.delegate;\n-        return delegate == null ? (!hasInvokeExactBehavior() ? this\n-                : new LazyStaticVarHandle(refc, field, writeAllowedOnFinalFields, false))\n-                : delegate.withInvokeBehavior();\n-    }\n-\n-    @Override\n-    MethodType accessModeTypeUncached(AccessType at) {\n-        return at.accessModeType(null, fieldType);\n-    }\n-\n-    @Override\n-    public Optional<VarHandleDesc> describeConstable() {\n-        var receiverTypeRef = field.getDeclaringClass().describeConstable();\n-        var fieldTypeRef = fieldType.describeConstable();\n-        if (!receiverTypeRef.isPresent() || !fieldTypeRef.isPresent())\n-            return Optional.empty();\n-\n-        String name = field.getName();\n-        return Optional.of(VarHandleDesc.ofStaticField(receiverTypeRef.get(), name, fieldTypeRef.get()));\n-    }\n-\n-    \/\/ Note: getMethodHandle() result anticipates a static field var handle, instead of\n-    \/\/ this lazy var handle, as its first argument\n-\n-    @Override\n-    public MethodHandle toMethodHandle(AccessMode accessMode) {\n-        var delegate = this.delegate;\n-        if (delegate != null)\n-            return delegate.toMethodHandle(accessMode);\n-\n-        class Holder {\n-            static final MethodHandle MH_delegate;\n-\n-            static {\n-                try {\n-                    MH_delegate = IMPL_LOOKUP.findVirtual(LazyStaticVarHandle.class, \"delegate\",\n-                            MethodType.methodType(VarHandle.class));\n-                } catch (Throwable ex) {\n-                    throw uncaughtException(ex);\n-                }\n-            }\n-        }\n-\n-        \/\/ not yet initialized, filter with delegate() call\n-        var mh = handleMap[accessMode.ordinal()];\n-        if (mh == null) {\n-            return handleMap[accessMode.ordinal()] = MethodHandles.\n-                    filterArgument(getMethodHandle(accessMode.ordinal()), 0, Holder.MH_delegate).bindTo(this);\n-        }\n-\n-        return mh;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LazyStaticVarHandle.java","additions":0,"deletions":185,"binary":false,"changes":185,"status":"deleted"},{"patch":"@@ -475,1 +475,1 @@\n-     permits IndirectVarHandle, LazyStaticVarHandle,\n+     permits IndirectVarHandle, LazyInitializingVarHandle,\n@@ -522,4 +522,0 @@\n-    RuntimeException unsupported() {\n-        return new UnsupportedOperationException();\n-    }\n-\n@@ -2184,5 +2180,0 @@\n-    \/**\n-     * Returns a method handle that can invoke the {@linkplain #asDirect() direct}\n-     * var handle of this var handle with the given access mode. Argument or\n-     * return value filtering should be done by the returned method handle.\n-     *\/\n@@ -2190,1 +2181,1 @@\n-    MethodHandle getMethodHandle(int mode) {\n+    final MethodHandle getMethodHandle(int mode) {\n@@ -2202,1 +2193,9 @@\n-    private final MethodHandle getMethodHandleUncached(int mode) {\n+    \/**\n+     * Computes a method handle that can be passed the {@linkplain #asDirect() direct}\n+     * var handle of this var handle with the given access mode. Pre\/postprocessing\n+     * such as argument or return value filtering should be done by the returned\n+     * method handle.\n+     *\n+     * @throws UnsupportedOperationException if the access mode is not supported\n+     *\/\n+    MethodHandle getMethodHandleUncached(int mode) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -110,8 +110,4 @@\n-            if (UNSAFE.shouldBeInitialized(refc)) {\n-                return new LazyStaticVarHandle(refc, f, isWriteAllowedOnFinalFields, false);\n-            }\n-\n-            Class<?> decl = f.getDeclaringClass();\n-            Object base = MethodHandleNatives.staticFieldBase(f);\n-            long foffset = MethodHandleNatives.staticFieldOffset(f);\n-            return makeInitializedStaticFieldVarHandle(f, decl, base, foffset, isWriteAllowedOnFinalFields);\n+            var vh = makeStaticFieldVarHandle(f, isWriteAllowedOnFinalFields);\n+            return maybeAdapt(UNSAFE.shouldBeInitialized(refc)\n+                    ? new LazyInitializingVarHandle(vh, refc)\n+                    : vh);\n@@ -121,1 +117,4 @@\n-    static VarHandle makeInitializedStaticFieldVarHandle(MemberName f, Class<?> decl, Object base, long foffset, boolean isWriteAllowedOnFinalFields) {\n+    static VarHandle makeStaticFieldVarHandle(MemberName f, boolean isWriteAllowedOnFinalFields) {\n+        Class<?> decl = f.getDeclaringClass();\n+        Object base = MethodHandleNatives.staticFieldBase(f);\n+        long foffset = MethodHandleNatives.staticFieldOffset(f);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"}]}