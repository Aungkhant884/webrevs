{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.util.List;\n@@ -49,1 +48,1 @@\n-    private final VarHandle directTarget; \/\/ cache, for performance reasons\n+    private @Stable VarHandle directTarget; \/\/ cache, for performance reasons\n@@ -64,1 +63,0 @@\n-        this.directTarget = target.asDirect();\n@@ -70,2 +68,2 @@\n-    public Class<?> varType() {\n-        return value;\n+    MethodType accessModeTypeUncached(AccessType at) {\n+        return at.accessModeType(null, value, coordinates);\n@@ -75,3 +73,4 @@\n-    public List<Class<?>> coordinateTypes() {\n-        return List.of(coordinates);\n-    }\n+    public boolean isAccessModeSupported(AccessMode accessMode) {\n+        var directTarget = this.directTarget;\n+        if (directTarget != null)\n+            return directTarget.isAccessModeSupported(accessMode);\n@@ -79,3 +78,1 @@\n-    @Override\n-    MethodType accessModeTypeUncached(AccessType at) {\n-        return at.accessModeType(null, value, coordinates);\n+        return target.isAccessModeSupported(accessMode);\n@@ -86,2 +83,3 @@\n-        return directTarget;\n-    }\n+        var directTarget = this.directTarget;\n+        if (directTarget != null)\n+            return directTarget;\n@@ -89,2 +87,1 @@\n-    VarHandle target() {\n-        return target;\n+        return this.directTarget = target.asDirect(); \/\/ may be a lazy method\n@@ -124,5 +121,0 @@\n-\n-    @Override\n-    public MethodHandle toMethodHandle(AccessMode accessMode) {\n-        return getMethodHandle(accessMode.ordinal()).bindTo(directTarget);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/IndirectVarHandle.java","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package java.lang.invoke;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Optional;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+import static java.lang.invoke.MethodHandleStatics.uncaughtException;\n+import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A lazy static field var handle. It lazily initializes the referenced class and the delegate\n+ * static field var handle upon invocation. Its var form is that of the static field var handle.\n+ *\/\n+final class LazyStaticVarHandle extends VarHandle {\n+\n+    private final Class<?> refc;\n+    private final MemberName field;\n+    private final Class<?> fieldType;\n+    private final boolean writeAllowedOnFinalFields;\n+    private @Stable VarHandle delegate;\n+    private final @Stable MethodHandle[] handleMap = new MethodHandle[AccessMode.COUNT];\n+\n+    private static VarForm findVarForm(MemberName field, boolean writeAllowedOnFinalFields) {\n+        Class<?> type = requireNonNull(field.getFieldType());\n+        boolean readOnly = field.isFinal() && !writeAllowedOnFinalFields;\n+        if (!type.isPrimitive()) {\n+            return readOnly ? VarHandleReferences.FieldStaticReadOnly.FORM : VarHandleReferences.FieldStaticReadWrite.FORM;\n+        }\n+        else if (type == boolean.class) {\n+            return readOnly ? VarHandleBooleans.FieldStaticReadOnly.FORM : VarHandleBooleans.FieldStaticReadWrite.FORM;\n+        }\n+        else if (type == byte.class) {\n+            return readOnly ? VarHandleBytes.FieldStaticReadOnly.FORM : VarHandleBytes.FieldStaticReadWrite.FORM;\n+        }\n+        else if (type == short.class) {\n+            return readOnly ? VarHandleShorts.FieldStaticReadOnly.FORM : VarHandleShorts.FieldStaticReadWrite.FORM;\n+        }\n+        else if (type == char.class) {\n+            return readOnly ? VarHandleChars.FieldStaticReadOnly.FORM : VarHandleChars.FieldStaticReadWrite.FORM;\n+        }\n+        else if (type == int.class) {\n+            return readOnly ? VarHandleInts.FieldStaticReadOnly.FORM : VarHandleInts.FieldStaticReadWrite.FORM;\n+        }\n+        else if (type == long.class) {\n+            return readOnly ? VarHandleLongs.FieldStaticReadOnly.FORM : VarHandleLongs.FieldStaticReadWrite.FORM;\n+        }\n+        else if (type == float.class) {\n+            return readOnly ? VarHandleFloats.FieldStaticReadOnly.FORM : VarHandleFloats.FieldStaticReadWrite.FORM;\n+        }\n+        else if (type == double.class) {\n+            return readOnly ? VarHandleDoubles.FieldStaticReadOnly.FORM : VarHandleDoubles.FieldStaticReadWrite.FORM;\n+        }\n+        else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    LazyStaticVarHandle(Class<?> refc, MemberName field, boolean writeAllowedOnFinalFields, boolean exact) {\n+        super(findVarForm(field, writeAllowedOnFinalFields), exact);\n+        this.refc = refc;\n+        this.field = field;\n+        this.fieldType = requireNonNull(field.getFieldType());\n+        this.writeAllowedOnFinalFields = writeAllowedOnFinalFields;\n+    }\n+\n+    @Override\n+    VarHandle asDirect() {\n+        return delegate();\n+    }\n+\n+    @Override\n+    boolean checkAccessModeThenIsDirect(AccessDescriptor ad) {\n+        super.checkAccessModeThenIsDirect(ad);\n+        return false;\n+    }\n+\n+    private VarHandle delegate() {\n+        var delegate = this.delegate;\n+        if (delegate != null)\n+            return delegate;\n+\n+        synchronized (this) {\n+            delegate = this.delegate;\n+            if (delegate != null)\n+                return delegate;\n+\n+            UNSAFE.ensureClassInitialized(refc);\n+            Object base = MethodHandleNatives.staticFieldBase(field);\n+            long offset = MethodHandleNatives.staticFieldOffset(field);\n+            return this.delegate = VarHandles.makeInitializedStaticFieldVarHandle(field, refc, base, offset, writeAllowedOnFinalFields);\n+        }\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeExactBehavior() {\n+        var delegate = this.delegate;\n+        return delegate == null ? (hasInvokeExactBehavior() ? this\n+                : new LazyStaticVarHandle(refc, field, writeAllowedOnFinalFields, false))\n+                : delegate.withInvokeExactBehavior();\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeBehavior() {\n+        var delegate = this.delegate;\n+        return delegate == null ? (!hasInvokeExactBehavior() ? this\n+                : new LazyStaticVarHandle(refc, field, writeAllowedOnFinalFields, true))\n+                : delegate.withInvokeBehavior();\n+    }\n+\n+    @Override\n+    MethodType accessModeTypeUncached(AccessType at) {\n+        return at.accessModeType(null, fieldType);\n+    }\n+\n+    @Override\n+    public Optional<VarHandleDesc> describeConstable() {\n+        var receiverTypeRef = field.getDeclaringClass().describeConstable();\n+        var fieldTypeRef = fieldType.describeConstable();\n+        if (!receiverTypeRef.isPresent() || !fieldTypeRef.isPresent())\n+            return Optional.empty();\n+\n+        String name = field.getName();\n+        return Optional.of(VarHandleDesc.ofStaticField(receiverTypeRef.get(), name, fieldTypeRef.get()));\n+    }\n+\n+    \/\/ Note: getMethodHandle() result anticipates a static field var handle, instead of\n+    \/\/ this lazy var handle, as its first argument\n+\n+    @Override\n+    public MethodHandle toMethodHandle(AccessMode accessMode) {\n+        var delegate = this.delegate;\n+        if (delegate != null)\n+            return delegate.toMethodHandle(accessMode);\n+\n+        class Holder {\n+            static final MethodHandle MH_delegate;\n+\n+            static {\n+                try {\n+                    MH_delegate = IMPL_LOOKUP.findVirtual(LazyStaticVarHandle.class, \"delegate\",\n+                            MethodType.methodType(VarHandle.class));\n+                } catch (Throwable ex) {\n+                    throw uncaughtException(ex);\n+                }\n+            }\n+        }\n+\n+        \/\/ not yet initialized, filter with delegate() call\n+        var mh = handleMap[accessMode.ordinal()];\n+        if (mh == null) {\n+            return handleMap[accessMode.ordinal()] = MethodHandles.\n+                    filterArgument(getMethodHandle(accessMode.ordinal()), 0, Holder.MH_delegate).bindTo(this);\n+        }\n+\n+        return mh;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LazyStaticVarHandle.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -4196,1 +4196,1 @@\n-            return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),\n+            return VarHandles.makeFieldHandle(getField, refc,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -475,1 +475,2 @@\n-     permits IndirectVarHandle, VarHandleSegmentViewBase,\n+     permits IndirectVarHandle, LazyStaticVarHandle,\n+             VarHandleSegmentViewBase,\n@@ -525,0 +526,6 @@\n+    \/**\n+     * The backing var handle for indirect var handles. The var handle guards invokes\n+     * with getMethodHandle on asDirect result.\n+     * @see #getMethodHandle(int)\n+     * @see #checkAccessModeThenIsDirect(AccessDescriptor)\n+     *\/\n@@ -529,2 +536,0 @@\n-    VarHandle target() { return null; }\n-\n@@ -2074,0 +2079,1 @@\n+     * @see #asDirect()\n@@ -2123,1 +2129,1 @@\n-    public final boolean isAccessModeSupported(AccessMode accessMode) {\n+    public boolean isAccessModeSupported(AccessMode accessMode) {\n@@ -2149,1 +2155,1 @@\n-            return mh.bindTo(this);\n+            return mh.bindTo(asDirect());\n@@ -2178,0 +2184,5 @@\n+    \/**\n+     * Returns a method handle that can invoke the {@linkplain #asDirect() direct}\n+     * var handle of this var handle with the given access mode. Argument or\n+     * return value filtering should be done by the returned method handle.\n+     *\/\n@@ -2406,1 +2417,1 @@\n-                case FIELD        -> lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                case FIELD        -> lookup.findVarHandle(declaringClass.resolveConstantDesc(lookup),\n@@ -2408,2 +2419,2 @@\n-                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n-                case STATIC_FIELD -> lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          varType.resolveConstantDesc(lookup));\n+                case STATIC_FIELD -> lookup.findStaticVarHandle(declaringClass.resolveConstantDesc(lookup),\n@@ -2411,2 +2422,2 @@\n-                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n-                case ARRAY        -> MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n+                                                          varType.resolveConstantDesc(lookup));\n+                case ARRAY        -> MethodHandles.arrayElementVarHandle(declaringClass.resolveConstantDesc(lookup));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    static VarHandle makeFieldHandle(MemberName f, Class<?> refc, Class<?> type, boolean isWriteAllowedOnFinalFields) {\n+    static VarHandle makeFieldHandle(MemberName f, Class<?> refc, boolean isWriteAllowedOnFinalFields) {\n@@ -59,0 +59,1 @@\n+            Class<?> type = f.getFieldType();\n@@ -109,8 +110,3 @@\n-            \/\/ TODO This is not lazy on first invocation\n-            \/\/ and might cause some circular initialization issues\n-\n-            \/\/ Replace with something similar to direct method handles\n-            \/\/ where a barrier is used then elided after use\n-\n-            if (UNSAFE.shouldBeInitialized(refc))\n-                UNSAFE.ensureClassInitialized(refc);\n+            if (UNSAFE.shouldBeInitialized(refc)) {\n+                return new LazyStaticVarHandle(refc, f, isWriteAllowedOnFinalFields, false);\n+            }\n@@ -121,48 +117,53 @@\n-            if (!type.isPrimitive()) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n-                       : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type));\n-            }\n-            else if (type == boolean.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleBooleans.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleBooleans.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == byte.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleBytes.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleBytes.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == short.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleShorts.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleShorts.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == char.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleChars.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleChars.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == int.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleInts.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleInts.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == long.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleLongs.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleLongs.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == float.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleFloats.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleFloats.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == double.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleDoubles.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleDoubles.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else {\n-                throw new UnsupportedOperationException();\n-            }\n+            return makeInitializedStaticFieldVarHandle(f, decl, base, foffset, isWriteAllowedOnFinalFields);\n+        }\n+    }\n+\n+    static VarHandle makeInitializedStaticFieldVarHandle(MemberName f, Class<?> decl, Object base, long foffset, boolean isWriteAllowedOnFinalFields) {\n+        Class<?> type = f.getFieldType();\n+        if (!type.isPrimitive()) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n+                    : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type));\n+        }\n+        else if (type == boolean.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleBooleans.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleBooleans.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == byte.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleBytes.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleBytes.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == short.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleShorts.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleShorts.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == char.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleChars.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleChars.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == int.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleInts.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleInts.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == long.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleLongs.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleLongs.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == float.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleFloats.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleFloats.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == double.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleDoubles.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleDoubles.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else {\n+            throw new UnsupportedOperationException();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":58,"deletions":57,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8291065\n+ * @summary Ensures creation of static field VarHandle does not trigger\n+ *          class initialization.\n+ * @run main LazyStaticTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class LazyStaticTest {\n+    static Set<Class<?>> initialized = ConcurrentHashMap.newKeySet();\n+\n+    public static void main(String... args) throws Throwable {\n+        assert initialized.isEmpty() : \"Incorrect initial state\";\n+\n+        class Sample1 {\n+            static int apple;\n+\n+            static {\n+                initialized.add(Sample1.class);\n+                apple = 5;\n+            }\n+        }\n+\n+        var lookup = MethodHandles.lookup();\n+        var sample1AppleVh = lookup.findStaticVarHandle(Sample1.class, \"apple\", int.class);\n+\n+        assert !initialized.contains(Sample1.class) : \"Sample1 class initialized on VarHandle creation\";\n+\n+        sample1AppleVh.set(42);\n+\n+        assert initialized.contains(Sample1.class) : \"Sample1 class initialized after VarHandle use\";\n+        assert Sample1.apple == 42 : \"The value is not set correctly to Sample1.apple\";\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/LazyStaticTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,3 @@\n-        assertTrue(re.isInstance(_e), String.format(\"%sIncorrect throwable thrown, %s. Expected %s\", message, _e, re));\n+        if (!re.isInstance(_e)) {\n+            fail(String.format(\"%sIncorrect throwable thrown, %s. Expected %s\", message, _e, re), _e);\n+        }\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleBaseTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import jdk.internal.classfile.Classfile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+\n+\/**\n+ * A benchmark ensuring that var and method handle lazy initialization are not\n+ * too slow compared to eager initialization.\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 10, warmups = 5, jvmArgsAppend = {\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\"\n+})\n+public class LazyStaticColdStart {\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    private Class<?> targetClass;\n+\n+    \/**\n+     * Ensures non-initialized targetClass is used and initializes the lazy\/non-lazy handles\n+     * to prevent further creation costs.\n+     *\/\n+    @Setup(Level.Iteration)\n+    public void setup() throws Throwable {\n+        class Holder {\n+            static final ClassDesc describedClass = LazyStaticColdStart.class.describeConstable().orElseThrow().nested(\"Data\");\n+            static final ClassDesc CD_ThreadLocalRandom = ThreadLocalRandom.class.describeConstable().orElseThrow();\n+            static final ClassDesc CD_Blackhole = Blackhole.class.describeConstable().orElseThrow();\n+            static final MethodTypeDesc MTD_void_long = MethodTypeDesc.of(CD_void, CD_long);\n+            static final MethodTypeDesc MTD_ThreadLocalRandom = MethodTypeDesc.of(CD_ThreadLocalRandom);\n+            static final MethodTypeDesc MTD_long = MethodTypeDesc.of(CD_long);\n+            static final byte[] classBytes = Classfile.build(describedClass, clb -> {\n+                clb.withField(\"v\", CD_long, ACC_STATIC);\n+                clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                    cob.constantInstruction(100L);\n+                    cob.invokestatic(CD_Blackhole, \"consumeCPU\", MTD_void_long);\n+                    cob.invokestatic(CD_ThreadLocalRandom, \"current\", MTD_ThreadLocalRandom);\n+                    cob.invokevirtual(CD_ThreadLocalRandom, \"nextLong\", MTD_long);\n+                    cob.putstatic(describedClass, \"v\", CD_long);\n+                    cob.return_();\n+                });\n+            });\n+\n+            static {\n+                class AnotherLazy {\n+                    static long f;\n+                }\n+                try {\n+                    LOOKUP.findStaticVarHandle(AnotherLazy.class, \"f\", long.class);\n+                    LOOKUP.findStaticGetter(AnotherLazy.class, \"f\", long.class);\n+                    AnotherLazy.f = 5L; \/\/ initialize class\n+                    LOOKUP.findStaticVarHandle(AnotherLazy.class, \"f\", long.class);\n+                    LOOKUP.findStaticGetter(AnotherLazy.class, \"f\", long.class);\n+                } catch (RuntimeException | Error e) {\n+                    throw e;\n+                } catch (Throwable ex) {\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n+            }\n+        }\n+        targetClass = LOOKUP.defineHiddenClass(Holder.classBytes, false).lookupClass();\n+    }\n+\n+    @Benchmark\n+    public VarHandle varHandleCreateLazy() throws Throwable {\n+        return LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public VarHandle varHandleCreateEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public long varHandleInitializeCallLazy() throws Throwable {\n+        return (long) LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class).get();\n+    }\n+\n+    @Benchmark\n+    public long varHandleInitializeCallEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return (long) LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class).get();\n+    }\n+\n+    @Benchmark\n+    public MethodHandle methodHandleCreateLazy() throws Throwable {\n+        return LOOKUP.findStaticGetter(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public MethodHandle methodHandleCreateEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return LOOKUP.findStaticGetter(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public long methodHandleInitializeCallLazy() throws Throwable {\n+        return (long) LOOKUP.findStaticGetter(targetClass, \"v\", long.class).invokeExact();\n+    }\n+\n+    @Benchmark\n+    public long methodHandleInitializeCallEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return (long) LOOKUP.findStaticGetter(targetClass, \"v\", long.class).invokeExact();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/LazyStaticColdStart.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * A benchmark testing lazy static var handle vs regular static var handle,\n+ * to ensure the lazy static var handle doesn't have too much post-initialization\n+ * invocation penalties.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(3)\n+public class VarHandleLazyStaticInvocation {\n+\n+    static final VarHandle initialized;\n+    static final VarHandle lazy;\n+    static long longField;\n+\n+    static {\n+        try {\n+            lazy = MethodHandles.lookup().findStaticVarHandle(Data.class, \"longField\", long.class);\n+            initialized = MethodHandles.lookup().findStaticVarHandle(VarHandleLazyStaticInvocation.class, \"longField\", long.class);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    static class Data {\n+        static long longField;\n+    }\n+\n+    @Benchmark\n+    public long lazyInvocation() {\n+        lazy.set((long) ThreadLocalRandom.current().nextLong());\n+        return (long) lazy.get();\n+    }\n+\n+    @Benchmark\n+    public long initializedInvocation() {\n+        initialized.set((long) ThreadLocalRandom.current().nextLong());\n+        return (long) initialized.get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/VarHandleLazyStaticInvocation.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}