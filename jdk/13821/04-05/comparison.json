{"files":[{"patch":"@@ -74,0 +74,2 @@\n+        if (!initialized && hasInvokeExactBehavior())\n+            return this;\n@@ -75,1 +77,1 @@\n-        return initialized ? new LazyInitializingVarHandle(updatedDelegate, refc) : updatedDelegate;\n+        return initialized ? updatedDelegate : new LazyInitializingVarHandle(updatedDelegate, refc);\n@@ -80,0 +82,2 @@\n+        if (!initialized && !hasInvokeExactBehavior())\n+            return this;\n@@ -81,1 +85,1 @@\n-        return initialized ? new LazyInitializingVarHandle(updatedDelegate, refc) : updatedDelegate;\n+        return initialized ? updatedDelegate : new LazyInitializingVarHandle(updatedDelegate, refc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LazyInitializingVarHandle.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -110,3 +110,4 @@\n-            var vh = makeStaticFieldVarHandle(f, isWriteAllowedOnFinalFields);\n-            return maybeAdapt(UNSAFE.shouldBeInitialized(refc)\n-                    ? new LazyInitializingVarHandle(vh, refc)\n+            Class<?> decl = f.getDeclaringClass();\n+            var vh = makeStaticFieldVarHandle(decl, f, isWriteAllowedOnFinalFields);\n+            return maybeAdapt(UNSAFE.shouldBeInitialized(decl)\n+                    ? new LazyInitializingVarHandle(vh, decl)\n@@ -117,2 +118,1 @@\n-    static VarHandle makeStaticFieldVarHandle(MemberName f, boolean isWriteAllowedOnFinalFields) {\n-        Class<?> decl = f.getDeclaringClass();\n+    static VarHandle makeStaticFieldVarHandle(Class<?> decl, MemberName f, boolean isWriteAllowedOnFinalFields) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @summary Ensures creation of static field VarHandle does not trigger\n- *          class initialization.\n+ * @summary Checks interaction of static field VarHandle with class\n+ *          initialization mechanism..\n@@ -39,2 +39,8 @@\n-    public static void main(String... args) throws Throwable {\n-        assert initialized.isEmpty() : \"Incorrect initial state\";\n+    static class SimpleSample {\n+        static int apple;\n+\n+        static {\n+            initialized.add(SimpleSample.class);\n+            apple = 5;\n+        }\n+    }\n@@ -42,2 +48,2 @@\n-        class Sample1 {\n-            static int apple;\n+    static class ParentSample {\n+        static int pear;\n@@ -45,4 +51,3 @@\n-            static {\n-                initialized.add(Sample1.class);\n-                apple = 5;\n-            }\n+        static {\n+            initialized.add(ParentSample.class);\n+            pear = 3;\n@@ -50,0 +55,11 @@\n+    }\n+\n+    static class ChildSample extends ParentSample {\n+        static {\n+            initialized.add(ChildSample.class);\n+            pear = 6;\n+        }\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        assert initialized.isEmpty() : \"Incorrect initial state\";\n@@ -52,1 +68,0 @@\n-        var sample1AppleVh = lookup.findStaticVarHandle(Sample1.class, \"apple\", int.class);\n@@ -54,1 +69,19 @@\n-        assert !initialized.contains(Sample1.class) : \"Sample1 class initialized on VarHandle creation\";\n+        \/\/ SimpleSample: a regular test case\n+        var simpleSampleAppleVh = lookup.findStaticVarHandle(SimpleSample.class, \"apple\", int.class);\n+\n+        assert !initialized.contains(SimpleSample.class) : \"SimpleSample class initialized on VH creation\";\n+\n+        assert (int) simpleSampleAppleVh.get() == 5 : \"VarHandle incorrectly reads before initialization\";\n+\n+        assert initialized.contains(SimpleSample.class) : \"SimpleSample class not initialized after VH use\";\n+\n+        simpleSampleAppleVh.set(42);\n+        assert SimpleSample.apple == 42 : \"The value is not set correctly to SimpleSample.apple\";\n+        assert (int) simpleSampleAppleVh.getAcquire() == 42\n+                : \"The SimpleSample.apple value is not read correctly from the VH after a few uses\";\n+\n+        \/\/ ChildSample: ensure only ParentSample (field declarer) is initialized\n+        var childSamplePearVh = lookup.findStaticVarHandle(ChildSample.class, \"pear\", int.class);\n+\n+        assert !initialized.contains(ParentSample.class) : \"ParentSample class initialized on VH creation\";\n+        assert !initialized.contains(ChildSample.class) : \"ChildSample class initialized on VH creation\";\n@@ -56,1 +89,1 @@\n-        sample1AppleVh.set(42);\n+        assert (int) childSamplePearVh.get() == 3 : \"ParentSample not correctly initialized before first VH use\";\n@@ -58,2 +91,2 @@\n-        assert initialized.contains(Sample1.class) : \"Sample1 class initialized after VarHandle use\";\n-        assert Sample1.apple == 42 : \"The value is not set correctly to Sample1.apple\";\n+        assert initialized.contains(ParentSample.class) : \"ParentSample class not initialized after VH use\";\n+        assert !initialized.contains(ChildSample.class) : \"ChildSample class initialized after unrelated VH use\";\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/LazyStaticTest.java","additions":48,"deletions":15,"binary":false,"changes":63,"status":"modified"}]}