{"files":[{"patch":"@@ -60,1 +60,1 @@\n-        this.directTarget = target.asDirect();\n+        this.directTarget = target.target();\n@@ -71,2 +71,3 @@\n-    VarHandle asDirect() {\n-        return directTarget;\n+    @ForceInline\n+    VarHandle target() {\n+        return this.directTarget;\n@@ -85,2 +86,2 @@\n-                ? this\n-                : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, false);\n+            ? this\n+            : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, false);\n@@ -89,0 +90,1 @@\n+    @Override\n@@ -106,5 +108,0 @@\n-\n-    @Override\n-    public MethodHandle toMethodHandle(AccessMode accessMode) {\n-        return getMethodHandle(accessMode.ordinal()).bindTo(directTarget);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/IndirectVarHandle.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-        return handle.asDirect();\n+        return handle.target();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package java.lang.invoke;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Optional;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+import static java.lang.invoke.MethodHandleStatics.uncaughtException;\n+import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;\n+\n+\/**\n+ * A lazy initializing var handle. It lazily initializes the referenced class before\n+ * any invocation of the target var handle to prevent reading uninitialized static\n+ * final field values.\n+ *\/\n+final class LazyInitializingVarHandle extends VarHandle {\n+\n+    private final VarHandle target;\n+    private final Class<?> refc;\n+    private @Stable boolean initialized;\n+\n+    LazyInitializingVarHandle(VarHandle target, Class<?> refc) {\n+        super(target.vform, target.exact);\n+        this.target = target;\n+        this.refc = refc;\n+    }\n+\n+    @Override\n+    boolean checkAccessModeThenIsDirect(AccessDescriptor ad) {\n+        super.checkAccessModeThenIsDirect(ad);\n+        return false;\n+    }\n+\n+    @Override\n+    MethodType accessModeTypeUncached(AccessType at) {\n+        return target.accessModeType(at.ordinal());\n+    }\n+\n+    @Override\n+    @ForceInline\n+    VarHandle target() {\n+        return target;\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeExactBehavior() {\n+        if (!initialized && hasInvokeExactBehavior())\n+            return this;\n+        var exactTarget = target.withInvokeExactBehavior();\n+        return initialized ? exactTarget : new LazyInitializingVarHandle(exactTarget, refc);\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeBehavior() {\n+        if (!initialized && !hasInvokeExactBehavior())\n+            return this;\n+        var nonExactTarget = target.withInvokeBehavior();\n+        return initialized ? nonExactTarget : new LazyInitializingVarHandle(nonExactTarget, refc);\n+    }\n+\n+    @Override\n+    public Optional<VarHandleDesc> describeConstable() {\n+        return target.describeConstable();\n+    }\n+\n+    @Override\n+    public MethodHandle getMethodHandleUncached(int accessMode) {\n+        ensureInitialized();\n+        return target.getMethodHandle(accessMode);\n+    }\n+\n+    @ForceInline\n+    private void ensureInitialized() {\n+        if (this.initialized)\n+            return;\n+\n+        initialize();\n+    }\n+\n+    private void initialize() {\n+        UNSAFE.ensureClassInitialized(refc);\n+        this.initialized = true;\n+\n+        this.methodHandleTable = target.methodHandleTable;\n+    }\n+\n+    private static @Stable MethodHandle MH_ensureInitialized;\n+\n+    private static MethodHandle ensureInitializedMh() {\n+        var mh = MH_ensureInitialized;\n+        if (mh != null)\n+            return mh;\n+\n+        try {\n+            return MH_ensureInitialized = IMPL_LOOKUP.findVirtual(LazyInitializingVarHandle.class,\n+                    \"ensureInitialized\",\n+                    MethodType.methodType(void.class));\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+    }\n+\n+    \/\/ regular impl uses getMethodHandle which we avoid, for our getMethodHandle\n+    \/\/ serves as an initialization barrier\n+    @Override\n+    public MethodHandle toMethodHandle(AccessMode accessMode) {\n+        var mh = target.toMethodHandle(accessMode);\n+        if (initialized)\n+            return mh;\n+\n+        \/\/ Add barrier\n+        return MethodHandles.collectArguments(mh, 0, ensureInitializedMh()).bindTo(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LazyInitializingVarHandle.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -4204,1 +4204,1 @@\n-            return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),\n+            return VarHandles.makeFieldHandle(getField, refc,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -475,1 +475,2 @@\n-     permits IndirectVarHandle, VarHandleSegmentViewBase,\n+     permits IndirectVarHandle, LazyInitializingVarHandle,\n+             VarHandleSegmentViewBase,\n@@ -521,5 +522,11 @@\n-    RuntimeException unsupported() {\n-        return new UnsupportedOperationException();\n-    }\n-\n-    VarHandle asDirect() {\n+    \/**\n+     * The VarHandle to be passed to {@link #getMethodHandle}, in Invokers\n+     * LambdaForms and VarHandleGuards.\n+     * Direct VH implementation methods also call this method to\n+     * unwrap lazy initializing VarHandles.\n+     *\n+     * @see #getMethodHandle(int)\n+     * @see #checkAccessModeThenIsDirect(AccessDescriptor)\n+     *\/\n+    @ForceInline\n+    VarHandle target() {\n@@ -2065,2 +2072,2 @@\n-     * the access mode of this VarHandle, then returns if this is a direct\n-     * method handle. These operations were grouped together to slightly\n+     * the access mode of this VarHandle, then returns if this is direct.\n+     * These operations were grouped together to slightly\n@@ -2069,0 +2076,5 @@\n+     * A direct VarHandle's VarForm has implementation MemberNames that can\n+     * be linked directly. If a VarHandle is indirect, it must override\n+     * {@link #isAccessModeSupported} and {@link #getMethodHandleUncached}\n+     * which access MemberNames..\n+     *\n@@ -2072,0 +2084,1 @@\n+     * @see #target()\n@@ -2147,1 +2160,1 @@\n-            return mh.bindTo(this);\n+            return mh.bindTo(target());\n@@ -2189,0 +2202,8 @@\n+    \/**\n+     * Computes a method handle that can be passed the {@linkplain #target() direct}\n+     * var handle of this var handle with the given access mode. Pre\/postprocessing\n+     * such as argument or return value filtering should be done by the returned\n+     * method handle.\n+     *\n+     * @throws UnsupportedOperationException if the access mode is not supported\n+     *\/\n@@ -2404,1 +2425,1 @@\n-                case FIELD        -> lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                case FIELD        -> lookup.findVarHandle(declaringClass.resolveConstantDesc(lookup),\n@@ -2406,2 +2427,2 @@\n-                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n-                case STATIC_FIELD -> lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          varType.resolveConstantDesc(lookup));\n+                case STATIC_FIELD -> lookup.findStaticVarHandle(declaringClass.resolveConstantDesc(lookup),\n@@ -2409,2 +2430,2 @@\n-                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n-                case ARRAY        -> MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n+                                                          varType.resolveConstantDesc(lookup));\n+                case ARRAY        -> MethodHandles.arrayElementVarHandle(declaringClass.resolveConstantDesc(lookup));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -43,1 +44,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -58,1 +59,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -71,1 +72,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -85,1 +86,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -99,1 +100,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -112,1 +113,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -127,1 +128,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -140,1 +141,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -153,1 +154,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -166,1 +167,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -179,1 +180,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -194,1 +195,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -207,1 +208,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -220,1 +221,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -233,1 +234,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -246,1 +247,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -261,1 +262,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -274,1 +275,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -287,1 +288,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -300,1 +301,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -313,1 +314,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -328,1 +329,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -341,1 +342,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -354,1 +355,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -367,1 +368,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -381,1 +382,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target());\n@@ -396,1 +397,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -409,1 +410,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -422,1 +423,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target());\n@@ -437,1 +438,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -450,1 +451,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -463,1 +464,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -476,1 +477,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -489,1 +490,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target());\n@@ -504,1 +505,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -517,1 +518,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -530,1 +531,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -543,1 +544,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -556,1 +557,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target());\n@@ -571,1 +572,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -584,1 +585,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -597,1 +598,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -610,1 +611,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -623,1 +624,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target());\n@@ -638,1 +639,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -651,1 +652,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -664,1 +665,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -677,1 +678,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0);\n@@ -691,1 +692,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -706,1 +707,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -719,1 +720,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -733,1 +734,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -747,1 +748,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -762,1 +763,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -775,1 +776,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -788,1 +789,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -801,1 +802,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -816,1 +817,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -829,1 +830,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -842,1 +843,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -855,1 +856,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -868,1 +869,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -883,1 +884,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -896,1 +897,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -909,1 +910,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -922,1 +923,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -935,1 +936,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -950,1 +951,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -963,1 +964,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -976,1 +977,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -989,1 +990,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -1002,1 +1003,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1);\n@@ -1017,1 +1018,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -1030,1 +1031,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -1043,1 +1044,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -1056,1 +1057,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -1071,1 +1072,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2);\n@@ -1084,1 +1085,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n@@ -1097,1 +1098,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.target(), arg0, arg1, arg2, arg3);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":81,"deletions":80,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    static VarHandle makeFieldHandle(MemberName f, Class<?> refc, Class<?> type, boolean isWriteAllowedOnFinalFields) {\n+    static VarHandle makeFieldHandle(MemberName f, Class<?> refc, boolean isWriteAllowedOnFinalFields) {\n@@ -59,0 +59,1 @@\n+            Class<?> type = f.getFieldType();\n@@ -109,9 +110,0 @@\n-            \/\/ TODO This is not lazy on first invocation\n-            \/\/ and might cause some circular initialization issues\n-\n-            \/\/ Replace with something similar to direct method handles\n-            \/\/ where a barrier is used then elided after use\n-\n-            if (UNSAFE.shouldBeInitialized(refc))\n-                UNSAFE.ensureClassInitialized(refc);\n-\n@@ -119,50 +111,58 @@\n-            Object base = MethodHandleNatives.staticFieldBase(f);\n-            long foffset = MethodHandleNatives.staticFieldOffset(f);\n-            if (!type.isPrimitive()) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n-                       : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type));\n-            }\n-            else if (type == boolean.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleBooleans.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleBooleans.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == byte.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleBytes.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleBytes.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == short.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleShorts.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleShorts.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == char.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleChars.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleChars.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == int.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleInts.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleInts.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == long.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleLongs.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleLongs.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == float.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleFloats.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleFloats.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == double.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleDoubles.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleDoubles.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else {\n-                throw new UnsupportedOperationException();\n-            }\n+            var vh = makeStaticFieldVarHandle(decl, f, isWriteAllowedOnFinalFields);\n+            return maybeAdapt(UNSAFE.shouldBeInitialized(decl)\n+                    ? new LazyInitializingVarHandle(vh, decl)\n+                    : vh);\n+        }\n+    }\n+\n+    static VarHandle makeStaticFieldVarHandle(Class<?> decl, MemberName f, boolean isWriteAllowedOnFinalFields) {\n+        Object base = MethodHandleNatives.staticFieldBase(f);\n+        long foffset = MethodHandleNatives.staticFieldOffset(f);\n+        Class<?> type = f.getFieldType();\n+        if (!type.isPrimitive()) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n+                    : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type));\n+        }\n+        else if (type == boolean.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleBooleans.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleBooleans.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == byte.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleBytes.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleBytes.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == short.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleShorts.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleShorts.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == char.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleChars.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleChars.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == int.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleInts.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleInts.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == long.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleLongs.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleLongs.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == float.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleFloats.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleFloats.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == double.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleDoubles.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleDoubles.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else {\n+            throw new UnsupportedOperationException();\n@@ -844,1 +844,1 @@\n-\/\/                    collect(joining(\", \"));\n+\/\/                    collect(Collectors.joining(\", \"));\n@@ -854,2 +854,1 @@\n-\/\/            List<String> LINK_TO_STATIC_ARGS = params.keySet().stream().\n-\/\/                    collect(toList());\n+\/\/            List<String> LINK_TO_STATIC_ARGS = new ArrayList<>(params.keySet());\n@@ -858,3 +857,2 @@\n-\/\/            List<String> LINK_TO_INVOKER_ARGS = params.keySet().stream().\n-\/\/                    collect(toList());\n-\/\/            LINK_TO_INVOKER_ARGS.set(0, LINK_TO_INVOKER_ARGS.get(0) + \".asDirect()\");\n+\/\/            List<String> LINK_TO_INVOKER_ARGS = new ArrayList<>(params.keySet());\n+\/\/            LINK_TO_INVOKER_ARGS.set(0, LINK_TO_INVOKER_ARGS.get(0) + \".target()\");\n@@ -888,1 +886,1 @@\n-\/\/                            collect(joining(\", \"))).\n+\/\/                            collect(Collectors.joining(\", \"))).\n@@ -890,1 +888,1 @@\n-\/\/                            collect(joining(\", \")))\n+\/\/                            collect(Collectors.joining(\", \")))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":66,"deletions":68,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8291065\n+ * @summary Checks interaction of static field VarHandle with class\n+ *          initialization mechanism..\n+ * @run junit LazyInitializingTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.Objects;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class LazyInitializingTest {\n+\n+    record SampleData(Runnable callback, int initialValue) {\n+        private static final Runnable FAIL_ON_CLINIT_CALLBACK = () -> {\n+            throw new AssertionError(\"Class shouldn't be initialized\");\n+        };\n+        static final SampleData FAIL_ON_CLINIT = new SampleData();\n+\n+        SampleData() {\n+            this(FAIL_ON_CLINIT_CALLBACK, 0);\n+        }\n+    }\n+    record ClassInfo(MethodHandles.Lookup definingLookup, VarHandle vh) {}\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    @Test\n+    public void testMeta() throws IllegalAccessException {\n+        boolean[] val = new boolean[1];\n+        var v0 = createSampleClass(new SampleData(() -> val[0] = true, 0));\n+        assertFalse(val[0], \"callback run before class init\");\n+        v0.definingLookup.ensureInitialized(v0.definingLookup.lookupClass());\n+        assertTrue(val[0], \"callback not run at class init\");\n+    }\n+\n+    @Test\n+    public void testUninitializedOperations() {\n+        var ci = createSampleClass(SampleData.FAIL_ON_CLINIT);\n+        var vh = ci.vh;\n+        vh.describeConstable();\n+        vh.isAccessModeSupported(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE);\n+        vh.withInvokeExactBehavior();\n+        vh.withInvokeBehavior();\n+        vh.toMethodHandle(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE);\n+        vh.hasInvokeExactBehavior();\n+        vh.accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE);\n+    }\n+\n+    @Test\n+    public void testInitializationOnVarHandleUse() {\n+        var initialized = new boolean[1];\n+        var ci = createSampleClass(new SampleData(() -> initialized[0] = true, 42));\n+        var vh = ci.vh;\n+\n+        assertEquals(42, vh.get(), \"VH does not read value set in class initializer\");\n+        assertTrue(initialized[0], \"class initialization not captured\");\n+    }\n+\n+    @Test\n+    public void testParentChildLoading() throws Throwable {\n+        \/\/ ChildSample: ensure only ParentSample (field declarer) is initialized\n+        var l = new ParentChildLoader();\n+        var childSampleClass = l.childClass();\n+        var lookup = MethodHandles.privateLookupIn(childSampleClass, LOOKUP);\n+        var childVh = lookup.findStaticVarHandle(childSampleClass, \"f\", int.class);\n+\n+        assertEquals(3, (int) childVh.get(), \"Child class initialized unnecessarily\");\n+\n+        lookup.ensureInitialized(childSampleClass);\n+\n+        assertEquals(6, (int) childVh.get(), \"Child class was not initialized\");\n+    }\n+\n+    static ClassInfo createSampleClass(SampleData sampleData) {\n+        try {\n+            var lookup = LOOKUP.defineHiddenClassWithClassData(sampleClassBytes(), sampleData, false);\n+            var vh = lookup.findStaticVarHandle(lookup.lookupClass(), \"f\", int.class);\n+            return new ClassInfo(lookup, vh);\n+        } catch (IllegalAccessException | NoSuchFieldException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    private static byte[] sampleClassBytes;\n+\n+    private static byte[] sampleClassBytes() {\n+        var bytes = sampleClassBytes;\n+        if (bytes != null)\n+            return bytes;\n+\n+        try (var in = LazyInitializingTest.class.getResourceAsStream(\"LazyInitializingSample.class\")) {\n+            if (in == null)\n+                throw new AssertionError(\"class file not found\");\n+            return sampleClassBytes = in.readAllBytes();\n+        } catch (IOException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+}\n+\n+\/\/ This is used as a template class, whose bytes are used to define\n+\/\/ hidden classes instead\n+class LazyInitializingSample {\n+    static int f;\n+\n+    static {\n+        try {\n+            var data = MethodHandles.classData(MethodHandles.lookup(), ConstantDescs.DEFAULT_NAME,\n+                    LazyInitializingTest.SampleData.class);\n+            Objects.requireNonNull(data);\n+\n+            data.callback().run();\n+            f = data.initialValue();\n+        } catch (IllegalAccessException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+}\n+\n+class ParentChildLoader extends ClassLoader {\n+    ParentChildLoader() {\n+        super(LazyInitializingTest.class.getClassLoader().getParent());\n+    }\n+\n+    Class<?> parentClass() {\n+        try {\n+            return loadClass(\"ParentSample\");\n+        } catch (ClassNotFoundException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    Class<?> childClass() {\n+        try {\n+            return loadClass(\"ChildSample\");\n+        } catch (ClassNotFoundException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+        try (var stream = switch (name) {\n+            case \"ParentSample\", \"ChildSample\" -> LazyInitializingTest.class.getResourceAsStream(name + \".class\");\n+            default -> throw new ClassNotFoundException(name);\n+        }) {\n+            if (stream == null)\n+                throw new AssertionError();\n+            var b = stream.readAllBytes();\n+            return defineClass(name, b, 0, b.length);\n+        } catch (IOException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+}\n+\n+class ParentSample {\n+    static int f;\n+\n+    static {\n+        f = 3;\n+    }\n+}\n+\n+class ChildSample extends ParentSample {\n+    static {\n+        f = 6;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/LazyInitializingTest.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,3 @@\n-        assertTrue(re.isInstance(_e), String.format(\"%sIncorrect throwable thrown, %s. Expected %s\", message, _e, re));\n+        if (!re.isInstance(_e)) {\n+            fail(String.format(\"%sIncorrect throwable thrown, %s. Expected %s\", message, _e, re), _e);\n+        }\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleBaseTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import jdk.internal.classfile.Classfile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+\n+\/**\n+ * A benchmark ensuring that var and method handle lazy initialization are not\n+ * too slow compared to eager initialization.\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 10, warmups = 5, jvmArgsAppend = {\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\"\n+})\n+public class LazyStaticColdStart {\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    private Class<?> targetClass;\n+\n+    \/**\n+     * Ensures non-initialized targetClass is used and initializes the lazy\/non-lazy handles\n+     * to prevent further creation costs.\n+     *\/\n+    @Setup(Level.Iteration)\n+    public void setup() throws Throwable {\n+        class Holder {\n+            static final ClassDesc describedClass = LazyStaticColdStart.class.describeConstable().orElseThrow().nested(\"Data\");\n+            static final ClassDesc CD_ThreadLocalRandom = ThreadLocalRandom.class.describeConstable().orElseThrow();\n+            static final ClassDesc CD_Blackhole = Blackhole.class.describeConstable().orElseThrow();\n+            static final MethodTypeDesc MTD_void_long = MethodTypeDesc.of(CD_void, CD_long);\n+            static final MethodTypeDesc MTD_ThreadLocalRandom = MethodTypeDesc.of(CD_ThreadLocalRandom);\n+            static final MethodTypeDesc MTD_long = MethodTypeDesc.of(CD_long);\n+            static final byte[] classBytes = Classfile.build(describedClass, clb -> {\n+                clb.withField(\"v\", CD_long, ACC_STATIC);\n+                clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                    cob.constantInstruction(100L);\n+                    cob.invokestatic(CD_Blackhole, \"consumeCPU\", MTD_void_long);\n+                    cob.invokestatic(CD_ThreadLocalRandom, \"current\", MTD_ThreadLocalRandom);\n+                    cob.invokevirtual(CD_ThreadLocalRandom, \"nextLong\", MTD_long);\n+                    cob.putstatic(describedClass, \"v\", CD_long);\n+                    cob.return_();\n+                });\n+            });\n+\n+            static {\n+                class AnotherLazy {\n+                    static long f;\n+                }\n+                try {\n+                    LOOKUP.findStaticVarHandle(AnotherLazy.class, \"f\", long.class);\n+                    LOOKUP.findStaticGetter(AnotherLazy.class, \"f\", long.class);\n+                    AnotherLazy.f = 5L; \/\/ initialize class\n+                    LOOKUP.findStaticVarHandle(AnotherLazy.class, \"f\", long.class);\n+                    LOOKUP.findStaticGetter(AnotherLazy.class, \"f\", long.class);\n+                } catch (RuntimeException | Error e) {\n+                    throw e;\n+                } catch (Throwable ex) {\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n+            }\n+        }\n+        targetClass = LOOKUP.defineHiddenClass(Holder.classBytes, false).lookupClass();\n+    }\n+\n+    @Benchmark\n+    public VarHandle varHandleCreateLazy() throws Throwable {\n+        return LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public VarHandle varHandleCreateEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public long varHandleInitializeCallLazy() throws Throwable {\n+        return (long) LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class).get();\n+    }\n+\n+    @Benchmark\n+    public long varHandleInitializeCallEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return (long) LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class).get();\n+    }\n+\n+    @Benchmark\n+    public MethodHandle methodHandleCreateLazy() throws Throwable {\n+        return LOOKUP.findStaticGetter(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public MethodHandle methodHandleCreateEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return LOOKUP.findStaticGetter(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public long methodHandleInitializeCallLazy() throws Throwable {\n+        return (long) LOOKUP.findStaticGetter(targetClass, \"v\", long.class).invokeExact();\n+    }\n+\n+    @Benchmark\n+    public long methodHandleInitializeCallEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return (long) LOOKUP.findStaticGetter(targetClass, \"v\", long.class).invokeExact();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/LazyStaticColdStart.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * A benchmark testing lazy static var handle vs regular static var handle,\n+ * to ensure the lazy static var handle doesn't have too much post-initialization\n+ * invocation penalties.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(3)\n+public class VarHandleLazyStaticInvocation {\n+\n+    static final VarHandle initialized;\n+    static final VarHandle lazy;\n+    static long longField;\n+\n+    static {\n+        try {\n+            lazy = MethodHandles.lookup().findStaticVarHandle(Data.class, \"longField\", long.class);\n+            initialized = MethodHandles.lookup().findStaticVarHandle(VarHandleLazyStaticInvocation.class, \"longField\", long.class);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    static class Data {\n+        static long longField;\n+    }\n+\n+    @Benchmark\n+    public long lazyInvocation() {\n+        lazy.set((long) ThreadLocalRandom.current().nextLong());\n+        return (long) lazy.get();\n+    }\n+\n+    @Benchmark\n+    public long initializedInvocation() {\n+        initialized.set((long) ThreadLocalRandom.current().nextLong());\n+        return (long) initialized.get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/VarHandleLazyStaticInvocation.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}