{"files":[{"patch":"@@ -3855,1 +3855,1 @@\n-               \/*release*\/ true, \/*weak*\/ false, noreg); \/\/ Sets flags for result\n+               \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n@@ -3864,0 +3864,11 @@\n+    __ br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n+\n+    __ cmp(rscratch1, rthread);\n+    __ br(Assembler::NE, cont); \/\/ Check for recursive locking\n+\n+    \/\/ Recursive lock case\n+    __ ldr(tmp, Address(disp_hdr, ObjectMonitor::recursions_offset_in_bytes() - markWord::monitor_value));\n+    __ add(tmp, tmp, 1u);\n+    __ str(tmp, Address(disp_hdr, ObjectMonitor::recursions_offset_in_bytes() - markWord::monitor_value));\n+    \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n+\n@@ -3907,3 +3918,3 @@\n-    __ eor(rscratch1, rscratch1, rthread); \/\/ Will be 0 if we are the owner.\n-    __ orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if there are 0 recursions\n-    __ cmp(rscratch1, zr); \/\/ Sets flags for result\n+\n+    Label notRecursive;\n+    __ cmp(rscratch1, rthread);\n@@ -3912,0 +3923,10 @@\n+    __ cmp(disp_hdr, (u1)0);\n+    __ br(Assembler::EQ, notRecursive);\n+\n+    \/\/ Recursive lock\n+    __ sub(disp_hdr, disp_hdr, 1u);\n+    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n+    __ cmp(rthread, rthread); \/\/ Reset flag == EQ for success;\n+    __ b(cont);\n+\n+    __ bind(notRecursive);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -577,1 +577,0 @@\n-  \/\/ Intentional fall-through into DONE_LABEL ...\n@@ -579,0 +578,6 @@\n+  jcc(Assembler::equal, DONE_LABEL);           \/\/ CAS above succeeded; propagate ZF = 1 (success)\n+\n+  cmpptr(r15_thread, rax);                     \/\/ Check if we are already the owner (recursive lock)\n+  jcc(Assembler::notEqual, DONE_LABEL);        \/\/ If not recursive, ZF = 0 at this point (fail)\n+  incq(Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  xorq(rax, rax); \/\/ Set ZF = 1 (success) for recursive lock, denoting locking success\n@@ -673,4 +678,0 @@\n-  \/\/ I'd like to add more cases in fast_lock() and fast_unlock() --\n-  \/\/ such as recursive enter and exit -- but we have to be wary of\n-  \/\/ I$ bloat, T$ effects and BP$ effects.\n-  \/\/\n@@ -724,3 +725,10 @@\n-  xorptr(boxReg, boxReg);\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  jccb  (Assembler::notZero, DONE_LABEL);\n+  Label LNotRecursive, LSuccess, LGoSlowPath;\n+\n+  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 0);\n+  jccb(Assembler::equal, LNotRecursive);\n+\n+  \/\/ Recursive inflated unlock\n+  decq(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  jmpb(LSuccess);\n+\n+  bind(LNotRecursive);\n@@ -735,1 +743,0 @@\n-  Label LSuccess, LGoSlowPath ;\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"}]}