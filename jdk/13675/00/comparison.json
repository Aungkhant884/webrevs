{"files":[{"patch":"@@ -1586,3 +1586,1 @@\n-    if (method != nullptr) {\n-      f(method);\n-    }\n+    f(method);\n@@ -1592,1 +1590,1 @@\n-    MutexLocker ml(InvokeMethodIntrinsicTable_lock);\n+    MutexLocker ml(InvokeMethodTable_lock);\n@@ -1944,7 +1942,0 @@\n-  InvokeMethodKey key(signature, iid_as_int);\n-  Method** met = nullptr;\n-\n-  \/\/ We only want one entry in the table for this (signature\/id, method) pair but the code\n-  \/\/ to create the intrinsic method needs to be outside the lock.\n-  \/\/ The first thread claims the entry by adding the key and the other threads wait, until the\n-  \/\/ Method has been added as the value.\n@@ -1952,11 +1943,5 @@\n-    MonitorLocker ml(THREAD, InvokeMethodIntrinsicTable_lock);\n-    while (met == nullptr) {\n-      bool created;\n-      met = _invoke_method_intrinsic_table.put_if_absent(key, &created);\n-      if (met != nullptr && *met != nullptr) {\n-        return *met;\n-      } else if (!created) {\n-        \/\/ Second thread waits for first to actually create the entry and returns\n-        \/\/ it after notify. Loop until method return is non-null.\n-        ml.wait();\n-      }\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    InvokeMethodKey key(signature, iid_as_int);\n+    Method** met = _invoke_method_intrinsic_table.get(key);\n+    if (met != nullptr) {\n+      return *met;\n@@ -1964,1 +1949,0 @@\n-  }\n@@ -1966,9 +1950,11 @@\n-  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, THREAD);\n-  bool throw_error = HAS_PENDING_EXCEPTION;\n-  if (!throw_error && (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative)) {\n-    \/\/ Generate a compiled form of the MH intrinsic\n-    \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n-    AdapterHandlerLibrary::create_native_wrapper(m);\n-    \/\/ Check if have the compiled code.\n-    throw_error = (!m->has_compiled_code());\n-  }\n+    bool throw_error = false;\n+    \/\/ This function could get an OOM but it is safe to call inside of a lock because\n+    \/\/ throwing OutOfMemoryError doesn't call Java code.\n+    methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n+    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n+        \/\/ Generate a compiled form of the MH intrinsic\n+        \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n+        AdapterHandlerLibrary::create_native_wrapper(m);\n+        \/\/ Check if have the compiled code.\n+        throw_error = (!m->has_compiled_code());\n+    }\n@@ -1976,8 +1962,1 @@\n-  {\n-    MonitorLocker ml(THREAD, InvokeMethodIntrinsicTable_lock);\n-    if (throw_error) {\n-      \/\/ Remove the entry and let another thread try, or get the same exception.\n-      bool removed = _invoke_method_intrinsic_table.remove(key);\n-      assert(removed, \"must be the owner\");\n-      ml.notify_all();\n-    } else {\n+    if (!throw_error) {\n@@ -1985,0 +1964,2 @@\n+      bool created = _invoke_method_intrinsic_table.put(key, m());\n+      assert(created, \"must be since we still hold the lock\");\n@@ -1988,2 +1969,0 @@\n-      *met = m(); \/\/ insert the element\n-      ml.notify_all();\n@@ -1994,6 +1973,3 @@\n-  \/\/ Throw VirtualMachineError or the pending exception in the JavaThread\n-  if (throw_error && !HAS_PENDING_EXCEPTION) {\n-    THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n-                   \"Out of space in CodeCache for method handle intrinsic\");\n-  }\n-  return nullptr;\n+  \/\/ Throw error outside of the lock.\n+  THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+                 \"Out of space in CodeCache for method handle intrinsic\");\n@@ -2142,1 +2118,1 @@\n-    MutexLocker ml(THREAD, InvokeMethodTypeTable_lock);\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n@@ -2211,1 +2187,1 @@\n-    MutexLocker ml(THREAD, InvokeMethodTypeTable_lock);\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":26,"deletions":50,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n-Mutex*   InvokeMethodTypeTable_lock   = nullptr;\n-Monitor* InvokeMethodIntrinsicTable_lock = nullptr;\n+Mutex*   InvokeMethodTable_lock       = nullptr;\n@@ -258,3 +257,1 @@\n-  MUTEX_DEFN(InvokeMethodTypeTable_lock      , PaddedMutex  , safepoint);\n-  MUTEX_DEFN(InvokeMethodIntrinsicTable_lock , PaddedMonitor, safepoint);\n-  MUTEX_DEFN(AdapterHandlerLibrary_lock      , PaddedMutex  , safepoint);\n+  MUTEX_DEFN(InvokeMethodTable_lock          , PaddedMutex  , safepoint);\n@@ -350,0 +347,1 @@\n+  MUTEX_DEFL(AdapterHandlerLibrary_lock     , PaddedMutex  , InvokeMethodTable_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-extern Mutex*   InvokeMethodTypeTable_lock;\n-extern Monitor* InvokeMethodIntrinsicTable_lock;\n+extern Mutex*   InvokeMethodTable_lock;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}