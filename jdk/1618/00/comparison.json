{"files":[{"patch":"@@ -648,1 +648,1 @@\n-          if (align_to_ref_p.invar() != p2.invar()) {\n+          if (!align_to_ref_p.invar_equals(p2)) {\n@@ -3529,0 +3529,5 @@\n+    Node* invar_scale = align_to_ref_p.invar_scale();\n+    if (invar_scale != NULL) {\n+      invar = new LShiftINode(invar, invar_scale);\n+      _igvn.register_new_node_with_optimizer(invar);\n+    }\n@@ -3714,0 +3719,1 @@\n+  _invar_scale(NULL),\n@@ -3782,0 +3788,1 @@\n+  _invar_scale(NULL),\n@@ -3899,1 +3906,1 @@\n-  } else if (opc == Op_LShiftL) {\n+  } else if (opc == Op_LShiftL && n->in(2)->is_Con()) {\n@@ -3909,7 +3916,7 @@\n-        if (tmp._invar == NULL || _slp->do_vector_loop()) {\n-          int mult = 1 << n->in(2)->get_int();\n-          _scale   = tmp._scale  * mult;\n-          _offset += tmp._offset * mult;\n-          _invar = tmp._invar;\n-          NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, mult);)\n-          return true;\n+        int scale = n->in(2)->get_int();\n+        _scale   = tmp._scale  << scale;\n+        _offset += tmp._offset << scale;\n+        _invar = tmp._invar;\n+        if (_invar != NULL) {\n+          _negate_invar = tmp._negate_invar;\n+          _invar_scale = n->in(2);\n@@ -3917,0 +3924,2 @@\n+        NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, _invar, _negate_invar);)\n+        return true;\n@@ -4015,1 +4024,1 @@\n-  tty->print(\"base: %d  adr: %d  scale: %d  offset: %d  invar: %c%d\\n\",\n+  tty->print(\"base: [%d]  adr: [%d]  scale: %d  offset: %d\",\n@@ -4018,3 +4027,5 @@\n-             _scale, _offset,\n-             _negate_invar?'-':'+',\n-             _invar != NULL ? _invar->_idx : 0);\n+             _scale, _offset);\n+  if (_invar != NULL) {\n+    tty->print(\"  invar: %c[%d] << [%d]\", _negate_invar?'-':'+', _invar->_idx, _invar_scale->_idx);\n+  }\n+  tty->cr();\n@@ -4208,1 +4219,1 @@\n-void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int _offset, int mult) {\n+void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int offset, Node* invar, bool negate_invar) {\n@@ -4210,3 +4221,6 @@\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d\", n->_idx, scale, _offset);\n-    print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset, in(2) %d used to get mult = %d: _scale = %d, _offset = %d\",\n-    n->in(1)->_idx, n->in(2)->_idx, mult, scale, _offset);\n+    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d\", n->_idx, scale, offset);\n+    print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: in(1) [%d] is scaled_iv_plus_offset, in(2) [%d] used to scale: _scale = %d, _offset = %d\",\n+    n->in(1)->_idx, n->in(2)->_idx, scale, offset);\n+    if (invar != NULL) {\n+      print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: scaled invariant: %c[%d]\", (negate_invar?'-':'+'), invar->_idx);\n+    }\n@@ -4216,0 +4230,3 @@\n+    if (invar != NULL) {\n+      print_depth(); invar->dump();\n+    }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -582,2 +582,3 @@\n-  jint  _scale;              \/\/ multiplier for iv (in bytes), 0 if no loop iv\n-  jint  _offset;             \/\/ constant offset (in bytes)\n+  int   _scale;              \/\/ multiplier for iv (in bytes), 0 if no loop iv\n+  int   _offset;             \/\/ constant offset (in bytes)\n+\n@@ -586,0 +587,2 @@\n+  Node* _invar_scale;        \/\/ multiplier for invariant\n+\n@@ -627,0 +630,1 @@\n+  Node* invar_scale()      { return _invar_scale; }\n@@ -632,0 +636,6 @@\n+  bool invar_equals(SWPointer& q) {\n+      return (_invar        == q._invar   &&\n+              _invar_scale  == q._invar_scale &&\n+              _negate_invar == q._negate_invar);\n+  }\n+\n@@ -635,3 +645,1 @@\n-        _scale == q._scale   &&\n-        _invar == q._invar   &&\n-        _negate_invar == q._negate_invar) {\n+        _scale == q._scale   && invar_equals(q)) {\n@@ -707,1 +715,1 @@\n-    void scaled_iv_9(Node* n, int _scale, int _offset, int mult);\n+    void scaled_iv_9(Node* n, int _scale, int _offset, Node* _invar, bool _negate_invar);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8257531\n+ * @summary Test vectorization for Buffer operations.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled & vm.debug == true\n+ * @run main compiler.vectorization.TestBufferVectorization array\n+ * @run main compiler.vectorization.TestBufferVectorization arrayOffset\n+ * @run main compiler.vectorization.TestBufferVectorization buffer\n+ * @run main compiler.vectorization.TestBufferVectorization bufferHeap\n+ * @run main compiler.vectorization.TestBufferVectorization bufferDirect\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.IntBuffer;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestBufferVectorization {\n+    final static int N = 500;\n+    final static int ITER = 1000;\n+    final static IntBuffer buffer = IntBuffer.allocate(N);\n+    final static int offset = buffer.arrayOffset();\n+    final static IntBuffer heap_buffer_byte_to_int = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+    final static IntBuffer direct_buffer_byte_to_int = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+\n+    interface Test {\n+        void init();\n+        void run();\n+        void verify();\n+    }\n+\n+    static class TestArray implements Test {\n+        final int[] array = new int[N];\n+\n+        public void init() {\n+            for (int k = 0; k < array.length; k++) {\n+                array[k] = k;\n+            }\n+        }\n+\n+        public void run() {\n+            for(int k = 0; k < array.length; k++) {\n+                array[k] += 1;\n+            }\n+        }\n+\n+        public void verify() {\n+            init(); \/\/ reset\n+            run();  \/\/ run compiled code\n+            for(int k = 0; k < array.length; k++) {\n+                if (array[k] != (k + 1)) {\n+                    throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n+                }\n+            }\n+        }\n+    }\n+\n+    static class TestArrayOffset implements Test {\n+        final int offset;\n+        final int[] array = new int[N];\n+\n+        public TestArrayOffset(int off) {\n+            offset = off;\n+        }\n+\n+        public void init() {\n+            for (int k = 0; k < array.length; k++) {\n+                array[k] = k;\n+            }\n+        }\n+\n+        public void run() {\n+            int l = array.length - offset;\n+            for(int k = 0; k < l; k++) {\n+                array[k + offset] += 1;\n+            }\n+        }\n+\n+        public void verify() {\n+            init(); \/\/ reset\n+            run();  \/\/ run compiled code\n+            int l = array.length - offset;\n+            for(int k = 0; k < l; k++) {\n+                if (array[k] != (k + 1)) {\n+                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n+                }\n+            }\n+            for(int k = l; k < array.length; k++) {\n+                if (array[k] != k) {\n+                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class TestBuffer implements Test {\n+        final IntBuffer buffer;\n+\n+        public TestBuffer(IntBuffer buf) {\n+            buffer = buf;\n+        }\n+\n+        public void init() {\n+            for (int k = 0; k < buffer.limit(); k++) {\n+                buffer.put(k, k);\n+            }\n+        }\n+\n+        public void run() {\n+            for (int k = 0; k < buffer.limit(); k++) {\n+                buffer.put(k, buffer.get(k) + 1);\n+            }\n+        }\n+\n+        public void verify() {\n+            init(); \/\/ reset\n+            run();  \/\/ run compiled code\n+            for(int k = 0; k < buffer.limit(); k++) {\n+                if (buffer.get(k) != (k + 1)) {\n+                    throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            throw new RuntimeException(\" Missing test name: array, arrayOffset, buffer, bufferHeap, bufferDirect\");\n+        }\n+\n+        Test te;\n+        switch (args[0]) {\n+            case \"array\":\n+                te = new TestArray();\n+                break;\n+            case \"arrayOffset\":\n+                te = new TestArrayOffset(offset);\n+                break;\n+            case \"buffer\":\n+                te = new TestBuffer(buffer);\n+                break;\n+            case \"bufferHeap\":\n+                te = new TestBuffer(heap_buffer_byte_to_int);\n+                break;\n+            case \"bufferDirect\":\n+                te = new TestBuffer(direct_buffer_byte_to_int);\n+                break;\n+            default:\n+                throw new RuntimeException(\" Unknown test: \" + args[0]);\n+        }\n+\n+        te.init();\n+        for (int i = 0; i < ITER; i++) {\n+            te.run();\n+        }\n+        te.verify();\n+\n+        if (args.length == 1) {\n+            verify_vectors(te, args[0]);\n+        }\n+    }\n+\n+    static void verify_vectors(Test t, String testName) {\n+        if (testName.equals(\"bufferDirect\")) {\n+            return; \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+        }\n+\n+        ProcessBuilder pb;\n+        OutputAnalyzer out;\n+        try {\n+            pb = ProcessTools.createJavaProcessBuilder(\"-XX:-BackgroundCompilation\",\n+                                                       \"-XX:+TraceNewVectors\",\n+                                                       \"compiler.vectorization.TestBufferVectorization\",\n+                                                       testName,\n+                                                       \"skip_verify\");\n+            out = new OutputAnalyzer(pb.start());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\" Exception launching Java process: \" + e);\n+        }\n+        out.shouldContain(\"ReplicateI\");\n+        out.shouldContain(\"LoadVector\");\n+        out.shouldContain(\"AddVI\");\n+        out.shouldContain(\"StoreVector\");\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestBufferVectorization.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"}]}