{"files":[{"patch":"@@ -39,12 +39,17 @@\n- * <p>\n- * The typical life-cycle of a HttpExchange is shown in the sequence\n- * below.\n- * <ol><li>{@link #getRequestMethod()} to determine the command\n- * <li>{@link #getRequestHeaders()} to examine the request headers (if needed)\n- * <li>{@link #getRequestBody()} returns a {@link java.io.InputStream} for reading the request body.\n- *     After reading the request body, the stream should be closed.\n- * <li>{@link #getResponseHeaders()} to set any response headers, except content-length\n- * <li>{@link #sendResponseHeaders(int,long)} to send the response headers. Must be called before\n- * next step.\n- * <li>{@link #getResponseBody()} to get a {@link java.io.OutputStream} to send the response body.\n- *      When the response body has been written, the stream must be closed to terminate the exchange.\n+ *\n+ * <p> The typical life-cycle of a {@code HttpExchange} is shown in the sequence\n+ * below:\n+ * <ol>\n+ *     <li>{@link #getRequestMethod()} to determine the command.\n+ *     <li>{@link #getRequestHeaders()} to examine the request headers (if\n+ *     needed).\n+ *     <li>{@link #getRequestBody()} returns an {@link java.io.InputStream} for\n+ *     reading the request body. After reading the request body, the stream\n+ *     should be closed.\n+ *     <li>{@link #getResponseHeaders()} to set any response headers, except\n+ *     content-length.\n+ *     <li>{@link #sendResponseHeaders(int,long)} to send the response headers.\n+ *     Must be called before next step.\n+ *     <li>{@link #getResponseBody()} to get a {@link java.io.OutputStream} to\n+ *     send the response body. When the response body has been written, the\n+ *     stream must be closed to terminate the exchange.\n@@ -52,0 +57,1 @@\n+ *\n@@ -53,10 +59,10 @@\n- * <br>\n- * Exchanges are terminated when both the request InputStream and response OutputStream are closed.\n- * Closing the OutputStream, implicitly closes the InputStream (if it is not already closed).\n- * However, it is recommended\n- * to consume all the data from the InputStream before closing it.\n- * The convenience method {@link #close()} does all of these tasks.\n- * Closing an exchange without consuming all of the request body is not an error\n- * but may make the underlying TCP connection unusable for following exchanges.\n- * The effect of failing to terminate an exchange is undefined, but will typically\n- * result in resources failing to be freed\/reused.\n+ * <br>Exchanges are terminated when both the request {@code InputStream} and\n+ * response {@code OutputStream} are closed. Closing the {@code OutputStream},\n+ * implicitly closes the {@code InputStream} (if it is not already closed).\n+ * However, it is recommended to consume all the data from the {@code InputStream}\n+ * before closing it. The convenience method {@link #close()} does all of these\n+ * tasks. Closing an exchange without consuming all of the request body is not\n+ * an error but may make the underlying TCP connection unusable for following\n+ * exchanges. The effect of failing to terminate an exchange is undefined, but\n+ * will typically result in resources failing to be freed\/reused.\n+ *\n@@ -71,1 +77,1 @@\n-    protected HttpExchange () {\n+    protected HttpExchange() {\n@@ -75,10 +81,12 @@\n-     * Returns an immutable Map containing the HTTP headers that were\n-     * included with this request. The keys in this Map will be the header\n-     * names, while the values will be a List of Strings containing each value\n-     * that was included (either for a header that was listed several times,\n-     * or one that accepts a comma-delimited list of values on a single line).\n-     * In either of these cases, the values for the header name will be\n-     * presented in the order that they were included in the request.\n-     * <p>\n-     * The keys in Map are case-insensitive.\n-     * @return a read-only Map which can be used to access request headers\n+     * Returns an immutable {@link Map} containing the HTTP headers that were\n+     * included with this request. The keys in this {@code Map} will be the header\n+     * names, while the values will be a {@link java.util.List} of\n+     * {@linkplain java.lang.String Strings} containing each value that was\n+     * included (either for a header that was listed several times, or one that\n+     * accepts a comma-delimited list of values on a single line). In either of\n+     * these cases, the values for the header name will be presented in the\n+     * order that they were included in the request.\n+     *\n+     * <p> The keys in {@code Map} are case-insensitive.\n+     *\n+     * @return a read-only {@code Map} which can be used to access request headers\n@@ -86,1 +94,1 @@\n-    public abstract Headers getRequestHeaders () ;\n+    public abstract Headers getRequestHeaders();\n@@ -89,8 +97,10 @@\n-     * Returns a mutable Map into which the HTTP response headers can be stored\n-     * and which will be transmitted as part of this response. The keys in the\n-     * Map will be the header names, while the values must be a List of Strings\n-     * containing each value that should be included multiple times\n-     * (in the order that they should be included).\n-     * <p>\n-     * The keys in Map are case-insensitive.\n-     * @return a writable Map which can be used to set response headers.\n+     * Returns a mutable {@link Map} into which the HTTP response headers can be\n+     * stored and which will be transmitted as part of this response. The keys in\n+     * the {@code Map} will be the header names, while the values must be a\n+     * {@link java.util.List} of {@linkplain java.lang.String Strings} containing\n+     * each value that should be included multiple times (in the order that they\n+     * should be included).\n+     *\n+     * <p> The keys in {@code Map} are case-insensitive.\n+     *\n+     * @return a writable {@code Map} which can be used to set response headers.\n@@ -98,1 +108,1 @@\n-    public abstract Headers getResponseHeaders () ;\n+    public abstract Headers getResponseHeaders();\n@@ -101,1 +111,1 @@\n-     * Get the request URI\n+     * Get the request {@link URI}.\n@@ -103,1 +113,1 @@\n-     * @return the request URI\n+     * @return the request {@code URI}\n@@ -105,1 +115,1 @@\n-    public abstract URI getRequestURI () ;\n+    public abstract URI getRequestURI();\n@@ -108,1 +118,2 @@\n-     * Get the request method\n+     * Get the request method.\n+     *\n@@ -111,1 +122,1 @@\n-    public abstract String getRequestMethod ();\n+    public abstract String getRequestMethod();\n@@ -114,2 +125,3 @@\n-     * Get the HttpContext for this exchange\n-     * @return the HttpContext\n+     * Get the {@link HttpContext} for this exchange.\n+     *\n+     * @return the {@code HttpContext}\n@@ -117,1 +129,1 @@\n-    public abstract HttpContext getHttpContext ();\n+    public abstract HttpContext getHttpContext();\n@@ -120,3 +132,4 @@\n-     * Ends this exchange by doing the following in sequence:<ol>\n-     * <li>close the request InputStream, if not already closed;<\/li>\n-     * <li>close the response OutputStream, if not already closed.<\/li>\n+     * Ends this exchange by doing the following in sequence:\n+     * <ol>\n+     *      <li> close the request {@link java.io.InputStream}, if not already closed.\n+     *      <li> close the response {@link java.io.OutputStream}, if not already closed.\n@@ -125,1 +138,1 @@\n-    public abstract void close () ;\n+    public abstract void close();\n@@ -128,1 +141,1 @@\n-     * returns a stream from which the request body can be read.\n+     * Returns a stream from which the request body can be read.\n@@ -130,6 +143,7 @@\n-     * It is recommended that applications should consume (read) all of the\n-     * data from this stream before closing it. If a stream is closed\n-     * before all data has been read, then the close() call will\n-     * read and discard remaining data (up to an implementation specific\n-     * number of bytes).\n-     * @return the stream from which the request body can be read.\n+     * It is recommended that applications should consume (read) all of the data\n+     * from this stream before closing it. If a stream is closed before all data\n+     * has been read, then the {@link java.io.InputStream#close()} call will read\n+     * and discard remaining data (up to an implementation specific number of\n+     * bytes).\n+     *\n+     * @return the stream from which the request body can be read\n@@ -137,1 +151,1 @@\n-    public abstract InputStream getRequestBody () ;\n+    public abstract InputStream getRequestBody();\n@@ -140,17 +154,18 @@\n-     * returns a stream to which the response body must be\n-     * written. {@link #sendResponseHeaders(int,long)}) must be called prior to calling\n-     * this method. Multiple calls to this method (for the same exchange)\n-     * will return the same stream. In order to correctly terminate\n-     * each exchange, the output stream must be closed, even if no\n-     * response body is being sent.\n-     * <p>\n-     * Closing this stream implicitly\n-     * closes the InputStream returned from {@link #getRequestBody()}\n-     * (if it is not already closed).\n-     * <P>\n-     * If the call to sendResponseHeaders() specified a fixed response\n-     * body length, then the exact number of bytes specified in that\n-     * call must be written to this stream. If too many bytes are written,\n-     * then write() will throw an IOException. If too few bytes are written\n-     * then the stream close() will throw an IOException. In both cases,\n-     * the exchange is aborted and the underlying TCP connection closed.\n+     * Returns a stream to which the response body must be\n+     * written. {@link #sendResponseHeaders(int,long)}) must be called prior to\n+     * calling this method. Multiple calls to this method (for the same exchange)\n+     * will return the same stream. In order to correctly terminate each exchange,\n+     * the output stream must be closed, even if no response body is being sent.\n+     *\n+     * <p> Closing this stream implicitly closes the {@link java.io.InputStream}\n+     * returned from {@link #getRequestBody()} (if it is not already closed).\n+     *\n+     * <p> If the call to {@link #sendResponseHeaders(int, long)} specified a\n+     * fixed response body length, then the exact number of bytes specified in\n+     * that call must be written to this stream. If too many bytes are written,\n+     * then {@link java.io.OutputStream#write()} will throw an {@code IOException}.\n+     * If too few bytes are written then the stream\n+     * {@link java.io.OutputStream#close()} will throw an {@code IOException}.\n+     * In both cases, the exchange is aborted and the underlying TCP connection\n+     * closed.\n+     *\n@@ -159,1 +174,1 @@\n-    public abstract OutputStream getResponseBody () ;\n+    public abstract OutputStream getResponseBody();\n@@ -163,13 +178,17 @@\n-     * Starts sending the response back to the client using the current set of response headers\n-     * and the numeric response code as specified in this method. The response body length is also specified\n-     * as follows. If the response length parameter is greater than zero, this specifies an exact\n-     * number of bytes to send and the application must send that exact amount of data.\n-     * If the response length parameter is {@code zero}, then chunked transfer encoding is\n-     * used and an arbitrary amount of data may be sent. The application terminates the\n-     * response body by closing the OutputStream. If response length has the value {@code -1}\n-     * then no response body is being sent.\n-     * <p>\n-     * If the content-length response header has not already been set then\n-     * this is set to the appropriate value depending on the response length parameter.\n-     * <p>\n-     * This method must be called prior to calling {@link #getResponseBody()}.\n+     * Starts sending the response back to the client using the current set of\n+     * response headers and the numeric response code as specified in this\n+     * method. The response body length is also specified as follows. If the\n+     * response length parameter is greater than {@code zero}, this specifies an\n+     * exact number of bytes to send and the application must send that exact\n+     * amount of data. If the response length parameter is {@code zero}, then\n+     * chunked transfer encoding is used and an arbitrary amount of data may be\n+     * sent. The application terminates the response body by closing the\n+     * {@link java.io.OutputStream}.\n+     * If response length has the value {@code -1} then no response body is\n+     * being sent.\n+     *\n+     * <p> If the content-length response header has not already been set then\n+     * this is set to the appropriate value depending on the response length\n+     * parameter.\n+     *\n+     * <p> This method must be called prior to calling {@link #getResponseBody()}.\n@@ -183,9 +202,10 @@\n-     * @param rCode the response code to send\n-     * @param responseLength if {@literal > 0}, specifies a fixed response\n-     *        body length and that exact number of bytes must be written\n-     *        to the stream acquired from getResponseBody(), or else\n-     *        if equal to 0, then chunked encoding is used,\n-     *        and an arbitrary number of bytes may be written.\n-     *        if {@literal <= -1}, then no response body length is specified and\n-     *        no response body may be written.\n-     * @see HttpExchange#getResponseBody()\n+     * @param rCode          the response code to send\n+     * @param responseLength if {@literal > 0}, specifies a fixed response body\n+     *                       length and that exact number of bytes must be written\n+     *                       to the stream acquired from {@link #getResponseCode()}\n+     *                       If {@literal == 0}, then chunked encoding is used,\n+     *                       and an arbitrary number of bytes may be written.\n+     *                       If {@literal <= -1}, then no response body length is\n+     *                       specified and no response body may be written.\n+     *\n+     * @see   HttpExchange#getResponseBody()\n@@ -193,1 +213,1 @@\n-    public abstract void sendResponseHeaders (int rCode, long responseLength) throws IOException ;\n+    public abstract void sendResponseHeaders(int rCode, long responseLength) throws IOException;\n@@ -196,2 +216,3 @@\n-     * Returns the address of the remote entity invoking this request\n-     * @return the InetSocketAddress of the caller\n+     * Returns the address of the remote entity invoking this request.\n+     *\n+     * @return the {@link InetSocketAddress} of the caller\n@@ -199,1 +220,1 @@\n-    public abstract InetSocketAddress getRemoteAddress ();\n+    public abstract InetSocketAddress getRemoteAddress();\n@@ -202,1 +223,2 @@\n-     * Returns the response code, if it has already been set\n+     * Returns the response code, if it has already been set.\n+     *\n@@ -205,1 +227,1 @@\n-    public abstract int getResponseCode ();\n+    public abstract int getResponseCode();\n@@ -208,2 +230,3 @@\n-     * Returns the local address on which the request was received\n-     * @return the InetSocketAddress of the local interface\n+     * Returns the local address on which the request was received.\n+     *\n+     * @return the {@link InetSocketAddress} of the local interface\n@@ -211,1 +234,1 @@\n-    public abstract InetSocketAddress getLocalAddress ();\n+    public abstract InetSocketAddress getLocalAddress();\n@@ -216,1 +239,2 @@\n-     * \"HTTP\/1.1\"\n+     * \"{@code HTTP\/1.1}\".\n+     *\n@@ -219,1 +243,1 @@\n-    public abstract String getProtocol ();\n+    public abstract String getProtocol();\n@@ -222,2 +246,2 @@\n-     * Filter modules may store arbitrary objects with HttpExchange\n-     * instances as an out-of-band communication mechanism. Other Filters\n+     * {@Link Filter} modules may store arbitrary objects with {@code HttpExchange}\n+     * instances as an out-of-band communication mechanism. Other filters\n@@ -225,2 +249,2 @@\n-     * <p>\n-     * Each Filter class will document the attributes which they make\n+     *\n+     * <p> Each {@code Filter} class will document the attributes which they make\n@@ -228,0 +252,1 @@\n+     *\n@@ -229,1 +254,1 @@\n-     * @return the attribute object, or null if it does not exist\n+     * @return the attribute object, or {@code null} if it does not exist\n@@ -232,1 +257,1 @@\n-    public abstract Object getAttribute (String name) ;\n+    public abstract Object getAttribute(String name);\n@@ -235,2 +260,2 @@\n-     * Filter modules may store arbitrary objects with HttpExchange\n-     * instances as an out-of-band communication mechanism. Other Filters\n+     * {@link Filter} modules may store arbitrary objects with {@code HttpExchange}\n+     * instances as an out-of-band communication mechanism. Other filters\n@@ -238,2 +263,2 @@\n-     * <p>\n-     * Each Filter class will document the attributes which they make\n+     *\n+     * <p> Each {@code Filter} class will document the attributes which they make\n@@ -241,1 +266,2 @@\n-     * @param name the name to associate with the attribute value\n+     *\n+     * @param name  the name to associate with the attribute value\n@@ -243,1 +269,1 @@\n-     * value is permitted.\n+     *              value is permitted.\n@@ -246,1 +272,1 @@\n-    public abstract void setAttribute (String name, Object value) ;\n+    public abstract void setAttribute(String name, Object value);\n@@ -249,13 +275,13 @@\n-     * Used by Filters to wrap either (or both) of this exchange's InputStream\n-     * and OutputStream, with the given filtered streams so\n-     * that subsequent calls to {@link #getRequestBody()} will\n-     * return the given {@link java.io.InputStream}, and calls to\n-     * {@link #getResponseBody()} will return the given\n-     * {@link java.io.OutputStream}. The streams provided to this\n-     * call must wrap the original streams, and may be (but are not\n-     * required to be) sub-classes of {@link java.io.FilterInputStream}\n-     * and {@link java.io.FilterOutputStream}.\n-     * @param i the filtered input stream to set as this object's inputstream,\n-     *          or {@code null} if no change.\n-     * @param o the filtered output stream to set as this object's outputstream,\n-     *          or {@code null} if no change.\n+     * Used by {@linkplain com.sun.net.httpserver.Filter Filters} to wrap either\n+     * (or both) of this exchange's {@link java.io.InputStream} and\n+     * {@link java.io.OutputStream}, with the given filtered streams so that\n+     * subsequent calls to {@link #getRequestBody()} will return the given\n+     * {@code InputStream}, and calls to {@link #getResponseBody()} will return\n+     * the given {@code OutputStream}. The streams provided to this call must wrap\n+     * the original streams, and may be (but are not required to be) sub-classes\n+     * of {@link java.io.FilterInputStream} and {@link java.io.FilterOutputStream}.\n+     *\n+     * @param i the filtered input stream to set as this object's\n+     *          {@code Inputstream}, or {@code null} if no change\n+     * @param o the filtered output stream to set as this object's\n+     *          {@code Outputstream}, or {@code null} if no change\n@@ -263,1 +289,1 @@\n-    public abstract void setStreams (InputStream i, OutputStream o);\n+    public abstract void setStreams(InputStream i, OutputStream o);\n@@ -267,1 +293,1 @@\n-     * If an authenticator is set on the HttpContext that owns this exchange,\n+     * If an authenticator is set on the {@link HttpContext} that owns this exchange,\n@@ -269,2 +295,3 @@\n-     * the authenticated user for this HttpExchange.\n-     * @return the HttpPrincipal, or {@code null} if no authenticator is set.\n+     * the authenticated user for this {@code HttpExchange}.\n+     *\n+     * @return the {@code HttpPrincipal}, or {@code null} if no authenticator is set\n@@ -272,1 +299,1 @@\n-    public abstract HttpPrincipal getPrincipal ();\n+    public abstract HttpPrincipal getPrincipal();\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpExchange.java","additions":172,"deletions":145,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * This class implements a simple HTTP server. A HttpServer is bound to an IP address\n+ * This class implements a simple HTTP server. A {@code HttpServer} is bound to an IP address\n@@ -39,7 +39,7 @@\n- * <p>\n- * One or more {@link HttpHandler} objects must be associated with a server\n- * in order to process requests. Each such HttpHandler is registered\n- * with a root URI path which represents the\n- * location of the application or service on this server. The mapping of a handler\n- * to a HttpServer is encapsulated by a {@link HttpContext} object. HttpContexts\n- * are created by calling {@link #createContext(String,HttpHandler)}.\n+ *\n+ * <p>One or more {@link HttpHandler} objects must be associated with a server\n+ * in order to process requests. Each such {@code HttpHandler} is registered with\n+ * a root URI path which represents the location of the application or service\n+ * on this server. The mapping of a handler to a {@code HttpServer} is\n+ * encapsulated by a {@link HttpContext} object. HttpContexts are created by\n+ * calling {@link #createContext(String,HttpHandler)}.\n@@ -50,9 +50,10 @@\n- * <p>\n- * <a id=\"mapping_description\"><\/a>\n- * <b>Mapping request URIs to HttpContext paths<\/b><p>\n- * When a HTTP request is received,\n- * the appropriate HttpContext (and handler) is located by finding the context\n- * whose path is the longest matching prefix of the request URI's path.\n- * Paths are matched literally, which means that the strings are compared\n- * case sensitively, and with no conversion to or from any encoded forms.\n- * For example. Given a HttpServer with the following HttpContexts configured.\n+ *\n+ * <p> <a id=\"mapping_description\"><\/a> <b>Mapping request URIs to HttpContext paths<\/b>\n+ *\n+ * <p>When a HTTP request is received, the appropriate {@code HttpContext}\n+ * (and handler) is located by finding the context whose path is the longest\n+ * matching prefix of the request URI's path. Paths are matched literally,\n+ * which means that the strings are compared case sensitively, and with no\n+ * conversion to or from any encoded forms. For example, given a {@code HttpServer}\n+ * with the following HttpContexts configured:\n+ *\n@@ -60,8 +61,11 @@\n- * <thead>\n- * <tr><th scope=\"col\"><i>Context<\/i><\/th><th scope=\"col\"><i>Context path<\/i><\/th><\/tr>\n- * <\/thead>\n- * <tbody>\n- * <tr><th scope=\"row\">ctx1<\/th><td>\"\/\"<\/td><\/tr>\n- * <tr><th scope=\"row\">ctx2<\/th><td>\"\/apps\/\"<\/td><\/tr>\n- * <tr><th scope=\"row\">ctx3<\/th><td>\"\/apps\/foo\/\"<\/td><\/tr>\n- * <\/tbody>\n+ *      <thead>\n+ *          <tr>\n+ *              <th scope=\"col\"><i>Context<\/i><\/th>\n+ *              <th scope=\"col\"><i>Context path<\/i><\/th>\n+ *          <\/tr>\n+ *      <\/thead>\n+ *      <tbody>\n+ *              <tr><th scope=\"row\">ctx1<\/th><td>\"\/\"<\/td><\/tr>\n+ *              <tr><th scope=\"row\">ctx2<\/th><td>\"\/apps\/\"<\/td><\/tr>\n+ *              <tr><th scope=\"row\">ctx3<\/th><td>\"\/apps\/foo\/\"<\/td><\/tr>\n+ *      <\/tbody>\n@@ -69,3 +73,3 @@\n- * <p>\n- * the following table shows some request URIs and which, if any context they would\n- * match with.\n+ *\n+ * <p>The following table shows some request URIs and which, if any context they would\n+ * match with:\n@@ -73,9 +77,12 @@\n- * <thead>\n- * <tr><th scope=\"col\"><i>Request URI<\/i><\/th><th scope=\"col\"><i>Matches context<\/i><\/th><\/tr>\n- * <\/thead>\n- * <tbody>\n- * <tr><th scope=\"row\">\"http:\/\/foo.com\/apps\/foo\/bar\"<\/th><td>ctx3<\/td><\/tr>\n- * <tr><th scope=\"row\">\"http:\/\/foo.com\/apps\/Foo\/bar\"<\/th><td>no match, wrong case<\/td><\/tr>\n- * <tr><th scope=\"row\">\"http:\/\/foo.com\/apps\/app1\"<\/th><td>ctx2<\/td><\/tr>\n- * <tr><th scope=\"row\">\"http:\/\/foo.com\/foo\"<\/th><td>ctx1<\/td><\/tr>\n- * <\/tbody>\n+ *      <thead>\n+ *          <tr>\n+ *              <th scope=\"col\"><i>Request URI<\/i><\/th>\n+ *              <th scope=\"col\"><i>Matches context<\/i><\/th>\n+ *          <\/tr>\n+ *      <\/thead>\n+ *      <tbody>\n+ *          <tr><th scope=\"row\">\"http:\/\/foo.com\/apps\/foo\/bar\"<\/th><td>ctx3<\/td><\/tr>\n+ *          <tr><th scope=\"row\">\"http:\/\/foo.com\/apps\/Foo\/bar\"<\/th><td>no match, wrong case<\/td><\/tr>\n+ *          <tr><th scope=\"row\">\"http:\/\/foo.com\/apps\/app1\"<\/th><td>ctx2<\/td><\/tr>\n+ *          <tr><th scope=\"row\">\"http:\/\/foo.com\/foo\"<\/th><td>ctx1<\/td><\/tr>\n+ *      <\/tbody>\n@@ -83,9 +90,13 @@\n- * <p>\n- * <b>Note about socket backlogs<\/b><p>\n- * When binding to an address and port number, the application can also specify an integer\n- * <i>backlog<\/i> parameter. This represents the maximum number of incoming TCP connections\n- * which the system will queue internally. Connections are queued while they are waiting to\n- * be accepted by the HttpServer. When the limit is reached, further connections may be\n- * rejected (or possibly ignored) by the underlying TCP implementation. Setting the right\n- * backlog value is a compromise between efficient resource usage in the TCP layer (not setting\n- * it too high) and allowing adequate throughput of incoming requests (not setting it too low).\n+ *\n+ * <p><b>Note about socket backlogs<\/b>\n+ *\n+ * <p>When binding to an address and port number, the application can also\n+ * specify an integer <i>backlog<\/i> parameter. This represents the maximum\n+ * number of incoming TCP connections which the system will queue internally.\n+ * Connections are queued while they are waiting to be accepted by the\n+ * {@code HttpServer}. When the limit is reached, further connections may be\n+ * rejected (or possibly ignored) by the underlying TCP implementation. Setting\n+ * the right backlog value is a compromise between efficient resource usage in\n+ * the TCP layer (not setting it too high) and allowing adequate throughput of\n+ * incoming requests (not setting it too low).\n+ *\n@@ -100,1 +111,1 @@\n-    protected HttpServer () {\n+    protected HttpServer() {\n@@ -104,3 +115,4 @@\n-     * creates a HttpServer instance which is initially not bound to any local address\/port.\n-     * The HttpServer is acquired from the currently installed {@link HttpServerProvider}\n-     * The server must be bound using {@link #bind(InetSocketAddress,int)} before it can be used.\n+     * Creates a {@code HttpServer} instance which is initially not bound to any\n+     * local address\/port. The {@code HttpServer} is acquired from the currently\n+     * installed {@link HttpServerProvider}. The server must be bound using\n+     * {@link #bind(InetSocketAddress,int)} before it can be used.\n@@ -109,1 +121,1 @@\n-     * @return An instance of HttpServer\n+     * @return an instance of {@code HttpServer}\n@@ -111,1 +123,1 @@\n-    public static HttpServer create () throws IOException {\n+    public static HttpServer create() throws IOException {\n@@ -116,2 +128,2 @@\n-     * Create a <code>HttpServer<\/code> instance which will bind to the\n-     * specified {@link java.net.InetSocketAddress} (IP address and port number)\n+     * Create a {@code HttpServer} instance which will bind to the\n+     * specified {@link java.net.InetSocketAddress} (IP address and port number).\n@@ -121,2 +133,3 @@\n-     * Queued TCP connections exceeding this limit may be rejected by the TCP implementation.\n-     * The HttpServer is acquired from the currently installed {@link HttpServerProvider}\n+     * Queued TCP connections exceeding this limit may be rejected by the TCP\n+     * implementation. The {@code HttpServer} is acquired from the currently\n+     * installed {@link HttpServerProvider}\n@@ -124,2 +137,3 @@\n-     * @param addr the address to listen on, if <code>null<\/code> then bind() must be called\n-     *  to set the address\n+     * @param addr the address to listen on, if {@code null} then\n+     *             {@link #bind(InetSocketAddress, int)} must be called to set\n+     *             the address\n@@ -127,3 +141,1 @@\n-     *          then a system default value is used.\n-     * @throws BindException if the server cannot bind to the requested address,\n-     *          or if the server is already bound.\n+     *                then a system default value is used\n@@ -131,1 +143,3 @@\n-     * @return An instance of HttpServer\n+     * @throws BindException if the server cannot bind to the requested address,\n+     * or if the server is already bound\n+     * @return an instance of {@code HttpServer}\n@@ -134,3 +148,1 @@\n-    public static HttpServer create (\n-        InetSocketAddress addr, int backlog\n-    ) throws IOException {\n+    public static HttpServer create(InetSocketAddress addr, int backlog) throws IOException {\n@@ -142,4 +154,6 @@\n-     * Binds a currently unbound HttpServer to the given address and port number.\n-     * A maximum backlog can also be specified. This is the maximum number of\n-     * queued incoming connections to allow on the listening socket.\n-     * Queued TCP connections exceeding this limit may be rejected by the TCP implementation.\n+     * Binds a currently unbound {@code HttpServer} to the given address and\n+     * port number. A maximum backlog can also be specified. This is the maximum\n+     * number of queued incoming connections to allow on the listening socket.\n+     * Queued TCP connections exceeding this limit may be rejected by the TCP\n+     * implementation.\n+     *\n@@ -147,5 +161,5 @@\n-     * @param backlog the socket backlog. If this value is less than or equal to zero,\n-     *          then a system default value is used.\n-     * @throws BindException if the server cannot bind to the requested address or if the server\n-     *          is already bound.\n-     * @throws NullPointerException if addr is <code>null<\/code>\n+     * @param backlog the socket backlog. If this value is less than or equal to\n+     *                zero, then a system default value is used\n+     * @throws BindException if the server cannot bind to the requested address\n+     * or if the server is already bound\n+     * @throws NullPointerException if addr is {@code null}\n@@ -153,1 +167,1 @@\n-    public abstract void bind (InetSocketAddress addr, int backlog) throws IOException;\n+    public abstract void bind(InetSocketAddress addr, int backlog) throws IOException;\n@@ -160,1 +174,1 @@\n-    public abstract void start () ;\n+    public abstract void start();\n@@ -163,2 +177,2 @@\n-     * sets this server's {@link java.util.concurrent.Executor} object. An\n-     * Executor must be established before {@link #start()} is called.\n+     * Sets this server's {@link java.util.concurrent.Executor} object. An\n+     * {@code Executor} must be established before {@link #start()} is called.\n@@ -166,6 +180,6 @@\n-     * If this method is not called (before start()) or if it is\n-     * called with a <code>null<\/code> Executor, then\n-     * a default implementation is used, which uses the thread\n-     * which was created by the {@link #start()} method.\n-     * @param executor the Executor to set, or <code>null<\/code> for  default\n-     *          implementation\n+     * If this method is not called (before {@link #start()}) or if it is called\n+     * with a {@code null Executor}, then a default implementation is used,\n+     * which uses the thread which was created by the {@link #start()} method.\n+     *\n+     * @param executor the {@code Executor} to set, or {@code null} for  default\n+     *                 implementation\n@@ -174,1 +188,1 @@\n-    public abstract void setExecutor (Executor executor);\n+    public abstract void setExecutor(Executor executor);\n@@ -178,4 +192,4 @@\n-     * returns this server's Executor object if one was specified with\n-     * {@link #setExecutor(Executor)}, or <code>null<\/code> if none was\n-     * specified.\n-     * @return the Executor established for this server or <code>null<\/code> if not set.\n+     * Returns this server's {@code Executor} object if one was specified with\n+     * {@link #setExecutor(Executor)}, or {@code null} if none was specified.\n+     *\n+     * @return the {@code Executor} established for this server or {@code null} if not set.\n@@ -183,1 +197,1 @@\n-    public abstract Executor getExecutor () ;\n+    public abstract Executor getExecutor() ;\n@@ -186,1 +200,1 @@\n-     * stops this server by closing the listening socket and disallowing\n+     * Stops this server by closing the listening socket and disallowing\n@@ -191,2 +205,2 @@\n-     * thread created by start() exits, and the method returns.\n-     * Once stopped, a HttpServer cannot be re-used.\n+     * thread created by {@link #start()} exits, and the method returns.\n+     * Once stopped, a {@code HttpServer} cannot be re-used.\n@@ -194,2 +208,2 @@\n-     * @param delay the maximum time in seconds to wait until exchanges have finished.\n-     * @throws IllegalArgumentException if delay is less than zero.\n+     * @param delay the maximum time in seconds to wait until exchanges have finished\n+     * @throws IllegalArgumentException if delay is less than zero\n@@ -197,1 +211,1 @@\n-    public abstract void stop (int delay);\n+    public abstract void stop(int delay);\n@@ -200,13 +214,17 @@\n-     * Creates a HttpContext. A HttpContext represents a mapping from a\n-     * URI path to a exchange handler on this HttpServer. Once created, all requests\n-     * received by the server for the path will be handled by calling\n-     * the given handler object. The context is identified by the path, and\n-     * can later be removed from the server using this with the {@link #removeContext(String)} method.\n-     * <p>\n-     * The path specifies the root URI path for this context. The first character of path must be\n-     * '\/'. <p>\n-     * The class overview describes how incoming request URIs are <a href=\"#mapping_description\">mapped<\/a>\n-     * to HttpContext instances.\n-     * @apiNote The path should generally, but is not required to, end with '\/'. If the path does not\n-     * end with '\/', eg such as with {@code \"\/foo\"} then this would match requests with a path of\n-     * {@code \"\/foobar\"} or {@code \"\/foo\/bar\"}.\n+     * Creates a {@code HttpContext}. A  {@code HttpContext} represents a mapping\n+     * from a URI path to a exchange handler on this  {@code HttpServer}. Once\n+     * created, all requests received by the server for the path will be handled\n+     * by calling the given handler object. The context is identified by the\n+     * path, and can later be removed from the server using this with the\n+     * {@link #removeContext(String)} method.\n+     *\n+     * <p> The path specifies the root URI path for this context. The first\n+     * character of path must be '\/'.\n+     *\n+     * <p>The class overview describes how incoming request URIs are\n+     * <a href=\"#mapping_description\">mapped<\/a> to HttpContext instances.\n+     *\n+     * @apiNote The path should generally, but is not required to, end with '\/'.\n+     * If the path does not end with '\/', eg such as with {@code \"\/foo\"} then\n+     * this would match requests with a path of {@code \"\/foobar\"} or\n+     * {@code \"\/foo\/bar\"}.\n@@ -215,1 +233,1 @@\n-     * @param handler the handler to invoke for incoming requests.\n+     * @param handler the handler to invoke for incoming requests\n@@ -217,3 +235,3 @@\n-     *          already exists for this path\n-     * @throws NullPointerException if either path, or handler are <code>null<\/code>\n-     * @return An instance of HttpContext\n+     * already exists for this path\n+     * @throws NullPointerException if either path, or handler are {@code null}\n+     * @return an instance of {@code HttpContext}\n@@ -221,1 +239,1 @@\n-    public abstract HttpContext createContext (String path, HttpHandler handler) ;\n+    public abstract HttpContext createContext(String path, HttpHandler handler);\n@@ -224,15 +242,19 @@\n-     * Creates a HttpContext without initially specifying a handler. The handler must later be specified using\n-     * {@link HttpContext#setHandler(HttpHandler)}.  A HttpContext represents a mapping from a\n-     * URI path to an exchange handler on this HttpServer. Once created, and when\n-     * the handler has been set, all requests\n-     * received by the server for the path will be handled by calling\n-     * the handler object. The context is identified by the path, and\n-     * can later be removed from the server using this with the {@link #removeContext(String)} method.\n-     * <p>\n-     * The path specifies the root URI path for this context. The first character of path must be\n-     * '\/'. <p>\n-     * The class overview describes how incoming request URIs are <a href=\"#mapping_description\">mapped<\/a>\n-     * to HttpContext instances.\n-     * @apiNote The path should generally, but is not required to, end with '\/'. If the path does not\n-     * end with '\/', eg such as with {@code \"\/foo\"} then this would match requests with a path of\n-     * {@code \"\/foobar\"} or {@code \"\/foo\/bar\"}.\n+     * Creates a HttpContext without initially specifying a handler. The handler\n+     * must later be specified using {@link HttpContext#setHandler(HttpHandler)}.\n+     * A {@code HttpContext} represents a mapping from a URI path to an exchange\n+     * handler on this {@code HttpServer}. Once created, and when the handler has\n+     * been set, all requests received by the server for the path will be handled\n+     * by calling the handler object. The context is identified by the path, and\n+     * can later be removed from the server using this with the\n+     * {@link #removeContext(String)} method.\n+     *\n+     * <p>The path specifies the root URI path for this context. The first character of path must be\n+     * '\/'.\n+     *\n+     * <p>The class overview describes how incoming request URIs are\n+     * <a href=\"#mapping_description\">mapped<\/a> to {@code HttpContext} instances.\n+     *\n+     * @apiNote The path should generally, but is not required to, end with '\/'.\n+     * If the path does not end with '\/', eg such as with {@code \"\/foo\"} then\n+     * this would match requests with a path of {@code \"\/foobar\"} or\n+     * {@code \"\/foo\/bar\"}.\n@@ -242,3 +264,3 @@\n-     *          already exists for this path\n-     * @throws NullPointerException if path is <code>null<\/code>\n-     * @return An instance of HttpContext\n+     * already exists for this path\n+     * @throws NullPointerException if path is {@code null}\n+     * @return an instance of {@code HttpContext}\n@@ -246,1 +268,1 @@\n-    public abstract HttpContext createContext (String path) ;\n+    public abstract HttpContext createContext(String path);\n@@ -252,0 +274,1 @@\n+     *\n@@ -254,2 +277,2 @@\n-     *          path exists.\n-     * @throws NullPointerException if path is <code>null<\/code>\n+     * path exists.\n+     * @throws NullPointerException if path is {@code null}\n@@ -257,1 +280,1 @@\n-    public abstract void removeContext (String path) throws IllegalArgumentException ;\n+    public abstract void removeContext(String path) throws IllegalArgumentException;\n@@ -263,0 +286,1 @@\n+     *\n@@ -264,1 +288,1 @@\n-     * @throws NullPointerException if context is <code>null<\/code>\n+     * @throws NullPointerException if context is {@code null}\n@@ -266,1 +290,1 @@\n-    public abstract void removeContext (HttpContext context) ;\n+    public abstract void removeContext(HttpContext context);\n@@ -269,2 +293,3 @@\n-     * returns the address this server is listening on\n-     * @return the address\/port number the server is listening on\n+     * Returns the address this server is listening on\n+     *\n+     * @return the {@code InetSocketAddress} the server is listening on\n@@ -272,1 +297,1 @@\n-    public abstract InetSocketAddress getAddress() ;\n+    public abstract InetSocketAddress getAddress();\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpServer.java","additions":166,"deletions":141,"binary":false,"changes":307,"status":"modified"}]}