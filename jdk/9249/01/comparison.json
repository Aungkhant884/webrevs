{"files":[{"patch":"@@ -83,1 +83,0 @@\n-import sun.nio.fs.AbstractFileSystemProvider;\n@@ -1597,1 +1596,1 @@\n-             InputStream in2 = Files.newInputStream(path2);) {\n+             InputStream in2 = Files.newInputStream(path2)) {\n@@ -2313,6 +2312,0 @@\n-        if (options.length == 0) {\n-            FileSystemProvider provider = provider(path);\n-            if (provider instanceof AbstractFileSystemProvider)\n-                return ((AbstractFileSystemProvider)provider).isDirectory(path);\n-        }\n-\n@@ -2320,1 +2313,3 @@\n-            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();\n+            var attrs = provider(path)\n+                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n+            return (attrs != null) && attrs.isDirectory();\n@@ -2356,6 +2351,0 @@\n-        if (options.length == 0) {\n-            FileSystemProvider provider = provider(path);\n-            if (provider instanceof AbstractFileSystemProvider)\n-                return ((AbstractFileSystemProvider)provider).isRegularFile(path);\n-        }\n-\n@@ -2363,1 +2352,3 @@\n-            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();\n+            var attrs = provider(path)\n+                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n+            return (attrs != null) && attrs.isRegularFile();\n@@ -2505,1 +2496,1 @@\n-     * .\n+     *\n@@ -2518,21 +2509,1 @@\n-        if (options.length == 0) {\n-            FileSystemProvider provider = provider(path);\n-            if (provider instanceof AbstractFileSystemProvider)\n-                return ((AbstractFileSystemProvider)provider).exists(path);\n-        }\n-\n-        try {\n-            if (followLinks(options)) {\n-                provider(path).checkAccess(path);\n-            } else {\n-                \/\/ attempt to read attributes without following links\n-                readAttributes(path, BasicFileAttributes.class,\n-                               LinkOption.NOFOLLOW_LINKS);\n-            }\n-            \/\/ file exists\n-            return true;\n-        } catch (IOException x) {\n-            \/\/ does not exist or unable to determine if file exists\n-            return false;\n-        }\n-\n+        return provider(path).exists(path, options);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":9,"deletions":38,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1173,0 +1173,118 @@\n+\n+    \/**\n+     * Tests whether a file exists. This method works in exactly the\n+     * manner specified by the {@link Files#exists(Path, LinkOption...)} method.\n+     *\n+     * @implSpec\n+     * The default implementation of this method invokes the\n+     * {@link #checkAccess(Path, AccessMode...)} method when symbolic links\n+     * are followed. If the option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS}\n+     * is present then symbolic links are not followed and the method\n+     * {@link #readAttributes(Path, Class, LinkOption...)} is called\n+     * to determine whether a file exists.\n+     *\n+     * @param   path\n+     *          the path to the file to test\n+     * @param   options\n+     *          options indicating how symbolic links are handled\n+     *\n+     * @return  {@code true} if the file exists; {@code false} if the file does\n+     *          not exist or its existence cannot be determined.\n+     *\n+     * @throws  SecurityException\n+     *          In the case of the default provider, the {@link\n+     *          SecurityManager#checkRead(String)} is invoked to check\n+     *          read access to the file.\n+     *\n+     * @since 20\n+     *\/\n+    public boolean exists(Path path, LinkOption... options) {\n+        try {\n+            if (followLinks(options)) {\n+                this.checkAccess(path);\n+            } else {\n+                \/\/ attempt to read attributes without following links\n+                readAttributes(path, BasicFileAttributes.class,  LinkOption.NOFOLLOW_LINKS);\n+            }\n+            \/\/ file exists\n+            return true;\n+        } catch (IOException x) {\n+            \/\/ does not exist or unable to determine if file exists\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Reads a file's attributes as a bulk operation if it exists.\n+     *\n+     * <p> The {@code type} parameter is the type of the attributes required\n+     * and this method returns an instance of that type if supported. All\n+     * implementations support a basic set of file attributes and so invoking\n+     * this method with a  {@code type} parameter of {@code\n+     * BasicFileAttributes.class} will not throw {@code\n+     * UnsupportedOperationException}.\n+     *\n+     * <p> The {@code options} array may be used to indicate how symbolic links\n+     * are handled for the case that the file is a symbolic link. By default,\n+     * symbolic links are followed and the file attribute of the final target\n+     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n+     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n+     *\n+     * <p> It is implementation specific if all file attributes are read as an\n+     * atomic operation with respect to other file system operations.\n+     *\n+     * @implSpec\n+     * The default implementation of this method invokes the\n+     * {@link #readAttributes(Path, Class, LinkOption...)} method\n+     * to read the file's attributes.\n+     *\n+     * @param   <A>\n+     *          The {@code BasicFileAttributes} type\n+     * @param   path\n+     *          the path to the file\n+     * @param   type\n+     *          the {@code Class} of the file attributes required\n+     *          to read\n+     * @param   options\n+     *          options indicating how symbolic links are handled\n+     *\n+     * @return  the file attributes or null if the file does not exist\n+     *\n+     * @throws  UnsupportedOperationException\n+     *          if an attributes of the given type are not supported\n+     * @throws  IOException\n+     *          if an I\/O error occurs\n+     * @throws  SecurityException\n+     *          In the case of the default provider, a security manager is\n+     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n+     *          method is invoked to check read access to the file. If this\n+     *          method is invoked to read security sensitive attributes then the\n+     *          security manager may be invoked to check for additional permissions.\n+     *\n+     * @since 20\n+     *\/\n+    public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                    Class<A> type,\n+                                                                    LinkOption... options)\n+        throws IOException\n+    {\n+        try {\n+            return readAttributes(path, type, options);\n+        } catch (NoSuchFileException ignore) {\n+            return null;\n+        }\n+    }\n+\n+    private static boolean followLinks(LinkOption... options) {\n+        boolean followLinks = true;\n+        for (LinkOption opt: options) {\n+            if (opt == LinkOption.NOFOLLOW_LINKS) {\n+                followLinks = false;\n+                continue;\n+            }\n+            if (opt == null)\n+                throw new NullPointerException();\n+            throw new AssertionError(\"Should not get here\");\n+        }\n+        return followLinks;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/spi\/FileSystemProvider.java","additions":119,"deletions":1,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n@@ -113,45 +112,0 @@\n-    \/**\n-     * Tests whether a file is a directory.\n-     *\n-     * @return  {@code true} if the file is a directory; {@code false} if\n-     *          the file does not exist, is not a directory, or it cannot\n-     *          be determined if the file is a directory or not.\n-     *\/\n-    public boolean isDirectory(Path file) {\n-        try {\n-            return readAttributes(file, BasicFileAttributes.class).isDirectory();\n-        } catch (IOException ioe) {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Tests whether a file is a regular file with opaque content.\n-     *\n-     * @return  {@code true} if the file is a regular file; {@code false} if\n-     *          the file does not exist, is not a regular file, or it\n-     *          cannot be determined if the file is a regular file or not.\n-     *\/\n-    public boolean isRegularFile(Path file) {\n-        try {\n-            return readAttributes(file, BasicFileAttributes.class).isRegularFile();\n-        } catch (IOException ioe) {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Checks the existence of a file.\n-     *\n-     * @return  {@code true} if the file exists; {@code false} if the file does\n-     *          not exist or its existence cannot be determined.\n-     *\/\n-    public boolean exists(Path file) {\n-        try {\n-            checkAccess(file);\n-            return true;\n-        } catch (IOException ioe) {\n-            return false;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractFileSystemProvider.java","additions":1,"deletions":47,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,13 @@\n+    \/\/ get the UnixFileAttributes for a given file. Returns null if the file does not exist.\n+    static UnixFileAttributes getIfExists(UnixPath path) throws UnixException {\n+        UnixFileAttributes attrs = new UnixFileAttributes();\n+        int errno = UnixNativeDispatcher.stat2(path, attrs);\n+        if (errno == 0) {\n+            return attrs;\n+        } else if (errno == UnixConstants.ENOENT) {\n+            return null;\n+        } else {\n+            throw new UnixException(errno);\n+        }\n+    }\n+\n@@ -254,10 +267,0 @@\n-    \/\/ unwrap BasicFileAttributes to get the underlying UnixFileAttributes\n-    \/\/ object. Returns null is not wrapped.\n-    static UnixFileAttributes toUnixFileAttributes(BasicFileAttributes attrs) {\n-        if (attrs instanceof UnixFileAttributes)\n-            return (UnixFileAttributes)attrs;\n-        if (attrs instanceof UnixAsBasicFileAttributes) {\n-            return ((UnixAsBasicFileAttributes)attrs).unwrap();\n-        }\n-        return null;\n-    }\n@@ -277,3 +280,0 @@\n-        UnixFileAttributes unwrap() {\n-            return attrs;\n-        }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributes.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-        return (V) null;\n+        return null;\n@@ -151,0 +151,19 @@\n+    @Override\n+    public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                    Class<A> type,\n+                                                                    LinkOption... options)\n+        throws IOException\n+    {\n+        if (type == BasicFileAttributes.class && Util.followLinks(options)) {\n+            UnixPath file = UnixPath.toUnixPath(path);\n+            try {\n+                @SuppressWarnings(\"unchecked\")\n+                A attrs = (A) UnixFileAttributes.getIfExists(file);\n+                return attrs;\n+            } catch (UnixException e) {\n+                e.rethrowAsIOException(file);\n+            }\n+        }\n+        return super.readAttributesIfExists(path, type, options);\n+    }\n+\n@@ -284,4 +303,3 @@\n-                    case READ : r = true; break;\n-                    case WRITE : w = true; break;\n-                    case EXECUTE : x = true; break;\n-                    default: throw new AssertionError(\"Should not get here\");\n+                    case READ -> r = true;\n+                    case WRITE -> w = true;\n+                    case EXECUTE -> x = true;\n@@ -324,1 +342,1 @@\n-        if (!(obj2 instanceof UnixPath))\n+        if (!(obj2 instanceof UnixPath file2))\n@@ -326,1 +344,0 @@\n-        UnixPath file2 = (UnixPath)obj2;\n@@ -519,14 +536,8 @@\n-    public final boolean isDirectory(Path obj) {\n-        UnixPath file = UnixPath.toUnixPath(obj);\n-        file.checkRead();\n-        int mode = UnixNativeDispatcher.stat(file);\n-        return ((mode & UnixConstants.S_IFMT) == UnixConstants.S_IFDIR);\n-    }\n-\n-    @Override\n-    public final boolean isRegularFile(Path obj) {\n-        UnixPath file = UnixPath.toUnixPath(obj);\n-        file.checkRead();\n-        int mode = UnixNativeDispatcher.stat(file);\n-        return ((mode & UnixConstants.S_IFMT) == UnixConstants.S_IFREG);\n-    }\n+    public boolean exists(Path path, LinkOption... options) {\n+        if (Util.followLinks(options)) {\n+            UnixPath file = UnixPath.toUnixPath(path);\n+            file.checkRead();\n+            return UnixNativeDispatcher.exists(file);\n+        } else {\n+            return super.exists(path, options);\n+        }\n@@ -534,5 +545,0 @@\n-    @Override\n-    public final boolean exists(Path obj) {\n-        UnixPath file = UnixPath.toUnixPath(obj);\n-        file.checkRead();\n-        return UnixNativeDispatcher.exists(file);\n@@ -540,1 +546,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":32,"deletions":27,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -321,1 +321,4 @@\n-                stat0(buffer.address(), attrs);\n+                int errno = stat0(buffer.address(), attrs);\n+                if (errno != 0) {\n+                    throw new UnixException(errno);\n+                }\n@@ -327,3 +330,0 @@\n-    private static native void stat0(long pathAddress, UnixFileAttributes attrs)\n-        throws UnixException;\n-\n@@ -331,6 +331,1 @@\n-    \/**\n-     * stat(const char* path, struct stat* buf)\n-     *\n-     * @return st_mode (file type and mode) or 0 if an error occurs.\n-     *\/\n-    static int stat(UnixPath path) {\n+    static int stat2(UnixPath path, UnixFileAttributes attrs) {\n@@ -340,1 +335,1 @@\n-                return stat1(buffer.address());\n+                return stat0(buffer.address(), attrs);\n@@ -346,1 +341,0 @@\n-    private static native int stat1(long pathAddress);\n@@ -348,0 +342,1 @@\n+    private static native int stat0(long pathAddress, UnixFileAttributes attrs);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,2 +121,3 @@\n-                int mode = UnixNativeDispatcher.stat(up);\n-                if ((mode & UnixConstants.S_IFMT) == UnixConstants.S_IFDIR)\n+                UnixFileAttributes attrs = UnixFileAttributes.getIfExists(up);\n+                if (attrs != null\n+                        && ((attrs.mode() & UnixConstants.S_IFMT) == UnixConstants.S_IFDIR))\n@@ -124,1 +125,1 @@\n-            } catch (SecurityException ignore) { }\n+            } catch (UnixException | SecurityException ignore) { }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUriUtils.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -524,1 +524,1 @@\n-JNIEXPORT void JNICALL\n+JNIEXPORT jint JNICALL\n@@ -533,3 +533,1 @@\n-    if (err == -1) {\n-        throwUnixException(env, errno);\n-    } else {\n+    if (err == 0) {\n@@ -537,11 +535,0 @@\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_UnixNativeDispatcher_stat1(JNIEnv* env, jclass this, jlong pathAddress) {\n-    int err;\n-    struct stat64 buf;\n-    const char* path = (const char*)jlong_to_ptr(pathAddress);\n-\n-    RESTARTABLE(stat64(path, &buf), err);\n-    if (err == -1) {\n@@ -550,1 +537,1 @@\n-        return (jint)buf.st_mode;\n+        return errno;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,9 @@\n+    @Override\n+    public boolean exists(Path path, LinkOption... options) {\n+        if (options.length == 0) {\n+            return toZipPath(path).exists();\n+        } else {\n+            return super.exists(path, options);\n+        }\n+    }\n+\n@@ -285,0 +294,10 @@\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\") \/\/ Cast to A\n+    public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                    Class<A> type,\n+                                                                    LinkOption... options)\n+        throws IOException\n+    {\n+        return (A) toZipPath(path).readAttributesIfExists();\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystemProvider.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-        if (!(other instanceof ZipPath))\n+        if (!(other instanceof final ZipPath o))\n@@ -334,1 +334,0 @@\n-        final ZipPath o = (ZipPath)other;\n@@ -352,1 +351,1 @@\n-        if (!(other instanceof ZipPath))\n+        if (!(other instanceof final ZipPath o))\n@@ -354,1 +353,0 @@\n-        final ZipPath o = (ZipPath)other;\n@@ -385,1 +383,1 @@\n-    public final Path resolveSibling(String other) {\n+    public Path resolveSibling(String other) {\n@@ -390,1 +388,1 @@\n-    public final boolean startsWith(String other) {\n+    public boolean startsWith(String other) {\n@@ -395,1 +393,1 @@\n-    public final boolean endsWith(String other) {\n+    public boolean endsWith(String other) {\n@@ -674,1 +672,1 @@\n-    public final File toFile() {\n+    public File toFile() {\n@@ -847,0 +845,4 @@\n+    ZipFileAttributes readAttributesIfExists() throws IOException {\n+        return zfs.getFileAttributes(getResolvedPath());\n+    }\n+\n@@ -904,1 +906,1 @@\n-    private boolean exists() {\n+    boolean exists() {\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,525 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.*;\n+import java.nio.file.attribute.*;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/**\n+ * StubFSProvider provides limited implementations of:\n+ * BasicAttributes:     BasicAttributes\n+ * FileSystemProvider:  StubFSProvider\n+ * FileSystem:          StubFileSystem\n+ * Path:                StubPath\n+ *\n+ * These classes are used by the test TestOverRideFSPMethods\n+ *\/\n+public class StubFSProvider extends FileSystemProvider {\n+\n+    private final StubFileSystem theFileSystem;\n+\n+    public StubFSProvider(FileSystemProvider defaultProvider) {\n+        FileSystem fs = defaultProvider.getFileSystem(URI.create(\"file:\/\"));\n+        this.theFileSystem = new StubFileSystem(fs, this);\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        return \"file\";\n+    }\n+\n+    @Override\n+    public FileSystem newFileSystem(URI uri, Map<String,?> env) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public FileSystem getFileSystem(URI uri) {\n+        return theFileSystem;\n+    }\n+\n+    @Override\n+    public Path getPath(URI uri) {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void setAttribute(Path file, String attribute, Object value,\n+                             LinkOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public Map<String,Object> readAttributes(Path file, String attributes,\n+                                             LinkOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public <A extends BasicFileAttributes> A readAttributes(Path file,\n+                                                            Class<A> type,\n+                                                            LinkOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                    Class<A> type,\n+                                                                    LinkOption... options)\n+            throws IOException {\n+        return (A) new StubAttributes();\n+    }\n+\n+    @Override\n+    public <V extends FileAttributeView> V getFileAttributeView(Path file,\n+                                                                Class<V> type,\n+                                                                LinkOption... options)\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void delete(Path file) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void createLink(Path link, Path existing) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public Path readSymbolicLink(Path link) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void copy(Path source, Path target, CopyOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void move(Path source, Path target, CopyOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public DirectoryStream<Path> newDirectoryStream(Path dir,\n+                                                    DirectoryStream.Filter<? super Path> filter)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void createDirectory(Path dir, FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public boolean exists(Path path, LinkOption... options) {\n+        var fs = path.getFileSystem();\n+        return ((fs instanceof StubFileSystem)\n+        && (fs.provider() instanceof StubFSProvider));\n+    }\n+\n+    @Override\n+    public SeekableByteChannel newByteChannel(Path file,\n+                                              Set<? extends OpenOption> options,\n+                                              FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public FileChannel newFileChannel(Path file,\n+                                      Set<? extends OpenOption> options,\n+                                      FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public boolean isHidden(Path file) throws IOException {\n+        throw new ReadOnlyFileSystemException();\n+    }\n+\n+    @Override\n+    public FileStore getFileStore(Path file) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public boolean isSameFile(Path file, Path other) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void checkAccess(Path file, AccessMode... modes)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    static class StubFileSystem extends FileSystem {\n+        private final FileSystem delegate;\n+        private final StubFSProvider provider;\n+\n+        StubFileSystem(FileSystem delegate, StubFSProvider provider) {\n+            this.delegate = delegate;\n+            this.provider = provider;\n+        }\n+\n+        Path wrap(Path path) {\n+            return (path != null) ? new StubPath(this, path) : null;\n+        }\n+\n+        Path unwrap(Path wrapper) {\n+            if (wrapper == null)\n+                throw new NullPointerException();\n+            if (!(wrapper instanceof StubPath))\n+                throw new ProviderMismatchException();\n+            return ((StubPath)wrapper).unwrap();\n+        }\n+\n+        @Override\n+        public FileSystemProvider provider() {\n+            return provider;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isReadOnly() {\n+            return false;\n+        }\n+\n+        @Override\n+        public String getSeparator() {\n+            return delegate.getSeparator();\n+        }\n+\n+        @Override\n+        public Iterable<Path> getRootDirectories() {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public Iterable<FileStore> getFileStores() {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public Set<String> supportedFileAttributeViews() {\n+            return delegate.supportedFileAttributeViews();\n+        }\n+\n+        @Override\n+        public Path getPath(String first, String... more) {\n+            Path path = delegate.getPath(first, more);\n+            return wrap(path);\n+        }\n+\n+        @Override\n+        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n+            return delegate.getPathMatcher(syntaxAndPattern);\n+        }\n+\n+        @Override\n+        public UserPrincipalLookupService getUserPrincipalLookupService() {\n+            return delegate.getUserPrincipalLookupService();\n+        }\n+\n+        @Override\n+        public WatchService newWatchService() throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class StubPath implements Path {\n+        private final StubFileSystem fs;\n+        private final Path delegate;\n+\n+        StubPath(StubFileSystem fs, Path delegate) {\n+            this.fs = fs;\n+            this.delegate = delegate;\n+        }\n+\n+        Path unwrap() {\n+            return delegate;\n+        }\n+\n+        @Override\n+        public FileSystem getFileSystem() {\n+            return fs;\n+        }\n+\n+        @Override\n+        public boolean isAbsolute() {\n+            return delegate.isAbsolute();\n+        }\n+\n+        @Override\n+        public Path getRoot() {\n+            return fs.wrap(delegate.getRoot());\n+        }\n+\n+        @Override\n+        public Path getParent() {\n+            return fs.wrap(delegate.getParent());\n+        }\n+\n+        @Override\n+        public int getNameCount() {\n+            return delegate.getNameCount();\n+        }\n+\n+        @Override\n+        public Path getFileName() {\n+            return fs.wrap(delegate.getFileName());\n+        }\n+\n+        @Override\n+        public Path getName(int index) {\n+            return fs.wrap(delegate.getName(index));\n+        }\n+\n+        @Override\n+        public Path subpath(int beginIndex, int endIndex) {\n+            return fs.wrap(delegate.subpath(beginIndex, endIndex));\n+        }\n+\n+        @Override\n+        public boolean startsWith(Path other) {\n+            return delegate.startsWith(fs.unwrap(other));\n+        }\n+\n+        @Override\n+        public boolean startsWith(String other) {\n+            return delegate.startsWith(other);\n+        }\n+\n+        @Override\n+        public boolean endsWith(Path other) {\n+            return delegate.endsWith(fs.unwrap(other));\n+        }\n+\n+        @Override\n+        public boolean endsWith(String other) {\n+            return delegate.endsWith(other);\n+        }\n+\n+        @Override\n+        public Path normalize() {\n+            return fs.wrap(delegate.normalize());\n+        }\n+\n+        @Override\n+        public Path resolve(Path other) {\n+            return fs.wrap(delegate.resolve(fs.unwrap(other)));\n+        }\n+\n+        @Override\n+        public Path resolve(String other) {\n+            return fs.wrap(delegate.resolve(other));\n+        }\n+\n+        @Override\n+        public Path resolveSibling(Path other) {\n+            return fs.wrap(delegate.resolveSibling(fs.unwrap(other)));\n+        }\n+\n+        @Override\n+        public Path resolveSibling(String other) {\n+            return fs.wrap(delegate.resolveSibling(other));\n+        }\n+\n+        @Override\n+        public Path relativize(Path other) {\n+            return fs.wrap(delegate.relativize(fs.unwrap(other)));\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (!(other instanceof StubPath))\n+                return false;\n+            return delegate.equals(fs.unwrap((StubPath) other));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return delegate.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return delegate.toString();\n+        }\n+\n+        @Override\n+        public URI toUri() {\n+            String ssp = delegate.toUri().getSchemeSpecificPart();\n+            return URI.create(fs.provider().getScheme() + \":\" + ssp);\n+        }\n+\n+        @Override\n+        public Path toAbsolutePath() {\n+            return fs.wrap(delegate.toAbsolutePath());\n+        }\n+\n+        @Override\n+        public Path toRealPath(LinkOption... options) throws IOException {\n+            return fs.wrap(delegate.toRealPath(options));\n+        }\n+\n+        @Override\n+        public File toFile() {\n+            return new File(toString());\n+        }\n+\n+        @Override\n+        public Iterator<Path> iterator() {\n+            final Iterator<Path> itr = delegate.iterator();\n+            return new Iterator<>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return itr.hasNext();\n+                }\n+\n+                @Override\n+                public Path next() {\n+                    return fs.wrap(itr.next());\n+                }\n+\n+                @Override\n+                public void remove() {\n+                    itr.remove();\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public int compareTo(Path other) {\n+            return delegate.compareTo(fs.unwrap(other));\n+        }\n+\n+        @Override\n+        public WatchKey register(WatchService watcher,\n+                                 WatchEvent.Kind<?>[] events,\n+                                 WatchEvent.Modifier... modifiers)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public  WatchKey register(WatchService watcher,\n+                                  WatchEvent.Kind<?>... events)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class StubAttributes implements BasicFileAttributes {\n+\n+        @Override\n+        public FileTime lastModifiedTime() {\n+            return null;\n+        }\n+\n+        @Override\n+        public FileTime lastAccessTime() {\n+            return null;\n+        }\n+\n+        @Override\n+        public FileTime creationTime() {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean isRegularFile() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isDirectory() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isSymbolicLink() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isOther() {\n+            return false;\n+        }\n+\n+        @Override\n+        public long size() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public Object fileKey() {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/spi\/StubFSProvider.java","additions":525,"deletions":0,"binary":false,"changes":525,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+\/**\n+ * @test\n+ * @summary Verifies that a FileSystemProvider's implementation of the exists\n+ * and readAttributesIfExists methods are invoked\n+ * @build TestOverRideFSPMethods StubFSProvider\n+ * @run testng\/othervm -Djava.nio.file.spi.DefaultFileSystemProvider=StubFSProvider TestOverRideFSPMethods\n+ *\/\n+public class TestOverRideFSPMethods {\n+\n+    \/\/ Non-existent Path to be used by the tests\n+    static final Path STUB_PATH = Path.of(\"fileThatDoesNotExist.txt\");\n+\n+    \/**\n+     * Validate that the Provider's version of exists() is invoked\n+     * The StubFSProvider will always return true\n+     *\/\n+    @Test\n+    public void TestExists() {\n+        var fsp = FileSystems.getDefault().provider();\n+        assertTrue(fsp.exists(STUB_PATH));\n+        \/\/ Now check via Files::exists\n+        assertTrue(Files.exists(STUB_PATH));\n+    }\n+\n+    \/**\n+     * Validate that the Provider's version of readAttributesIfExists() is invoked.\n+     *\n+     * The StubFSProvider will return an instance of\n+     * StubFSProvider.StubAttributes when readAttributesIfExists()\n+     * is called\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void TestReadAttributesIfExists() throws IOException {\n+        var fsp = FileSystems.getDefault().provider();\n+        var attrs = fsp.readAttributesIfExists(STUB_PATH,\n+                BasicFileAttributes.class);\n+        \/\/ This should always be true if the StubFSProvider is used\n+        assertTrue(attrs instanceof StubFSProvider.StubAttributes);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/spi\/TestOverRideFSPMethods.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}