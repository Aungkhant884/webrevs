{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1183,2 +1183,2 @@\n-     *  {@link #readAttributes(Path, Class, LinkOption...)} is called\n-     *  to determine whether a file exists.\n+     * {@link #readAttributes(Path, Class, LinkOption...)} is called\n+     * to determine whether a file exists.\n@@ -1236,1 +1236,1 @@\n-     *  @implSpec\n+     * @implSpec\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/spi\/FileSystemProvider.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractFileSystemProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,1 +306,0 @@\n-                    default -> throw new AssertionError(\"Should not get here\");\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUriUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,0 +297,1 @@\n+    @SuppressWarnings(\"unchecked\") \/\/ Cast to A\n@@ -302,1 +303,1 @@\n-        return exists(path) ? readAttributes(path, type, options) : null;\n+        return (A) toZipPath(path).readAttributesIfExists();\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystemProvider.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -845,0 +845,4 @@\n+    ZipFileAttributes readAttributesIfExists() throws IOException {\n+        return zfs.getFileAttributes(getResolvedPath());\n+    }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,525 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.*;\n+import java.nio.file.attribute.*;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/**\n+ * StubFSProvider provides limited implementations of:\n+ * BasicAttributes:     BasicAttributes\n+ * FileSystemProvider:  StubFSProvider\n+ * FileSystem:          StubFileSystem\n+ * Path:                StubPath\n+ *\n+ * These classes are used by the test TestOverRideFSPMethods\n+ *\/\n+public class StubFSProvider extends FileSystemProvider {\n+\n+    private final StubFileSystem theFileSystem;\n+\n+    public StubFSProvider(FileSystemProvider defaultProvider) {\n+        FileSystem fs = defaultProvider.getFileSystem(URI.create(\"file:\/\"));\n+        this.theFileSystem = new StubFileSystem(fs, this);\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        return \"file\";\n+    }\n+\n+    @Override\n+    public FileSystem newFileSystem(URI uri, Map<String,?> env) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public FileSystem getFileSystem(URI uri) {\n+        return theFileSystem;\n+    }\n+\n+    @Override\n+    public Path getPath(URI uri) {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void setAttribute(Path file, String attribute, Object value,\n+                             LinkOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public Map<String,Object> readAttributes(Path file, String attributes,\n+                                             LinkOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public <A extends BasicFileAttributes> A readAttributes(Path file,\n+                                                            Class<A> type,\n+                                                            LinkOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                    Class<A> type,\n+                                                                    LinkOption... options)\n+            throws IOException {\n+        return (A) new StubAttributes();\n+    }\n+\n+    @Override\n+    public <V extends FileAttributeView> V getFileAttributeView(Path file,\n+                                                                Class<V> type,\n+                                                                LinkOption... options)\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void delete(Path file) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void createLink(Path link, Path existing) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public Path readSymbolicLink(Path link) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void copy(Path source, Path target, CopyOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void move(Path source, Path target, CopyOption... options)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public DirectoryStream<Path> newDirectoryStream(Path dir,\n+                                                    DirectoryStream.Filter<? super Path> filter)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void createDirectory(Path dir, FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public boolean exists(Path path, LinkOption... options) {\n+        var fs = path.getFileSystem();\n+        return ((fs instanceof StubFileSystem)\n+        && (fs.provider() instanceof StubFSProvider));\n+    }\n+\n+    @Override\n+    public SeekableByteChannel newByteChannel(Path file,\n+                                              Set<? extends OpenOption> options,\n+                                              FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public FileChannel newFileChannel(Path file,\n+                                      Set<? extends OpenOption> options,\n+                                      FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public boolean isHidden(Path file) throws IOException {\n+        throw new ReadOnlyFileSystemException();\n+    }\n+\n+    @Override\n+    public FileStore getFileStore(Path file) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public boolean isSameFile(Path file, Path other) throws IOException {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    @Override\n+    public void checkAccess(Path file, AccessMode... modes)\n+        throws IOException\n+    {\n+        throw new RuntimeException(\"not implemented\");\n+    }\n+\n+    static class StubFileSystem extends FileSystem {\n+        private final FileSystem delegate;\n+        private final StubFSProvider provider;\n+\n+        StubFileSystem(FileSystem delegate, StubFSProvider provider) {\n+            this.delegate = delegate;\n+            this.provider = provider;\n+        }\n+\n+        Path wrap(Path path) {\n+            return (path != null) ? new StubPath(this, path) : null;\n+        }\n+\n+        Path unwrap(Path wrapper) {\n+            if (wrapper == null)\n+                throw new NullPointerException();\n+            if (!(wrapper instanceof StubPath))\n+                throw new ProviderMismatchException();\n+            return ((StubPath)wrapper).unwrap();\n+        }\n+\n+        @Override\n+        public FileSystemProvider provider() {\n+            return provider;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isReadOnly() {\n+            return false;\n+        }\n+\n+        @Override\n+        public String getSeparator() {\n+            return delegate.getSeparator();\n+        }\n+\n+        @Override\n+        public Iterable<Path> getRootDirectories() {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public Iterable<FileStore> getFileStores() {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public Set<String> supportedFileAttributeViews() {\n+            return delegate.supportedFileAttributeViews();\n+        }\n+\n+        @Override\n+        public Path getPath(String first, String... more) {\n+            Path path = delegate.getPath(first, more);\n+            return wrap(path);\n+        }\n+\n+        @Override\n+        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n+            return delegate.getPathMatcher(syntaxAndPattern);\n+        }\n+\n+        @Override\n+        public UserPrincipalLookupService getUserPrincipalLookupService() {\n+            return delegate.getUserPrincipalLookupService();\n+        }\n+\n+        @Override\n+        public WatchService newWatchService() throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class StubPath implements Path {\n+        private final StubFileSystem fs;\n+        private final Path delegate;\n+\n+        StubPath(StubFileSystem fs, Path delegate) {\n+            this.fs = fs;\n+            this.delegate = delegate;\n+        }\n+\n+        Path unwrap() {\n+            return delegate;\n+        }\n+\n+        @Override\n+        public FileSystem getFileSystem() {\n+            return fs;\n+        }\n+\n+        @Override\n+        public boolean isAbsolute() {\n+            return delegate.isAbsolute();\n+        }\n+\n+        @Override\n+        public Path getRoot() {\n+            return fs.wrap(delegate.getRoot());\n+        }\n+\n+        @Override\n+        public Path getParent() {\n+            return fs.wrap(delegate.getParent());\n+        }\n+\n+        @Override\n+        public int getNameCount() {\n+            return delegate.getNameCount();\n+        }\n+\n+        @Override\n+        public Path getFileName() {\n+            return fs.wrap(delegate.getFileName());\n+        }\n+\n+        @Override\n+        public Path getName(int index) {\n+            return fs.wrap(delegate.getName(index));\n+        }\n+\n+        @Override\n+        public Path subpath(int beginIndex, int endIndex) {\n+            return fs.wrap(delegate.subpath(beginIndex, endIndex));\n+        }\n+\n+        @Override\n+        public boolean startsWith(Path other) {\n+            return delegate.startsWith(fs.unwrap(other));\n+        }\n+\n+        @Override\n+        public boolean startsWith(String other) {\n+            return delegate.startsWith(other);\n+        }\n+\n+        @Override\n+        public boolean endsWith(Path other) {\n+            return delegate.endsWith(fs.unwrap(other));\n+        }\n+\n+        @Override\n+        public boolean endsWith(String other) {\n+            return delegate.endsWith(other);\n+        }\n+\n+        @Override\n+        public Path normalize() {\n+            return fs.wrap(delegate.normalize());\n+        }\n+\n+        @Override\n+        public Path resolve(Path other) {\n+            return fs.wrap(delegate.resolve(fs.unwrap(other)));\n+        }\n+\n+        @Override\n+        public Path resolve(String other) {\n+            return fs.wrap(delegate.resolve(other));\n+        }\n+\n+        @Override\n+        public Path resolveSibling(Path other) {\n+            return fs.wrap(delegate.resolveSibling(fs.unwrap(other)));\n+        }\n+\n+        @Override\n+        public Path resolveSibling(String other) {\n+            return fs.wrap(delegate.resolveSibling(other));\n+        }\n+\n+        @Override\n+        public Path relativize(Path other) {\n+            return fs.wrap(delegate.relativize(fs.unwrap(other)));\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (!(other instanceof StubPath))\n+                return false;\n+            return delegate.equals(fs.unwrap((StubPath) other));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return delegate.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return delegate.toString();\n+        }\n+\n+        @Override\n+        public URI toUri() {\n+            String ssp = delegate.toUri().getSchemeSpecificPart();\n+            return URI.create(fs.provider().getScheme() + \":\" + ssp);\n+        }\n+\n+        @Override\n+        public Path toAbsolutePath() {\n+            return fs.wrap(delegate.toAbsolutePath());\n+        }\n+\n+        @Override\n+        public Path toRealPath(LinkOption... options) throws IOException {\n+            return fs.wrap(delegate.toRealPath(options));\n+        }\n+\n+        @Override\n+        public File toFile() {\n+            return new File(toString());\n+        }\n+\n+        @Override\n+        public Iterator<Path> iterator() {\n+            final Iterator<Path> itr = delegate.iterator();\n+            return new Iterator<>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return itr.hasNext();\n+                }\n+\n+                @Override\n+                public Path next() {\n+                    return fs.wrap(itr.next());\n+                }\n+\n+                @Override\n+                public void remove() {\n+                    itr.remove();\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public int compareTo(Path other) {\n+            return delegate.compareTo(fs.unwrap(other));\n+        }\n+\n+        @Override\n+        public WatchKey register(WatchService watcher,\n+                                 WatchEvent.Kind<?>[] events,\n+                                 WatchEvent.Modifier... modifiers)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public  WatchKey register(WatchService watcher,\n+                                  WatchEvent.Kind<?>... events)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class StubAttributes implements BasicFileAttributes {\n+\n+        @Override\n+        public FileTime lastModifiedTime() {\n+            return null;\n+        }\n+\n+        @Override\n+        public FileTime lastAccessTime() {\n+            return null;\n+        }\n+\n+        @Override\n+        public FileTime creationTime() {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean isRegularFile() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isDirectory() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isSymbolicLink() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isOther() {\n+            return false;\n+        }\n+\n+        @Override\n+        public long size() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public Object fileKey() {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/spi\/StubFSProvider.java","additions":525,"deletions":0,"binary":false,"changes":525,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+\/**\n+ * @test\n+ * @summary Verifies that a FileSystemProvider's implementation of the exists\n+ * and readAttributesIfExists methods are invoked\n+ * @build TestOverRideFSPMethods StubFSProvider\n+ * @run testng\/othervm -Djava.nio.file.spi.DefaultFileSystemProvider=StubFSProvider TestOverRideFSPMethods\n+ *\/\n+public class TestOverRideFSPMethods {\n+\n+    \/\/ Non-existent Path to be used by the tests\n+    static final Path STUB_PATH = Path.of(\"fileThatDoesNotExist.txt\");\n+\n+    \/**\n+     * Validate that the Provider's version of exists() is invoked\n+     * The StubFSProvider will always return true\n+     *\/\n+    @Test\n+    public void TestExists() {\n+        var fsp = FileSystems.getDefault().provider();\n+        assertTrue(fsp.exists(STUB_PATH));\n+        \/\/ Now check via Files::exists\n+        assertTrue(Files.exists(STUB_PATH));\n+    }\n+\n+    \/**\n+     * Validate that the Provider's version of readAttributesIfExists() is invoked.\n+     *\n+     * The StubFSProvider will return an instance of\n+     * StubFSProvider.StubAttributes when readAttributesIfExists()\n+     * is called\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void TestReadAttributesIfExists() throws IOException {\n+        var fsp = FileSystems.getDefault().provider();\n+        var attrs = fsp.readAttributesIfExists(STUB_PATH,\n+                BasicFileAttributes.class);\n+        \/\/ This should always be true if the StubFSProvider is used\n+        assertTrue(attrs instanceof StubFSProvider.StubAttributes);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/spi\/TestOverRideFSPMethods.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}