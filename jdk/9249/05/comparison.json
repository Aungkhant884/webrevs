{"files":[{"patch":"@@ -83,1 +83,0 @@\n-import sun.nio.fs.AbstractFileSystemProvider;\n@@ -1597,1 +1596,1 @@\n-             InputStream in2 = Files.newInputStream(path2);) {\n+             InputStream in2 = Files.newInputStream(path2)) {\n@@ -2313,6 +2312,0 @@\n-        if (options.length == 0) {\n-            FileSystemProvider provider = provider(path);\n-            if (provider instanceof AbstractFileSystemProvider)\n-                return ((AbstractFileSystemProvider)provider).isDirectory(path);\n-        }\n-\n@@ -2320,1 +2313,3 @@\n-            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();\n+            var attrs = provider(path)\n+                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n+            return (attrs != null) && attrs.isDirectory();\n@@ -2356,6 +2351,0 @@\n-        if (options.length == 0) {\n-            FileSystemProvider provider = provider(path);\n-            if (provider instanceof AbstractFileSystemProvider)\n-                return ((AbstractFileSystemProvider)provider).isRegularFile(path);\n-        }\n-\n@@ -2363,1 +2352,3 @@\n-            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();\n+            var attrs = provider(path)\n+                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n+            return (attrs != null) && attrs.isRegularFile();\n@@ -2505,1 +2496,1 @@\n-     * .\n+     *\n@@ -2518,21 +2509,1 @@\n-        if (options.length == 0) {\n-            FileSystemProvider provider = provider(path);\n-            if (provider instanceof AbstractFileSystemProvider)\n-                return ((AbstractFileSystemProvider)provider).exists(path);\n-        }\n-\n-        try {\n-            if (followLinks(options)) {\n-                provider(path).checkAccess(path);\n-            } else {\n-                \/\/ attempt to read attributes without following links\n-                readAttributes(path, BasicFileAttributes.class,\n-                               LinkOption.NOFOLLOW_LINKS);\n-            }\n-            \/\/ file exists\n-            return true;\n-        } catch (IOException x) {\n-            \/\/ does not exist or unable to determine if file exists\n-            return false;\n-        }\n-\n+        return provider(path).exists(path, options);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":9,"deletions":38,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1173,0 +1173,118 @@\n+\n+    \/**\n+     * Tests whether a file exists. This method works in exactly the\n+     * manner specified by the {@link Files#exists(Path, LinkOption...)} method.\n+     *\n+     * @implSpec\n+     * The default implementation of this method invokes the\n+     * {@link #checkAccess(Path, AccessMode...)} method when symbolic links\n+     * are followed. If the option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS}\n+     * is present then symbolic links are not followed and the method\n+     * {@link #readAttributes(Path, Class, LinkOption...)} is called\n+     * to determine whether a file exists.\n+     *\n+     * @param   path\n+     *          the path to the file to test\n+     * @param   options\n+     *          options indicating how symbolic links are handled\n+     *\n+     * @return  {@code true} if the file exists; {@code false} if the file does\n+     *          not exist or its existence cannot be determined.\n+     *\n+     * @throws  SecurityException\n+     *          In the case of the default provider, the {@link\n+     *          SecurityManager#checkRead(String)} is invoked to check\n+     *          read access to the file.\n+     *\n+     * @since 20\n+     *\/\n+    public boolean exists(Path path, LinkOption... options) {\n+        try {\n+            if (followLinks(options)) {\n+                this.checkAccess(path);\n+            } else {\n+                \/\/ attempt to read attributes without following links\n+                readAttributes(path, BasicFileAttributes.class,  LinkOption.NOFOLLOW_LINKS);\n+            }\n+            \/\/ file exists\n+            return true;\n+        } catch (IOException x) {\n+            \/\/ does not exist or unable to determine if file exists\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Reads a file's attributes as a bulk operation if it exists.\n+     *\n+     * <p> The {@code type} parameter is the type of the attributes required\n+     * and this method returns an instance of that type if supported. All\n+     * implementations support a basic set of file attributes and so invoking\n+     * this method with a  {@code type} parameter of {@code\n+     * BasicFileAttributes.class} will not throw {@code\n+     * UnsupportedOperationException}.\n+     *\n+     * <p> The {@code options} array may be used to indicate how symbolic links\n+     * are handled for the case that the file is a symbolic link. By default,\n+     * symbolic links are followed and the file attribute of the final target\n+     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n+     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n+     *\n+     * <p> It is implementation specific if all file attributes are read as an\n+     * atomic operation with respect to other file system operations.\n+     *\n+     * @implSpec\n+     * The default implementation of this method invokes the\n+     * {@link #readAttributes(Path, Class, LinkOption...)} method\n+     * to read the file's attributes.\n+     *\n+     * @param   <A>\n+     *          The {@code BasicFileAttributes} type\n+     * @param   path\n+     *          the path to the file\n+     * @param   type\n+     *          the {@code Class} of the file attributes required\n+     *          to read\n+     * @param   options\n+     *          options indicating how symbolic links are handled\n+     *\n+     * @return  the file attributes or null if the file does not exist\n+     *\n+     * @throws  UnsupportedOperationException\n+     *          if an attributes of the given type are not supported\n+     * @throws  IOException\n+     *          if an I\/O error occurs\n+     * @throws  SecurityException\n+     *          In the case of the default provider, a security manager is\n+     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n+     *          method is invoked to check read access to the file. If this\n+     *          method is invoked to read security sensitive attributes then the\n+     *          security manager may be invoked to check for additional permissions.\n+     *\n+     * @since 20\n+     *\/\n+    public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                    Class<A> type,\n+                                                                    LinkOption... options)\n+        throws IOException\n+    {\n+        try {\n+            return readAttributes(path, type, options);\n+        } catch (NoSuchFileException ignore) {\n+            return null;\n+        }\n+    }\n+\n+    private static boolean followLinks(LinkOption... options) {\n+        boolean followLinks = true;\n+        for (LinkOption opt: options) {\n+            if (opt == LinkOption.NOFOLLOW_LINKS) {\n+                followLinks = false;\n+                continue;\n+            }\n+            if (opt == null)\n+                throw new NullPointerException();\n+            throw new AssertionError(\"Should not get here\");\n+        }\n+        return followLinks;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/spi\/FileSystemProvider.java","additions":119,"deletions":1,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n@@ -113,45 +112,0 @@\n-    \/**\n-     * Tests whether a file is a directory.\n-     *\n-     * @return  {@code true} if the file is a directory; {@code false} if\n-     *          the file does not exist, is not a directory, or it cannot\n-     *          be determined if the file is a directory or not.\n-     *\/\n-    public boolean isDirectory(Path file) {\n-        try {\n-            return readAttributes(file, BasicFileAttributes.class).isDirectory();\n-        } catch (IOException ioe) {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Tests whether a file is a regular file with opaque content.\n-     *\n-     * @return  {@code true} if the file is a regular file; {@code false} if\n-     *          the file does not exist, is not a regular file, or it\n-     *          cannot be determined if the file is a regular file or not.\n-     *\/\n-    public boolean isRegularFile(Path file) {\n-        try {\n-            return readAttributes(file, BasicFileAttributes.class).isRegularFile();\n-        } catch (IOException ioe) {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Checks the existence of a file.\n-     *\n-     * @return  {@code true} if the file exists; {@code false} if the file does\n-     *          not exist or its existence cannot be determined.\n-     *\/\n-    public boolean exists(Path file) {\n-        try {\n-            checkAccess(file);\n-            return true;\n-        } catch (IOException ioe) {\n-            return false;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractFileSystemProvider.java","additions":1,"deletions":47,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,13 @@\n+    \/\/ get the UnixFileAttributes for a given file. Returns null if the file does not exist.\n+    static UnixFileAttributes getIfExists(UnixPath path) throws UnixException {\n+        UnixFileAttributes attrs = new UnixFileAttributes();\n+        int errno = UnixNativeDispatcher.stat2(path, attrs);\n+        if (errno == 0) {\n+            return attrs;\n+        } else if (errno == UnixConstants.ENOENT) {\n+            return null;\n+        } else {\n+            throw new UnixException(errno);\n+        }\n+    }\n+\n@@ -254,10 +267,0 @@\n-    \/\/ unwrap BasicFileAttributes to get the underlying UnixFileAttributes\n-    \/\/ object. Returns null is not wrapped.\n-    static UnixFileAttributes toUnixFileAttributes(BasicFileAttributes attrs) {\n-        if (attrs instanceof UnixFileAttributes)\n-            return (UnixFileAttributes)attrs;\n-        if (attrs instanceof UnixAsBasicFileAttributes) {\n-            return ((UnixAsBasicFileAttributes)attrs).unwrap();\n-        }\n-        return null;\n-    }\n@@ -277,3 +280,0 @@\n-        UnixFileAttributes unwrap() {\n-            return attrs;\n-        }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributes.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-        return (V) null;\n+        return null;\n@@ -151,0 +151,19 @@\n+    @Override\n+    public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                    Class<A> type,\n+                                                                    LinkOption... options)\n+        throws IOException\n+    {\n+        if (type == BasicFileAttributes.class && Util.followLinks(options)) {\n+            UnixPath file = UnixPath.toUnixPath(path);\n+            try {\n+                @SuppressWarnings(\"unchecked\")\n+                A attrs = (A) UnixFileAttributes.getIfExists(file);\n+                return attrs;\n+            } catch (UnixException e) {\n+                e.rethrowAsIOException(file);\n+            }\n+        }\n+        return super.readAttributesIfExists(path, type, options);\n+    }\n+\n@@ -284,4 +303,3 @@\n-                    case READ : r = true; break;\n-                    case WRITE : w = true; break;\n-                    case EXECUTE : x = true; break;\n-                    default: throw new AssertionError(\"Should not get here\");\n+                    case READ -> r = true;\n+                    case WRITE -> w = true;\n+                    case EXECUTE -> x = true;\n@@ -324,1 +342,1 @@\n-        if (!(obj2 instanceof UnixPath))\n+        if (!(obj2 instanceof UnixPath file2))\n@@ -326,1 +344,0 @@\n-        UnixPath file2 = (UnixPath)obj2;\n@@ -519,14 +536,8 @@\n-    public final boolean isDirectory(Path obj) {\n-        UnixPath file = UnixPath.toUnixPath(obj);\n-        file.checkRead();\n-        int mode = UnixNativeDispatcher.stat(file);\n-        return ((mode & UnixConstants.S_IFMT) == UnixConstants.S_IFDIR);\n-    }\n-\n-    @Override\n-    public final boolean isRegularFile(Path obj) {\n-        UnixPath file = UnixPath.toUnixPath(obj);\n-        file.checkRead();\n-        int mode = UnixNativeDispatcher.stat(file);\n-        return ((mode & UnixConstants.S_IFMT) == UnixConstants.S_IFREG);\n-    }\n+    public boolean exists(Path path, LinkOption... options) {\n+        if (Util.followLinks(options)) {\n+            UnixPath file = UnixPath.toUnixPath(path);\n+            file.checkRead();\n+            return UnixNativeDispatcher.exists(file);\n+        } else {\n+            return super.exists(path, options);\n+        }\n@@ -534,5 +545,0 @@\n-    @Override\n-    public final boolean exists(Path obj) {\n-        UnixPath file = UnixPath.toUnixPath(obj);\n-        file.checkRead();\n-        return UnixNativeDispatcher.exists(file);\n@@ -540,1 +546,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":32,"deletions":27,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -321,1 +321,4 @@\n-                stat0(buffer.address(), attrs);\n+                int errno = stat0(buffer.address(), attrs);\n+                if (errno != 0) {\n+                    throw new UnixException(errno);\n+                }\n@@ -327,3 +330,0 @@\n-    private static native void stat0(long pathAddress, UnixFileAttributes attrs)\n-        throws UnixException;\n-\n@@ -331,6 +331,1 @@\n-    \/**\n-     * stat(const char* path, struct stat* buf)\n-     *\n-     * @return st_mode (file type and mode) or 0 if an error occurs.\n-     *\/\n-    static int stat(UnixPath path) {\n+    static int stat2(UnixPath path, UnixFileAttributes attrs) {\n@@ -340,1 +335,1 @@\n-                return stat1(buffer.address());\n+                return stat0(buffer.address(), attrs);\n@@ -346,1 +341,0 @@\n-    private static native int stat1(long pathAddress);\n@@ -348,0 +342,1 @@\n+    private static native int stat0(long pathAddress, UnixFileAttributes attrs);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,2 +121,3 @@\n-                int mode = UnixNativeDispatcher.stat(up);\n-                if ((mode & UnixConstants.S_IFMT) == UnixConstants.S_IFDIR)\n+                UnixFileAttributes attrs = UnixFileAttributes.getIfExists(up);\n+                if (attrs != null\n+                        && ((attrs.mode() & UnixConstants.S_IFMT) == UnixConstants.S_IFDIR))\n@@ -124,1 +125,1 @@\n-            } catch (SecurityException ignore) { }\n+            } catch (UnixException | SecurityException ignore) { }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUriUtils.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -524,1 +524,1 @@\n-JNIEXPORT void JNICALL\n+JNIEXPORT jint JNICALL\n@@ -533,3 +533,1 @@\n-    if (err == -1) {\n-        throwUnixException(env, errno);\n-    } else {\n+    if (err == 0) {\n@@ -537,11 +535,0 @@\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_UnixNativeDispatcher_stat1(JNIEnv* env, jclass this, jlong pathAddress) {\n-    int err;\n-    struct stat64 buf;\n-    const char* path = (const char*)jlong_to_ptr(pathAddress);\n-\n-    RESTARTABLE(stat64(path, &buf), err);\n-    if (err == -1) {\n@@ -550,1 +537,1 @@\n-        return (jint)buf.st_mode;\n+        return errno;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,9 @@\n+    @Override\n+    public boolean exists(Path path, LinkOption... options) {\n+        if (options.length == 0) {\n+            return toZipPath(path).exists();\n+        } else {\n+            return super.exists(path, options);\n+        }\n+    }\n+\n@@ -285,0 +294,10 @@\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\") \/\/ Cast to A\n+    public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                    Class<A> type,\n+                                                                    LinkOption... options)\n+        throws IOException\n+    {\n+        return (A) toZipPath(path).readAttributesIfExists();\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystemProvider.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-        if (!(other instanceof ZipPath))\n+        if (!(other instanceof final ZipPath o))\n@@ -334,1 +334,0 @@\n-        final ZipPath o = (ZipPath)other;\n@@ -352,1 +351,1 @@\n-        if (!(other instanceof ZipPath))\n+        if (!(other instanceof final ZipPath o))\n@@ -354,1 +353,0 @@\n-        final ZipPath o = (ZipPath)other;\n@@ -385,1 +383,1 @@\n-    public final Path resolveSibling(String other) {\n+    public Path resolveSibling(String other) {\n@@ -390,1 +388,1 @@\n-    public final boolean startsWith(String other) {\n+    public boolean startsWith(String other) {\n@@ -395,1 +393,1 @@\n-    public final boolean endsWith(String other) {\n+    public boolean endsWith(String other) {\n@@ -674,1 +672,1 @@\n-    public final File toFile() {\n+    public File toFile() {\n@@ -847,0 +845,4 @@\n+    ZipFileAttributes readAttributesIfExists() throws IOException {\n+        return zfs.getFileAttributes(getResolvedPath());\n+    }\n+\n@@ -904,1 +906,1 @@\n-    private boolean exists() {\n+    boolean exists() {\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+\/**\n+ * @test\n+ * @summary Verifies that a FileSystemProvider's implementation of the exists\n+ * and readAttributesIfExists methods are invoked\n+ * @build TestDelegation TestProvider\n+ * @run testng\/othervm  TestDelegation\n+ *\/\n+public class TestDelegation {\n+\n+    \/\/ Non-existent Path to be used by the test\n+    private Path NON_EXISTENT_FILE;\n+    \/\/ Path to Temp directory used by the test\n+    private Path TEMP_DIRECTORY;\n+    \/\/ Valid file Path used by the test\n+    private Path FILE_THAT_EXISTS;\n+    \/\/ The FileSystemProvider used by the test\n+    private MyProvider PROVIDER;\n+\n+\n+    \/**\n+     * Create the FileSystemProvider, the FileSystem and\n+     * Path's used by the test.\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeClass\n+    public void setup() throws IOException {\n+        PROVIDER = new MyProvider();\n+        FileSystem fs = PROVIDER.getFileSystem(URI.create(\"\/\"));\n+        \/\/ Path to Current Working Directory\n+        Path cwd = fs.getPath(\".\");\n+        TEMP_DIRECTORY = Files.createTempDirectory(cwd, \"tmp\");\n+        FILE_THAT_EXISTS = Files.createFile(TEMP_DIRECTORY.resolve(\"file\"));\n+        NON_EXISTENT_FILE = TEMP_DIRECTORY.resolve(\"doesNotExist\");\n+    }\n+\n+    \/**\n+     * DataProvider that is used to test Files::exists. The DataProvider's\n+     * elements are:\n+     * <UL>\n+     *     <li>Path to validate<\/li>\n+     *     <li>Does the Path Exist<\/li>\n+     * <\/UL>\n+     * @return The test parameter data\n+     *\/\n+    @DataProvider\n+    private Object[][] testExists() {\n+        return new Object[][]{\n+                {TEMP_DIRECTORY, true},\n+                {FILE_THAT_EXISTS, true},\n+                {NON_EXISTENT_FILE, false}\n+        };\n+    }\n+\n+    \/**\n+     * DataProvider that is used to test Files::isDirectory. The DataProvider's\n+     * elements are:\n+     * <UL>\n+     *     <li>Path to validate<\/li>\n+     *     <li>Is the Path a Directory<\/li>\n+     * <\/UL>\n+     * @return The test parameter data\n+     *\/\n+    @DataProvider\n+    private Object[][] testIsDirectory() {\n+        return new Object[][]{\n+                {TEMP_DIRECTORY, true},\n+                {FILE_THAT_EXISTS, false},\n+                {NON_EXISTENT_FILE, false}\n+        };\n+    }\n+    \/**\n+     * DataProvider that is used to test Files::isRegularFile. The DataProvider's\n+     * elements are:\n+     * <UL>\n+     *     <li>Path to validate<\/li>\n+     *     <li>Is the Path a regular file<\/li>\n+     * <\/UL>\n+     * @return The test parameter data\n+     *\/\n+    @DataProvider\n+    private Object[][] testIsRegularFile() {\n+        return new Object[][]{\n+                {TEMP_DIRECTORY, false},\n+                {FILE_THAT_EXISTS, true},\n+                {NON_EXISTENT_FILE, false}\n+        };\n+    }\n+\n+    \/**\n+     * Validate that Files::exists delegates to the FileSystemProvider's\n+     * implementation of exists.\n+     *\n+     * @param p      the path to the file to test\n+     * @param exists does the path exist\n+     *\/\n+    @Test(dataProvider = \"testExists\")\n+    public void testExists(Path p, boolean exists) {\n+        assertEquals(Files.exists(p), exists);\n+        \/\/ We should only have called exists once\n+        assertEquals(1, PROVIDER.findCall(\"exists\").size());\n+        assertEquals(0, PROVIDER.findCall(\"readAttributesIfExists\").size());\n+        PROVIDER.resetCalls();\n+    }\n+\n+    \/**\n+     * Validate that Files::isDirectory delegates to the FileSystemProvider's\n+     * implementation readAttributesIfExists.\n+     *\n+     * @param p      the path to the file to test\n+     * @param isDir  is the path a directory\n+     *\/\n+    @Test(dataProvider = \"testIsDirectory\")\n+    public void testIsDirectory(Path p, boolean isDir) {\n+        assertEquals(Files.isDirectory(p), isDir);\n+        \/\/ We should only have called readAttributesIfExists once\n+        assertEquals(0, PROVIDER.findCall(\"exists\").size());\n+        assertEquals(1, PROVIDER.findCall(\"readAttributesIfExists\").size());\n+        PROVIDER.resetCalls();\n+    }\n+\n+    \/**\n+     * Validate that Files::isRegularFile delegates to the FileSystemProvider's\n+     * implementation readAttributesIfExists.\n+     *\n+     * @param p      the path to the file to test\n+     * @param isFile is the path a regular file\n+     *\/\n+    @Test(dataProvider = \"testIsRegularFile\")\n+    public void testIsRegularFile(Path p, boolean isFile) {\n+        assertEquals(Files.isRegularFile(p), isFile);\n+        \/\/ We should only have called readAttributesIfExists once\n+        assertEquals(0, PROVIDER.findCall(\"exists\").size());\n+        assertEquals(1, PROVIDER.findCall(\"readAttributesIfExists\").size());\n+        PROVIDER.resetCalls();\n+    }\n+\n+    \/**\n+     * The FileSystemProvider implementation used by the test\n+     *\/\n+    static class MyProvider extends TestProvider {\n+        private final Map<String, List<Path>> calls = new HashMap<>();\n+\n+        private MyProvider() {\n+            super(FileSystems.getDefault().provider());\n+        }\n+\n+        private void recordCall(String op, Path path) {\n+            calls.computeIfAbsent(op, k -> new ArrayList<>()).add(path);\n+        }\n+\n+        List<Path> findCall(String op) {\n+            return calls.getOrDefault(op, List.of());\n+        }\n+\n+        void resetCalls() {\n+            calls.clear();\n+        }\n+\n+        @Override\n+        public boolean exists(Path path, LinkOption... options) {\n+            recordCall(\"exists\", path);\n+            return super.exists(path, options);\n+        }\n+\n+        @Override\n+        public <A extends BasicFileAttributes> A readAttributesIfExists(Path path,\n+                                                                        Class<A> type,\n+                                                                        LinkOption... options)\n+                throws IOException {\n+            recordCall(\"readAttributesIfExists\", path);\n+            return super.readAttributesIfExists(path, type, options);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/nio\/file\/spi\/TestDelegation.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.Collections;\n@@ -51,4 +50,0 @@\n-    FileSystemProvider defaultProvider() {\n-        return defaultProvider;\n-    }\n-\n@@ -206,1 +201,2 @@\n-        throw new RuntimeException(\"not implemented\");\n+        Path delegate = theFileSystem.unwrap(file);\n+        defaultProvider.checkAccess(delegate, modes);\n@@ -472,0 +468,1 @@\n+\n","filename":"test\/jdk\/java\/nio\/file\/spi\/TestProvider.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.nio.zipfs;\n+\n+import  org.openjdk.jmh.annotations.*;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Simple benchmark measuring cost of Files::exist, Files::isDirectory and\n+ * Files::isRegularFile with ZipFileSystem.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class ZipfileSystemProviderDelegation {\n+\n+    public static final String ZIP_FILE = \"zipfsprovider-delegation-benchmark.zip\";\n+    public static final String NON_EXISTENT_SUFFIX = \"-nope\";\n+    @Param({\"256\", \"512\"})\n+    private int entriesToTest;\n+    public String[] entries;\n+    private FileSystem zipfs;\n+\n+    private int index = 0;\n+\n+    @Setup\n+    public void setup() throws IOException {\n+        Path zip = Paths.get(ZIP_FILE);\n+        Files.deleteIfExists(zip);\n+        Random random = new Random(4711);\n+        entries = new String[entriesToTest];\n+        URI zipURI = URI.create(\"jar:file:\"+ zip.toAbsolutePath().toString());\n+        Map<String, String> env = new HashMap<>();\n+        env.put(\"create\", \"true\");\n+        zipfs = FileSystems.newFileSystem(zipURI, env);\n+            for (int i = 0; i < entriesToTest; i++) {\n+                Path dir = zipfs.getPath(\"dir-\" + (random.nextInt(90000) + 10000)\n+                        + \"-\" + i);\n+                Files.createDirectory(dir);\n+                Path entry = dir.resolve(\"entry-\" +\n+                        (random.nextInt(90000) + 10000)\n+                        + \"-\" + i);\n+                Files.write(entry, \"\".getBytes(StandardCharsets.UTF_8));\n+                entries[i] = entry.toString();\n+            }\n+    }\n+\n+    @TearDown\n+    public void cleanup() throws IOException {\n+        zipfs.close();\n+        Files.deleteIfExists(Paths.get(ZIP_FILE));\n+    }\n+\n+    @Benchmark\n+    public void existsWithEntry() {\n+        if (index >= entriesToTest) {\n+            index = 0;\n+        }\n+        Files.exists(zipfs.getPath(entries[index++]));\n+    }\n+\n+    @Benchmark\n+    public void existsWithNonExistingEntry() {\n+        if (index >= entriesToTest) {\n+            index = 0;\n+        }\n+        Files.exists(zipfs.getPath(entries[index++] + NON_EXISTENT_SUFFIX));\n+    }\n+\n+    @Benchmark\n+    public void isDirectoryWithEntry() {\n+        if (index >= entriesToTest) {\n+            index = 0;\n+        }\n+        Files.isDirectory(zipfs.getPath(entries[index++]));\n+    }\n+\n+    @Benchmark\n+    public void isDirectoryWithNonExistingEntry() {\n+        if (index >= entriesToTest) {\n+            index = 0;\n+        }\n+        Files.isDirectory(zipfs.getPath(entries[index++] + NON_EXISTENT_SUFFIX));\n+    }\n+\n+    @Benchmark\n+    public void isRegularFileWithEntry() {\n+        if (index >= entriesToTest) {\n+            index = 0;\n+        }\n+        Files.isRegularFile(zipfs.getPath(entries[index++]));\n+    }\n+\n+    @Benchmark\n+    public void isRegularFileWithNonExistingEntry() {\n+        if (index >= entriesToTest) {\n+            index = 0;\n+        }\n+        Files.isRegularFile(zipfs.getPath(entries[index++] + NON_EXISTENT_SUFFIX));\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/nio\/zipfs\/ZipfileSystemProviderDelegation.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}