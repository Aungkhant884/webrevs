{"files":[{"patch":"@@ -34,11 +34,0 @@\n-const int ConcreteRegisterImpl::max_gpr = Register::number_of_registers LP64_ONLY( << 1 );\n-\n-const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::max_gpr +\n-    FloatRegister::number_of_registers * FloatRegister::max_slots_per_register;\n-\n-const int ConcreteRegisterImpl::max_xmm = ConcreteRegisterImpl::max_fpr +\n-    XMMRegister::number_of_registers * XMMRegister::max_slots_per_register;\n-\n-const int ConcreteRegisterImpl::max_kpr = ConcreteRegisterImpl::max_xmm +\n-    KRegister::number_of_registers * KRegister::max_slots_per_register;\n-\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -371,16 +371,17 @@\n-  \/\/ A big enough number for C2: all the registers plus flags\n-  \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n-  \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n-  \/\/ it's optoregs.\n-\n-  \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n-  \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n-  \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n-  \/\/ added for 32 bit jvm.\n-    number_of_registers =\n-        Register::number_of_registers * Register::max_slots_per_register +\n-        FloatRegister::number_of_registers * FloatRegister::max_slots_per_register +\n-        XMMRegister::number_of_registers * XMMRegister::max_slots_per_register +\n-        KRegister::number_of_registers * KRegister::max_slots_per_register + \/\/ mask registers\n-        NOT_LP64( 8 + ) \/\/ FILL0-FILL7 in x86_32.ad\n-        1 \/\/ eflags\n+    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n+    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n+    max_xmm = max_fpr + XMMRegister::number_of_registers * XMMRegister::max_slots_per_register,\n+    max_kpr = max_xmm + KRegister::number_of_registers * KRegister::max_slots_per_register,\n+\n+    \/\/ A big enough number for C2: all the registers plus flags\n+    \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n+    \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n+    \/\/ it's optoregs.\n+\n+    \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n+    \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n+    \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n+    \/\/ added for 32 bit jvm.\n+    number_of_registers = max_kpr +       \/\/ gpr\/fpr\/xmm\/kpr\n+                          NOT_LP64( 8 + ) \/\/ FILL0-FILL7 in x86_32.ad\n+                          1               \/\/ eflags\n@@ -388,5 +389,0 @@\n-\n-  static const int max_gpr;\n-  static const int max_fpr;\n-  static const int max_xmm;\n-  static const int max_kpr;\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"}]}