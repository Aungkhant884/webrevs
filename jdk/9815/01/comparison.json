{"files":[{"patch":"@@ -66,4 +66,4 @@\n-REGISTER_DECLARATION(Register, c_rarg0, rcx);\n-REGISTER_DECLARATION(Register, c_rarg1, rdx);\n-REGISTER_DECLARATION(Register, c_rarg2, r8);\n-REGISTER_DECLARATION(Register, c_rarg3, r9);\n+constexpr Register c_rarg0 = rcx;\n+constexpr Register c_rarg1 = rdx;\n+constexpr Register c_rarg2 =  r8;\n+constexpr Register c_rarg3 =  r9;\n@@ -71,4 +71,4 @@\n-REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);\n+constexpr XMMRegister c_farg0 = xmm0;\n+constexpr XMMRegister c_farg1 = xmm1;\n+constexpr XMMRegister c_farg2 = xmm2;\n+constexpr XMMRegister c_farg3 = xmm3;\n@@ -78,15 +78,15 @@\n-REGISTER_DECLARATION(Register, c_rarg0, rdi);\n-REGISTER_DECLARATION(Register, c_rarg1, rsi);\n-REGISTER_DECLARATION(Register, c_rarg2, rdx);\n-REGISTER_DECLARATION(Register, c_rarg3, rcx);\n-REGISTER_DECLARATION(Register, c_rarg4, r8);\n-REGISTER_DECLARATION(Register, c_rarg5, r9);\n-\n-REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);\n-REGISTER_DECLARATION(XMMRegister, c_farg4, xmm4);\n-REGISTER_DECLARATION(XMMRegister, c_farg5, xmm5);\n-REGISTER_DECLARATION(XMMRegister, c_farg6, xmm6);\n-REGISTER_DECLARATION(XMMRegister, c_farg7, xmm7);\n+constexpr Register c_rarg0 = rdi;\n+constexpr Register c_rarg1 = rsi;\n+constexpr Register c_rarg2 = rdx;\n+constexpr Register c_rarg3 = rcx;\n+constexpr Register c_rarg4 =  r8;\n+constexpr Register c_rarg5 =  r9;\n+\n+constexpr XMMRegister c_farg0 = xmm0;\n+constexpr XMMRegister c_farg1 = xmm1;\n+constexpr XMMRegister c_farg2 = xmm2;\n+constexpr XMMRegister c_farg3 = xmm3;\n+constexpr XMMRegister c_farg4 = xmm4;\n+constexpr XMMRegister c_farg5 = xmm5;\n+constexpr XMMRegister c_farg6 = xmm6;\n+constexpr XMMRegister c_farg7 = xmm7;\n@@ -112,3 +112,3 @@\n-REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);\n-REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);\n-REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);\n+constexpr Register j_rarg0 = c_rarg1;\n+constexpr Register j_rarg1 = c_rarg2;\n+constexpr Register j_rarg2 = c_rarg3;\n@@ -117,2 +117,2 @@\n-REGISTER_DECLARATION(Register, j_rarg3, rdi);\n-REGISTER_DECLARATION(Register, j_rarg4, rsi);\n+constexpr Register j_rarg3 = rdi;\n+constexpr Register j_rarg4 = rsi;\n@@ -120,2 +120,2 @@\n-REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);\n-REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);\n+constexpr Register j_rarg3 = c_rarg4;\n+constexpr Register j_rarg4 = c_rarg5;\n@@ -123,1 +123,1 @@\n-REGISTER_DECLARATION(Register, j_rarg5, c_rarg0);\n+constexpr Register j_rarg5 = c_rarg0;\n@@ -125,8 +125,8 @@\n-REGISTER_DECLARATION(XMMRegister, j_farg0, xmm0);\n-REGISTER_DECLARATION(XMMRegister, j_farg1, xmm1);\n-REGISTER_DECLARATION(XMMRegister, j_farg2, xmm2);\n-REGISTER_DECLARATION(XMMRegister, j_farg3, xmm3);\n-REGISTER_DECLARATION(XMMRegister, j_farg4, xmm4);\n-REGISTER_DECLARATION(XMMRegister, j_farg5, xmm5);\n-REGISTER_DECLARATION(XMMRegister, j_farg6, xmm6);\n-REGISTER_DECLARATION(XMMRegister, j_farg7, xmm7);\n+constexpr XMMRegister j_farg0 = xmm0;\n+constexpr XMMRegister j_farg1 = xmm1;\n+constexpr XMMRegister j_farg2 = xmm2;\n+constexpr XMMRegister j_farg3 = xmm3;\n+constexpr XMMRegister j_farg4 = xmm4;\n+constexpr XMMRegister j_farg5 = xmm5;\n+constexpr XMMRegister j_farg6 = xmm6;\n+constexpr XMMRegister j_farg7 = xmm7;\n@@ -134,2 +134,2 @@\n-REGISTER_DECLARATION(Register, rscratch1, r10);  \/\/ volatile\n-REGISTER_DECLARATION(Register, rscratch2, r11);  \/\/ volatile\n+constexpr Register rscratch1 = r10;  \/\/ volatile\n+constexpr Register rscratch2 = r11;  \/\/ volatile\n@@ -137,2 +137,2 @@\n-REGISTER_DECLARATION(Register, r12_heapbase, r12); \/\/ callee-saved\n-REGISTER_DECLARATION(Register, r15_thread, r15); \/\/ callee-saved\n+constexpr Register r12_heapbase = r12; \/\/ callee-saved\n+constexpr Register r15_thread   = r15; \/\/ callee-saved\n@@ -152,1 +152,1 @@\n-REGISTER_DECLARATION(Register, rbp_mh_SP_save, noreg);\n+constexpr Register rbp_mh_SP_save = noreg;\n@@ -2935,1 +2935,1 @@\n-    _embedded_opmask_register_specifier = (*mask).encoding() & 0x7;\n+    _embedded_opmask_register_specifier = mask->encoding() & 0x7;\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":45,"deletions":45,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n-  pd_nof_cpu_regs_frame_map = RegisterImpl::number_of_registers,       \/\/ number of registers used during code emission\n-  pd_nof_fpu_regs_frame_map = FloatRegisterImpl::number_of_registers,  \/\/ number of registers used during code emission\n-  pd_nof_xmm_regs_frame_map = XMMRegisterImpl::number_of_registers,    \/\/ number of registers used during code emission\n+  pd_nof_cpu_regs_frame_map = Register::number_of_registers,       \/\/ number of registers used during code emission\n+  pd_nof_fpu_regs_frame_map = FloatRegister::number_of_registers,  \/\/ number of registers used during code emission\n+  pd_nof_xmm_regs_frame_map = XMMRegister::number_of_registers,    \/\/ number of registers used during code emission\n","filename":"src\/hotspot\/cpu\/x86\/c1_Defs_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-XMMRegister FrameMap::_xmm_regs [] = { 0, };\n+XMMRegister FrameMap::_xmm_regs[] = {};\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-    return XMMRegisterImpl::available_xmm_registers();\n+    return XMMRegister::available_xmm_registers();\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1956,1 +1956,1 @@\n-    assert(newval != NULL, \"new val must be register\");\n+    assert(newval != noreg, \"new val must be register\");\n@@ -1987,1 +1987,1 @@\n-    assert(newval != NULL, \"new val must be register\");\n+    assert(newval != noreg, \"new val must be register\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  int last_xmm_reg = pd_first_xmm_reg + XMMRegisterImpl::available_xmm_registers() - 1;\n+  int last_xmm_reg = pd_first_xmm_reg + XMMRegister::available_xmm_registers() - 1;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    int delta = XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers;\n+    int delta = XMMRegister::max_slots_per_register * XMMRegister::number_of_registers;\n@@ -50,1 +50,1 @@\n-    int xmm_slots = XMMRegisterImpl::max_slots_per_register;\n+    int xmm_slots = XMMRegister::max_slots_per_register;\n","filename":"src\/hotspot\/cpu\/x86\/c2_init_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  assert(newval != NULL, \"new val must be register\");\n+  assert(newval != noreg, \"new val must be register\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-    assert(res != NULL, \"need result register\");\n+    assert(res != noreg, \"need result register\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_32.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n@@ -107,1 +107,1 @@\n-                                                   NULL, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n+                                                   noreg, $mem_ptr$$Address, $oldval$$Register, $newval$$Register,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-  if (jvmci_reg < RegisterImpl::number_of_registers) {\n+  if (jvmci_reg < Register::number_of_registers) {\n@@ -216,2 +216,2 @@\n-    jint floatRegisterNumber = jvmci_reg - RegisterImpl::number_of_registers;\n-    if (floatRegisterNumber < XMMRegisterImpl::number_of_registers) {\n+    jint floatRegisterNumber = jvmci_reg - Register::number_of_registers;\n+    if (floatRegisterNumber < XMMRegister::number_of_registers) {\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3775,1 +3775,1 @@\n-  int num_xmm_registers = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_registers = XMMRegister::available_xmm_registers();\n@@ -3816,1 +3816,1 @@\n-  gp_area_size = align_up(gp_registers.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size,\n+  gp_area_size = align_up(gp_registers.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size,\n@@ -3909,1 +3909,1 @@\n-    int register_push_size = set.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    int register_push_size = set.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -3919,1 +3919,1 @@\n-    spill_offset += RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    spill_offset += Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -3925,1 +3925,1 @@\n-  int gp_reg_size = RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+  int gp_reg_size = Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-void MacroAssembler::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+void MacroAssembler::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask) {\n@@ -61,1 +61,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_aes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-    const int saved_regs_count = RegisterImpl::number_of_registers;\n+    const int saved_regs_count = Register::number_of_registers;\n@@ -539,1 +539,1 @@\n-      assert(RegisterImpl::number_of_registers == 16, \"sanity\");\n+      assert(Register::number_of_registers == 16, \"sanity\");\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    int base_reg_enc = (reg_base \/ XMMRegisterImpl::max_slots_per_register);\n-    assert(base_reg_enc >= 0 && base_reg_enc < XMMRegisterImpl::number_of_registers, \"invalid XMMRegister: %d\", base_reg_enc);\n+    int base_reg_enc = (reg_base \/ XMMRegister::max_slots_per_register);\n+    assert(base_reg_enc >= 0 && base_reg_enc < XMMRegister::number_of_registers, \"invalid XMMRegister: %d\", base_reg_enc);\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,4 +29,4 @@\n-REGISTER_IMPL_DEFINITION(Register, RegisterImpl, RegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(XMMRegister, XMMRegisterImpl, XMMRegisterImpl::number_of_registers);\n-REGISTER_IMPL_DEFINITION(KRegister, KRegisterImpl, KRegisterImpl::number_of_registers);\n+Register::RegisterImpl           all_RegisterImpls     [Register::number_of_registers      + 1];\n+FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers + 1];\n+XMMRegister::XMMRegisterImpl     all_XMMRegisterImpls  [XMMRegister::number_of_registers   + 1];\n+KRegister::KRegisterImpl         all_KRegisterImpls    [KRegister::number_of_registers     + 1];\n@@ -34,14 +34,1 @@\n-#ifndef AMD64\n-const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers;\n-#else\n-const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers << 1;\n-#endif \/\/ AMD64\n-\n-const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::max_gpr +\n-    2 * FloatRegisterImpl::number_of_registers;\n-const int ConcreteRegisterImpl::max_xmm = ConcreteRegisterImpl::max_fpr +\n-    XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers;\n-const int ConcreteRegisterImpl::max_kpr = ConcreteRegisterImpl::max_xmm +\n-    KRegisterImpl::max_slots_per_register * KRegisterImpl::number_of_registers;\n-\n-const char* RegisterImpl::name() const {\n+const char * Register::RegisterImpl::name() const {\n@@ -49,3 +36,1 @@\n-#ifndef AMD64\n-    \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"\n-#else\n+#ifdef _LP64\n@@ -54,1 +39,3 @@\n-#endif \/\/ AMD64\n+#else\n+    \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"\n+#endif \/\/ _LP64\n@@ -59,1 +46,1 @@\n-const char* FloatRegisterImpl::name() const {\n+const char* FloatRegister::FloatRegisterImpl::name() const {\n@@ -63,1 +50,1 @@\n-  return is_valid() ? names[encoding()] : \"noreg\";\n+  return is_valid() ? names[encoding()] : \"fnoreg\";\n@@ -66,1 +53,1 @@\n-const char* XMMRegisterImpl::name() const {\n+const char* XMMRegister::XMMRegisterImpl::name() const {\n@@ -68,2 +55,2 @@\n-    \"xmm0\",\"xmm1\",\"xmm2\",\"xmm3\",\"xmm4\",\"xmm5\",\"xmm6\",\"xmm7\"\n-#ifdef AMD64\n+    \"xmm0\",    \"xmm1\",  \"xmm2\",  \"xmm3\",  \"xmm4\",  \"xmm5\",  \"xmm6\",  \"xmm7\"\n+#ifdef _LP64\n@@ -73,1 +60,1 @@\n-#endif \/\/ AMD64\n+#endif \/\/ _LP64\n@@ -78,26 +65,1 @@\n-const char* XMMRegisterImpl::sub_word_name(int i) const {\n-  const char* names[number_of_registers * 8] = {\n-      \"xmm0:0\", \"xmm0:1\", \"xmm0:2\", \"xmm0:3\", \"xmm0:4\", \"xmm0:5\", \"xmm0:6\", \"xmm0:7\",\n-      \"xmm1:0\", \"xmm1:1\", \"xmm1:2\", \"xmm1:3\", \"xmm1:4\", \"xmm1:5\", \"xmm1:6\", \"xmm1:7\",\n-      \"xmm2:0\", \"xmm2:1\", \"xmm2:2\", \"xmm2:3\", \"xmm2:4\", \"xmm2:5\", \"xmm2:6\", \"xmm2:7\",\n-      \"xmm3:0\", \"xmm3:1\", \"xmm3:2\", \"xmm3:3\", \"xmm3:4\", \"xmm3:5\", \"xmm3:6\", \"xmm3:7\",\n-      \"xmm4:0\", \"xmm4:1\", \"xmm4:2\", \"xmm4:3\", \"xmm4:4\", \"xmm4:5\", \"xmm4:6\", \"xmm4:7\",\n-      \"xmm5:0\", \"xmm5:1\", \"xmm5:2\", \"xmm5:3\", \"xmm5:4\", \"xmm5:5\", \"xmm5:6\", \"xmm5:7\",\n-      \"xmm6:0\", \"xmm6:1\", \"xmm6:2\", \"xmm6:3\", \"xmm6:4\", \"xmm6:5\", \"xmm6:6\", \"xmm6:7\",\n-      \"xmm7:0\", \"xmm7:1\", \"xmm7:2\", \"xmm7:3\", \"xmm7:4\", \"xmm7:5\", \"xmm7:6\", \"xmm7:7\",\n-#ifdef AMD64\n-      \"xmm8:0\", \"xmm8:1\", \"xmm8:2\", \"xmm8:3\", \"xmm8:4\", \"xmm8:5\", \"xmm8:6\", \"xmm8:7\",\n-      \"xmm9:0\", \"xmm9:1\", \"xmm9:2\", \"xmm9:3\", \"xmm9:4\", \"xmm9:5\", \"xmm9:6\", \"xmm9:7\",\n-      \"xmm10:0\", \"xmm10:1\", \"xmm10:2\", \"xmm10:3\", \"xmm10:4\", \"xmm10:5\", \"xmm10:6\", \"xmm10:7\",\n-      \"xmm11:0\", \"xmm11:1\", \"xmm11:2\", \"xmm11:3\", \"xmm11:4\", \"xmm11:5\", \"xmm11:6\", \"xmm11:7\",\n-      \"xmm12:0\", \"xmm12:1\", \"xmm12:2\", \"xmm12:3\", \"xmm12:4\", \"xmm12:5\", \"xmm12:6\", \"xmm12:7\",\n-      \"xmm13:0\", \"xmm13:1\", \"xmm13:2\", \"xmm13:3\", \"xmm13:4\", \"xmm13:5\", \"xmm13:6\", \"xmm13:7\",\n-      \"xmm14:0\", \"xmm14:1\", \"xmm14:2\", \"xmm14:3\", \"xmm14:4\", \"xmm14:5\", \"xmm14:6\", \"xmm14:7\",\n-      \"xmm15:0\", \"xmm15:1\", \"xmm15:2\", \"xmm15:3\", \"xmm15:4\", \"xmm15:5\", \"xmm15:6\", \"xmm15:7\",\n-#endif \/\/ AMD64\n-  };\n-  assert(i >= 0 && i < 8, \"offset too large\");\n-  return is_valid() ? names[encoding() * 8 + i] : \"xnoreg\";\n-}\n-\n-const char* KRegisterImpl::name() const {\n+const char* KRegister::KRegisterImpl::name() const {\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.cpp","additions":16,"deletions":54,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -36,3 +36,4 @@\n-\/\/ Use Register as shortcut\n-class RegisterImpl;\n-typedef RegisterImpl* Register;\n+\/\/ The implementation of integer registers for the x86\/x64 architectures.\n+class Register {\n+private:\n+  int _encoding;\n@@ -40,6 +41,1 @@\n-\/\/ The implementation of integer registers for the ia32 architecture\n-\n-inline constexpr Register as_Register(int encoding);\n-\n-class RegisterImpl: public AbstractRegisterImpl {\n-  static constexpr Register first();\n+  constexpr Register(int encoding, bool unused) : _encoding(encoding) {}\n@@ -48,0 +44,2 @@\n+  inline friend constexpr Register as_Register(int encoding);\n+\n@@ -49,9 +47,3 @@\n-#ifndef AMD64\n-    number_of_registers      = 8,\n-    number_of_byte_registers = 4,\n-    max_slots_per_register   = 1\n-#else\n-    number_of_registers      = 16,\n-    number_of_byte_registers = 16,\n-    max_slots_per_register   = 2\n-#endif \/\/ AMD64\n+    number_of_registers      = LP64_ONLY( 16 ) NOT_LP64( 8 ),\n+    number_of_byte_registers = LP64_ONLY( 16 ) NOT_LP64( 4 ),\n+    max_slots_per_register   = LP64_ONLY(  2 ) NOT_LP64( 1 )\n@@ -60,2 +52,19 @@\n-  \/\/ derived registers, offsets, and addresses\n-  Register successor() const                          { return as_Register(encoding() + 1); }\n+  class RegisterImpl: public AbstractRegisterImpl {\n+    friend class Register;\n+\n+    static constexpr RegisterImpl* first();\n+\n+  public:\n+    \/\/ accessors\n+    int   raw_encoding() const      { return this - first(); }\n+    int   encoding() const          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    bool  has_byte_register() const { return 0 <= raw_encoding() && raw_encoding() < number_of_byte_registers; }\n+\n+    \/\/ derived registers, offsets, and addresses\n+    inline Register successor() const;\n+\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n@@ -63,2 +72,1 @@\n-  \/\/ construction\n-  inline constexpr friend Register as_Register(int encoding);\n+  constexpr Register() : _encoding(-1) {} \/\/ noreg\n@@ -66,1 +74,2 @@\n-  inline VMReg as_VMReg() const;\n+  int operator==(const Register r) const { return _encoding == r._encoding; }\n+  int operator!=(const Register r) const { return _encoding != r._encoding; }\n@@ -68,6 +77,1 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                     { return this - first(); }\n-  int   encoding() const                         { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                         { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  bool  has_byte_register() const                { return 0 <= raw_encoding() && raw_encoding() < number_of_byte_registers; }\n-  const char *name() const;\n+  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -76,1 +80,1 @@\n-REGISTER_IMPL_DECLARATION(Register, RegisterImpl, RegisterImpl::number_of_registers);\n+extern Register::RegisterImpl all_RegisterImpls[Register::number_of_registers + 1] INTERNAL_VISIBILITY;\n@@ -78,1 +82,5 @@\n-\/\/ The integer registers of the ia32\/amd64 architecture\n+inline constexpr Register::RegisterImpl* Register::RegisterImpl::first() {\n+  return all_RegisterImpls + 1;\n+}\n+\n+constexpr Register noreg = Register();\n@@ -80,1 +88,6 @@\n-CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));\n+inline constexpr Register as_Register(int encoding) {\n+  if (0 <= encoding && encoding < Register::number_of_registers) {\n+    return Register(encoding, false);\n+  }\n+  return noreg;\n+}\n@@ -82,0 +95,4 @@\n+inline Register Register::RegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_Register(encoding() + 1);\n+}\n@@ -83,18 +100,18 @@\n-CONSTANT_REGISTER_DECLARATION(Register, rax,    (0));\n-CONSTANT_REGISTER_DECLARATION(Register, rcx,    (1));\n-CONSTANT_REGISTER_DECLARATION(Register, rdx,    (2));\n-CONSTANT_REGISTER_DECLARATION(Register, rbx,    (3));\n-CONSTANT_REGISTER_DECLARATION(Register, rsp,    (4));\n-CONSTANT_REGISTER_DECLARATION(Register, rbp,    (5));\n-CONSTANT_REGISTER_DECLARATION(Register, rsi,    (6));\n-CONSTANT_REGISTER_DECLARATION(Register, rdi,    (7));\n-#ifdef AMD64\n-CONSTANT_REGISTER_DECLARATION(Register, r8,     (8));\n-CONSTANT_REGISTER_DECLARATION(Register, r9,     (9));\n-CONSTANT_REGISTER_DECLARATION(Register, r10,   (10));\n-CONSTANT_REGISTER_DECLARATION(Register, r11,   (11));\n-CONSTANT_REGISTER_DECLARATION(Register, r12,   (12));\n-CONSTANT_REGISTER_DECLARATION(Register, r13,   (13));\n-CONSTANT_REGISTER_DECLARATION(Register, r14,   (14));\n-CONSTANT_REGISTER_DECLARATION(Register, r15,   (15));\n-#endif \/\/ AMD64\n+constexpr Register rax = as_Register(0);\n+constexpr Register rcx = as_Register(1);\n+constexpr Register rdx = as_Register(2);\n+constexpr Register rbx = as_Register(3);\n+constexpr Register rsp = as_Register(4);\n+constexpr Register rbp = as_Register(5);\n+constexpr Register rsi = as_Register(6);\n+constexpr Register rdi = as_Register(7);\n+#ifdef _LP64\n+constexpr Register r8  = as_Register( 8);\n+constexpr Register r9  = as_Register( 9);\n+constexpr Register r10 = as_Register(10);\n+constexpr Register r11 = as_Register(11);\n+constexpr Register r12 = as_Register(12);\n+constexpr Register r13 = as_Register(13);\n+constexpr Register r14 = as_Register(14);\n+constexpr Register r15 = as_Register(15);\n+#endif \/\/ _LP64\n@@ -102,3 +119,0 @@\n-\/\/ Use FloatRegister as shortcut\n-class FloatRegisterImpl;\n-typedef const FloatRegisterImpl* FloatRegister;\n@@ -106,1 +120,4 @@\n-inline constexpr FloatRegister as_FloatRegister(int encoding);\n+\/\/ The implementation of x87 floating point registers for the ia32 architecture.\n+class FloatRegister {\n+private:\n+  int _encoding;\n@@ -108,3 +125,1 @@\n-\/\/ The implementation of floating point registers for the ia32 architecture\n-class FloatRegisterImpl: public AbstractRegisterImpl {\n-  static constexpr FloatRegister first();\n+  constexpr FloatRegister(int encoding, bool unused) : _encoding(encoding) {}\n@@ -113,0 +128,2 @@\n+  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n+\n@@ -114,1 +131,2 @@\n-    number_of_registers = 8\n+    number_of_registers    = 8,\n+    max_slots_per_register = 2\n@@ -117,2 +135,4 @@\n-  \/\/ construction\n-  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n+  class FloatRegisterImpl: public AbstractRegisterImpl {\n+    friend class FloatRegister;\n+\n+    static constexpr FloatRegisterImpl* first();\n@@ -120,1 +140,5 @@\n-  inline VMReg as_VMReg() const;\n+  public:\n+    \/\/ accessors\n+    int   raw_encoding() const { return this - first(); }\n+    int   encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const     { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -122,1 +146,2 @@\n-  \/\/ derived registers, offsets, and addresses\n+    \/\/ derived registers, offsets, and addresses\n+    inline FloatRegister successor() const;\n@@ -124,1 +149,4 @@\n-  FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n@@ -126,5 +154,1 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                      { return this - first(); }\n-  int   encoding() const                          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n+  constexpr FloatRegister() : _encoding(-1) {} \/\/ fnoreg\n@@ -132,0 +156,4 @@\n+  int operator==(const FloatRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const FloatRegister r) const { return _encoding != r._encoding; }\n+\n+  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n@@ -134,1 +162,1 @@\n-REGISTER_IMPL_DECLARATION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n+extern FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n@@ -136,1 +164,3 @@\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));\n+inline constexpr FloatRegister::FloatRegisterImpl* FloatRegister::FloatRegisterImpl::first() {\n+  return all_FloatRegisterImpls + 1;\n+}\n@@ -138,3 +168,13 @@\n-\/\/ Use XMMRegister as shortcut\n-class XMMRegisterImpl;\n-typedef XMMRegisterImpl* XMMRegister;\n+constexpr FloatRegister fnoreg = FloatRegister();\n+\n+inline constexpr FloatRegister as_FloatRegister(int encoding) {\n+  if (0 <= encoding && encoding < FloatRegister::number_of_registers) {\n+    return FloatRegister(encoding, false);\n+  }\n+  return fnoreg;\n+}\n+\n+inline FloatRegister FloatRegister::FloatRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_FloatRegister(encoding() + 1);\n+}\n@@ -142,1 +182,0 @@\n-inline constexpr XMMRegister as_XMMRegister(int encoding);\n@@ -145,2 +184,8 @@\n-class XMMRegisterImpl: public AbstractRegisterImpl {\n-  static constexpr XMMRegister first();\n+class XMMRegister {\n+private:\n+  int _encoding;\n+\n+  constexpr XMMRegister(int encoding, bool unused) : _encoding(encoding) {}\n+\n+public:\n+  inline friend constexpr XMMRegister as_XMMRegister(int encoding);\n@@ -148,1 +193,0 @@\n- public:\n@@ -150,7 +194,2 @@\n-#ifndef AMD64\n-    number_of_registers = 8,\n-    max_slots_per_register = 16   \/\/ 512-bit\n-#else\n-    number_of_registers = 32,\n-    max_slots_per_register = 16   \/\/ 512-bit\n-#endif \/\/ AMD64\n+    number_of_registers    = LP64_ONLY( 32 ) NOT_LP64(  8 ),\n+    max_slots_per_register = LP64_ONLY( 16 ) NOT_LP64( 16 )   \/\/ 512-bit\n@@ -159,2 +198,2 @@\n-  \/\/ construction\n-  friend constexpr XMMRegister as_XMMRegister(int encoding);\n+  class XMMRegisterImpl: public AbstractRegisterImpl {\n+    friend class XMMRegister;\n@@ -162,1 +201,1 @@\n-  inline VMReg as_VMReg() const;\n+    static constexpr XMMRegisterImpl* first();\n@@ -164,2 +203,5 @@\n-  \/\/ derived registers, offsets, and addresses\n-  XMMRegister successor() const                          { return as_XMMRegister(encoding() + 1); }\n+  public:\n+    \/\/ accessors\n+    int raw_encoding() const  { return this - first(); }\n+    int   encoding() const    { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -167,6 +209,2 @@\n-  \/\/ accessors\n-  int raw_encoding() const                       { return this - first(); }\n-  int   encoding() const                         { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-  bool  is_valid() const                         { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n-  const char* sub_word_name(int offset) const;\n+    \/\/ derived registers, offsets, and addresses\n+    inline XMMRegister successor() const;\n@@ -174,2 +212,13 @@\n-  \/\/ Actually available XMM registers for use, depending on actual CPU capabilities\n-  \/\/ and flags.\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+  constexpr XMMRegister() : _encoding(-1) {} \/\/ xnoreg\n+\n+  int operator==(const XMMRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const XMMRegister r) const { return _encoding != r._encoding; }\n+\n+  const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n+\n+  \/\/ Actually available XMM registers for use, depending on actual CPU capabilities and flags.\n@@ -177,1 +226,0 @@\n-    int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n@@ -180,1 +228,1 @@\n-      num_xmm_regs \/= 2;\n+      return number_of_registers \/ 2;\n@@ -182,2 +230,2 @@\n-#endif\n-    return num_xmm_regs;\n+#endif \/\/ _LP64\n+    return number_of_registers;\n@@ -187,0 +235,5 @@\n+extern XMMRegister::XMMRegisterImpl all_XMMRegisterImpls[XMMRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr XMMRegister::XMMRegisterImpl* XMMRegister::XMMRegisterImpl::first() {\n+  return all_XMMRegisterImpls + 1;\n+}\n@@ -188,48 +241,56 @@\n-REGISTER_IMPL_DECLARATION(XMMRegister, XMMRegisterImpl, XMMRegisterImpl::number_of_registers);\n-\n-\/\/ The XMM registers, for P3 and up chips\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xnoreg , (-1));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm0 , ( 0));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm1 , ( 1));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm2 , ( 2));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm3 , ( 3));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm4 , ( 4));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm5 , ( 5));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm6 , ( 6));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm7 , ( 7));\n-#ifdef AMD64\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm8,      (8));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm9,      (9));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm10,    (10));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm11,    (11));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm12,    (12));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm13,    (13));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm14,    (14));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm15,    (15));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm16,    (16));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm17,    (17));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm18,    (18));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm19,    (19));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm20,    (20));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm21,    (21));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm22,    (22));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm23,    (23));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm24,    (24));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm25,    (25));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm26,    (26));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm27,    (27));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm28,    (28));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm29,    (29));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm30,    (30));\n-CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm31,    (31));\n-#endif \/\/ AMD64\n-\n-\/\/ Use KRegister as shortcut\n-class KRegisterImpl;\n-typedef KRegisterImpl* KRegister;\n-\n-inline constexpr KRegister as_KRegister(int encoding);\n-\n-\/\/ The implementation of AVX-3 (AVX-512) opmask registers.\n-class KRegisterImpl : public AbstractRegisterImpl {\n-  static constexpr KRegister first();\n+constexpr XMMRegister xnoreg = XMMRegister();\n+\n+inline constexpr XMMRegister as_XMMRegister(int encoding) {\n+  if (0 <= encoding && encoding < XMMRegister::number_of_registers) {\n+    return XMMRegister(encoding, false);\n+  }\n+  return xnoreg;\n+}\n+\n+inline XMMRegister XMMRegister::XMMRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_XMMRegister(encoding() + 1);\n+}\n+\n+constexpr XMMRegister xmm0  = as_XMMRegister( 0);\n+constexpr XMMRegister xmm1  = as_XMMRegister( 1);\n+constexpr XMMRegister xmm2  = as_XMMRegister( 2);\n+constexpr XMMRegister xmm3  = as_XMMRegister( 3);\n+constexpr XMMRegister xmm4  = as_XMMRegister( 4);\n+constexpr XMMRegister xmm5  = as_XMMRegister( 5);\n+constexpr XMMRegister xmm6  = as_XMMRegister( 6);\n+constexpr XMMRegister xmm7  = as_XMMRegister( 7);\n+#ifdef _LP64\n+constexpr XMMRegister xmm8  = as_XMMRegister( 8);\n+constexpr XMMRegister xmm9  = as_XMMRegister( 9);\n+constexpr XMMRegister xmm10 = as_XMMRegister(10);\n+constexpr XMMRegister xmm11 = as_XMMRegister(11);\n+constexpr XMMRegister xmm12 = as_XMMRegister(12);\n+constexpr XMMRegister xmm13 = as_XMMRegister(13);\n+constexpr XMMRegister xmm14 = as_XMMRegister(14);\n+constexpr XMMRegister xmm15 = as_XMMRegister(15);\n+constexpr XMMRegister xmm16 = as_XMMRegister(16);\n+constexpr XMMRegister xmm17 = as_XMMRegister(17);\n+constexpr XMMRegister xmm18 = as_XMMRegister(18);\n+constexpr XMMRegister xmm19 = as_XMMRegister(19);\n+constexpr XMMRegister xmm20 = as_XMMRegister(20);\n+constexpr XMMRegister xmm21 = as_XMMRegister(21);\n+constexpr XMMRegister xmm22 = as_XMMRegister(22);\n+constexpr XMMRegister xmm23 = as_XMMRegister(23);\n+constexpr XMMRegister xmm24 = as_XMMRegister(24);\n+constexpr XMMRegister xmm25 = as_XMMRegister(25);\n+constexpr XMMRegister xmm26 = as_XMMRegister(26);\n+constexpr XMMRegister xmm27 = as_XMMRegister(27);\n+constexpr XMMRegister xmm28 = as_XMMRegister(28);\n+constexpr XMMRegister xmm29 = as_XMMRegister(29);\n+constexpr XMMRegister xmm30 = as_XMMRegister(30);\n+constexpr XMMRegister xmm31 = as_XMMRegister(31);\n+#endif \/\/ _LP64\n+\n+\n+\/\/ The implementation of AVX-512 opmask registers.\n+class KRegister {\n+private:\n+  int _encoding;\n+\n+  constexpr KRegister(int encoding, bool unused) : _encoding(encoding) {}\n@@ -238,0 +299,2 @@\n+  inline friend constexpr KRegister as_KRegister(int encoding);\n+\n@@ -245,2 +308,4 @@\n-  \/\/ construction\n-  friend constexpr KRegister as_KRegister(int encoding);\n+  class KRegisterImpl: public AbstractRegisterImpl {\n+    friend class KRegister;\n+\n+    static constexpr KRegisterImpl* first();\n@@ -248,1 +313,1 @@\n-  inline VMReg as_VMReg() const;\n+  public:\n@@ -250,2 +315,4 @@\n-  \/\/ derived registers, offsets, and addresses\n-  KRegister successor() const                          { return as_KRegister(encoding() + 1); }\n+    \/\/ accessors\n+    int   raw_encoding() const { return this - first(); }\n+    int   encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool  is_valid() const     { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -253,5 +320,14 @@\n-  \/\/ accessors\n-  int   raw_encoding() const                      { return this - first(); }\n-  int   encoding() const                          { assert(is_valid(), \"invalid register (%d)\", (int)raw_encoding()); return raw_encoding(); }\n-  bool  is_valid() const                          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n-  const char* name() const;\n+    \/\/ derived registers, offsets, and addresses\n+    inline KRegister successor() const;\n+\n+    inline VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+  constexpr KRegister() : _encoding(-1) {} \/\/ knoreg\n+\n+  int operator==(const KRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const KRegister r) const { return _encoding != r._encoding; }\n+\n+  const KRegisterImpl* operator->() const { return KRegisterImpl::first() + _encoding; }\n@@ -260,1 +336,28 @@\n-REGISTER_IMPL_DECLARATION(KRegister, KRegisterImpl, KRegisterImpl::number_of_registers);\n+extern KRegister::KRegisterImpl all_KRegisterImpls[KRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr KRegister::KRegisterImpl* KRegister::KRegisterImpl::first() {\n+  return all_KRegisterImpls + 1;\n+}\n+\n+constexpr KRegister knoreg = KRegister();\n+\n+inline constexpr KRegister as_KRegister(int encoding) {\n+  if (0 <= encoding && encoding < KRegister::number_of_registers) {\n+    return KRegister(encoding, false);\n+  }\n+  return knoreg;\n+}\n+\n+inline KRegister KRegister::KRegisterImpl::successor() const {\n+  assert(is_valid(), \"sanity\");\n+  return as_KRegister(encoding() + 1);\n+}\n+\n+constexpr KRegister k0 = as_KRegister(0);\n+constexpr KRegister k1 = as_KRegister(1);\n+constexpr KRegister k2 = as_KRegister(2);\n+constexpr KRegister k3 = as_KRegister(3);\n+constexpr KRegister k4 = as_KRegister(4);\n+constexpr KRegister k5 = as_KRegister(5);\n+constexpr KRegister k6 = as_KRegister(6);\n+constexpr KRegister k7 = as_KRegister(7);\n@@ -262,10 +365,0 @@\n-\/\/ The Mask registers, for AVX3 enabled and up chips\n-CONSTANT_REGISTER_DECLARATION(KRegister, knoreg, (-1));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k0, (0));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k1, (1));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k2, (2));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k3, (3));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k4, (4));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k5, (5));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k6, (6));\n-CONSTANT_REGISTER_DECLARATION(KRegister, k7, (7));\n@@ -278,14 +371,17 @@\n-  \/\/ A big enough number for C2: all the registers plus flags\n-  \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n-  \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n-  \/\/ it's optoregs.\n-\n-  \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n-  \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n-  \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n-  \/\/ added for 32 bit jvm.\n-    number_of_registers = RegisterImpl::number_of_registers * RegisterImpl::max_slots_per_register +\n-      2 * FloatRegisterImpl::number_of_registers + NOT_LP64(8) LP64_ONLY(0) +\n-      XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::number_of_registers +\n-      KRegisterImpl::number_of_registers * KRegisterImpl::max_slots_per_register + \/\/ mask registers\n-      1 \/\/ eflags\n+    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n+    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n+    max_xmm = max_fpr + XMMRegister::number_of_registers * XMMRegister::max_slots_per_register,\n+    max_kpr = max_xmm + KRegister::number_of_registers * KRegister::max_slots_per_register,\n+\n+    \/\/ A big enough number for C2: all the registers plus flags\n+    \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n+    \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n+    \/\/ it's optoregs.\n+\n+    \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n+    \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n+    \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n+    \/\/ added for 32 bit jvm.\n+    number_of_registers = max_kpr +       \/\/ gpr\/fpr\/xmm\/kpr\n+                          NOT_LP64( 8 + ) \/\/ FILL0-FILL7 in x86_32.ad\n+                          1               \/\/ eflags\n@@ -293,6 +389,0 @@\n-\n-  static const int max_gpr;\n-  static const int max_fpr;\n-  static const int max_xmm;\n-  static const int max_kpr;\n-\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":280,"deletions":190,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n+  int num_xmm_regs = XMMRegister::number_of_registers;\n@@ -135,1 +135,1 @@\n-  int opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+  int opmask_state_bytes = KRegister::number_of_registers * 8;\n@@ -202,1 +202,1 @@\n-  for (int n = 0; n < FloatRegisterImpl::number_of_registers; n++) {\n+  for (int n = 0; n < FloatRegister::number_of_registers; n++) {\n@@ -238,1 +238,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -271,1 +271,1 @@\n-  for (int n = 0; n < FloatRegisterImpl::number_of_registers; n++) {\n+  for (int n = 0; n < FloatRegister::number_of_registers; n++) {\n@@ -294,1 +294,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n+  int num_xmm_regs = XMMRegister::number_of_registers;\n@@ -307,1 +307,1 @@\n-      opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+      opmask_state_bytes = KRegister::number_of_registers * 8;\n@@ -348,1 +348,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -415,2 +415,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 32-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 32-bit\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_regs = XMMRegister::available_xmm_registers();\n@@ -226,1 +226,1 @@\n-      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for(int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -243,1 +243,1 @@\n-      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for(int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -366,1 +366,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_regs = XMMRegister::available_xmm_registers();\n@@ -406,1 +406,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -423,1 +423,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -467,2 +467,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 64-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 64-bit\n@@ -1809,3 +1809,3 @@\n-  bool reg_destroyed[RegisterImpl::number_of_registers];\n-  bool freg_destroyed[XMMRegisterImpl::number_of_registers];\n-  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+  bool reg_destroyed[Register::number_of_registers];\n+  bool freg_destroyed[XMMRegister::number_of_registers];\n+  for ( int r = 0 ; r < Register::number_of_registers ; r++ ) {\n@@ -1814,1 +1814,1 @@\n-  for ( int f = 0 ; f < XMMRegisterImpl::number_of_registers ; f++ ) {\n+  for ( int f = 0 ; f < XMMRegister::number_of_registers ; f++ ) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2207,1 +2207,1 @@\n-  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -2209,1 +2209,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n@@ -2218,1 +2218,1 @@\n-  void aes_enc_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void aes_enc_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -2225,1 +2225,1 @@\n-  void aes_dec_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void aes_dec_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -3509,3 +3509,3 @@\n-    const Register empty = 0; \/\/ will never be used, in order not\n-                              \/\/ to change a signature for crc32c_IPL_Alg2_Alt2\n-                              \/\/ between 64\/32 I'm just keeping it here\n+    const Register empty = noreg; \/\/ will never be used, in order not\n+                                  \/\/ to change a signature for crc32c_IPL_Alg2_Alt2\n+                                  \/\/ between 64\/32 I'm just keeping it here\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3569,1 +3569,1 @@\n-  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -3571,1 +3571,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n@@ -4977,9 +4977,6 @@\n-  void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = NULL) {\n-    __ movdqu(xmmdst, Address(key, offset));\n-    if (xmm_shuf_mask != NULL) {\n-      __ pshufb(xmmdst, xmm_shuf_mask);\n-    } else {\n-      __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n-    }\n-    __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n-\n+void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n+  __ movdqu(xmmdst, Address(key, offset));\n+  if (xmm_shuf_mask != xnoreg) {\n+    __ pshufb(xmmdst, xmm_shuf_mask);\n+  } else {\n+    __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n@@ -4987,0 +4984,3 @@\n+  __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n+\n+}\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    for (int j = 0 ; j < XMMRegisterImpl::max_slots_per_register ; j++) {\n+    for (int j = 0 ; j < XMMRegister::max_slots_per_register ; j++) {\n@@ -59,1 +59,1 @@\n-    for (int j = 0; j < KRegisterImpl::max_slots_per_register; j++) {\n+    for (int j = 0; j < KRegister::max_slots_per_register; j++) {\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    (XMMRegisterImpl::max_slots_per_register * XMMRegisterImpl::available_xmm_registers());\n+    (XMMRegister::max_slots_per_register * XMMRegister::available_xmm_registers());\n@@ -90,1 +90,1 @@\n-    return base % XMMRegisterImpl::max_slots_per_register == 0;\n+    return (base % XMMRegister::max_slots_per_register) == 0;\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,7 +28,2 @@\n-inline VMReg RegisterImpl::as_VMReg() const {\n-  if( this==noreg ) return VMRegImpl::Bad();\n-#ifdef AMD64\n-  return VMRegImpl::as_VMReg(encoding() << 1 );\n-#else\n-  return VMRegImpl::as_VMReg(encoding() );\n-#endif \/\/ AMD64\n+inline VMReg Register::RegisterImpl::as_VMReg() const {\n+  return VMRegImpl::as_VMReg(encoding() LP64_ONLY( << 1 ));\n@@ -37,1 +32,1 @@\n-inline VMReg FloatRegisterImpl::as_VMReg() const {\n+inline VMReg FloatRegister::FloatRegisterImpl::as_VMReg() const {\n@@ -41,1 +36,1 @@\n-inline VMReg XMMRegisterImpl::as_VMReg() const {\n+inline VMReg XMMRegister::XMMRegisterImpl::as_VMReg() const {\n@@ -45,1 +40,1 @@\n-inline VMReg KRegisterImpl::as_VMReg() const {\n+inline VMReg KRegister::KRegisterImpl::as_VMReg() const {\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.inline.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -258,1 +258,2 @@\n-#define   HIGH_FROM_LOW(x) ((x)+2)\n+#define   HIGH_FROM_LOW(x) (as_Register((x)->encoding()+2))\n+#define   HIGH_FROM_LOW_ENC(x) ((x)+2)\n@@ -1653,1 +1654,1 @@\n-    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -1664,1 +1665,1 @@\n-    int desthi = HIGH_FROM_LOW(destlo);\n+    int desthi = HIGH_FROM_LOW_ENC(destlo);\n@@ -1949,1 +1950,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1957,1 +1958,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1961,1 +1962,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2086,1 +2087,1 @@\n-    int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  \/\/ Hi register of pair, computed from lo\n+    int reg_encoding = HIGH_FROM_LOW_ENC($ereg$$reg);  \/\/ Hi register of pair, computed from lo\n@@ -2097,2 +2098,2 @@\n-    if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }\n-    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }\n+    if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW_ENC($dst$$reg); }\n+    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW_ENC($dst$$reg); }\n@@ -2110,1 +2111,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2117,1 +2118,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2123,2 +2124,2 @@\n-    if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }\n-    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }\n+    if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW_ENC($dst$$reg); }\n+    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW_ENC($dst$$reg); }\n@@ -2268,1 +2269,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2276,1 +2277,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2292,1 +2293,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2295,1 +2296,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2300,1 +2301,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2303,1 +2304,1 @@\n-    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2316,1 +2317,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2319,1 +2320,1 @@\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2325,1 +2326,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2328,1 +2329,1 @@\n-    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2658,1 +2659,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2674,1 +2675,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );\n+    encode_Copy( cbuf, HIGH_FROM_LOW_ENC(dst_encoding), src_encoding );\n@@ -2677,1 +2678,1 @@\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );\n+    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC(dst_encoding) );\n@@ -2683,1 +2684,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));\n+    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2713,1 +2714,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));\n+    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2745,1 +2746,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2747,1 +2748,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );\n+    encode_Copy( cbuf, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2751,1 +2752,1 @@\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );\n+    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2754,1 +2755,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2760,1 +2761,1 @@\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );\n+    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $tmp$$reg );\n@@ -2768,1 +2769,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2783,1 +2784,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2787,1 +2788,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2804,1 +2805,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2808,1 +2809,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2829,1 +2830,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2841,1 +2842,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2850,1 +2851,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src1$$reg) );\n@@ -2853,1 +2854,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2865,1 +2866,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2871,1 +2872,1 @@\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2875,1 +2876,1 @@\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":46,"deletions":45,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -143,1 +143,3 @@\n-    assert(start <= end, \"must be\");\n+    int start_enc = start->encoding();\n+    int   end_enc = end->encoding();\n+    assert(start_enc <= end_enc, \"must be\");\n@@ -145,3 +147,3 @@\n-    bits <<= start->encoding();\n-    bits <<= 31 - end->encoding();\n-    bits >>= 31 - end->encoding();\n+    bits <<= start_enc;\n+    bits <<= 31 - end_enc;\n+    bits >>= 31 - end_enc;\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2555,1 +2555,0 @@\n-  declare_constant(RegisterImpl::number_of_registers)                     \\\n@@ -2557,1 +2556,1 @@\n-  declare_preprocessor_constant(\"REG_COUNT\", REG_COUNT)                \\\n+  declare_preprocessor_constant(\"REG_COUNT\", REG_COUNT)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}