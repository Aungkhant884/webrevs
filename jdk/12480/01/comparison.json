{"files":[{"patch":"@@ -91,0 +91,2 @@\n+  product(bool, UseCryptoPmullForCRC32, false,                          \\\n+          \"Use Crypto PMULL instructions for CRC32 computation\")        \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3606,0 +3606,59 @@\n+void MacroAssembler::kernel_crc32_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2, Register tmp3) {\n+    Label CRC_by4_loop, CRC_by1_loop, CRC_less128, CRC_by128_pre, CRC_by32_loop, CRC_less32, L_exit;\n+    assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2);\n+\n+    subs(tmp0, len, 384);\n+    mvnw(crc, crc);\n+    br(Assembler::GE, CRC_by128_pre);\n+  BIND(CRC_less128);\n+    subs(len, len, 32);\n+    br(Assembler::GE, CRC_by32_loop);\n+  BIND(CRC_less32);\n+    adds(len, len, 32 - 4);\n+    br(Assembler::GE, CRC_by4_loop);\n+    adds(len, len, 4);\n+    br(Assembler::GT, CRC_by1_loop);\n+    b(L_exit);\n+\n+  BIND(CRC_by32_loop);\n+    ldp(tmp0, tmp1, Address(buf));\n+    crc32x(crc, crc, tmp0);\n+    ldp(tmp2, tmp3, Address(buf, 16));\n+    crc32x(crc, crc, tmp1);\n+    add(buf, buf, 32);\n+    crc32x(crc, crc, tmp2);\n+    subs(len, len, 32);\n+    crc32x(crc, crc, tmp3);\n+    br(Assembler::GE, CRC_by32_loop);\n+    cmn(len, (u1)32);\n+    br(Assembler::NE, CRC_less32);\n+    b(L_exit);\n+\n+  BIND(CRC_by4_loop);\n+    ldrw(tmp0, Address(post(buf, 4)));\n+    subs(len, len, 4);\n+    crc32w(crc, crc, tmp0);\n+    br(Assembler::GE, CRC_by4_loop);\n+    adds(len, len, 4);\n+    br(Assembler::LE, L_exit);\n+  BIND(CRC_by1_loop);\n+    ldrb(tmp0, Address(post(buf, 1)));\n+    subs(len, len, 1);\n+    crc32b(crc, crc, tmp0);\n+    br(Assembler::GT, CRC_by1_loop);\n+    b(L_exit);\n+\n+  BIND(CRC_by128_pre);\n+    kernel_crc32_common_fold_using_crypto_pmull(crc, buf, len, tmp0, tmp1, tmp2,\n+      4*256*sizeof(juint) + 8*sizeof(juint));\n+    mov(crc, 0);\n+    crc32x(crc, crc, tmp0);\n+    crc32x(crc, crc, tmp1);\n+\n+    cbnz(len, CRC_less128);\n+\n+  BIND(L_exit);\n+    mvnw(crc, crc);\n+}\n+\n@@ -3718,1 +3777,5 @@\n-      kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);\n+      if (UseCryptoPmullForCRC32) {\n+        kernel_crc32_using_crypto_pmull(crc, buf, len, table0, table1, table2, table3);\n+      } else {\n+        kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);\n+      }\n@@ -4016,0 +4079,117 @@\n+void MacroAssembler::kernel_crc32_common_fold_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2, size_t table_offset) {\n+    Label CRC_by128_loop;\n+    assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2);\n+\n+    sub(len, len, 256);\n+    Register table = tmp0;\n+    {\n+      uint64_t offset;\n+      adrp(table, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n+      add(table, table, offset);\n+    }\n+    add(table, table, table_offset);\n+\n+    sub(buf, buf, 0x10);\n+    ldrq(v1, Address(buf, 0x10));\n+    ldrq(v2, Address(buf, 0x20));\n+    ldrq(v3, Address(buf, 0x30));\n+    ldrq(v4, Address(buf, 0x40));\n+    ldrq(v5, Address(buf, 0x50));\n+    ldrq(v6, Address(buf, 0x60));\n+    ldrq(v7, Address(buf, 0x70));\n+    ldrq(v8, Address(pre(buf, 0x80)));\n+\n+    movi(v25, T4S, 0);\n+    mov(v25, S, 0, crc);\n+    eor(v1, T16B, v1, v25);\n+\n+    ldrq(v0, Address(table));\n+    b(CRC_by128_loop);\n+\n+    align(OptoLoopAlignment);\n+  BIND(CRC_by128_loop);\n+    pmull (v9,  T1Q, v1, v0, T1D);\n+    pmull2(v10, T1Q, v1, v0, T2D);\n+    ldrq(v1, Address(buf, 0x10));\n+    eor3(v1, T16B, v9,  v10, v1);\n+\n+    pmull (v11, T1Q, v2, v0, T1D);\n+    pmull2(v12, T1Q, v2, v0, T2D);\n+    ldrq(v2, Address(buf, 0x20));\n+    eor3(v2, T16B, v11, v12, v2);\n+\n+    pmull (v13, T1Q, v3, v0, T1D);\n+    pmull2(v14, T1Q, v3, v0, T2D);\n+    ldrq(v3, Address(buf, 0x30));\n+    eor3(v3, T16B, v13, v14, v3);\n+\n+    pmull (v15, T1Q, v4, v0, T1D);\n+    pmull2(v16, T1Q, v4, v0, T2D);\n+    ldrq(v4, Address(buf, 0x40));\n+    eor3(v4, T16B, v15, v16, v4);\n+\n+    pmull (v17, T1Q, v5, v0, T1D);\n+    pmull2(v18, T1Q, v5, v0, T2D);\n+    ldrq(v5, Address(buf, 0x50));\n+    eor3(v5, T16B, v17, v18, v5);\n+\n+    pmull (v19, T1Q, v6, v0, T1D);\n+    pmull2(v20, T1Q, v6, v0, T2D);\n+    ldrq(v6, Address(buf, 0x60));\n+    eor3(v6, T16B, v19, v20, v6);\n+\n+    pmull (v21, T1Q, v7, v0, T1D);\n+    pmull2(v22, T1Q, v7, v0, T2D);\n+    ldrq(v7, Address(buf, 0x70));\n+    eor3(v7, T16B, v21, v22, v7);\n+\n+    pmull (v23, T1Q, v8, v0, T1D);\n+    pmull2(v24, T1Q, v8, v0, T2D);\n+    ldrq(v8, Address(pre(buf, 0x80)));\n+    eor3(v8, T16B, v23, v24, v8);\n+\n+    subs(len, len, 0x80);\n+    br(Assembler::GE, CRC_by128_loop);\n+\n+    \/\/ fold into 512 bits\n+    ldrq(v0, Address(table, 0x10));\n+\n+    pmull (v10,  T1Q, v1, v0, T1D);\n+    pmull2(v11, T1Q, v1, v0, T2D);\n+    eor3(v1, T16B, v10, v11, v5);\n+\n+    pmull (v12, T1Q, v2, v0, T1D);\n+    pmull2(v13, T1Q, v2, v0, T2D);\n+    eor3(v2, T16B, v12, v13, v6);\n+\n+    pmull (v14, T1Q, v3, v0, T1D);\n+    pmull2(v15, T1Q, v3, v0, T2D);\n+    eor3(v3, T16B, v14, v15, v7);\n+\n+    pmull (v16, T1Q, v4, v0, T1D);\n+    pmull2(v17, T1Q, v4, v0, T2D);\n+    eor3(v4, T16B, v16, v17, v8);\n+\n+    \/\/ fold into 128 bits\n+    ldrq(v5, Address(table, 0x20));\n+    pmull (v10, T1Q, v1, v5, T1D);\n+    pmull2(v11, T1Q, v1, v5, T2D);\n+    eor3(v4, T16B, v4, v10, v11);\n+\n+    ldrq(v6, Address(table, 0x30));\n+    pmull (v12, T1Q, v2, v6, T1D);\n+    pmull2(v13, T1Q, v2, v6, T2D);\n+    eor3(v4, T16B, v4, v12, v13);\n+\n+    ldrq(v7, Address(table, 0x40));\n+    pmull (v14, T1Q, v3, v7, T1D);\n+    pmull2(v15, T1Q, v3, v7, T2D);\n+    eor3(v1, T16B, v4, v14, v15);\n+\n+    add(len, len, 0x80);\n+    add(buf, buf, 0x10);\n+\n+    mov(tmp0, v1, D, 0);\n+    mov(tmp1, v1, D, 1);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":181,"deletions":1,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -1425,0 +1425,3 @@\n+  void kernel_crc32_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2,\n+        Register tmp3);\n@@ -1431,0 +1434,3 @@\n+  void kernel_crc32_common_fold_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2,\n+        size_t table_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -293,0 +293,12 @@\n+\n+    \/\/ Constants for CRC-32 crypto pmull implementation\n+    0xe88ef372UL, 0x00000001UL,\n+    0x4a7fe880UL, 0x00000001UL,\n+    0x54442bd4UL, 0x00000001UL,\n+    0xc6e41596UL, 0x00000001UL,\n+    0x3db1ecdcUL, 0x00000000UL,\n+    0x74359406UL, 0x00000001UL,\n+    0xf1da05aaUL, 0x00000000UL,\n+    0x5a546366UL, 0x00000001UL,\n+    0x751997d0UL, 0x00000001UL,\n+    0xccaa009eUL, 0x00000000UL,\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -249,0 +249,13 @@\n+\n+  \/\/ Neoverse V1\n+  if (_cpu == CPU_ARM && (_model == 0xd40 || _model2 == 0xd40)) {\n+    if (FLAG_IS_DEFAULT(UseCryptoPmullForCRC32)) {\n+      FLAG_SET_DEFAULT(UseCryptoPmullForCRC32, true);\n+    }\n+  }\n+\n+  if (UseCryptoPmullForCRC32 && (!VM_Version::supports_sha3() || !VM_Version::supports_pmull())) {\n+    warning(\"UseCryptoPmullForCRC32 specified, but not supported on this CPU\");\n+    FLAG_SET_DEFAULT(UseCryptoPmullForCRC32, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}