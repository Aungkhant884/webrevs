{"files":[{"patch":"@@ -1,580 +0,0 @@\n-\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8217408\n- * @summary Verify that setting multiple instances of the same cipher suite does\n- * not result in extra reported suites\n- * @run main\/othervm CheckDuplicateCipherSuites\n- * @run main\/othervm -Djdk.tls.namedGroups=ffdhe2048,secp256r1,ffdhe2048,secp256r1,ffdhe2048,secp256r1,ffdhe2048,secp256r1 CheckDuplicateCipherSuites\n- * @run main\/othervm -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ed25519,ed448,ecdsa_secp256r1_sha256,ed25519,ed448,ecdsa_secp256r1_sha256,ed25519,ed448,rsa_pkcs1_sha256 CheckDuplicateCipherSuites\n- *\/\n-\n-import javax.net.ssl.*;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-\n-public class CheckDuplicateCipherSuites {\n-    enum CipherSuite {\n-        TLS_AES_256_GCM_SHA384\n-                (0x1302,    \"TLS_AES_256_GCM_SHA384\"),\n-        TLS_AES_128_GCM_SHA256\n-                (0x1301,    \"TLS_AES_128_GCM_SHA256\"),\n-        TLS_CHACHA20_POLY1305_SHA256\n-                (0x1303,    \"TLS_CHACHA20_POLY1305_SHA256\"),\n-        TLS_DHE_RSA_WITH_AES_128_CBC_SHA\n-                (0x0033,    \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\"),\n-        TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\n-                (0x0067,    \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"),\n-        TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\n-                (0x009E,    \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\"),\n-        TLS_DHE_RSA_WITH_AES_256_CBC_SHA\n-                (0x0039,    \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\"),\n-        TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\n-                (0x006B,    \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\"),\n-        TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\n-                (0x009F,    \"TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\");\n-\n-        final int id;\n-        final String name;\n-\n-        CipherSuite(int id, String name) {\n-            this.id = id;\n-            this.name = name;\n-        }\n-\n-        \/**\n-         * Get a list of the ciphersuite names only\n-         *\n-         * @param orig a list of CipherSuite enums\n-         *\n-         * @return a list of ciphersuite String names\n-         *\/\n-        private static List<String> names(List<CipherSuite> orig) {\n-            List<String> names = new ArrayList<>();\n-            orig.forEach(cs -> names.add(cs.name));\n-            return names;\n-        }\n-\n-        \/**\n-         * Get a list of the ciphersuite ids only\n-         *\n-         * @param orig a list of CipherSuite enums\n-         *\n-         * @return a list of ciphersuite hex IDs\n-         *\/\n-        private static List<Integer> ids(List<CipherSuite> orig) {\n-            List<Integer> ids = new ArrayList<>();\n-            orig.forEach(cs -> ids.add(cs.id));\n-            return ids;\n-        }\n-\n-        private static String nameOf(int id) {\n-            for (CipherSuite cs : CipherSuite.values()) {\n-                if (cs.id == id) {\n-                    return cs.name;\n-                }\n-            }\n-            return \"UNKNOWN-CIPHER-SUITE(\" + id + \")\";\n-        }\n-    }\n-\n-    enum ProtocolVersion {\n-        TLS13       (0x0304, \"TLSv1.3\"),\n-        TLS12       (0x0303, \"TLSv1.2\"),\n-        TLS11       (0x0302, \"TLSv1.1\"),\n-        TLS10       (0x0301, \"TLSv1\"),\n-        SSL30       (0x0300, \"SSLv3\"),\n-        SSL20Hello  (0x0002, \"SSLv2Hello\"),\n-\n-        DTLS12      (0xFEFD, \"DTLSv1.2\"),\n-        DTLS10      (0xFEFF, \"DTLSv1.0\");\n-\n-        final int id;\n-        final String name;\n-\n-        ProtocolVersion(int id, String name) {\n-            this.id = id;\n-            this.name = name;\n-        }\n-\n-        \/**\n-         * Get a list of the protocol version names only\n-         *\n-         * @param orig a list of ProtocolVersion enums\n-         *\n-         * @return a list of protocol version String names\n-         *\/\n-        private static List<String> names(List<ProtocolVersion> orig) {\n-            List<String> names = new ArrayList<>();\n-            orig.forEach(cs -> names.add(cs.name));\n-            return names;\n-        }\n-\n-        \/**\n-         * Get a list of the protocol version ids only\n-         *\n-         * @param orig a list of ProtocolVersion enums\n-         *\n-         * @return a list of protocol version hex IDs\n-         *\/\n-        private static List<Integer> ids(List<ProtocolVersion> orig) {\n-            List<Integer> ids = new ArrayList<>();\n-            orig.forEach(cs -> ids.add(cs.id));\n-            return ids;\n-        }\n-\n-        private static String nameOf(int id) {\n-            for (ProtocolVersion pv : ProtocolVersion.values()) {\n-                if (pv.id == id) {\n-                    return pv.name;\n-                }\n-            }\n-            return \"UNKNOWN-PROTOCOL-VERSION(\" + id + \")\";\n-        }\n-    }\n-\n-    enum NamedGroup {\n-        FFDHE_2048(0x0100, \"ffdhe2048\"),\n-        SECP256_R1(0x0017, \"secp256r1\"),\n-        X25519(0x001D, \"x25519\"),\n-        X448(0x001E, \"x448\"),\n-        SECP384_R1(0x0018, \"secp384r1\"),\n-        SECP521_R1(0x0019, \"secp521r1\"),\n-        FFDHE_3072(0x0101, \"ffdhe3072\"),\n-        FFDHE_4096(0x0102, \"ffdhe4096\"),\n-        FFDHE_6144(0x0103, \"ffdhe6144\"),\n-        FFDHE_8192(0x0104, \"ffdhe8192\");\n-\n-        final int id;           \/\/ hash + signature\n-        final String name;      \/\/ literal name\n-\n-        NamedGroup(int id, String name) {\n-            this.id = id;\n-            this.name = name;\n-        }\n-\n-        private static List<String> names(List<NamedGroup> orig) {\n-            List<String> names = new ArrayList<>();\n-            orig.forEach(ng -> names.add(ng.name));\n-            return names;\n-        }\n-\n-        private static List<Integer> ids(List<NamedGroup> orig) {\n-            List<Integer> ids = new ArrayList<>();\n-            orig.forEach(ng -> ids.add(ng.id));\n-            return ids;\n-        }\n-\n-        private static String nameOf(int id) {\n-            for (NamedGroup ng : NamedGroup.values()) {\n-                if (ng.id == id) {\n-                    return ng.name;\n-                }\n-            }\n-            return \"UNKNOWN-NAMED-GROUP(\" + id + \")\";\n-        }\n-    }\n-\n-    enum SignatureScheme {\n-        ECDSA_SECP256R1_SHA256  (0x0403, \"ecdsa_secp256r1_sha256\"),\n-        ED25519                 (0x0807, \"ed25519\"),\n-        ED448                   (0x0808, \"ed448\"),\n-        RSA_PKCS1_SHA256        (0x0401, \"rsa_pkcs1_sha256\"),\n-        ECDSA_SECP384R1_SHA384  (0x0503, \"ecdsa_secp384r1_sha384\"),\n-        ECDSA_SECP521R1_SHA512  (0x0603, \"ecdsa_secp521r1_sha512\"),\n-        RSA_PSS_RSAE_SHA256     (0x0804, \"rsa_pss_rsae_sha256\"),\n-        RSA_PSS_RSAE_SHA384     (0x0805, \"rsa_pss_rsae_sha384\"),\n-        RSA_PSS_RSAE_SHA512     (0x0806, \"rsa_pss_rsae_sha512\"),\n-        RSA_PSS_PSS_SHA256      (0x0809, \"rsa_pss_pss_sha256\"),\n-        RSA_PSS_PSS_SHA384      (0x080A, \"rsa_pss_pss_sha384\"),\n-        RSA_PSS_PSS_SHA512      (0x080B, \"rsa_pss_pss_sha512\"),\n-        RSA_PKCS1_SHA384        (0x0501, \"rsa_pkcs1_sha384\"),\n-        RSA_PKCS1_SHA512        (0x0601, \"rsa_pkcs1_sha512\"),\n-        DSA_SHA256              (0x0402, \"dsa_sha256\"),\n-        ECDSA_SHA224            (0x0303, \"ecdsa_sha224\"),\n-        RSA_SHA224              (0x0301, \"rsa_sha224\"),\n-        DSA_SHA224              (0x0302, \"dsa_sha224\"),\n-        ECDSA_SHA1              (0x0203, \"ecdsa_sha1\"),\n-        RSA_PKCS1_SHA1          (0x0201, \"rsa_pkcs1_sha1\"),\n-        DSA_SHA1                (0x0202, \"dsa_sha1\");\n-\n-        final int id;           \/\/ hash + signature\n-        final String name;      \/\/ literal name\n-\n-        SignatureScheme(int id, String name) {\n-            this.id = id;\n-            this.name = name;\n-        }\n-\n-        private static List<String> names(List<SignatureScheme> orig) {\n-            List<String> names = new ArrayList<>();\n-            orig.forEach(ss -> names.add(ss.name));\n-            return names;\n-        }\n-\n-        private static List<Integer> ids(List<SignatureScheme> orig) {\n-            List<Integer> ids = new ArrayList<>();\n-            orig.forEach(ss -> ids.add(ss.id));\n-            return ids;\n-        }\n-\n-        private static String nameOf(int id) {\n-            for (SignatureScheme ss : SignatureScheme.values()) {\n-                if (ss.id == id) {\n-                    return ss.name;\n-                }\n-            }\n-            return \"UNKNOWN-SIGNATURE-SCHEME(\" + id + \")\";\n-        }\n-    }\n-\n-    enum CompressionAlgorithm {\n-        ZLIB            (0x0001, \"zlib\"),\n-        BROTLI          (0x0002, \"brotli\"),\n-        ZSTD            (0x0003, \"zstd\"),\n-        NO_COMPRESSION  (0x0000, \"compression_disabled\");\n-\n-        final int id;           \/\/ hash + signature\n-        final String name;      \/\/ literal name\n-\n-        CompressionAlgorithm(int id, String name) {\n-            this.id = id;\n-            this.name = name;\n-        }\n-\n-        private static List<String> names(List<CompressionAlgorithm> orig) {\n-            List<String> names = new ArrayList<>();\n-            orig.forEach(cm -> names.add(cm.name));\n-            return names;\n-        }\n-\n-        private static List<Integer> ids(List<CompressionAlgorithm> orig) {\n-            List<Integer> ids = new ArrayList<>();\n-            orig.forEach(cm -> ids.add(cm.id));\n-            return ids;\n-        }\n-\n-        private static String nameOf(int id) {\n-            for (CompressionAlgorithm cm : CompressionAlgorithm.values()) {\n-                if (cm.id == id) {\n-                    return cm.name;\n-                }\n-            }\n-            return \"UNKNOWN-COMPRESSION-ALGORITHM(\" + id + \")\";\n-        }\n-    }\n-\n-    static final int HELLO_EXT_SERVER_NAMES = 0;\n-    static final int TLS_HANDSHAKE_CLIHELLO = 1;\n-    static final int HELLO_EXT_SUPP_GROUPS = 10;\n-    static final int HELLO_EXT_SIG_ALGS = 13;\n-    static final int HELLO_EXT_ALPN_NEGOT = 16;\n-    static final int TLS_RECORD_HANDSHAKE = 22;\n-    static final int HELLO_EXT_SUPP_VERS = 43;\n-    static final int HELLO_EXT_SIG_ALG_CERTS = 50;\n-    static final List<CipherSuite> malfCS = List.of(\n-            CipherSuite.TLS_AES_256_GCM_SHA384,\n-            CipherSuite.TLS_AES_128_GCM_SHA256,\n-            CipherSuite.TLS_CHACHA20_POLY1305_SHA256,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,\n-            CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA256);\n-    static final List<ProtocolVersion> malfPV = List.of(\n-            ProtocolVersion.TLS11,\n-            ProtocolVersion.SSL20Hello,\n-            ProtocolVersion.DTLS12,\n-            ProtocolVersion.TLS13,\n-            ProtocolVersion.DTLS10,\n-            ProtocolVersion.TLS12,\n-            ProtocolVersion.SSL30,\n-            ProtocolVersion.TLS10,\n-            ProtocolVersion.TLS13,\n-            ProtocolVersion.TLS13,\n-            ProtocolVersion.TLS13);\n-    static final List<String> malfALPN = List.of(\"http\/1.1\", \"spdy\/2\", \"spdy\/3\",\n-            \"stun.turn\", \"stun.nat-discovery\", \"h2c\", \"c-webrtc\", \"sunrpc\",\n-            \"irc\", \"http\/1.1\", \"http\/1.1\", \"http\/1.1\", \"http\/1.1\");\n-    \/* Duplicate server names are illegal (RFC 6066), so a malformed server name\n-    list causes an IllegalArgumentException to be thrown, so the duplicate\n-    testing has been commented out but the code left for verification purposes.\n-    static final List<SNIServerName> malfSN = List.of(\n-            new SNIHostName(\"www.yahoo.com\"),\n-            new SNIHostName(\"www.oracle.com\"),\n-            new SNIHostName(\"duckduckgo.com\"),\n-            new SNIHostName(\"www.google.com\"),\n-            new SNIHostName(\"www.yahoo.com\"),\n-            new SNIHostName(\"www.oracle.com\"),\n-            new SNIHostName(\"duckduckgo.com\"),\n-            new SNIHostName(\"www.google.com\"),\n-            new SNIHostName(\"www.yahoo.com\"),\n-            new SNIHostName(\"www.oracle.com\"),\n-            new SNIHostName(\"duckduckgo.com\"),\n-            new SNIHostName(\"www.google.com\"));*\/\n-    static SSLContext defaultCtx;\n-\n-    public static void main(String[] args) throws Exception {\n-        defaultCtx = SSLContext.getDefault();\n-        ByteBuffer transitData = clientHelloEnv();\n-        checkClientHello(transitData);\n-    }\n-\n-    \/**\n-     * Create an SSLEngine from the default context, modify the parameters to\n-     * the various malformed lists, and initiate a ClientHello to be evaluated.\n-     *\/\n-    private static ByteBuffer clientHelloEnv() throws Exception {\n-        SSLEngine eng = defaultCtx.createSSLEngine();\n-        SSLParameters sslp = new SSLParameters(\n-                CipherSuite.names(malfCS).toArray(new String[0]),\n-                ProtocolVersion.names(malfPV).toArray(new String[0]));\n-        sslp.setApplicationProtocols(malfALPN.toArray(new String[0]));\n-        \/*sslp.setServerNames(malfSN);*\/\n-        eng.setSSLParameters(sslp);\n-        eng.setUseClientMode(true);\n-        SSLSession session = eng.getSession();\n-        ByteBuffer clientOut = ByteBuffer.wrap(\"Client\".getBytes());\n-        ByteBuffer cTOs =\n-                ByteBuffer.allocateDirect(session.getPacketBufferSize());\n-\n-        \/\/ Create and check the ClientHello message\n-        SSLEngineResult clientResult = eng.wrap(clientOut, cTOs);\n-        if (clientResult.getStatus() != SSLEngineResult.Status.OK) {\n-            throw new RuntimeException(\"Client wrap status: \"\n-                    + clientResult.getStatus());\n-        }\n-\n-        cTOs.flip();\n-        return cTOs;\n-    }\n-\n-    \/**\n-     * Examine the ClientHello to check the agreed upon cipher suites\n-     * for handling of duplicate entries.\n-     *\n-     * @param data the ByteBuffer containing the ClientHello bytes\n-     *\/\n-    private static void checkClientHello(ByteBuffer data) {\n-        Objects.requireNonNull(data);\n-        data.mark();\n-\n-        \/\/ Process the TLS record header\n-        int type = Byte.toUnsignedInt(data.get());\n-        int ver = Short.toUnsignedInt(data.getShort());\n-        int recLen = Short.toUnsignedInt(data.getShort());\n-\n-        \/\/ Sanity checks on the record header\n-        if (type != TLS_RECORD_HANDSHAKE) {\n-            throw new RuntimeException(\"Not a handshake, type = \" + type);\n-        } else if (recLen > data.remaining()) {\n-            throw new RuntimeException(\"Buffer record is incomplete. \" +\n-                    \"Record length = \" + recLen + \", remaining = \" +\n-                    data.remaining());\n-        }\n-\n-        \/\/ Extract the handshake message header\n-        int msgHdr = data.getInt();\n-        int msgType = msgHdr >>> 24;\n-        int msgLen = msgHdr & 0x00FFFFFF;\n-\n-        \/\/ Sanity check on the message type\n-        if (msgType != TLS_HANDSHAKE_CLIHELLO) {\n-            throw new RuntimeException(\"Not a ClientHello, type = \" + msgType);\n-        }\n-\n-        \/\/ Skip protocol version and client random\n-        data.position(data.position() + 34);\n-\n-        \/\/ Jump past session ID if it exists\n-        int sessLen = Byte.toUnsignedInt(data.get());\n-        if (sessLen != 0) {\n-            data.position(data.position() + sessLen);\n-        }\n-\n-        \/\/ Extract the cipher suites and put them in a separate List\n-        List<String> transitCSs = new ArrayList<>();\n-        int csLen = Short.toUnsignedInt(data.getShort());\n-        for (int i=0; i < csLen; i+=2) {\n-            transitCSs.add(\n-                    CipherSuite.nameOf(Short.toUnsignedInt(data.getShort())));\n-        }\n-\n-        \/\/ Extract the compression algorithms\n-        List<String> transitCmprsnAlgs = new ArrayList<>();\n-        int compLen = Byte.toUnsignedInt(data.get());\n-        for (int i=0; i<compLen; i+=2) {\n-            transitCmprsnAlgs.add(CompressionAlgorithm.nameOf(\n-                    Byte.toUnsignedInt(data.get())));\n-        }\n-\n-        \/\/ Go through the extensions and look for supported_versions and ALPNs,\n-        \/\/ then add each entry to a list to be checked later\n-        int extsLen = Short.toUnsignedInt(data.getShort());\n-        List<String> transitPVs = new ArrayList<>();\n-        List<String> transitALPNs = new ArrayList<>();\n-        List<String> transitNmdGrps = new ArrayList<>();\n-        List<String> transitSigSchms = new ArrayList<>();\n-        List<String> transitCertSigAlgs = new ArrayList<>();\n-        \/*List<String> transitServNames = new ArrayList<>();*\/\n-        while (data.hasRemaining()) {\n-            int extType = Short.toUnsignedInt(data.getShort());\n-            int extLen = Short.toUnsignedInt(data.getShort());\n-            switch (extType) {\n-                case HELLO_EXT_SUPP_VERS:\n-                    int supVerLen = Byte.toUnsignedInt(data.get());\n-                    for (int i=0; i < supVerLen; i+=2) {\n-                        transitPVs.add(ProtocolVersion.\n-                                nameOf(Short.toUnsignedInt(data.getShort())));\n-                    }\n-                    break;\n-                case HELLO_EXT_ALPN_NEGOT:\n-                    int alpnListLen = Short.toUnsignedInt(data.getShort());\n-                    while (alpnListLen > 0) {\n-                        byte[] alpnBytes = new\n-                                byte[Byte.toUnsignedInt(data.get())];\n-                        data.get(alpnBytes);\n-                        transitALPNs.add(new String(alpnBytes,\n-                                StandardCharsets.UTF_8));\n-                        alpnListLen -= (1 + alpnBytes.length);\n-                    }\n-                    break;\n-                case HELLO_EXT_SUPP_GROUPS:\n-                    int supGrpLen = Short.toUnsignedInt(data.getShort());\n-                    for (int i=0; i<supGrpLen; i+=2) {\n-                        transitNmdGrps.add(NamedGroup.nameOf(\n-                                Short.toUnsignedInt(data.getShort())));\n-                    }\n-                    break;\n-                case HELLO_EXT_SIG_ALGS:\n-                    int sigAlgLen = Short.toUnsignedInt(data.getShort());\n-                    for (int i=0; i<sigAlgLen; i+=2) {\n-                        transitSigSchms.add(SignatureScheme.nameOf(\n-                                Short.toUnsignedInt(data.getShort())));\n-                    }\n-                    break;\n-                case HELLO_EXT_SIG_ALG_CERTS:\n-                    int certSigAlgLen = Short.toUnsignedInt(data.getShort());\n-                    for (int i=0; i<certSigAlgLen; i+=2) {\n-                        transitCertSigAlgs.add(SignatureScheme.nameOf(\n-                                Short.toUnsignedInt(data.getShort())));\n-                    }\n-                    break;\n-                \/*case HELLO_EXT_SERVER_NAMES:\n-                    int servNameListLen = Short.toUnsignedInt(data.getShort());\n-                    while (servNameListLen > 0) {\n-                        byte[] servNameBytes = new\n-                                byte[Short.toUnsignedInt(data.getShort())];\n-                        data.get(servNameBytes);\n-                        transitServNames.add(new String(servNameBytes,\n-                                StandardCharsets.UTF_8));\n-                        servNameListLen -= (2 + servNameBytes.length);\n-                    }\n-                    break;*\/\n-                default:\n-                    data.position(data.position() + extLen);\n-                    break;\n-            }\n-        }\n-\n-        System.out.println(\"Transmitted CipherSuites: \" + transitCSs);\n-        System.out.println(\"Transmitted ProtocolVersions : \" + transitPVs);\n-        System.out.println(\"Transmitted ALPNs: \" + transitALPNs);\n-        System.out.println(\"Transmitted NamedGroups: \" + transitNmdGrps);\n-        System.out.println(\"Transmitted SignatureSchemes: \" + transitSigSchms);\n-        System.out.println(\"Transmitted CertificateSignatureAlgorithms: \" +\n-                transitCertSigAlgs);\n-        System.out.println(\"Transmitted CompressionAlgorithms: \" +\n-                transitCmprsnAlgs);\n-        \/*System.out.println(\"Transmitted ServerNames: \" + transitServNames);*\/\n-\n-        if (containsDuplicates(transitCSs)) {\n-            throw new RuntimeException(\"CipherSuite list contains duplicates\");\n-        }\n-        if (containsDuplicates(transitPVs)) {\n-            throw new RuntimeException(\"ProtocolVersion list contains duplicates\");\n-        }\n-        if (containsDuplicates(transitALPNs)) {\n-            throw new RuntimeException(\"ALPN list contains duplicates\");\n-        }\n-        if (containsDuplicates(transitNmdGrps)) {\n-            throw new RuntimeException(\"NamedGroup list contains duplicates\");\n-        }\n-        if (containsDuplicates(transitSigSchms)) {\n-            throw new RuntimeException(\"SignatureScheme list contains duplicates\");\n-        }\n-        if (containsDuplicates(transitCertSigAlgs)) {\n-            throw new RuntimeException(\"CertificateSignatureAlgorithm list \" +\n-                    \"contains duplicates\");\n-        }\n-        \/*if (containsDuplicates(transitCmprsnAlgs)) {\n-            throw new RuntimeException(\"CompressionAlgorithm list contains \" +\n-                    \"duplicates\");\n-        }*\/\n-\n-        \/\/ move ByteBuffer location back to the beginning point saved earlier\n-        data.reset();\n-    }\n-\n-    \/**\n-     * Eliminate duplicates from a generic List while preserving order.\n-     *\n-     * @param src an unsanitized array\n-     *\n-     * @return a list with the same elements and order, but without duplicates\n-     *\/\n-    private static <T> List<T> clearDuplicates(List<T> src) {\n-        Set<T> setVers = new LinkedHashSet<>();\n-        setVers.addAll(src);\n-        List<T> clean = new ArrayList<>(setVers);\n-\n-        return clean;\n-    }\n-\n-    \/**\n-     * Check if a generic list contains duplicates. Set.add(...) returns true\n-     * if the element is not present in the set, and false otherwise, so the\n-     * return value is reversed.\n-     *\n-     * @param src list to be checked\n-     *\n-     * @return true if duplicates are found, false otherwise\n-     *\/\n-    private static <T> boolean containsDuplicates(List<T> src) {\n-        Set<T> setVers = new LinkedHashSet<>();\n-        for (T entry : src) {\n-            if (!setVers.add(entry)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-}\n","filename":"test\/jdk\/javax\/net\/ssl\/ciphersuites\/CheckDuplicateCipherSuites.java","additions":0,"deletions":580,"binary":false,"changes":580,"status":"deleted"}]}