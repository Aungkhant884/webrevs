[{"commit":{"message":"8263425: AArch64: two potential bugs in C1 LIRGenerator::generate_address()\n\nAround line 177 we have:\n\n  LIR_Opr tmp = new_pointer_register();\n  if (Assembler::operand_valid_for_add_sub_immediate(large_disp)) {\n    __ add(tmp, tmp, LIR_OprFact::intptrConst(large_disp));    <----\n    index = tmp;\n   } else {\n\nThis is supposed to be calculating \"tmp = index + large_disp\" where tmp\nis a freshly allocated register but it actually does \"large_disp = tmp +\ntmp\".\n\nOn line 155 we check if index is a constant and if so accumulate its\nvalue into large_disp. Then on line 194:\n\n  \/\/ at this point we either have base + index or base + displacement\n  if (large_disp == 0) {\n    return new LIR_Address(base, index, type);      <----\n  } else {\n\nLIR_Address::verify() asserts that index is either a register or an\nillegal value, but if the displacement and constant index sum to zero we\npass a constant in here.\n\nC1 in mainline JDK doesn't hit these code paths, but I don't see any\nreason why it couldn't in the future, and indeed it does on the lworld\nbranch. Tested tier1 on AArch64 with TieredStopAtLevel=1."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp"}],"sha":"eec02e7d4f0675e6815ae7c5f9ff0b8831fcff7a"}]