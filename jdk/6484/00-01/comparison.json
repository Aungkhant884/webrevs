{"files":[{"patch":"@@ -1362,1 +1362,1 @@\n-  ClassLoaderExt::record_result(classpath_index, ik);\n+  ClassLoaderExt::record_result(classpath_index, ik, stream);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/classFileStream.hpp\"\n@@ -231,1 +232,12 @@\n-void ClassLoaderExt::record_result(const s2 classpath_index, InstanceKlass* result) {\n+bool ClassLoaderExt::is_module_image_path(const char* path) {\n+  char* runtime_boot_path = Arguments::get_sysclasspath();\n+  char* p = strstr((char*)runtime_boot_path, os::path_separator());\n+  size_t module_path_len = (p == NULL) ? strlen(runtime_boot_path) : p - runtime_boot_path + 1;\n+  if (strlen(path) == module_path_len && strncmp(path, runtime_boot_path, module_path_len) == 0) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void ClassLoaderExt::record_result(const s2 classpath_index, InstanceKlass* result, const ClassFileStream* stream) {\n@@ -250,17 +262,14 @@\n-  if (!result->is_hidden() && classloader_type == ClassLoader::BOOT_LOADER) {\n-    \/\/ Only these classes used by heap object archiving.\n-    if (DumpSharedSpaces && AllowArchivingWithJavaAgent &&\n-        classpath_index < 0 && HeapShared::can_write()) {\n-      \/\/ During static dump, classes for the built-in loaders are always loaded from\n-      \/\/ known locations (jimage, classpath or modulepath), so classpath_index should\n-      \/\/ always be >= 0.\n-      \/\/ The only exception is when a java agent is used during dump time (for testing\n-      \/\/ purposes only). If a class is transformed by the agent, the CodeSource of\n-      \/\/ this class may point to an unknown location. This may break heap object archiving,\n-      \/\/ which requires all the boot classes to be from known locations. This is an\n-      \/\/ uncommon scenario (even in test cases). Let's simply disable heap object archiving.\n-      ResourceMark rm;\n-      log_warning(cds)(\"CDS heap objects cannot be written because class %s maybe modified by ClassFileLoadHook.\",\n-                       result->external_name());\n-      HeapShared::disable_writing();\n-    }\n+  if (DumpSharedSpaces && AllowArchivingWithJavaAgent && classloader_type == ClassLoader::BOOT_LOADER &&\n+      classpath_index < 0 && HeapShared::can_write() && is_module_image_path(stream->source())) {\n+    \/\/ During static dump, classes for the built-in loaders are always loaded from\n+    \/\/ known locations (jimage, classpath or modulepath), so classpath_index should\n+    \/\/ always be >= 0.\n+    \/\/ The only exception is when a java agent is used during dump time (for testing\n+    \/\/ purposes only). If a class is transformed by the agent, the CodeSource of\n+    \/\/ this class may point to an unknown location. This may break heap object archiving,\n+    \/\/ which requires all the boot classes to be from known locations. This is an\n+    \/\/ uncommon scenario (even in test cases). Let's simply disable heap object archiving.\n+    ResourceMark rm;\n+    log_warning(cds)(\"CDS heap objects cannot be written because class %s maybe modified by ClassFileLoadHook.\",\n+                     result->external_name());\n+    HeapShared::disable_writing();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class ClassFileStream;\n@@ -62,0 +63,1 @@\n+  static bool is_module_image_path(const char* path);\n@@ -114,1 +116,1 @@\n-  static void record_result(const s2 classpath_index, InstanceKlass* result);\n+  static void record_result(const s2 classpath_index, InstanceKlass* result, const ClassFileStream* stream);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}