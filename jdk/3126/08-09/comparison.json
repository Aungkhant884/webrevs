{"files":[{"patch":"@@ -56,0 +56,3 @@\n+                if (Utils.shouldSkipBytecode(clazz.getName(), clazz.getSuperclass())) {\n+                    return oldBytes;\n+                }\n@@ -99,0 +102,3 @@\n+            if (Utils.shouldSkipBytecode(eventName, superClass)) {\n+                return oldBytes;\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -93,0 +94,5 @@\n+    \/*\n+     * This field will be lazily initialized and the access is not synchronized.\n+     * The possible data race is benign and is worth of not introducing any contention here.\n+     *\/\n+    private static Metrics metrics;\n@@ -722,0 +728,14 @@\n+    public static boolean shouldSkipBytecode(String eventName, Class<?> superClass) {\n+        if (!superClass.getName().equals(\"jdk.jfr.events.AbstractJDKEvent\")) {\n+            return false;\n+        }\n+        return eventName.startsWith(\"jdk.Container\") && getMetrics() == null;\n+    }\n+\n+    private static Metrics getMetrics() {\n+        if (metrics == null) {\n+            metrics = Metrics.systemMetrics();\n+        }\n+        return metrics;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}