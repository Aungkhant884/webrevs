{"files":[{"patch":"@@ -2195,1 +2195,1 @@\n-void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, uint64_t imm,\n+void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,\n@@ -2199,1 +2199,1 @@\n-  if (operand_valid_for_add_sub_immediate(imm)) {\n+  if (operand_valid_for_add_sub_immediate((int)imm)) {\n@@ -2207,1 +2207,1 @@\n-       mov(Rd, imm);\n+       mov(Rd, (uint64_t)imm);\n@@ -2215,1 +2215,1 @@\n-void MacroAssembler::wrap_adds_subs_imm_insn(Register Rd, Register Rn, uint64_t imm,\n+void MacroAssembler::wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,\n@@ -2218,1 +2218,1 @@\n-  if (operand_valid_for_add_sub_immediate(imm)) {\n+  if (operand_valid_for_add_sub_immediate((int)imm)) {\n@@ -2223,1 +2223,1 @@\n-    mov(Rd, imm);\n+    mov(Rd, (uint64_t)imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-      Assembler::addw(Rd, Rn, 0U);\n+      addw(Rd, Rn, 0U);\n@@ -224,1 +224,1 @@\n-      Assembler::add(Rd, Rn, 0U);\n+      add(Rd, Rn, 0U);\n@@ -1147,1 +1147,1 @@\n-  void wrap_add_sub_imm_insn(Register Rd, Register Rn, uint64_t imm,\n+  void wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,\n@@ -1151,1 +1151,1 @@\n-  void wrap_adds_subs_imm_insn(Register Rd, Register Rn, uint64_t imm,\n+  void wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,\n@@ -1156,1 +1156,1 @@\n-  void INSN(Register Rd, Register Rn, uint64_t imm) {                   \\\n+  void INSN(Register Rd, Register Rn, unsigned imm) {                   \\\n@@ -1178,1 +1178,1 @@\n-  void INSN(Register Rd, Register Rn, uint64_t imm) {                   \\\n+  void INSN(Register Rd, Register Rn, unsigned imm) {                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6524,1 +6524,1 @@\n-    __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n+    __ sub(sp, rfp, ((unsigned)framesize-4) << LogBytesPerInt); \/\/ prolog\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5280,0 +5280,2 @@\n+  const int fill64_per_loop = 4;\n+  const int max_unrolled_fill64 = 8;\n@@ -5283,1 +5285,17 @@\n-  for (int i = 0; i < vector64_count; i++) {\n+  int start64 = 0;\n+  if (vector64_count > max_unrolled_fill64) {\n+    Label LOOP;\n+    Register index = rtmp;\n+\n+    start64 = vector64_count - (vector64_count % fill64_per_loop);\n+\n+    movl(index, 0);\n+    BIND(LOOP);\n+    for (int i = 0; i < fill64_per_loop; i++) {\n+      fill64(Address(base, index, Address::times_1, i * 64), xtmp, use64byteVector);\n+    }\n+    addl(index, fill64_per_loop * 64);\n+    cmpl(index, start64 * 64);\n+    jccb(Assembler::less, LOOP);\n+  }\n+  for (int i = start64; i < vector64_count; i++) {\n@@ -8877,1 +8895,1 @@\n-void MacroAssembler::fill32(Register dst, int disp, XMMRegister xmm) {\n+void MacroAssembler::fill32(Address dst, XMMRegister xmm) {\n@@ -8879,1 +8897,1 @@\n-  vmovdqu(Address(dst, disp), xmm);\n+  vmovdqu(dst, xmm);\n@@ -8882,1 +8900,5 @@\n-void MacroAssembler::fill64(Register dst, int disp, XMMRegister xmm, bool use64byteVector) {\n+void MacroAssembler::fill32(Register dst, int disp, XMMRegister xmm) {\n+  fill32(Address(dst, disp), xmm);\n+}\n+\n+void MacroAssembler::fill64(Address dst, XMMRegister xmm, bool use64byteVector) {\n@@ -8884,1 +8906,0 @@\n-  BasicType type[] = {T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n@@ -8886,2 +8907,2 @@\n-    fill32(dst, disp, xmm);\n-    fill32(dst, disp + 32, xmm);\n+    fill32(dst, xmm);\n+    fill32(dst.plus_disp(32), xmm);\n@@ -8889,1 +8910,1 @@\n-    evmovdquq(Address(dst, disp), xmm, Assembler::AVX_512bit);\n+    evmovdquq(dst, xmm, Assembler::AVX_512bit);\n@@ -8893,0 +8914,4 @@\n+void MacroAssembler::fill64(Register dst, int disp, XMMRegister xmm, bool use64byteVector) {\n+  fill64(Address(dst, disp), xmm, use64byteVector);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":33,"deletions":8,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1988,0 +1988,2 @@\n+  void fill32(Address dst, XMMRegister xmm);\n+\n@@ -1990,0 +1992,2 @@\n+  void fill64(Address dst, XMMRegister xmm, bool use64byteVector = false);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3075,1 +3075,1 @@\n-  if (!IdealizeClearArrayNode || _is_large) return NULL;\n+  if (_is_large) return NULL;\n@@ -3096,0 +3096,1 @@\n+  if (!IdealizeClearArrayNode) return NULL;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4000,1 +4000,1 @@\n-  } else if (opc == Op_SubI) {\n+  } else if (opc == Op_SubI || opc == Op_SubL) {\n@@ -4319,1 +4319,1 @@\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED\", n->_idx);\n+    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: Op_%s PASSED\", n->_idx, n->Name());\n@@ -4327,1 +4327,1 @@\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED\", n->_idx);\n+    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: Op_%s PASSED\", n->_idx, n->Name());\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-    static final class ThreadPerTaskExecutor implements Executor {\n+    private static final class ThreadPerTaskExecutor implements Executor {\n@@ -2137,0 +2137,32 @@\n+    @Override\n+    public T resultNow() {\n+        Object r = result;\n+        if (r != null) {\n+            if (r instanceof AltResult alt) {\n+                if (alt.ex == null) return null;\n+            } else {\n+                @SuppressWarnings(\"unchecked\")\n+                T t = (T) r;\n+                return t;\n+            }\n+        }\n+        throw new IllegalStateException();\n+    }\n+\n+    @Override\n+    public Throwable exceptionNow() {\n+        Object r = result;\n+        Throwable x;\n+        if (r instanceof AltResult alt\n+                && ((x = alt.ex) != null)\n+                && !(x instanceof CancellationException)) {\n+            if (x instanceof CompletionException) {\n+                Throwable cause = x.getCause();\n+                if (cause != null)\n+                    x = cause;\n+            }\n+            return x;\n+        }\n+        throw new IllegalStateException();\n+    }\n+\n@@ -2512,0 +2544,14 @@\n+    @Override\n+    public State state() {\n+        Object r = result;\n+        if (r == null)\n+            return State.RUNNING;\n+        if (r != NIL && r instanceof AltResult alt) {\n+            if (alt.ex instanceof CancellationException)\n+                return State.CANCELLED;\n+            else\n+                return State.FAILED;\n+        }\n+        return State.SUCCESS;\n+    }\n+\n@@ -2915,0 +2961,4 @@\n+        @Override public T resultNow() {\n+            throw new UnsupportedOperationException(); }\n+        @Override public Throwable exceptionNow() {\n+            throw new UnsupportedOperationException(); }\n@@ -2931,0 +2981,2 @@\n+        @Override public State state() {\n+            throw new UnsupportedOperationException(); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n+import jdk.internal.misc.Unsafe;\n@@ -543,1 +542,1 @@\n-        PENDING.getAndAdd(this, delta);\n+        U.getAndAddInt(this, PENDING, delta);\n@@ -555,1 +554,1 @@\n-        return PENDING.compareAndSet(this, expected, count);\n+        return U.compareAndSetInt(this, PENDING, expected, count);\n@@ -560,1 +559,1 @@\n-        return PENDING.weakCompareAndSet(this, expected, count);\n+        return U.weakCompareAndSetInt(this, PENDING, expected, count);\n@@ -736,1 +735,0 @@\n-\n@@ -782,2 +780,8 @@\n-    \/\/ VarHandle mechanics\n-    private static final VarHandle PENDING;\n+    \/*\n+     * This class uses jdk-internal Unsafe for atomics and special\n+     * memory modes, rather than VarHandles, to avoid initialization\n+     * dependencies in other jdk components that require early\n+     * parallelism.\n+     *\/\n+    private static final Unsafe U;\n+    private static final long PENDING;\n@@ -785,7 +789,2 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            PENDING = l.findVarHandle(CountedCompleter.class, \"pending\", int.class);\n-\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n+        U = Unsafe.getUnsafe();\n+        PENDING = U.objectFieldOffset(CountedCompleter.class, \"pending\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CountedCompleter.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -105,3 +105,14 @@\n- * The following method shuts down an {@code ExecutorService} in two phases,\n- * first by calling {@code shutdown} to reject incoming tasks, and then\n- * calling {@code shutdownNow}, if necessary, to cancel any lingering tasks:\n+ * An {@code ExecutorService} may also be established and closed\n+ * (shutdown, blocking until terminated) as follows; illustrating with\n+ * a different {@code Executors} factory method:\n+ *\n+ * <pre> {@code\n+ * try (ExecutorService e =  Executors.newWorkStealingPool()) {\n+ *   \/\/ submit or execute many tasks with e ...\n+ * }}<\/pre>\n+ *\n+ * Further customization is also possible. For example, the following\n+ * method shuts down an {@code ExecutorService} in two phases, first\n+ * by calling {@code shutdown} to reject incoming tasks, and then\n+ * calling {@code shutdownNow}, if necessary, to cancel any lingering\n+ * tasks:\n@@ -138,1 +149,1 @@\n-public interface ExecutorService extends Executor {\n+public interface ExecutorService extends Executor, AutoCloseable {\n@@ -371,0 +382,48 @@\n+\n+    \/**\n+     * Initiates an orderly shutdown in which previously submitted tasks are\n+     * executed, but no new tasks will be accepted. This method waits until all\n+     * tasks have completed execution and the executor has terminated.\n+     *\n+     * <p> If interrupted while waiting, this method stops all executing tasks as\n+     * if by invoking {@link #shutdownNow()}. It then continues to wait until all\n+     * actively executing tasks have completed. Tasks that were awaiting\n+     * execution are not executed. The interrupt status will be re-asserted\n+     * before this method returns.\n+     *\n+     * <p> If already terminated, invoking this method has no effect.\n+     *\n+     * @implSpec\n+     * The default implementation invokes {@code shutdown()} and waits for tasks\n+     * to complete execution with {@code awaitTermination}.\n+     *\n+     * @throws SecurityException if a security manager exists and\n+     *         shutting down this ExecutorService may manipulate\n+     *         threads that the caller is not permitted to modify\n+     *         because it does not hold {@link\n+     *         java.lang.RuntimePermission}{@code (\"modifyThread\")},\n+     *         or the security manager's {@code checkAccess} method\n+     *         denies access.\n+     * @since 19\n+     *\/\n+    @Override\n+    default void close() {\n+        boolean terminated = isTerminated();\n+        if (!terminated) {\n+            shutdown();\n+            boolean interrupted = false;\n+            while (!terminated) {\n+                try {\n+                    terminated = awaitTermination(1L, TimeUnit.DAYS);\n+                } catch (InterruptedException e) {\n+                    if (!interrupted) {\n+                        shutdownNow();\n+                        interrupted = true;\n+                    }\n+                }\n+            }\n+            if (interrupted) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ExecutorService.java","additions":63,"deletions":4,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -56,0 +54,2 @@\n+import jdk.internal.misc.Unsafe;\n+\/\/import jdk.internal.vm.SharedThreadContainer; \/\/ for loom\n@@ -161,1 +161,2 @@\n- * {@link Permissions} enabled.\n+ * {@link Permissions} enabled, and are not guaranteed to preserve\n+ * the values of {@link java.lang.ThreadLocal} variables across tasks.\n@@ -169,8 +170,7 @@\n- * <p><b>Implementation notes:<\/b> This implementation restricts the\n- * maximum number of running threads to 32767. Attempts to create\n- * pools with greater than the maximum number result in\n- * {@code IllegalArgumentException}.\n- *\n- * <p>This implementation rejects submitted tasks (that is, by throwing\n- * {@link RejectedExecutionException}) only when the pool is shut down\n- * or internal resources have been exhausted.\n+ * @implNote This implementation restricts the maximum number of\n+ * running threads to 32767. Attempts to create pools with greater\n+ * than the maximum number result in {@code\n+ * IllegalArgumentException}. Also, this implementation rejects\n+ * submitted tasks (that is, by throwing {@link\n+ * RejectedExecutionException}) only when the pool is shut down or\n+ * internal resources have been exhausted.\n@@ -205,1 +205,3 @@\n-     * details.\n+     * details. There are a fair number of odd code constructions and\n+     * design decisions for components that reside at the edge of Java\n+     * vs JVM functionality.\n@@ -230,1 +232,26 @@\n-     * (\"base\" and \"top\") to the slots themselves.\n+     * (\"base\" and \"top\") to the slots themselves. These provide the\n+     * primary required memory ordering -- see \"Correct and Efficient\n+     * Work-Stealing for Weak Memory Models\" by Le, Pop, Cohen, and\n+     * Nardelli, PPoPP 2013\n+     * (http:\/\/www.di.ens.fr\/~zappa\/readings\/ppopp13.pdf) for an\n+     * analysis of memory ordering requirements in work-stealing\n+     * algorithms similar to the one used here. We also use ordered,\n+     * moded accesses and\/or fences for other control, with modes\n+     * reflecting the presence or absence of other contextual sync\n+     * provided by atomic and\/or volatile accesses. Some methods (or\n+     * their primary loops) begin with an acquire fence or\n+     * otherwise-unnecessary volatile read that amounts to an\n+     * acquiring read of \"this\" to cover all fields (which is\n+     * sometimes stronger than necessary, but less brittle). Some\n+     * constructions are intentionally racy because they use read\n+     * values as hints, not for correctness.\n+     *\n+     * We also support a user mode in which local task processing is\n+     * in FIFO, not LIFO order, simply by using a local version of\n+     * poll rather than pop.  This can be useful in message-passing\n+     * frameworks in which tasks are never joined, although with\n+     * increased contention among task producers and consumers. Also,\n+     * the same data structure (and class) is used for \"submission\n+     * queues\" (described below) holding externally submitted tasks,\n+     * that differ only in that a lock (field \"access\"; see below) is\n+     * required by external callers to push and pop tasks.\n@@ -239,1 +266,3 @@\n-     * signals waiting workers to start scanning -- see below.\n+     * signals waiting workers to start scanning (described below),\n+     * which requires even internal usages to strictly order accesses\n+     * (using a form of lock release).\n@@ -244,1 +273,3 @@\n-     * If this fails, the queue is empty.\n+     * If this fails, the queue is empty. This operation is one part\n+     * of the nextLocalTask method, that instead does a local-poll\n+     * in FIFO mode.\n@@ -246,2 +277,2 @@\n-     * The poll operation by another stealer thread is, basically:\n-     *   if (CAS nonnull task at q.array[q.base % length] to null)\n+     * The poll operation is, basically:\n+     *   if (CAS nonnull task t = q.array[k = q.base % length] to null)\n@@ -250,72 +281,70 @@\n-     * This may fail due to contention, and may be retried.\n-     * Implementations must ensure a consistent snapshot of the base\n-     * index and the task (by looping or trying elsewhere) before\n-     * trying CAS.  There isn't actually a method of this form,\n-     * because failure due to inconsistency or contention is handled\n-     * in different ways in different contexts, normally by first\n-     * trying other queues. (For the most straightforward example, see\n-     * method pollScan.) There are further variants for cases\n-     * requiring inspection of elements before extracting them, so\n-     * must interleave these with variants of this code.  Also, a more\n-     * efficient version (nextLocalTask) is used for polls by owners.\n-     * It avoids some overhead because the queue cannot be growing\n-     * during call.\n-     *\n-     * Memory ordering.  See \"Correct and Efficient Work-Stealing for\n-     * Weak Memory Models\" by Le, Pop, Cohen, and Nardelli, PPoPP 2013\n-     * (http:\/\/www.di.ens.fr\/~zappa\/readings\/ppopp13.pdf) for an\n-     * analysis of memory ordering requirements in work-stealing\n-     * algorithms similar to the one used here.  Inserting and\n-     * extracting tasks in array slots via volatile or atomic accesses\n-     * or explicit fences provides primary synchronization.\n-     *\n-     * Operations on deque elements require reads and writes of both\n-     * indices and slots. When possible, we allow these to occur in\n-     * any order.  Because the base and top indices (along with other\n-     * pool or array fields accessed in many methods) only imprecisely\n-     * guide where to extract from, we let accesses other than the\n-     * element getAndSet\/CAS\/setVolatile appear in any order, using\n-     * plain mode. But we must still preface some methods (mainly\n-     * those that may be accessed externally) with an acquireFence to\n-     * avoid unbounded staleness. This is equivalent to acting as if\n-     * callers use an acquiring read of the reference to the pool or\n-     * queue when invoking the method, even when they do not. We use\n-     * explicit acquiring reads (getSlot) rather than plain array\n-     * access when acquire mode is required but not otherwise ensured\n-     * by context. To reduce stalls by other stealers, we encourage\n-     * timely writes to the base index by immediately following\n-     * updates with a write of a volatile field that must be updated\n-     * anyway, or an Opaque-mode write if there is no such\n-     * opportunity.\n-     *\n-     * Because indices and slot contents cannot always be consistent,\n-     * the emptiness check base == top is only quiescently accurate\n-     * (and so used where this suffices). Otherwise, it may err on the\n-     * side of possibly making the queue appear nonempty when a push,\n-     * pop, or poll have not fully committed, or making it appear\n-     * empty when an update of top or base has not yet been seen.\n-     * Similarly, the check in push for the queue array being full may\n-     * trigger when not completely full, causing a resize earlier than\n-     * required.\n-     *\n-     * Mainly because of these potential inconsistencies among slots\n-     * vs indices, the poll operation, considered individually, is not\n-     * wait-free. One thief cannot successfully continue until another\n-     * in-progress one (or, if previously empty, a push) visibly\n-     * completes.  This can stall threads when required to consume\n-     * from a given queue (which may spin).  However, in the\n-     * aggregate, we ensure probabilistic non-blockingness at least\n-     * until checking quiescence (which is intrinsically blocking):\n-     * If an attempted steal fails, a scanning thief chooses a\n-     * different victim target to try next. So, in order for one thief\n-     * to progress, it suffices for any in-progress poll or new push\n-     * on any empty queue to complete. The worst cases occur when many\n-     * threads are looking for tasks being produced by a stalled\n-     * producer.\n-     *\n-     * This approach also enables support of a user mode in which\n-     * local task processing is in FIFO, not LIFO order, simply by\n-     * using poll rather than pop.  This can be useful in\n-     * message-passing frameworks in which tasks are never joined,\n-     * although with increased contention among task producers and\n-     * consumers.\n+     * However, there are several more cases that must be dealt with.\n+     * Some of them are just due to asynchrony; others reflect\n+     * contention and stealing policies. Stepping through them\n+     * illustrates some of the implementation decisions in this class.\n+     *\n+     *  * Slot k must be read with an acquiring read, which it must\n+     *    anyway to dereference and run the task if the (acquiring)\n+     *    CAS succeeds, but uses an explicit acquire fence to support\n+     *    the following rechecks even if the CAS is not attempted.\n+     *\n+     *  * q.base may change between reading and using its value to\n+     *    index the slot. To avoid trying to use the wrong t, the\n+     *    index and slot must be reread (not necessarily immediately)\n+     *    until consistent, unless this is a local poll by owner, in\n+     *    which case this form of inconsistency can only appear as t\n+     *    being null, below.\n+     *\n+     *  * Similarly, q.array may change (due to a resize), unless this\n+     *    is a local poll by owner. Otherwise, when t is present, this\n+     *    only needs consideration on CAS failure (since a CAS\n+     *    confirms the non-resized case.)\n+     *\n+     *  * t may appear null because a previous poll operation has not\n+     *    yet incremented q.base, so the read is from an already-taken\n+     *    index. This form of stall reflects the non-lock-freedom of\n+     *    the poll operation. Stalls can be detected by observing that\n+     *    q.base doesn't change on repeated reads of null t and when\n+     *    no other alternatives apply, spin-wait for it to settle.  To\n+     *    reduce producing these kinds of stalls by other stealers, we\n+     *    encourage timely writes to indices using store fences when\n+     *    memory ordering is not already constrained by context.\n+     *\n+     *  * The CAS may fail, in which case we may want to retry unless\n+     *    there is too much contention. One goal is to balance and\n+     *    spread out the many forms of contention that may be\n+     *    encountered across polling and other operations to avoid\n+     *    sustained performance degradations. Across all cases where\n+     *    alternatives exist, a bounded number of CAS misses or stalls\n+     *    are tolerated (for slots, ctl, and elsewhere described\n+     *    below) before taking alternative action. These may move\n+     *    contention or retries elsewhere, which is still preferable\n+     *    to single-point bottlenecks.\n+     *\n+     *  * Even though the check \"top == base\" is quiescently accurate\n+     *    to determine whether a queue is empty, it is not of much use\n+     *    when deciding whether to try to poll or repoll after a\n+     *    failure.  Both top and base may move independently, and both\n+     *    lag updates to the underlying array. To reduce memory\n+     *    contention, when possible, non-owners avoid reading the\n+     *    \"top\" index at all, and instead use array reads, including\n+     *    one-ahead reads to check whether to repoll, relying on the\n+     *    fact that a non-empty queue does not have two null slots in\n+     *    a row, except in cases (resizes and shifts) that can be\n+     *    detected with a secondary recheck.\n+     *\n+     * The poll operations in q.poll(), scan(), helpJoin(), and\n+     * elsewhere differ with respect to whether other queues are\n+     * available to try, and the presence or nature of screening steps\n+     * when only some kinds of tasks can be taken. When alternatives\n+     * (or failing) is an option, they uniformly give up after\n+     * bounded numbers of stalls and\/or CAS failures, which reduces\n+     * contention when too many workers are polling too few tasks.\n+     * Overall, in the aggregate, we ensure probabilistic\n+     * non-blockingness of work-stealing at least until checking\n+     * quiescence (which is intrinsically blocking): If an attempted\n+     * steal fails in these ways, a scanning thief chooses a different\n+     * target to try next. In contexts where alternatives aren't\n+     * available, and when progress conditions can be isolated to\n+     * values of a single variable, simple spinloops (using\n+     * Thread.onSpinWait) are used to reduce memory traffic.\n@@ -333,4 +362,8 @@\n-     * a simple spinlock (using field \"source\"), because submitters\n-     * encountering a busy queue move to a different position to use\n-     * or create other queues. They block only when registering new\n-     * queues.\n+     * a simple spinlock because submitters encountering a busy queue\n+     * move to a different position to use or create other queues.\n+     * They (spin) block when registering new queues, and less\n+     * often in tryRemove and helpComplete.  The lock needed for\n+     * external queues is generalized (as field \"access\") for\n+     * operations on owned queues that require a fully-fenced write\n+     * (including push, parking status, and termination) in order to\n+     * deal with Dekker-like signalling constructs described below.\n@@ -352,3 +385,3 @@\n-     * state is held in a few volatile variables that are by far most\n-     * often read (not written) as status and consistency checks. We\n-     * pack as much information into them as we can.\n+     * state is held in a few variables that are by far most often\n+     * read (not written) as status and consistency checks. We pack as\n+     * much information into them as we can.\n@@ -362,6 +395,11 @@\n-     * subfields.\n-     *\n-     * Field \"mode\" holds configuration parameters as well as lifetime\n-     * status, atomically and monotonically setting SHUTDOWN, STOP,\n-     * and finally TERMINATED bits. It is updated only via bitwise\n-     * atomics (getAndBitwiseOr).\n+     * subfields. Field \"parallelism\" holds the target parallelism\n+     * (normally corresponding to pool size). It is needed (nearly)\n+     * only in methods updating ctl, so is packed nearby. As of the\n+     * current release, users can dynamically reset target\n+     * parallelism, which is read once per update, so only slowly has\n+     * an effect in creating threads or letting them time out and\n+     * terminate when idle.\n+     *\n+     * Field \"runState\" holds lifetime status, atomically and\n+     * monotonically setting SHUTDOWN, STOP, and finally TERMINATED\n+     * bits. It is updated only via bitwise atomics (getAndBitwiseOr).\n@@ -371,8 +409,9 @@\n-     * registrationLock, but is otherwise concurrently readable, and\n-     * accessed directly (although always prefaced by acquireFences or\n-     * other acquiring reads). To simplify index-based operations, the\n-     * array size is always a power of two, and all readers must\n-     * tolerate null slots.  Worker queues are at odd indices. Worker\n-     * ids masked with SMASK match their index. Shared (submission)\n-     * queues are at even indices. Grouping them together in this way\n-     * simplifies and speeds up task scanning.\n+     * registrationLock, but is otherwise concurrently readable (often\n+     * prefaced by a volatile read of mode to check termination, that\n+     * is required anyway, and serves as an acquire fence). To\n+     * simplify index-based operations, the array size is always a\n+     * power of two, and all readers must tolerate null slots.  Worker\n+     * queues are at odd indices. Worker ids masked with SMASK match\n+     * their index. Shared (submission) queues are at even\n+     * indices. Grouping them together in this way simplifies and\n+     * speeds up task scanning.\n@@ -385,5 +424,6 @@\n-     * GC, all accesses to workQueues are via indices into the\n-     * queues array (which is one source of some of the messy code\n-     * constructions here). In essence, the queues array serves as\n-     * a weak reference mechanism. Thus for example the stack top\n-     * subfield of ctl stores indices, not references.\n+     * GC, all accesses to workQueues in waiting, signalling, and\n+     * control methods are via indices into the queues array (which is\n+     * one source of some of the messy code constructions here). In\n+     * essence, the queues array serves as a weak reference\n+     * mechanism. In particular, the stack top subfield of ctl stores\n+     * indices, not references.\n@@ -409,1 +449,1 @@\n-     * recorded in the ctl stack. These workers are made available for\n+     * recorded in the ctl stack. These workers are made eligible for\n@@ -434,7 +474,9 @@\n-     * manage and track whether a worker is UNSIGNALLED (possibly\n-     * blocked waiting for a signal).  When a worker is enqueued its\n-     * phase field is set negative. Note that phase field updates lag\n-     * queue CAS releases; seeing a negative phase does not guarantee\n-     * that the worker is available. When queued, the lower 16 bits of\n-     * its phase must hold its pool index. So we place the index there\n-     * upon initialization and never modify these bits.\n+     * manage and track whether a worker is unsignalled (possibly\n+     * blocked waiting for a signal), conveniently using the sign bit\n+     * to check.  When a worker is enqueued its phase field is set\n+     * negative. Note that phase field updates lag queue CAS releases;\n+     * seeing a negative phase does not guarantee that the worker is\n+     * available (and so is never checked in this way). When queued,\n+     * the lower 16 bits of its phase must hold its pool index. So we\n+     * place the index there upon initialization and never modify\n+     * these bits.\n@@ -449,1 +491,1 @@\n-     * signalWork invocations are prefaced with a full-volatile memory\n+     * signalWork invocations are prefaced with a fully fenced memory\n@@ -460,2 +502,5 @@\n-     * If instead, tasks come in serially from only a single producer,\n-     * each worker taking its first (since the last quiescence) task\n+     * (To reduce resource usages in some cases, at the expense of\n+     * slower startup in others, activation of an idle thread is\n+     * preferred over creating a new one, here and elsewhere.)  If\n+     * instead, tasks come in serially from only a single producer,\n+     * each worker taking its first (since the last activation) task\n@@ -468,10 +513,9 @@\n-     * both approaches.  We approximate the second rule by arranging\n-     * that workers in scan() do not repeat signals when repeatedly\n-     * taking tasks from any given queue, by remembering the previous\n-     * one. There are narrow windows in which both rules may apply,\n-     * leading to duplicate or unnecessary signals. Despite such\n-     * limitations, these rules usually avoid slowdowns that otherwise\n-     * occur when too many workers contend to take too few tasks, or\n-     * when producers waste most of their time resignalling.  However,\n-     * contention and overhead effects may still occur during ramp-up,\n-     * ramp-down, and small computations involving only a few workers.\n+     * both approaches. Together these are minimally necessary for\n+     * maintaining liveness. However, they do not account for the fact\n+     * that when tasks are short-lived, signals are unnecessary\n+     * because workers will already be scanning for new tasks without\n+     * the need of new signals. We track these cases (variable\n+     * \"prevSrc\" in scan() and related methods) to avoid some\n+     * unnecessary signals and scans.  However, signal contention and\n+     * overhead effects may still occur during ramp-up, ramp-down, and\n+     * small computations involving only a few workers.\n@@ -480,37 +524,55 @@\n-     * execution of) tasks.  Scans by different workers and\/or at\n-     * different times are unlikely to poll queues in the same\n-     * order. Each scan traverses and tries to poll from each queue in\n-     * a pseudorandom permutation order by starting at a random index,\n-     * and using a constant cyclically exhaustive stride; restarting\n-     * upon contention.  (Non-top-level scans; for example in\n-     * helpJoin, use simpler linear probes because they do not\n-     * systematically contend with top-level scans.)  The pseudorandom\n-     * generator need not have high-quality statistical properties in\n-     * the long term. We use Marsaglia XorShifts, seeded with the Weyl\n-     * sequence from ThreadLocalRandom probes, which are cheap and\n-     * suffice. Scans do not otherwise explicitly take into account\n-     * core affinities, loads, cache localities, etc, However, they do\n-     * exploit temporal locality (which usually approximates these) by\n-     * preferring to re-poll from the same queue after a successful\n-     * poll before trying others (see method topLevelExec).  This\n-     * reduces fairness, which is partially counteracted by using a\n-     * one-shot form of poll (tryPoll) that may lose to other workers.\n-     *\n-     * Deactivation. Method scan returns a sentinel when no tasks are\n-     * found, leading to deactivation (see awaitWork). The count\n-     * fields in ctl allow accurate discovery of quiescent states\n-     * (i.e., when all workers are idle) after deactivation. However,\n-     * this may also race with new (external) submissions, so a\n-     * recheck is also needed to determine quiescence. Upon apparently\n-     * triggering quiescence, awaitWork re-scans and self-signals if\n-     * it may have missed a signal. In other cases, a missed signal\n-     * may transiently lower parallelism because deactivation does not\n-     * necessarily mean that there is no more work, only that that\n-     * there were no tasks not taken by other workers.  But more\n-     * signals are generated (see above) to eventually reactivate if\n-     * needed.\n-     *\n-     * Trimming workers. To release resources after periods of lack of\n-     * use, a worker starting to wait when the pool is quiescent will\n-     * time out and terminate if the pool has remained quiescent for\n-     * period given by field keepAlive.\n+     * execution of) tasks by polling a pseudo-random permutation of\n+     * the array (by starting at a random index, and using a constant\n+     * cyclically exhaustive stride.) It uses the same basic polling\n+     * method as WorkQueue.poll(), but restarts with a different\n+     * permutation on each invocation. (Non-top-level scans; for\n+     * example in helpJoin, use simpler and faster linear probes\n+     * because they do not systematically contend with top-level\n+     * scans.)  The pseudorandom generator need not have high-quality\n+     * statistical properties in the long term. We use Marsaglia\n+     * XorShifts, seeded with the Weyl sequence from ThreadLocalRandom\n+     * probes, which are cheap and suffice. Scans do not otherwise\n+     * explicitly take into account core affinities, loads, cache\n+     * localities, etc, However, they do exploit temporal locality\n+     * (which usually approximates these) by preferring to re-poll\n+     * from the same queue (using method tryPoll()) after a successful\n+     * poll before trying others (see method topLevelExec), which also\n+     * reduces bookkeeping and scanning overhead.  This also reduces\n+     * fairness, which is partially counteracted by giving up on\n+     * contention.\n+     *\n+     * Deactivation. When method scan indicates that no tasks are\n+     * found by a worker, it deactivates (see awaitWork).  Note that\n+     * not finding tasks doesn't mean that there won't soon be\n+     * some. Further, a scan may give up under contention, returning\n+     * even without knowing whether any tasks are still present, which\n+     * is OK, given the above signalling rules that will eventually\n+     * maintain progress.  Blocking and unblocking via park\/unpark can\n+     * cause serious slowdowns when tasks are rapidly but irregularly\n+     * generated (which is often due to garbage collectors and other\n+     * activities). One way to ameliorate is for workers to rescan\n+     * multiple times, even when there are unlikely to be tasks. But\n+     * this causes enough memory and CAS contention to prefer using\n+     * quieter spinwaits in awaitWork; currently set to small values\n+     * that only cover near-miss scenarios for deactivate vs activate\n+     * races. Because idle workers are often not yet blocked (via\n+     * LockSupport.park), we use the WorkQueue access field to\n+     * advertise that a waiter actually needs unparking upon signal.\n+     *\n+     * When idle workers are not continually woken up, the count\n+     * fields in ctl allow efficient and accurate discovery of\n+     * quiescent states (i.e., when all workers are idle) after\n+     * deactivation. However, this voting mechanism alone does not\n+     * guarantee that a pool can become dormant (quiesced or\n+     * terminated), because external racing producers do not vote, and\n+     * can asynchronously submit new tasks. To deal with this, the\n+     * final unparked thread (in awaitWork) scans external queues to\n+     * check for tasks that could have been added during a race window\n+     * that would not be accompanied by a signal, in which case\n+     * re-activating itself (or any other worker) to recheck. The same\n+     * sets of checks are used in tryTerminate, to correctly trigger\n+     * delayed termination (shutDown, followed by quiescence) in the\n+     * presence of racing submissions. In all cases, the notion of the\n+     * \"final\" unparked thread is an approximation, because new\n+     * workers could be in the process of being constructed, which\n+     * occasionally adds some extra unnecessary processing.\n@@ -522,6 +584,22 @@\n-     * waking them up. Calls to non-abrupt shutdown() preface this by\n-     * checking isQuiescent before triggering the \"STOP\" phase of\n-     * termination. To conform to ExecutorService invoke, invokeAll,\n-     * and invokeAny specs, we must track pool status while waiting,\n-     * and interrupt interruptible callers on termination (see\n-     * ForkJoinTask.joinForPoolInvoke etc).\n+     * interrupting other workers. Calls to non-abrupt shutdown()\n+     * preface this by checking isQuiescent before triggering the\n+     * \"STOP\" phase of termination. During termination, workers are\n+     * stopped using all three of (often in parallel): releasing via\n+     * ctl (method reactivate), interrupts, and cancelling tasks that\n+     * will cause workers to not find work and exit. To support this,\n+     * worker references not removed from the queues array during\n+     * termination. It is possible for late thread creations to still\n+     * be in progress after a quiescent termination reports terminated\n+     * status, but they will also immediately terminate. To conform to\n+     * ExecutorService invoke, invokeAll, and invokeAny specs, we must\n+     * track pool status while waiting in ForkJoinTask.awaitDone, and\n+     * interrupt interruptible callers on termination, while also\n+     * avoiding cancelling other tasks that are normally completing\n+     * during quiescent termination. This is tracked by recording\n+     * ForkJoinTask.POOLSUBMIT in task status and\/or as a bit flag\n+     * argument to joining methods.\n+     *\n+     * Trimming workers. To release resources after periods of lack of\n+     * use, a worker starting to wait when the pool is quiescent will\n+     * time out and terminate if the pool has remained quiescent for\n+     * period given by field keepAlive.\n@@ -533,1 +611,1 @@\n-     * is to try to unfork it from local queue and run it.  Otherwise,\n+     * is to try to take it from local queue and run it.  Otherwise,\n@@ -556,2 +634,2 @@\n-     * (rare) possibility of reduced parallelism because of a\n-     * transient gap in the queue array.\n+     * possibility of reduced parallelism because of a transient gap\n+     * in the queue array that stalls stealers.\n@@ -567,11 +645,12 @@\n-     * Each worker records (in field \"source\") the id of the queue\n-     * from which it last stole a task.  The scan in method helpJoin\n-     * uses these markers to try to find a worker to help (i.e., steal\n-     * back a task from and execute it) that could hasten completion\n-     * of the actively joined task.  Thus, the joiner executes a task\n-     * that would be on its own local deque if the to-be-joined task\n-     * had not been stolen. This is a conservative variant of the\n-     * approach described in Wagner & Calder \"Leapfrogging: a portable\n-     * technique for implementing efficient futures\" SIGPLAN Notices,\n-     * 1993 (http:\/\/portal.acm.org\/citation.cfm?id=155354). It differs\n-     * mainly in that we only record queue ids, not full dependency\n+     * Each worker records (in field \"source\") a reference to the\n+     * queue from which it last stole a task.  The scan in method\n+     * helpJoin uses these markers to try to find a worker to help\n+     * (i.e., steal back a task from and execute it) that could hasten\n+     * completion of the actively joined task.  Thus, the joiner\n+     * executes a task that would be on its own local deque if the\n+     * to-be-joined task had not been stolen. This is a conservative\n+     * variant of the approach described in Wagner & Calder\n+     * \"Leapfrogging: a portable technique for implementing efficient\n+     * futures\" SIGPLAN Notices, 1993\n+     * (http:\/\/portal.acm.org\/citation.cfm?id=155354). It differs\n+     * mainly in that we only record queues, not full dependency\n@@ -580,5 +659,8 @@\n-     * than adding to per-task overhead. Also, searches are limited to\n-     * direct and at most two levels of indirect stealers, after which\n-     * there are rapidly diminishing returns on increased overhead.\n-     * Searches can fail to locate stealers when stalls delay\n-     * recording sources.  Further, even when accurately identified,\n+     * than adding to per-task overhead.  For CountedCompleters, the\n+     * analogous method helpComplete doesn't need stealer-tracking,\n+     * but requires a similar check of completion chains.\n+     *\n+     * In either case, searches can fail to locate stealers when\n+     * stalls delay recording sources. We avoid some of these cases by\n+     * using snapshotted values of ctl as a check that the numbers of\n+     * workers are not changing.  But even when accurately identified,\n@@ -589,13 +671,0 @@\n-     * Joining CountedCompleters (see helpComplete) differs from (and\n-     * is generally more efficient than) other cases because task\n-     * eligibility is determined by checking completion chains rather\n-     * than tracking stealers.\n-     *\n-     * Joining under timeouts (ForkJoinTask timed get) uses a\n-     * constrained mixture of helping and compensating in part because\n-     * pools (actually, only the common pool) may not have any\n-     * available threads: If the pool is saturated (all available\n-     * workers are busy), the caller tries to remove and otherwise\n-     * help; else it blocks under compensation so that it may time out\n-     * independently of any tasks.\n-     *\n@@ -612,3 +681,2 @@\n-     * commonPool (see COMMON_MAX_SPARES) better enable JVMs to cope\n-     * with programming errors and abuse before running out of\n-     * resources to do so.\n+     * commonPool better enable JVMs to cope with programming errors\n+     * and abuse before running out of resources to do so.\n@@ -622,5 +690,12 @@\n-     * footprint to the setup of about a dozen fields.\n-     *\n-     * When external threads submit to the common pool, they can\n-     * perform subtask processing (see helpComplete and related\n-     * methods) upon joins.  This caller-helps policy makes it\n+     * footprint to the setup of about a dozen fields, although with\n+     * some System property parsing and with security processing that\n+     * takes far longer than the actual construction when\n+     * SecurityManagers are used or properties are set. The common\n+     * pool is distinguished internally by having both a null\n+     * workerNamePrefix and ISCOMMON config bit set, along with\n+     * PRESET_SIZE set if parallelism was configured by system\n+     * property.\n+     *\n+     * When external threads use ForkJoinTask.fork for the common\n+     * pool, they can perform subtask processing (see helpComplete and\n+     * related methods) upon joins.  This caller-helps policy makes it\n@@ -629,7 +704,6 @@\n-     * pure caller-runs.  We do not need to record whether external\n-     * submissions are to the common pool -- if not, external help\n-     * methods return quickly. These submitters would otherwise be\n-     * blocked waiting for completion, so the extra effort (with\n-     * liberally sprinkled task status checks) in inapplicable cases\n-     * amounts to an odd form of limited spin-wait before blocking in\n-     * ForkJoinTask.join.\n+     * pure caller-runs. For the sake of ExecutorService specs, we can\n+     * only do this for tasks entered via fork, not submit.  We track\n+     * this using a task status bit (markPoolSubmission).  In all\n+     * other cases, external threads waiting for joins first check the\n+     * common pool for their task, which fails quickly if the caller\n+     * did not fork to common pool.\n@@ -641,2 +715,2 @@\n-     * including those that retry helping steps until we are sure that\n-     * none apply if there are no workers.\n+     * including those that retry helping steps or spin until we are\n+     * sure that none apply if there are no workers.\n@@ -648,1 +722,1 @@\n-     * to any user-defined ThreadGroup, and erase all ThreadLocals\n+     * to any user-defined ThreadGroup, and clear all ThreadLocals\n@@ -664,5 +738,3 @@\n-     * interrupted). If so, interruption is reinstated after blocking\n-     * if status could be visible during the scope of any task.  For\n-     * cases in which task bodies are specified or desired to\n-     * interrupt upon cancellation, ForkJoinTask.cancel can be\n-     * overridden to do so (as is done for invoke{Any,All}).\n+     * interrupted).  For cases in which task bodies are specified or\n+     * desired to interrupt upon cancellation, ForkJoinTask.cancel can\n+     * be overridden to do so (as is done for invoke{Any,All}).\n@@ -673,13 +745,31 @@\n-     * Performance can be very sensitive to placement of instances of\n-     * ForkJoinPool and WorkQueues and their queue arrays. To reduce\n-     * false-sharing impact, the @Contended annotation isolates the\n-     * ForkJoinPool.ctl field as well as the most heavily written\n-     * WorkQueue fields. These mainly reduce cache traffic by scanners.\n-     * WorkQueue arrays are presized large enough to avoid resizing\n-     * (which transiently reduces throughput) in most tree-like\n-     * computations, although not in some streaming usages. Initial\n-     * sizes are not large enough to avoid secondary contention\n-     * effects (especially for GC cardmarks) when queues are placed\n-     * near each other in memory. This is common, but has different\n-     * impact in different collectors and remains incompletely\n-     * addressed.\n+     * Performance is very sensitive to placement of instances of\n+     * ForkJoinPool and WorkQueues and their queue arrays, as well the\n+     * placement of their fields. Caches misses and contention due to\n+     * false-sharing have been observed to slow down some programs by\n+     * more than a factor of four. There is no perfect solution, in\n+     * part because isolating more fields also generates more cache\n+     * misses in more common cases (because some fields snd slots are\n+     * usually read at the same time), and the main means of placing\n+     * memory, the @Contended annotation provides only rough control\n+     * (for good reason). We isolate the ForkJoinPool.ctl field as\n+     * well the set of WorkQueue fields that otherwise cause the most\n+     * false-sharing misses with respect to other fields. Also,\n+     * ForkJoinPool fields are ordered such that fields less prone to\n+     * contention effects are first, offsetting those that otherwise\n+     * would be, while also reducing total footprint vs using\n+     * multiple @Contended regions, which tends to slow down\n+     * less-contended applications.  These arrangements mainly reduce\n+     * cache traffic by scanners, which speeds up finding tasks to\n+     * run.  Initial sizing and resizing of WorkQueue arrays is an\n+     * even more delicate tradeoff because the best strategy may vary\n+     * across garbage collectors. Small arrays are better for locality\n+     * and reduce GC scan time, but large arrays reduce both direct\n+     * false-sharing and indirect cases due to GC bookkeeping\n+     * (cardmarks etc), and reduce the number of resizes, which are\n+     * not especially fast because they require atomic transfers, and\n+     * may cause other scanning workers to stall or give up.\n+     * Currently, arrays are initialized to be fairly small but early\n+     * resizes rapidly increase size by more than a factor of two\n+     * until very large.  (Maintenance note: any changes in fields,\n+     * queues, or their uses must be accompanied by re-evaluation of\n+     * these placement and sizing decisions.)\n@@ -691,2 +781,5 @@\n-     * getAndSet, getAndAdd) along with explicit fences.  This can be\n-     * awkward and ugly, but also reflects the need to control\n+     * getAndSet, getAndAdd) along with moded accesses. These use\n+     * jdk-internal Unsafe for atomics and special memory modes,\n+     * rather than VarHandles, to avoid initialization dependencies in\n+     * other jdk components that require early parallelism.  This can\n+     * be awkward and ugly, but also reflects the need to control\n@@ -696,8 +789,13 @@\n-     * they can never be null under current usages.  Array accesses\n-     * using masked indices include checks (that are always true) that\n-     * the array length is non-zero to avoid compilers inserting more\n-     * expensive traps.  This is usually done in a \"C\"-like style of\n-     * listing declarations at the heads of methods or blocks, and\n-     * using inline assignments on first encounter.  Nearly all\n-     * explicit checks lead to bypass\/return, not exception throws,\n-     * because they may legitimately arise during shutdown.\n+     * they can never be null under current usages. Usually,\n+     * computations (held in local variables) are defined as soon as\n+     * logically enabled, sometimes to convince compilers that they\n+     * may be performed despite memory ordering constraints.  Array\n+     * accesses using masked indices include checks (that are always\n+     * true) that the array length is non-zero to avoid compilers\n+     * inserting more expensive traps.  This is usually done in a\n+     * \"C\"-like style of listing declarations at the heads of methods\n+     * or blocks, and using inline assignments on first encounter.\n+     * Nearly all explicit checks lead to bypass\/return, not exception\n+     * throws, because they may legitimately arise during shutdown. A\n+     * few unusual loop constructions encourage (with varying\n+     * effectiveness) JVMs about where (not) to place safepoints.\n@@ -720,3 +818,3 @@\n-     * (1) Static utility functions\n-     * (2) Nested (static) classes\n-     * (3) Static fields\n+     * (1) Static constants\n+     * (2) Static utility functions\n+     * (3) Nested (static) classes\n@@ -732,2 +830,1 @@\n-     * The main sources of differences of January 2020 ForkJoin\n-     * classes from previous version are:\n+     * The main sources of differences from previous version are:\n@@ -735,9 +832,9 @@\n-     * * ForkJoinTask now uses field \"aux\" to support blocking joins\n-     *   and\/or record exceptions, replacing reliance on builtin\n-     *   monitors and side tables.\n-     * * Scans probe slots (vs compare indices), along with related\n-     *   changes that reduce performance differences across most\n-     *   garbage collectors, and reduce contention.\n-     * * Refactoring for better integration of special task types and\n-     *   other capabilities that had been incrementally tacked on. Plus\n-     *   many minor reworkings to improve consistency.\n+     * * Use of Unsafe vs VarHandle, including re-instatement of some\n+     *   constructions from pre-VarHandle versions.\n+     * * Reduced memory and signal contention, mainly by distinguishing\n+     *   failure cases.\n+     * * Improved initialization, in part by preparing for possible\n+     *   removal of SecurityManager\n+     * * Enable resizing (includes refactoring quiescence\/termination)\n+     * * Unification of most internal vs external operations; some made\n+     *   possible via use of WorkQueue.access, and POOLSUBMIT status in tasks.\n@@ -746,0 +843,83 @@\n+    \/\/ static configuration constants\n+\n+    \/**\n+     * Default idle timeout value (in milliseconds) for idle threads\n+     * to park waiting for new work before terminating.\n+     *\/\n+    static final long DEFAULT_KEEPALIVE = 60_000L;\n+\n+    \/**\n+     * Undershoot tolerance for idle timeouts\n+     *\/\n+    static final long TIMEOUT_SLOP = 20L;\n+\n+    \/**\n+     * The default value for common pool maxSpares.  Overridable using\n+     * the \"java.util.concurrent.ForkJoinPool.common.maximumSpares\"\n+     * system property.  The default value is far in excess of normal\n+     * requirements, but also far short of MAX_CAP and typical OS\n+     * thread limits, so allows JVMs to catch misuse\/abuse before\n+     * running out of resources needed to do so.\n+     *\/\n+    static final int DEFAULT_COMMON_MAX_SPARES = 256;\n+\n+    \/**\n+     * Initial capacity of work-stealing queue array.  Must be a power\n+     * of two, at least 2. See above.\n+     *\/\n+    static final int INITIAL_QUEUE_CAPACITY = 1 << 6;\n+\n+    \/\/ Bounds\n+    static final int SWIDTH    = 16;               \/\/ width of short\n+    static final int SMASK     = 0xffff;           \/\/ short bits == max index\n+    static final int MAX_CAP   = 0x7fff;           \/\/ max #workers - 1\n+\n+    \/\/ pool.runState and workQueue.access bits and sentinels\n+    static final int STOP         = 1 << 31;       \/\/ must be negative\n+    static final int SHUTDOWN     = 1;\n+    static final int TERMINATED   = 2;\n+    static final int PARKED       = -1;            \/\/ access value when parked\n+\n+    \/\/ {pool, workQueue}.config bits\n+    static final int FIFO         = 1 << 16;       \/\/ fifo queue or access mode\n+    static final int SRC          = 1 << 17;       \/\/ set when stealable\n+    static final int CLEAR_TLS    = 1 << 18;       \/\/ set for Innocuous workers\n+    static final int TRIMMED      = 1 << 19;       \/\/ timed out while idle\n+    static final int ISCOMMON     = 1 << 20;       \/\/ set for common pool\n+    static final int PRESET_SIZE  = 1 << 21;       \/\/ size was set by property\n+\n+    static final int UNCOMPENSATE = 1 << 16;       \/\/ tryCompensate return\n+\n+    \/*\n+     * Bits and masks for ctl and bounds are packed with 4 16 bit subfields:\n+     * RC: Number of released (unqueued) workers\n+     * TC: Number of total workers\n+     * SS: version count and status of top waiting thread\n+     * ID: poolIndex of top of Treiber stack of waiters\n+     *\n+     * When convenient, we can extract the lower 32 stack top bits\n+     * (including version bits) as sp=(int)ctl. When sp is non-zero,\n+     * there are waiting workers.  Count fields may be transiently\n+     * negative during termination because of out-of-order updates.\n+     * To deal with this, we use casts in and out of \"short\" and\/or\n+     * signed shifts to maintain signedness. Because it occupies\n+     * uppermost bits, we can add one release count using getAndAdd of\n+     * RC_UNIT, rather than CAS, when returning from a blocked join.\n+     * Other updates of multiple subfields require CAS.\n+     *\/\n+\n+    \/\/ Lower and upper word masks\n+    static final long SP_MASK  = 0xffffffffL;\n+    static final long UC_MASK  = ~SP_MASK;\n+    \/\/ Release counts\n+    static final int  RC_SHIFT = 48;\n+    static final long RC_UNIT  = 0x0001L << RC_SHIFT;\n+    static final long RC_MASK  = 0xffffL << RC_SHIFT;\n+    \/\/ Total counts\n+    static final int  TC_SHIFT = 32;\n+    static final long TC_UNIT  = 0x0001L << TC_SHIFT;\n+    static final long TC_MASK  = 0xffffL << TC_SHIFT;\n+    \/\/ sp bits\n+    static final int SS_SEQ    = 1 << 16;  \/\/ version count\n+    static final int INACTIVE  = 1 << 31;  \/\/ phase bit when idle\n+\n@@ -752,7 +932,0 @@\n-    private static void checkPermission() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null)\n-            security.checkPermission(modifyThreadPermission);\n-    }\n-\n@@ -760,6 +933,8 @@\n-    static AccessControlContext contextWithPermissions(Permission ... perms) {\n-        Permissions permissions = new Permissions();\n-        for (Permission perm : perms)\n-            permissions.add(perm);\n-        return new AccessControlContext(\n-            new ProtectionDomain[] { new ProtectionDomain(null, permissions) });\n+    private static void checkPermission() {\n+        SecurityManager security; RuntimePermission perm;\n+        if ((security = System.getSecurityManager()) != null) {\n+            if ((perm = modifyThreadPermission) == null)\n+                modifyThreadPermission = perm = \/\/ races OK\n+                    new RuntimePermission(\"modifyThread\");\n+            security.checkPermission(perm);\n+        }\n@@ -802,1 +977,20 @@\n-        \/\/ ACC for access to the factory\n+        public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {\n+            boolean isCommon = (pool.workerNamePrefix == null);\n+            @SuppressWarnings(\"removal\")\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm == null)\n+                return new ForkJoinWorkerThread(null, pool, true, false);\n+            else if (isCommon)\n+                return newCommonWithACC(pool);\n+            else\n+                return newRegularWithACC(pool);\n+        }\n+\n+        \/*\n+         * Create and use static AccessControlContexts only if there\n+         * is a SecurityManager. (These can be removed if\/when\n+         * SecurityManagers are removed from platform.) The ACCs are\n+         * immutable and equivalent even when racily initialized, so\n+         * they don't require locking, although with the chance of\n+         * needlessly duplicate construction.\n+         *\/\n@@ -804,3 +998,2 @@\n-        private static final AccessControlContext ACC = contextWithPermissions(\n-            new RuntimePermission(\"getClassLoader\"),\n-            new RuntimePermission(\"setContextClassLoader\"));\n+        static volatile AccessControlContext regularACC, commonACC;\n+\n@@ -808,1 +1001,10 @@\n-        public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {\n+        static ForkJoinWorkerThread newRegularWithACC(ForkJoinPool pool) {\n+            AccessControlContext acc = regularACC;\n+            if (acc == null) {\n+                Permissions ps = new Permissions();\n+                ps.add(new RuntimePermission(\"getClassLoader\"));\n+                ps.add(new RuntimePermission(\"setContextClassLoader\"));\n+                regularACC = acc =\n+                    new AccessControlContext(new ProtectionDomain[] {\n+                            new ProtectionDomain(null, ps) });\n+            }\n@@ -813,2 +1015,1 @@\n-                    }},\n-                ACC);\n+                    }}, acc);\n@@ -816,18 +1017,0 @@\n-    }\n-\n-    \/**\n-     * Factory for CommonPool unless overridden by System property.\n-     * Creates InnocuousForkJoinWorkerThreads if a security manager is\n-     * present at time of invocation.  Support requires that we break\n-     * quite a lot of encapsulation (some via helper methods in\n-     * ThreadLocalRandom) to access and set Thread fields.\n-     *\/\n-    static final class DefaultCommonPoolForkJoinWorkerThreadFactory\n-        implements ForkJoinWorkerThreadFactory {\n-        @SuppressWarnings(\"removal\")\n-        private static final AccessControlContext ACC = contextWithPermissions(\n-            modifyThreadPermission,\n-            new RuntimePermission(\"enableContextClassLoaderOverride\"),\n-            new RuntimePermission(\"modifyThreadGroup\"),\n-            new RuntimePermission(\"getClassLoader\"),\n-            new RuntimePermission(\"setContextClassLoader\"));\n@@ -836,1 +1019,13 @@\n-        public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {\n+        static ForkJoinWorkerThread newCommonWithACC(ForkJoinPool pool) {\n+            AccessControlContext acc = commonACC;\n+            if (acc == null) {\n+                Permissions ps = new Permissions();\n+                ps.add(new RuntimePermission(\"getClassLoader\"));\n+                ps.add(new RuntimePermission(\"setContextClassLoader\"));\n+                ps.add(new RuntimePermission(\"modifyThread\"));\n+                ps.add(new RuntimePermission(\"enableContextClassLoaderOverride\"));\n+                ps.add(new RuntimePermission(\"modifyThreadGroup\"));\n+                commonACC = acc =\n+                    new AccessControlContext(new ProtectionDomain[] {\n+                            new ProtectionDomain(null, ps) });\n+            }\n@@ -838,7 +1033,5 @@\n-                 new PrivilegedAction<>() {\n-                     public ForkJoinWorkerThread run() {\n-                         return System.getSecurityManager() == null ?\n-                             new ForkJoinWorkerThread(null, pool, true, true):\n-                             new ForkJoinWorkerThread.\n-                             InnocuousForkJoinWorkerThread(pool); }},\n-                 ACC);\n+                new PrivilegedAction<>() {\n+                    public ForkJoinWorkerThread run() {\n+                        return new ForkJoinWorkerThread.\n+                            InnocuousForkJoinWorkerThread(pool);\n+                    }}, acc);\n@@ -848,27 +1041,0 @@\n-    \/\/ Constants shared across ForkJoinPool and WorkQueue\n-\n-    \/\/ Bounds\n-    static final int SWIDTH       = 16;            \/\/ width of short\n-    static final int SMASK        = 0xffff;        \/\/ short bits == max index\n-    static final int MAX_CAP      = 0x7fff;        \/\/ max #workers - 1\n-\n-    \/\/ Masks and units for WorkQueue.phase and ctl sp subfield\n-    static final int UNSIGNALLED  = 1 << 31;       \/\/ must be negative\n-    static final int SS_SEQ       = 1 << 16;       \/\/ version count\n-\n-    \/\/ Mode bits and sentinels, some also used in WorkQueue fields\n-    static final int FIFO         = 1 << 16;       \/\/ fifo queue or access mode\n-    static final int SRC          = 1 << 17;       \/\/ set for valid queue ids\n-    static final int INNOCUOUS    = 1 << 18;       \/\/ set for Innocuous workers\n-    static final int QUIET        = 1 << 19;       \/\/ quiescing phase or source\n-    static final int SHUTDOWN     = 1 << 24;\n-    static final int TERMINATED   = 1 << 25;\n-    static final int STOP         = 1 << 31;       \/\/ must be negative\n-    static final int UNCOMPENSATE = 1 << 16;       \/\/ tryCompensate return\n-\n-    \/**\n-     * Initial capacity of work-stealing queue array.  Must be a power\n-     * of two, at least 2. See above.\n-     *\/\n-    static final int INITIAL_QUEUE_CAPACITY = 1 << 8;\n-\n@@ -880,1 +1046,0 @@\n-        volatile int phase;        \/\/ versioned, negative if inactive\n@@ -887,1 +1052,1 @@\n-        \/\/ segregate fields frequently updated but not read by scans or steals\n+        \/\/ fields otherwise causing more unnecessary false-sharing cache misses\n@@ -891,1 +1056,5 @@\n-        volatile int source;       \/\/ source queue id, lock, or sentinel\n+        volatile int access;       \/\/ values 0, 1 (locked), PARKED, STOP\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        volatile int phase;        \/\/ versioned, negative if inactive\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        volatile int source;       \/\/ source queue id in topLevelExec\n@@ -896,9 +1065,9 @@\n-        private static final VarHandle QA; \/\/ for array slots\n-        private static final VarHandle SOURCE;\n-        private static final VarHandle BASE;\n-        static final ForkJoinTask<?> getSlot(ForkJoinTask<?>[] a, int i) {\n-            return (ForkJoinTask<?>)QA.getAcquire(a, i);\n-        }\n-        static final ForkJoinTask<?> getAndClearSlot(ForkJoinTask<?>[] a,\n-                                                     int i) {\n-            return (ForkJoinTask<?>)QA.getAndSet(a, i, null);\n+        private static final Unsafe U;\n+        private static final long ACCESS;\n+        private static final long PHASE;\n+        private static final long ABASE;\n+        private static final int  ASHIFT;\n+\n+        static ForkJoinTask<?> getAndClearSlot(ForkJoinTask<?>[] a, int i) {\n+            return (ForkJoinTask<?>)\n+                U.getAndSetReference(a, ((long)i << ASHIFT) + ABASE, null);\n@@ -906,3 +1075,4 @@\n-        static final void setSlotVolatile(ForkJoinTask<?>[] a, int i,\n-                                          ForkJoinTask<?> v) {\n-            QA.setVolatile(a, i, v);\n+        static boolean casSlotToNull(ForkJoinTask<?>[] a, int i,\n+                                     ForkJoinTask<?> c) {\n+            return U.compareAndSetReference(a, ((long)i << ASHIFT) + ABASE,\n+                                            c, null);\n@@ -910,3 +1080,2 @@\n-        static final boolean casSlotToNull(ForkJoinTask<?>[] a, int i,\n-                                          ForkJoinTask<?> c) {\n-            return QA.compareAndSet(a, i, c, null);\n+        final void forcePhaseActive() {    \/\/ clear sign bit\n+            U.getAndBitwiseAndInt(this, PHASE, 0x7fffffff);\n@@ -914,2 +1083,2 @@\n-        final boolean tryLock() {\n-            return SOURCE.compareAndSet(this, 0, 1);\n+        final int getAndSetAccess(int v) {\n+            return U.getAndSetInt(this, ACCESS, v);\n@@ -917,2 +1086,2 @@\n-        final void setBaseOpaque(int b) {\n-            BASE.setOpaque(this, b);\n+        final void releaseAccess() {\n+            U.putIntRelease(this, ACCESS, 0);\n@@ -922,2 +1091,2 @@\n-         * Constructor used by ForkJoinWorkerThreads. Most fields\n-         * are initialized upon thread start, in pool.registerWorker.\n+         * Constructor. For owned queues, most fields are initialized\n+         * upon thread start in pool.registerWorker.\n@@ -925,2 +1094,1 @@\n-        WorkQueue(ForkJoinWorkerThread owner, boolean isInnocuous) {\n-            this.config = (isInnocuous) ? INNOCUOUS : 0;\n+        WorkQueue(ForkJoinWorkerThread owner, int config) {\n@@ -928,7 +1096,0 @@\n-        }\n-\n-        \/**\n-         * Constructor used for external queues.\n-         *\/\n-        WorkQueue(int config) {\n-            array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n@@ -936,2 +1097,1 @@\n-            owner = null;\n-            phase = -1;\n+            base = top = 1;\n@@ -951,11 +1111,2 @@\n-            VarHandle.acquireFence(); \/\/ ensure fresh reads by external callers\n-            int n = top - base;\n-            return (n < 0) ? 0 : n;   \/\/ ignore transient negative\n-        }\n-\n-        \/**\n-         * Provides a more conservative estimate of whether this queue\n-         * has any tasks than does queueSize.\n-         *\/\n-        final boolean isEmpty() {\n-            return !((source != 0 && owner == null) || top - base > 0);\n+            int unused = access;            \/\/ for ordering effect\n+            return Math.max(top - base, 0); \/\/ ignore transient negative\n@@ -965,1 +1116,1 @@\n-         * Pushes a task. Call only by owner in unshared queues.\n+         * Pushes a task. Called only by owner or if already locked\n@@ -968,1 +1119,2 @@\n-         * @param pool (no-op if null)\n+         * @param pool the pool. Must be non-null unless terminating.\n+         * @param signalIfEmpty true if signal when pushing to empty queue\n@@ -971,56 +1123,24 @@\n-        final void push(ForkJoinTask<?> task, ForkJoinPool pool) {\n-            ForkJoinTask<?>[] a = array;\n-            int s = top++, d = s - base, cap, m; \/\/ skip insert if disabled\n-            if (a != null && pool != null && (cap = a.length) > 0) {\n-                setSlotVolatile(a, (m = cap - 1) & s, task);\n-                if (d == m)\n-                    growArray();\n-                if (d == m || a[m & (s - 1)] == null)\n-                    pool.signalWork(); \/\/ signal if was empty or resized\n-            }\n-        }\n-\n-        \/**\n-         * Pushes task to a shared queue with lock already held, and unlocks.\n-         *\n-         * @return true if caller should signal work\n-         *\/\n-        final boolean lockedPush(ForkJoinTask<?> task) {\n-            ForkJoinTask<?>[] a = array;\n-            int s = top++, d = s - base, cap, m;\n-            if (a != null && (cap = a.length) > 0) {\n-                a[(m = cap - 1) & s] = task;\n-                if (d == m)\n-                    growArray();\n-                source = 0; \/\/ unlock\n-                if (d == m || a[m & (s - 1)] == null)\n-                    return true;\n-            }\n-            return false;\n-        }\n-\n-        \/**\n-         * Doubles the capacity of array. Called by owner or with lock\n-         * held after pre-incrementing top, which is reverted on\n-         * allocation failure.\n-         *\/\n-        final void growArray() {\n-            ForkJoinTask<?>[] oldArray = array, newArray;\n-            int s = top - 1, oldCap, newCap;\n-            if (oldArray != null && (oldCap = oldArray.length) > 0 &&\n-                (newCap = oldCap << 1) > 0) { \/\/ skip if disabled\n-                try {\n-                    newArray = new ForkJoinTask<?>[newCap];\n-                } catch (Throwable ex) {\n-                    top = s;\n-                    if (owner == null)\n-                        source = 0; \/\/ unlock\n-                    throw new RejectedExecutionException(\n-                        \"Queue capacity exceeded\");\n-                }\n-                int newMask = newCap - 1, oldMask = oldCap - 1;\n-                for (int k = oldCap; k > 0; --k, --s) {\n-                    ForkJoinTask<?> x;        \/\/ poll old, push to new\n-                    if ((x = getAndClearSlot(oldArray, s & oldMask)) == null)\n-                        break;                \/\/ others already taken\n-                    newArray[s & newMask] = x;\n+        final void push(ForkJoinTask<?> task, ForkJoinPool pool,\n+                        boolean signalIfEmpty) {\n+            boolean resize = false;\n+            int s = top++, b = base, cap, m; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0) {\n+                if ((m = (cap - 1)) == s - b) {\n+                    resize = true;            \/\/ rapidly grow until large\n+                    int newCap = (cap < 1 << 24) ? cap << 2 : cap << 1;\n+                    ForkJoinTask<?>[] newArray;\n+                    try {\n+                        newArray = new ForkJoinTask<?>[newCap];\n+                    } catch (Throwable ex) {\n+                        top = s;\n+                        access = 0;\n+                        throw new RejectedExecutionException(\n+                            \"Queue capacity exceeded\");\n+                    }\n+                    if (newCap > 0) {         \/\/ always true\n+                        int newMask = newCap - 1, k = s;\n+                        do {                  \/\/ poll old, push to new\n+                            newArray[k-- & newMask] = task;\n+                        } while ((task = getAndClearSlot(a, k & m)) != null);\n+                    }\n+                    array = newArray;\n@@ -1028,2 +1148,6 @@\n-                VarHandle.releaseFence();     \/\/ fill before publish\n-                array = newArray;\n+                else\n+                    a[m & s] = task;\n+                getAndSetAccess(0);           \/\/ for memory effects if owned\n+                if ((resize || (a[m & (s - 1)] == null && signalIfEmpty)) &&\n+                    pool != null)\n+                    pool.signalWork();\n@@ -1033,2 +1157,0 @@\n-        \/\/ Variants of pop\n-\n@@ -1036,1 +1158,3 @@\n-         * Pops and returns task, or null if empty. Called only by owner.\n+         * Takes next task, if one exists, in order specified by mode,\n+         * so acts as either local-pop or local-poll. Called only by owner.\n+         * @param fifo nonzero if FIFO mode\n@@ -1038,1 +1162,1 @@\n-        private ForkJoinTask<?> pop() {\n+        final ForkJoinTask<?> nextLocalTask(int fifo) {\n@@ -1040,4 +1164,22 @@\n-            int s = top, cap; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0 && base != s-- &&\n-                (t = getAndClearSlot(a, (cap - 1) & s)) != null)\n-                top = s;\n+            ForkJoinTask<?>[] a = array;\n+            int p = top, s = p - 1, b = base, nb, cap;\n+            if (p - b > 0 && a != null && (cap = a.length) > 0) {\n+                do {\n+                    if (fifo == 0 || (nb = b + 1) == p) {\n+                        if ((t = getAndClearSlot(a, (cap - 1) & s)) != null)\n+                            top = s;\n+                        break;                   \/\/ lost race for only task\n+                    }\n+                    else if ((t = getAndClearSlot(a, (cap - 1) & b)) != null) {\n+                        base = nb;\n+                        break;\n+                    }\n+                    else {\n+                        while (b == (b = base)) {\n+                            U.loadFence();\n+                            Thread.onSpinWait(); \/\/ spin to reduce memory traffic\n+                        }\n+                    }\n+                } while (p - b > 0);\n+                U.storeStoreFence(); \/\/ for timely index updates\n+            }\n@@ -1048,1 +1190,2 @@\n-         * Pops the given task for owner only if it is at the current top.\n+         * Takes next task, if one exists, using configured mode.\n+         * (Always owned, never called for Common pool.)\n@@ -1050,8 +1193,2 @@\n-        final boolean tryUnpush(ForkJoinTask<?> task) {\n-            int s = top, cap; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0 && base != s-- &&\n-                casSlotToNull(a, (cap - 1) & s, task)) {\n-                top = s;\n-                return true;\n-            }\n-            return false;\n+        final ForkJoinTask<?> nextLocalTask() {\n+            return nextLocalTask(config & FIFO);\n@@ -1061,1 +1198,1 @@\n-         * Locking version of tryUnpush.\n+         * Pops the given task only if it is at the current top.\n@@ -1063,14 +1200,13 @@\n-        final boolean externalTryUnpush(ForkJoinTask<?> task) {\n-            boolean taken = false;\n-            for (;;) {\n-                int s = top, cap, k; ForkJoinTask<?>[] a;\n-                if ((a = array) == null || (cap = a.length) <= 0 ||\n-                    a[k = (cap - 1) & (s - 1)] != task)\n-                    break;\n-                if (tryLock()) {\n-                    if (top == s && array == a) {\n-                        if (taken = casSlotToNull(a, k, task)) {\n-                            top = s - 1;\n-                            source = 0;\n-                            break;\n-                        }\n+        final boolean tryUnpush(ForkJoinTask<?> task, boolean owned) {\n+            ForkJoinTask<?>[] a = array;\n+            int p = top, s, cap, k;\n+            if (task != null && base != p && a != null && (cap = a.length) > 0 &&\n+                a[k = (cap - 1) & (s = p - 1)] == task) {\n+                if (owned || getAndSetAccess(1) == 0) {\n+                    if (top != p || a[k] != task ||\n+                        getAndClearSlot(a, k) == null)\n+                        access = 0;\n+                    else {\n+                        top = s;\n+                        access = 0;\n+                        return true;\n@@ -1078,1 +1214,0 @@\n-                    source = 0; \/\/ release lock for retry\n@@ -1080,1 +1215,0 @@\n-                Thread.yield(); \/\/ trylock failure\n@@ -1082,1 +1216,1 @@\n-            return taken;\n+            return false;\n@@ -1086,2 +1220,1 @@\n-         * Deep form of tryUnpush: Traverses from top and removes task if\n-         * present, shifting others to fill gap.\n+         * Returns next task, if one exists, in order specified by mode.\n@@ -1089,18 +1222,11 @@\n-        final boolean tryRemove(ForkJoinTask<?> task, boolean owned) {\n-            boolean taken = false;\n-            int p = top, cap; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n-            if ((a = array) != null && task != null && (cap = a.length) > 0) {\n-                int m = cap - 1, s = p - 1, d = p - base;\n-                for (int i = s, k; d > 0; --i, --d) {\n-                    if ((t = a[k = i & m]) == task) {\n-                        if (owned || tryLock()) {\n-                            if ((owned || (array == a && top == p)) &&\n-                                (taken = casSlotToNull(a, k, t))) {\n-                                for (int j = i; j != s; ) \/\/ shift down\n-                                    a[j & m] = getAndClearSlot(a, ++j & m);\n-                                top = s;\n-                            }\n-                            if (!owned)\n-                                source = 0;\n-                        }\n-                        break;\n+        final ForkJoinTask<?> peek() {\n+            ForkJoinTask<?>[] a = array;\n+            int cfg = config, p = top, b = base, cap;\n+            if (p != b && a != null && (cap = a.length) > 0) {\n+                if ((cfg & FIFO) == 0)\n+                    return a[(cap - 1) & (p - 1)];\n+                else { \/\/ skip over in-progress removals\n+                    ForkJoinTask<?> t;\n+                    for ( ; p - b > 0; ++b) {\n+                        if ((t = a[(cap - 1) & b]) != null)\n+                            return t;\n@@ -1110,1 +1236,1 @@\n-            return taken;\n+            return null;\n@@ -1113,2 +1239,0 @@\n-        \/\/ variants of poll\n-\n@@ -1116,2 +1240,4 @@\n-         * Tries once to poll next task in FIFO order, failing on\n-         * inconsistency or contention.\n+         * Polls for a task. Used only by non-owners in usually\n+         * uncontended contexts.\n+         *\n+         * @param pool if nonnull, pool to signal if more tasks exist\n@@ -1119,6 +1245,15 @@\n-        final ForkJoinTask<?> tryPoll() {\n-            int cap, b, k; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                ForkJoinTask<?> t = getSlot(a, k = (cap - 1) & (b = base));\n-                if (base == b++ && t != null && casSlotToNull(a, k, t)) {\n-                    setBaseOpaque(b);\n+        final ForkJoinTask<?> poll(ForkJoinPool pool) {\n+            for (int b = base;;) {\n+                int cap; ForkJoinTask<?>[] a;\n+                if ((a = array) == null || (cap = a.length) <= 0)\n+                    break;                        \/\/ currently impossible\n+                int k = (cap - 1) & b, nb = b + 1, nk = (cap - 1) & nb;\n+                ForkJoinTask<?> t = a[k];\n+                U.loadFence();                    \/\/ for re-reads\n+                if (b != (b = base))              \/\/ inconsistent\n+                    ;\n+                else if (t != null && casSlotToNull(a, k, t)) {\n+                    base = nb;\n+                    U.storeFence();\n+                    if (pool != null && a[nk] != null)\n+                        pool.signalWork();        \/\/ propagate\n@@ -1127,0 +1262,4 @@\n+                else if (array != a || a[k] != null)\n+                    ;                             \/\/ stale\n+                else if (a[nk] == null && top - b <= 0)\n+                    break;                        \/\/ empty\n@@ -1132,1 +1271,3 @@\n-         * Takes next task, if one exists, in order specified by mode.\n+         * Tries to poll next task in FIFO order, failing on\n+         * contention or stalls. Used only by topLevelExec to repoll\n+         * from the queue obtained from pool.scan.\n@@ -1134,3 +1275,2 @@\n-        final ForkJoinTask<?> nextLocalTask(int cfg) {\n-            ForkJoinTask<?> t = null;\n-            int s = top, cap; ForkJoinTask<?>[] a;\n+        final ForkJoinTask<?> tryPoll() {\n+            int b = base, cap; ForkJoinTask<?>[] a;\n@@ -1138,11 +1278,13 @@\n-                for (int b, d;;) {\n-                    if ((d = s - (b = base)) <= 0)\n-                        break;\n-                    if (d == 1 || (cfg & FIFO) == 0) {\n-                        if ((t = getAndClearSlot(a, --s & (cap - 1))) != null)\n-                            top = s;\n-                        break;\n-                    }\n-                    if ((t = getAndClearSlot(a, b++ & (cap - 1))) != null) {\n-                        setBaseOpaque(b);\n-                        break;\n+                for (;;) {\n+                    int k = (cap - 1) & b, nb = b + 1;\n+                    ForkJoinTask<?> t = a[k];\n+                    U.loadFence();                \/\/ for re-reads\n+                    if (b != (b = base))\n+                        ;                         \/\/ inconsistent\n+                    else if (t != null) {\n+                        if (casSlotToNull(a, k, t)) {\n+                            base = nb;\n+                            U.storeStoreFence();\n+                            return t;\n+                        }\n+                        break;                   \/\/ contended\n@@ -1150,0 +1292,2 @@\n+                    else if (a[k] == null)\n+                        break;                   \/\/ empty or stalled\n@@ -1152,18 +1296,1 @@\n-            return t;\n-        }\n-\n-        \/**\n-         * Takes next task, if one exists, using configured mode.\n-         *\/\n-        final ForkJoinTask<?> nextLocalTask() {\n-            return nextLocalTask(config);\n-        }\n-\n-        \/**\n-         * Returns next task, if one exists, in order specified by mode.\n-         *\/\n-        final ForkJoinTask<?> peek() {\n-            VarHandle.acquireFence();\n-            int cap; ForkJoinTask<?>[] a;\n-            return ((a = array) != null && (cap = a.length) > 0) ?\n-                a[(cap - 1) & ((config & FIFO) != 0 ? base : top - 1)] : null;\n+            return null;\n@@ -1176,2 +1303,2 @@\n-         * remaining local tasks and\/or others available from the\n-         * given queue.\n+         * remaining local tasks and\/or others available from its\n+         * source queue, if any.\n@@ -1179,2 +1306,2 @@\n-        final void topLevelExec(ForkJoinTask<?> task, WorkQueue q) {\n-            int cfg = config, nstolen = 1;\n+        final void topLevelExec(ForkJoinTask<?> task, WorkQueue src) {\n+            int cfg = config, fifo = cfg & FIFO, nstolen = 1;\n@@ -1183,2 +1310,2 @@\n-                if ((task = nextLocalTask(cfg)) == null &&\n-                    q != null && (task = q.tryPoll()) != null)\n+                if ((task = nextLocalTask(fifo)) == null &&\n+                    src != null && (task = src.tryPoll()) != null)\n@@ -1189,1 +1316,1 @@\n-            if ((cfg & INNOCUOUS) != 0)\n+            if ((cfg & CLEAR_TLS) != 0)\n@@ -1193,0 +1320,38 @@\n+        \/**\n+         * Deep form of tryUnpush: Traverses from top and removes and\n+         * runs task if present, shifting others to fill gap.\n+         * @return task status if removed, else 0\n+         *\/\n+        final int tryRemoveAndExec(ForkJoinTask<?> task, boolean owned) {\n+            ForkJoinTask<?>[] a = array;\n+            int p = top, s = p - 1, d = p - base, cap;\n+            if (task != null && d > 0 && a != null && (cap = a.length) > 0) {\n+                for (int m = cap - 1, i = s; ; --i) {\n+                    ForkJoinTask<?> t; int k;\n+                    if ((t = a[k = i & m]) == task) {\n+                        if (!owned && getAndSetAccess(1) != 0)\n+                            break;                 \/\/ fail if locked\n+                        else if (top != p || a[k] != task ||\n+                                 getAndClearSlot(a, k) == null) {\n+                            access = 0;\n+                            break;                 \/\/ missed\n+                        }\n+                        else {\n+                            if (i != s && i == base)\n+                                base = i + 1;      \/\/ avoid shift\n+                            else {\n+                                for (int j = i; j != s;) \/\/ shift down\n+                                    a[j & m] = getAndClearSlot(a, ++j & m);\n+                                top = s;\n+                            }\n+                            releaseAccess();\n+                            return task.doExec();\n+                        }\n+                    }\n+                    else if (t == null || --d == 0)\n+                        break;\n+                }\n+            }\n+            return 0;\n+        }\n+\n@@ -1197,2 +1362,1 @@\n-         * @param task root of CountedCompleter computation\n-         * @param owned true if owned by a ForkJoinWorkerThread\n+         * @param task root of computation\n@@ -1203,23 +1367,10 @@\n-            int status = 0, cap, k, p, s; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n-            while (task != null && (status = task.status) >= 0 &&\n-                   (a = array) != null && (cap = a.length) > 0 &&\n-                   (t = a[k = (cap - 1) & (s = (p = top) - 1)])\n-                   instanceof CountedCompleter) {\n-                CountedCompleter<?> f = (CountedCompleter<?>)t;\n-                boolean taken = false;\n-                for (;;) {     \/\/ exec if root task is a completer of t\n-                    if (f == task) {\n-                        if (owned) {\n-                            if ((taken = casSlotToNull(a, k, t)))\n-                                top = s;\n-                        }\n-                        else if (tryLock()) {\n-                            if (top == p && array == a &&\n-                                (taken = casSlotToNull(a, k, t)))\n-                                top = s;\n-                            source = 0;\n-                        }\n-                        if (taken)\n-                            t.doExec();\n-                        else if (!owned)\n-                            Thread.yield(); \/\/ tryLock failure\n+            int status = 0;\n+            if (task != null) {\n+                outer: for (;;) {\n+                    ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n+                    int p, s, cap, k;\n+                    if ((status = task.status) < 0)\n+                        return status;\n+                    if ((a = array) == null || (cap = a.length) <= 0 ||\n+                        (t = a[k = (cap - 1) & (s = (p = top) - 1)]) == null ||\n+                        !(t instanceof CountedCompleter))\n@@ -1227,0 +1378,11 @@\n+                    for (CountedCompleter<?> f = (CountedCompleter<?>)t;;) {\n+                        if (f == task)\n+                            break;\n+                        else if ((f = f.completer) == null)\n+                            break outer;       \/\/ ineligible\n+                    }\n+                    if (!owned && getAndSetAccess(1) != 0)\n+                        break;                 \/\/ fail if locked\n+                    if (top != p || a[k] != t || getAndClearSlot(a, k) == null) {\n+                        access = 0;\n+                        break;                 \/\/ missed\n@@ -1228,1 +1390,4 @@\n-                    else if ((f = f.completer) == null)\n+                    top = s;\n+                    releaseAccess();\n+                    t.doExec();\n+                    if (limit != 0 && --limit == 0)\n@@ -1231,2 +1396,1 @@\n-                if (taken && limit != 0 && --limit == 0)\n-                    break;\n+                status = task.status;\n@@ -1239,1 +1403,1 @@\n-         * none found or blocker is released.\n+         * none found or blocker is released\n@@ -1244,10 +1408,26 @@\n-            int cap, b, d, k; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n-            while (blocker != null && (d = top - (b = base)) > 0 &&\n-                   (a = array) != null && (cap = a.length) > 0 &&\n-                   (((t = getSlot(a, k = (cap - 1) & b)) == null && d > 1) ||\n-                    t instanceof\n-                    CompletableFuture.AsynchronousCompletionTask) &&\n-                   !blocker.isReleasable()) {\n-                if (t != null && base == b++ && casSlotToNull(a, k, t)) {\n-                    setBaseOpaque(b);\n-                    t.doExec();\n+            if (blocker != null) {\n+                for (;;) {\n+                    int b = base, cap; ForkJoinTask<?>[] a;\n+                    if ((a = array) == null || (cap = a.length) <= 0 || b == top)\n+                        break;\n+                    int k = (cap - 1) & b, nb = b + 1, nk = (cap - 1) & nb;\n+                    ForkJoinTask<?> t = a[k];\n+                    U.loadFence();                     \/\/ for re-reads\n+                    if (base != b)\n+                        ;\n+                    else if (blocker.isReleasable())\n+                        break;\n+                    else if (a[k] != t)\n+                        ;\n+                    else if (t != null) {\n+                        if (!(t instanceof CompletableFuture\n+                              .AsynchronousCompletionTask))\n+                            break;\n+                        else if (casSlotToNull(a, k, t)) {\n+                            base = nb;\n+                            U.storeStoreFence();\n+                            t.doExec();\n+                        }\n+                    }\n+                    else if (a[nk] == null)\n+                        break;\n@@ -1260,18 +1440,0 @@\n-        \/** AccessControlContext for innocuous workers, created on 1st use. *\/\n-        @SuppressWarnings(\"removal\")\n-        private static AccessControlContext INNOCUOUS_ACC;\n-\n-        \/**\n-         * Initializes (upon registration) InnocuousForkJoinWorkerThreads.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        final void initializeInnocuousWorker() {\n-            AccessControlContext acc; \/\/ racy construction OK\n-            if ((acc = INNOCUOUS_ACC) == null)\n-                INNOCUOUS_ACC = acc = new AccessControlContext(\n-                    new ProtectionDomain[] { new ProtectionDomain(null, null) });\n-            Thread t = Thread.currentThread();\n-            ThreadLocalRandom.setInheritedAccessControlContext(t, acc);\n-            ThreadLocalRandom.eraseThreadLocals(t);\n-        }\n-\n@@ -1283,1 +1445,1 @@\n-            return ((wt = owner) != null &&\n+            return (access != STOP && (wt = owner) != null &&\n@@ -1289,0 +1451,7 @@\n+        \/**\n+         * Called in constructors if ThreadLocals not preserved\n+         *\/\n+        final void setClearThreadLocals() {\n+            config |= CLEAR_TLS;\n+        }\n+\n@@ -1290,8 +1459,10 @@\n-            try {\n-                QA = MethodHandles.arrayElementVarHandle(ForkJoinTask[].class);\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                SOURCE = l.findVarHandle(WorkQueue.class, \"source\", int.class);\n-                BASE = l.findVarHandle(WorkQueue.class, \"base\", int.class);\n-            } catch (ReflectiveOperationException e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n+            U = Unsafe.getUnsafe();\n+            Class<WorkQueue> klass = WorkQueue.class;\n+            ACCESS = U.objectFieldOffset(klass, \"access\");\n+            PHASE = U.objectFieldOffset(klass, \"phase\");\n+            Class<ForkJoinTask[]> aklass = ForkJoinTask[].class;\n+            ABASE = U.arrayBaseOffset(aklass);\n+            int scale = U.arrayIndexScale(aklass);\n+            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);\n+            if ((scale & (scale - 1)) != 0)\n+                throw new Error(\"array index scale not a power of two\");\n@@ -1310,6 +1481,0 @@\n-    \/**\n-     * Permission required for callers of methods that may start or\n-     * kill threads.\n-     *\/\n-    static final RuntimePermission modifyThreadPermission;\n-\n@@ -1324,13 +1489,0 @@\n-    \/**\n-     * Common pool parallelism. To allow simpler use and management\n-     * when common pool threads are disabled, we allow the underlying\n-     * common.parallelism field to be zero, but in that case still report\n-     * parallelism as 1 to reflect resulting caller-runs mechanics.\n-     *\/\n-    static final int COMMON_PARALLELISM;\n-\n-    \/**\n-     * Limit on spare thread construction in tryCompensate.\n-     *\/\n-    private static final int COMMON_MAX_SPARES;\n-\n@@ -1342,2 +1494,0 @@\n-    \/\/ static configuration constants\n-\n@@ -1345,45 +1495,2 @@\n-     * Default idle timeout value (in milliseconds) for the thread\n-     * triggering quiescence to park waiting for new work\n-     *\/\n-    private static final long DEFAULT_KEEPALIVE = 60_000L;\n-\n-    \/**\n-     * Undershoot tolerance for idle timeouts\n-     *\/\n-    private static final long TIMEOUT_SLOP = 20L;\n-\n-    \/**\n-     * The default value for COMMON_MAX_SPARES.  Overridable using the\n-     * \"java.util.concurrent.ForkJoinPool.common.maximumSpares\" system\n-     * property.  The default value is far in excess of normal\n-     * requirements, but also far short of MAX_CAP and typical OS\n-     * thread limits, so allows JVMs to catch misuse\/abuse before\n-     * running out of resources needed to do so.\n-     *\/\n-    private static final int DEFAULT_COMMON_MAX_SPARES = 256;\n-\n-    \/*\n-     * Bits and masks for field ctl, packed with 4 16 bit subfields:\n-     * RC: Number of released (unqueued) workers minus target parallelism\n-     * TC: Number of total workers minus target parallelism\n-     * SS: version count and status of top waiting thread\n-     * ID: poolIndex of top of Treiber stack of waiters\n-     *\n-     * When convenient, we can extract the lower 32 stack top bits\n-     * (including version bits) as sp=(int)ctl.  The offsets of counts\n-     * by the target parallelism and the positionings of fields makes\n-     * it possible to perform the most common checks via sign tests of\n-     * fields: When ac is negative, there are not enough unqueued\n-     * workers, when tc is negative, there are not enough total\n-     * workers.  When sp is non-zero, there are waiting workers.  To\n-     * deal with possibly negative fields, we use casts in and out of\n-     * \"short\" and\/or signed shifts to maintain signedness.\n-     *\n-     * Because it occupies uppermost bits, we can add one release\n-     * count using getAndAdd of RC_UNIT, rather than CAS, when\n-     * returning from a blocked join.  Other updates entail multiple\n-     * subfields and masking, requiring CAS.\n-     *\n-     * The limits packed in field \"bounds\" are also offset by the\n-     * parallelism level to make them comparable to the ctl rc and tc\n-     * fields.\n+     * Permission required for callers of methods that may start or\n+     * kill threads. Lazily constructed.\n@@ -1391,0 +1498,1 @@\n+    static volatile RuntimePermission modifyThreadPermission;\n@@ -1392,14 +1500,0 @@\n-    \/\/ Lower and upper word masks\n-    private static final long SP_MASK    = 0xffffffffL;\n-    private static final long UC_MASK    = ~SP_MASK;\n-\n-    \/\/ Release counts\n-    private static final int  RC_SHIFT   = 48;\n-    private static final long RC_UNIT    = 0x0001L << RC_SHIFT;\n-    private static final long RC_MASK    = 0xffffL << RC_SHIFT;\n-\n-    \/\/ Total counts\n-    private static final int  TC_SHIFT   = 32;\n-    private static final long TC_UNIT    = 0x0001L << TC_SHIFT;\n-    private static final long TC_MASK    = 0xffffL << TC_SHIFT;\n-    private static final long ADD_WORKER = 0x0001L << (TC_SHIFT + 15); \/\/ sign\n@@ -1408,2 +1502,0 @@\n-\n-    final long keepAlive;                \/\/ milliseconds before dropping if idle\n@@ -1411,4 +1503,5 @@\n-    int scanRover;                       \/\/ advances across pollScan calls\n-    volatile int threadIds;              \/\/ for worker thread names\n-    final int bounds;                    \/\/ min, max threads packed as shorts\n-    volatile int mode;                   \/\/ parallelism, runstate, queue mode\n+    volatile long threadIds;             \/\/ for worker thread names\n+    final long keepAlive;                \/\/ milliseconds before dropping if idle\n+    final long bounds;                   \/\/ min, max threads packed as shorts\n+    final int config;                    \/\/ static configuration bits\n+    volatile int runState;               \/\/ SHUTDOWN, STOP, TERMINATED bits\n@@ -1422,0 +1515,1 @@\n+    \/\/    final SharedThreadContainer container; \/\/ for loom\n@@ -1425,0 +1519,2 @@\n+    @jdk.internal.vm.annotation.Contended(\"fjpctl\") \/\/ colocate\n+    int parallelism;                     \/\/ target number of workers\n@@ -1427,4 +1523,7 @@\n-    private static final VarHandle CTL;\n-    private static final VarHandle MODE;\n-    private static final VarHandle THREADIDS;\n-    private static final VarHandle POOLIDS;\n+    private static final Unsafe U;\n+    private static final long CTL;\n+    private static final long RUNSTATE;\n+    private static final long PARALLELISM;\n+    private static final long THREADIDS;\n+    private static final long POOLIDS;\n+\n@@ -1432,1 +1531,1 @@\n-        return CTL.compareAndSet(this, c, v);\n+        return U.compareAndSetLong(this, CTL, c, v);\n@@ -1435,1 +1534,1 @@\n-        return (long)CTL.compareAndExchange(this, c, v);\n+        return U.compareAndExchangeLong(this, CTL, c, v);\n@@ -1438,1 +1537,1 @@\n-        return (long)CTL.getAndAdd(this, v);\n+        return U.getAndAddLong(this, CTL, v);\n@@ -1440,2 +1539,2 @@\n-    private int getAndBitwiseOrMode(int v) {\n-        return (int)MODE.getAndBitwiseOr(this, v);\n+    private int getAndBitwiseOrRunState(int v) {\n+        return U.getAndBitwiseOrInt(this, RUNSTATE, v);\n@@ -1443,2 +1542,2 @@\n-    private int getAndAddThreadIds(int x) {\n-        return (int)THREADIDS.getAndAdd(this, x);\n+    private long incrementThreadIds() {\n+        return U.getAndAddLong(this, THREADIDS, 1L);\n@@ -1447,1 +1546,7 @@\n-        return (int)POOLIDS.getAndAdd(x);\n+        return U.getAndAddInt(ForkJoinPool.class, POOLIDS, x);\n+    }\n+    private int getAndSetParallelism(int v) {\n+        return U.getAndSetInt(this, PARALLELISM, v);\n+    }\n+    private int getParallelismOpaque() {\n+        return U.getIntOpaque(this, PARALLELISM);\n@@ -1450,1 +1555,1 @@\n-    \/\/ Creating, registering and deregistering workers\n+    \/\/ Creating, registering, and deregistering workers\n@@ -1464,2 +1569,4 @@\n-            if (fac != null && (wt = fac.newThread(this)) != null) {\n-                wt.start();\n+            if (runState >= 0 &&  \/\/ avoid construction if terminating\n+                fac != null && (wt = fac.newThread(this)) != null) {\n+                wt.start();       \/\/ replace with following line for loom\n+                \/\/                container.start(wt);\n@@ -1480,1 +1587,1 @@\n-        int tid = getAndAddThreadIds(1) + 1;\n+        long tid = incrementThreadIds() + 1L;\n@@ -1483,1 +1590,1 @@\n-        return prefix.concat(Integer.toString(tid));\n+        return prefix.concat(Long.toString(tid));\n@@ -1492,1 +1599,0 @@\n-        ReentrantLock lock = registrationLock;\n@@ -1495,0 +1601,2 @@\n+        ReentrantLock lock = registrationLock;\n+        int cfg = config & FIFO;\n@@ -1496,1 +1604,0 @@\n-            int modebits = (mode & FIFO) | w.config;\n@@ -1498,3 +1605,2 @@\n-            w.stackPred = seed;                         \/\/ stash for runWorker\n-            if ((modebits & INNOCUOUS) != 0)\n-                w.initializeInnocuousWorker();\n+            cfg |= w.config | SRC;\n+            w.stackPred = seed;\n@@ -1510,1 +1616,1 @@\n-                    w.phase = w.config = id | modebits; \/\/ now publishable\n+                    w.phase = w.config = id | cfg;      \/\/ now publishable\n@@ -1525,1 +1631,1 @@\n-                        VarHandle.releaseFence();       \/\/ fill before publish\n+                        U.storeFence();                 \/\/ fill before publish\n@@ -1544,14 +1650,106 @@\n-    final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n-        ReentrantLock lock = registrationLock;\n-        WorkQueue w = null;\n-        int cfg = 0;\n-        if (wt != null && (w = wt.workQueue) != null && lock != null) {\n-            WorkQueue[] qs; int n, i;\n-            cfg = w.config;\n-            long ns = w.nsteals & 0xffffffffL;\n-            lock.lock();                             \/\/ remove index from array\n-            if ((qs = queues) != null && (n = qs.length) > 0 &&\n-                qs[i = cfg & (n - 1)] == w)\n-                qs[i] = null;\n-            stealCount += ns;                        \/\/ accumulate steals\n-            lock.unlock();\n+    final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n+        WorkQueue w = (wt == null) ? null : wt.workQueue;\n+        int cfg = (w == null) ? 0 : w.config;\n+        long c = ctl;\n+        if ((cfg & TRIMMED) == 0)             \/\/ decrement counts\n+            do {} while (c != (c = compareAndExchangeCtl(\n+                                   c, ((RC_MASK & (c - RC_UNIT)) |\n+                                       (TC_MASK & (c - TC_UNIT)) |\n+                                       (SP_MASK & c)))));\n+        else if ((int)c == 0)                 \/\/ was dropped on timeout\n+            cfg &= ~SRC;                      \/\/ suppress signal if last\n+        if (!tryTerminate(false, false) && w != null) {\n+            ReentrantLock lock; WorkQueue[] qs; int n, i;\n+            long ns = w.nsteals & 0xffffffffL;\n+            if ((lock = registrationLock) != null) {\n+                lock.lock();                  \/\/ remove index unless terminating\n+                if ((qs = queues) != null && (n = qs.length) > 0 &&\n+                    qs[i = cfg & (n - 1)] == w)\n+                    qs[i] = null;\n+                stealCount += ns;             \/\/ accumulate steals\n+                lock.unlock();\n+            }\n+            if ((cfg & SRC) != 0)\n+                signalWork();                 \/\/ possibly replace worker\n+        }\n+        if (ex != null) {\n+            if (w != null) {\n+                w.access = STOP;              \/\/ cancel tasks\n+                for (ForkJoinTask<?> t; (t = w.nextLocalTask(0)) != null; )\n+                    ForkJoinTask.cancelIgnoringExceptions(t);\n+            }\n+            ForkJoinTask.rethrow(ex);\n+        }\n+    }\n+\n+    \/*\n+     * Releases an idle worker, or creates one if not enough exist.\n+     *\/\n+    final void signalWork() {\n+        int pc = parallelism, n;\n+        long c = ctl;\n+        WorkQueue[] qs = queues;\n+        if ((short)(c >>> RC_SHIFT) < pc && qs != null && (n = qs.length) > 0) {\n+            for (;;) {\n+                boolean create = false;\n+                int sp = (int)c & ~INACTIVE;\n+                WorkQueue v = qs[sp & (n - 1)];\n+                int deficit = pc - (short)(c >>> TC_SHIFT);\n+                long ac = (c + RC_UNIT) & RC_MASK, nc;\n+                if (sp != 0 && v != null)\n+                    nc = (v.stackPred & SP_MASK) | (c & TC_MASK);\n+                else if (deficit <= 0)\n+                    break;\n+                else {\n+                    create = true;\n+                    nc = ((c + TC_UNIT) & TC_MASK);\n+                }\n+                if (c == (c = compareAndExchangeCtl(c, nc | ac))) {\n+                    if (create)\n+                        createWorker();\n+                    else {\n+                        Thread owner = v.owner;\n+                        v.phase = sp;\n+                        if (v.access == PARKED)\n+                            LockSupport.unpark(owner);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Reactivates any idle worker, if one exists.\n+     *\n+     * @return the signalled worker, or null if none\n+     *\/\n+    private WorkQueue reactivate() {\n+        WorkQueue[] qs; int n;\n+        long c = ctl;\n+        if ((qs = queues) != null && (n = qs.length) > 0) {\n+            for (;;) {\n+                int sp = (int)c & ~INACTIVE;\n+                WorkQueue v = qs[sp & (n - 1)];\n+                long ac = UC_MASK & (c + RC_UNIT);\n+                if (sp == 0 || v == null)\n+                    break;\n+                if (c == (c = compareAndExchangeCtl(\n+                              c, (v.stackPred & SP_MASK) | ac))) {\n+                    Thread owner = v.owner;\n+                    v.phase = sp;\n+                    if (v.access == PARKED)\n+                        LockSupport.unpark(owner);\n+                    return v;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Tries to deactivate worker w; called only on idle timeout.\n+     *\/\n+    private boolean tryTrim(WorkQueue w) {\n+        if (w != null) {\n+            int pred = w.stackPred, cfg = w.config | TRIMMED;\n@@ -1559,15 +1757,10 @@\n-            if ((cfg & QUIET) == 0) \/\/ unless self-signalled, decrement counts\n-                do {} while (c != (c = compareAndExchangeCtl(\n-                                       c, ((RC_MASK & (c - RC_UNIT)) |\n-                                           (TC_MASK & (c - TC_UNIT)) |\n-                                           (SP_MASK & c)))));\n-            else if ((int)c == 0)                    \/\/ was dropped on timeout\n-                cfg = 0;                             \/\/ suppress signal if last\n-            for (ForkJoinTask<?> t; (t = w.pop()) != null; )\n-                ForkJoinTask.cancelIgnoringExceptions(t); \/\/ cancel tasks\n-        }\n-\n-        if (!tryTerminate(false, false) && w != null && (cfg & SRC) != 0)\n-            signalWork();                            \/\/ possibly replace worker\n-        if (ex != null)\n-            ForkJoinTask.rethrow(ex);\n+            int sp = (int)c & ~INACTIVE;\n+            if ((sp & SMASK) == (cfg & SMASK) &&\n+                compareAndSetCtl(c, ((pred & SP_MASK) |\n+                                     (UC_MASK & (c - TC_UNIT))))) {\n+                w.config = cfg;  \/\/ add sentinel for deregisterWorker\n+                w.phase = sp;\n+                return true;\n+            }\n+        }\n+        return false;\n@@ -1576,2 +1769,5 @@\n-    \/*\n-     * Tries to create or release a worker if too few are running.\n+    \/**\n+     * Returns true if any queue is detectably nonempty.  Accurate\n+     * only when workers are quiescent; else conservatively\n+     * approximate.\n+     * @param submissionsOnly if true, only check submission queues\n@@ -1579,26 +1775,12 @@\n-    final void signalWork() {\n-        for (long c = ctl; c < 0L;) {\n-            int sp, i; WorkQueue[] qs; WorkQueue v;\n-            if ((sp = (int)c & ~UNSIGNALLED) == 0) {  \/\/ no idle workers\n-                if ((c & ADD_WORKER) == 0L)           \/\/ enough total workers\n-                    break;\n-                if (c == (c = compareAndExchangeCtl(\n-                              c, ((RC_MASK & (c + RC_UNIT)) |\n-                                  (TC_MASK & (c + TC_UNIT)))))) {\n-                    createWorker();\n-                    break;\n-                }\n-            }\n-            else if ((qs = queues) == null)\n-                break;                                \/\/ unstarted\/terminated\n-            else if (qs.length <= (i = sp & SMASK))\n-                break;                                \/\/ terminated\n-            else if ((v = qs[i]) == null)\n-                break;                                \/\/ terminating\n-            else {\n-                long nc = (v.stackPred & SP_MASK) | (UC_MASK & (c + RC_UNIT));\n-                Thread vt = v.owner;\n-                if (c == (c = compareAndExchangeCtl(c, nc))) {\n-                    v.phase = sp;\n-                    LockSupport.unpark(vt);           \/\/ release idle worker\n-                    break;\n+    private boolean hasTasks(boolean submissionsOnly) {\n+        int step = submissionsOnly ? 2 : 1;\n+        for (int checkSum = 0;;) { \/\/ repeat until stable (normally twice)\n+            U.loadFence();\n+            WorkQueue[] qs = queues;\n+            int n = (qs == null) ? 0 : qs.length, sum = 0;\n+            for (int i = 0; i < n; i += step) {\n+                WorkQueue q; int s;\n+                if ((q = qs[i]) != null) {\n+                    if (q.access > 0 || (s = q.top) != q.base)\n+                        return true;\n+                    sum += (s << 16) + i + 1;\n@@ -1607,0 +1789,2 @@\n+            if (checkSum == (checkSum = sum))\n+                return false;\n@@ -1617,2 +1801,1 @@\n-        if (mode >= 0 && w != null) {           \/\/ skip on failed init\n-            w.config |= SRC;                    \/\/ mark as valid source\n+        if (w != null) {                        \/\/ skip on failed init\n@@ -1624,0 +1807,1 @@\n+            w.access = STOP;                    \/\/ record normal termination\n@@ -1630,2 +1814,1 @@\n-     * returning source id or retry indicator if contended or\n-     * inconsistent.\n+     * returning source id or retry indicator.\n@@ -1642,2 +1825,2 @@\n-            int j, cap, b; WorkQueue q; ForkJoinTask<?>[] a;\n-            if ((q = qs[j = r & (n - 1)]) != null && \/\/ poll at qs[j].array[k]\n+            int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+            if ((q = qs[j = r & (n - 1)]) != null &&\n@@ -1645,3 +1828,4 @@\n-                int k = (cap - 1) & (b = q.base), nextBase = b + 1;\n-                int nextIndex = (cap - 1) & nextBase, src = j | SRC;\n-                ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n+                int src = j | SRC, b = q.base;\n+                int k = (cap - 1) & b, nb = b + 1, nk = (cap - 1) & nb;\n+                ForkJoinTask<?> t = a[k];\n+                U.loadFence();                  \/\/ for re-reads\n@@ -1651,3 +1835,3 @@\n-                    q.base = nextBase;\n-                    ForkJoinTask<?> next = a[nextIndex];\n-                    if ((w.source = src) != prevSrc && next != null)\n+                    q.base = nb;\n+                    w.source = src;\n+                    if (prevSrc == 0 && q.base == nb && a[nk] != null)\n@@ -1658,2 +1842,2 @@\n-                else if (a[nextIndex] != null)  \/\/ revisit\n-                    return prevSrc;\n+                else if (q.array != a || a[k] != null || a[nk] != null)\n+                    return prevSrc;             \/\/ revisit\n@@ -1662,1 +1846,1 @@\n-        return (queues != qs) ? prevSrc: -1;    \/\/ possibly resized\n+        return -1;\n@@ -1666,2 +1850,1 @@\n-     * Advances worker phase, pushes onto ctl stack, and awaits signal\n-     * or reports termination.\n+     * Advances phase, enqueues, and awaits signal or termination.\n@@ -1673,26 +1856,34 @@\n-            return -1;                       \/\/ already terminated\n-        int phase = (w.phase + SS_SEQ) & ~UNSIGNALLED;\n-        w.phase = phase | UNSIGNALLED;       \/\/ advance phase\n-        long prevCtl = ctl, c;               \/\/ enqueue\n-        do {\n-            w.stackPred = (int)prevCtl;\n-            c = ((prevCtl - RC_UNIT) & UC_MASK) | (phase & SP_MASK);\n-        } while (prevCtl != (prevCtl = compareAndExchangeCtl(prevCtl, c)));\n-\n-        Thread.interrupted();                \/\/ clear status\n-        LockSupport.setCurrentBlocker(this); \/\/ prepare to block (exit also OK)\n-        long deadline = 0L;                  \/\/ nonzero if possibly quiescent\n-        int ac = (int)(c >> RC_SHIFT), md;\n-        if ((md = mode) < 0)                 \/\/ pool is terminating\n-            return -1;\n-        else if ((md & SMASK) + ac <= 0) {\n-            boolean checkTermination = (md & SHUTDOWN) != 0;\n-            if ((deadline = System.currentTimeMillis() + keepAlive) == 0L)\n-                deadline = 1L;               \/\/ avoid zero\n-            WorkQueue[] qs = queues;         \/\/ check for racing submission\n-            int n = (qs == null) ? 0 : qs.length;\n-            for (int i = 0; i < n; i += 2) {\n-                WorkQueue q; ForkJoinTask<?>[] a; int cap, b;\n-                if (ctl != c) {              \/\/ already signalled\n-                    checkTermination = false;\n-                    break;\n+            return -1;                           \/\/ currently impossible\n+        int p = (w.phase + SS_SEQ) & ~INACTIVE;  \/\/ advance phase\n+        boolean idle = false;                    \/\/ true if possibly quiescent\n+        if (runState < 0)\n+            return -1;                           \/\/ terminating\n+        long sp = p & SP_MASK, pc = ctl, qc;\n+        w.phase = p | INACTIVE;\n+        do {                                     \/\/ enqueue\n+            w.stackPred = (int)pc;               \/\/ set ctl stack link\n+        } while (pc != (pc = compareAndExchangeCtl(\n+                            pc, qc = ((pc - RC_UNIT) & UC_MASK) | sp)));\n+        if ((qc & RC_MASK) <= 0L) {\n+            if (hasTasks(true) && (w.phase >= 0 || reactivate() == w))\n+                return 0;                        \/\/ check for stragglers\n+            if (runState != 0 && tryTerminate(false, false))\n+                return -1;                       \/\/ quiescent termination\n+            idle = true;\n+        }\n+        WorkQueue[] qs = queues; \/\/ spin for expected #accesses in scan+signal\n+        int spins = ((qs == null) ? 0 : ((qs.length & SMASK) << 1)) | 0xf;\n+        while ((p = w.phase) < 0 && --spins > 0)\n+            Thread.onSpinWait();\n+        if (p < 0) {\n+            long deadline = idle ? keepAlive + System.currentTimeMillis() : 0L;\n+            LockSupport.setCurrentBlocker(this);\n+            for (;;) {                           \/\/ await signal or termination\n+                if (runState < 0)\n+                    return -1;\n+                w.access = PARKED;               \/\/ enable unpark\n+                if (w.phase < 0) {\n+                    if (idle)\n+                        LockSupport.parkUntil(deadline);\n+                    else\n+                        LockSupport.park();\n@@ -1700,7 +1891,3 @@\n-                else if ((q = qs[i]) != null &&\n-                         (a = q.array) != null && (cap = a.length) > 0 &&\n-                         ((b = q.base) != q.top || a[(cap - 1) & b] != null ||\n-                          q.source != 0)) {\n-                    if (compareAndSetCtl(c, prevCtl))\n-                        w.phase = phase;     \/\/ self-signal\n-                    checkTermination = false;\n+                w.access = 0;                    \/\/ disable unpark\n+                if (w.phase >= 0) {\n+                    LockSupport.setCurrentBlocker(null);\n@@ -1709,0 +1896,9 @@\n+                Thread.interrupted();            \/\/ clear status for next park\n+                if (idle) {                      \/\/ check for idle timeout\n+                    if (deadline - System.currentTimeMillis() < TIMEOUT_SLOP) {\n+                        if (tryTrim(w))\n+                            return -1;\n+                        else                     \/\/ not at head; restart timer\n+                            deadline += keepAlive;\n+                    }\n+                }\n@@ -1710,25 +1906,0 @@\n-            if (checkTermination && tryTerminate(false, false))\n-                return -1;                   \/\/ trigger quiescent termination\n-        }\n-\n-        for (boolean alt = false;;) {        \/\/ await activation or termination\n-            if (w.phase >= 0)\n-                break;\n-            else if (mode < 0)\n-                return -1;\n-            else if ((c = ctl) == prevCtl)\n-                Thread.onSpinWait();         \/\/ signal in progress\n-            else if (!(alt = !alt))          \/\/ check between park calls\n-                Thread.interrupted();\n-            else if (deadline == 0L)\n-                LockSupport.park();\n-            else if (deadline - System.currentTimeMillis() > TIMEOUT_SLOP)\n-                LockSupport.parkUntil(deadline);\n-            else if (((int)c & SMASK) == (w.config & SMASK) &&\n-                     compareAndSetCtl(c, ((UC_MASK & (c - TC_UNIT)) |\n-                                          (prevCtl & SP_MASK)))) {\n-                w.config |= QUIET;           \/\/ sentinel for deregisterWorker\n-                return -1;                   \/\/ drop on timeout\n-            }\n-            else if ((deadline += keepAlive) == 0L)\n-                deadline = 1L;               \/\/ not at head; restart timer\n@@ -1739,2 +1910,0 @@\n-    \/\/ Utilities used by ForkJoinTask\n-\n@@ -1742,1 +1911,2 @@\n-     * Returns true if can start terminating if enabled, or already terminated\n+     * Non-overridable version of isQuiescent. Returns true if\n+     * quiescent or already terminating.\n@@ -1744,6 +1914,4 @@\n-    final boolean canStop() {\n-        outer: for (long oldSum = 0L;;) { \/\/ repeat until stable\n-            int md; WorkQueue[] qs;  long c;\n-            if ((qs = queues) == null || ((md = mode) & STOP) != 0)\n-                return true;\n-            if ((md & SMASK) + (int)((c = ctl) >> RC_SHIFT) > 0)\n+    private boolean canStop() {\n+        long c = ctl;\n+        do {\n+            if (runState < 0)\n@@ -1751,9 +1919,24 @@\n-            long checkSum = c;\n-            for (int i = 1; i < qs.length; i += 2) { \/\/ scan submitters\n-                WorkQueue q; ForkJoinTask<?>[] a; int s = 0, cap;\n-                if ((q = qs[i]) != null && (a = q.array) != null &&\n-                    (cap = a.length) > 0 &&\n-                    ((s = q.top) != q.base || a[(cap - 1) & s] != null ||\n-                     q.source != 0))\n-                    break outer;\n-                checkSum += (((long)i) << 32) ^ s;\n+            if ((c & RC_MASK) > 0L || hasTasks(false))\n+                return false;\n+        } while (c != (c = ctl));  \/\/ validate\n+        return true;\n+    }\n+\n+    \/**\n+     * Scans for and returns a polled task, if available.  Used only\n+     * for untracked polls. Begins scan at a random index to avoid\n+     * systematic unfairness.\n+     *\n+     * @param submissionsOnly if true, only scan submission queues\n+     *\/\n+    private ForkJoinTask<?> pollScan(boolean submissionsOnly) {\n+        int r = ThreadLocalRandom.nextSecondarySeed();\n+        if (submissionsOnly)                    \/\/ even indices only\n+            r &= ~1;\n+        int step = (submissionsOnly) ? 2 : 1;\n+        WorkQueue[] qs; int n; WorkQueue q; ForkJoinTask<?> t;\n+        if (runState >= 0 && (qs = queues) != null && (n = qs.length) > 0) {\n+            for (int i = n; i > 0; i -= step, r += step) {\n+                if ((q = qs[r & (n - 1)]) != null &&\n+                    (t = q.poll(this)) != null)\n+                    return t;\n@@ -1761,2 +1944,0 @@\n-            if (oldSum == (oldSum = checkSum) && queues == qs)\n-                return true;\n@@ -1764,1 +1945,1 @@\n-        return (mode & STOP) != 0; \/\/ recheck mode on false return\n+        return null;\n@@ -1776,0 +1957,1 @@\n+     * @param canSaturate to override saturate predicate\n@@ -1778,1 +1960,1 @@\n-    private int tryCompensate(long c) {\n+    private int tryCompensate(long c, boolean canSaturate) {\n@@ -1780,2 +1962,2 @@\n-        int md = mode, b = bounds;\n-        \/\/ counts are signed; centered at parallelism level == 0\n+        long b = bounds;                               \/\/ unpack fields\n+        int pc = parallelism;\n@@ -1783,2 +1965,2 @@\n-            maxTotal  = b >>> SWIDTH,\n-            active    = (int)(c >> RC_SHIFT),\n+            maxTotal  = (short)(b >>> SWIDTH) + pc,\n+            active    = (short)(c >>> RC_SHIFT),\n@@ -1786,15 +1968,10 @@\n-            sp        = (int)c & ~UNSIGNALLED;\n-        if ((md & SMASK) == 0)\n-            return 0;                  \/\/ cannot compensate if parallelism zero\n-        else if (total >= 0) {\n-            if (sp != 0) {                        \/\/ activate idle worker\n-                WorkQueue[] qs; int n; WorkQueue v;\n-                if ((qs = queues) != null && (n = qs.length) > 0 &&\n-                    (v = qs[sp & (n - 1)]) != null) {\n-                    Thread vt = v.owner;\n-                    long nc = ((long)v.stackPred & SP_MASK) | (UC_MASK & c);\n-                    if (compareAndSetCtl(c, nc)) {\n-                        v.phase = sp;\n-                        LockSupport.unpark(vt);\n-                        return UNCOMPENSATE;\n-                    }\n+            sp        = (int)c & ~INACTIVE;\n+        if (sp != 0 && active <= pc) {                 \/\/ activate idle worker\n+            WorkQueue[] qs; WorkQueue v; int i;\n+            if (ctl == c && (qs = queues) != null &&\n+                qs.length > (i = sp & SMASK) && (v = qs[i]) != null) {\n+                long nc = (v.stackPred & SP_MASK) | (UC_MASK & c);\n+                if (compareAndSetCtl(c, nc)) {\n+                    v.phase = sp;\n+                    LockSupport.unpark(v.owner);\n+                    return UNCOMPENSATE;\n@@ -1802,5 +1979,0 @@\n-                return -1;                        \/\/ retry\n-            }\n-            else if (active > minActive) {        \/\/ reduce parallelism\n-                long nc = ((RC_MASK & (c - RC_UNIT)) | (~RC_MASK & c));\n-                return compareAndSetCtl(c, nc) ? UNCOMPENSATE : -1;\n@@ -1808,0 +1980,5 @@\n+            return -1;                                  \/\/ retry\n+        }\n+        else if (active > minActive && total >= pc) {   \/\/ reduce active workers\n+            long nc = ((RC_MASK & (c - RC_UNIT)) | (~RC_MASK & c));\n+            return compareAndSetCtl(c, nc) ? UNCOMPENSATE : -1;\n@@ -1809,1 +1986,1 @@\n-        if (total < maxTotal) {                   \/\/ expand pool\n+        else if (total < maxTotal && total < MAX_CAP) { \/\/ expand pool\n@@ -1814,1 +1991,1 @@\n-        else if (!compareAndSetCtl(c, c))         \/\/ validate\n+        else if (!compareAndSetCtl(c, c))               \/\/ validate\n@@ -1816,1 +1993,1 @@\n-        else if ((sat = saturate) != null && sat.test(this))\n+        else if (canSaturate || ((sat = saturate) != null && sat.test(this)))\n@@ -1831,3 +2008,4 @@\n-     * Helps if possible until the given task is done.  Scans other\n-     * queues for a task produced by one of w's stealers; returning\n-     * compensated blocking sentinel if none are found.\n+     * Helps if possible until the given task is done.  Processes\n+     * compatible local tasks and scans other queues for task produced\n+     * by w's stealers; returning compensated blocking sentinel if\n+     * none are found.\n@@ -1837,1 +2015,1 @@\n-     * @param canHelp if false, compensate only\n+     * @param timed true if this is a timed join\n@@ -1840,53 +2018,14 @@\n-    final int helpJoin(ForkJoinTask<?> task, WorkQueue w, boolean canHelp) {\n-        int s = 0;\n-        if (task != null && w != null) {\n-            int wsrc = w.source, wid = w.config & SMASK, r = wid + 2;\n-            boolean scan = true;\n-            long c = 0L;                          \/\/ track ctl stability\n-            outer: for (;;) {\n-                if ((s = task.status) < 0)\n-                    break;\n-                else if (scan = !scan) {          \/\/ previous scan was empty\n-                    if (mode < 0)\n-                        ForkJoinTask.cancelIgnoringExceptions(task);\n-                    else if (c == (c = ctl) && (s = tryCompensate(c)) >= 0)\n-                        break;                    \/\/ block\n-                }\n-                else if (canHelp) {               \/\/ scan for subtasks\n-                    WorkQueue[] qs = queues;\n-                    int n = (qs == null) ? 0 : qs.length, m = n - 1;\n-                    for (int i = n; i > 0; i -= 2, r += 2) {\n-                        int j; WorkQueue q, x, y; ForkJoinTask<?>[] a;\n-                        if ((q = qs[j = r & m]) != null) {\n-                            int sq = q.source & SMASK, cap, b;\n-                            if ((a = q.array) != null && (cap = a.length) > 0) {\n-                                int k = (cap - 1) & (b = q.base);\n-                                int nextBase = b + 1, src = j | SRC, sx;\n-                                ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n-                                boolean eligible = sq == wid ||\n-                                    ((x = qs[sq & m]) != null &&   \/\/ indirect\n-                                     ((sx = (x.source & SMASK)) == wid ||\n-                                      ((y = qs[sx & m]) != null && \/\/ 2-indirect\n-                                       (y.source & SMASK) == wid)));\n-                                if ((s = task.status) < 0)\n-                                    break outer;\n-                                else if ((q.source & SMASK) != sq ||\n-                                         q.base != b)\n-                                    scan = true;          \/\/ inconsistent\n-                                else if (t == null)\n-                                    scan |= (a[nextBase & (cap - 1)] != null ||\n-                                             q.top != b); \/\/ lagging\n-                                else if (eligible) {\n-                                    if (WorkQueue.casSlotToNull(a, k, t)) {\n-                                        q.base = nextBase;\n-                                        w.source = src;\n-                                        t.doExec();\n-                                        w.source = wsrc;\n-                                    }\n-                                    scan = true;\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+    final int helpJoin(ForkJoinTask<?> task, WorkQueue w, boolean timed) {\n+        if (w == null || task == null)\n+            return 0;\n+        int wsrc = w.source, wid = (w.config & SMASK) | SRC, r = wid + 2;\n+        long sctl = 0L;                               \/\/ track stability\n+        for (boolean rescan = true;;) {\n+            int s; WorkQueue[] qs;\n+            if ((s = task.status) < 0)\n+                return s;\n+            if (!rescan && sctl == (sctl = ctl)) {\n+                if (runState < 0)\n+                    return 0;\n+                if ((s = tryCompensate(sctl, timed)) >= 0)\n+                    return s;                              \/\/ block\n@@ -1894,45 +2033,19 @@\n-        }\n-        return s;\n-    }\n-\n-    \/**\n-     * Extra helpJoin steps for CountedCompleters.  Scans for and runs\n-     * subtasks of the given root task, returning if none are found.\n-     *\n-     * @param task root of CountedCompleter computation\n-     * @param w caller's WorkQueue\n-     * @param owned true if owned by a ForkJoinWorkerThread\n-     * @return task status on exit\n-     *\/\n-    final int helpComplete(ForkJoinTask<?> task, WorkQueue w, boolean owned) {\n-        int s = 0;\n-        if (task != null && w != null) {\n-            int r = w.config;\n-            boolean scan = true, locals = true;\n-            long c = 0L;\n-            outer: for (;;) {\n-                if (locals) {                     \/\/ try locals before scanning\n-                    if ((s = w.helpComplete(task, owned, 0)) < 0)\n-                        break;\n-                    locals = false;\n-                }\n-                else if ((s = task.status) < 0)\n-                    break;\n-                else if (scan = !scan) {\n-                    if (c == (c = ctl))\n-                        break;\n-                }\n-                else {                            \/\/ scan for subtasks\n-                    WorkQueue[] qs = queues;\n-                    int n = (qs == null) ? 0 : qs.length;\n-                    for (int i = n; i > 0; --i, ++r) {\n-                        int j, cap, b; WorkQueue q; ForkJoinTask<?>[] a;\n-                        boolean eligible = false;\n-                        if ((q = qs[j = r & (n - 1)]) != null &&\n-                            (a = q.array) != null && (cap = a.length) > 0) {\n-                            int k = (cap - 1) & (b = q.base), nextBase = b + 1;\n-                            ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n-                            if (t instanceof CountedCompleter) {\n-                                CountedCompleter<?> f = (CountedCompleter<?>)t;\n-                                do {} while (!(eligible = (f == task)) &&\n-                                             (f = f.completer) != null);\n+            rescan = false;\n+            int n = ((qs = queues) == null) ? 0 : qs.length, m = n - 1;\n+            scan: for (int i = n >>> 1; i > 0; --i, r += 2) {\n+                int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                if ((q = qs[j = r & m]) != null && (a = q.array) != null &&\n+                    (cap = a.length) > 0) {\n+                    for (int src = j | SRC;;) {\n+                        int sq = q.source, b = q.base;\n+                        int k = (cap - 1) & b, nb = b + 1;\n+                        ForkJoinTask<?> t = a[k];\n+                        U.loadFence();                \/\/ for re-reads\n+                        boolean eligible = true;      \/\/ check steal chain\n+                        for (int d = n, v = sq;;) {   \/\/ may be cyclic; bound\n+                            WorkQueue p;\n+                            if (v == wid)\n+                                break;\n+                            if (v == 0 || --d == 0 || (p = qs[v & m]) == null) {\n+                                eligible = false;\n+                                break;\n@@ -1940,14 +2053,11 @@\n-                            if ((s = task.status) < 0)\n-                                break outer;\n-                            else if (q.base != b)\n-                                scan = true;       \/\/ inconsistent\n-                            else if (t == null)\n-                                scan |= (a[nextBase & (cap - 1)] != null ||\n-                                         q.top != b);\n-                            else if (eligible) {\n-                                if (WorkQueue.casSlotToNull(a, k, t)) {\n-                                    q.setBaseOpaque(nextBase);\n-                                    t.doExec();\n-                                    locals = true;\n-                                }\n-                                scan = true;\n+                            v = p.source;\n+                        }\n+                        if (q.source != sq || q.base != b)\n+                            ;                          \/\/ stale\n+                        else if ((s = task.status) < 0)\n+                            return s;                  \/\/ recheck before taking\n+                        else if (t == null) {\n+                            if (a[k] == null) {\n+                                if (!rescan && eligible &&\n+                                    (q.array != a || q.top != b))\n+                                    rescan = true;     \/\/ resized or stalled\n@@ -1957,0 +2067,10 @@\n+                        else if (t != task && !eligible)\n+                            break;\n+                        else if (WorkQueue.casSlotToNull(a, k, t)) {\n+                            q.base = nb;\n+                            w.source = src;\n+                            t.doExec();\n+                            w.source = wsrc;\n+                            rescan = true;\n+                            break scan;\n+                        }\n@@ -1961,1 +2081,0 @@\n-        return s;\n@@ -1965,3 +2084,1 @@\n-     * Scans for and returns a polled task, if available.  Used only\n-     * for untracked polls. Begins scan at an index (scanRover)\n-     * advanced on each call, to avoid systematic unfairness.\n+     * Version of helpJoin for CountedCompleters.\n@@ -1969,1 +2086,5 @@\n-     * @param submissionsOnly if true, only scan submission queues\n+     * @param task the task\n+     * @param w caller's WorkQueue\n+     * @param owned true if w is owned by a ForkJoinWorkerThread\n+     * @param timed true if this is a timed join\n+     * @return task status on exit, or UNCOMPENSATE for compensated blocking\n@@ -1971,24 +2092,57 @@\n-    private ForkJoinTask<?> pollScan(boolean submissionsOnly) {\n-        VarHandle.acquireFence();\n-        int r = scanRover += 0x61c88647; \/\/ Weyl increment; raciness OK\n-        if (submissionsOnly)             \/\/ even indices only\n-            r &= ~1;\n-        int step = (submissionsOnly) ? 2 : 1;\n-        WorkQueue[] qs; int n;\n-        while ((qs = queues) != null && (n = qs.length) > 0) {\n-            boolean scan = false;\n-            for (int i = 0; i < n; i += step) {\n-                int j, cap, b; WorkQueue q; ForkJoinTask<?>[] a;\n-                if ((q = qs[j = (n - 1) & (r + i)]) != null &&\n-                    (a = q.array) != null && (cap = a.length) > 0) {\n-                    int k = (cap - 1) & (b = q.base), nextBase = b + 1;\n-                    ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n-                    if (q.base != b)\n-                        scan = true;\n-                    else if (t == null)\n-                        scan |= (q.top != b || a[nextBase & (cap - 1)] != null);\n-                    else if (!WorkQueue.casSlotToNull(a, k, t))\n-                        scan = true;\n-                    else {\n-                        q.setBaseOpaque(nextBase);\n-                        return t;\n+    final int helpComplete(ForkJoinTask<?> task, WorkQueue w, boolean owned,\n+                           boolean timed) {\n+        if (w == null || task == null)\n+            return 0;\n+        int wsrc = w.source, r = w.config;\n+        long sctl = 0L;                               \/\/ track stability\n+        for (boolean rescan = true;;) {\n+            int s; WorkQueue[] qs;\n+            if ((s = w.helpComplete(task, owned, 0)) < 0)\n+                return s;\n+            if (!rescan && sctl == (sctl = ctl)) {\n+                if (!owned || runState < 0)\n+                    return 0;\n+                if ((s = tryCompensate(sctl, timed)) >= 0)\n+                    return s;\n+            }\n+            rescan = false;\n+            int n = ((qs = queues) == null) ? 0 : qs.length, m = n - 1;\n+            scan: for (int i = n; i > 0; --i, ++r) {\n+                int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                if ((q = qs[j = r & m]) != null && (a = q.array) != null &&\n+                    (cap = a.length) > 0) {\n+                    poll: for (int src = j | SRC, b = q.base;;) {\n+                        int k = (cap - 1) & b, nb = b + 1;\n+                        ForkJoinTask<?> t = a[k];\n+                        U.loadFence();                \/\/ for re-reads\n+                        if (b != (b = q.base))\n+                            ;                         \/\/ stale\n+                        else if ((s = task.status) < 0)\n+                            return s;                 \/\/ recheck before taking\n+                        else if (t == null) {\n+                            if (a[k] == null) {\n+                                if (!rescan &&        \/\/ resized or stalled\n+                                    (q.array != a || q.top != b))\n+                                    rescan = true;\n+                                break;\n+                            }\n+                        }\n+                        else if (t instanceof CountedCompleter) {\n+                            CountedCompleter<?> f;\n+                            for (f = (CountedCompleter<?>)t;;) {\n+                                if (f == task)\n+                                    break;\n+                                else if ((f = f.completer) == null)\n+                                    break poll;       \/\/ ineligible\n+                            }\n+                            if (WorkQueue.casSlotToNull(a, k, t)) {\n+                                q.base = nb;\n+                                w.source = src;\n+                                t.doExec();\n+                                w.source = wsrc;\n+                                rescan = true;\n+                                break scan;\n+                            }\n+                        }\n+                        else\n+                            break;\n@@ -1998,2 +2152,0 @@\n-            if (!scan && queues == qs)\n-                break;\n@@ -2001,2 +2153,1 @@\n-        return null;\n-    }\n+     }\n@@ -2013,3 +2164,1 @@\n-    final int helpQuiescePool(WorkQueue w, long nanos, boolean interruptible) {\n-        if (w == null)\n-            return 0;\n+    private int helpQuiesce(WorkQueue w, long nanos, boolean interruptible) {\n@@ -2017,6 +2166,13 @@\n-        int prevSrc = w.source, wsrc = prevSrc, cfg = w.config, r = cfg + 1;\n-        for (boolean active = true, locals = true;;) {\n-            boolean busy = false, scan = false;\n-            if (locals) {  \/\/ run local tasks before (re)polling\n-                locals = false;\n-                for (ForkJoinTask<?> u; (u = w.nextLocalTask(cfg)) != null;)\n+        int phase; \/\/ w.phase set negative when temporarily quiescent\n+        if (w == null || (phase = w.phase) < 0)\n+            return 0;\n+        int activePhase = phase, inactivePhase = phase | INACTIVE;\n+        int wsrc = w.source, r = 0;\n+        for (boolean locals = true;;) {\n+            WorkQueue[] qs; WorkQueue q;\n+            if (runState < 0) {             \/\/ terminating\n+                w.phase = activePhase;\n+                return 1;\n+            }\n+            if (locals) {                   \/\/ run local tasks before (re)polling\n+                for (ForkJoinTask<?> u; (u = w.nextLocalTask()) != null;)\n@@ -2025,16 +2181,23 @@\n-            WorkQueue[] qs = queues;\n-            int n = (qs == null) ? 0 : qs.length;\n-            for (int i = n; i > 0; --i, ++r) {\n-                int j, b, cap; WorkQueue q; ForkJoinTask<?>[] a;\n-                if ((q = qs[j = (n - 1) & r]) != null && q != w &&\n-                    (a = q.array) != null && (cap = a.length) > 0) {\n-                    int k = (cap - 1) & (b = q.base);\n-                    int nextBase = b + 1, src = j | SRC;\n-                    ForkJoinTask<?> t = WorkQueue.getSlot(a, k);\n-                    if (q.base != b)\n-                        busy = scan = true;\n-                    else if (t != null) {\n-                        busy = scan = true;\n-                        if (!active) {    \/\/ increment before taking\n-                            active = true;\n-                            getAndAddCtl(RC_UNIT);\n+            boolean rescan = false, busy = locals = false, interrupted;\n+            int n = ((qs = queues) == null) ? 0 : qs.length, m = n - 1;\n+            scan: for (int i = n, j; i > 0; --i, ++r) {\n+                if ((q = qs[j = m & r]) != null && q != w) {\n+                    for (int src = j | SRC;;) {\n+                        ForkJoinTask<?>[] a = q.array;\n+                        int b = q.base, cap;\n+                        if (a == null || (cap = a.length) <= 0)\n+                            break;\n+                        int k = (cap - 1) & b, nb = b + 1, nk = (cap - 1) & nb;\n+                        ForkJoinTask<?> t = a[k];\n+                        U.loadFence();      \/\/ for re-reads\n+                        if (q.base != b || q.array != a || a[k] != t)\n+                            ;\n+                        else if (t == null) {\n+                            if (!rescan) {\n+                                if (a[nk] != null || q.top - b > 0)\n+                                    rescan = true;\n+                                else if (!busy &&\n+                                         q.owner != null && q.phase >= 0)\n+                                    busy = true;\n+                            }\n+                            break;\n@@ -2042,2 +2205,4 @@\n-                        if (WorkQueue.casSlotToNull(a, k, t)) {\n-                            q.base = nextBase;\n+                        else if (phase < 0) \/\/ reactivate before taking\n+                            w.phase = phase = activePhase;\n+                        else if (WorkQueue.casSlotToNull(a, k, t)) {\n+                            q.base = nb;\n@@ -2046,2 +2211,3 @@\n-                            w.source = wsrc = prevSrc;\n-                            locals = true;\n+                            w.source = wsrc;\n+                            rescan = locals = true;\n+                            break scan;\n@@ -2049,7 +2215,0 @@\n-                        break;\n-                    }\n-                    else if (!busy) {\n-                        if (q.top != b || a[nextBase & (cap - 1)] != null)\n-                            busy = scan = true;\n-                        else if (q.source != QUIET && q.phase >= 0)\n-                            busy = true;\n@@ -2059,30 +2218,23 @@\n-            VarHandle.acquireFence();\n-            if (!scan && queues == qs) {\n-                boolean interrupted;\n-                if (!busy) {\n-                    w.source = prevSrc;\n-                    if (!active)\n-                        getAndAddCtl(RC_UNIT);\n-                    return 1;\n-                }\n-                if (wsrc != QUIET)\n-                    w.source = wsrc = QUIET;\n-                if (active) {                 \/\/ decrement\n-                    active = false;\n-                    parkTime = 0L;\n-                    getAndAddCtl(RC_MASK & -RC_UNIT);\n-                }\n-                else if (parkTime == 0L) {\n-                    parkTime = 1L << 10; \/\/ initially about 1 usec\n-                    Thread.yield();\n-                }\n-                else if ((interrupted = interruptible && Thread.interrupted()) ||\n-                         System.nanoTime() - startTime > nanos) {\n-                    getAndAddCtl(RC_UNIT);\n-                    return interrupted ? -1 : 0;\n-                }\n-                else {\n-                    LockSupport.parkNanos(this, parkTime);\n-                    if (parkTime < nanos >>> 8 && parkTime < 1L << 20)\n-                        parkTime <<= 1;  \/\/ max sleep approx 1 sec or 1% nanos\n-                }\n+            if (rescan)\n+                ;                   \/\/ retry\n+            else if (phase >= 0) {\n+                parkTime = 0L;\n+                w.phase = phase = inactivePhase;\n+            }\n+            else if (!busy) {\n+                w.phase = activePhase;\n+                return 1;\n+            }\n+            else if (parkTime == 0L) {\n+                parkTime = 1L << 10; \/\/ initially about 1 usec\n+                Thread.yield();\n+            }\n+            else if ((interrupted = interruptible && Thread.interrupted()) ||\n+                     System.nanoTime() - startTime > nanos) {\n+                w.phase = activePhase;\n+                return interrupted ? -1 : 0;\n+            }\n+            else {\n+                LockSupport.parkNanos(this, parkTime);\n+                if (parkTime < nanos >>> 8 && parkTime < 1L << 20)\n+                    parkTime <<= 1;  \/\/ max sleep approx 1 sec or 1% nanos\n@@ -2100,1 +2252,1 @@\n-    final int externalHelpQuiescePool(long nanos, boolean interruptible) {\n+    private int externalHelpQuiesce(long nanos, boolean interruptible) {\n@@ -2125,0 +2277,21 @@\n+    \/**\n+     * Helps quiesce from either internal or external caller\n+     *\n+     * @param pool the pool to use, or null if any\n+     * @param nanos max wait time (Long.MAX_VALUE if effectively untimed)\n+     * @param interruptible true if return on interrupt\n+     * @return positive if quiescent, negative if interrupted, else 0\n+     *\/\n+    static final int helpQuiescePool(ForkJoinPool pool, long nanos,\n+                                     boolean interruptible) {\n+        Thread t; ForkJoinPool p; ForkJoinWorkerThread wt;\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread &&\n+            (p = (wt = (ForkJoinWorkerThread)t).pool) != null &&\n+            (p == pool || pool == null))\n+            return p.helpQuiesce(wt.workQueue, nanos, interruptible);\n+        else if ((p = pool) != null || (p = common) != null)\n+            return p.externalHelpQuiesce(nanos, interruptible);\n+        else\n+            return 0;\n+    }\n+\n@@ -2132,1 +2305,1 @@\n-        if (w == null || (t = w.nextLocalTask(w.config)) == null)\n+        if (w == null || (t = w.nextLocalTask()) == null)\n@@ -2141,1 +2314,2 @@\n-     * returns null if shutdown or terminating.\n+     * throws RejectedExecutionException if shutdown or terminating.\n+     * @param isSubmit false if this is for a common pool fork\n@@ -2143,1 +2317,1 @@\n-    final WorkQueue submissionQueue() {\n+    final WorkQueue submissionQueue(boolean isSubmit) {\n@@ -2145,0 +2319,1 @@\n+        ReentrantLock lock = registrationLock;\n@@ -2149,11 +2324,11 @@\n-        for (int id = r << 1;;) {                    \/\/ even indices only\n-            int md = mode, n, i; WorkQueue q; ReentrantLock lock;\n-            WorkQueue[] qs = queues;\n-            if ((md & SHUTDOWN) != 0 || qs == null || (n = qs.length) <= 0)\n-                return null;\n-            else if ((q = qs[i = (n - 1) & id]) == null) {\n-                if ((lock = registrationLock) != null) {\n-                    WorkQueue w = new WorkQueue(id | SRC);\n-                    lock.lock();                    \/\/ install under lock\n-                    if (qs[i] == null)\n-                        qs[i] = w;                  \/\/ else lost race; discard\n+        if (lock != null) {                          \/\/ else init error\n+            for (int id = r << 1;;) {                \/\/ even indices only\n+                int n, i; WorkQueue[] qs; WorkQueue q;\n+                if ((qs = queues) == null || (n = qs.length) <= 0)\n+                    break;\n+                else if ((q = qs[i = (n - 1) & id]) == null) {\n+                    WorkQueue w = new WorkQueue(null, id | SRC);\n+                    w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n+                    lock.lock();                     \/\/ install under lock\n+                    if (queues == qs && qs[i] == null)\n+                        qs[i] = w;                   \/\/ else lost race; discard\n@@ -2162,0 +2337,8 @@\n+                else if (q.getAndSetAccess(1) != 0)  \/\/ move and restart\n+                    id = (r = ThreadLocalRandom.advanceProbe(r)) << 1;\n+                else if (isSubmit && runState != 0) {\n+                    q.access = 0;                    \/\/ check while lock held\n+                    break;\n+                }\n+                else\n+                    return q;\n@@ -2163,4 +2346,0 @@\n-            else if (!q.tryLock())                  \/\/ move and restart\n-                id = (r = ThreadLocalRandom.advanceProbe(r)) << 1;\n-            else\n-                return q;\n@@ -2168,0 +2347,1 @@\n+        throw new RejectedExecutionException();\n@@ -2171,15 +2351,2 @@\n-     * Adds the given task to an external submission queue, or throws\n-     * exception if shutdown or terminating.\n-     *\n-     * @param task the task. Caller must ensure non-null.\n-     *\/\n-    final void externalPush(ForkJoinTask<?> task) {\n-        WorkQueue q;\n-        if ((q = submissionQueue()) == null)\n-            throw new RejectedExecutionException(); \/\/ shutdown or disabled\n-        else if (q.lockedPush(task))\n-            signalWork();\n-    }\n-\n-    \/**\n-     * Pushes a possibly-external submission.\n+     * Pushes a submission to the pool, using internal queue if called\n+     * from ForkJoinWorkerThread, else external queue.\n@@ -2187,4 +2354,5 @@\n-    private <T> ForkJoinTask<T> externalSubmit(ForkJoinTask<T> task) {\n-        Thread t; ForkJoinWorkerThread wt; WorkQueue q;\n-        if (task == null)\n-            throw new NullPointerException();\n+    private <T> ForkJoinTask<T> poolSubmit(boolean signalIfEmpty,\n+                                           ForkJoinTask<T> task) {\n+        WorkQueue q; Thread t; ForkJoinWorkerThread wt;\n+        U.storeStoreFence();  \/\/ ensure safely publishable\n+        if (task == null) throw new NullPointerException();\n@@ -2192,5 +2360,7 @@\n-            (q = (wt = (ForkJoinWorkerThread)t).workQueue) != null &&\n-            wt.pool == this)\n-            q.push(task, this);\n-        else\n-            externalPush(task);\n+            (wt = (ForkJoinWorkerThread)t).pool == this)\n+            q = wt.workQueue;\n+        else {\n+            task.markPoolSubmission();\n+            q = submissionQueue(true);\n+        }\n+        q.push(task, this, signalIfEmpty);\n@@ -2201,2 +2371,2 @@\n-     * Returns common pool queue for an external thread that has\n-     * possibly ever submitted a common pool task (nonzero probe), or\n+     * Returns queue for an external thread, if one exists that has\n+     * possibly ever submitted to the given pool (nonzero probe), or\n@@ -2205,2 +2375,2 @@\n-    static WorkQueue commonQueue() {\n-        ForkJoinPool p; WorkQueue[] qs;\n+    private static WorkQueue externalQueue(ForkJoinPool p) {\n+        WorkQueue[] qs;\n@@ -2208,1 +2378,1 @@\n-        return ((p = common) != null && (qs = p.queues) != null &&\n+        return (p != null && (qs = p.queues) != null &&\n@@ -2213,0 +2383,7 @@\n+    \/**\n+     * Returns external queue for common pool.\n+     *\/\n+    static WorkQueue commonQueue() {\n+        return externalQueue(common);\n+    }\n+\n@@ -2217,4 +2394,1 @@\n-        WorkQueue[] qs;\n-        int r = ThreadLocalRandom.getProbe(), n;\n-        return ((qs = queues) != null && (n = qs.length) > 0 && r != 0) ?\n-            qs[(n - 1) & (r << 1)] : null;\n+        return externalQueue(this);\n@@ -2287,2 +2461,0 @@\n-            int p = pool.mode & SMASK;\n-            int a = p + (int)(pool.ctl >> RC_SHIFT);\n@@ -2290,0 +2462,2 @@\n+            int p = pool.parallelism;\n+            int a = (short)(pool.ctl >>> RC_SHIFT);\n@@ -2302,1 +2476,1 @@\n-     * Possibly initiates and\/or completes termination.\n+     * Possibly initiates and\/or completes pool termination.\n@@ -2310,16 +2484,12 @@\n-        int md; \/\/ try to set SHUTDOWN, then STOP, then help terminate\n-        if (((md = mode) & SHUTDOWN) == 0) {\n-            if (!enable)\n-                return false;\n-            md = getAndBitwiseOrMode(SHUTDOWN);\n-        }\n-        if ((md & STOP) == 0) {\n-            if (!now && !canStop())\n-                return false;\n-            md = getAndBitwiseOrMode(STOP);\n-        }\n-        for (boolean rescan = true;;) { \/\/ repeat until no changes\n-            boolean changed = false;\n-            for (ForkJoinTask<?> t; (t = pollScan(false)) != null; ) {\n-                changed = true;\n-                ForkJoinTask.cancelIgnoringExceptions(t); \/\/ help cancel\n+        int rs; ReentrantLock lock; Condition cond;\n+        if ((rs = runState) >= 0) {                 \/\/ set SHUTDOWN and\/or STOP\n+            if ((config & ISCOMMON) != 0)\n+                return false;                       \/\/ cannot shutdown\n+            if (!now) {\n+                if ((rs & SHUTDOWN) == 0) {\n+                    if (!enable)\n+                        return false;\n+                    getAndBitwiseOrRunState(SHUTDOWN);\n+                }\n+                if (!canStop())\n+                    return false;\n@@ -2327,6 +2497,19 @@\n-            WorkQueue[] qs; int n; WorkQueue q; Thread thread;\n-            if ((qs = queues) != null && (n = qs.length) > 0) {\n-                for (int j = 1; j < n; j += 2) { \/\/ unblock other workers\n-                    if ((q = qs[j]) != null && (thread = q.owner) != null &&\n-                        !thread.isInterrupted()) {\n-                        changed = true;\n+            getAndBitwiseOrRunState(SHUTDOWN | STOP);\n+        }\n+        WorkQueue released = reactivate();          \/\/ try signalling waiter\n+        int tc = (short)(ctl >>> TC_SHIFT);\n+        if (released == null && tc > 0) {           \/\/ help unblock and cancel\n+            Thread current = Thread.currentThread();\n+            WorkQueue w = ((current instanceof ForkJoinWorkerThread) ?\n+                           ((ForkJoinWorkerThread)current).workQueue : null);\n+            int r = (w == null) ? 0 : w.config + 1; \/\/ stagger traversals\n+            WorkQueue[] qs = queues;\n+            int n = (qs == null) ? 0 : qs.length;\n+            for (int i = 0; i < n; ++i) {\n+                WorkQueue q; Thread thread;\n+                if ((q = qs[(r + i) & (n - 1)]) != null &&\n+                    (thread = q.owner) != current && q.access != STOP) {\n+                    for (ForkJoinTask<?> t; (t = q.poll(null)) != null; )\n+                        ForkJoinTask.cancelIgnoringExceptions(t);\n+                    if (thread != null && !thread.isInterrupted()) {\n+                        q.forcePhaseActive();      \/\/ for awaitWork\n@@ -2340,16 +2523,9 @@\n-            ReentrantLock lock; Condition cond; \/\/ signal when no workers\n-            if (((md = mode) & TERMINATED) == 0 &&\n-                (md & SMASK) + (short)(ctl >>> TC_SHIFT) <= 0 &&\n-                (getAndBitwiseOrMode(TERMINATED) & TERMINATED) == 0 &&\n-                (lock = registrationLock) != null) {\n-                lock.lock();\n-                if ((cond = termination) != null)\n-                    cond.signalAll();\n-                lock.unlock();\n-            }\n-            if (changed)\n-                rescan = true;\n-            else if (rescan)\n-                rescan = false;\n-            else\n-                break;\n+        }\n+        if ((tc <= 0 || (short)(ctl >>> TC_SHIFT) <= 0) &&\n+            (getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0 &&\n+            (lock = registrationLock) != null) {\n+            lock.lock();                            \/\/ signal when no workers\n+            if ((cond = termination) != null)\n+                cond.signalAll();\n+            lock.unlock();\n+            \/\/ container.close(); \/\/ for loom\n@@ -2531,0 +2707,1 @@\n+        this.parallelism = p;\n@@ -2534,0 +2711,1 @@\n+        this.config = asyncMode ? FIFO : 0;\n@@ -2535,1 +2713,0 @@\n-        int size = 1 << (33 - Integer.numberOfLeadingZeros(p - 1));\n@@ -2537,6 +2714,5 @@\n-        int maxSpares = Math.min(maximumPoolSize, MAX_CAP) - p;\n-        int minAvail = Math.min(Math.max(minimumRunnable, 0), MAX_CAP);\n-        this.bounds = ((minAvail - p) & SMASK) | (maxSpares << SWIDTH);\n-        this.mode = p | (asyncMode ? FIFO : 0);\n-        this.ctl = ((((long)(-corep) << TC_SHIFT) & TC_MASK) |\n-                    (((long)(-p)     << RC_SHIFT) & RC_MASK));\n+        int maxSpares = Math.max(0, Math.min(maximumPoolSize - p, MAX_CAP));\n+        int minAvail = Math.max(0, Math.min(minimumRunnable, MAX_CAP));\n+        this.bounds = (long)(minAvail & SMASK) | (long)(maxSpares << SWIDTH) |\n+            ((long)corep << 32);\n+        int size = 1 << (33 - Integer.numberOfLeadingZeros(p - 1));\n@@ -2546,11 +2722,3 @@\n-        this.workerNamePrefix = \"ForkJoinPool-\" + pid + \"-worker-\";\n-    }\n-\n-    \/\/ helper method for commonPool constructor\n-    private static Object newInstanceFromSystemProperty(String property)\n-        throws ReflectiveOperationException {\n-        String className = System.getProperty(property);\n-        return (className == null)\n-            ? null\n-            : ClassLoader.getSystemClassLoader().loadClass(className)\n-            .getConstructor().newInstance();\n+        String name = \"ForkJoinPool-\" + pid;\n+        this.workerNamePrefix = name + \"-worker-\";\n+        \/\/        this.container = SharedThreadContainer.create(name); \/\/ for loom\n@@ -2564,2 +2732,1 @@\n-        int parallelism = Math.max(1, Runtime.getRuntime().availableProcessors() - 1);\n-        ForkJoinWorkerThreadFactory fac = null;\n+        ForkJoinWorkerThreadFactory fac = defaultForkJoinWorkerThreadFactory;\n@@ -2567,0 +2734,2 @@\n+        int maxSpares = DEFAULT_COMMON_MAX_SPARES;\n+        int pc = 0, preset = 0; \/\/ nonzero if size set as property\n@@ -2568,4 +2737,0 @@\n-            fac = (ForkJoinWorkerThreadFactory) newInstanceFromSystemProperty(\n-                \"java.util.concurrent.ForkJoinPool.common.threadFactory\");\n-            handler = (UncaughtExceptionHandler) newInstanceFromSystemProperty(\n-                \"java.util.concurrent.ForkJoinPool.common.exceptionHandler\");\n@@ -2574,2 +2739,21 @@\n-            if (pp != null)\n-                parallelism = Integer.parseInt(pp);\n+            if (pp != null) {\n+                pc = Math.max(0, Integer.parseInt(pp));\n+                preset = PRESET_SIZE;\n+            }\n+            String ms = System.getProperty\n+                (\"java.util.concurrent.ForkJoinPool.common.maximumSpares\");\n+            if (ms != null)\n+                maxSpares = Math.max(0, Math.min(MAX_CAP, Integer.parseInt(ms)));\n+            String sf = System.getProperty\n+                (\"java.util.concurrent.ForkJoinPool.common.threadFactory\");\n+            String sh = System.getProperty\n+                (\"java.util.concurrent.ForkJoinPool.common.exceptionHandler\");\n+            if (sf != null || sh != null) {\n+                ClassLoader ldr = ClassLoader.getSystemClassLoader();\n+                if (sf != null)\n+                    fac = (ForkJoinWorkerThreadFactory)\n+                        ldr.loadClass(sf).getConstructor().newInstance();\n+                if (sh != null)\n+                    handler = (UncaughtExceptionHandler)\n+                        ldr.loadClass(sh).getConstructor().newInstance();\n+            }\n@@ -2578,0 +2762,8 @@\n+        if (preset == 0)\n+            pc = Math.max(1, Runtime.getRuntime().availableProcessors() - 1);\n+        int p = Math.min(pc, MAX_CAP);\n+        int size = (p == 0) ? 1 : 1 << (33 - Integer.numberOfLeadingZeros(p-1));\n+        this.parallelism = p;\n+        this.config = ISCOMMON | preset;\n+        this.bounds = (long)(1 | (maxSpares << SWIDTH));\n+        this.factory = fac;\n@@ -2582,15 +2774,0 @@\n-        int p = Math.min(Math.max(parallelism, 0), MAX_CAP), size;\n-        this.mode = p;\n-        if (p > 0) {\n-            size = 1 << (33 - Integer.numberOfLeadingZeros(p - 1));\n-            this.bounds = ((1 - p) & SMASK) | (COMMON_MAX_SPARES << SWIDTH);\n-            this.ctl = ((((long)(-p) << TC_SHIFT) & TC_MASK) |\n-                        (((long)(-p) << RC_SHIFT) & RC_MASK));\n-        } else {  \/\/ zero min, max, spare counts, 1 slot\n-            size = 1;\n-            this.bounds = 0;\n-            this.ctl = 0L;\n-        }\n-        this.factory = (fac != null) ? fac :\n-            new DefaultCommonPoolForkJoinWorkerThreadFactory();\n-        this.queues = new WorkQueue[size];\n@@ -2598,0 +2775,2 @@\n+        this.queues = new WorkQueue[size];\n+        \/\/        this.container = SharedThreadContainer.create(\"ForkJoinPool.commonPool\"); \/\/ for loom\n@@ -2638,2 +2817,2 @@\n-        externalSubmit(task);\n-        return task.joinForPoolInvoke(this);\n+        poolSubmit(true, task);\n+        return task.join();\n@@ -2651,1 +2830,1 @@\n-        externalSubmit(task);\n+        poolSubmit(true, task);\n@@ -2664,3 +2843,3 @@\n-        externalSubmit((task instanceof ForkJoinTask<?>)\n-                       ? (ForkJoinTask<Void>) task \/\/ avoid re-wrap\n-                       : new ForkJoinTask.RunnableExecuteAction(task));\n+        poolSubmit(true, (task instanceof ForkJoinTask<?>)\n+                   ? (ForkJoinTask<Void>) task \/\/ avoid re-wrap\n+                   : new ForkJoinTask.RunnableExecuteAction(task));\n@@ -2680,1 +2859,1 @@\n-        return externalSubmit(task);\n+        return poolSubmit(true, task);\n@@ -2690,1 +2869,1 @@\n-        return externalSubmit(new ForkJoinTask.AdaptedCallable<T>(task));\n+        return poolSubmit(true, new ForkJoinTask.AdaptedCallable<T>(task));\n@@ -2700,1 +2879,1 @@\n-        return externalSubmit(new ForkJoinTask.AdaptedRunnable<T>(task, result));\n+        return poolSubmit(true, new ForkJoinTask.AdaptedRunnable<T>(task, result));\n@@ -2711,3 +2890,54 @@\n-        return externalSubmit((task instanceof ForkJoinTask<?>)\n-            ? (ForkJoinTask<Void>) task \/\/ avoid re-wrap\n-            : new ForkJoinTask.AdaptedRunnableAction(task));\n+        return poolSubmit(true, (task instanceof ForkJoinTask<?>)\n+                          ? (ForkJoinTask<Void>) task \/\/ avoid re-wrap\n+                          : new ForkJoinTask.AdaptedRunnableAction(task));\n+    }\n+\n+    \/\/ Added mainly for possible use in Loom\n+\n+    \/**\n+     * Submits the given task without guaranteeing that it will\n+     * eventually execute in the absence of available active threads.\n+     * In some contexts, this method may reduce contention and\n+     * overhead by relying on context-specific knowledge that existing\n+     * threads (possibly including the calling thread if operating in\n+     * this pool) will eventually be available to execute the task.\n+     *\n+     * @param task the task\n+     * @param <T> the type of the task's result\n+     * @return the task\n+     * @since 19\n+     *\/\n+    public <T> ForkJoinTask<T> lazySubmit(ForkJoinTask<T> task) {\n+        return poolSubmit(false, task);\n+    }\n+\n+    \/**\n+     * Changes the target parallelism of this pool, controlling the\n+     * future creation, use, and termination of worker threads.\n+     * Applications include contexts in which the number of available\n+     * processors changes over time.\n+     *\n+     * @implNote This implementation restricts the maximum number of\n+     * running threads to 32767\n+     *\n+     * @param size the target parallelism level\n+     * @return the previous parallelism level.\n+     * @throws IllegalArgumentException if size is less than 1 or\n+     *         greater than the maximum supported by this pool.\n+     * @throws UnsupportedOperationException this is the{@link\n+     *         #commonPool()} and parallelism level was set by System\n+     *         property {@systemProperty\n+     *         java.util.concurrent.ForkJoinPool.common.parallelism}.\n+     * @throws SecurityException if a security manager exists and\n+     *         the caller is not permitted to modify threads\n+     *         because it does not hold {@link\n+     *         java.lang.RuntimePermission}{@code (\"modifyThread\")}\n+     * @since 19\n+     *\/\n+    public int setParallelism(int size) {\n+        if (size < 1 || size > MAX_CAP)\n+            throw new IllegalArgumentException();\n+        if ((config & PRESET_SIZE) != 0)\n+            throw new UnsupportedOperationException(\"Cannot override System property\");\n+        checkPermission();\n+        return getAndSetParallelism(size);\n@@ -2728,1 +2958,1 @@\n-                externalSubmit(f);\n+                poolSubmit(true, f);\n@@ -2731,1 +2961,1 @@\n-                ((ForkJoinTask<?>)futures.get(i)).awaitPoolInvoke(this);\n+                ((ForkJoinTask<?>)futures.get(i)).quietlyJoin();\n@@ -2751,1 +2981,1 @@\n-                externalSubmit(f);\n+                poolSubmit(true, f);\n@@ -2756,1 +2986,1 @@\n-                Future<T> f = futures.get(i);\n+                ForkJoinTask<T> f = (ForkJoinTask<T>)futures.get(i);\n@@ -2758,0 +2988,2 @@\n+                    if (!timedOut)\n+                        timedOut = !f.quietlyJoin(ns, TimeUnit.NANOSECONDS);\n@@ -2760,5 +2992,2 @@\n-                    else {\n-                        ((ForkJoinTask<T>)f).awaitPoolInvoke(this, ns);\n-                        if ((ns = nanos - (System.nanoTime() - startTime)) < 0L)\n-                            timedOut = true;\n-                    }\n+                    else\n+                        ns = nanos - (System.nanoTime() - startTime);\n@@ -2791,1 +3020,1 @@\n-                (pool != null && pool.mode < 0))\n+                (pool != null && pool.runState < 0))\n@@ -2804,1 +3033,1 @@\n-            if ((pool != null && pool.mode < 0) ||\n+            if ((pool != null && pool.runState < 0) ||\n@@ -2861,1 +3090,1 @@\n-                externalSubmit(f);\n+                poolSubmit(true, f);\n@@ -2865,1 +3094,1 @@\n-            return root.getForPoolInvoke(this);\n+            return root.get();\n@@ -2888,1 +3117,1 @@\n-                externalSubmit(f);\n+                poolSubmit(true, f);\n@@ -2892,1 +3121,1 @@\n-            return root.getForPoolInvoke(this, nanos);\n+            return root.get(nanos, TimeUnit.NANOSECONDS);\n@@ -2924,2 +3153,1 @@\n-        int par = mode & SMASK;\n-        return (par > 0) ? par : 1;\n+        return Math.max(getParallelismOpaque(), 1);\n@@ -2935,1 +3163,1 @@\n-        return COMMON_PARALLELISM;\n+        return common.getParallelism();\n@@ -2947,1 +3175,1 @@\n-        return ((mode & SMASK) + (short)(ctl >>> TC_SHIFT));\n+        return (short)(ctl >>> TC_SHIFT);\n@@ -2957,1 +3185,1 @@\n-        return (mode & FIFO) != 0;\n+        return (config & FIFO) != 0;\n@@ -2969,1 +3197,0 @@\n-        VarHandle.acquireFence();\n@@ -2972,1 +3199,1 @@\n-        if ((qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n@@ -2989,2 +3216,1 @@\n-        int r = (mode & SMASK) + (int)(ctl >> RC_SHIFT);\n-        return (r <= 0) ? 0 : r; \/\/ suppress momentarily negative values\n+        return Math.max((short)(ctl >>> RC_SHIFT), 0);\n@@ -3025,1 +3251,1 @@\n-                    count += (long)q.nsteals & 0xffffffffL;\n+                     count += (long)q.nsteals & 0xffffffffL;\n@@ -3042,1 +3268,0 @@\n-        VarHandle.acquireFence();\n@@ -3045,1 +3270,1 @@\n-        if ((qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n@@ -3062,1 +3287,0 @@\n-        VarHandle.acquireFence();\n@@ -3065,1 +3289,1 @@\n-        if ((qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n@@ -3081,9 +3305,1 @@\n-        VarHandle.acquireFence();\n-        WorkQueue[] qs; WorkQueue q;\n-        if ((qs = queues) != null) {\n-            for (int i = 0; i < qs.length; i += 2) {\n-                if ((q = qs[i]) != null && !q.isEmpty())\n-                    return true;\n-            }\n-        }\n-        return false;\n+        return hasTasks(true);\n@@ -3138,2 +3354,0 @@\n-        int md = mode; \/\/ read volatile fields first\n-        long c = ctl;\n@@ -3159,3 +3373,4 @@\n-        int pc = (md & SMASK);\n-        int tc = pc + (short)(c >>> TC_SHIFT);\n-        int ac = pc + (int)(c >> RC_SHIFT);\n+        int pc = parallelism;\n+        long c = ctl;\n+        int tc = (short)(c >>> TC_SHIFT);\n+        int ac = (short)(c >>> RC_SHIFT);\n@@ -3164,3 +3379,4 @@\n-        String level = ((md & TERMINATED) != 0 ? \"Terminated\" :\n-                        (md & STOP)       != 0 ? \"Terminating\" :\n-                        (md & SHUTDOWN)   != 0 ? \"Shutting down\" :\n+        int rs = runState;\n+        String level = ((rs & TERMINATED) != 0 ? \"Terminated\" :\n+                        (rs & STOP)       != 0 ? \"Terminating\" :\n+                        (rs & SHUTDOWN)   != 0 ? \"Shutting down\" :\n@@ -3196,2 +3412,1 @@\n-        if (this != common)\n-            tryTerminate(false, true);\n+        tryTerminate(false, true);\n@@ -3220,2 +3435,1 @@\n-        if (this != common)\n-            tryTerminate(true, true);\n+        tryTerminate(true, true);\n@@ -3231,1 +3445,1 @@\n-        return (mode & TERMINATED) != 0;\n+        return (runState & TERMINATED) != 0;\n@@ -3248,1 +3462,1 @@\n-        return (mode & (STOP | TERMINATED)) == STOP;\n+        return (runState & (STOP | TERMINATED)) == STOP;\n@@ -3257,1 +3471,1 @@\n-        return (mode & SHUTDOWN) != 0;\n+        return runState != 0;\n@@ -3276,1 +3490,1 @@\n-        ReentrantLock lock; Condition cond;\n+        ReentrantLock lock; Condition cond; boolean terminated;\n@@ -3278,9 +3492,2 @@\n-        boolean terminated = false;\n-        if (this == common) {\n-            Thread t; ForkJoinWorkerThread wt; int q;\n-            if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread &&\n-                (wt = (ForkJoinWorkerThread)t).pool == this)\n-                q = helpQuiescePool(wt.workQueue, nanos, true);\n-            else\n-                q = externalHelpQuiescePool(nanos, true);\n-            if (q < 0)\n+        if ((config & ISCOMMON) != 0) {\n+            if (helpQuiescePool(this, nanos, true) < 0)\n@@ -3288,0 +3495,1 @@\n+            terminated = false;\n@@ -3289,10 +3497,14 @@\n-        else if (!(terminated = ((mode & TERMINATED) != 0)) &&\n-                 (lock = registrationLock) != null) {\n-            lock.lock();\n-            try {\n-                if ((cond = termination) == null)\n-                    termination = cond = lock.newCondition();\n-                while (!(terminated = ((mode & TERMINATED) != 0)) && nanos > 0L)\n-                    nanos = cond.awaitNanos(nanos);\n-            } finally {\n-                lock.unlock();\n+        else if (!(terminated = ((runState & TERMINATED) != 0))) {\n+            tryTerminate(false, false);  \/\/ reduce transient blocking\n+            if ((lock = registrationLock) != null &&\n+                !(terminated = (((runState & TERMINATED) != 0)))) {\n+                lock.lock();\n+                try {\n+                    if ((cond = termination) == null)\n+                        termination = cond = lock.newCondition();\n+                    while (!(terminated = ((runState & TERMINATED) != 0)) &&\n+                           nanos > 0L)\n+                        nanos = cond.awaitNanos(nanos);\n+                } finally {\n+                    lock.unlock();\n+                }\n@@ -3316,8 +3528,1 @@\n-        Thread t; ForkJoinWorkerThread wt; int q;\n-        long nanos = unit.toNanos(timeout);\n-        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread &&\n-            (wt = (ForkJoinWorkerThread)t).pool == this)\n-            q = helpQuiescePool(wt.workQueue, nanos, false);\n-        else\n-            q = externalHelpQuiescePool(nanos, false);\n-        return (q > 0);\n+        return (helpQuiescePool(this, unit.toNanos(timeout), false) > 0);\n@@ -3447,1 +3652,1 @@\n-            if ((comp = tryCompensate(c)) >= 0) {\n+            if ((comp = tryCompensate(c, false)) >= 0) {\n@@ -3482,0 +3687,2 @@\n+        U = Unsafe.getUnsafe();\n+        Class<ForkJoinPool> klass = ForkJoinPool.class;\n@@ -3483,6 +3690,2 @@\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            CTL = l.findVarHandle(ForkJoinPool.class, \"ctl\", long.class);\n-            MODE = l.findVarHandle(ForkJoinPool.class, \"mode\", int.class);\n-            THREADIDS = l.findVarHandle(ForkJoinPool.class, \"threadIds\", int.class);\n-            POOLIDS = l.findStaticVarHandle(ForkJoinPool.class, \"poolIds\", int.class);\n-        } catch (ReflectiveOperationException e) {\n+            POOLIDS = U.staticFieldOffset(klass.getDeclaredField(\"poolIds\"));\n+        } catch (NoSuchFieldException e) {\n@@ -3491,13 +3694,4 @@\n-\n-        \/\/ Reduce the risk of rare disastrous classloading in first call to\n-        \/\/ LockSupport.park: https:\/\/bugs.openjdk.java.net\/browse\/JDK-8074773\n-        Class<?> ensureLoaded = LockSupport.class;\n-\n-        int commonMaxSpares = DEFAULT_COMMON_MAX_SPARES;\n-        try {\n-            String p = System.getProperty\n-                (\"java.util.concurrent.ForkJoinPool.common.maximumSpares\");\n-            if (p != null)\n-                commonMaxSpares = Integer.parseInt(p);\n-        } catch (Exception ignore) {}\n-        COMMON_MAX_SPARES = commonMaxSpares;\n+        CTL = U.objectFieldOffset(klass, \"ctl\");\n+        RUNSTATE = U.objectFieldOffset(klass, \"runState\");\n+        PARALLELISM = U.objectFieldOffset(klass, \"parallelism\");\n+        THREADIDS = U.objectFieldOffset(klass, \"threadIds\");\n@@ -3507,1 +3701,0 @@\n-        modifyThreadPermission = new RuntimePermission(\"modifyThread\");\n@@ -3509,6 +3702,6 @@\n-        ForkJoinPool tmp = AccessController.doPrivileged(new PrivilegedAction<>() {\n-            public ForkJoinPool run() {\n-                return new ForkJoinPool((byte)0); }});\n-        common = tmp;\n-\n-        COMMON_PARALLELISM = Math.max(common.mode & SMASK, 1);\n+        ForkJoinPool p = common = (System.getSecurityManager() == null) ?\n+            new ForkJoinPool((byte)0) :\n+            AccessController.doPrivileged(new PrivilegedAction<>() {\n+                    public ForkJoinPool run() {\n+                        return new ForkJoinPool((byte)0); }});\n+        Class<?> dep = LockSupport.class; \/\/ ensure loaded\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":1575,"deletions":1382,"binary":false,"changes":2957,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -46,0 +44,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -221,3 +220,5 @@\n-     * Revision notes: The use of \"Aux\" field replaces previous\n-     * reliance on a table to hold exceptions and synchronized blocks\n-     * and monitors to wait for completion.\n+     * Revision notes: This class uses jdk-internal Unsafe for atomics\n+     * and special memory modes, rather than VarHandles, to avoid\n+     * initialization dependencies in other jdk components that\n+     * require early parallelism. It also simplifies handling of\n+     * pool-submitted tasks, among other minor improvements.\n@@ -241,1 +242,1 @@\n-            return NEXT.compareAndSet(this, c, v);\n+            return U.compareAndSetReference(this, NEXT, c, v);\n@@ -243,1 +244,2 @@\n-        private static final VarHandle NEXT;\n+        private static final Unsafe U;\n+        private static final long NEXT;\n@@ -245,6 +247,2 @@\n-            try {\n-                NEXT = MethodHandles.lookup()\n-                    .findVarHandle(Aux.class, \"next\", Aux.class);\n-            } catch (ReflectiveOperationException e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n+            U = Unsafe.getUnsafe();\n+            NEXT = U.objectFieldOffset(Aux.class, \"next\");\n@@ -264,5 +262,11 @@\n-    private static final int DONE         = 1 << 31; \/\/ must be negative\n-    private static final int ABNORMAL     = 1 << 16;\n-    private static final int THROWN       = 1 << 17;\n-    private static final int SMASK        = 0xffff;  \/\/ short bits for tags\n-    private static final int UNCOMPENSATE = 1 << 16; \/\/ helpJoin return sentinel\n+    static final int DONE         = 1 << 31; \/\/ must be negative\n+    static final int ABNORMAL     = 1 << 16;\n+    static final int THROWN       = 1 << 17;\n+    static final int SMASK        = 0xffff;  \/\/ short bits for tags\n+    static final int UNCOMPENSATE = 1 << 16; \/\/ helpJoin return sentinel\n+    static final int POOLSUBMIT   = 1 << 18; \/\/ for pool.submit vs fork\n+\n+    \/\/ flags for awaitDone (in addition to above)\n+    static final int RAN           = 1;\n+    static final int INTERRUPTIBLE = 2;\n+    static final int TIMED         = 4;\n@@ -275,2 +279,3 @@\n-    private static final VarHandle STATUS;\n-    private static final VarHandle AUX;\n+    private static final Unsafe U;\n+    private static final long STATUS;\n+    private static final long AUX;\n@@ -278,1 +283,1 @@\n-        return (int)STATUS.getAndBitwiseOr(this, v);\n+        return U.getAndBitwiseOrInt(this, STATUS, v);\n@@ -281,1 +286,1 @@\n-        return STATUS.compareAndSet(this, c, v);\n+        return U.compareAndSetInt(this, STATUS, c, v);\n@@ -284,1 +289,8 @@\n-        return AUX.compareAndSet(this, c, v);\n+        return U.compareAndSetReference(this, AUX, c, v);\n+    }\n+\n+    \/**\n+     * Marks this task as an external pool submission.\n+     *\/\n+    final void markPoolSubmission() {\n+        getAndBitwiseOrStatus(POOLSUBMIT);\n@@ -390,5 +402,2 @@\n-     * @param pool if nonnull, known submitted pool, else assumes current pool\n-     * @param ran true if task known to have been exec'd\n-     * @param interruptible true if park interruptibly when external\n-     * @param timed true if use timed wait\n-     * @param nanos if timed, timeout value\n+     * @param how flags for POOLSUBMIT, RAN, INTERRUPTIBLE, TIMED\n+     * @param deadline if timed, timeout deadline\n@@ -397,4 +406,2 @@\n-    private int awaitDone(ForkJoinPool pool, boolean ran,\n-                          boolean interruptible, boolean timed,\n-                          long nanos) {\n-        ForkJoinPool p; boolean internal; int s; Thread t;\n+    private int awaitDone(int how, long deadline) {\n+        int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool p;\n@@ -402,0 +409,2 @@\n+        boolean timed = (how & TIMED) != 0;\n+        boolean owned = false, uncompensate = false;\n@@ -403,1 +412,2 @@\n-            ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n+            owned = true;\n+            q = (wt = (ForkJoinWorkerThread)t).workQueue;\n@@ -405,4 +415,0 @@\n-            if (pool == null)\n-                pool = p;\n-            if (internal = (pool == p))\n-                q = wt.workQueue;\n@@ -410,18 +416,12 @@\n-        else {\n-            internal = false;\n-            p = ForkJoinPool.common;\n-            if (pool == null)\n-                pool = p;\n-            if (pool == p && p != null)\n-                q = p.externalQueue();\n-        }\n-        if (interruptible && Thread.interrupted())\n-            return ABNORMAL;\n-        if ((s = status) < 0)\n-            return s;\n-        long deadline = 0L;\n-        if (timed) {\n-            if (nanos <= 0L)\n-                return 0;\n-            else if ((deadline = nanos + System.nanoTime()) == 0L)\n-                deadline = 1L;\n+        else if ((p = ForkJoinPool.common) != null && (how & POOLSUBMIT) == 0)\n+            q = p.externalQueue();\n+        if (q != null && p != null) { \/\/ try helping\n+            if (this instanceof CountedCompleter)\n+                s = p.helpComplete(this, q, owned, timed);\n+            else if ((how & RAN) != 0 ||\n+                     (s = q.tryRemoveAndExec(this, owned)) >= 0)\n+                s = (owned) ? p.helpJoin(this, q, timed) : 0;\n+            if (s < 0)\n+                return s;\n+            if (s == UNCOMPENSATE)\n+                uncompensate = true;\n@@ -429,11 +429,13 @@\n-        boolean uncompensate = false;\n-        if (q != null && p != null) {  \/\/ try helping\n-            \/\/ help even in timed mode if pool has no parallelism\n-            boolean canHelp = !timed || (p.mode & SMASK) == 0;\n-            if (canHelp) {\n-                if ((this instanceof CountedCompleter) &&\n-                    (s = p.helpComplete(this, q, internal)) < 0)\n-                    return s;\n-                if (!ran && ((!internal && q.externalTryUnpush(this)) ||\n-                             q.tryRemove(this, internal)) && (s = doExec()) < 0)\n-                    return s;\n+        Aux node = null;\n+        long ns = 0L;\n+        boolean interrupted = false, queued = false;\n+        for (;;) {                    \/\/ install node and await signal\n+            Aux a;\n+            if ((s = status) < 0)\n+                break;\n+            else if (node == null)\n+                node = new Aux(Thread.currentThread(), null);\n+            else if (!queued) {\n+                if (((a = aux) == null || a.ex == null) &&\n+                    (queued = casAux(node.next = a, node)))\n+                    LockSupport.setCurrentBlocker(this);\n@@ -441,5 +443,3 @@\n-            if (internal) {\n-                if ((s = p.helpJoin(this, q, canHelp)) < 0)\n-                    return s;\n-                if (s == UNCOMPENSATE)\n-                    uncompensate = true;\n+            else if (timed && (ns = deadline - System.nanoTime()) <= 0) {\n+                s = 0;\n+                break;\n@@ -447,11 +447,5 @@\n-        }\n-        \/\/ block until done or cancelled wait\n-        boolean interrupted = false, queued = false;\n-        boolean parked = false, fail = false;\n-        Aux node = null;\n-        while ((s = status) >= 0) {\n-            Aux a; long ns;\n-            if (fail || (fail = (pool != null && pool.mode < 0)))\n-                casStatus(s, s | (DONE | ABNORMAL)); \/\/ try to cancel\n-            else if (parked && Thread.interrupted()) {\n-                if (interruptible) {\n+            else if (Thread.interrupted()) {\n+                interrupted = true;\n+                if ((how & POOLSUBMIT) != 0 && p != null && p.runState < 0)\n+                    cancelIgnoringExceptions(this); \/\/ cancel on shutdown\n+                else if ((how & INTERRUPTIBLE) != 0) {\n@@ -461,24 +455,0 @@\n-                interrupted = true;\n-            }\n-            else if (queued) {\n-                if (deadline != 0L) {\n-                    if ((ns = deadline - System.nanoTime()) <= 0L)\n-                        break;\n-                    LockSupport.parkNanos(ns);\n-                }\n-                else\n-                    LockSupport.park();\n-                parked = true;\n-            }\n-            else if (node != null) {\n-                if ((a = aux) != null && a.ex != null)\n-                    Thread.onSpinWait();     \/\/ exception in progress\n-                else if (queued = casAux(node.next = a, node))\n-                    LockSupport.setCurrentBlocker(this);\n-            }\n-            else {\n-                try {\n-                    node = new Aux(Thread.currentThread(), null);\n-                } catch (Throwable ex) {     \/\/ cannot create\n-                    fail = true;\n-                }\n@@ -486,0 +456,6 @@\n+            else if ((s = status) < 0) \/\/ recheck\n+                break;\n+            else if (timed)\n+                LockSupport.parkNanos(ns);\n+            else\n+                LockSupport.park();\n@@ -487,2 +463,2 @@\n-        if (pool != null && uncompensate)\n-            pool.uncompensate();\n+        if (uncompensate)\n+            p.uncompensate();\n@@ -581,2 +557,1 @@\n-        if ((s & ABNORMAL) != 0 &&\n-            ((s & THROWN) == 0 || (ex = getThrowableException()) == null))\n+        if ((s & ABNORMAL) != 0 && (ex = getThrowableException()) == null)\n@@ -592,2 +567,1 @@\n-        ForkJoinTask.<RuntimeException>uncheckedThrow(\n-            (s & THROWN) != 0 ? getThrowableException() : null);\n+        ForkJoinTask.<RuntimeException>uncheckedThrow(getThrowableException());\n@@ -601,1 +575,1 @@\n-        Throwable ex = null;\n+        Throwable ex = null, rx;\n@@ -606,2 +580,2 @@\n-        else if ((s & THROWN) != 0 && (ex = getThrowableException()) != null)\n-            ex = new ExecutionException(ex);\n+        else if ((rx = getThrowableException()) != null)\n+            ex = new ExecutionException(rx);\n@@ -650,3 +624,7 @@\n-        Thread t; ForkJoinWorkerThread w;\n-        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n-            (w = (ForkJoinWorkerThread)t).workQueue.push(this, w.pool);\n+        Thread t; ForkJoinWorkerThread wt;\n+        ForkJoinPool p; ForkJoinPool.WorkQueue q;\n+        U.storeStoreFence();  \/\/ ensure safely publishable\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n+            p = (wt = (ForkJoinWorkerThread)t).pool;\n+            q = wt.workQueue;\n+        }\n@@ -654,1 +632,2 @@\n-            ForkJoinPool.common.externalPush(this);\n+            q = (p = ForkJoinPool.common).submissionQueue(false);\n+        q.push(this, p, true);\n@@ -672,1 +651,1 @@\n-            s = awaitDone(null, false, false, false, 0L);\n+            s = awaitDone(s & POOLSUBMIT, 0L);\n@@ -689,1 +668,1 @@\n-            s = awaitDone(null, true, false, false, 0L);\n+            s = awaitDone(RAN, 0L);\n@@ -718,1 +697,1 @@\n-            s1 = t1.awaitDone(null, true, false, false, 0L);\n+            s1 = t1.awaitDone(RAN, 0L);\n@@ -723,2 +702,6 @@\n-        else if (((s2 = t2.awaitDone(null, false, false, false, 0L)) & ABNORMAL) != 0)\n-            t2.reportException(s2);\n+        else {\n+            if ((s2 = t2.status) >= 0)\n+                s2 = t2.awaitDone(0, 0L);\n+            if ((s2 & ABNORMAL) != 0)\n+                t2.reportException(s2);\n+        }\n@@ -754,1 +737,1 @@\n-                    s = t.awaitDone(null, true, false, false, 0L);\n+                    s = t.awaitDone(RAN, 0L);\n@@ -767,1 +750,1 @@\n-                        s = t.awaitDone(null, false, false, false, 0L);\n+                        s = t.awaitDone(0, 0L);\n@@ -817,1 +800,1 @@\n-                    s = t.awaitDone(null, true, false, false, 0L);\n+                    s = t.awaitDone(RAN, 0L);\n@@ -830,1 +813,1 @@\n-                        s = t.awaitDone(null, false, false, false, 0L);\n+                        s = t.awaitDone(0, 0L);\n@@ -903,0 +886,23 @@\n+    @Override\n+    public State state() {\n+        int s = status;\n+        return (s >= 0) ? State.RUNNING :\n+            ((s & (DONE | ABNORMAL)) == DONE) ? State.SUCCESS:\n+            ((s & (ABNORMAL | THROWN)) == (ABNORMAL | THROWN)) ? State.FAILED :\n+            State.CANCELLED;\n+    }\n+\n+    @Override\n+    public V resultNow() {\n+        if (!isCompletedNormally())\n+            throw new IllegalStateException();\n+        return getRawResult();\n+    }\n+\n+    @Override\n+    public Throwable exceptionNow() {\n+        if ((status & (ABNORMAL | THROWN)) != (ABNORMAL | THROWN))\n+            throw new IllegalStateException();\n+        return getThrowableException();\n+    }\n+\n@@ -981,1 +987,5 @@\n-        int s = awaitDone(null, false, true, false, 0L);\n+        int s;\n+        if (Thread.interrupted())\n+            s = ABNORMAL;\n+        else if ((s = status) >= 0)\n+            s = awaitDone((s & POOLSUBMIT) | INTERRUPTIBLE, 0L);\n@@ -1004,1 +1014,6 @@\n-        int s = awaitDone(null, false, true, true, nanos);\n+        int s;\n+        if (Thread.interrupted())\n+            s = ABNORMAL;\n+        else if ((s = status) >= 0 && nanos > 0L)\n+            s = awaitDone((s & POOLSUBMIT) | INTERRUPTIBLE | TIMED,\n+                          nanos + System.nanoTime());\n@@ -1017,2 +1032,3 @@\n-        if (status >= 0)\n-            awaitDone(null, false, false, false, 0L);\n+        int s;\n+        if ((s = status) >= 0)\n+            awaitDone(s & POOLSUBMIT, 0L);\n@@ -1021,1 +1037,0 @@\n-\n@@ -1028,2 +1043,3 @@\n-        if (doExec() >= 0)\n-            awaitDone(null, true, false, false, 0L);\n+        int s;\n+        if ((s = doExec()) >= 0)\n+            awaitDone(RAN, 0L);\n@@ -1032,21 +1048,25 @@\n-    \/\/ Versions of join\/get for pool.invoke* methods that use external,\n-    \/\/ possibly-non-commonPool submits\n-\n-    final void awaitPoolInvoke(ForkJoinPool pool) {\n-        awaitDone(pool, false, false, false, 0L);\n-    }\n-    final void awaitPoolInvoke(ForkJoinPool pool, long nanos) {\n-        awaitDone(pool, false, true, true, nanos);\n-    }\n-    final V joinForPoolInvoke(ForkJoinPool pool) {\n-        int s = awaitDone(pool, false, false, false, 0L);\n-        if ((s & ABNORMAL) != 0)\n-            reportException(s);\n-        return getRawResult();\n-    }\n-    final V getForPoolInvoke(ForkJoinPool pool)\n-        throws InterruptedException, ExecutionException {\n-        int s = awaitDone(pool, false, true, false, 0L);\n-        if ((s & ABNORMAL) != 0)\n-            reportExecutionException(s);\n-        return getRawResult();\n+    \/**\n+     * Tries to join this task, returning true if it completed\n+     * (possibly exceptionally) before the given timeout and\n+     * the current thread has not been interrupted.\n+     *\n+     * @param timeout the maximum time to wait\n+     * @param unit the time unit of the timeout argument\n+     * @return true if this task completed\n+     * @throws InterruptedException if the current thread was\n+     * interrupted while waiting\n+     * @since 19\n+     *\/\n+    public final boolean quietlyJoin(long timeout, TimeUnit unit)\n+        throws InterruptedException {\n+        int s;\n+        long nanos = unit.toNanos(timeout);\n+        if (Thread.interrupted())\n+            s = ABNORMAL;\n+        else if ((s = status) >= 0 && nanos > 0L)\n+            s = awaitDone((s & POOLSUBMIT) | INTERRUPTIBLE | TIMED,\n+                          nanos + System.nanoTime());\n+        if (s == ABNORMAL)\n+            throw new InterruptedException();\n+        else\n+            return (s < 0);\n@@ -1054,6 +1074,17 @@\n-    final V getForPoolInvoke(ForkJoinPool pool, long nanos)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-        int s = awaitDone(pool, false, true, true, nanos);\n-        if (s >= 0 || (s & ABNORMAL) != 0)\n-            reportExecutionException(s);\n-        return getRawResult();\n+\n+    \/**\n+     * Tries to join this task, returning true if it completed\n+     * (possibly exceptionally) before the given timeout.\n+     *\n+     * @param timeout the maximum time to wait\n+     * @param unit the time unit of the timeout argument\n+     * @return true if this task completed\n+     * @since 19\n+     *\/\n+    public final boolean quietlyJoinUninterruptibly(long timeout,\n+                                                    TimeUnit unit) {\n+        int s;\n+        long nanos = unit.toNanos(timeout);\n+        if ((s = status) >= 0 && nanos > 0L)\n+            s = awaitDone((s & POOLSUBMIT) | TIMED, nanos + System.nanoTime());\n+        return (s < 0);\n@@ -1070,6 +1101,1 @@\n-        Thread t; ForkJoinWorkerThread w; ForkJoinPool p;\n-        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread &&\n-            (p = (w = (ForkJoinWorkerThread)t).pool) != null)\n-            p.helpQuiescePool(w.workQueue, Long.MAX_VALUE, false);\n-        else\n-            ForkJoinPool.common.externalHelpQuiescePool(Long.MAX_VALUE, false);\n+        ForkJoinPool.helpQuiescePool(null, Long.MAX_VALUE, false);\n@@ -1137,6 +1163,6 @@\n-        Thread t; ForkJoinPool.WorkQueue q;\n-        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n-            ? (q = ((ForkJoinWorkerThread)t).workQueue) != null\n-               && q.tryUnpush(this)\n-            : (q = ForkJoinPool.commonQueue()) != null\n-               && q.externalTryUnpush(this);\n+        Thread t; ForkJoinPool.WorkQueue q; boolean owned;\n+        if (owned = (t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n+            q = ((ForkJoinWorkerThread)t).workQueue;\n+        else\n+            q = ForkJoinPool.commonQueue();\n+        return (q != null && q.tryUnpush(this, owned));\n@@ -1544,1 +1570,1 @@\n-     * @since 17\n+     * @since 19\n@@ -1546,3 +1572,2 @@\n-    \/\/ adaptInterruptible deferred to its own independent change\n-    \/\/ https:\/\/bugs.openjdk.java.net\/browse\/JDK-8246587\n-    \/* TODO: public *\/ private static <T> ForkJoinTask<T> adaptInterruptible(Callable<? extends T> callable) {\n+    public static <T> ForkJoinTask<T> adaptInterruptible(Callable<? extends T> callable) {\n+        \/\/ https:\/\/bugs.openjdk.java.net\/browse\/JDK-8246587\n@@ -1587,7 +1612,5 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            STATUS = l.findVarHandle(ForkJoinTask.class, \"status\", int.class);\n-            AUX = l.findVarHandle(ForkJoinTask.class, \"aux\", Aux.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n+        U = Unsafe.getUnsafe();\n+        STATUS = U.objectFieldOffset(ForkJoinTask.class, \"status\");\n+        AUX = U.objectFieldOffset(ForkJoinTask.class, \"aux\");\n+        Class<?> dep1 = LockSupport.class; \/\/ ensure loaded\n+        Class<?> dep2 = Aux.class;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":208,"deletions":185,"binary":false,"changes":393,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.security.AccessControlContext;\n@@ -40,0 +41,1 @@\n+import java.security.ProtectionDomain;\n@@ -73,2 +75,3 @@\n-                         boolean useSystemClassLoader, boolean isInnocuous) {\n-        super(group, null, pool.nextWorkerThreadName(), 0L);\n+                         boolean useSystemClassLoader,\n+                         boolean clearThreadLocals) {\n+        super(group, null, pool.nextWorkerThreadName(), 0L, !clearThreadLocals);\n@@ -76,1 +79,3 @@\n-        this.workQueue = new ForkJoinPool.WorkQueue(this, isInnocuous);\n+        this.workQueue = new ForkJoinPool.WorkQueue(this, 0);\n+        if (clearThreadLocals)\n+            workQueue.setClearThreadLocals();\n@@ -86,1 +91,1 @@\n-     * pool.\n+     * pool, and with the given policy for preserving ThreadLocals.\n@@ -88,1 +93,4 @@\n-     * @param group if non-null, the thread group for this thread\n+     * @param group if non-null, the thread group for this\n+     * thread. Otherwise, the thread group is chosen by the security\n+     * manager if present, else set to the current thread's thread\n+     * group.\n@@ -90,0 +98,2 @@\n+     * @param preserveThreadLocals if true, always preserve the values of\n+     * ThreadLocal variables across tasks; otherwise they may be cleared.\n@@ -91,0 +101,1 @@\n+     * @since 19\n@@ -92,2 +103,3 @@\n-    \/* TODO: protected *\/ ForkJoinWorkerThread(ThreadGroup group, ForkJoinPool pool) {\n-        this(group, pool, false, false);\n+    protected ForkJoinWorkerThread(ThreadGroup group, ForkJoinPool pool,\n+                                   boolean preserveThreadLocals) {\n+        this(group, pool, false, !preserveThreadLocals);\n@@ -184,1 +196,1 @@\n-     * thread context class loader, and erases all ThreadLocals after\n+     * thread context class loader, and clears all ThreadLocals after\n@@ -189,0 +201,1 @@\n+        private static final ThreadGroup innocuousThreadGroup;\n@@ -190,10 +203,1 @@\n-        private static final ThreadGroup innocuousThreadGroup =\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public ThreadGroup run() {\n-                    ThreadGroup group = Thread.currentThread().getThreadGroup();\n-                    for (ThreadGroup p; (p = group.getParent()) != null; )\n-                        group = p;\n-                    return new ThreadGroup(\n-                        group, \"InnocuousForkJoinWorkerThreadGroup\");\n-                }});\n-\n+        private static final AccessControlContext innocuousACC;\n@@ -204,0 +208,6 @@\n+        @Override @SuppressWarnings(\"removal\")\n+        protected void onStart() {\n+            Thread t = Thread.currentThread();\n+            ThreadLocalRandom.setInheritedAccessControlContext(t, innocuousACC);\n+        }\n+\n@@ -212,0 +222,28 @@\n+\n+        @SuppressWarnings(\"removal\")\n+        static AccessControlContext createACC() {\n+            return new AccessControlContext(\n+                new ProtectionDomain[] { new ProtectionDomain(null, null) });\n+        }\n+        static ThreadGroup createGroup() {\n+            ThreadGroup group = Thread.currentThread().getThreadGroup();\n+            for (ThreadGroup p; (p = group.getParent()) != null; )\n+                group = p;\n+            return new ThreadGroup(group, \"InnocuousForkJoinWorkerThreadGroup\");\n+        }\n+        static {\n+            @SuppressWarnings(\"removal\")\n+            SecurityManager sm = System.getSecurityManager();\n+            @SuppressWarnings(\"removal\")\n+            ThreadGroup g = innocuousThreadGroup =\n+                (sm == null) ? createGroup() :\n+                AccessController.doPrivileged(new PrivilegedAction<>() {\n+                        public ThreadGroup run() {\n+                            return createGroup(); }});\n+            @SuppressWarnings(\"removal\")\n+            AccessControlContext a = innocuousACC =\n+                (sm == null) ? createACC() :\n+                AccessController.doPrivileged(new PrivilegedAction<>() {\n+                        public AccessControlContext run() {\n+                            return createACC(); }});\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":56,"deletions":18,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -164,0 +164,139 @@\n+\n+    \/**\n+     * Returns the computed result, without waiting.\n+     *\n+     * <p> This method is for cases where the caller knows that the task has\n+     * already completed successfully, for example when filtering a stream\n+     * of Future objects for the successful tasks and using a mapping\n+     * operation to obtain a stream of results.\n+     * {@snippet lang=java :\n+     *     results = futures.stream()\n+     *                .filter(f -> f.state() == Future.State.SUCCESS)\n+     *                .map(Future::resultNow)\n+     *                .toList();\n+     * }\n+     *\n+     * @implSpec\n+     * The default implementation invokes {@code isDone()} to test if the task\n+     * has completed. If done, it invokes {@code get()} to obtain the result.\n+     *\n+     * @return the computed result\n+     * @throws IllegalStateException if the task has not completed or the task\n+     * did not complete with a result\n+     * @since 19\n+     *\/\n+    default V resultNow() {\n+        if (!isDone())\n+            throw new IllegalStateException(\"Task has not completed\");\n+        boolean interrupted = false;\n+        try {\n+            while (true) {\n+                try {\n+                    return get();\n+                } catch (InterruptedException e) {\n+                    interrupted = true;\n+                } catch (ExecutionException e) {\n+                    throw new IllegalStateException(\"Task completed with exception\");\n+                } catch (CancellationException e) {\n+                    throw new IllegalStateException(\"Task was cancelled\");\n+                }\n+            }\n+        } finally {\n+            if (interrupted) Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the exception thrown by the task, without waiting.\n+     *\n+     * <p> This method is for cases where the caller knows that the task\n+     * has already completed with an exception.\n+     *\n+     * @implSpec\n+     * The default implementation invokes {@code isDone()} to test if the task\n+     * has completed. If done and not cancelled, it invokes {@code get()} and\n+     * catches the {@code ExecutionException} to obtain the exception.\n+     *\n+     * @return the exception thrown by the task\n+     * @throws IllegalStateException if the task has not completed, the task\n+     * completed normally, or the task was cancelled\n+     * @since 19\n+     *\/\n+    default Throwable exceptionNow() {\n+        if (!isDone())\n+            throw new IllegalStateException(\"Task has not completed\");\n+        if (isCancelled())\n+            throw new IllegalStateException(\"Task was cancelled\");\n+        boolean interrupted = false;\n+        try {\n+            while (true) {\n+                try {\n+                    get();\n+                    throw new IllegalStateException(\"Task completed with a result\");\n+                } catch (InterruptedException e) {\n+                    interrupted = true;\n+                } catch (ExecutionException e) {\n+                    return e.getCause();\n+                }\n+            }\n+        } finally {\n+            if (interrupted) Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    \/**\n+     * Represents the computation state.\n+     * @since 19\n+     *\/\n+    enum State {\n+        \/**\n+         * The task has not completed.\n+         *\/\n+        RUNNING,\n+        \/**\n+         * The task completed with a result.\n+         * @see Future#resultNow()\n+         *\/\n+        SUCCESS,\n+        \/**\n+         * The task completed with an exception.\n+         * @see Future#exceptionNow()\n+         *\/\n+        FAILED,\n+        \/**\n+         * The task was cancelled.\n+         * @see #cancel(boolean)\n+         *\/\n+        CANCELLED\n+    }\n+\n+    \/**\n+     * {@return the computation state}\n+     *\n+     * @implSpec\n+     * The default implementation uses {@code isDone()}, {@code isCancelled()},\n+     * and {@code get()} to determine the state.\n+     *\n+     * @since 19\n+     *\/\n+    default State state() {\n+        if (!isDone())\n+            return State.RUNNING;\n+        if (isCancelled())\n+            return State.CANCELLED;\n+        boolean interrupted = false;\n+        try {\n+            while (true) {\n+                try {\n+                    get();  \/\/ may throw InterruptedException when done\n+                    return State.SUCCESS;\n+                } catch (InterruptedException e) {\n+                    interrupted = true;\n+                } catch (ExecutionException e) {\n+                    return State.FAILED;\n+                }\n+            }\n+        } finally {\n+            if (interrupted) Thread.currentThread().interrupt();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Future.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -208,0 +208,53 @@\n+    @Override\n+    public V resultNow() {\n+        switch (state()) {    \/\/ Future.State\n+            case SUCCESS:\n+                @SuppressWarnings(\"unchecked\")\n+                V result = (V) outcome;\n+                return result;\n+            case FAILED:\n+                throw new IllegalStateException(\"Task completed with exception\");\n+            case CANCELLED:\n+                throw new IllegalStateException(\"Task was cancelled\");\n+            default:\n+                throw new IllegalStateException(\"Task has not completed\");\n+        }\n+    }\n+\n+    @Override\n+    public Throwable exceptionNow() {\n+        switch (state()) {    \/\/ Future.State\n+            case SUCCESS:\n+                throw new IllegalStateException(\"Task completed with a result\");\n+            case FAILED:\n+                Object x = outcome;\n+                return (Throwable) x;\n+            case CANCELLED:\n+                throw new IllegalStateException(\"Task was cancelled\");\n+            default:\n+                throw new IllegalStateException(\"Task has not completed\");\n+        }\n+    }\n+\n+    @Override\n+    public State state() {\n+        int s = state;\n+        while (s == COMPLETING) {\n+            \/\/ waiting for transition to NORMAL or EXCEPTIONAL\n+            Thread.yield();\n+            s = state;\n+        }\n+        switch (s) {\n+            case NORMAL:\n+                return State.SUCCESS;\n+            case EXCEPTIONAL:\n+                return State.FAILED;\n+            case CANCELLED:\n+            case INTERRUPTING:\n+            case INTERRUPTED:\n+                return State.CANCELLED;\n+            default:\n+                return State.RUNNING;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/FutureTask.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * <p>For a classic example, here is a task computing Fibonacci numbers:\n+ * <p>For example, here is a task-based program for computing Factorials:\n@@ -44,10 +44,26 @@\n- * class Fibonacci extends RecursiveTask<Integer> {\n- *   final int n;\n- *   Fibonacci(int n) { this.n = n; }\n- *   protected Integer compute() {\n- *     if (n <= 1)\n- *       return n;\n- *     Fibonacci f1 = new Fibonacci(n - 1);\n- *     f1.fork();\n- *     Fibonacci f2 = new Fibonacci(n - 2);\n- *     return f2.compute() + f1.join();\n+ * import java.util.concurrent.RecursiveTask;\n+ * import java.math.BigInteger;\n+ * public class Factorial {\n+ *   static class FactorialTask extends RecursiveTask<BigInteger> {\n+ *     private final int from, to;\n+ *     FactorialTask(int from, int to) { this.from = from; this.to = to; }\n+ *     protected BigInteger compute() {\n+ *       int range = to - from;\n+ *       if (range == 0) {                       \/\/ base case\n+ *         return BigInteger.valueOf(from);\n+ *       } else if (range == 1) {                \/\/ too small to parallelize\n+ *         return BigInteger.valueOf(from).multiply(BigInteger.valueOf(to));\n+ *       } else {                                \/\/ split in half\n+ *         int mid = from + range \/ 2;\n+ *         FactorialTask leftTask = new FactorialTask(from, mid);\n+ *         leftTask.fork();         \/\/ perform about half the work locally\n+ *         return new FactorialTask(mid + 1, to).compute()\n+ *                .multiply(leftTask.join());\n+ *       }\n+ *     }\n+ *   }\n+ *   static BigInteger factorial(int n) { \/\/ uses ForkJoinPool.commonPool()\n+ *     return (n <= 1) ? BigInteger.ONE : new FactorialTask(1, n).invoke();\n+ *   }\n+ *   public static void main(String[] args) {\n+ *     System.out.println(factorial(Integer.parseInt(args[0])));\n@@ -57,8 +73,0 @@\n- * However, besides being a dumb way to compute Fibonacci functions\n- * (there is a simple fast linear algorithm that you'd use in\n- * practice), this is likely to perform poorly because the smallest\n- * subtasks are too small to be worthwhile splitting up. Instead, as\n- * is the case for nearly all fork\/join applications, you'd pick some\n- * minimum granularity size (for example 10 here) for which you always\n- * sequentially solve rather than subdividing.\n- *\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/RecursiveTask.java","additions":27,"deletions":19,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1159,1 +1159,3 @@\n-            return node != null && node.prev != null && isEnqueued(node);\n+            Node p; \/\/ traverse unless known to be bidirectionally linked\n+            return node != null && (p = node.prev) != null &&\n+                (p.next == node || isEnqueued(node));\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1527,1 +1527,3 @@\n-            return node != null && node.prev != null && isEnqueued(node);\n+            Node p; \/\/ traverse unless known to be bidirectionally linked\n+            return node != null && (p = node.prev) != null &&\n+                (p.next == node || isEnqueued(node));\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,2 @@\n+ * <li>{@code EMASK} &mdash; the bit mask of the operand type, where {@code EMASK=(1<<(ESIZE*8))-1}\n+ *\n@@ -551,1 +553,1 @@\n-    \/** Produce {@code a>>>(n&(ESIZE*8-1))}.  Integral only. *\/\n+    \/** Produce {@code (a&EMASK)>>>(n&(ESIZE*8-1))}.  Integral only. *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  assert(_n_snapshots > 0, \"non-null array should have at least 1 element\");\n+  ASSERT_GT(_n_snapshots, size_t(0)) << \"non-null array should have at least 1 element\";\n","filename":"test\/hotspot\/gtest\/logging\/logTestFixture.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  assert(!file_exists(name), \"can't create directory: %s already exists\", name);\n+  ASSERT_FALSE(file_exists(name)) << \"can't create directory: \" << name << \" already exists\";\n@@ -67,1 +67,1 @@\n-  assert(!failed, \"failed to create directory %s\", name);\n+  ASSERT_FALSE(failed) << \"failed to create directory \" << name;\n","filename":"test\/hotspot\/gtest\/logging\/logTestUtils.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -172,0 +172,13 @@\n+  \/\/ Generate sufficiently unique directory path and log spec for that path\n+  ss.print(\"%s%s%s%d\", os::get_temp_directory(), os::file_separator(), \"tmplogdir\", os::current_process_id());\n+  char* path = ss.as_string();\n+  ss.reset();\n+\n+  ss.print(\"%s%s\", \"file=\", path);\n+  char* log_spec = ss.as_string();\n+  ss.reset();\n+\n+  ss.print(\"%s is not a regular file\", path);\n+  char* expected_output_substring = ss.as_string();\n+  ss.reset();\n+\n@@ -173,2 +186,2 @@\n-  create_directory(\"tmplogdir\");\n-  LogFileOutput bad_file(\"file=tmplogdir\");\n+  create_directory(path);\n+  LogFileOutput bad_file(log_spec);\n@@ -177,3 +190,4 @@\n-  EXPECT_TRUE(string_contains_substring(ss.as_string(), \"tmplogdir is not a regular file\"))\n-    << \"missing expected error message, received msg: %s\" << ss.as_string();\n-  delete_empty_directory(\"tmplogdir\");\n+  char* logger_output = ss.as_string();\n+  EXPECT_TRUE(string_contains_substring(logger_output, expected_output_substring))\n+    << \"missing expected error message, received msg: %s\" << logger_output;\n+  delete_empty_directory(path);\n","filename":"test\/hotspot\/gtest\/logging\/test_logFileOutput.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test ClearArray.java\n+ * @bug 8284883\n+ * @compile ClearArray.java\n+ * @summary ClearArray instruction overflows scratch buffer\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -Xbatch\n+ *   -XX:InitArrayShortSize=32768 -XX:-IdealizeClearArrayNode compiler.c2.ClearArray\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation -Xbatch\n+ *   -XX:InitArrayShortSize=32768 -XX:-IdealizeClearArrayNode -XX:UseAVX=3 compiler.c2.ClearArray\n+ *\/\n+\n+package compiler.c2;\n+\n+public class ClearArray {\n+\n+    static long[] STATIC;\n+\n+    static void foo() {\n+        STATIC = new long[2048 - 1];\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; ++i) {\n+            foo();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/ClearArray.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8284981\n+ * @summary Auto-vectorization enhancement for special counting down loops\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestAutoVecCountingDownLoop\n+ *\/\n+\n+public class TestAutoVecCountingDownLoop {\n+    final private static int ARRLEN = 3000;\n+\n+    private static int[] a = new int[ARRLEN];\n+    private static int[] b = new int[ARRLEN];\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testCountingDown(int[] a, int[] b) {\n+        for (int i = 2000; i > 0; i--) {\n+            b[ARRLEN - i] = a[ARRLEN - i];\n+        }\n+    }\n+\n+    @Run(test = \"testCountingDown\")\n+    private void testCountingDown_runner() {\n+        testCountingDown(a, b);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAutoVecCountingDownLoop.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,1 @@\n+      test_cp_countingdown(a1, a2);\n@@ -555,0 +556,4 @@\n+      test_cp_countingdown(a1, a2);\n+      for (int i = 500; i > 0; i--) {\n+        errn += verify(\"test_cp_countingdown: a2\", ARRLEN - i, a2[ARRLEN - i], a1[ARRLEN - i]);\n+      }\n@@ -840,0 +845,6 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_cp_countingdown(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_cp_countingdown: \" + (end - start));\n@@ -1098,1 +1109,5 @@\n-\n+  static void test_cp_countingdown(int[] a, int[] b) {\n+    for (int i = 500; i > 0; i--) {\n+      b[ARRLEN - i] = a[ARRLEN - i];\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntVect.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -34,1 +36,3 @@\n- *      -XX:-UseGCOverheadLimit\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI\n@@ -44,0 +48,2 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n@@ -45,1 +51,0 @@\n-import nsk.share.gc.Algorithms;\n@@ -48,2 +53,0 @@\n-import nsk.share.gc.gp.GarbageProducer;\n-import nsk.share.gc.gp.GarbageUtils;\n@@ -90,1 +93,0 @@\n-        GarbageProducer gp = GarbageUtils.getArrayProducers().get(0);\n@@ -101,15 +103,10 @@\n-                try {\n-                    refq = new ReferenceQueue();\n-                    alive = new int[3];\n-                    wrong = new int[3];\n-                    for (int j = 0; j < RANGE; j++) {\n-                        holder[j] = new CircularLinkedList();\n-                        holder[j].addNelements(300);\n-                        wr[j] = new WeakReference(holder[j], refq);\n-                        sr[j] = new SoftReference(holder[j], refq);\n-                        phr[j] = new PhantomReference(holder[j], refq);\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                    \/\/ we should just skip the test\n-                    \/\/ the other thread could eat all memory\n-                    continue;\n+\n+                refq = new ReferenceQueue();\n+                alive = new int[3];\n+                wrong = new int[3];\n+                for (int j = 0; j < RANGE; j++) {\n+                    holder[j] = new CircularLinkedList();\n+                    holder[j].addNelements(300);\n+                    wr[j] = new WeakReference(holder[j], refq);\n+                    sr[j] = new SoftReference(holder[j], refq);\n+                    phr[j] = new PhantomReference(holder[j], refq);\n@@ -137,1 +134,2 @@\n-                Algorithms.eatMemory(stresser);\n+                \/\/ WB.fullGC() is guaranteed to clear all kinds of weak references.\n+                WhiteBox.getWhiteBox().fullGC();\n@@ -141,2 +139,0 @@\n-                \/\/ At this point OOME was thrown and accordingly to spec\n-                \/\/ all weak refs should be processed\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/ReferencesGC\/ReferencesGC.java","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,495 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, the following notice accompanied the original version of this\n+ * file:\n+ *\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group and released to the public domain, as explained at\n+ * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n+ *\/\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+import java.util.HashSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountedCompleter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinTask;\n+import java.util.concurrent.RecursiveAction;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.Callable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+\/**\n+ * Tests for ForkJoinPool and corresponding ForkJoinTask additions.\n+ *\/\n+public class ForkJoinPool19Test extends JSR166TestCase {\n+    public static void main(String[] args) {\n+        main(suite(), args);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(ForkJoinPool8Test.class);\n+    }\n+\n+    \/**\n+     * SetParallelism sets reported parallellism and returns previous value\n+     *\/\n+    public void testSetParallelism() {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        assertEquals(2, p.getParallelism());\n+        assertEquals(2, p.setParallelism(3));\n+        assertEquals(3, p.setParallelism(2));\n+        p.shutdown();\n+    }\n+    \/**\n+     * SetParallelism throws exception if argument out of bounds\n+     *\/\n+    public void testSetParallelismBadArgs() {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try {\n+            p.setParallelism(0);\n+            shouldThrow();\n+        } catch (Exception success) {\n+        }\n+        try {\n+            p.setParallelism(Integer.MAX_VALUE);\n+            shouldThrow();\n+        } catch (Exception success) {\n+        }\n+        assertEquals(2, p.getParallelism());\n+        p.shutdown();\n+    }\n+\n+\n+    \/*\n+     * Some test methods adapted from RecursiveAction\n+     *\/\n+    private static ForkJoinPool mainPool() {\n+        return new ForkJoinPool();\n+    }\n+\n+    private void testInvokeOnPool(ForkJoinPool pool, RecursiveAction a) {\n+        try (PoolCleaner cleaner = cleaner(pool)) {\n+            checkNotDone(a);\n+            assertNull(pool.invoke(a));\n+            checkCompletedNormally(a);\n+        }\n+    }\n+\n+    private void checkInvoke(ForkJoinTask<?> a) {\n+        checkNotDone(a);\n+        assertNull(a.invoke());\n+        checkCompletedNormally(a);\n+    }\n+\n+    void checkNotDone(ForkJoinTask<?> a) {\n+        assertFalse(a.isDone());\n+        assertFalse(a.isCompletedNormally());\n+        assertFalse(a.isCompletedAbnormally());\n+        assertFalse(a.isCancelled());\n+        assertNull(a.getException());\n+        assertNull(a.getRawResult());\n+\n+        if (! ForkJoinTask.inForkJoinPool()) {\n+            Thread.currentThread().interrupt();\n+            try {\n+                a.get();\n+                shouldThrow();\n+            } catch (InterruptedException success) {\n+            } catch (Throwable fail) { threadUnexpectedException(fail); }\n+\n+            Thread.currentThread().interrupt();\n+            try {\n+                a.get(randomTimeout(), randomTimeUnit());\n+                shouldThrow();\n+            } catch (InterruptedException success) {\n+            } catch (Throwable fail) { threadUnexpectedException(fail); }\n+        }\n+\n+        try {\n+            a.get(randomExpiredTimeout(), randomTimeUnit());\n+            shouldThrow();\n+        } catch (TimeoutException success) {\n+        } catch (Throwable fail) { threadUnexpectedException(fail); }\n+    }\n+\n+    void checkCompletedNormally(ForkJoinTask<?> a) {\n+        assertTrue(a.isDone());\n+        assertFalse(a.isCancelled());\n+        assertTrue(a.isCompletedNormally());\n+        assertFalse(a.isCompletedAbnormally());\n+        assertNull(a.getException());\n+        assertNull(a.getRawResult());\n+        assertNull(a.join());\n+        assertFalse(a.cancel(false));\n+        assertFalse(a.cancel(true));\n+\n+        Object v1 = null, v2 = null;\n+        try {\n+            v1 = a.get();\n+            v2 = a.get(randomTimeout(), randomTimeUnit());\n+        } catch (Throwable fail) { threadUnexpectedException(fail); }\n+        assertNull(v1);\n+        assertNull(v2);\n+    }\n+\n+    void checkCancelled(ForkJoinTask<?> a) {\n+        assertTrue(a.isDone());\n+        assertTrue(a.isCancelled());\n+        assertFalse(a.isCompletedNormally());\n+        assertTrue(a.isCompletedAbnormally());\n+        assertTrue(a.getException() instanceof CancellationException);\n+        assertNull(a.getRawResult());\n+\n+        try {\n+            a.join();\n+            shouldThrow();\n+        } catch (CancellationException success) {\n+        } catch (Throwable fail) { threadUnexpectedException(fail); }\n+\n+        try {\n+            a.get();\n+            shouldThrow();\n+        } catch (CancellationException success) {\n+        } catch (Throwable fail) { threadUnexpectedException(fail); }\n+\n+        try {\n+            a.get(randomTimeout(), randomTimeUnit());\n+            shouldThrow();\n+        } catch (CancellationException success) {\n+        } catch (Throwable fail) { threadUnexpectedException(fail); }\n+    }\n+\n+    void checkCompletedAbnormally(ForkJoinTask<?> a, Throwable t) {\n+        assertTrue(a.isDone());\n+        assertFalse(a.isCancelled());\n+        assertFalse(a.isCompletedNormally());\n+        assertTrue(a.isCompletedAbnormally());\n+        assertSame(t.getClass(), a.getException().getClass());\n+        assertNull(a.getRawResult());\n+        assertFalse(a.cancel(false));\n+        assertFalse(a.cancel(true));\n+\n+        try {\n+            a.join();\n+            shouldThrow();\n+        } catch (Throwable expected) {\n+            assertSame(expected.getClass(), t.getClass());\n+        }\n+\n+        try {\n+            a.get();\n+            shouldThrow();\n+        } catch (ExecutionException success) {\n+            assertSame(t.getClass(), success.getCause().getClass());\n+        } catch (Throwable fail) { threadUnexpectedException(fail); }\n+\n+        try {\n+            a.get(randomTimeout(), randomTimeUnit());\n+            shouldThrow();\n+        } catch (ExecutionException success) {\n+            assertSame(t.getClass(), success.getCause().getClass());\n+        } catch (Throwable fail) { threadUnexpectedException(fail); }\n+    }\n+\n+    public static final class FJException extends RuntimeException {\n+        public FJException() { super(); }\n+        public FJException(Throwable cause) { super(cause); }\n+    }\n+\n+    \/** A simple recursive action for testing. *\/\n+    final class FibAction extends CheckedRecursiveAction {\n+        final int number;\n+        int result;\n+        FibAction(int n) { number = n; }\n+        protected void realCompute() {\n+            int n = number;\n+            if (n <= 1)\n+                result = n;\n+            else {\n+                FibAction f1 = new FibAction(n - 1);\n+                FibAction f2 = new FibAction(n - 2);\n+                invokeAll(f1, f2);\n+                result = f1.result + f2.result;\n+            }\n+        }\n+    }\n+\n+    \/** A recursive action failing in base case. *\/\n+    static final class FailingFibAction extends RecursiveAction {\n+        final int number;\n+        int result;\n+        FailingFibAction(int n) { number = n; }\n+        public void compute() {\n+            int n = number;\n+            if (n <= 1)\n+                throw new FJException();\n+            else {\n+                FailingFibAction f1 = new FailingFibAction(n - 1);\n+                FailingFibAction f2 = new FailingFibAction(n - 2);\n+                invokeAll(f1, f2);\n+                result = f1.result + f2.result;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * lazySubmit submits a task that is not executed until new\n+     * workers are created or it is explicitly joined by a worker.\n+     *\/\n+    public void testLazySubmit() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() {\n+                final ForkJoinPool p = mainPool();\n+                FibAction f = new FibAction(8);\n+                p.lazySubmit(f);\n+                checkNotDone(f);\n+                FibAction g = new FibAction(8);\n+                p.submit(g);\n+                g.join();\n+                f.join();\n+                assertEquals(21, f.result);\n+                checkCompletedNormally(f);\n+            }};\n+        testInvokeOnPool(mainPool(), a);\n+    }\n+\n+    \/**\n+     * quietlyInvoke task returns when task completes normally.\n+     * isCompletedAbnormally and isCancelled return false for normally\n+     * completed tasks\n+     *\/\n+    public void testQuietlyInvoke() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() {\n+                FibAction f = new FibAction(8);\n+                f.quietlyInvoke();\n+                assertEquals(21, f.result);\n+                checkCompletedNormally(f);\n+            }};\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * join of a forked task returns when task completes\n+     *\/\n+    public void testForkJoin() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() {\n+                FibAction f = new FibAction(8);\n+                assertSame(f, f.fork());\n+                assertNull(f.join());\n+                assertEquals(21, f.result);\n+                checkCompletedNormally(f);\n+            }};\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * timed quietlyJoinUninterruptibly of a forked task succeeds in\n+     * the presence of interrupts\n+     *\/\n+    public void testTimedQuietlyJoinUninterruptiblyInterrupts() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() {\n+                FibAction f;\n+                final Thread currentThread = Thread.currentThread();\n+\n+                \/\/ test quietlyJoin()\n+                f = new FibAction(8);\n+                assertSame(f, f.fork());\n+                currentThread.interrupt();\n+                f.quietlyJoinUninterruptibly(LONG_DELAY_MS, MILLISECONDS);\n+                Thread.interrupted();\n+                assertEquals(21, f.result);\n+                checkCompletedNormally(f);\n+\n+                f = new FibAction(8);\n+                f.cancel(true);\n+                assertSame(f, f.fork());\n+                currentThread.interrupt();\n+                f.quietlyJoinUninterruptibly(LONG_DELAY_MS, MILLISECONDS);\n+                Thread.interrupted();\n+                checkCancelled(f);\n+\n+                f = new FibAction(8);\n+                f.completeExceptionally(new FJException());\n+                assertSame(f, f.fork());\n+                currentThread.interrupt();\n+                f.quietlyJoinUninterruptibly(LONG_DELAY_MS, MILLISECONDS);\n+                Thread.interrupted();\n+                checkCompletedAbnormally(f, f.getException());\n+            }};\n+        checkInvoke(a);\n+        a.reinitialize();\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * timed quietlyJoin throws IE in the presence of interrupts\n+     *\/\n+    public void testTimedQuietlyJoinInterrupts() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() {\n+                FibAction f;\n+                final Thread currentThread = Thread.currentThread();\n+\n+                f = new FibAction(8);\n+                assertSame(f, f.fork());\n+                currentThread.interrupt();\n+                try {\n+                    f.quietlyJoin(LONG_DELAY_MS, MILLISECONDS);\n+                } catch (InterruptedException success) {\n+                }\n+                Thread.interrupted();\n+                f.quietlyJoin();\n+\n+                f = new FibAction(8);\n+                f.cancel(true);\n+                assertSame(f, f.fork());\n+                currentThread.interrupt();\n+                try {\n+                    f.quietlyJoin(LONG_DELAY_MS, MILLISECONDS);\n+                } catch (InterruptedException success) {\n+                }\n+                f.quietlyJoin();\n+                checkCancelled(f);\n+            }};\n+        checkInvoke(a);\n+        a.reinitialize();\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * timed quietlyJoin of a forked task returns when task completes\n+     *\/\n+    public void testForkTimedQuietlyJoin() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() throws Exception {\n+                FibAction f = new FibAction(8);\n+                assertSame(f, f.fork());\n+                assertTrue(f.quietlyJoin(LONG_DELAY_MS, MILLISECONDS));\n+                assertEquals(21, f.result);\n+                checkCompletedNormally(f);\n+            }};\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * timed quietlyJoin with null time unit throws NPE\n+     *\/\n+    public void testForkTimedQuietlyJoinNPE() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() throws Exception {\n+                FibAction f = new FibAction(8);\n+                assertSame(f, f.fork());\n+                try {\n+                    f.quietlyJoin(randomTimeout(), null);\n+                    shouldThrow();\n+                } catch (NullPointerException success) {}\n+            }};\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * quietlyInvoke task returns when task completes abnormally\n+     *\/\n+    public void testAbnormalTimedQuietlyJoin() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() throws Exception {\n+                FailingFibAction f = new FailingFibAction(8);\n+                assertSame(f, f.fork());\n+                assertTrue(f.quietlyJoin(LONG_DELAY_MS, MILLISECONDS));\n+                assertTrue(f.getException() instanceof FJException);\n+                checkCompletedAbnormally(f, f.getException());\n+            }};\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * timed quietlyJoinUninterruptibly of a forked task returns when task completes\n+     *\/\n+    public void testForkTimedQuietlyJoinUninterruptibly() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() throws Exception {\n+                FibAction f = new FibAction(8);\n+                assertSame(f, f.fork());\n+                assertTrue(f.quietlyJoinUninterruptibly(LONG_DELAY_MS, MILLISECONDS));\n+                assertEquals(21, f.result);\n+                checkCompletedNormally(f);\n+            }};\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * timed quietlyJoinUninterruptibly with null time unit throws NPE\n+     *\/\n+    public void testForkTimedQuietlyJoinUninterruptiblyNPE() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() throws Exception {\n+                FibAction f = new FibAction(8);\n+                assertSame(f, f.fork());\n+                try {\n+                    f.quietlyJoinUninterruptibly(randomTimeout(), null);\n+                    shouldThrow();\n+                } catch (NullPointerException success) {}\n+            }};\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * quietlyInvoke task returns when task completes abnormally\n+     *\/\n+    public void testAbnormalTimedQuietlyJoinUninterruptibly() {\n+        RecursiveAction a = new CheckedRecursiveAction() {\n+            protected void realCompute() {\n+                FailingFibAction f = new FailingFibAction(8);\n+                assertSame(f, f.fork());\n+                assertTrue(f.quietlyJoinUninterruptibly(LONG_DELAY_MS, MILLISECONDS));\n+                assertTrue(f.getException() instanceof FJException);\n+                checkCompletedAbnormally(f, f.getException());\n+            }};\n+        checkInvoke(a);\n+    }\n+\n+    \/**\n+     * adaptInterruptible(callable).toString() contains toString of wrapped task\n+     *\/\n+    public void testAdaptInterruptible_Callable_toString() {\n+        if (testImplementationDetails) {\n+            Callable<String> c = () -> \"\";\n+            ForkJoinTask<String> task = ForkJoinTask.adaptInterruptible(c);\n+            assertEquals(\n+                identityString(task) + \"[Wrapped task = \" + c.toString() + \"]\",\n+                task.toString());\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool19Test.java","additions":495,"deletions":0,"binary":false,"changes":495,"status":"added"},{"patch":"@@ -228,0 +228,1 @@\n+    \/\/ No longer run with custom securityManagers\n@@ -229,1 +230,1 @@\n-        Boolean.getBoolean(\"jsr166.useSecurityManager\");\n+    Boolean.getBoolean(\"jsr166.useSecurityManager\");\n@@ -440,0 +441,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -444,1 +446,4 @@\n-            System.setSecurityManager(new SecurityManager());\n+            try {\n+                System.setSecurityManager(new SecurityManager());\n+            } catch(Throwable ok) {  \/\/ failure OK during deprecation\n+            }\n@@ -485,1 +490,2 @@\n-            JAVA_CLASS_VERSION = java.security.AccessController.doPrivileged(\n+            @SuppressWarnings(\"removal\") double jcv =\n+            java.security.AccessController.doPrivileged(\n@@ -489,1 +495,3 @@\n-            JAVA_SPECIFICATION_VERSION = java.security.AccessController.doPrivileged(\n+            JAVA_CLASS_VERSION = jcv;\n+            @SuppressWarnings(\"removal\") String jsv =\n+            java.security.AccessController.doPrivileged(\n@@ -493,0 +501,1 @@\n+            JAVA_SPECIFICATION_VERSION = jsv;\n@@ -629,0 +638,6 @@\n+        if (atLeastJava17()) {\n+            String[] java17TestClassNames = {\n+                \"ForkJoinPool19Test\",\n+            };\n+            addNamedTestClasses(suite, java17TestClassNames);\n+        }\n@@ -1087,1 +1102,1 @@\n-            if (!pool.awaitTermination(2 * LONG_DELAY_MS, MILLISECONDS)) {\n+            if (!pool.awaitTermination(20 * LONG_DELAY_MS, MILLISECONDS)) {\n@@ -1171,0 +1186,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1379,3 +1395,1 @@\n-        Item[] items = defaultItems;\n-        Item x = (i >= 0 && i < items.length) ? items[i] : new Item(i);\n-        assertFalse(c.remove(x));\n+        assertFalse(c.remove(itemFor(i)));\n@@ -1406,0 +1420,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1421,0 +1436,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1423,0 +1439,1 @@\n+        if (!useSecurityManager) return;\n@@ -1430,0 +1447,1 @@\n+            } catch (UnsupportedOperationException ok) {\n@@ -1431,2 +1449,5 @@\n-                System.setSecurityManager(null);\n-                Policy.setPolicy(savedPolicy);\n+                try {\n+                    System.setSecurityManager(null);\n+                    Policy.setPolicy(savedPolicy);\n+                } catch (Exception ok) {\n+                }\n@@ -1459,0 +1480,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1488,0 +1510,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import javax.swing.JButton;\n+import javax.swing.JDesktopPane;\n+import javax.swing.JFrame;\n+import javax.swing.JInternalFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 4202966\n+ * @key headful\n+ * @summary Wrong coordinates in events retargeted to subcomponents of\n+ *      JInternalFrame\n+ * @run main IntFrameCoord\n+ *\/\n+\n+public class IntFrameCoord {\n+    private static JFrame frame;\n+    private static JDesktopPane dt;\n+    private static JButton tf;\n+    private static volatile JButton b;\n+    private static JInternalFrame if1;\n+    private static JInternalFrame if2;\n+    private static boolean isFail;\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException, AWTException {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+\n+        SwingUtilities.invokeAndWait(IntFrameCoord::createGUI);\n+\n+        robot.delay(1000);\n+\n+        MouseListener mouseListener = new MouseAdapter() {\n+            public void mousePressed(MouseEvent e) {\n+                double height = b.getSize().getHeight();\n+                if (e.getY() >= height) {\n+                    isFail = true;\n+                } else {\n+                    isFail = false;\n+                }\n+            }\n+        };\n+\n+        b.addMouseListener(mouseListener);\n+\n+        robot.waitForIdle();\n+\n+        robot.mouseMove(if2.getLocationOnScreen().x + (if2.getWidth() \/ 2),\n+                if2.getLocationOnScreen().y + 10);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        robot.mouseMove(if1.getLocationOnScreen().x + (if1.getWidth() \/ 2),\n+                if1.getLocationOnScreen().y + 10);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        robot.mouseMove(b.getLocationOnScreen().x + (b.getWidth() \/ 2),\n+                b.getLocationOnScreen().y + (b.getHeight() \/ 2));\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        SwingUtilities.invokeAndWait(() -> frame.dispose());\n+\n+        if(isFail) {\n+            throw new RuntimeException(\"Mouse coordinates wrong in \" +\n+                    \"retargeted JInternalFrame\");\n+        }\n+    }\n+\n+    private static void createGUI() {\n+        frame = new JFrame();\n+        dt = new JDesktopPane();\n+        frame.setLayout(new BorderLayout());\n+        frame.add(BorderLayout.CENTER, dt);\n+\n+        if1 = new JInternalFrame(\"Click here second\", true, true, true, true);\n+        if1.setLayout(new BorderLayout());\n+\n+        tf = new JButton (\"ignore\");\n+        if1.add(tf, BorderLayout.NORTH);\n+\n+        tf = new JButton (\"ignore\");\n+        if1.add(tf, BorderLayout.CENTER);\n+\n+        if1.setBounds(300,0,300,100);\n+\n+        dt.add(if1);\n+\n+        if2 = new JInternalFrame(\"Click here first\", true, true, true, true);\n+        if2.setLayout(new BorderLayout());\n+\n+        tf = new JButton (\"ignore\");\n+        if2.add(tf, BorderLayout.NORTH);\n+\n+        b = new JButton (\"Click here third\");\n+        if2.add (b, BorderLayout.CENTER);\n+\n+        if2.setBounds(0,0,300,100);\n+\n+        dt.add(if2);\n+\n+        if1.setVisible(true);\n+        if2.setVisible(true);\n+\n+        frame.setLocationRelativeTo(null);\n+        frame.setTitle(\"test\");\n+        frame.setSize(500, 300);\n+        frame.setVisible(true);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/4202966\/IntFrameCoord.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.test.lib.Platform;\n@@ -60,0 +61,1 @@\n+        testJcmdPidVMinfo();\n@@ -167,0 +169,17 @@\n+    \/**\n+     * Sanity check for VM.info\n+     *\/\n+    private static void testJcmdPidVMinfo() throws Exception {\n+        OutputAnalyzer output = JcmdBase.jcmd(VM_ARGS, new String[] {\"VM.info\"});\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(Long.toString(ProcessTools.getProcessId()) + \":\");\n+\n+        \/\/ Should find the signal handler summary (except on Windows):\n+        if (!Platform.isWindows()) {\n+          output.shouldContain(\"Signal Handlers:\");\n+          \/\/ Should not find any of the possible signal handler modification warnings:\n+          output.shouldNotContain(\" handler modified!\"); \/\/ e.g. Warning: SIGILL handler modified!\n+          output.shouldNotContain(\"*** Handler was modified!\");\n+          output.shouldNotContain(\"*** Expected: \"); \/\/ e.g. *** Expected: javaSignalHandler in ...\n+        }\n+    }\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdSanity.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"}]}