{"files":[{"patch":"@@ -302,0 +302,1 @@\n+    VectorSet visited;\n@@ -304,1 +305,2 @@\n-    Node* result = expand_vbox_node_helper(vbox, vect, vec_box->box_type(), vec_box->vec_type());\n+    Node* result = expand_vbox_node_helper(vbox, vect, vec_box->box_type(),\n+                                           vec_box->vec_type(), visited);\n@@ -314,1 +316,23 @@\n-                                           const TypeVect* vect_type) {\n+                                           const TypeVect* vect_type,\n+                                           VectorSet &visited) {\n+  \/\/ JDK-8304948 shows an example that there may be a cycle in the graph.\n+  if (visited.test_set(vbox->_idx)) {\n+    assert(vbox->is_Phi(), \"should be phi\");\n+    return vbox; \/\/ already visited\n+  }\n+\n+  \/\/ Handle the case when the allocation input to VectorBoxNode is a Proj.\n+  \/\/ This is the normal case before expanding.\n+  if (vbox->is_Proj() && vbox->in(0)->Opcode() == Op_VectorBoxAllocate) {\n+    VectorBoxAllocateNode* vbox_alloc = static_cast<VectorBoxAllocateNode*>(vbox->in(0));\n+    return expand_vbox_alloc_node(vbox_alloc, vect, box_type, vect_type);\n+  }\n+\n+  \/\/ Handle the case when both the allocation input and vector input to\n+  \/\/ VectorBoxNode are Phi. This case is generated after the transformation of\n+  \/\/ Phi: Phi (VectorBox1 VectorBox2) => VectorBox (Phi1 Phi2).\n+  \/\/ With this optimization, the relative two allocation inputs of VectorBox1 and\n+  \/\/ VectorBox2 are gathered into Phi1 now. Similarly, the original vector\n+  \/\/ inputs of two VectorBox nodes are in Phi2.\n+  \/\/\n+  \/\/ See PhiNode::merge_through_phi in cfg.cpp for more details.\n@@ -317,1 +341,0 @@\n-    Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);\n@@ -319,2 +342,6 @@\n-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect->in(i), box_type, vect_type);\n-      new_phi->set_req(i, new_box);\n+      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect->in(i),\n+                                              box_type, vect_type, visited);\n+      if (!new_box->is_Phi()) {\n+        C->initial_gvn()->hash_delete(vbox);\n+        vbox->set_req(i, new_box);\n+      }\n@@ -322,11 +349,11 @@\n-    new_phi = C->initial_gvn()->transform(new_phi);\n-    return new_phi;\n-  } else if (vbox->is_Phi() && (vect->is_Vector() || vect->is_LoadVector())) {\n-    \/\/ Handle the case when the allocation input to VectorBoxNode is a phi\n-    \/\/ but the vector input is not, which can definitely be the case if the\n-    \/\/ vector input has been value-numbered. It seems to be safe to do by\n-    \/\/ construction because VectorBoxNode and VectorBoxAllocate come in a\n-    \/\/ specific order as a result of expanding an intrinsic call. After that, if\n-    \/\/ any of the inputs to VectorBoxNode are value-numbered they can only\n-    \/\/ move up and are guaranteed to dominate.\n-    Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);\n+    return C->initial_gvn()->transform(vbox);\n+  }\n+\n+  \/\/ Handle the case when the allocation input to VectorBoxNode is a phi\n+  \/\/ but the vector input is not, which can definitely be the case if the\n+  \/\/ vector input has been value-numbered. It seems to be safe to do by\n+  \/\/ construction because VectorBoxNode and VectorBoxAllocate come in a\n+  \/\/ specific order as a result of expanding an intrinsic call. After that, if\n+  \/\/ any of the inputs to VectorBoxNode are value-numbered they can only\n+  \/\/ move up and are guaranteed to dominate.\n+  if (vbox->is_Phi() && (vect->is_Vector() || vect->is_LoadVector())) {\n@@ -334,2 +361,6 @@\n-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect, box_type, vect_type);\n-      new_phi->set_req(i, new_box);\n+      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect,\n+                                              box_type, vect_type, visited);\n+      if (!new_box->is_Phi()) {\n+        C->initial_gvn()->hash_delete(vbox);\n+        vbox->set_req(i, new_box);\n+      }\n@@ -337,9 +368,1 @@\n-    new_phi = C->initial_gvn()->transform(new_phi);\n-    return new_phi;\n-  } else if (vbox->is_Proj() && vbox->in(0)->Opcode() == Op_VectorBoxAllocate) {\n-    VectorBoxAllocateNode* vbox_alloc = static_cast<VectorBoxAllocateNode*>(vbox->in(0));\n-    return expand_vbox_alloc_node(vbox_alloc, vect, box_type, vect_type);\n-  } else {\n-    assert(!vbox->is_Phi(), \"\");\n-    \/\/ TODO: assert that expanded vbox is initialized with the same value (vect).\n-    return vbox; \/\/ already expanded\n+    return C->initial_gvn()->transform(vbox);\n@@ -347,0 +370,4 @@\n+\n+  assert(!vbox->is_Phi(), \"should be expanded\");\n+  \/\/ TODO: assert that expanded vbox is initialized with the same value (vect).\n+  return vbox; \/\/ already expanded\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":54,"deletions":27,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,2 @@\n-                                const TypeVect* vect_type);\n+                                const TypeVect* vect_type,\n+                                VectorSet &visited);\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.IntVector;\n+\n+\/*\n+ * @test\n+ * @bug 8304948\n+ * @summary C2 crashes when expanding VectorBox\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -ea -XX:CompileCommand=dontinline,*VectorBoxExpandTest.test compiler.vectorapi.VectorBoxExpandTest\n+ *\/\n+public class VectorBoxExpandTest {\n+\n+    private static final int ARR_LEN = 1024;\n+    private static final int NUM_ITER = 2000;\n+\n+    private static int[] iarr = new int[ARR_LEN];\n+    private static IntVector g;\n+\n+    \/\/ C2 would generate IR graph like below:\n+    \/\/\n+    \/\/                ------------\n+    \/\/               \/            \\\n+    \/\/       Region |  VectorBox   |\n+    \/\/            \\ | \/            |\n+    \/\/             Phi             |\n+    \/\/              |              |\n+    \/\/              |              |\n+    \/\/       Region |  VectorBox   |\n+    \/\/            \\ | \/            |\n+    \/\/             Phi             |\n+    \/\/              |              |\n+    \/\/              |\\------------\/\n+    \/\/              |\n+    \/\/\n+    \/\/\n+    \/\/ which would be optimized by merge_through_phi through Phi::Ideal and some\n+    \/\/ other transformations. Finally C2 would expand VectorBox on a graph like\n+    \/\/ below:\n+    \/\/\n+    \/\/                ------------\n+    \/\/               \/            \\\n+    \/\/       Region |  Proj        |\n+    \/\/            \\ | \/            |\n+    \/\/             Phi             |\n+    \/\/              |              |\n+    \/\/              |              |\n+    \/\/       Region |  Proj        |\n+    \/\/            \\ | \/            |\n+    \/\/             Phi             |\n+    \/\/              |              |\n+    \/\/              |\\------------\/\n+    \/\/              |\n+    \/\/              |      Phi\n+    \/\/              |     \/\n+    \/\/           VectorBox\n+    \/\/\n+    \/\/ where the cycle case should be taken into consideration as well.\n+    private static void test() {\n+        IntVector a = IntVector.fromArray(IntVector.SPECIES_PREFERRED, iarr, 0);\n+\n+        for (int ic = 0; ic < NUM_ITER; ic++) {\n+            for (int i = 0; i < iarr.length; i++) {\n+                a = a.add(a);\n+            }\n+        }\n+        g = a;\n+    }\n+\n+    public static void main(String[] args) {\n+        test();\n+        System.out.println(\"PASS\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorBoxExpandTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"}]}