{"files":[{"patch":"@@ -28,1 +28,1 @@\n- * @build AsyncExceptionOnMonitorEnter\n+ * @library \/test\/hotspot\/jtreg\/testlibrary\n@@ -33,0 +33,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -40,0 +42,1 @@\n+    public static native int stopThread(Thread thread);\n@@ -145,1 +148,1 @@\n-                    worker2.stop();\n+                    JVMTIUtils.stopThread(worker2);\n@@ -149,1 +152,1 @@\n-                        worker1.stop();\n+                        JVMTIUtils.stopThread(worker1);\n@@ -200,1 +203,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionOnMonitorEnter.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,3 +29,2 @@\n- * @library \/test\/lib \/test\/hotspot\/jtreg\n- * @build AsyncExceptionTest\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -Xcomp\n+ * @library \/test\/hotspot\/jtreg\/testlibrary\n+ * @run main\/othervm -Xcomp\n@@ -38,0 +37,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -56,1 +57,3 @@\n-            throw new RuntimeException(\"Catched ThreadDeath in run() instead of internalRun2() or internalRun1(). receivedThreadDeathinInternal1=\" + receivedThreadDeathinInternal1 + \"; receivedThreadDeathinInternal2=\" + receivedThreadDeathinInternal2);\n+            throw new RuntimeException(\"Catched ThreadDeath in run() instead of internalRun2() or internalRun1().\\n\"\n+                    + \"receivedThreadDeathinInternal1=\" + receivedThreadDeathinInternal1\n+                    + \"; receivedThreadDeathinInternal2=\" + receivedThreadDeathinInternal2);\n@@ -58,1 +61,1 @@\n-            \/\/ ignore because we're testing Thread.stop() which can cause it\n+            \/\/ ignore because we're testing StopThread() which can cause it\n@@ -62,1 +65,3 @@\n-            throw new RuntimeException(\"Didn't catched ThreadDeath in internalRun2() nor in internalRun1(). receivedThreadDeathinInternal1=\" + receivedThreadDeathinInternal1 + \"; receivedThreadDeathinInternal2=\" + receivedThreadDeathinInternal2);\n+            throw new RuntimeException(\"Didn't catched ThreadDeath in internalRun2() nor in internalRun1().\\n\"\n+                    + \"receivedThreadDeathinInternal1=\" + receivedThreadDeathinInternal1\n+                    + \"; receivedThreadDeathinInternal2=\" + receivedThreadDeathinInternal2);\n@@ -123,1 +128,1 @@\n-                    thread.stop();\n+                    JVMTIUtils.stopThread(thread);\n@@ -136,1 +141,1 @@\n-                \/\/ Ignore because we're testing Thread.stop() which can\n+                \/\/ Ignore because we're testing StopThread which can\n@@ -168,1 +173,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionTest.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/libAsyncExceptionOnMonitorEnter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,2 +78,0 @@\n-        System.out.println(\"Calling stop ...\");\n-        t.stop();\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/terminatedThread\/TestTerminatedThread.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jvmti;\n+\n+public class JVMTIUtils {\n+\n+    private static native int init();\n+\n+    static {\n+        System.loadLibrary(\"JvmtiUtils\");\n+        if (init() != 0) {\n+            throw new RuntimeException(\"Error during native lib utilization.\");\n+        }\n+    }\n+\n+    private static native void stopThread(Thread t, Throwable ex);\n+\n+    public static void stopThread(Thread t) {\n+        stopThread(t, new ThreadDeath());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jvmti\/JVMTIUtils.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv* jvmti = NULL;\n+\n+JNIEXPORT jint JNICALL\n+Java_jvmti_JVMTIUtils_init(JNIEnv *jni, jclass cls) {\n+  JavaVM* jvm;\n+  jni->GetJavaVM(&jvm);\n+\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiCapabilities caps;\n+  memset(&caps, 0, sizeof (caps));\n+  caps.can_signal_thread = 1;\n+  jvmtiError err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"error in JVMTI AddCapabilities: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jvmti_JVMTIUtils_stopThread(JNIEnv *jni, jclass cls, jthread thread, jobject exception) {\n+  jvmtiError err =  jvmti->StopThread(thread, exception);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+    LOG(\"JVMTI_ERROR_THREAD_NOT_ALIVE happened\");\n+    return;\n+  }\n+  check_jvmti_status(jni, err, \"Error during StopThread()\");\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jvmti\/libJvmtiUtils.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,2 +116,0 @@\n-                        tArray[1].stop(); \/\/ Once javaHeapEater is finished, stop the\n-                        \/\/ the cHeapEater thread.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/mallocWithGC2\/mallocWithGC2.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        while (timer.isAlive())\n+        while (timer.isAlive()) {\n@@ -84,2 +84,1 @@\n-        \/\/      if (tester.isAlive())\n-\/\/          return 2;\n+        }\n@@ -93,0 +92,1 @@\n+        public volatile boolean stop;\n@@ -97,0 +97,1 @@\n+            stop = false;\n@@ -106,0 +107,3 @@\n+                if (stop) {\n+                    return;\n+                }\n@@ -107,4 +111,0 @@\n-\/\/          } catch (StackOverflowError e) {\n-\/\/\n-\/\/ OutOfMemoryError is also eligible to indicate stack overflow:\n-\/\/\n@@ -115,9 +115,0 @@\n-\n-\/***\n- *** Originally, I supposed that VM crashes because of unexpected\n- *** native stack overflow (println() invokes native method).\n- *** However, I found that HS 1.3 and HS 2.0 crash even on\n- *** invocation of Java (not native) method.\n- ***\n- out.println(\"StackOverflowError, depth=\" + depth);\n- ***\/\n@@ -139,12 +130,9 @@\n-            while (System.currentTimeMillis() - started < timeout)\n-                ; \/***\n-             *** The test hangs on JDK 1.2.2 Classic VM if sleep() is invoked.\n-             ***\n-             try {\n-             this.sleep(1000);\n-             } catch (InterruptedException e) {\n-             e.printStackTrace(tester.out);\n-             return;\n-             };\n-             ***\/\n-            tester.stop();\n+            while (System.currentTimeMillis() - started < timeout) {\n+                try {\n+                    this.sleep(1000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace(tester.out);\n+                    return;\n+                };\n+            }\n+            tester.stop = true;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack002.java","additions":17,"deletions":29,"binary":false,"changes":46,"status":"modified"}]}