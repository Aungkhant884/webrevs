{"files":[{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm AsyncExceptionOnMonitorEnter 0\n+ * @run main\/othervm\/native -agentlib:AsyncExceptionOnMonitorEnter AsyncExceptionOnMonitorEnter 0\n@@ -40,0 +40,1 @@\n+    public static native int stopThread(Thread thread);\n@@ -145,1 +146,1 @@\n-                    worker2.stop();\n+                    stopThread(worker2);\n@@ -149,1 +150,1 @@\n-                        worker1.stop();\n+                        stopThread(worker1);\n@@ -200,1 +201,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionOnMonitorEnter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -Xcomp\n+ * @run main\/othervm\/native -agentlib:AsyncException -Xcomp\n@@ -51,0 +51,2 @@\n+    public static native int stopThread(Thread thread);\n+\n@@ -58,1 +60,1 @@\n-            \/\/ ignore because we're testing Thread.stop() which can cause it\n+            \/\/ ignore because we're testing StopThread() which can cause it\n@@ -123,1 +125,1 @@\n-                    thread.stop();\n+                    stopThread(thread);\n@@ -136,1 +138,1 @@\n-                \/\/ Ignore because we're testing Thread.stop() which can\n+                \/\/ Ignore because we're testing StopThread which can\n@@ -168,1 +170,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv* jvmti = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_AsyncExceptionTest_stopThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  stop_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiCapabilities caps;\n+  memset(&caps, 0, sizeof (caps));\n+  caps.can_signal_thread = 1;\n+  jvmtiError err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"error in JVMTI AddCapabilities: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+  return JNI_OK;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/libAsyncException.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvmti_common.h\"\n@@ -32,0 +33,6 @@\n+JNIEXPORT void JNICALL\n+Java_AsyncExceptionOnMonitorEnter_stopThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  stop_thread(jvmti, jni, thread);\n+}\n+\n+\n@@ -82,0 +89,8 @@\n+  jvmtiCapabilities caps;\n+  memset(&caps, 0, sizeof (caps));\n+  caps.can_signal_thread = 1;\n+  jvmtiError err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"error in JVMTI AddCapabilities: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n@@ -85,1 +100,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/libAsyncExceptionOnMonitorEnter.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,2 +78,0 @@\n-        System.out.println(\"Calling stop ...\");\n-        t.stop();\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/terminatedThread\/TestTerminatedThread.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,2 +116,0 @@\n-                        tArray[1].stop(); \/\/ Once javaHeapEater is finished, stop the\n-                        \/\/ the cHeapEater thread.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/mallocWithGC2\/mallocWithGC2.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,1 @@\n+        public volatile boolean stop;\n@@ -97,0 +98,1 @@\n+            stop = false;\n@@ -106,0 +108,3 @@\n+                if (stop) {\n+                    return;\n+                }\n@@ -150,1 +155,1 @@\n-            tester.stop();\n+            tester.stop = true;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack002.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -95,0 +95,7 @@\n+static void\n+assert_not_null(JNIEnv* jni, void* obj, const char* msg) {\n+  if (obj == NULL) {\n+    jni->FatalError(msg);\n+  }\n+}\n+\n@@ -829,1 +836,1 @@\n-int\n+static int\n@@ -837,0 +844,21 @@\n+static const char* THREAD_DEATH_CLASS_NAME = \"java\/lang\/ThreadDeath\";\n+static const char* THREAD_DEATH_CTOR_NAME = \"<init>\";\n+static const char* THREAD_DEATH_CTOR_SIGNATURE = \"()V\";\n+\n+static void\n+stop_thread(jvmtiEnv* jvmti, JNIEnv *jni, jthread thread) {\n+  jclass clz = jni->FindClass(THREAD_DEATH_CLASS_NAME);\n+  assert_not_null(jni, clz, \"stop_thread: FindClass returned NULL\");\n+  jmethodID ctor = jni->GetMethodID(clz, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE);\n+  assert_not_null(jni, ctor, \"stop_thread: GetMethodID returned NULL\");\n+  jobject thread_death = jni->NewObject(clz, ctor);\n+  assert_not_null(jni, thread_death, \"stop_thread: NewObject returned NULL\");\n+\n+  jvmtiError err =  jvmti->StopThread(thread, thread_death);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+    LOG(\"JVMTI_ERROR_THREAD_NOT_ALIVE happened\");\n+    return;\n+  }\n+  check_jvmti_status(jni, err, \"Error during StopThread()\");\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.h","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"}]}