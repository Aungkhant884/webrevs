{"files":[{"patch":"@@ -438,0 +438,6 @@\n+  \/\/ Check if a block between early and LCA block of uses is cheaper by\n+  \/\/ frequency-based policy, latency-based policy and random-based policy\n+  bool is_cheaper_block(Block* LCA, Node* self, uint target_latency,\n+                        uint end_latency, double least_freq,\n+                        int cand_cnt, bool in_latency);\n+\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1133,0 +1133,32 @@\n+\/\/------------------------------is_cheaper_block-------------------------\n+\/\/ Check if a block between early and LCA block of uses is cheaper by\n+\/\/ frequency-based policy, latency-based policy and random-based policy\n+bool PhaseCFG::is_cheaper_block(Block* LCA, Node* self, uint target_latency,\n+                                uint end_latency, double least_freq,\n+                                int cand_cnt, bool in_latency) {\n+  if (StressGCM && C->randomized_select(cand_cnt)) {\n+    \/\/ Should be randomly accepted in stress mode\n+    return true;\n+  }\n+\n+  if (!StressGCM) {\n+    \/\/ Better Frequency\n+    if (LCA->_freq < least_freq) {\n+      return true;\n+    }\n+    \/\/ Otherwise, choose with latency\n+    const double delta = 1 + PROB_UNLIKELY_MAG(4);\n+    if (!in_latency                     &&  \/\/ No block containing latency\n+        LCA->_freq < least_freq * delta &&  \/\/ No worse frequency\n+        target_latency >= end_latency   &&  \/\/ within latency range\n+        !self->is_iteratively_computed()    \/\/ But don't hoist IV increments\n+             \/\/ because they may end up above other uses of their phi forcing\n+             \/\/ their result register to be different from their input.\n+    ) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n@@ -1134,2 +1166,2 @@\n-\/\/ Pick a block for node self, between early and LCA, that is a cheaper\n-\/\/ alternative to LCA.\n+\/\/ Pick a block for node self, between early and LCA block of uses, that is a\n+\/\/ cheaper alternative to LCA.\n@@ -1137,1 +1169,0 @@\n-  const double delta = 1+PROB_UNLIKELY_MAG(4);\n@@ -1174,1 +1205,2 @@\n-  \/\/ the earliest legal location.  Capture the least execution frequency.\n+  \/\/ the earliest legal location. Capture the least execution frequency,\n+  \/\/ or choose a random block if -XX:+StressGCM, or using latency-based policy\n@@ -1208,10 +1240,1 @@\n-    if (LCA_freq < least_freq              || \/\/ Better Frequency\n-        (StressGCM && C->randomized_select(cand_cnt)) || \/\/ Should be randomly accepted in stress mode\n-         (!StressGCM                    &&    \/\/ Otherwise, choose with latency\n-          !in_latency                   &&    \/\/ No block containing latency\n-          LCA_freq < least_freq * delta &&    \/\/ No worse frequency\n-          target >= end_lat             &&    \/\/ within latency range\n-          !self->is_iteratively_computed() )  \/\/ But don't hoist IV increments\n-             \/\/ because they may end up above other uses of their phi forcing\n-             \/\/ their result register to be different from their input.\n-       ) {\n+    if (is_cheaper_block(LCA, self, target, end_lat, least_freq, cand_cnt, in_latency)) {\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"}]}