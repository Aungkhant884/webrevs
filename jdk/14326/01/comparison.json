{"files":[{"patch":"@@ -1783,0 +1783,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1785,1 +1786,0 @@\n-    JvmtiVTMSTransitionDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1347,1 +1347,1 @@\n-JvmtiEnvBase::get_threadOop_and_JavaThread(ThreadsList* t_list, jthread thread,\n+JvmtiEnvBase::get_threadOop_and_JavaThread(ThreadsList* t_list, jthread thread, JavaThread* cur_thread,\n@@ -1349,1 +1349,0 @@\n-  JavaThread* cur_thread = JavaThread::current();\n@@ -1354,0 +1353,3 @@\n+    if (cur_thread == nullptr) { \/\/ cur_thread can be null when called from a VM_op\n+      return JVMTI_ERROR_INVALID_THREAD;\n+    }\n@@ -1384,0 +1386,8 @@\n+jvmtiError\n+JvmtiEnvBase::get_threadOop_and_JavaThread(ThreadsList* t_list, jthread thread,\n+                                           JavaThread** jt_pp, oop* thread_oop_p) {\n+  JavaThread* cur_thread = JavaThread::current();\n+  jvmtiError err = get_threadOop_and_JavaThread(t_list, thread, cur_thread, jt_pp, thread_oop_p);\n+  return err;\n+}\n+\n@@ -1934,1 +1944,2 @@\n-    jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), jt, &java_thread, &thread_oop);\n+    jvmtiError err = JvmtiEnvBase::get_threadOop_and_JavaThread(tlh.list(), jt, nullptr, &java_thread, &thread_oop);\n+\n@@ -1939,2 +1950,3 @@\n-      \/\/ In the virtual thread case the cv_external_thread_to_JavaThread is expected to correctly set\n-      \/\/ the thread_oop and return JVMTI_ERROR_INVALID_THREAD which we ignore here.\n+      \/\/ In the virtual thread case the get_threadOop_and_JavaThread is expected to correctly set\n+      \/\/ the thread_oop and return JVMTI_ERROR_THREAD_NOT_ALIVE which we ignore here.\n+      \/\/ Thei corresponding thread state will be recorded in the jvmtiStackInfo.state.\n@@ -1945,1 +1957,0 @@\n-      \/\/ We have a valid thread_oop.\n@@ -1955,1 +1966,1 @@\n-  oop thread_oop = jt->threadObj();\n+  oop thread_oop = JNIHandles::resolve_external_guard(_jthread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -217,0 +217,2 @@\n+  static jvmtiError get_threadOop_and_JavaThread(ThreadsList* t_list, jthread thread, JavaThread* cur_thread,\n+                                                 JavaThread** jt_pp, oop* thread_oop_p);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8295976\n+ * @summary GetThreadListStackTraces returns wrong state for blocked VirtualThread\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @run main\/othervm\/native -agentlib:ThreadListStackTracesTest ThreadListStackTracesTest\n+ *\/\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.*;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+class TestTask implements Runnable {\n+    volatile boolean threadReady = false;\n+\n+    static void log(String msg) { System.out.println(msg); }\n+\n+    static void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interruption in TestTask.sleep: \\n\\t\" + e);\n+        }\n+    }\n+\n+    public void ensureReady(Thread vt, Thread.State expState) {\n+        \/\/ wait while the thread is not ready or thread state is unexpected\n+        while (!threadReady || (vt.getState() != expState)) {\n+            sleep(1);\n+        }\n+    }\n+\n+    public void run() {\n+        log(\"TestTask.run()\");\n+    }\n+}\n+\n+class ReentrantLockTestTask extends TestTask {\n+    public void run() {\n+        log(\"grabbing reentrantLock\");\n+        threadReady = true;\n+        ThreadListStackTracesTest.reentrantLock.lock();\n+        log(\"grabbed reentrantLock\");\n+    }\n+}\n+\n+class ObjectMonitorTestTask extends TestTask {\n+    public void run() {\n+        log(\"entering synchronized statement\");\n+        threadReady = true;\n+        synchronized (ThreadListStackTracesTest.objectMonitor) {\n+            log(\"entered synchronized statement\");\n+        }\n+    }\n+}\n+\n+public class ThreadListStackTracesTest {\n+    static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;\n+    static final int JVMTI_THREAD_STATE_WAITING = 0x0080;\n+\n+    static final ReentrantLock reentrantLock = new ReentrantLock();\n+    static final Object objectMonitor = new Object();\n+\n+    private static native int getStateSingle(Thread thread);\n+    private static native int getStateMultiple(Thread thread, Thread other);\n+\n+    static void log(String msg) { System.out.println(msg); }\n+    static void failed(String msg) { throw new RuntimeException(msg); }\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        checkReentrantLock();\n+        checkSynchronized();\n+    }\n+\n+    private static void checkReentrantLock() throws InterruptedException {\n+        final Thread.State expState = Thread.State.WAITING;\n+        reentrantLock.lock();\n+        String name = \"ObjectMonitorTestTask\";\n+        TestTask task = new ReentrantLockTestTask();\n+        Thread vt = Thread.ofVirtual().name(name).start(task);\n+        task.ensureReady(vt, expState);\n+        checkStates(vt, expState);\n+    }\n+\n+    private static void checkSynchronized() throws InterruptedException {\n+        final Thread.State expState = Thread.State.BLOCKED;\n+        synchronized (objectMonitor) {\n+            String name = \"ObjectMonitorTestTask\";\n+            TestTask task = new ObjectMonitorTestTask();\n+            Thread vt = Thread.ofVirtual().name(name).start(task);\n+            task.ensureReady(vt, expState);\n+            checkStates(vt, expState);\n+        }\n+    }\n+\n+    private static void checkStates(Thread vt, Thread.State expState) {\n+        int singleState = getStateSingle(vt);\n+        int multiState = getStateMultiple(vt, Thread.currentThread());\n+        int jvmtiExpState = (expState == Thread.State.WAITING) ?\n+                            JVMTI_THREAD_STATE_WAITING :\n+                            JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+\n+        System.out.printf(\"State: expected: %s single: %x multi: %x\\n\",\n+                          vt.getState(), singleState, multiState);\n+\n+        if (vt.getState() != expState) {\n+            failed(\"Java thread state is wrong\");\n+        }\n+        if ((singleState & jvmtiExpState) == 0) {\n+            failed(\"JVMTI single thread state is wrong\");\n+        }\n+        if ((multiState & jvmtiExpState) == 0) {\n+            failed(\"JVMTI multi thread state is wrong\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadListStackTracesTest\/ThreadListStackTracesTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti_common.h\"\n+\n+static jvmtiEnv* jvmti = nullptr;\n+static const jint MAX_FRAME_COUNT = 32;\n+\n+extern \"C\" {\n+\n+JNIEXPORT jint JNICALL Java_ThreadListStackTracesTest_getStateSingle(JNIEnv* jni, jclass clazz, jthread vthread) {\n+  jvmtiStackInfo* info = NULL;\n+\n+  jvmtiError err = jvmti->GetThreadListStackTraces(1, &vthread, MAX_FRAME_COUNT, &info);\n+  check_jvmti_status(jni, err, \"getStateSingle: error in JVMTI GetThreadListStackTraces\");\n+\n+  return info[0].state;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ThreadListStackTracesTest_getStateMultiple(JNIEnv* jni, jclass clazz, jthread vhread, jthread other) {\n+  jthread threads[2] = { vhread, other };\n+  jvmtiStackInfo* info = NULL;\n+\n+  jvmtiError err = jvmti->GetThreadListStackTraces(2, threads, MAX_FRAME_COUNT, &info);\n+  check_jvmti_status(jni, err, \"getStateMultiple: error in JVMTI GetThreadListStackTraces\");\n+\n+  return info[0].state;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    LOG(\"Agent_OnLoad: error in GetEnv\");\n+    return JNI_ERR;\n+  }\n+  return 0;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadListStackTracesTest\/libThreadListStackTracesTest.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"}]}