{"files":[{"patch":"@@ -87,1 +87,1 @@\n-    ls.print_cr(\"Preinit state:\");\n+    ls.print_cr(\"Preinit state: \");\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  \/\/ parses the tracking level from a string. Returns NMT_unknown if\n+  \/\/ Parses the tracking level from a string. Returns NMT_unknown if\n@@ -131,1 +131,1 @@\n-  \/\/ returns textual representation of a tracking level.\n+  \/\/ Returns textual representation of a tracking level.\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-\/\/ --------- NMTPreinitHashTable --------------\n+\/\/ --------- NMTPreInitAllocationTable --------------\n@@ -83,1 +83,1 @@\n-  for (int i = 0; i < table_size; i ++) {\n+  for (int i = 0; i < table_size; i++) {\n@@ -86,1 +86,1 @@\n-      chain_len ++;\n+      chain_len++;\n@@ -90,1 +90,1 @@\n-      num_primary_entries ++;\n+      num_primary_entries++;\n@@ -103,1 +103,1 @@\n-  for (int i = 0; i < table_size; i ++) {\n+  for (int i = 0; i < table_size; i++) {\n@@ -119,1 +119,1 @@\n-  for (index_t i = 0; i < table_size; i ++) {\n+  for (index_t i = 0; i < table_size; i++) {\n@@ -136,1 +136,1 @@\n-      num_chains_too_long ++;\n+      num_chains_too_long++;\n@@ -155,2 +155,0 @@\n-unsigned NMTPreInit::_num_reallocs_pre_to_post = 0;\n-unsigned NMTPreInit::_num_frees_pre_to_post = 0;\n@@ -169,39 +167,0 @@\n-#ifdef ASSERT\n-\/\/ We do some small test allocations in pre-init and post-init phase; this is to test\n-\/\/ os::malloc handling. Most of the test coding for NMT preinit stuff is done in gtests and\n-\/\/ jtreg tests. This bit, however, cannot be done anywhere else since part of it needs to run during\n-\/\/ libjvm C++ initialization.\n-class TestAllocations {\n-  void* p1, *p2, *p3, *p4;\n-  \/\/ Some shorts to save writing out the flags every time\n-  static void* os_malloc(size_t s)              { return os::malloc(s, mtTest); }\n-  static void* os_realloc(void* old, size_t s)  { return os::realloc(old, s, mtTest); }\n-public:\n-  TestAllocations() {\n-    test_pre();\n-  }\n-  void test_pre() {\n-    p1 = os_malloc(100);                 \/\/ normal allocation\n-    os::free(os_malloc(0));              \/\/ 0-sized allocation, should be free-able\n-    p2 = os_realloc(os_malloc(10), 20);  \/\/ realloc, growing\n-    p3 = os_realloc(os_malloc(20), 10);  \/\/ realloc, shrinking\n-    p4 = os_realloc(NULL, 10);           \/\/ realloc with NULL pointer\n-    os_realloc(os_realloc(os_malloc(20), 0), 30);  \/\/ realloc to size 0 and back up again\n-    os::free(os_malloc(20));             \/\/ malloc, free\n-    os::free(os_realloc(os_malloc(20), 30));  \/\/ malloc, realloc, free\n-    os::free(NULL);                      \/\/ free(null)\n-    NMTPreInit::verify();\n-  }\n-  void test_post() {\n-    p1 = os_realloc(p1, 140);  \/\/ realloc from pre-init-phase, growing\n-    p2 = os_realloc(p2, 150);  \/\/ realloc from pre-init-phase, growing\n-    p3 = os_realloc(p3, 50);   \/\/ realloc from pre-init-phase, growing\n-    p4 = os_realloc(p4, 8);    \/\/ realloc from pre-init-phase, shrinking\n-  }\n-  void free_all() {\n-    os::free(p1); os::free(p2); os::free(p3); os::free(p4);\n-  }\n-};\n-static TestAllocations g_test_allocations; \/\/ make this an automatic object to let ctor run during in C++ dynamic initialization.\n-#endif \/\/ ASSERT\n-\n@@ -213,5 +172,1 @@\n-#ifdef ASSERT\n-  g_test_allocations.test_post();\n-  g_test_allocations.free_all();\n-  verify();\n-#endif\n+  DEBUG_ONLY(verify();)\n@@ -226,3 +181,1 @@\n-         _num_frees_pre <= _num_mallocs_pre &&\n-         _num_reallocs_pre_to_post <= _num_mallocs_pre &&\n-         _num_frees_pre_to_post <= _num_mallocs_pre, \"stats are off\");\n+         _num_frees_pre <= _num_mallocs_pre, \"stats are off\");\n@@ -237,4 +190,2 @@\n-  st->print_cr(\"pre-init mallocs: %u, pre-init reallocs: %u, pre-init frees: %u, \"\n-               \"pre-to-post reallocs: %u, pre-to-post frees: %u\",\n-               _num_mallocs_pre, _num_reallocs_pre, _num_frees_pre,\n-               _num_reallocs_pre_to_post, _num_frees_pre_to_post);\n+  st->print_cr(\"pre-init mallocs: %u, pre-init reallocs: %u, pre-init frees: %u\",\n+               _num_mallocs_pre, _num_reallocs_pre, _num_frees_pre);\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.cpp","additions":11,"deletions":60,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+#ifdef ASSERT\n+#include \"runtime\/atomic.hpp\"\n+#endif\n@@ -114,4 +117,4 @@\n-\/\/  The table is customized for holding malloced pointers. One main point of this map is that we do\n-\/\/  not allocate memory for the nodes themselves. Instead we piggy-back on the user allocation:\n-\/\/  the hashmap entry structure precedes, as a header, the malloced block. That way we avoid extra\n-\/\/  allocations just to hold the map nodes. This keeps runtime\/memory overhead as small as possible.\n+\/\/   The table is customized for holding malloced pointers. One main point of this map is that we do\n+\/\/   not allocate memory for the nodes themselves. Instead we piggy-back on the user allocation:\n+\/\/   the hashmap entry structure precedes, as a header, the malloced block. That way we avoid extra\n+\/\/   allocations just to hold the map nodes. This keeps runtime\/memory overhead as small as possible.\n@@ -130,1 +133,1 @@\n-  \/\/ These functions do allocate\/free a raw malloc block of given payload size,\n+  \/\/ These functions do raw-malloc\/realloc\/free a C-heap block of given payload size,\n@@ -139,2 +142,2 @@\n-  \/\/ table_size: keep table size a prime and the hash function simple; this\n-  \/\/  seems to give a good distribution for malloce'd pointers on all our libc variants.\n+  \/\/ Table_size: keep table size a prime and the hash function simple; this\n+  \/\/  seems to give a good distribution for malloced pointers on all our libc variants.\n@@ -164,1 +167,5 @@\n-  NMTPreInitAllocation** find_entry(const void* p) const {\n+  const NMTPreInitAllocation* const * find_entry(const void* p) const {\n+    return const_cast<NMTPreInitAllocationTable*>(this)->find_entry(p);\n+  }\n+\n+  NMTPreInitAllocation** find_entry(const void* p) {\n@@ -166,1 +173,1 @@\n-    NMTPreInitAllocation** aa = (NMTPreInitAllocation**) (&(_entries[index]));\n+    NMTPreInitAllocation** aa = (&(_entries[index]));\n@@ -192,3 +199,2 @@\n-  NMTPreInitAllocation* find(const void* p) const {\n-    NMTPreInitAllocation** aa = find_entry(p);\n-    return *aa;\n+  const NMTPreInitAllocation* find(const void* p) const {\n+    return *(find_entry(p));\n@@ -222,2 +228,0 @@\n-  static unsigned _num_reallocs_pre_to_post;  \/\/ Number of post-init reallocs for pre-init blocks\n-  static unsigned _num_frees_pre_to_post;     \/\/ Number of post-init frees for pre-init blocks\n@@ -237,1 +241,1 @@\n-  static NMTPreInitAllocation* find_in_map(void* p) {\n+  static const NMTPreInitAllocation* find_in_map(void* p) {\n@@ -257,0 +261,3 @@\n+  \/\/ Returns true if we are still in pre-init phase, false if post-init\n+  static bool in_preinit_phase()  { return _nmt_was_initialized == false; }\n+\n@@ -268,1 +275,1 @@\n-      _num_mallocs_pre ++;\n+      _num_mallocs_pre++;\n@@ -304,1 +311,1 @@\n-      NMTPreInitAllocation* a = find_in_map(old_p);\n+      const NMTPreInitAllocation* a = find_in_map(old_p);\n@@ -309,1 +316,0 @@\n-        _num_reallocs_pre_to_post++;\n@@ -327,1 +333,2 @@\n-      (void)find_and_remove_in_map(p);\n+      NMTPreInitAllocation* a = find_and_remove_in_map(p);\n+      NMTPreInitAllocation::do_free(a);\n@@ -338,1 +345,0 @@\n-        _num_frees_pre_to_post++;\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.hpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-static void SetJvmEnvironment(int argc, char **argv);\n@@ -287,3 +286,0 @@\n-    \/* Set env. Must be done before LoadJavaVM. *\/\n-    SetJvmEnvironment(argc, argv);\n-\n@@ -801,36 +797,0 @@\n-\/*\n- * This method must be called before the VM is loaded, primarily\n- * used to parse and set any VM related options or env variables.\n- * This function is non-destructive leaving the argument list intact.\n- *\/\n-static void\n-SetJvmEnvironment(int argc, char **argv) {\n-\n-    int i;\n-    \/* process only the launcher arguments *\/\n-    for (i = 0; i < argc; i++) {\n-        char *arg = argv[i];\n-        \/*\n-         * Java launcher (!IsJavaArgs()):\n-         *   Since this must be a VM flag we stop processing once we see\n-         *   an argument the launcher would not have processed beyond (such\n-         *   as -version or -h), or an argument that indicates the following\n-         *   arguments are for the application (i.e. the main class name, or\n-         *   the -jar argument).\n-         * Other launchers (IsJavaArgs()):\n-         *   All arguments have to be scanned to see if it is a -J argument.\n-         *\/\n-        if (!IsJavaArgs() && i > 0) {\n-            char *prev = argv[i - 1];\n-            \/\/ skip non-dash arg preceded by class path specifiers\n-            if (*arg != '-' && IsWhiteSpaceOption(prev)) {\n-                continue;\n-            }\n-\n-            if (*arg != '-' || isTerminalOpt(arg)) {\n-                return;\n-            }\n-        }\n-    }\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -96,2 +96,0 @@\n-#define JLI_PutEnv                      _putenv\n-#define JLI_GetPid                      _getpid\n@@ -105,2 +103,0 @@\n-#define JLI_PutEnv                      putenv\n-#define JLI_GetPid                      getpid\n","filename":"src\/java.base\/share\/native\/libjli\/jli_util.h","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/nmtPreInit.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ convenience log. switch on if debugging tests. Don't use tty, plain stdio only.\n+\/\/#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+#define LOG(...)\n+\n+\n+\/\/ This tests the ability of the NMT pre-init system to deal with various combinations\n+\/\/ of pre- and post-init-allocations.\n+\n+\/\/ The tests consist of two phases:\n+\/\/ 1) before NMT initialization (pre-NMT-init) we allocate and reallocate a bunch of\n+\/\/    blocks via os::malloc() and os::realloc(), and free some of them via os::free()\n+\/\/ 2) after NMT initialization, we reallocate some more, then free all of them.\n+\/\/\n+\/\/ The intent is to check that blocks allocated in pre-init phase and potentially realloced\n+\/\/ in pre-init phase are handled correctly if further realloc'ed or free'd post-init.\n+\n+\/\/ We manage to run tests in different phases with this technique:\n+\/\/ - for the pre-init phase, we start the tests in the constructor of a global object; that constructor will\n+\/\/   run as part of the dyn. C++ initialization of the gtestlauncher binary. Since the gtestlauncher links\n+\/\/   *statically* against the libjvm, gtestlauncher and libjvm initialization fold into one and are the same.\n+\/\/ - for the post-init phase, we just start it inside a TEST_VM scope, which needs to create the VM for\n+\/\/   us. So inside that scope VM initialization ran and with it the NMT initialization.\n+\/\/ To be sure, we assert those assumptions.\n+\n+#if INCLUDE_NMT\n+\n+\/\/ Some shorts to save writing out the flags every time\n+static void* os_malloc(size_t s)              { return os::malloc(s, mtTest); }\n+static void* os_realloc(void* old, size_t s)  { return os::realloc(old, s, mtTest); }\n+\n+static void log_state() {\n+  \/\/ Don't use tty! the only safe thing to use at all times is stringStream.\n+  char tmp[256];\n+  stringStream ss(tmp, sizeof(tmp));\n+  NMTPreInit::print_state(&ss);\n+  LOG(\"%s\", tmp);\n+}\n+\n+class TestAllocations {\n+  void* p1, *p2, *p3, *p4;\n+public:\n+  TestAllocations() {\n+    test_pre();\n+  }\n+  void test_pre() {\n+    \/\/ Note that this part will run every time a gtestlauncher execs (so, for every TEST_OTHER_VM).\n+    assert(NMTPreInit::in_preinit_phase(),\n+           \"This should be run in pre-init phase (as part of C++ dyn. initialization)\");\n+    LOG(\"corner cases, pre-init (%d)\", os::current_process_id());\n+    log_state();\n+\n+    p1 = os_malloc(100);                 \/\/ normal allocation\n+    os::free(os_malloc(0));              \/\/ 0-sized allocation, should be free-able\n+    p2 = os_realloc(os_malloc(10), 20);  \/\/ realloc, growing\n+    p3 = os_realloc(os_malloc(20), 10);  \/\/ realloc, shrinking\n+    p4 = os_realloc(NULL, 10);           \/\/ realloc with NULL pointer\n+    os_realloc(os_realloc(os_malloc(20), 0), 30);  \/\/ realloc to size 0 and back up again\n+    os::free(os_malloc(20));             \/\/ malloc, free\n+    os::free(os_realloc(os_malloc(20), 30));  \/\/ malloc, realloc, free\n+    os::free(NULL);                      \/\/ free(null)\n+    DEBUG_ONLY(NMTPreInit::verify();)\n+\n+    log_state();\n+  }\n+  void test_post() {\n+    assert(NMTPreInit::in_preinit_phase() == false,\n+           \"This should be run in post-init phase (from inside a TEST_VM test)\");\n+    LOG(\"corner cases, post-init (%d)\", os::current_process_id());\n+    log_state();\n+\n+    p1 = os_realloc(p1, 140);  \/\/ realloc from pre-init-phase, growing\n+    p2 = os_realloc(p2, 150);  \/\/ realloc from pre-init-phase, growing\n+    p3 = os_realloc(p3, 50);   \/\/ realloc from pre-init-phase, growing\n+    p4 = os_realloc(p4, 8);    \/\/ realloc from pre-init-phase, shrinking\n+    DEBUG_ONLY(NMTPreInit::verify();)\n+\n+    log_state();\n+  }\n+  void free_all() {\n+    assert(NMTPreInit::in_preinit_phase() == false,\n+           \"This should be run in post-init phase (from inside a TEST_VM test)\");\n+    LOG(\"corner cases, free-all (%d)\", os::current_process_id());\n+    log_state();\n+\n+    os::free(p1); os::free(p2); os::free(p3); os::free(p4);\n+    DEBUG_ONLY(NMTPreInit::verify();)\n+\n+    log_state();\n+  }\n+};\n+\n+static TestAllocations g_test_allocations;\n+\n+TEST_VM(NMTPreInit, pre_to_post_allocs) {\n+  g_test_allocations.test_post();\n+  g_test_allocations.free_all();\n+}\n+\n+#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinit.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +36,2 @@\n+\/\/ This tests the NMTPreInitAllocationTable hash table used to store C-heap allocations before NMT initialization ran.\n+\n@@ -48,1 +51,1 @@\n-#define VERBOSE\n+\/\/#define VERBOSE\n@@ -70,1 +73,1 @@\n-  for (int i = 0; i < num_allocs; i ++) {\n+  for (int i = 0; i < num_allocs; i++) {\n@@ -79,2 +82,2 @@\n-  for (int i = 0; i < num_allocs; i ++) {\n-    NMTPreInitAllocation* a = table.find(allocations[i]->payload());\n+  for (int i = 0; i < num_allocs; i++) {\n+    const NMTPreInitAllocation* a = table.find(allocations[i]->payload());\n@@ -98,2 +101,2 @@\n-  for (int i = 0; i < num_allocs; i ++) {\n-    NMTPreInitAllocation* a = table.find(allocations[i]->payload());\n+  for (int i = 0; i < num_allocs; i++) {\n+    const NMTPreInitAllocation* a = table.find(allocations[i]->payload());\n@@ -104,1 +107,1 @@\n-  for (int i = 0; i < num_allocs; i ++) {\n+  for (int i = 0; i < num_allocs; i++) {\n@@ -107,0 +110,2 @@\n+    NMTPreInitAllocation::do_free(a);\n+    allocations[i] = NULL;\n@@ -119,1 +124,1 @@\n-  for (int i = 0; i < num_allocs; i ++) {\n+  for (int i = 0; i < num_allocs; i++) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinitmap.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * With JDK-8256844 \"Make NMT late-initializable\", NMT should work out of the box with jdk launchers other than\n+ * java.exe.\n+ *\n+ * Test that assumption (we test with javac and jar and leave it at that, other tools should be fine as well)\n+ *\/\n+\n+\/**\n+ * @test id=javac\n+ * @bug 8256844\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver NMTForOtherLaunchersTest javac\n+ *\/\n+\n+\/**\n+ * @test id=jar\n+ * @bug 8256844\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver NMTForOtherLaunchersTest jar\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.JDKToolFinder;\n+\n+public class NMTForOtherLaunchersTest {\n+    public static void main(String args[]) throws Exception {\n+        String tool = args[0];\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(new String[]{\n+                JDKToolFinder.getJDKTool(tool),\n+                \"-J-XX:NativeMemoryTracking=summary\",\n+                \"-J-XX:+UnlockDiagnosticVMOptions\",\n+                \"-J-XX:+PrintNMTStatistics\",\n+                \"--help\"});\n+        System.out.println(pb.command());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        \/\/ We should not see the \"wrong launcher?\" message, which would indicate\n+        \/\/ an older JDK, and we should see the NMT stat output when the VM shuts down.\n+        output.shouldNotContain(\"wrong launcher\");\n+        output.shouldContain(\"Native Memory Tracking:\");\n+        output.shouldMatch(\"Total: reserved=\\\\d+, committed=\\\\d+.*\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTForOtherLaunchersTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTInitializationTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}