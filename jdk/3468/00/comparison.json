{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.Objects;\n+import java.util.function.Consumer;\n@@ -143,0 +145,61 @@\n+    \/**\n+     * Returns a pre-processing Filter with the given description and operation.\n+     *\n+     * <p>The {@link Consumer operation} is the effective implementation of\n+     * the returned Filter and is executed for each {@code HttpExchange} before\n+     * invoking the next filter in the chain, or the exchange handler\n+     * (if this is the final filter in the chain).\n+     *\n+     * @param description the description of the returned filter\n+     * @param operation the operation of the returned filter\n+     * @return a filter\n+     * @throws NullPointerException if any argument is null\n+     * @since 17\n+     *\/\n+    public static Filter beforeResponse(String description,\n+                                        Consumer<HttpExchange> operation) {\n+        Objects.requireNonNull(description);\n+        Objects.requireNonNull(operation);\n+        return new Filter() {\n+            @Override\n+            public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n+                operation.accept(exchange);\n+                chain.doFilter(exchange);\n+            }\n+            @Override\n+            public String description() {\n+                return description;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns a post-processing Filter with the given description and operation.\n+     *\n+     * <p>The {@link Consumer operation} is the effective implementation of\n+     * the returned Filter and is executed for each {@code HttpExchange} after\n+     * invoking the next filter in the chain, or the exchange handler\n+     * (if this is the final filter in the chain).\n+     *\n+     * @param description the description of the returned filter\n+     * @param operation the operation of the returned filter\n+     * @return a filter\n+     * @throws NullPointerException if any argument is null\n+     * @since 17\n+     *\/\n+    public static Filter afterResponse(String description,\n+                                       Consumer<HttpExchange> operation) {\n+        Objects.requireNonNull(description);\n+        Objects.requireNonNull(operation);\n+        return new Filter() {\n+            @Override\n+            public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n+                chain.doFilter(exchange);\n+                operation.accept(exchange);\n+            }\n+            @Override\n+            public String description() {\n+                return description;\n+            }\n+        };\n+    }\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Filter.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -662,1 +662,3 @@\n-            assert r.result.getStatus() == Status.CLOSED;\n+            assert r.result.getStatus() == Status.CLOSED\n+                    : \"status is: \" + r.result.getStatus()\n+                    + \", handshakeStatus is: \" + stat;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/SSLStreams.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic tests for static factory methods of Filter\n+ * @run testng\/othervm FilterTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import com.sun.net.httpserver.Filter;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.BeforeTest;\n+import static org.testng.Assert.*;\n+\n+public class FilterTest {\n+\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+\n+    static final boolean ENABLE_LOGGING = true;\n+\n+    @BeforeTest\n+    public void setup() {\n+        if (ENABLE_LOGGING) {\n+            Logger logger = Logger.getLogger(\"com.sun.net.httpserver\");\n+            ConsoleHandler ch = new ConsoleHandler();\n+            logger.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            logger.addHandler(ch);\n+        }\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        expectThrows(NPE, () -> Filter.beforeResponse(null, (HttpExchange e) -> e.getResponseHeaders().set(\"X-Foo\", \"Bar\")));\n+        expectThrows(NPE, () -> Filter.beforeResponse(\"Some description\", null));\n+        expectThrows(NPE, () -> Filter.afterResponse(null, HttpExchange::getResponseCode));\n+        expectThrows(NPE, () -> Filter.afterResponse(\"Some description\", null));\n+    }\n+\n+    @Test\n+    public void testDescription() {\n+        var desc = \"Some description\";\n+        var beforeFilter = Filter.beforeResponse(desc, HttpExchange::getRequestBody);\n+        var afterFilter = Filter.afterResponse(desc, HttpExchange::getRequestBody);\n+        assertEquals(desc, beforeFilter.description());\n+        assertEquals(desc, afterFilter.description());\n+    }\n+\n+    @Test\n+    public void testBeforeResponse() throws Exception {\n+        var handler = new TestHttpHandler();\n+        var filter = Filter.beforeResponse(\"Add x-foo response header\",\n+                (var e) -> e.getResponseHeaders().set(\"x-foo\", \"bar\"));\n+        var server = HttpServer.create(new InetSocketAddress(0), 10);\n+        server.createContext(\"\/\", handler).getFilters().add(filter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.headers().firstValue(\"x-foo\").orElseThrow(), \"bar\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testBeforeResponseRepeated() throws Exception {\n+        var handler = new TestHttpHandler();\n+        var filter1 = Filter.beforeResponse(\"Add x-foo response header\",\n+                (var e) -> e.getResponseHeaders().set(\"x-foo\", \"bar\"));\n+        var filter2 = Filter.beforeResponse(\"Update x-foo response header\",\n+                (var e) -> e.getResponseHeaders().set(\"x-foo\", \"barbar\"));\n+        var server = HttpServer.create(new InetSocketAddress(0), 10);\n+        var context = server.createContext(\"\/\", handler);\n+        context.getFilters().add(filter1);\n+        context.getFilters().add(filter2);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.headers().firstValue(\"x-foo\").orElseThrow(), \"barbar\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testAfterResponse() throws Exception {\n+        var handler = new TestHttpHandler();\n+        var respCode = new int[1];\n+        var filter = Filter.afterResponse(\"Log response code\",\n+                (var e) -> respCode[0] = e.getResponseCode());\n+        var server = HttpServer.create(new InetSocketAddress(0), 10);\n+        server.createContext(\"\/\", handler).getFilters().add(filter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.statusCode(), respCode[0]);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testAfterResponseRepeated() throws Exception {\n+        var handler = new TestHttpHandler();\n+        var attr = new String[1];\n+        final var value = \"some value\";\n+        var afterFilter1 = Filter.afterResponse(\"Set attribute\",\n+                (var e) -> e.setAttribute(\"test-attr\", value));\n+        var afterFilter2 = Filter.afterResponse(\"Read attribute\",\n+                (var e) -> attr[0] = (String) e.getAttribute(\"test-attr\"));\n+        var server = HttpServer.create(new InetSocketAddress(0), 10);\n+        var context = server.createContext(\"\/\", handler);\n+        context.getFilters().add(afterFilter2);\n+        context.getFilters().add(afterFilter1);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(attr[0], value);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testBeforeAndAfterResponse() throws Exception {\n+        var handler = new TestHttpHandler();\n+        var respCode = new int[1];\n+        var beforeFilter = Filter.beforeResponse(\"Add x-foo response header\",\n+                (var e) -> e.getResponseHeaders().set(\"x-foo\", \"bar\"));\n+        var afterFilter = Filter.afterResponse(\"Log response code\",\n+                (var e) -> respCode[0] = e.getResponseCode());\n+        var server = HttpServer.create(new InetSocketAddress(0), 10);\n+        var context = server.createContext(\"\/\", handler);\n+        context.getFilters().add(beforeFilter);\n+        context.getFilters().add(afterFilter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.statusCode(), respCode[0]);\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.headers().firstValue(\"x-foo\").orElseThrow(), \"bar\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URI.create(\"http:\/\/localhost:%s\/%s\".formatted(server.getAddress().getPort(), path));\n+    }\n+\n+    \/**\n+     * A test handler that discards the request and sends no response\n+     *\/\n+    static class TestHttpHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody()) {\n+                is.readAllBytes();\n+                exchange.sendResponseHeaders(200, -1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/FilterTest.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"}]}