{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.Objects;\n+import java.util.function.Consumer;\n@@ -143,0 +145,107 @@\n+    \/**\n+     * Returns a pre-processing {@code Filter} with the given description and\n+     * operation.\n+     *\n+     * <p>The {@link Consumer operation} is the effective implementation of the\n+     * filter. It is executed for each {@code HttpExchange} before invoking\n+     * either the next filter in the chain or the exchange handler (if this is\n+     * the final filter in the chain).\n+     *\n+     * @apiNote\n+     * A beforeHandler filter is typically used to examine or modify the\n+     * exchange state before it is handled. The filter {@code operation} is\n+     * executed before {@link Filter.Chain#doFilter(HttpExchange)} is invoked,\n+     * so before any subsequent filters in the chain and the exchange handler\n+     * are executed. The filter {@code operation} is not expected to handle the\n+     * request or {@linkplain HttpExchange#sendResponseHeaders(int, long) send response headers},\n+     * since this is commonly done by the exchange handler.\n+     *\n+     * <p> Example of adding the {@code \"Foo\"} response header to all responses:\n+     * <pre>{@code\n+     *     var filter = Filter.beforeHandler(\"Add response header Foo\",\n+     *                 e -> e.getResponseHeaders().set(\"Foo\", \"Bar\"));\n+     *     httpContext.getFilters().add(filter);\n+     * }<\/pre>\n+     *\n+     * @param description the string to be returned from {@link #description()}\n+     * @param operation the operation of the returned filter\n+     * @return a filter whose operation is invoked before the exchange is handled\n+     * @throws NullPointerException if any argument is null\n+     * @since 17\n+     *\/\n+    public static Filter beforeHandler(String description,\n+                                       Consumer<HttpExchange> operation) {\n+        Objects.requireNonNull(description);\n+        Objects.requireNonNull(operation);\n+        return new Filter() {\n+            @Override\n+            public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n+                operation.accept(exchange);\n+                chain.doFilter(exchange);\n+            }\n+            @Override\n+            public String description() {\n+                return description;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns a post-processing {@code Filter} with the given description and\n+     * operation.\n+     *\n+     * <p>The {@link Consumer operation} is the effective implementation of the\n+     * filter. It is executed for each {@code HttpExchange} after invoking\n+     * either the next filter in the chain or the exchange handler (if this\n+     * filter is the final filter in the chain).\n+     *\n+     * @apiNote\n+     * An afterHandler filter is typically used to examine the exchange state\n+     * rather than modifying it. The filter {@code operation} is executed after\n+     * {@link Filter.Chain#doFilter(HttpExchange)} is invoked, this means any\n+     * subsequent filters in the chain and the exchange handler have been\n+     * executed. The filter {@code operation} is not expected to handle the\n+     * exchange or {@linkplain HttpExchange#sendResponseHeaders(int, long) send the response headers}.\n+     * Doing so is likely to fail, since the exchange has commonly been handled\n+     * before the operation is invoked.\n+     *\n+     * <p> Example of adding a filter that logs the response code of all exchanges:\n+     * <pre>{@code\n+     *     var filter = Filter.afterHandler(\"Log response code\", e -> log(e.getResponseCode());\n+     *     httpContext.getFilters().add(filter);\n+     * }<\/pre>\n+     *\n+     * <p> Example of adding a sequence of afterHandler filters to a context:<br>\n+     * The order in which the filter operations are invoked is reverse to the\n+     * order in which the filters are added to the context's filter-list.\n+     *\n+     * <pre>{@code\n+     *     var a1Set = Filter.afterHandler(\"Set a1\", e -> e.setAttribute(\"a1\", \"some value\"));\n+     *     var a1Get = Filter.afterHandler(\"Get a1\", e -> doSomething(e.getAttribute(\"a1\")));\n+     *     httpContext.getFilters().addAll(List.of(a1Get, a1Set));\n+     * }<\/pre>\n+     * <p>The operation of {@code a1Get} will be invoked after the operation of\n+     * {@code a1Set} because {@code a1Get} was added before {@code a1Set}.\n+     *\n+     * @param description the string to be returned from {@link #description()}\n+     * @param operation the operation of the returned filter\n+     * @return a filter whose operation is invoked after the exchange is handled\n+     * @throws NullPointerException if any argument is null\n+     * @since 17\n+     *\/\n+    public static Filter afterHandler(String description,\n+                                      Consumer<HttpExchange> operation) {\n+        Objects.requireNonNull(description);\n+        Objects.requireNonNull(operation);\n+        return new Filter() {\n+            @Override\n+            public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n+                chain.doFilter(exchange);\n+                operation.accept(exchange);\n+            }\n+            @Override\n+            public String description() {\n+                return description;\n+            }\n+        };\n+    }\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Filter.java","additions":110,"deletions":1,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -662,1 +662,3 @@\n-            assert r.result.getStatus() == Status.CLOSED;\n+            assert r.result.getStatus() == Status.CLOSED\n+                    : \"status is: \" + r.result.getStatus()\n+                    + \", handshakeStatus is: \" + stat;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/SSLStreams.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for Filter static factory methods\n+ * @run testng\/othervm FilterTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import com.sun.net.httpserver.Filter;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.BeforeTest;\n+import static org.testng.Assert.*;\n+\n+public class FilterTest {\n+\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+    static final InetAddress LOOPBACK_ADDR = InetAddress.getLoopbackAddress();\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger logger = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            logger.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            logger.addHandler(ch);\n+        }\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        expectThrows(NPE, () -> Filter.beforeHandler(null, e -> e.getResponseHeaders().set(\"X-Foo\", \"Bar\")));\n+        expectThrows(NPE, () -> Filter.beforeHandler(\"Some description\", null));\n+        expectThrows(NPE, () -> Filter.afterHandler(null, HttpExchange::getResponseCode));\n+        expectThrows(NPE, () -> Filter.afterHandler(\"Some description\", null));\n+    }\n+\n+    @Test\n+    public void testDescription() {\n+        var desc = \"Some description\";\n+        var beforeFilter = Filter.beforeHandler(desc, HttpExchange::getRequestBody);\n+        var afterFilter = Filter.afterHandler(desc, HttpExchange::getResponseCode);\n+        assertEquals(desc, beforeFilter.description());\n+        assertEquals(desc, afterFilter.description());\n+    }\n+\n+    @Test\n+    public void testBeforeHandler() throws Exception {\n+        var handler = new EchoHandler();\n+        var filter = Filter.beforeHandler(\"Add x-foo response header\",\n+                e -> e.getResponseHeaders().set(\"x-foo\", \"bar\"));\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR,0), 10);\n+        server.createContext(\"\/\", handler).getFilters().add(filter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.headers().firstValue(\"x-foo\").orElseThrow(), \"bar\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testBeforeHandlerRepeated() throws Exception {\n+        var handler = new EchoHandler();\n+        var filter1 = Filter.beforeHandler(\"Add x-foo response header\",\n+                e -> e.getResponseHeaders().set(\"x-foo\", \"bar\"));\n+        var filter2 = Filter.beforeHandler(\"Update x-foo response header\",\n+                e -> e.getResponseHeaders().set(\"x-foo\", \"barbar\"));\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR, 0), 10);\n+        var context = server.createContext(\"\/\", handler);\n+        context.getFilters().add(filter1);\n+        context.getFilters().add(filter2);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.headers().firstValue(\"x-foo\").orElseThrow(), \"barbar\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testBeforeHandlerSendResponse() throws Exception {\n+        var handler = new NoResponseHandler();\n+        var filter = Filter.beforeHandler(\"Add x-foo response header and send response\",\n+                e -> {\n+                    try (InputStream is = e.getRequestBody();\n+                         OutputStream os = e.getResponseBody()) {\n+                        is.readAllBytes();\n+                        e.getResponseHeaders().set(\"x-foo\", \"bar\");\n+                        var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                        e.sendResponseHeaders(200, resp.length);\n+                        os.write(resp);\n+                    } catch (IOException ioe) {\n+                        ioe.printStackTrace(System.out);\n+                        throw new UncheckedIOException(ioe);\n+                    }\n+                });\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR, 0), 10);\n+        server.createContext(\"\/\", handler).getFilters().add(filter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.headers().firstValue(\"x-foo\").orElseThrow(), \"bar\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testAfterHandler() throws Exception {\n+        var handler = new EchoHandler();\n+        var respCode = new AtomicInteger();\n+        var filter = Filter.afterHandler(\"Log response code\",\n+                e -> respCode.set(e.getResponseCode()));\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR, 0), 10);\n+        server.createContext(\"\/\", handler).getFilters().add(filter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.statusCode(), respCode.get());\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testAfterHandlerRepeated() throws Exception {\n+        var handler = new EchoHandler();\n+        var attr = new AtomicReference<String>();\n+        final var value = \"some value\";\n+        var filter1 = Filter.afterHandler(\"Set attribute\",\n+                e -> e.setAttribute(\"test-attr\", value));\n+        var filter2 = Filter.afterHandler(\"Read attribute\",\n+                e -> attr.set((String) e.getAttribute(\"test-attr\")));\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR, 0), 10);\n+        var context = server.createContext(\"\/\", handler);\n+        context.getFilters().add(filter2);\n+        context.getFilters().add(filter1);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(attr.get(), value);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testAfterHandlerSendResponse() throws Exception {\n+        var handler = new NoResponseHandler();\n+        var respCode = new AtomicInteger();\n+        var filter = Filter.afterHandler(\"Log response code and send response\",\n+                e -> {\n+                    try (InputStream is = e.getRequestBody();\n+                         OutputStream os = e.getResponseBody()) {\n+                        is.readAllBytes();\n+                        var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                        e.sendResponseHeaders(200, resp.length);\n+                        os.write(resp);\n+                        respCode.set(e.getResponseCode());\n+                    } catch (IOException ioe) {\n+                        ioe.printStackTrace(System.out);\n+                        throw new UncheckedIOException(ioe);\n+                    }\n+                });\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR, 0), 10);\n+        server.createContext(\"\/\", handler).getFilters().add(filter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.statusCode(), respCode.get());\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testBeforeAndAfterHandler() throws Exception {\n+        var handler = new EchoHandler();\n+        var respCode = new AtomicInteger();\n+        var beforeFilter = Filter.beforeHandler(\"Add x-foo response header\",\n+                e -> e.getResponseHeaders().set(\"x-foo\", \"bar\"));\n+        var afterFilter = Filter.afterHandler(\"Log response code\",\n+                e -> respCode.set(e.getResponseCode()));\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR, 0), 10);\n+        var context = server.createContext(\"\/\", handler);\n+        context.getFilters().add(beforeFilter);\n+        context.getFilters().add(afterFilter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.statusCode(), respCode.get());\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.headers().firstValue(\"x-foo\").orElseThrow(), \"bar\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URI.create(\"http:\/\/localhost:%s\/%s\".formatted(server.getAddress().getPort(), path));\n+    }\n+\n+    \/**\n+     * A test handler that discards the request and sends a response\n+     *\/\n+    static class EchoHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                exchange.sendResponseHeaders(200, resp.length);\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A test handler that does nothing\n+     *\/\n+    static class NoResponseHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException { }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/FilterTest.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"}]}