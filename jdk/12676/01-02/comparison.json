{"files":[{"patch":"@@ -53,1 +53,1 @@\n-    extends HashMap<KeepAliveKey, ClientVector>\n+    extends HashMap<KeepAliveKey, KeepAliveCache.ClientVector>\n@@ -303,8 +303,0 @@\n-}\n-\n-\/* LIFO order for reusing HttpClients. Most recent entries at the front.\n- * If > maxConns are in use, discard oldest.\n- *\/\n-class ClientVector extends ArrayDeque<KeepAliveEntry> {\n-    @java.io.Serial\n-    private static final long serialVersionUID = -8680532108106489459L;\n@@ -312,2 +304,6 @@\n-    \/\/ sleep time in milliseconds, before cache clear\n-    int nap;\n+    \/* LIFO order for reusing HttpClients. Most recent entries at the front.\n+     * If > maxConns are in use, discard oldest.\n+     *\/\n+    class ClientVector extends ArrayDeque<KeepAliveEntry> {\n+        @java.io.Serial\n+        private static final long serialVersionUID = -8680532108106489459L;\n@@ -315,3 +311,2 @@\n-    ClientVector(int nap) {\n-        this.nap = nap;\n-    }\n+        \/\/ sleep time in milliseconds, before cache clear\n+        int nap;\n@@ -319,6 +314,2 @@\n-    \/* return a still valid, idle HttpClient *\/\n-    HttpClient get() {\n-        \/\/ check the most recent connection, use if still valid\n-        KeepAliveEntry e = peekFirst();\n-        if (e == null) {\n-            return null;\n+        ClientVector(int nap) {\n+            this.nap = nap;\n@@ -326,9 +317,20 @@\n-        long currentTime = System.currentTimeMillis();\n-        if ((currentTime - e.idleStartTime) > nap) {\n-            return null; \/\/ all connections stale - will be cleaned up later\n-        } else {\n-            pollFirst();\n-            if (KeepAliveCache.logger.isLoggable(PlatformLogger.Level.FINEST)) {\n-                String msg = \"cached HttpClient was idle for \"\n-                        + Long.toString(currentTime - e.idleStartTime);\n-                KeepAliveCache.logger.finest(msg);\n+\n+        \/* return a still valid, idle HttpClient *\/\n+        HttpClient get() {\n+            assert cacheLock.isHeldByCurrentThread();\n+            \/\/ check the most recent connection, use if still valid\n+            KeepAliveEntry e = peekFirst();\n+            if (e == null) {\n+                return null;\n+            }\n+            long currentTime = System.currentTimeMillis();\n+            if ((currentTime - e.idleStartTime) > nap) {\n+                return null; \/\/ all connections stale - will be cleaned up later\n+            } else {\n+                pollFirst();\n+                if (KeepAliveCache.logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+                    String msg = \"cached HttpClient was idle for \"\n+                            + Long.toString(currentTime - e.idleStartTime);\n+                    KeepAliveCache.logger.finest(msg);\n+                }\n+                return e.hc;\n@@ -336,1 +338,0 @@\n-            return e.hc;\n@@ -338,1 +339,0 @@\n-    }\n@@ -340,6 +340,11 @@\n-    HttpClient put(HttpClient h) {\n-        HttpClient staleClient = null;\n-        assert KeepAliveCache.getMaxConnections() > 0;\n-        if (size() >= KeepAliveCache.getMaxConnections()) {\n-            \/\/ remove oldest connection\n-            staleClient = removeLast().hc;\n+        HttpClient put(HttpClient h) {\n+            assert cacheLock.isHeldByCurrentThread();\n+            HttpClient staleClient = null;\n+            assert KeepAliveCache.getMaxConnections() > 0;\n+            if (size() >= KeepAliveCache.getMaxConnections()) {\n+                \/\/ remove oldest connection\n+                staleClient = removeLast().hc;\n+            }\n+            addFirst(new KeepAliveEntry(h, System.currentTimeMillis()));\n+            \/\/ close after releasing the locks\n+            return staleClient;\n@@ -347,4 +352,0 @@\n-        addFirst(new KeepAliveEntry(h, System.currentTimeMillis()));\n-        \/\/ close after releasing the locks\n-        return staleClient;\n-    }\n@@ -352,7 +353,7 @@\n-    \/*\n-     * Do not serialize this class!\n-     *\/\n-    @java.io.Serial\n-    private void writeObject(ObjectOutputStream stream) throws IOException {\n-        throw new NotSerializableException();\n-    }\n+        \/*\n+         * Do not serialize this class!\n+         *\/\n+        @java.io.Serial\n+        private void writeObject(ObjectOutputStream stream) throws IOException {\n+            throw new NotSerializableException();\n+        }\n@@ -360,5 +361,5 @@\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-        throws IOException, ClassNotFoundException\n-    {\n-        throw new NotSerializableException();\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            throw new NotSerializableException();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":54,"deletions":53,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1233,1 +1233,1 @@\n-            Class clientVectorClass = Class.forName(\"sun.net.www.http.ClientVector\");\n+            Class clientVectorClass = Class.forName(\"sun.net.www.http.KeepAliveCache$ClientVector\");\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/KeepAliveTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}