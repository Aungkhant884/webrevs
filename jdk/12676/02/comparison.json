{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.concurrent.locks.Lock;\n@@ -54,1 +53,1 @@\n-    extends HashMap<KeepAliveKey, ClientVector>\n+    extends HashMap<KeepAliveKey, KeepAliveCache.ClientVector>\n@@ -246,0 +245,5 @@\n+                if (isEmpty()) {\n+                    \/\/ cache not used in the last LIFETIME - exit\n+                    keepAliveTimer = null;\n+                    break;\n+                }\n@@ -251,12 +255,6 @@\n-                    v.lock();\n-                    try {\n-                        KeepAliveEntry e = v.peekLast();\n-                        while (e != null) {\n-                            if ((currentTime - e.idleStartTime) > v.nap) {\n-                                v.pollLast();\n-                                if (closeList == null) {\n-                                    closeList = new ArrayList<>();\n-                                }\n-                                closeList.add(e.hc);\n-                            } else {\n-                                break;\n+                    KeepAliveEntry e = v.peekLast();\n+                    while (e != null) {\n+                        if ((currentTime - e.idleStartTime) > v.nap) {\n+                            v.pollLast();\n+                            if (closeList == null) {\n+                                closeList = new ArrayList<>();\n@@ -264,1 +262,3 @@\n-                            e = v.peekLast();\n+                            closeList.add(e.hc);\n+                        } else {\n+                            break;\n@@ -266,0 +266,2 @@\n+                        e = v.peekLast();\n+                    }\n@@ -267,5 +269,2 @@\n-                        if (v.isEmpty()) {\n-                            keysToRemove.add(key);\n-                        }\n-                    } finally {\n-                        v.unlock();\n+                    if (v.isEmpty()) {\n+                        keysToRemove.add(key);\n@@ -287,1 +286,1 @@\n-        } while (!isEmpty());\n+        } while (keepAliveTimer == Thread.currentThread());\n@@ -304,1 +303,0 @@\n-}\n@@ -306,7 +304,6 @@\n-\/* LIFO order for reusing HttpClients. Most recent entries at the front.\n- * If > maxConns are in use, discard oldest.\n- *\/\n-class ClientVector extends ArrayDeque<KeepAliveEntry> {\n-    @java.io.Serial\n-    private static final long serialVersionUID = -8680532108106489459L;\n-    private final ReentrantLock lock = new ReentrantLock();\n+    \/* LIFO order for reusing HttpClients. Most recent entries at the front.\n+     * If > maxConns are in use, discard oldest.\n+     *\/\n+    class ClientVector extends ArrayDeque<KeepAliveEntry> {\n+        @java.io.Serial\n+        private static final long serialVersionUID = -8680532108106489459L;\n@@ -314,2 +311,2 @@\n-    \/\/ sleep time in milliseconds, before cache clear\n-    int nap;\n+        \/\/ sleep time in milliseconds, before cache clear\n+        int nap;\n@@ -317,3 +314,3 @@\n-    ClientVector(int nap) {\n-        this.nap = nap;\n-    }\n+        ClientVector(int nap) {\n+            this.nap = nap;\n+        }\n@@ -321,4 +318,3 @@\n-    \/* return a still valid, idle HttpClient *\/\n-    HttpClient get() {\n-        lock();\n-        try {\n+        \/* return a still valid, idle HttpClient *\/\n+        HttpClient get() {\n+            assert cacheLock.isHeldByCurrentThread();\n@@ -342,2 +338,0 @@\n-        } finally {\n-            unlock();\n@@ -345,1 +339,0 @@\n-    }\n@@ -347,4 +340,3 @@\n-    HttpClient put(HttpClient h) {\n-        HttpClient staleClient = null;\n-        lock();\n-        try {\n+        HttpClient put(HttpClient h) {\n+            assert cacheLock.isHeldByCurrentThread();\n+            HttpClient staleClient = null;\n@@ -357,2 +349,2 @@\n-        } finally {\n-            unlock();\n+            \/\/ close after releasing the locks\n+            return staleClient;\n@@ -360,7 +352,0 @@\n-        \/\/ close after releasing the locks\n-        return staleClient;\n-    }\n-\n-    final void lock() {\n-        lock.lock();\n-    }\n@@ -368,11 +353,7 @@\n-    final void unlock() {\n-        lock.unlock();\n-    }\n-\n-    \/*\n-     * Do not serialize this class!\n-     *\/\n-    @java.io.Serial\n-    private void writeObject(ObjectOutputStream stream) throws IOException {\n-        throw new NotSerializableException();\n-    }\n+        \/*\n+         * Do not serialize this class!\n+         *\/\n+        @java.io.Serial\n+        private void writeObject(ObjectOutputStream stream) throws IOException {\n+            throw new NotSerializableException();\n+        }\n@@ -380,5 +361,5 @@\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-        throws IOException, ClassNotFoundException\n-    {\n-        throw new NotSerializableException();\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            throw new NotSerializableException();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":52,"deletions":71,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1233,1 +1233,1 @@\n-            Class clientVectorClass = Class.forName(\"sun.net.www.http.ClientVector\");\n+            Class clientVectorClass = Class.forName(\"sun.net.www.http.KeepAliveCache$ClientVector\");\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/KeepAliveTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}