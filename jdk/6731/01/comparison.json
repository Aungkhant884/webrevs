{"files":[{"patch":"@@ -124,1 +124,0 @@\n-        ResourceMark rm;\n@@ -1045,1 +1044,6 @@\n-\/\/ a utility class for checking file header\n+\/\/ A utility class for reading\/validating the GenericCDSFileMapHeader portion of\n+\/\/ a CDS archive's header. The file header of all CDS archives with versions from\n+\/\/ CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION (12) are guaranteed to always start\n+\/\/ with GenericCDSFileMapHeader. This makes it possible to read important information\n+\/\/ from a CDS archive created by a different version of HotSpot, so that we can\n+\/\/ automatically regenerate the archive as necessary (JDK-8261455).\n@@ -1048,1 +1052,3 @@\n-  GenericCDSFileMapHeader _header;\n+  bool _is_valid;\n+  GenericCDSFileMapHeader* _header;\n+  const char* _base_archive_name;\n@@ -1051,3 +1057,1 @@\n-  FileHeaderHelper() {\n-    _fd = -1;\n-  }\n+  FileHeaderHelper() : _fd(-1), _is_valid(false), _header(nullptr), _base_archive_name(nullptr) {}\n@@ -1062,0 +1066,1 @@\n+    log_info(cds)(\"Opening shared archive: %s\", archive_name);\n@@ -1064,0 +1069,1 @@\n+      FileMapInfo::fail_continue(\"Specified shared archive not found (%s)\", archive_name);\n@@ -1072,0 +1078,4 @@\n+\n+\n+    \/\/ First read the generic header so we know the exact size of the actual header.\n+    GenericCDSFileMapHeader gen_header;\n@@ -1074,1 +1084,29 @@\n-    size_t n = os::read(fd, (void*)&_header, (unsigned int)size);\n+    size_t n = os::read(fd, (void*)&gen_header, (unsigned int)size);\n+    if (n != size) {\n+      FileMapInfo::fail_continue(\"Unable to read generic CDS file map header from shared archive\");\n+      return false;\n+    }\n+\n+    if (gen_header._magic != CDS_ARCHIVE_MAGIC &&\n+        gen_header._magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+      FileMapInfo::fail_continue(\"The shared archive file has a bad magic number: %#x\", gen_header._magic);\n+      return false;\n+    }\n+\n+    if (gen_header._version < CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION) {\n+      FileMapInfo::fail_continue(\"Cannot handle shared archive file version %d. Must be at least %d\",\n+                                 gen_header._version, CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION);\n+      return false;\n+    }\n+\n+    size_t filelen = os::lseek(fd, 0, SEEK_END);\n+    if (gen_header._header_size >= filelen) {\n+      FileMapInfo::fail_continue(\"Archive file header larger than archive file\");\n+      return false;\n+    }\n+\n+    \/\/ Read the actual header and perform more checks\n+    size = gen_header._header_size;\n+    _header = (GenericCDSFileMapHeader*)NEW_C_HEAP_ARRAY(char, size, mtInternal);\n+    lseek(fd, 0, SEEK_SET);\n+    n = os::read(fd, (void*)_header, (unsigned int)size);\n@@ -1076,1 +1114,1 @@\n-      vm_exit_during_initialization(\"Unable to read generic CDS file map header from shared archive\");\n+      FileMapInfo::fail_continue(\"Unable to read actual CDS file map header from shared archive\");\n@@ -1079,0 +1117,11 @@\n+\n+    if (!check_crc()) {\n+      return false;\n+    }\n+\n+    if (!check_and_init_base_archive_name()) {\n+      return false;\n+    }\n+\n+    \/\/ All fields in the GenericCDSFileMapHeader has been validated.\n+    _is_valid = true;\n@@ -1083,14 +1132,20 @@\n-    return &_header;\n-  }\n-\n-  char* read_base_archive_name() {\n-    assert(_fd != -1, \"Archive should be open\");\n-    size_t name_size = _header._base_archive_name_size;\n-    assert(name_size != 0, \"For non-default base archive, name size should be non-zero!\");\n-    char* base_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n-    lseek(_fd, _header._base_archive_name_offset, SEEK_SET); \/\/ position to correct offset.\n-    size_t n = os::read(_fd, base_name, (unsigned int)name_size);\n-    if (n != name_size) {\n-      log_info(cds)(\"Unable to read base archive name from archive\");\n-      FREE_C_HEAP_ARRAY(char, base_name);\n-      return nullptr;\n+    assert(_header != nullptr && _is_valid, \"must be a valid archive file\");\n+    return _header;\n+  }\n+\n+  const char* base_archive_name() {\n+    assert(_header != nullptr && _is_valid, \"must be a valid archive file\");\n+    return _base_archive_name;\n+  }\n+\n+ private:\n+  bool check_crc() {\n+    if (VerifySharedSpaces) {\n+      FileMapHeader* header = (FileMapHeader*)_header;\n+      int actual_crc = header->compute_crc();\n+      if (actual_crc != header->crc()) {\n+        log_info(cds)(\"_crc expected: %d\", header->crc());\n+        log_info(cds)(\"       actual: %d\", actual_crc);\n+        FileMapInfo::fail_continue(\"Header checksum verification failed.\");\n+        return false;\n+      }\n@@ -1098,4 +1153,12 @@\n-    if (base_name[name_size - 1] != '\\0' || strlen(base_name) != name_size - 1) {\n-      log_info(cds)(\"Base archive name is damaged\");\n-      FREE_C_HEAP_ARRAY(char, base_name);\n-      return nullptr;\n+    return true;\n+  }\n+\n+  bool check_and_init_base_archive_name() {\n+    unsigned int name_offset = _header->_base_archive_name_offset;\n+    unsigned int name_size   = _header->_base_archive_name_size;\n+    unsigned int header_size = _header->_header_size;\n+\n+    if (name_offset + name_size < name_offset) {\n+      FileMapInfo::fail_continue(\"base_archive_name offset\/size overflow: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n+                                 name_offset, name_size);\n+      return false;\n@@ -1103,4 +1166,36 @@\n-    if (!os::file_exists(base_name)) {\n-      log_info(cds)(\"Base archive %s does not exist\", base_name);\n-      FREE_C_HEAP_ARRAY(char, base_name);\n-      return nullptr;\n+    if (_header->_magic == CDS_ARCHIVE_MAGIC) {\n+      if (name_offset != 0) {\n+        FileMapInfo::fail_continue(\"static shared archive must have zero _base_archive_name_offset\");\n+        return false;\n+      }\n+      if (name_size != 0) {\n+        FileMapInfo::fail_continue(\"static shared archive must have zero _base_archive_name_size\");\n+        return false;\n+      }\n+    } else {\n+      assert(_header->_magic == CDS_DYNAMIC_ARCHIVE_MAGIC, \"must be\");\n+      if ((name_size == 0 && name_offset != 0) ||\n+          (name_size != 0 && name_offset == 0)) {\n+        \/\/ If either is zero, both must be zero. This indicates that we are using the default base archive.\n+        FileMapInfo::fail_continue(\"Invalid base_archive_name offset\/size: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n+                                   name_offset, name_size);\n+        return false;\n+      }\n+      if (name_size > 0) {\n+        if (name_offset + name_size > header_size) {\n+          FileMapInfo::fail_continue(\"Invalid base_archive_name offset\/size (out of range): \"\n+                                     UINT32_FORMAT \" + \" UINT32_FORMAT \" > \" UINT32_FORMAT ,\n+                                     name_offset, name_size, header_size);\n+          return false;\n+        }\n+        const char* name = ((const char*)_header) + _header->_base_archive_name_offset;\n+        if (name[name_size - 1] != '\\0' || strlen(name) != name_size - 1) {\n+          FileMapInfo::fail_continue(\"Base archive name is damaged\");\n+          return false;\n+        }\n+        if (!os::file_exists(name)) {\n+          FileMapInfo::fail_continue(\"Base archive %s does not exist\", name);\n+          return false;\n+        }\n+        _base_archive_name = name;\n+      }\n@@ -1108,1 +1203,1 @@\n-    return base_name;\n+    return true;\n@@ -1115,3 +1210,1 @@\n-    \/\/ do not vm_exit_during_initialization here because Arguments::init_shared_archive_paths()\n-    \/\/ requires a shared archive name. The open_for_read() function will log a message regarding\n-    \/\/ failure in opening a shared archive.\n+    \/\/ Any errors are reported by fail_continue().\n@@ -1124,6 +1217,1 @@\n-      vm_exit_during_initialization(\"Not a base shared archive\", archive_name);\n-      return false;\n-    }\n-    if (header->_base_archive_name_offset != 0) {\n-      log_info(cds)(\"_base_archive_name_offset should be 0\");\n-      log_info(cds)(\"_base_archive_name_offset = \" UINT32_FORMAT, header->_base_archive_name_offset);\n+      fail_continue(\"Not a base shared archive: %s\", archive_name);\n@@ -1134,1 +1222,1 @@\n-      vm_exit_during_initialization(\"Not a top shared archive\", archive_name);\n+      fail_continue(\"Not a top shared archive: %s\", archive_name);\n@@ -1137,15 +1225,0 @@\n-    unsigned int name_size = header->_base_archive_name_size;\n-    unsigned int name_offset = header->_base_archive_name_offset;\n-    unsigned int header_size = header->_header_size;\n-    if (name_offset + name_size != header_size) {\n-      log_info(cds)(\"_header_size should be equal to _base_archive_name_offset plus _base_archive_name_size\");\n-      log_info(cds)(\"  _base_archive_name_size   = \" UINT32_FORMAT, name_size);\n-      log_info(cds)(\"  _base_archive_name_offset = \" UINT32_FORMAT, name_offset);\n-      log_info(cds)(\"  _header_size              = \" UINT32_FORMAT, header_size);\n-      return false;\n-    }\n-    char* base_name = file_helper.read_base_archive_name();\n-    if (base_name == nullptr) {\n-      return false;\n-    }\n-    FREE_C_HEAP_ARRAY(char, base_name);\n@@ -1156,0 +1229,7 @@\n+\/\/ Return value:\n+\/\/ false:\n+\/\/      <archive_name> is not a valid archive. *base_archive_name is set to null.\n+\/\/ true && (*base_archive_name) == NULL:\n+\/\/      <archive_name> is a valid static archive.\n+\/\/ true && (*base_archive_name) != NULL:\n+\/\/      <archive_name> is a valid dynamic archive.\n@@ -1159,0 +1239,2 @@\n+  *base_archive_name = NULL;\n+\n@@ -1164,2 +1246,2 @@\n-    \/\/ Not a dynamic header, no need to proceed further.\n-    return false;\n+    assert(header->_magic == CDS_ARCHIVE_MAGIC, \"must be\");\n+    return true;\n@@ -1168,7 +1250,2 @@\n-  if ((header->_base_archive_name_size == 0 && header->_base_archive_name_offset != 0) ||\n-      (header->_base_archive_name_size != 0 && header->_base_archive_name_offset == 0)) {\n-    fail_continue(\"Default base archive not set correct\");\n-    return false;\n-  }\n-  if (header->_base_archive_name_size == 0 &&\n-      header->_base_archive_name_offset == 0) {\n+  const char* base = file_helper.base_archive_name();\n+  if (base == nullptr) {\n@@ -1177,5 +1254,1 @@\n-    \/\/ read the base archive name\n-    *base_archive_name = file_helper.read_base_archive_name();\n-    if (*base_archive_name == nullptr) {\n-      return false;\n-    }\n+    *base_archive_name = os::strdup_check_oom(base);\n@@ -1183,0 +1256,1 @@\n+\n@@ -1250,10 +1324,0 @@\n-  if (VerifySharedSpaces) {\n-    int expected_crc = header()->compute_crc();\n-    if (expected_crc != header()->crc()) {\n-      log_info(cds)(\"_crc expected: %d\", expected_crc);\n-      log_info(cds)(\"       actual: %d\", header()->crc());\n-      FileMapInfo::fail_continue(\"Header checksum verification failed.\");\n-      return false;\n-    }\n-  }\n-\n@@ -1297,1 +1361,1 @@\n-      fail_continue(\"Specified shared archive not found (%s).\", _full_path);\n+      fail_continue(\"Specified shared archive not found (%s)\", _full_path);\n@@ -1299,1 +1363,1 @@\n-      fail_continue(\"Failed to open shared archive file (%s).\",\n+      fail_continue(\"Failed to open shared archive file (%s)\",\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":146,"deletions":82,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#define CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION 12\n@@ -62,1 +63,2 @@\n-\/\/ This portion of the archive file header must remain unchanged for _version >= 12.\n+\/\/ This portion of the archive file header must remain unchanged for\n+\/\/ _version >= CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION (12).\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3423,1 +3423,1 @@\n-jint Arguments::set_shared_spaces_flags_and_archive_paths() {\n+void Arguments::set_shared_spaces_flags_and_archive_paths() {\n@@ -3433,1 +3433,5 @@\n-  init_shared_archive_paths();\n+  \/\/\n+  \/\/ UseSharedSpaces may be disabled if -XX:SharedArchiveFile is invalid.\n+  if (DumpSharedSpaces || UseSharedSpaces) {\n+    init_shared_archive_paths();\n+  }\n@@ -3435,1 +3439,0 @@\n-  return JNI_OK;\n@@ -3484,1 +3487,3 @@\n-  FileMapInfo::check_archive((const char*)cur_path, true \/*is_static*\/);\n+  if (!FileMapInfo::check_archive((const char*)cur_path, true \/*is_static*\/)) {\n+    return;\n+  }\n@@ -3496,1 +3501,3 @@\n-  FileMapInfo::check_archive((const char*)cur_path, false \/*is_static*\/);\n+  if (!FileMapInfo::check_archive((const char*)cur_path, false \/*is_static*\/)) {\n+    return;\n+  }\n@@ -3540,1 +3547,1 @@\n-        char* temp_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n+        char* base_archive_path = NULL;\n@@ -3542,1 +3549,1 @@\n-          FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &SharedArchivePath);\n+          FileMapInfo::get_base_archive_name_from_header(SharedArchiveFile, &base_archive_path);\n@@ -3544,1 +3551,4 @@\n-          SharedArchivePath = temp_archive_path;\n+          no_shared_spaces(\"invalid archive\");\n+        } else if (base_archive_path == NULL) {\n+          \/\/ User has specified a single archive, which is a static archive.\n+          SharedArchivePath = const_cast<char *>(SharedArchiveFile);\n@@ -3546,1 +3556,3 @@\n-          SharedDynamicArchivePath = temp_archive_path;\n+          \/\/ User has specified a single archive, which is a dynamic archive.\n+          SharedDynamicArchivePath = const_cast<char *>(SharedArchiveFile);\n+          SharedArchivePath = base_archive_path; \/\/ has been c-heap allocated.\n@@ -3551,0 +3563,4 @@\n+        if (SharedArchivePath == NULL) {\n+          assert(SharedDynamicArchivePath == NULL, \"must be\");\n+          no_shared_spaces(\"invalid archive\");\n+        }\n@@ -4023,2 +4039,1 @@\n-  result = set_shared_spaces_flags_and_archive_paths();\n-  if (result != JNI_OK) return result;\n+  set_shared_spaces_flags_and_archive_paths();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -369,1 +369,1 @@\n-  static jint set_shared_spaces_flags_and_archive_paths();\n+  static void set_shared_spaces_flags_and_archive_paths();\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,2 @@\n-        String[] execArgs = {\"-Xlog:cds=debug\", \"-cp\", jarFile, \"Hello\"};\n+        \/\/ disable VerifySharedSpaces, it may be turned on by jtreg args\n+        String[] execArgs = {\"-Xlog:cds=debug\", \"-XX:-VerifySharedSpaces\", \"-cp\", jarFile, \"Hello\"};\n@@ -175,1 +176,1 @@\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x00000000);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x3FFFFFFF);\n@@ -183,0 +184,11 @@\n+        System.out.println(\"\\n2e. Corrupt _version, should fail\\n\");\n+        String modVersion2 = startNewArchive(\"modify-version2\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modVersion2);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x00000000);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n+        output.shouldContain(\"Cannot handle shared archive file version 0. Must be at least 12\");\n+        output.shouldNotContain(\"Checksum verification failed\");\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI ArchiveConsistency\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI ArchiveConsistency on\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI ArchiveConsistency auto\n@@ -43,0 +44,2 @@\n+    private static final String HELLO_WORLD = \"Hello World\";\n+    private static boolean isAuto;\n@@ -45,0 +48,5 @@\n+        if (args.length != 1 || (!args[0].equals(\"on\") && !args[0].equals(\"auto\"))) {\n+            throw new RuntimeException(\"Must have one arg either of \\\"on\\\" or \\\"auto\\\"\");\n+        }\n+        isAuto = args[0].equals(\"auto\");\n+        setAutoMode(isAuto);\n@@ -56,0 +64,2 @@\n+    static boolean VERIFY_CRC = false;\n+\n@@ -57,1 +67,1 @@\n-                       String jarName, String mainClassName, int exitValue,\n+                       String jarName, String mainClassName, int expectedExitValue,\n@@ -62,1 +72,1 @@\n-                \"-XX:+VerifySharedSpaces\",\n+                VERIFY_CRC ? \"-XX:+VerifySharedSpaces\" : \"-XX:-VerifySharedSpaces\",\n@@ -66,1 +76,1 @@\n-        if (exitValue == 0) {\n+        if (expectedExitValue == 0) {\n@@ -71,0 +81,1 @@\n+                output.shouldContain(HELLO_WORLD);\n@@ -77,0 +88,1 @@\n+                output.shouldContain(\"Unable to use shared archive\");\n@@ -81,0 +93,4 @@\n+    private static void startTest(String str) {\n+        System.out.println(\"\\n\" + str);\n+    }\n+\n@@ -97,2 +113,1 @@\n-        \/\/ 1. Modify the CRC values in the header of the top archive.\n-        System.out.println(\"\\n1. Modify the CRC values in the header of the top archive\");\n+        startTest(\"1. Modify the CRC values in the header of the top archive\");\n@@ -103,0 +118,1 @@\n+        VERIFY_CRC = true;\n@@ -104,3 +120,3 @@\n-               appJar, mainClass, 1,\n-               new String[] {\"Header checksum verification failed\",\n-                             \"Unable to use shared archive\"});\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Header checksum verification failed\");\n+        VERIFY_CRC = false;\n@@ -108,2 +124,1 @@\n-        \/\/ 2. Make header size larger than the archive size\n-        System.out.println(\"\\n2. Make header size larger than the archive size\");\n+        startTest(\"2. Make header size larger than the archive size\");\n@@ -114,3 +129,2 @@\n-               appJar, mainClass, 1,\n-               new String[] {\"_header_size should be equal to _base_archive_name_offset plus _base_archive_name_size\",\n-                             \"Unable to use shared archive\"});\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Archive file header larger than archive file\");\n@@ -118,2 +132,1 @@\n-        \/\/ 3. Make base archive path offset beyond of header size\n-        System.out.println(\"\\n3. Make base archive path offset beyond of header size.\");\n+        startTest(\"3. Make base archive name offset beyond of header size.\");\n@@ -126,4 +139,2 @@\n-               appJar, mainClass, 1,\n-               new String[] {\"_header_size should be equal to _base_archive_name_offset plus _base_archive_name_size\",\n-                             \"The shared archive file has an incorrect header size\",\n-                             \"Unable to use shared archive\"});\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Invalid base_archive_name offset\/size (out of range)\");\n@@ -131,2 +142,1 @@\n-        \/\/ 4. Make base archive path offset points to middle of name size\n-        System.out.println(\"\\n4. Make base archive path offset points to middle of name size\");\n+        startTest(\"4. Make base archive name offset points to middle of the base archive name\");\n@@ -140,4 +150,2 @@\n-               appJar, mainClass, 1,\n-               new String[] {\"An error has occurred while processing the shared archive file.\",\n-                             \"Header checksum verification failed\",\n-                             \"Unable to use shared archive\"});\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Base archive name is damaged\");\n@@ -145,2 +153,1 @@\n-        \/\/ 5. Make base archive name not terminated with '\\0'\n-        System.out.println(\"\\n5. Make base archive name not terminated with '\\0'\");\n+        startTest(\"5. Make base archive name not terminated with '\\0'\");\n@@ -155,3 +162,2 @@\n-               appJar, mainClass, 1,\n-               new String[] {\"Base archive name is damaged\",\n-                             \"Header checksum verification failed\"});\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Base archive name is damaged\");\n@@ -159,2 +165,1 @@\n-        \/\/ 6. Modify base archive name to a file that doesn't exist.\n-        System.out.println(\"\\n6. Modify base archive name to a file that doesn't exist\");\n+        startTest(\"6. Modify base archive name to a file that doesn't exist\");\n@@ -173,3 +178,27 @@\n-               appJar, mainClass, 1,\n-               new String[] {\"Base archive \" + badName + \" does not exist\",\n-                             \"Header checksum verification failed\"});\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Base archive \" + badName + \" does not exist\");\n+\n+        \/\/ Following three tests:\n+        \/\/   -XX:SharedArchiveFile=non-exist-base.jsa:top.jsa\n+        \/\/   -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\n+        \/\/   -XX:SharedArchiveFile=non-exist-base.jsa:non-exist-top.jsa\n+        startTest(\"7. Non-exist base archive\");\n+        String nonExistBase = \"non-exist-base.jsa\";\n+        File nonExistBaseFile = new File(nonExistBase);\n+        nonExistBaseFile.delete();\n+        runTwo(nonExistBase, topArchiveName,\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Specified shared archive not found (\" + nonExistBase + \")\");\n+\n+        startTest(\"8. Non-exist top archive\");\n+        String nonExistTop = \"non-exist-top.jsa\";\n+        File nonExistTopFile = new File(nonExistTop);\n+        nonExistTopFile.delete();\n+        runTwo(baseArchiveName, nonExistTop,\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Specified shared archive not found (\" + nonExistTop + \")\");\n+\n+        startTest(\"9. nost-exist-base and non-exist-top\");\n+        runTwo(nonExistBase, nonExistTop,\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Specified shared archive not found (\" + nonExistBase + \")\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":65,"deletions":36,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    private static boolean autoMode = false;  \/\/ -Xshare:auto\n@@ -50,0 +51,1 @@\n+    public static void setAutoMode(boolean val) { autoMode = val; }\n@@ -186,1 +188,1 @@\n-            \"-Xshare:on\",\n+            autoMode ? \"-Xshare:auto\" : \"-Xshare:on\",\n@@ -205,1 +207,1 @@\n-            \"-Xshare:on\",\n+            autoMode ? \"-Xshare:auto\" : \"-Xshare:on\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveTestBase.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}