{"files":[{"patch":"@@ -37,0 +37,3 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.annotation.Stable;\n@@ -38,1 +41,0 @@\n-import jdk.internal.vm.annotation.*;\n@@ -122,1 +124,1 @@\n- * {@code childTask2()}, and {@code childTask3()} will read the value \"duke\".\n+ * {@code childTask2()}, and {@code childTask3()} will read the value \"{@code duke}\".\n@@ -153,6 +155,5 @@\n- * <p>Because the scoped-value per-thread cache is small, you should\n- * try to minimize the number of bound scoped values in\n- * use. For example, if you need to pass a number of values in this\n- * way, it makes sense to create a record class to hold those values,\n- * and then bind a single `ScopedValue` to an instance of that\n- * record.\n+ * <p>Because the scoped-value per-thread cache is small, clients\n+ * should minimize the number of bound scoped values in use. For\n+ * example, if it is necessary to pass a number of values in this way,\n+ * it makes sense to create a record class to hold those values, and\n+ * then bind a single `ScopedValue` to an instance of that record.\n@@ -160,2 +161,3 @@\n- * <p>For this incubator release, we have provided some system properties\n- * to tune the performance of scoped values.\n+ * <p>For this incubator release, the reference implementation\n+ * provides some system properties to tune the performance of scoped\n+ * values.\n@@ -179,5 +181,5 @@\n- * ScopedValue.cacheSize}, this is a space versus speed trade-off: if\n- * you have a great many virtual threads that are blocked most of the\n- * time, setting this property to {@code false} might result in a\n- * useful memory saving, but each virtual thread's scoped-value cache\n- * would have to be regenerated after a blocking operation.\n+ * ScopedValue.cacheSize}, this is a space versus speed trade-off: in\n+ * situations where many virtual threads are blocked most of the time,\n+ * setting this property to {@code false} might result in a useful\n+ * memory saving, but each virtual thread's scoped-value cache would\n+ * have to be regenerated after a blocking operation.\n@@ -256,3 +258,3 @@\n-     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in\n-     * the mapping bound to values. The following example runs an operation with k1\n-     * bound (or rebound) to v1, and k2 bound (or rebound) to v2.\n+     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in the\n+     * mapping bound to values. The following example runs an operation with {@code k1}\n+     * bound (or rebound) to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n@@ -307,1 +309,1 @@\n-         * @param key the ScopedValue key\n+         * @param key the {@code ScopedValue} key\n@@ -453,2 +455,2 @@\n-     * values. The following example runs an operation with k1 bound (or rebound) to v1,\n-     * and k2 bound (or rebound) to v2.\n+     * values. The following example runs an operation with {@code k1} bound (or rebound)\n+     * to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n@@ -460,1 +462,1 @@\n-     * @param key the ScopedValue key\n+     * @param key the {@code ScopedValue} key\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopedValue.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -213,2 +213,2 @@\n- * StructuredTaskScopes form a tree where parent-child relations are established\n- * implicitly when opening a new task scope:\n+ * Task scopes form a tree where parent-child relations are established implicitly when\n+ * opening a new task scope:\n@@ -225,0 +225,3 @@\n+ * The <i>descendants<\/i> of a task scope that are child task scopes that it is a parent\n+ * of, plus the descendants of the child task scopes, recursively.\n+ *\n@@ -233,5 +236,5 @@\n- * value {@code USERNAME} is bound to the value \"duke\". A StructuredTaskScope is created\n- * and its {@code fork} method invoked to start a thread to execute {@code childTask}.\n- * The thread inherits the scoped value <em>bindings<\/em> captured when creating the\n- * task scope. The code in {@code childTask} uses the value of the scoped value and so\n- * reads the value \"duke\".\n+ * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n+ * is created and its {@code fork} method invoked to start a thread to execute {@code\n+ * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n+ * creating the task scope. The code in {@code childTask} uses the value of the scoped\n+ * value and so reads the value \"{@code duke}\".\n@@ -415,5 +418,6 @@\n-     * completes with a result or exception. If the Future's {@link Future#cancel(boolean)\n-     * cancel} method is used the cancel a task before the task scope is shut down, then\n-     * the {@code handleComplete} method is run by the thread that invokes {@code cancel}.\n-     * If the task scope shuts down at or around the same time that the task completes or\n-     * is cancelled then the {@code handleComplete} method may or may not be invoked.\n+     * completes with a result or exception. If the {@code Future}'s {@link\n+     * Future#cancel(boolean) cancel} method is used to cancel a task before the task scope\n+     * is shut down, then the {@code handleComplete} method is run by the thread that\n+     * invokes {@code cancel}. If the task scope shuts down at or around the same time\n+     * that the task completes or is cancelled then the {@code handleComplete} method may\n+     * or may not be invoked.\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -801,4 +801,0 @@\n-############################################################################\n-\n-# Loom, fibers branch\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}