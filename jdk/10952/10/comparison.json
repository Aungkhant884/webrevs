{"files":[{"patch":"@@ -197,2 +197,0 @@\n-JVM_ExtentLocalCache\n-JVM_SetExtentLocalCache\n@@ -228,0 +226,6 @@\n+\n+# Scoped values\n+JVM_EnsureMaterializedForStackWalk_func\n+JVM_FindScopedValueBindings\n+JVM_ScopedValueCache\n+JVM_SetScopedValueCache\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2167,1 +2167,0 @@\n-    $$$emit8$primary;\n@@ -2170,0 +2169,1 @@\n+      $$$emit8$primary;\n@@ -2173,0 +2173,3 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      __ addr_nop_5();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n@@ -2174,0 +2177,1 @@\n+      $$$emit8$primary;\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1431,2 +1431,2 @@\n-void LIRGenerator::do_extentLocalCache(Intrinsic* x) {\n-  do_JavaThreadField(x, JavaThread::extentLocalCache_offset());\n+void LIRGenerator::do_scopedValueCache(Intrinsic* x) {\n+  do_JavaThreadField(x, JavaThread::scopedValueCache_offset());\n@@ -2951,1 +2951,1 @@\n-  case vmIntrinsics::_extentLocalCache: do_extentLocalCache(x); break;\n+  case vmIntrinsics::_scopedValueCache: do_scopedValueCache(x); break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  void do_extentLocalCache(Intrinsic* x);\n+  void do_scopedValueCache(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1685,1 +1685,1 @@\n-int java_lang_Thread::_extentLocalBindings_offset;\n+int java_lang_Thread::_scopedValueBindings_offset;\n@@ -1698,1 +1698,1 @@\n-  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n+  macro(_scopedValueBindings_offset, k, \"scopedValueBindings\", object_signature, false);\n@@ -1731,2 +1731,4 @@\n-void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n-  java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n+void java_lang_Thread::clear_scopedValueBindings(oop java_thread) {\n+  if (java_thread != NULL) {\n+    java_thread->obj_field_put(_scopedValueBindings_offset, NULL);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-  static int _extentLocalBindings_offset;\n+  static int _scopedValueBindings_offset;\n@@ -401,2 +401,2 @@\n-  \/\/ Clear all extent local bindings on error\n-  static void clear_extentLocalBindings(oop java_thread);\n+  \/\/ Clear all scoped value bindings on error\n+  static void clear_scopedValueBindings(oop java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n@@ -130,2 +130,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n@@ -268,2 +268,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                                                                                                                       \\\n+                                                                                                                        \\\n@@ -289,6 +289,9 @@\n-  do_intrinsic(_extentLocalCache,          java_lang_Thread,       extentLocalCache_name, extentLocalCache_signature, F_SN) \\\n-   do_name(     extentLocalCache_name,                            \"extentLocalCache\")                                     \\\n-   do_signature(extentLocalCache_signature,                       \"()[Ljava\/lang\/Object;\")                               \\\n-  do_intrinsic(_setExtentLocalCache,       java_lang_Thread,       setExtentLocalCache_name, setExtentLocalCache_signature, F_SN) \\\n-   do_name(     setExtentLocalCache_name,                         \"setExtentLocalCache\")                                  \\\n-   do_signature(setExtentLocalCache_signature,                    \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_scopedValueCache,         java_lang_Thread,       scopedValueCache_name, scopedValueCache_signature, F_SN) \\\n+   do_name(     scopedValueCache_name,                           \"scopedValueCache\")                                    \\\n+   do_signature(scopedValueCache_signature,                      \"()[Ljava\/lang\/Object;\")                               \\\n+  do_intrinsic(_setScopedValueCache,      java_lang_Thread,       setScopedValueCache_name, setScopedValueCache_signature, F_SN) \\\n+   do_name(     setScopedValueCache_name,                        \"setScopedValueCache\")                                 \\\n+   do_signature(setScopedValueCache_signature,                   \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_findScopedValueBindings,  java_lang_Thread,       findScopedValueBindings_name, void_object_signature, F_SN) \\\n+   do_name(     findScopedValueBindings_name,                    \"findScopedValueBindings\")                             \\\n+                                                                                                                        \\\n@@ -334,0 +337,3 @@\n+  do_intrinsic(_ensureMaterializedForStackWalk, java_lang_Thread, ensureMaterializedForStackWalk_name, object_void_signature, F_SN)  \\\n+   do_name(     ensureMaterializedForStackWalk_name,              \"ensureMaterializedForStackWalk\")                     \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -159,0 +159,2 @@\n+  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n+  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n@@ -399,0 +401,2 @@\n+  template(call_method_name,                          \"call\")                                     \\\n+  template(runWith_method_name,                       \"runWith\")                                  \\\n@@ -608,0 +612,1 @@\n+  template(runnable_void_signature,                   \"(Ljava\/lang\/Runnable;)V\")                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-JVM_ExtentLocalCache(JNIEnv *env, jclass threadClass);\n+JVM_ScopedValueCache(JNIEnv *env, jclass threadClass);\n@@ -316,1 +316,4 @@\n-JVM_SetExtentLocalCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+JVM_SetScopedValueCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+\n+JNIEXPORT jobject JNICALL\n+JVM_FindScopedValueBindings(JNIEnv *env, jclass threadClass);\n@@ -745,0 +748,2 @@\n+JNIEXPORT void JNICALL\n+JVM_EnsureMaterializedForStackWalk_func(JNIEnv* env, jobject vthread, jobject value);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -375,0 +375,6 @@\n+  \/\/ Remove the ScopedValue cache in case we got a StackOverflowError\n+  \/\/ while we were trying to remove ScopedValue bindings.\n+  current->set_scopedValueCache(NULL);\n+  \/\/ And the ScopedValue bindings too.\n+  oop threadObj = current->vthread();\n+  java_lang_Thread::clear_scopedValueBindings(threadObj);\n@@ -386,0 +392,6 @@\n+  \/\/ Remove the ScopedValue cache in case we got a StackOverflowError\n+  \/\/ while we were trying to remove ScopedValue bindings.\n+  current->set_scopedValueCache(NULL);\n+  \/\/ And the ScopedValue bindings too.\n+  oop threadObj = current->vthread();\n+  java_lang_Thread::clear_scopedValueBindings(threadObj);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1602,1 +1602,1 @@\n-    GrowableArray<ScopeValue*>* extentLocals = cvf->scope()->locals();\n+    GrowableArray<ScopeValue*>* scopedValues = cvf->scope()->locals();\n@@ -1607,1 +1607,1 @@\n-        if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+        if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  \/\/ Used only for removing handle.\n","filename":"src\/hotspot\/share\/oops\/oopHandle.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -683,2 +683,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -475,2 +475,2 @@\n-  case vmIntrinsics::_extentLocalCache:          return inline_native_extentLocalCache();\n-  case vmIntrinsics::_setExtentLocalCache:       return inline_native_setExtentLocalCache();\n+  case vmIntrinsics::_scopedValueCache:          return inline_native_scopedValueCache();\n+  case vmIntrinsics::_setScopedValueCache:       return inline_native_setScopedValueCache();\n@@ -3361,1 +3361,1 @@\n-Node* LibraryCallKit::extentLocalCache_helper() {\n+Node* LibraryCallKit::scopedValueCache_helper() {\n@@ -3368,3 +3368,7 @@\n-  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::extentLocalCache_offset()));\n-  return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n-        TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n+  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::scopedValueCache_offset()));\n+  \/\/ We cannot use immutable_memory() because we might flip onto a\n+  \/\/ different carrier thread, at which point we'll need to use that\n+  \/\/ carrier thread's cache.\n+  \/\/ return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n+  \/\/       TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n+  return make_load(NULL, p, p->bottom_type()->is_ptr(), T_ADDRESS, MemNode::unordered);\n@@ -3373,2 +3377,2 @@\n-\/\/------------------------inline_native_extentLocalCache------------------\n-bool LibraryCallKit::inline_native_extentLocalCache() {\n+\/\/------------------------inline_native_scopedValueCache------------------\n+bool LibraryCallKit::inline_native_scopedValueCache() {\n@@ -3379,1 +3383,1 @@\n-  \/\/ Because we create the extentLocal cache lazily we have to make the\n+  \/\/ Because we create the scopedValue cache lazily we have to make the\n@@ -3383,1 +3387,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n@@ -3389,2 +3393,2 @@\n-\/\/------------------------inline_native_setExtentLocalCache------------------\n-bool LibraryCallKit::inline_native_setExtentLocalCache() {\n+\/\/------------------------inline_native_setScopedValueCache------------------\n+bool LibraryCallKit::inline_native_setScopedValueCache() {\n@@ -3392,1 +3396,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -242,3 +242,3 @@\n-  bool inline_native_extentLocalCache();\n-  Node* extentLocalCache_helper();\n-  bool inline_native_setExtentLocalCache();\n+  bool inline_native_scopedValueCache();\n+  Node* scopedValueCache_helper();\n+  bool inline_native_setScopedValueCache();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-      in_bytes(JavaThread::extentLocalCache_offset()),\n+      in_bytes(JavaThread::scopedValueCache_offset()),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1366,0 +1366,50 @@\n+class ScopedValueBindingsResolver {\n+public:\n+  InstanceKlass* Carrier_klass;\n+  ScopedValueBindingsResolver(JavaThread* THREAD) {\n+    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ScopedValue_Carrier(), true, THREAD);\n+    Carrier_klass = InstanceKlass::cast(k);\n+  }\n+};\n+\n+JVM_ENTRY(jobject, JVM_FindScopedValueBindings(JNIEnv *env, jclass cls))\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Handle>* local_array = new GrowableArray<Handle>(12);\n+  JvmtiVMObjectAllocEventCollector oam;\n+\n+  bool found = false;\n+\n+  static ScopedValueBindingsResolver resolver(THREAD);\n+\n+  \/\/ Iterate through Java frames\n+  vframeStream vfst(thread);\n+  for(; !vfst.at_end(); vfst.next()) {\n+    int loc = 0;\n+    \/\/ get method of frame\n+    Method* method = vfst.method();\n+\n+    Symbol *name = method->name();\n+\n+    InstanceKlass* holder = method->method_holder();\n+    if (name == vmSymbols::runWith_method_name()) {\n+      if ((holder == resolver.Carrier_klass\n+           || holder == vmClasses::VirtualThread_klass()\n+           || holder == vmClasses::Thread_klass())) {\n+        loc = 1;\n+      }\n+    }\n+\n+    if (loc != 0) {\n+      javaVFrame *frame = vfst.asJavaVFrame();\n+      StackValueCollection* locals = frame->locals();\n+      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ScopedValue$Snapshot\n+      Handle result = head_sv->get_obj();\n+      assert(!head_sv->obj_is_scalar_replaced(), \"found scalar-replaced object\");\n+      if (result() != NULL) {\n+        return JNIHandles::make_local(THREAD, result());\n+      }\n+    }\n+  }\n+\n+  return NULL;\n+JVM_END\n@@ -3117,6 +3167,2 @@\n-JVM_ENTRY(jobject, JVM_ExtentLocalCache(JNIEnv* env, jclass threadClass))\n-  oop theCache = thread->extentLocalCache();\n-  if (theCache) {\n-    arrayOop objs = arrayOop(theCache);\n-    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n-  }\n+JVM_ENTRY(jobject, JVM_ScopedValueCache(JNIEnv* env, jclass threadClass))\n+  oop theCache = thread->scopedValueCache();\n@@ -3126,1 +3172,1 @@\n-JVM_ENTRY(void, JVM_SetExtentLocalCache(JNIEnv* env, jclass threadClass,\n+JVM_ENTRY(void, JVM_SetScopedValueCache(JNIEnv* env, jclass threadClass,\n@@ -3129,4 +3175,1 @@\n-  if (objs != NULL) {\n-    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n-  }\n-  thread->set_extentLocalCache(objs);\n+  thread->set_scopedValueCache(objs);\n@@ -4022,0 +4065,9 @@\n+\n+\/*\n+ * Ensure that code doing a stackwalk and using javaVFrame::locals() to\n+ * get the value will see a materialized value and not a scalar-replaced\n+ * null value.\n+ *\/\n+JVM_ENTRY(void, JVM_EnsureMaterializedForStackWalk_func(JNIEnv* env, jobject vthread, jobject value))\n+  JVM_EnsureMaterializedForStackWalk(env, value);\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":63,"deletions":11,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-    \/\/ FIXME: This very crudely destroys all ExtentLocal bindings. This\n+    \/\/ FIXME: This very crudely destroys all ScopedValue bindings. This\n@@ -460,2 +460,2 @@\n-    current->set_extentLocalCache(NULL);\n-    java_lang_Thread::clear_extentLocalBindings(java_thread);\n+    current->set_scopedValueCache(NULL);\n+    java_lang_Thread::clear_scopedValueBindings(java_thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,12 +95,0 @@\n-JVMFlag::Error ExtentLocalCacheSizeConstraintFunc(intx value, bool verbose) {\n-  if (!is_power_of_2(value)) {\n-    JVMFlag::printError(verbose,\n-                        \"ExtentLocalCacheSize (\" INTX_FORMAT \") must be \"\n-                        \"power of 2\\n\",\n-                        value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  }\n-\n-  return JVMFlag::SUCCESS;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  f(intx,   ExtentLocalCacheSizeConstraintFunc)        \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1945,5 +1945,0 @@\n-  product(intx, ExtentLocalCacheSize, 16,                                   \\\n-          \"Size of the cache for scoped values\")                            \\\n-           range(0, max_intx)                                               \\\n-           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n+  _scopedValueCache = OopHandle(_thread_oop_storage, NULL);\n@@ -189,2 +189,2 @@\n-oop JavaThread::extentLocalCache() const {\n-  return _extentLocalCache.resolve();\n+oop JavaThread::scopedValueCache() const {\n+  return _scopedValueCache.resolve();\n@@ -193,3 +193,6 @@\n-void JavaThread::set_extentLocalCache(oop p) {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  _extentLocalCache.replace(p);\n+void JavaThread::set_scopedValueCache(oop p) {\n+  if (_scopedValueCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n+    _scopedValueCache.replace(p);\n+  } else {\n+    assert(p == NULL, \"not yet initialized\");\n+  }\n@@ -606,0 +609,1 @@\n+  ServiceThread::add_oop_handle_release(_scopedValueCache);\n@@ -1070,2 +1074,2 @@\n-  \/\/ Clear any extent-local bindings\n-  set_extentLocalCache(NULL);\n+  \/\/ Clear any scoped-value bindings\n+  set_scopedValueCache(NULL);\n@@ -1074,1 +1078,1 @@\n-  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+  java_lang_Thread::clear_scopedValueBindings(threadOop);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  OopHandle      _extentLocalCache;\n+  OopHandle      _scopedValueCache;\n@@ -467,1 +467,1 @@\n-  jlong _extentLocal_hash_table_shift;\n+  jlong _scopedValue_hash_table_shift;\n@@ -469,1 +469,1 @@\n-  void allocate_extentLocal_hash_table(int count);\n+  void allocate_scopedValue_hash_table(int count);\n@@ -523,2 +523,2 @@\n-  oop extentLocalCache() const;\n-  void set_extentLocalCache(oop p);\n+  oop scopedValueCache() const;\n+  void set_scopedValueCache(oop p);\n@@ -755,1 +755,1 @@\n-  static ByteSize extentLocalCache_offset()       { return byte_offset_of(JavaThread, _extentLocalCache); }\n+  static ByteSize scopedValueCache_offset()       { return byte_offset_of(JavaThread, _scopedValueCache); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -889,3 +889,6 @@\n-  \/\/ Remove the ExtentLocal cache in case we got a StackOverflowError\n-  \/\/ while we were trying to remove ExtentLocal bindings.\n-  current->set_extentLocalCache(NULL);\n+  \/\/ Remove the ScopedValue cache in case we got a StackOverflowError\n+  \/\/ while we were trying to remove ScopedValue bindings.\n+  current->set_scopedValueCache(NULL);\n+  \/\/ And the ScopedValue bindings too.\n+  oop threadObj = current->vthread();\n+  java_lang_Thread::clear_scopedValueBindings(threadObj);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  GrowableArray<ScopeValue*>* extentLocals = scope()->locals();\n+  GrowableArray<ScopeValue*>* scopedValues = scope()->locals();\n@@ -153,1 +153,1 @@\n-      if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+      if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-  nonstatic_field(JavaThread,                  _extentLocalCache,                              OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                              OopHandle)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,2 +163,11 @@\n-  if (h_exception->is_a(vmClasses::OutOfMemoryError_klass())) {\n-    count_out_of_memory_exceptions(h_exception);\n+  if (h_exception->is_a(vmClasses::VirtualMachineError_klass())) {\n+    \/\/ Remove the ScopedValue cache in case we got a virtual machine\n+    \/\/ Error while we were trying to manipulate ScopedValue bindings.\n+    thread->set_scopedValueCache(NULL);\n+    \/\/ And the ScopedValue bindings too.\n+    oop threadObj = thread->vthread();\n+    java_lang_Thread::clear_scopedValueBindings(threadObj);\n+\n+    if (h_exception->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      count_out_of_memory_exceptions(h_exception);\n+    }\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -2575,2 +2576,2 @@\n-            public Object[] extentLocalCache() {\n-                return Thread.extentLocalCache();\n+            public Object[] scopedValueCache() {\n+                return Thread.scopedValueCache();\n@@ -2579,2 +2580,2 @@\n-            public void setExtentLocalCache(Object[] cache) {\n-                Thread.setExtentLocalCache(cache);\n+            public void setScopedValueCache(Object[] cache) {\n+                Thread.setScopedValueCache(cache);\n@@ -2583,2 +2584,2 @@\n-            public Object extentLocalBindings() {\n-                return Thread.extentLocalBindings();\n+            public Object scopedValueBindings() {\n+                return Thread.scopedValueBindings();\n@@ -2587,2 +2588,11 @@\n-            public void setExtentLocalBindings(Object bindings) {\n-                Thread.setExtentLocalBindings(bindings);\n+            public Object findScopedValueBindings() {\n+                return Thread.findScopedValueBindings();\n+            }\n+\n+            public void setScopedValueBindings(Object bindings) {\n+                Thread.setScopedValueBindings(bindings);\n+            }\n+\n+            @ForceInline\n+            public void ensureMaterializedForStackWalk(Object value) {\n+                Thread.ensureMaterializedForStackWalk(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.ref.Reference;\n@@ -51,1 +52,1 @@\n-import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -54,0 +55,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n@@ -281,1 +284,1 @@\n-     * Extent locals binding are maintained by the ExtentLocal class.\n+     * Scoped value bindings are maintained by the ScopedValue class.\n@@ -283,1 +286,1 @@\n-    private Object extentLocalBindings;\n+    private Object scopedValueBindings;\n@@ -285,2 +288,4 @@\n-    static Object extentLocalBindings() {\n-        return currentThread().extentLocalBindings;\n+    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n+\n+    static Object scopedValueBindings() {\n+        return currentThread().scopedValueBindings;\n@@ -289,2 +294,2 @@\n-    static void setExtentLocalBindings(Object bindings) {\n-        currentThread().extentLocalBindings = bindings;\n+    static void setScopedValueBindings(Object bindings) {\n+        currentThread().scopedValueBindings = bindings;\n@@ -294,1 +299,7 @@\n-     * Inherit the extent-local bindings from the given container.\n+     * Search the stack for the most recent scoped-value bindings.\n+     *\/\n+    @IntrinsicCandidate\n+    static native Object findScopedValueBindings();\n+\n+    \/**\n+     * Inherit the scoped-value bindings from the given container.\n@@ -297,2 +308,2 @@\n-    void inheritExtentLocalBindings(ThreadContainer container) {\n-        ExtentLocalContainer.BindingsSnapshot snapshot;\n+    void inheritScopedValueBindings(ThreadContainer container) {\n+        ScopedValueContainer.BindingsSnapshot snapshot;\n@@ -300,1 +311,1 @@\n-                && (snapshot = container.extentLocalBindings()) != null) {\n+                && (snapshot = container.scopedValueBindings()) != null) {\n@@ -303,3 +314,3 @@\n-            Object bindings = snapshot.extentLocalBindings();\n-            if (currentThread().extentLocalBindings != bindings) {\n-                StructureViolationExceptions.throwException(\"Extent local bindings have changed\");\n+            Object bindings = snapshot.scopedValueBindings();\n+            if (currentThread().scopedValueBindings != bindings) {\n+                StructureViolationExceptions.throwException(\"Scoped value bindings have changed\");\n@@ -308,1 +319,1 @@\n-            this.extentLocalBindings = bindings;\n+            this.scopedValueBindings = bindings;\n@@ -395,1 +406,1 @@\n-    \/\/ ExtentLocal support:\n+    \/\/ ScopedValue support:\n@@ -398,1 +409,1 @@\n-    static native Object[] extentLocalCache();\n+    static native Object[] scopedValueCache();\n@@ -401,1 +412,4 @@\n-    static native void setExtentLocalCache(Object[] cache);\n+    static native void setScopedValueCache(Object[] cache);\n+\n+    @IntrinsicCandidate\n+    static native void ensureMaterializedForStackWalk(Object o);\n@@ -730,0 +744,3 @@\n+\n+        \/\/ special value to mean a new thread\n+        this.scopedValueBindings = NEW_THREAD_BINDINGS;\n@@ -769,0 +786,3 @@\n+        \/\/ special value to mean a new thread\n+        this.scopedValueBindings = Thread.class;\n+\n@@ -1559,2 +1579,2 @@\n-                \/\/ extent locals may be inherited\n-                inheritExtentLocalBindings(container);\n+                \/\/ scoped values may be inherited\n+                inheritScopedValueBindings(container);\n@@ -1591,1 +1611,2 @@\n-            task.run();\n+            Object bindings = scopedValueBindings();\n+            runWith(bindings, task);\n@@ -1595,0 +1616,8 @@\n+    @Hidden\n+    @ForceInline\n+    private void runWith(Object bindings, Runnable op) {\n+        ensureMaterializedForStackWalk(bindings);\n+        op.run();\n+        Reference.reachabilityFence(bindings);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":50,"deletions":21,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.ref.Reference;\n@@ -56,0 +57,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n@@ -286,0 +289,1 @@\n+        Object bindings = scopedValueBindings();\n@@ -287,1 +291,1 @@\n-            task.run();\n+            runWith(bindings, task);\n@@ -292,1 +296,0 @@\n-\n@@ -313,0 +316,7 @@\n+    @Hidden\n+    @ForceInline\n+    private void runWith(Object bindings, Runnable op) {\n+        ensureMaterializedForStackWalk(bindings);\n+        op.run();\n+        Reference.reachabilityFence(bindings);\n+    }\n@@ -491,2 +501,2 @@\n-            \/\/ extent locals may be inherited\n-            inheritExtentLocalBindings(container);\n+            \/\/ scoped values may be inherited\n+            inheritScopedValueBindings(container);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-    \/\/ used by ExtentLocal\n+    \/\/ used by ScopedValue\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-     * Returns the current thread's extent locals cache\n+     * Returns the current thread's scoped values cache\n@@ -480,1 +480,1 @@\n-    Object[] extentLocalCache();\n+    Object[] scopedValueCache();\n@@ -483,1 +483,1 @@\n-     * Sets the current thread's extent locals cache\n+     * Sets the current thread's scoped values cache\n@@ -485,1 +485,1 @@\n-    void setExtentLocalCache(Object[] cache);\n+    void setScopedValueCache(Object[] cache);\n@@ -488,1 +488,1 @@\n-     * Return the current thread's extent local bindings.\n+     * Return the current thread's scoped value bindings.\n@@ -490,1 +490,1 @@\n-    Object extentLocalBindings();\n+    Object scopedValueBindings();\n@@ -493,1 +493,1 @@\n-     * Set the current thread's extent local bindings.\n+     * Set the current thread's scoped value bindings.\n@@ -495,1 +495,5 @@\n-    void setExtentLocalBindings(Object bindings);\n+    void setScopedValueBindings(Object bindings);\n+\n+    Object findScopedValueBindings();\n+\n+    void ensureMaterializedForStackWalk(Object value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -102,1 +102,1 @@\n-    private final ExtentLocalContainer.BindingsSnapshot extentLocalBindings;\n+    private final ScopedValueContainer.BindingsSnapshot scopedValueBindings;\n@@ -114,1 +114,1 @@\n-        this.extentLocalBindings = ExtentLocalContainer.captureBindings();\n+        this.scopedValueBindings = ScopedValueContainer.captureBindings();\n@@ -122,2 +122,2 @@\n-    private ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n-        return extentLocalBindings;\n+    private ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n+        return scopedValueBindings;\n@@ -213,1 +213,1 @@\n-     * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n+     * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n@@ -253,1 +253,1 @@\n-     * <p> The thread is started with the extent-local bindings that were captured\n+     * <p> The thread is started with the scoped value bindings that were captured\n@@ -266,1 +266,1 @@\n-     * extent-local bindings are not the same as when the flock was created\n+     * scoped value bindings are not the same as when the flock was created\n@@ -401,6 +401,5 @@\n-     * closes this flock, and then throws {@link\n-     * jdk.incubator.concurrent.StructureViolationException}.\n-     * Similarly, if called to close a flock that <em>encloses<\/em> {@linkplain\n-     * jdk.incubator.concurrent.ExtentLocal.Carrier#run(Runnable) operations} with\n-     * extent-local bindings then it also throws {@code StructureViolationException}\n-     * after closing the flock.\n+     * closes this flock, and then throws {@code StructureViolationException}.\n+     * Similarly, if this method is called to close a thread flock while executing with\n+     * scoped value bindings, and the thread flock was created before the scoped values\n+     * were bound, then {@code StructureViolationException} is thrown after closing the\n+     * thread flock.\n@@ -588,2 +587,2 @@\n-        public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n-            return flock.extentLocalBindings();\n+        public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n+            return flock.scopedValueBindings();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private static final boolean PRESERVE_EXTENT_LOCAL_CACHE;\n+    private static final boolean PRESERVE_SCOPED_VALUE_CACHE;\n@@ -57,2 +57,2 @@\n-        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveExtentLocalCache\");\n-        PRESERVE_EXTENT_LOCAL_CACHE = (value == null) || Boolean.parseBoolean(value);\n+        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveScopedValueCache\");\n+        PRESERVE_SCOPED_VALUE_CACHE = (value == null) || Boolean.parseBoolean(value);\n@@ -132,1 +132,1 @@\n-    private Object[] extentLocalCache;\n+    private Object[] scopedValueCache;\n@@ -241,1 +241,1 @@\n-            JLA.setExtentLocalCache(extentLocalCache);\n+            JLA.setScopedValueCache(scopedValueCache);\n@@ -273,2 +273,2 @@\n-                    if (PRESERVE_EXTENT_LOCAL_CACHE) {\n-                        extentLocalCache = JLA.extentLocalCache();\n+                    if (PRESERVE_SCOPED_VALUE_CACHE) {\n+                        scopedValueCache = JLA.scopedValueCache();\n@@ -276,1 +276,1 @@\n-                        extentLocalCache = null;\n+                        scopedValueCache = null;\n@@ -278,1 +278,1 @@\n-                    JLA.setExtentLocalCache(null);\n+                    JLA.setScopedValueCache(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.vm;\n-\n-import java.util.concurrent.Callable;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.StructureViolationExceptions;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n-\n-\/**\n- * A StackableScope to represent extent-local bindings.\n- *\n- * This class defines static methods to run an operation with a ExtentLocalContainer\n- * on the scope stack. It also defines a method to get the latest ExtentLocalContainer\n- * and a method to return a snapshot of the extent local bindings.\n- *\/\n-public class ExtentLocalContainer extends StackableScope {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    static {\n-        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n-    }\n-\n-    private ExtentLocalContainer() {\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This may be on\n-     * the current thread's scope task or ma require walking up the tree to find it.\n-     *\/\n-    public static <T extends ExtentLocalContainer> T latest(Class<T> containerClass) {\n-        StackableScope scope = head();\n-        if (scope == null) {\n-            scope = JLA.threadContainer(Thread.currentThread());\n-            if (scope == null || scope.owner() == null)\n-                return null;\n-        }\n-        if (containerClass.isInstance(scope)) {\n-            @SuppressWarnings(\"unchecked\")\n-            T tmp = (T) scope;\n-            return tmp;\n-        } else {\n-            return scope.enclosingScope(containerClass);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This\n-     * may be on the current thread's scope task or may require walking up the\n-     * tree to find it.\n-     *\/\n-    public static ExtentLocalContainer latest() {\n-        return latest(ExtentLocalContainer.class);\n-    }\n-\n-    \/**\n-     * A snapshot of the extent local bindings. The snapshot includes the bindings\n-     * established for the current thread and extent local container.\n-     *\/\n-    public record BindingsSnapshot(Object extentLocalBindings,\n-                                   ExtentLocalContainer container) { }\n-\n-    \/**\n-     * Returns the extent local bindings for the current thread.\n-     *\/\n-    public static BindingsSnapshot captureBindings() {\n-        return new BindingsSnapshot(JLA.extentLocalBindings(), latest());\n-    }\n-\n-    \/**\n-     * For use by ExtentLocal to run an operation in a structured context.\n-     *\/\n-    public static void run(Runnable op) {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            runWithoutScope(op);\n-        } else {\n-            new ExtentLocalContainer().doRun(op);\n-        }\n-    }\n-\n-    \/**\n-     * Run an operation without a scope on the stack.\n-     *\/\n-    private static void runWithoutScope(Runnable op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();   \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * Run an operation with this scope on the stack.\n-     *\/\n-    private void doRun(Runnable op) {\n-        Throwable ex;\n-        boolean atTop;\n-        push();\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * For use by ExtentLocal to call a value returning operation in a structured context.\n-     *\/\n-    public static <V> V call(Callable<V> op) throws Exception {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            return callWithoutScope(op);\n-        } else {\n-            return new ExtentLocalContainer().doCall(op);\n-        }\n-    }\n-\n-    \/**\n-     * Call an operation without a scope on the stack.\n-     *\/\n-    private static <V> V callWithoutScope(Callable<V> op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Call an operation with this scope on the stack.\n-     *\/\n-    private <V> V doCall(Callable<V> op) {\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        push();\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n-     * as a suppressed exception when {@code atTop} is false.\n-     *\/\n-    @DontInline @ReservedStackAccess\n-    private static void throwIfFailed(Throwable ex, boolean atTop) {\n-        if (ex != null || !atTop) {\n-            if (!atTop) {\n-                var sve = StructureViolationExceptions.newException();\n-                if (ex == null) {\n-                    ex = sve;\n-                } else {\n-                    ex.addSuppressed(sve);\n-                }\n-            }\n-            Unsafe.getUnsafe().throwException(ex);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ExtentLocalContainer.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.util.concurrent.Callable;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.StructureViolationExceptions;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ReservedStackAccess;\n+\n+\/**\n+ * A StackableScope to represent scoped-value bindings.\n+ *\n+ * This class defines static methods to run an operation with a ScopedValueContainer\n+ * on the scope stack. It also defines a method to get the latest ScopedValueContainer\n+ * and a method to return a snapshot of the scoped value bindings.\n+ *\/\n+public class ScopedValueContainer extends StackableScope {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    static {\n+        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n+    }\n+\n+    private ScopedValueContainer() {\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ScopedValueContainer for the current Thread. This may be on\n+     * the current thread's scope task or may require walking up the tree to find it.\n+     *\/\n+    public static <T extends ScopedValueContainer> T latest(Class<T> containerClass) {\n+        StackableScope scope = head();\n+        if (scope == null) {\n+            scope = JLA.threadContainer(Thread.currentThread());\n+            if (scope == null || scope.owner() == null)\n+                return null;\n+        }\n+        if (containerClass.isInstance(scope)) {\n+            @SuppressWarnings(\"unchecked\")\n+            T tmp = (T) scope;\n+            return tmp;\n+        } else {\n+            return scope.enclosingScope(containerClass);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ScopedValueContainer for the current Thread. This\n+     * may be on the current thread's scope task or may require walking up the\n+     * tree to find it.\n+     *\/\n+    public static ScopedValueContainer latest() {\n+        return latest(ScopedValueContainer.class);\n+    }\n+\n+    \/**\n+     * A snapshot of the scoped value bindings. The snapshot includes the bindings\n+     * established for the current thread and scoped value container.\n+     *\/\n+    public record BindingsSnapshot(Object scopedValueBindings,\n+                                   ScopedValueContainer container) { }\n+\n+    \/**\n+     * Returns the scoped value bindings for the current thread.\n+     *\/\n+    public static BindingsSnapshot captureBindings() {\n+        return new BindingsSnapshot(JLA.scopedValueBindings(), latest());\n+    }\n+\n+    \/**\n+     * For use by ScopedValue to run an operation in a structured context.\n+     *\/\n+    public static void run(Runnable op) {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            runWithoutScope(op);\n+        } else {\n+            new ScopedValueContainer().doRun(op);\n+        }\n+    }\n+\n+    \/**\n+     * Run an operation without a scope on the stack.\n+     *\/\n+    private static void runWithoutScope(Runnable op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();   \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * Run an operation with this scope on the stack.\n+     *\/\n+    private void doRun(Runnable op) {\n+        Throwable ex;\n+        boolean atTop;\n+        push();\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * For use by ScopedValue to call a value returning operation in a structured context.\n+     *\/\n+    public static <V> V call(Callable<V> op) throws Exception {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            return callWithoutScope(op);\n+        } else {\n+            return new ScopedValueContainer().doCall(op);\n+        }\n+    }\n+\n+    \/**\n+     * Call an operation without a scope on the stack.\n+     *\/\n+    private static <V> V callWithoutScope(Callable<V> op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Call an operation with this scope on the stack.\n+     *\/\n+    private <V> V doCall(Callable<V> op) {\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        push();\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n+     * as a suppressed exception when {@code atTop} is false.\n+     *\/\n+    private static void throwIfFailed(Throwable ex, boolean atTop) {\n+        if (ex != null || !atTop) {\n+            if (!atTop) {\n+                var sve = StructureViolationExceptions.newException();\n+                if (ex == null) {\n+                    ex = sve;\n+                } else {\n+                    ex.addSuppressed(sve);\n+                }\n+            }\n+            Unsafe.getUnsafe().throwException(ex);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ScopedValueContainer.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -92,1 +92,1 @@\n-     * The extent locals captured when the thread container was created.\n+     * The scoped values captured when the thread container was created.\n@@ -94,1 +94,1 @@\n-    public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n+    public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,1 +169,2 @@\n-        jdk.net;\n+        jdk.net,\n+        jdk.incubator.concurrent;\n@@ -248,0 +249,1 @@\n+        jdk.incubator.concurrent,\n@@ -254,0 +256,1 @@\n+        jdk.incubator.concurrent,\n@@ -308,1 +311,2 @@\n-        jdk.crypto.ec;\n+        jdk.crypto.ec,\n+        jdk.incubator.concurrent;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,3 +53,6 @@\n-    {\"extentLocalCache\",  \"()[\" OBJ,    (void *)&JVM_ExtentLocalCache},\n-    {\"setExtentLocalCache\", \"([\" OBJ \")V\",(void *)&JVM_SetExtentLocalCache},\n-    {\"getNextThreadIdOffset\", \"()J\",     (void *)&JVM_GetNextThreadIdOffset}\n+    {\"scopedValueCache\", \"()[\" OBJ,    (void *)&JVM_ScopedValueCache},\n+    {\"setScopedValueCache\", \"([\" OBJ \")V\",(void *)&JVM_SetScopedValueCache},\n+    {\"getNextThreadIdOffset\", \"()J\",   (void *)&JVM_GetNextThreadIdOffset},\n+    {\"findScopedValueBindings\", \"()\" OBJ, (void *)&JVM_FindScopedValueBindings},\n+    {\"ensureMaterializedForStackWalk\",\n+                         \"(\" OBJ \")V\", (void*)&JVM_EnsureMaterializedForStackWalk_func},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,847 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.concurrent;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.vm.ScopedValueContainer;\n+import sun.security.action.GetPropertyAction;\n+\n+\/**\n+ * A value that is set once and is then available for reading for a bounded period of\n+ * execution by a thread. A {@code ScopedValue} allows for safely and efficiently sharing\n+ * data for a bounded period of execution without passing the data as method arguments.\n+ *\n+ * <p> {@code ScopedValue} defines the {@link #where(ScopedValue, Object, Runnable)}\n+ * method to set the value of a {@code ScopedValue} for the bouned period of execution by\n+ * a thread of the runnable's {@link Runnable#run() run} method. The unfolding execution of\n+ * the methods executed by {@code run} defines a <b><em>dynamic scope<\/em><\/b>. The scoped\n+ * value is {@linkplain #isBound() bound} while executing in the dynamic scope, it reverts\n+ * to being <em>unbound<\/em> when the {@code run} method completes (normally or with an\n+ * exception). Code executing in the dynamic scope uses the {@code ScopedValue} {@link\n+ * #get() get} method to read its value.\n+ *\n+ * <p> Like a {@linkplain ThreadLocal thread-local variable}, a scoped value has multiple\n+ * incarnations, one per thread. The particular incarnation that is used depends on which\n+ * thread calls its methods.\n+ *\n+ * <p> Consider the following example with a scoped value {@code USERNAME} that is\n+ * <em>bound<\/em> to the value \"{@code duke}\" for the execution, by a thread, of a run\n+ * method that invokes {@code doSomething()}.\n+ * {@snippet lang=java :\n+ *     \/\/ @link substring=\"newInstance\" target=\"#newInstance\" :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> doSomething());\n+ * }\n+ * Code executed directly or indirectly by {@code doSomething()} that invokes {@code\n+ * USERNAME.get()} will read the value \"{@code duke}\". The scoped value is bound while\n+ * executing {@code doSomething()} and becomes unbound when {@code doSomething()}\n+ * completes (normally or with an exception). If one thread were to call {@code\n+ * doSomething()} with {@code USERNAME} bound to \"{@code duke1}\", and another thread\n+ * were to call the method with {@code USERNAME} bound to \"{@code duke2}\", then\n+ * {@code USERNAME.get()} would read the value \"{@code duke1}\" or \"{@code duke2}\",\n+ * depending on which thread is executing.\n+ *\n+ * <p> In addition to the {@code where} method that executes a {@code run} method, {@code\n+ * ScopedValue} defines the {@link #where(ScopedValue, Object, Callable)} method to execute\n+ * a method that returns a result. It also defines the {@link #where(ScopedValue, Object)}\n+ * method for cases where it is useful to accumulate mappings of {@code ScopedValue} to\n+ * value.\n+ *\n+ * <p> A {@code ScopedValue} will typically be declared in a {@code final} and {@code\n+ * static} field. The accessibility of the field will determine which components can\n+ * bind or read its value.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n+ * class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * <h2><a id=\"rebind\">Rebinding<\/a><\/h2>\n+ *\n+ * The {@code ScopedValue} API allows a new binding to be established for <em>nested\n+ * dynamic scopes<\/em>. This is known as <em>rebinding<\/em>. A {@code ScopedValue} that\n+ * is bound to some value may be bound to a new value for the bounded execution of some\n+ * method. The unfolding execution of code executed by that method defines the nested\n+ * dynamic scope. When the method completes (normally or with an exception), the value of\n+ * the {@code ScopedValue} reverts to its previous value.\n+ *\n+ * <p> In the above example, suppose that code executed by {@code doSomething()} binds\n+ * {@code USERNAME} to a new value with:\n+ * {@snippet lang=java :\n+ *     ScopedValue.where(USERNAME, \"duchess\", () -> doMore());\n+ * }\n+ * Code executed directly or indirectly by {@code doMore()} that invokes {@code\n+ * USERNAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n+ * (normally or with an exception), the value of {@code USERNAME} reverts to\n+ * \"{@code duke}\".\n+ *\n+ * <h2><a id=\"inheritance\">Inheritance<\/a><\/h2>\n+ *\n+ * {@code ScopedValue} supports sharing data across threads. This sharing is limited to\n+ * structured cases where child threads are started and terminate within the bounded\n+ * period of execution by a parent thread. More specifically, when using a {@link\n+ * StructuredTaskScope}, scoped value bindings are <em>captured<\/em> when creating a\n+ * {@code StructuredTaskScope} and inherited by all threads started in that scope with\n+ * the {@link StructuredTaskScope#fork(Callable) fork} method.\n+ *\n+ * <p> In the following example, the {@code ScopedValue} {@code USERNAME} is bound to the\n+ * value \"{@code duke}\" for the execution of a runnable operation. The code in the {@code\n+ * run} method creates a {@code StructuredTaskScope} and forks three child threads. Code\n+ * executed directly or indirectly by these threads running {@code childTask1()},\n+ * {@code childTask2()}, and {@code childTask3()} will read the value \"{@code duke}\".\n+ *\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask1());\n+ *             scope.fork(() -> childTask2());\n+ *             scope.fork(() -> childTask3());\n+ *\n+ *             ...\n+ *          }\n+ *     });\n+ * }\n+ *\n+ * @implNote\n+ * Scoped values are designed to be used in fairly small\n+ * numbers. {@link #get} initially performs a search through enclosing\n+ * scopes to find a scoped value's innermost binding. It\n+ * then caches the result of the search in a small thread-local\n+ * cache. Subsequent invocations of {@link #get} for that scoped value\n+ * will almost always be very fast. However, if a program has many\n+ * scoped values that it uses cyclically, the cache hit rate\n+ * will be low and performance will be poor. This design allows\n+ * scoped-value inheritance by {@link StructuredTaskScope} threads to\n+ * be very fast: in essence, no more than copying a pointer, and\n+ * leaving an scoped-value binding also requires little more than\n+ * updating a pointer.\n+ *\n+ * <p>Because the scoped-value per-thread cache is small, clients\n+ * should minimize the number of bound scoped values in use. For\n+ * example, if it is necessary to pass a number of values in this way,\n+ * it makes sense to create a record class to hold those values, and\n+ * then bind a single `ScopedValue` to an instance of that record.\n+ *\n+ * <p>For this incubator release, the reference implementation\n+ * provides some system properties to tune the performance of scoped\n+ * values.\n+ *\n+ * <p>The system property {@code jdk.incubator.concurrent.ScopedValue.cacheSize}\n+ * controls the size of the (per-thread) scoped-value cache. This cache is crucial\n+ * for the performance of scoped values. If it is too small,\n+ * the runtime library will repeatedly need to scan for each\n+ * {@link #get}. If it is too large, memory will be unnecessarily\n+ * consumed. The default scoped-value cache size is 16 entries. It may\n+ * be varied from 2 to 16 entries in size. {@code ScopedValue.cacheSize}\n+ * must be an integer power of 2.\n+ *\n+ * <p>For example, you could use {@code -Djdk.incubator.concurrent.ScopedValue.cacheSize=8}.\n+ *\n+ * <p>The other system property is {@code jdk.preserveScopedValueCache}.\n+ * This property determines whether the per-thread scoped-value\n+ * cache is preserved when a virtual thread is blocked. By default\n+ * this property is set to {@code true}, meaning that every virtual\n+ * thread preserves its scoped-value cache when blocked. Like {@code\n+ * ScopedValue.cacheSize}, this is a space versus speed trade-off: in\n+ * situations where many virtual threads are blocked most of the time,\n+ * setting this property to {@code false} might result in a useful\n+ * memory saving, but each virtual thread's scoped-value cache would\n+ * have to be regenerated after a blocking operation.\n+ *\n+ * @param <T> the type of the value\n+ * @since 20\n+ *\/\n+public final class ScopedValue<T> {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private final @Stable int hash;\n+\n+    @Override\n+    public int hashCode() { return hash; }\n+\n+    \/**\n+     * An immutable map from {@code ScopedValue} to values.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+     * or method in this class will cause a {@link NullPointerException} to be thrown.\n+     *\/\n+    static sealed class Snapshot permits EmptySnapshot {\n+        final Snapshot prev;\n+        final Carrier bindings;\n+        final int bitmask;\n+\n+        private static final Object NIL = new Object();\n+\n+        Snapshot(Carrier bindings, Snapshot prev) {\n+            this.prev = prev;\n+            this.bindings = bindings;\n+            this.bitmask = bindings.bitmask | prev.bitmask;\n+        }\n+\n+        protected Snapshot() {\n+            this.prev = null;\n+            this.bindings = null;\n+            this.bitmask = 0;\n+        }\n+\n+        Object find(ScopedValue<?> key) {\n+            int bits = key.bitmask();\n+            for (Snapshot snapshot = this;\n+                 containsAll(snapshot.bitmask, bits);\n+                 snapshot = snapshot.prev) {\n+                for (Carrier carrier = snapshot.bindings;\n+                     carrier != null && containsAll(carrier.bitmask, bits);\n+                     carrier = carrier.prev) {\n+                    if (carrier.getKey() == key) {\n+                        Object value = carrier.get();\n+                        return value;\n+                    }\n+                }\n+            }\n+            return NIL;\n+        }\n+    }\n+\n+    static final class EmptySnapshot extends Snapshot {\n+\n+        private EmptySnapshot() {\n+            super();\n+        }\n+\n+        private static final Snapshot SINGLETON = new EmptySnapshot();\n+\n+        static final Snapshot getInstance() {\n+            return SINGLETON;\n+        }\n+    }\n+\n+    \/**\n+     * A mapping of scoped values, as <em>keys<\/em>, to values.\n+     *\n+     * <p> A {@code Carrier} is used to accumlate mappings so that an operation (a\n+     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in the\n+     * mapping bound to values. The following example runs an operation with {@code k1}\n+     * bound (or rebound) to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"where\" target=\"#where(ScopedValue, Object)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * <p> A {@code Carrier} is immutable and thread-safe. The {@link\n+     * #where(ScopedValue, Object) where} method returns a new {@code Carrier} object,\n+     * it does not mutate an existing mapping.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method in\n+     * this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 20\n+     *\/\n+    public static final class Carrier {\n+        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n+        \/\/ hits that slot in the cache.\n+        final int bitmask;\n+        final ScopedValue<?> key;\n+        final Object value;\n+        final Carrier prev;\n+\n+        Carrier(ScopedValue<?> key, Object value, Carrier prev) {\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+            int bits = key.bitmask();\n+            if (prev != null) {\n+                bits |= prev.bitmask;\n+            }\n+            this.bitmask = bits;\n+        }\n+\n+        \/**\n+         * Add a binding to this map, returning a new Carrier instance.\n+         *\/\n+        private static final <T> Carrier where(ScopedValue<T> key, T value,\n+                                               Carrier prev) {\n+            return new Carrier(key, value, prev);\n+        }\n+\n+        \/**\n+         * Returns a new {@code Carrier} with the mappings from this carrier plus a\n+         * new mapping from {@code key} to {@code value}. If this carrier already has a\n+         * mapping for the scoped value {@code key} then it will map to the new\n+         * {@code value}. The current carrier is immutable, it is not changed by this\n+         * method.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param value the value, can be {@code null}\n+         * @param <T> the type of the value\n+         * @return a new Carrier with the mappings from this carrier plus the new mapping\n+         *\/\n+        public <T> Carrier where(ScopedValue<T> key, T value) {\n+            return where(key, value, this);\n+        }\n+\n+        \/*\n+         * Return a new set consisting of a single binding.\n+         *\/\n+        static <T> Carrier of(ScopedValue<T> key, T value) {\n+            return where(key, value, null);\n+        }\n+\n+        final Object get() {\n+            return value;\n+        }\n+\n+        final ScopedValue<?> getKey() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the value of a {@link ScopedValue} in this mapping.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param <T> the type of the value\n+         * @return the value\n+         * @throws NoSuchElementException if the key is not present in this mapping\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T get(ScopedValue<T> key) {\n+            var bits = key.bitmask();\n+            for (Carrier carrier = this;\n+                 carrier != null && containsAll(carrier.bitmask, bits);\n+                 carrier = carrier.prev) {\n+                if (carrier.getKey() == key) {\n+                    Object value = carrier.get();\n+                    return (T)value;\n+                }\n+            }\n+            throw new NoSuchElementException();\n+        }\n+\n+        \/**\n+         * Calls a value-returning operation with each scoped value in this mapping bound\n+         * to its value in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or rervert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @param <R> the type of the result of the operation\n+         * @return the result\n+         * @throws Exception if {@code op} completes with an exception\n+         * @see ScopedValue#where(ScopedValue, Object, Callable)\n+         *\/\n+        public <R> R call(Callable<? extends R> op) throws Exception {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            return runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Execute the action with a set of ScopedValue bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        private <R> R runWith(Snapshot newSnapshot, Callable<R> op) throws Exception {\n+            try {\n+                JLA.setScopedValueBindings(newSnapshot);\n+                JLA.ensureMaterializedForStackWalk(newSnapshot);\n+                return ScopedValueContainer.call(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                JLA.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+\n+        \/**\n+         * Runs an operation with each scoped value in this mapping bound to its value\n+         * in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or rervert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @see ScopedValue#where(ScopedValue, Object, Runnable)\n+         *\/\n+        public void run(Runnable op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Execute the action with a set of ScopedValue bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private void runWith(Snapshot newSnapshot, Runnable op) {\n+            try {\n+                JLA.setScopedValueBindings(newSnapshot);\n+                JLA.ensureMaterializedForStackWalk(newSnapshot);\n+                ScopedValueContainer.run(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                JLA.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new {@code Carrier} with a single mapping of a {@code ScopedValue}\n+     * <em>key<\/em> to a value. The {@code Carrier} can be used to accumlate mappings so\n+     * that an operation can be executed with all scoped values in the mapping bound to\n+     * values. The following example runs an operation with {@code k1} bound (or rebound)\n+     * to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @return a new Carrier with a single mapping\n+     *\/\n+    public static <T> Carrier where(ScopedValue<T> key, T value) {\n+        return Carrier.of(key, value);\n+    }\n+\n+    \/**\n+     * Calls a value-returning operation with a {@code ScopedValue} bound to a value\n+     * in the current thread. When the operation completes (normally or with an\n+     * exception), the {@code ScopedValue} will revert to being unbound, or rervert to\n+     * its previous value when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"call\" target=\"Carrier#call(Callable)\" :\n+     *     ScopedValue.where(key, value).call(op);\n+     * }\n+     *\n+     * @param key the ScopedValue\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param <R> the result type\n+     * @param op the operation to call\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <T, R> R where(ScopedValue<T> key,\n+                                 T value,\n+                                 Callable<? extends R> op) throws Exception {\n+        return where(key, value).call(op);\n+    }\n+\n+    \/**\n+     * Run an operation with a {@code ScopedValue} bound to a value in the current\n+     * thread. When the operation completes (normally or with an exception), the\n+     * {@code ScopedValue} will revert to being unbound, or rervert to its previous value\n+     * when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(key, value).run(op);\n+     * }\n+     *\n+     * @param key the ScopedValue\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param op the operation to call\n+     *\/\n+    public static <T> void where(ScopedValue<T> key, T value, Runnable op) {\n+        where(key, value).run(op);\n+    }\n+\n+    private ScopedValue() {\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * Creates a scoped value that is initially unbound for all threads.\n+     *\n+     * @param <T> the type of the value\n+     * @return a new {@code ScopedValue}\n+     *\/\n+    public static <T> ScopedValue<T> newInstance() {\n+        return new ScopedValue<T>();\n+    }\n+\n+    \/**\n+     * {@return the value of the scoped value if bound in the current thread}\n+     *\n+     * @throws NoSuchElementException if the scoped value is not bound\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = scopedValueCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var value = findBinding();\n+        if (value == Snapshot.NIL) {\n+            throw new NoSuchElementException();\n+        }\n+        Cache.put(this, value);\n+        return (T)value;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if this scoped value is bound in the current thread}\n+     *\/\n+    public boolean isBound() {\n+        Object[] objects = scopedValueCache();\n+        if (objects != null) {\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+        }\n+        var value = findBinding();\n+        boolean result = (value != Snapshot.NIL);\n+        if (result)  Cache.put(this, value);\n+        return result;\n+    }\n+\n+    \/**\n+     * Return the value of the scoped value or NIL if not bound.\n+     *\/\n+    private Object findBinding() {\n+        Object value = scopedValueBindings().find(this);\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * returns {@code other}.\n+     *\n+     * @param other the value to return if not bound, can be {@code null}\n+     * @return the value of the scoped value if bound, otherwise {@code other}\n+     *\/\n+    public T orElse(T other) {\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            return other;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * throws an exception produced by the exception supplying function.\n+     *\n+     * @param <X> the type of the exception that may be thrown\n+     * @param exceptionSupplier the supplying function that produces the exception to throw\n+     * @return the value of the scoped value if bound in the current thread\n+     * @throws X if the scoped value is not bound in the current thread\n+     *\/\n+    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n+        Objects.requireNonNull(exceptionSupplier);\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    private static Object[] scopedValueCache() {\n+        return JLA.scopedValueCache();\n+    }\n+\n+    private static void setScopedValueCache(Object[] cache) {\n+        JLA.setScopedValueCache(cache);\n+    }\n+\n+    private static Snapshot scopedValueBindings() {\n+        \/\/ Bindings can be in one of four states:\n+        \/\/\n+        \/\/ 1: class Thread: this is a new Thread instance, and no\n+        \/\/ scoped values have ever been bound in this Thread.\n+        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n+        \/\/ 3: A Snapshot instance: this contains one or more scoped value\n+        \/\/ bindings.\n+        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n+        \/\/ where they are. We must invoke JLA.findScopedValueBindings() to walk\n+        \/\/ the stack to find them.\n+\n+        Object bindings = JLA.scopedValueBindings();\n+        if (bindings == Thread.class) {\n+            \/\/ This must be a new thread\n+           return EmptySnapshot.getInstance();\n+        }\n+        if (bindings == null) {\n+            \/\/ Search the stack\n+            bindings = JLA.findScopedValueBindings();\n+            if (bindings == null) {\n+                \/\/ Nothing on the stack.\n+                bindings = EmptySnapshot.getInstance();\n+            }\n+        }\n+        assert (bindings != null);\n+        JLA.setScopedValueBindings(bindings);\n+        return (Snapshot) bindings;\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n+    \/\/ to different slots in the cache.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * Return a bit mask that may be used to determine if this ScopedValue is\n+     * bound in the current context. Each Carrier holds a bit mask which is\n+     * the OR of all the bit masks of the bound ScopedValues.\n+     * @return the bitmask\n+     *\/\n+    int bitmask() {\n+        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+    }\n+\n+    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n+    \/\/ of the bits in targetBits.\n+    static boolean containsAll(int bitmask, int targetBits) {\n+        return (bitmask & targetBits) == targetBits;\n+    }\n+\n+    \/\/ A small fixed-size key-value cache. When an scoped value's get() method\n+    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n+    \/\/ for fast access in future.\n+    private static class Cache {\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n+\n+        \/\/ The number of elements in the cache array, and a bit mask used to\n+        \/\/ select elements from it.\n+        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+        \/\/ or equal to 2.\n+        private static final int MAX_CACHE_SIZE = 16;\n+\n+        static {\n+            final String propertyName = \"jdk.incubator.concurrent.ScopedValue.cacheSize\";\n+            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n+            var cacheSize = Integer.valueOf(sizeString);\n+            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+            }\n+            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+            }\n+            CACHE_TABLE_SIZE = cacheSize;\n+            SLOT_MASK = cacheSize - 1;\n+        }\n+\n+        static final int primaryIndex(ScopedValue<?> key) {\n+            return key.hash & TABLE_MASK;\n+        }\n+\n+        static final int secondaryIndex(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        }\n+\n+        private static final int primarySlot(ScopedValue<?> key) {\n+            return key.hashCode() & SLOT_MASK;\n+        }\n+\n+        private static final int secondarySlot(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static final int primarySlot(int hash) {\n+            return hash & SLOT_MASK;\n+        }\n+\n+        static final int secondarySlot(int hash) {\n+            return (hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static void put(ScopedValue<?> key, Object value) {\n+            Object[] theCache = scopedValueCache();\n+            if (theCache == null) {\n+                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                setScopedValueCache(theCache);\n+            }\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = primarySlot(key);\n+            int k2 = secondarySlot(key);\n+            var usePrimaryIndex = chooseVictim();\n+            int victim = usePrimaryIndex ? k1 : k2;\n+            int other = usePrimaryIndex ? k2 : k1;\n+            setKeyAndObjectAt(victim, key, value);\n+            if (getKey(theCache, other) == key) {\n+                setKeyAndObjectAt(other, key, value);\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            var cache = scopedValueCache();\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, int n) {\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, int n, Object key) {\n+            objs[n * 2] = key;\n+        }\n+\n+        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n+        \/\/ This chooses either the primary or secondary cache slot, but the\n+        \/\/ primary slot is approximately twice as likely to be chosen as the\n+        \/\/ secondary one.\n+        private static boolean chooseVictim() {\n+            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            return (r & 15) >= 5;\n+        }\n+\n+        public static void invalidate() {\n+            setScopedValueCache(null);\n+        }\n+\n+        \/\/ Null a set of cache entries, indicated by the 1-bits given\n+        static void invalidate(int toClearBits) {\n+            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            Object[] objects;\n+            if ((objects = scopedValueCache()) != null) {\n+                for (int bits = toClearBits; bits != 0; ) {\n+                    int index = Integer.numberOfTrailingZeros(bits);\n+                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    bits &= ~1 << index;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopedValue.java","additions":847,"deletions":0,"binary":false,"changes":847,"status":"added"},{"patch":"@@ -213,2 +213,2 @@\n- * StructuredTaskScopes form a tree where parent-child relations are established\n- * implicitly when opening a new task scope:\n+ * Task scopes form a tree where parent-child relations are established implicitly when\n+ * opening a new task scope:\n@@ -225,4 +225,39 @@\n- * <p> The tree structure supports confinement checks. The phrase \"threads contained in\n- * the task scope\" in method descriptions means threads started in the task scope or\n- * descendant scopes. {@code StructuredTaskScope} does not define APIs that exposes the\n- * tree structure at this time.\n+ * The <i>descendants<\/i> of a task scope that are child task scopes that it is a parent\n+ * of, plus the descendants of the child task scopes, recursively.\n+ *\n+ * <p> The tree structure supports:\n+ * <ul>\n+ *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n+ *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n+ *   descriptions means threads started in the task scope or descendant scopes.\n+ * <\/ul>\n+ *\n+ * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n+ * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n+ * is created and its {@code fork} method invoked to start a thread to execute {@code\n+ * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n+ * creating the task scope. The code in {@code childTask} uses the value of the scoped\n+ * value and so reads the value \"{@code duke}\".\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *\n+ *     \/\/ @link substring=\"where\" target=\"ScopedValue#where(ScopedValue, Object, Runnable)\" :\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n+ *             ...\n+ *          }\n+ *     });\n+ *\n+ *     ...\n+ *\n+ *     String childTask() {\n+ *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n+ *         String name = USERNAME.get();   \/\/ \"duke\"\n+ *         ...\n+ *     }\n+ * }\n+ *\n+ * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n+ * at this time.\n@@ -237,1 +272,1 @@\n- * <a href=\"..\/..\/..\/..\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n@@ -283,0 +318,6 @@\n+     * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+     * bindings for inheritance by threads created in the task scope. The\n+     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+     * details how parent-child relations are established implicitly for the purpose of\n+     * inheritance of scoped value bindings.\n+     *\n@@ -370,1 +411,3 @@\n-     * <p> The new thread is created with the task scope's {@link ThreadFactory}.\n+     * <p> The new thread is created with the task scope's {@link ThreadFactory}. It\n+     * inherits the current thread's {@linkplain ScopedValue scoped value} bindings. The\n+     * bindings must match the bindings captured when the task scope was created.\n@@ -373,7 +416,8 @@\n-     * then the {@link #handleComplete(Future) handle} method is invoked to consume the\n-     * completed task. The {@code handleComplete} method is run when the task completes\n-     * with a result or exception. If the {@code Future} {@link Future#cancel(boolean)\n-     * cancel} method is used the cancel a task before the task scope is shut down, then\n-     * the {@code handleComplete} method is run by the thread that invokes {@code cancel}.\n-     * If the task scope shuts down at or around the same time that the task completes or\n-     * is cancelled then the {@code handleComplete} method may or may not be invoked.\n+     * then the {@link #handleComplete(Future) handleComplete} method is invoked to\n+     * consume the completed task. The {@code handleComplete} method is run when the task\n+     * completes with a result or exception. If the {@code Future}'s {@link\n+     * Future#cancel(boolean) cancel} method is used to cancel a task before the task scope\n+     * is shut down, then the {@code handleComplete} method is run by the thread that\n+     * invokes {@code cancel}. If the task scope shuts down at or around the same time\n+     * that the task completes or is cancelled then the {@code handleComplete} method may\n+     * or may not be invoked.\n@@ -398,0 +442,2 @@\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the task scope was created\n@@ -631,0 +677,6 @@\n+     *\n+     * Similarly, if this method is called to close a task scope while executing with\n+     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n+     * before the scoped values were bound, then {@code StructureViolationException} is\n+     * thrown after closing the task scope.\n+     *\n@@ -827,0 +879,6 @@\n+         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+         * bindings for inheritance by threads created in the task scope. The\n+         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n+         * the class description details how parent-child relations are established\n+         * implicitly for the purpose of inheritance of scoped value bindings.\n+         *\n@@ -1003,0 +1061,6 @@\n+         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+         * bindings for inheritance by threads created in the task scope. The\n+         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n+         * the class description details how parent-child relations are established\n+         * implicitly for the purpose of inheritance of scoped value bindings.\n+         *\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":79,"deletions":15,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-           checkFrames(Thread.currentThread(), false, 9);\n+           checkFrames(Thread.currentThread(), false, 10);\n@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 14);\n+        checkFrames(vThread1, false, 15);\n@@ -88,1 +88,1 @@\n-            checkFrames(Thread.currentThread(), false, 5);\n+            checkFrames(Thread.currentThread(), false, 6);\n@@ -104,1 +104,1 @@\n-        checkFrames(pThread1, false, 5);\n+        checkFrames(pThread1, false, 6);\n@@ -121,1 +121,1 @@\n-    \/\/ Each stack has 2 frames additional to expected depth\n+    \/\/ Each stack has 3 frames additional to expected depth\n@@ -124,1 +124,2 @@\n-    static final int ADDITIONAL_STACK_COUNT = 2;\n+    \/\/ 2: java\/lang\/Thread: runWith()V\n+    static final int ADDITIONAL_STACK_COUNT = 3;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-    {\"Ljava\/lang\/VirtualThread;\", \"run\", \"(Ljava\/lang\/Runnable;)V\"}\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/VirtualThread;\", \"run\", \"(Ljava\/lang\/Runnable;)V\"},\n@@ -47,1 +48,2 @@\n-    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"}\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceCurrentThreadTest\/libGetStackTraceCurrentThreadTest.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"}\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"},\n@@ -46,0 +47,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr03\/libgetstacktr03.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -51,0 +52,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr04\/libgetstacktr04.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -51,0 +52,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr05\/libgetstacktr05.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -55,0 +56,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr06\/libgetstacktr06.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -58,0 +59,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr07\/libgetstacktr07.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -59,0 +60,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr08\/libgetstacktr08.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -800,0 +800,1 @@\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test ScopedValue with many bindings and rebinings\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @library \/test\/lib\n+ * @key randomness\n+ * @run testng ManyBindings\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.ScopedValue.Carrier;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class ManyBindings {\n+    private static final Random RND = RandomFactory.getRandom();\n+\n+    \/\/ number of scoped values to create\n+    private static final int SCOPED_VALUE_COUNT = 16;\n+\n+    \/\/ recursive depth to test\n+    private static final int MAX_DEPTH = 24;\n+\n+    \/**\n+     * Stress test bindings on platform thread.\n+     *\/\n+    public void testPlatformThread() {\n+        test();\n+    }\n+\n+    \/**\n+     * Stress test bindings on virtual thread.\n+     *\/\n+    public void testVirtualThread() throws Exception {\n+        VThreadRunner.run(() -> test());\n+    }\n+\n+    \/**\n+     * Scoped value and its expected value (or null if not bound).\n+     *\/\n+    record KeyAndValue<T>(ScopedValue<T> key, T value) {\n+        KeyAndValue() {\n+            this(ScopedValue.newInstance(), null);\n+        }\n+    }\n+\n+    \/**\n+     * Stress test bindings on current thread.\n+     *\/\n+    private void test() {\n+        KeyAndValue<Integer>[] array = new KeyAndValue[SCOPED_VALUE_COUNT];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = new KeyAndValue<>();\n+        }\n+        test(array, 1);\n+    }\n+\n+    \/**\n+     * Test that the scoped values in the array have the expected value, then\n+     * recursively call this method with some of the scoped values bound to a\n+     * new value.\n+     *\n+     * @param array the scoped values and their expected value\n+     * @param depth current recurive depth\n+     *\/\n+    private void test(KeyAndValue<Integer>[] array, int depth) {\n+        if (depth > MAX_DEPTH)\n+            return;\n+\n+        \/\/ check that the scoped values have the expected values\n+        check(array);\n+\n+        \/\/ try to pollute the cache\n+        lotsOfReads(array);\n+\n+        \/\/ create a Carrier to bind\/rebind some of the scoped values\n+        int len = array.length;\n+        Carrier carrier = null;\n+\n+        KeyAndValue<Integer>[] newArray = Arrays.copyOf(array, len);\n+        int n = Math.max(1, RND.nextInt(len \/ 2));\n+        while (n > 0) {\n+            int index = RND.nextInt(len);\n+            ScopedValue<Integer> key = array[index].key;\n+            int newValue = RND.nextInt();\n+            if (carrier == null) {\n+                carrier = ScopedValue.where(key, newValue);\n+            } else {\n+                carrier = carrier.where(key, newValue);\n+            }\n+            newArray[index] = new KeyAndValue<>(key, newValue);\n+            n--;\n+        }\n+\n+        \/\/ invoke recursively\n+        carrier.run(() -> {\n+            test(newArray, depth+1);\n+        });\n+\n+        \/\/ check that the scoped values have the origina values\n+        check(array);\n+    }\n+\n+    \/**\n+     * Check that the given scoped values have the expected value.\n+     *\/\n+    private void check(KeyAndValue<Integer>[] array) {\n+        for (int i = 0; i < array.length; i++) {\n+            ScopedValue<Integer> key = array[i].key;\n+            Integer value = array[i].value;\n+            if (value == null) {\n+                assertFalse(key.isBound());\n+            } else {\n+                assertEquals(key.get(), value);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Do lots of reads of the scoped values, to pollute the SV cache.\n+     *\/\n+    private void lotsOfReads(KeyAndValue<Integer>[] array) {\n+        for (int k = 0; k < 1000; k++) {\n+            int index = RND.nextInt(array.length);\n+            Integer value = array[index].value;\n+            if (value != null) {\n+                ScopedValue<Integer> key = array[index].key;\n+                assertEquals(key.get(), value);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ManyBindings.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,442 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ScopedValue API\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng ScopeValueAPI\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class ScopeValueAPI {\n+\n+    @DataProvider\n+    public Object[][] factories() {\n+        return new Object[][] {\n+                { Thread.ofPlatform().factory() },\n+                { Thread.ofVirtual().factory() },\n+        };\n+    }\n+\n+    \/**\n+     * Test that the run method is invoked.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRun(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class Box { static boolean executed; }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue.where(name, \"duke\", () -> { Box.executed = true; });\n+            assertTrue(Box.executed);\n+        });\n+    }\n+\n+    \/**\n+     * Test the run method throwing an exception.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRunThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Runnable op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test that the call method is invoked.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCall(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            String result = ScopedValue.where(name, \"duke\", name::get);\n+            assertEquals(result, \"duke\");\n+        });\n+    }\n+\n+    \/**\n+     * Test the call method throwing an exception.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCallThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Callable<Void> op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test get method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ run\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertEquals(name1.get(), \"duke\");\n+                assertThrows(NoSuchElementException.class, name2::get);\n+\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ call\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertEquals(name1.get(), \"duke\");\n+                assertThrows(NoSuchElementException.class, name2::get);\n+                return null;\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+        });\n+    }\n+\n+    \/**\n+     * Test isBound method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testIsBound(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ run\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+                return null;\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test orElse method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testOrElse(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertTrue(name.orElse(null) == null);\n+            assertEquals(name.orElse(\"default\"), \"default\");\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElse(null), \"duke\");\n+                assertEquals(name.orElse(\"default\"), \"duke\");\n+            });\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElse(null), \"duke\");\n+                assertEquals(name.orElse(\"default\"), \"duke\");\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test orElseThrow method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testOrElseThrow(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException { }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertThrows(FooException.class, () -> name.orElseThrow(FooException::new));\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElseThrow(FooException::new), \"duke\");\n+            });\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElseThrow(FooException::new), \"duke\");\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test two bindings.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testTwoBindings(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\").where(age, 100).run(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                assertEquals((int) age.get(), 100);\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\").where(age, 100).call(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                assertEquals((int) age.get(), 100);\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebinding(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding from null vaue to another value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebindingFromNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), null);\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), null);\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding to null value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebindingToNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(name.get() == null);\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(name.get() == null);\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test Carrier.get.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCarrierGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ one scoped value\n+            var carrier1 = ScopedValue.where(name, \"duke\");\n+            assertEquals(carrier1.get(name), \"duke\");\n+            assertThrows(NoSuchElementException.class, () -> carrier1.get(age));\n+\n+            \/\/ two scoped values\n+            var carrier2 = carrier1.where(age, 20);\n+            assertEquals(carrier2.get(name), \"duke\");\n+            assertEquals((int) carrier2.get(age), 20);\n+        });\n+    }\n+\n+    \/**\n+     * Test NullPointerException.\n+     *\/\n+    public void testNullPointerException() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> { }));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> null));\n+\n+        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+\n+        var carrier = ScopedValue.where(name, \"duke\");\n+        assertThrows(NullPointerException.class, () -> carrier.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> carrier.get(null));\n+        assertThrows(NullPointerException.class, () -> carrier.run(null));\n+        assertThrows(NullPointerException.class, () -> carrier.call(null));\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Run the given task in a thread created with the given thread factory.\n+     * @throws Exception if the task throws an exception\n+     *\/\n+    private static void test(ThreadFactory factory, ThrowingRunnable task) throws Exception {\n+        try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+            var future = executor.submit(() -> {\n+                task.run();\n+                return null;\n+            });\n+            try {\n+                future.get();\n+            } catch (ExecutionException ee) {\n+                Throwable cause = ee.getCause();\n+                if (cause instanceof Exception e)\n+                    throw e;\n+                if (cause instanceof Error e)\n+                    throw e;\n+                throw new RuntimeException(cause);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ScopeValueAPI.java","additions":442,"deletions":0,"binary":false,"changes":442,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2021, 2022 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary StressStackOverflow the recovery path for ScopedValue\n+ * @modules jdk.incubator.concurrent\n+ * @compile --enable-preview -source ${jdk.version} StressStackOverflow.java\n+ * @run main\/othervm\/timeout=300 -XX:-TieredCompilation --enable-preview StressStackOverflow\n+ * @run main\/othervm\/timeout=300 -XX:TieredStopAtLevel=1 --enable-preview StressStackOverflow\n+ * @run main\/othervm\/timeout=300 --enable-preview StressStackOverflow\n+ *\/\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadLocalRandom;\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+\n+public class StressStackOverflow {\n+    public static final ScopedValue<Integer> el = ScopedValue.newInstance();\n+\n+    public static final ScopedValue<Integer> inheritedValue = ScopedValue.newInstance();\n+\n+    final ThreadLocalRandom tlr = ThreadLocalRandom.current();\n+    static final TestFailureException testFailureException = new TestFailureException(\"Unexpected value for ScopedValue\");\n+    int ITERS = 1_000_000;\n+\n+    static class TestFailureException extends RuntimeException {\n+        TestFailureException(String s) { super(s); }\n+    }\n+\n+    \/\/ Test the ScopedValue recovery mechanism for stack overflows. We implement both Callable\n+    \/\/ and Runnable interfaces. Which one gets tested depends on the constructor argument.\n+    class DeepRecursion implements Callable, Runnable {\n+\n+        static enum Behaviour {CALL, RUN}\n+        final Behaviour behaviour;\n+\n+        public DeepRecursion(Behaviour behaviour) {\n+            this.behaviour = behaviour;\n+        }\n+\n+        public void run() {\n+            final var last = el.get();\n+            ITERS--;\n+            var nextRandomFloat = tlr.nextFloat();\n+            try {\n+                switch (behaviour) {\n+                    case CALL ->\n+                        ScopedValue.where(el, el.get() + 1).call(() -> fibonacci_pad(20, this));\n+                    case RUN ->\n+                        ScopedValue.where(el, el.get() + 1).run(() -> fibonacci_pad(20, this));\n+                }\n+                if (!last.equals(el.get())) {\n+                    throw testFailureException;\n+                }\n+            } catch (StackOverflowError e) {\n+                if (nextRandomFloat <= 0.1) {\n+                    ScopedValue.where(el, el.get() + 1).run(this);\n+                }\n+            } catch (TestFailureException e) {\n+                throw e;\n+            } catch (Throwable throwable) {\n+                \/\/ StackOverflowErrors cause many different failures. These include\n+                \/\/ StructureViolationExceptions and InvocationTargetExceptions. This test\n+                \/\/ checks that, no matter what the failure mode, scoped values are handled\n+                \/\/ correctly.\n+            } finally {\n+                if (!last.equals(el.get())) {\n+                    throw testFailureException;\n+                }\n+            }\n+\n+            Thread.yield();\n+        }\n+\n+        public Object call() {\n+            run();\n+            return null;\n+        }\n+    }\n+\n+    static final Runnable nop = new Runnable() {\n+        public void run() { }\n+    };\n+\n+    \/\/ Consume some stack.\n+    \/\/\n+\n+    \/\/ The double recursion used here prevents an optimizing JIT from\n+    \/\/ inlining all the recursive calls, which would make it\n+    \/\/ ineffective.\n+    private long fibonacci_pad1(int n, Runnable op) {\n+        if (n <= 1) {\n+            op.run();\n+            return n;\n+        }\n+        return fibonacci_pad1(n - 1, op) + fibonacci_pad1(n - 2, nop);\n+    }\n+\n+    private static final Integer I_42 = 42;\n+\n+    long fibonacci_pad(int n, Runnable op) {\n+        final var last = el.get();\n+        try {\n+            return fibonacci_pad1(tlr.nextInt(n), op);\n+        } catch (StackOverflowError err) {\n+            if (!inheritedValue.get().equals(I_42)) {\n+                throw testFailureException;\n+            }\n+            if (!last.equals(el.get())) {\n+                throw testFailureException;\n+            }\n+            throw err;\n+        }\n+    }\n+\n+    \/\/ Run op in a new thread. Platform or virtual threads are chosen at random.\n+    void runInNewThread(Runnable op) {\n+        var threadFactory\n+                = (tlr.nextBoolean() ? Thread.ofPlatform() : Thread.ofVirtual()).factory();\n+        try (var scope = new StructuredTaskScope<Object>(\"\", threadFactory)) {\n+            var future = scope.fork(() -> {\n+                op.run();\n+                return null;\n+            });\n+            future.get();\n+            scope.join();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public void run() {\n+        try {\n+            ScopedValue.where(inheritedValue, 42).where(el, 0).run(() -> {\n+                try (var scope = new StructuredTaskScope<Object>()) {\n+                    try {\n+                        if (tlr.nextBoolean()) {\n+                            \/\/ Repeatedly test Scoped Values set by ScopedValue::call() and ScopedValue::run()\n+                            final var deepRecursion\n+                                    = new DeepRecursion(tlr.nextBoolean() ? DeepRecursion.Behaviour.CALL : DeepRecursion.Behaviour.RUN);\n+                            deepRecursion.run();\n+                        } else {\n+                            \/\/ Recursively run ourself until we get a stack overflow\n+                            \/\/ Catch the overflow and make sure the recovery path works\n+                            \/\/ for values inherited from a StructuredTaskScope.\n+                            Runnable op = new Runnable() {\n+                                public void run() {\n+                                    try {\n+                                        fibonacci_pad(20, this);\n+                                    } catch (StackOverflowError e) {\n+                                    } catch (TestFailureException e) {\n+                                        throw e;\n+                                    } catch (Throwable throwable) {\n+                                        \/\/ StackOverflowErrors cause many different failures. These include\n+                                        \/\/ StructureViolationExceptions and InvocationTargetExceptions. This test\n+                                        \/\/ checks that, no matter what the failure mode, scoped values are handled\n+                                        \/\/ correctly.\n+                                    } finally {\n+                                        if (!inheritedValue.get().equals(I_42)) {\n+                                            throw testFailureException;\n+                                        }\n+                                    }\n+                                }\n+                            };\n+                            runInNewThread(op);\n+                        }\n+                        scope.join();\n+                    } catch (StructureViolationException structureViolationException) {\n+                        \/\/ Can happen if a stack overflow prevented a StackableScope from\n+                        \/\/ being removed. We can continue.\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            });\n+        } catch (StructureViolationException structureViolationException) {\n+            \/\/ Can happen if a stack overflow prevented a StackableScope from\n+            \/\/ being removed. We can continue.\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        var torture = new StressStackOverflow();\n+        while (torture.ITERS > 0) {\n+            torture.run();\n+        }\n+        System.out.println(\"OK\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic tests for StructuredTaskScope with scoped values\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng WithScopedValue\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class WithScopedValue {\n+\n+    @DataProvider\n+    public Object[][] factories() {\n+        return new Object[][] {\n+                { Thread.ofPlatform().factory() },\n+                { Thread.ofVirtual().factory() },\n+        };\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a child thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future = scope.fork(() -> {\n+                    return name.get(); \/\/ child should read \"x\"\n+                });\n+                scope.join();\n+                return future.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a grandchild thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future1 = scope1.fork(() -> {\n+                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                        Future<String> future2 = scope2.fork(() -> {\n+                            return name.get(); \/\/ grandchild should read \"x\"\n+                        });\n+                        scope2.join();\n+                        return future2.resultNow();\n+                    }\n+                });\n+                scope1.join();\n+                return future1.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a rebound scoped value into a grandchild thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future1 = scope1.fork(() -> {\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+\n+                    \/\/ rebind name to \"y\"\n+                    String grandchildValue = ScopedValue.where(name, \"y\", () -> {\n+                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                            Future<String> future2 = scope2.fork(() -> {\n+                                return name.get(); \/\/ grandchild should read \"y\"\n+                            });\n+                            scope2.join();\n+                            return future2.resultNow();\n+                        }\n+                    });\n+\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+                    return grandchildValue;\n+                });\n+                scope1.join();\n+                return future1.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"y\");\n+    }\n+\n+    \/**\n+     * Test exiting a dynamic scope with an open task scope.\n+     *\/\n+    public void testStructureViolation1() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            StructuredTaskScope<Object> scope;\n+        }\n+        var box = new Box();\n+        try {\n+            try {\n+                ScopedValue.where(name, \"x\", () -> {\n+                    box.scope = new StructuredTaskScope<Object>();\n+                });\n+                fail();\n+            } catch (StructureViolationException expected) { }\n+\n+            \/\/ underlying flock should be closed, fork should return a cancelled task\n+            StructuredTaskScope<Object> scope = box.scope;\n+            AtomicBoolean ran = new AtomicBoolean();\n+            Future<Object> future = scope.fork(() -> {\n+                ran.set(true);\n+                return null;\n+            });\n+            assertTrue(future.isCancelled());\n+            scope.join();\n+            assertFalse(ran.get());\n+\n+        } finally {\n+            StructuredTaskScope<Object> scope = box.scope;\n+            if (scope != null) {\n+                scope.close();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a StructuredTaskScope while executing in a dynamic scope.\n+     *\/\n+    public void testStructureViolation2() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.where(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class, scope::close);\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is bound after a StructuredTaskScope is created.\n+     *\/\n+    public void testStructureViolation3() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.where(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class,\n+                        () -> scope.fork(() -> \"foo\"));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is re-bound after a StructuredTaskScope is created.\n+     *\/\n+    public void testStructureViolation4() throws Exception {\n+        ScopedValue<String> name1 = ScopedValue.newInstance();\n+        ScopedValue<String> name2 = ScopedValue.newInstance();\n+\n+        \/\/ rebind\n+        ScopedValue.where(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.where(name1, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+\n+        \/\/ new binding\n+        ScopedValue.where(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.where(name2, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ThreadFlock with scoped values\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules jdk.incubator.concurrent\n+ * @run testng WithScopedValue\n+ *\/\n+\n+import jdk.internal.misc.ThreadFlock;\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class WithScopedValue {\n+\n+    @DataProvider(name = \"factories\")\n+    public Object[][] factories() {\n+        var defaultThreadFactory = Executors.defaultThreadFactory();\n+        var virtualThreadFactory = Thread.ofVirtual().factory();\n+        return new Object[][]{\n+                { defaultThreadFactory, },\n+                { virtualThreadFactory, },\n+        };\n+    }\n+\n+    \/**\n+     * Test inheritance of a scoped value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInheritsScopedValue(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"duke\", () -> {\n+            var result = new AtomicReference<String>();\n+            try (var flock = ThreadFlock.open(null)) {\n+                Thread thread = factory.newThread(() -> {\n+                    \/\/ child\n+                    result.set(name.get());\n+                });\n+                flock.start(thread);\n+            }\n+            return result.get();\n+        });\n+        assertEquals(value, \"duke\");\n+    }\n+\n+    \/**\n+     * Test exiting a dynamic scope with open thread flocks.\n+     *\/\n+    public void testStructureViolation1() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            ThreadFlock flock1;\n+            ThreadFlock flock2;\n+        }\n+        var box = new Box();\n+        try {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                box.flock1 = ThreadFlock.open(null);\n+                box.flock2 = ThreadFlock.open(null);\n+            });\n+            fail();\n+        } catch (StructureViolationException expected) { }\n+        assertTrue(box.flock1.isClosed());\n+        assertTrue(box.flock2.isClosed());\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock1.\n+     *\/\n+    public void testStructureViolation2() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock1.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertTrue(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock2.\n+     *\/\n+    public void testStructureViolation3() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock2.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock3.\n+     *\/\n+    public void testStructureViolation4() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock3.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertFalse(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test start when a scoped value is bound after a thread flock is created.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock = ThreadFlock.open(null)) {\n+            ScopedValue.where(name, \"duke\", () -> {\n+                Thread thread = factory.newThread(() -> { });\n+                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test start when a scoped value is re-bound after a thread flock is created.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testStructureViolation6(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        ScopedValue.where(name, \"duke\", () -> {\n+            try (var flock = ThreadFlock.open(null)) {\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    Thread thread = factory.newThread(() -> { });\n+                    expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/WithScopedValue.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesData.*;\n+\n+\/**\n+ * Tests ScopedValue\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations=4, time=1)\n+@Measurement(iterations=10, time=1)\n+@Threads(1)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesExecutorService\",\n+                        \"-Djmh.executor=CUSTOM\",\n+                        \"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--add-modules=jdk.incubator.concurrent\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class ScopedValues {\n+\n+    private static final Integer THE_ANSWER = 42;\n+\n+    \/\/ Test 1: make sure ScopedValue.get() is hoisted out of loops.\n+\n+    @Benchmark\n+    public void thousandAdds_ScopedValue(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.sl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    @Benchmark\n+    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.tl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ Test 2: stress the ScopedValue cache.\n+    \/\/ The idea here is to use a bunch of bound values cyclically, which\n+    \/\/ stresses the ScopedValue cache.\n+\n+    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n+        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ScopedValue() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, sl1.get(), sl2.get(), sl3.get(), sl4.get(), sl5.get(), sl6.get());\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ThreadLocal() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Test 3: The cost of bind, then get\n+    \/\/ This is the worst case for ScopedValues because we have to create\n+    \/\/ a binding, link it in, then search the current bindings. In addition, we\n+    \/\/ create a cache entry for the bound value, then we immediately have to\n+    \/\/ destroy it.\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int CreateBindThenGetThenRemove_ScopedValue() throws Exception {\n+        return ScopedValue.where(sl1, THE_ANSWER).call(sl1::get);\n+    }\n+\n+\n+    \/\/ Create a Carrier ahead of time: might be slightly faster\n+    private static final ScopedValue.Carrier HOLD_42 = ScopedValue.where(sl1, 42);\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ScopedValue() throws Exception {\n+        return HOLD_42.call(sl1::get);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return tl1.get();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+        return tl1.get();\n+    }\n+\n+    \/\/ Test 4: The cost of binding, but not using any result\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ScopedValue() throws Exception {\n+        return HOLD_42.call(this::getClass);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return this.getClass();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ Simply set a ThreadLocal so that the caller can see it\n+    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+    }\n+\n+    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n+    \/\/ returns a value in a ScopedValue container. The container must already\n+    \/\/ be bound to an AtomicReference for this to work.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ScopedValue() throws Exception {\n+        sl_atomicRef.get().setPlain(THE_ANSWER);\n+    }\n+\n+    \/\/ Test 5: A simple counter\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ScopedValue() {\n+        sl_atomicInt.get().setPlain(\n+                sl_atomicInt.get().getPlain() + 1);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ThreadLocal() {\n+        \/\/ Very slow:\n+        \/\/ tl1.set(tl1.get() + 1);\n+        var ctr = tl_atomicInt.get();\n+        ctr.setPlain(ctr.getPlain() + 1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValues.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+@SuppressWarnings(\"preview\")\n+public class ScopedValuesData {\n+\n+    static final ScopedValue<Integer> sl1 = ScopedValue.newInstance();\n+    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n+\n+    static final ScopedValue<Integer> sl2 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl3 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl4 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl5 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl6 = ScopedValue.newInstance();\n+    static final ScopedValue<AtomicInteger> sl_atomicInt = ScopedValue.newInstance();\n+\n+    static final ScopedValue<Integer> unbound = ScopedValue.newInstance();\n+\n+    static final ScopedValue<AtomicReference<Integer>> sl_atomicRef = ScopedValue.newInstance();\n+\n+    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n+    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n+\n+    static final ScopedValue.Carrier VALUES = ScopedValue\n+            .where(sl1, 42).where(sl2, 2).where(sl3, 3)\n+            .where(sl4, 4).where(sl5, 5).where(sl6, 6);\n+\n+    public static void run(Runnable action) {\n+        try {\n+            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n+            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n+            tl_atomicInt.set(new AtomicInteger());\n+            VALUES.where(sl_atomicInt, new AtomicInteger())\n+                  .where(sl_atomicRef, new AtomicReference<>())\n+                  .run(action);\n+        } finally {\n+            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n+            tl_atomicInt.remove();\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesData.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import java.util.concurrent.*;\n+\n+public class ScopedValuesExecutorService extends ThreadPoolExecutor {\n+    public ScopedValuesExecutorService(int corePoolSize, String prefix) {\n+        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n+              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n+    }\n+}\n+\n+class AThreadFactory implements ThreadFactory {\n+    public Thread newThread(Runnable action) {\n+        return new Thread() {\n+            public void run() {\n+                ScopedValuesData.run(action);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesExecutorService.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}