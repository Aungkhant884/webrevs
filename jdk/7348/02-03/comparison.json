{"files":[{"patch":"@@ -876,1 +876,1 @@\n-        \/\/ ZipEntry::getName should not return null\n+        \/\/ ZipEntry::getName should not return null, if it does, return null\n@@ -881,1 +881,1 @@\n-            throw new ZipException(\"ZipEntry::getName returned null\");\n+            return null;\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.zip.ZipException;\n@@ -68,4 +67,0 @@\n-    \/\/ Error message from JarFile::verifiableEntry when ZipEntry::getName\n-    \/\/ returns null\n-    public static final String ZIPENTRY_GETNAME_NULL_ERROR_MSG\n-            = \"ZipEntry::getName returned null\";\n@@ -727,1 +722,1 @@\n-     * DataProvider used to specify whether we will verify the jar\n+     * DataProvider used to specify valid jars and whether to verify them\n@@ -729,1 +724,1 @@\n-     * @return Entry object indicating whether the jar will be verified\n+     * @return Entry object indicating the jar file and whether it will be verified\n@@ -732,1 +727,1 @@\n-    public Object[][] trueFalse() {\n+    public Object[][] validJars() {\n@@ -734,2 +729,19 @@\n-                {true},\n-                {false},\n+                {SIGNED_VALID_ENTRY_NAME_JAR, true},\n+                {SIGNED_VALID_ENTRY_NAME_JAR, false},\n+                {VALID_ENTRY_NAME_JAR, true},\n+                {VALID_ENTRY_NAME_JAR, false},\n+        };\n+    }\n+\n+    \/**\n+     * DataProvider used to specify invalid jars and whether to verify them\n+     *\n+     * @return Entry object indicating the jar file and whether it will be verified\n+     *\/\n+    @DataProvider\n+    public Object[][] inValidJars() {\n+        return new Object[][]{\n+                {SIGNED_INVALID_ENTRY_NAME_JAR, true},\n+                {SIGNED_INVALID_ENTRY_NAME_JAR, false},\n+                {INVALID_ENTRY_NAME_JAR, true},\n+                {INVALID_ENTRY_NAME_JAR, false},\n@@ -790,1 +802,1 @@\n-     * the original jar when the file is opened using JarFile when accessed via\n+     * the original jar when the file is opened using JarFile and accessed via\n@@ -793,0 +805,2 @@\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified\n@@ -795,3 +809,3 @@\n-    @Test(dataProvider = \"trueFalse\")\n-    public static void validJarZipEntryNameTest(boolean verify) throws Exception {\n-        try (JarFile jf = new JarFile(VALID_ENTRY_NAME_JAR.toFile(), verify)) {\n+    @Test(dataProvider = \"validJars\")\n+    public static void validJarFileZipEntryTest(Path jar, boolean verify) throws Exception {\n+        try (JarFile jf = new JarFile(jar.toFile(), verify)) {\n@@ -807,1 +821,1 @@\n-     * the original jar when the file is opened using JarFile when accessed via\n+     * the original jar when the file is opened using JarFile and accessed via\n@@ -810,0 +824,2 @@\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified\n@@ -812,19 +828,3 @@\n-    @Test(dataProvider = \"trueFalse\")\n-    public static void validJarEntryNameTest(boolean verify) throws Exception {\n-        try (JarFile jf = new JarFile(VALID_ENTRY_NAME_JAR.toFile(), verify)) {\n-            JarEntry je = jf.getJarEntry(CEN_FILENAME_TO_MODIFY);\n-            var is = jf.getInputStream(je);\n-            byte[] cnt = is.readAllBytes();\n-            assertNotNull(cnt);\n-        }\n-    }\n-\n-    \/**\n-     * Validate that the CEN filename to be modified can be accessed in\n-     * the original jar when the file is opened using ZipFile\n-     *\n-     * @throws Exception if an error occurs\n-     *\/\n-    @Test\n-    public static void validZipEntryNameTest() throws Exception {\n-        try (ZipFile jf = new ZipFile(VALID_ENTRY_NAME_JAR.toFile())) {\n+    @Test(dataProvider = \"validJars\")\n+    public static void validJarFileJarEntryTest(Path jar, boolean verify) throws Exception {\n+        try (JarFile jf = new JarFile(jar.toFile(), verify)) {\n@@ -840,18 +840,1 @@\n-     * the original signed jar when accessed via a JarEntry\n-     *\n-     * @param verify true if the jar should be verified; false otherwise\n-     * @throws Exception if an error occurs\n-     *\/\n-    @Test(dataProvider = \"trueFalse\")\n-    public static void signedValidJarEntryNameTest(boolean verify) throws Exception {\n-        try (JarFile jf = new JarFile(SIGNED_VALID_ENTRY_NAME_JAR.toFile(), verify)) {\n-            JarEntry je = jf.getJarEntry(CEN_FILENAME_TO_MODIFY);\n-            var is = jf.getInputStream(je);\n-            byte[] cnt = is.readAllBytes();\n-            assertNotNull(cnt);\n-        }\n-    }\n-\n-    \/**\n-     * Validate that the CEN filename to be modified can be accessed in\n-     * the original signed jar when accessed via a ZipEntry\n+     * the original jar when the file is opened using ZipFile\n@@ -859,1 +842,2 @@\n-     * @param verify true if the jar should be verified; false otherwise\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified(not used)\n@@ -862,3 +846,3 @@\n-    @Test(dataProvider = \"trueFalse\")\n-    public static void signedValidZipEntryNameTest(boolean verify) throws Exception {\n-        try (JarFile jf = new JarFile(SIGNED_VALID_ENTRY_NAME_JAR.toFile(), verify)) {\n+    @Test(dataProvider = \"validJars\")\n+    public static void validZipFileZipEntryTest(Path jar, boolean verify) throws Exception {\n+        try (ZipFile jf = new ZipFile(jar.toFile())) {\n@@ -874,1 +858,1 @@\n-     * when the specified ZipEntry is null and the jar is not signed.\n+     * when the specified ZipEntry is null.\n@@ -876,0 +860,2 @@\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified(not used)\n@@ -878,3 +864,3 @@\n-    @Test(dataProvider = \"trueFalse\")\n-    public static void invalidJarZipEntry(boolean verify) throws Exception {\n-        try (JarFile jf = new JarFile(INVALID_ENTRY_NAME_JAR.toFile(), verify)) {\n+    @Test(dataProvider = \"inValidJars\")\n+    public static void invalidJarFileZipEntry(Path jar, boolean verify) throws Exception {\n+        try (JarFile jf = new JarFile(jar.toFile(), verify)) {\n@@ -890,18 +876,0 @@\n-    \/**\n-     * Validate that a NullPointerException is thrown by JarFile::getInputStream\n-     * when the specified JarEntry is null and the jar is not signed.\n-     *\n-     * @throws Exception if an error occurs\n-     *\/\n-    @Test(dataProvider = \"trueFalse\")\n-    public static void invalidJarJarEntry(boolean verify) throws Exception {\n-        try (JarFile jf = new JarFile(INVALID_ENTRY_NAME_JAR.toFile(), verify)) {\n-            \/\/ The entry will not be found resulting in the ZipEntry being null\n-            JarEntry je = jf.getJarEntry(CEN_FILENAME_TO_MODIFY);\n-            var ex= expectThrows(NullPointerException.class,\n-                    () -> jf.getInputStream(je) );\n-            \/\/ Validate that we receive the expected message from Objects.requireNonNull\n-            assertTrue( ex != null && ex.getMessage().equals(\"ze\"));\n-        }\n-    }\n-\n@@ -911,1 +879,2 @@\n-     *\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified(not used)\n@@ -914,3 +883,3 @@\n-    @Test\n-    public static void invalidJarZipEntry() throws IOException {\n-        try (ZipFile zip = new ZipFile(INVALID_ENTRY_NAME_JAR.toFile())) {\n+    @Test(dataProvider = \"inValidJars\")\n+    public static void invalidZipFileZipEntry(Path jar, boolean verify) throws Exception {\n+        try (ZipFile jf = new ZipFile(jar.toFile())) {\n@@ -918,1 +887,1 @@\n-            ZipEntry ze = zip.getEntry(CEN_FILENAME_TO_MODIFY);\n+            ZipEntry ze = jf.getEntry(CEN_FILENAME_TO_MODIFY);\n@@ -920,1 +889,1 @@\n-                    () -> zip.getInputStream(ze) );\n+                    () -> jf.getInputStream(ze) );\n@@ -927,2 +896,2 @@\n-     * Validate that a NullPointerException is thrown by JarFile::getInputStream\n-     * when the specified JarEntry is null and the jar is signed.\n+     * Validate that JarFile::getInputStream will return null when the specified\n+     * ZipEntry does not exist in the Jar file\n@@ -930,1 +899,2 @@\n-     * @param verify true if the jar should be verified; false otherwise\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified\n@@ -933,11 +903,3 @@\n-    @Test(dataProvider = \"trueFalse\")\n-    public static void testInvalidSignedJarJarEntry(boolean verify) throws Exception {\n-        try (JarFile jf = new JarFile(SIGNED_INVALID_ENTRY_NAME_JAR.toFile(), verify)) {\n-            \/\/ The entry will not be found resulting in the ZipEntry being null\n-            JarEntry ze = jf.getJarEntry(CEN_FILENAME_TO_MODIFY);\n-            var ex= expectThrows(NullPointerException.class,\n-                    () -> jf.getInputStream(ze) );\n-            \/\/ Validate that we receive the expected message from Objects.requireNonNull\n-            assertTrue( ex != null && ex.getMessage().equals(\"ze\"));\n-        }\n-    }\n+    @Test(dataProvider = \"validJars\")\n+    public static void JarFileZipEntryDoesNotExistGetInputStreamTest(\n+            Path jar, boolean verify) throws Exception {\n@@ -945,16 +907,5 @@\n-    \/**\n-     * Validate that a NullPointerException is thrown by JarFile::getInputStream\n-     * when the specified ZipEntry is null and the jar is signed.\n-     *\n-     * @param verify true if the jar should be verified; false otherwise\n-     * @throws Exception if an error occurs\n-     *\/\n-    @Test(dataProvider = \"trueFalse\")\n-    public static void testInvalidSignedJarZipEntry(boolean verify) throws Exception {\n-        try (JarFile jf = new JarFile(SIGNED_INVALID_ENTRY_NAME_JAR.toFile(), verify)) {\n-            \/\/ The entry will not be found resulting in the ZipEntry being null\n-            ZipEntry ze = jf.getEntry(CEN_FILENAME_TO_MODIFY);\n-            var ex= expectThrows(NullPointerException.class,\n-                    () -> jf.getInputStream(ze) );\n-            \/\/ Validate that we receive the expected message from Objects.requireNonNull\n-            assertTrue( ex != null && ex.getMessage().equals(\"ze\"));\n+        try (JarFile jf = new JarFile(jar.toFile(), verify)) {\n+            var ze = new ZipEntry(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n+            var is = jf.getInputStream(ze);\n+            \/\/ As the ZipEntry cannot be found, the returned InputStream is null\n+            assertNull(is);\n@@ -965,3 +916,4 @@\n-     * Validate that JarFile::verifiableEntry will throw the correct ZipException\n-     * if the ZipEntry passed as a parameter returns null when ZipEntry::getName\n-     * is invoked.\n+     * Validate that ZipFile::getInputStream will return null when the specified\n+     * ZipEntry does not exist in the Jar file\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified(not used)\n@@ -970,10 +922,8 @@\n-    @Test\n-    public static void verifiableEntryZipEntryGetNameNullTest() throws Exception {\n-        try (JarFile jf = new JarFile(SIGNED_VALID_ENTRY_NAME_JAR.toFile(), true)) {\n-            var ze = new InvalidZipEntry(CEN_FILENAME_TO_MODIFY);\n-            var ex= expectThrows(ZipException.class,\n-                    () -> jf.getInputStream(ze) );\n-            \/\/ Validate that we receive the expected message from\n-            \/\/ JarFile::verifiableEntry when ZipEntry::getName returns null\n-            assertTrue( ex != null &&\n-                    ex.getMessage().equals(ZIPENTRY_GETNAME_NULL_ERROR_MSG));\n+    @Test(dataProvider = \"validJars\")\n+    public static void ZipFileZipEntryDoesNotExistGetInputStreamTest(\n+            Path jar, boolean verify) throws Exception {\n+        try (ZipFile jf = new ZipFile(jar.toFile())) {\n+            var ze = new ZipEntry(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n+            var is = jf.getInputStream(ze);\n+            \/\/ As the ZipEntry cannot be found, the returned InputStream is null\n+            assertNull(is);\n@@ -985,1 +935,3 @@\n-     * Zip File entry does not exist in the Jar file\n+     * JarEntry does not exist in the Jar file\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified\n@@ -988,26 +940,7 @@\n-    @Test\n-    public static void JarFileZipEntryNullGetInputStreamTest() throws Exception {\n-        \/\/ Unsigned Jar\n-        try (JarFile jf = new JarFile(VALID_ENTRY_NAME_JAR.toFile())) {\n-            var ze = new ZipEntry(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n-            var is = jf.getInputStream(ze);\n-            \/\/ As the ZipEntry cannot be found, the returned InputStream is null\n-            assertNull(is);\n-        }\n-        \/\/ Signed Jar is used for the next checks\n-        try (JarFile jf = new JarFile(SIGNED_INVALID_ENTRY_NAME_JAR.toFile(), false)) {\n-            var ze = new ZipEntry(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n-            var is = jf.getInputStream(ze);\n-            \/\/ As the ZipEntry cannot be found, the returned InputStream is null\n-            assertNull(is);\n-        }\n-        try (JarFile jf = new JarFile(SIGNED_VALID_ENTRY_NAME_JAR.toFile(), true)) {\n-            var ze = new ZipEntry(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n-            var is = jf.getInputStream(ze);\n-            \/\/ As the ZipEntry cannot be found, the returned InputStream is null\n-            assertNull(is);\n-        }\n-        try (JarFile jf = new JarFile(SIGNED_VALID_ENTRY_NAME_JAR.toFile())) {\n-            var ze = new ZipEntry(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n-            var is = jf.getInputStream(ze);\n-            \/\/ As the ZipEntry cannot be found, the returned InputStream is null\n+    @Test(dataProvider = \"validJars\")\n+    public static void JarFileJarEntryEntryDoesNotExistGetInputStreamTest (\n+            Path jar, boolean verify) throws Exception {\n+        try (JarFile jf = new JarFile(jar.toFile(), verify)) {\n+            var je = new JarEntry(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n+            var is = jf.getInputStream(je);\n+            \/\/ As the JarEntry cannot be found, the returned InputStream is null\n@@ -1019,2 +952,5 @@\n-     * Validate that ZipFile::getInputStream will return null when the specified\n-     * Zip File entry does not exist in the Jar file\n+     * Validate that JarFile::getInputStream will return null when validating\n+     * a signed jar and the ZipEntry passed as a parameter returns null\n+     * when ZipEntry::getName is invoked.\n+     * @param jar the jar file to be used\n+     * @param verify indicates whether the jar should be verified\n@@ -1023,6 +959,8 @@\n-    @Test\n-    public static void ZipFileZipEntryNullGetInputStreamTest() throws Exception {\n-        try (ZipFile zf = new ZipFile(VALID_ENTRY_NAME_JAR.toFile())) {\n-            var ze = new ZipEntry(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n-            var is = zf.getInputStream(ze);\n-            \/\/ As the ZipEntry cannot be found, the returned InpuStream is null\n+    @Test(dataProvider = \"validJars\")\n+    public static void JarFileZipEntryGetNameNullTest(Path jar, boolean verify) throws Exception {\n+\n+        \/\/ Signed Jar is used for the next checks\n+        try (JarFile jf = new JarFile(jar.toFile(), verify)) {\n+            var ze = new InvalidZipEntry(CEN_FILENAME_TO_MODIFY);\n+            var is = jf.getInputStream(ze);\n+            \/\/ As the ZipEntry cannot be found, the returned InputStream is null\n@@ -1063,2 +1001,2 @@\n-     * Overridden ZipEntry class which will always return null\n-     * for the Zip entry name\n+     * Overridden ZipEntry class which specifies an invalid name for the\n+     * ZipEntry and will always return null for the Zip entry name\n@@ -1068,1 +1006,1 @@\n-            super(name);\n+            super(ZIP_ENTRY_THAT_DOES_NOT_EXIST);\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/GetInputStreamNPETest.java","additions":103,"deletions":165,"binary":false,"changes":268,"status":"modified"}]}