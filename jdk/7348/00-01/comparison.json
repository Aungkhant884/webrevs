{"files":[{"patch":"@@ -841,14 +841,0 @@\n-        try {\n-            maybeInstantiateVerifier();\n-            if (jv == null) {\n-                return super.getInputStream(ze);\n-            }\n-            if (!jvInitialized) {\n-                initializeVerifier();\n-                jvInitialized = true;\n-                \/\/ could be set to null after a call to\n-                \/\/ initializeVerifier if we have nothing to\n-                \/\/ verify\n-                if (jv == null)\n-                    return super.getInputStream(ze);\n-            }\n@@ -856,11 +842,12 @@\n-            \/\/ wrap a verifier stream around the real stream\n-            return new JarVerifier.VerifierStream(\n-                    getManifestFromReference(),\n-                    verifiableEntry(ze),\n-                    super.getInputStream(ze),\n-                    jv);\n-        } catch (IOException | IllegalStateException | SecurityException e) {\n-            throw e;\n-        } catch (Exception e2) {\n-            \/\/ Any other Exception should be a ZipException\n-            throw (ZipException) new ZipException(\"Zip file format error\").initCause(e2);\n+        maybeInstantiateVerifier();\n+        if (jv == null) {\n+            return super.getInputStream(ze);\n+        }\n+        if (!jvInitialized) {\n+            initializeVerifier();\n+            jvInitialized = true;\n+            \/\/ could be set to null after a call to\n+            \/\/ initializeVerifier if we have nothing to\n+            \/\/ verify\n+            if (jv == null)\n+                return super.getInputStream(ze);\n@@ -868,0 +855,8 @@\n+\n+        \/\/ wrap a verifier stream around the real stream\n+        return new JarVerifier.VerifierStream(\n+                getManifestFromReference(),\n+                verifiableEntry(ze),\n+                super.getInputStream(ze),\n+                jv);\n+\n@@ -870,1 +865,1 @@\n-    private JarEntry verifiableEntry(ZipEntry ze) {\n+    private JarEntry verifiableEntry(ZipEntry ze) throws ZipException {\n@@ -875,1 +870,10 @@\n-        ze = getJarEntry(ze.getName());\n+        \/\/ ZipEntry::getName should not return null\n+        if(ze.getName() != null) {\n+            ze = getJarEntry(ze.getName());\n+        } else {\n+            throw new ZipException(\"Error: ZipEntry::getName returned null!\");\n+        }\n+        \/\/ ZipEntry returned from JarFile::getJarEntry should not be null\n+        if(ze == null) {\n+            throw new ZipException(\"Error: ZipEntry should not be null!\");\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -355,40 +355,38 @@\n-        try {\n-            int pos;\n-            ZipFileInputStream in;\n-            Source zsrc = res.zsrc;\n-            Set<InputStream> istreams = res.istreams;\n-            synchronized (this) {\n-                ensureOpen();\n-                if (Objects.equals(lastEntryName, entry.name)) {\n-                    pos = lastEntryPos;\n-                } else {\n-                    pos = zsrc.getEntryPos(entry.name, false);\n-                }\n-                if (pos == -1) {\n-                    return null;\n-                }\n-                in = new ZipFileInputStream(zsrc.cen, pos);\n-                switch (CENHOW(zsrc.cen, pos)) {\n-                    case STORED:\n-                        synchronized (istreams) {\n-                            istreams.add(in);\n-                        }\n-                        return in;\n-                    case DEFLATED:\n-                        \/\/ Inflater likes a bit of slack\n-                        \/\/ MORE: Compute good size for inflater stream:\n-                        long size = CENLEN(zsrc.cen, pos) + 2;\n-                        if (size > 65536) {\n-                            size = 8192;\n-                        }\n-                        if (size <= 0) {\n-                            size = 4096;\n-                        }\n-                        InputStream is = new ZipFileInflaterInputStream(in, res, (int) size);\n-                        synchronized (istreams) {\n-                            istreams.add(is);\n-                        }\n-                        return is;\n-                    default:\n-                        throw new ZipException(\"invalid compression method\");\n-                }\n+        int pos;\n+        ZipFileInputStream in;\n+        Source zsrc = res.zsrc;\n+        Set<InputStream> istreams = res.istreams;\n+        synchronized (this) {\n+            ensureOpen();\n+            if (Objects.equals(lastEntryName, entry.name)) {\n+                pos = lastEntryPos;\n+            } else {\n+                pos = zsrc.getEntryPos(entry.name, false);\n+            }\n+            if (pos == -1) {\n+                return null;\n+            }\n+            in = new ZipFileInputStream(zsrc.cen, pos);\n+            switch (CENHOW(zsrc.cen, pos)) {\n+                case STORED:\n+                    synchronized (istreams) {\n+                        istreams.add(in);\n+                    }\n+                    return in;\n+                case DEFLATED:\n+                    \/\/ Inflater likes a bit of slack\n+                    \/\/ MORE: Compute good size for inflater stream:\n+                    long size = CENLEN(zsrc.cen, pos) + 2;\n+                    if (size > 65536) {\n+                        size = 8192;\n+                    }\n+                    if (size <= 0) {\n+                        size = 4096;\n+                    }\n+                    InputStream is = new ZipFileInflaterInputStream(in, res, (int) size);\n+                    synchronized (istreams) {\n+                        istreams.add(is);\n+                    }\n+                    return is;\n+                default:\n+                    throw new ZipException(\"invalid compression method\");\n@@ -396,5 +394,0 @@\n-        } catch (IOException | IllegalStateException e) {\n-            throw e;\n-        } catch (Exception e2) {\n-            \/\/ Any other Exception should be a ZipException\n-            throw (ZipException) new ZipException(\"Zip file format error\").initCause(e2);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":38,"deletions":45,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.zip.ZipException;\n@@ -67,0 +68,8 @@\n+    \/\/ Error message from JarFile::verifiableEntry when ZipEntry::getName\n+    \/\/ returns null\n+    public static final String ZIPENTRY_GETNAME_NULL_ERROR_MSG\n+            = \"Error: ZipEntry::getName returned null!\";\n+    \/\/ Error message from JarFile::verifiableEntry when JarFile::getJarEntry\n+    \/\/ returns null\n+    public static final String ZIPENTRY_NULL_ERROR_MSG\n+            = \"Error: ZipEntry should not be null!\";\n@@ -957,0 +966,36 @@\n+    \/**\n+     * Validate that JarFile::verifiableEntry will throw the correct ZipException\n+     * if the ZipEntry returned from JarFile::getJarEntry is null.\n+     * @throws Exception if an error occurs\n+     *\/\n+    @Test\n+    public static void verifiableEntryZipEntryNullTest() throws Exception {\n+        try (JarFile jf = new JarFile(SIGNED_VALID_ENTRY_NAME_JAR.toFile(), true)) {\n+            var ze = new InvalidZipEntry(\"javax\/inject\/Singleton.class\");\n+            var ex= expectThrows(ZipException.class,\n+                    () -> jf.getInputStream(ze) );\n+            \/\/ Validate that we receive the expected message from\n+            \/\/ JarFile::verifiableEntry when JarFile::getJarEntry returns null\n+            assertTrue( ex != null &&\n+                    ex.getMessage().equals(ZIPENTRY_NULL_ERROR_MSG));\n+        }\n+    }\n+\n+    \/**\n+     * Validate that JarFile::verifiableEntry will throw the correct ZipException\n+     * if the ZipEntry passed to it returns null when ZipEntry::getName is invoked.\n+     * @throws Exception if an error occurs\n+     *\/\n+    @Test\n+    public static void verifiableEntryZipEntryGetNameNullTest() throws Exception {\n+        try (JarFile jf = new JarFile(SIGNED_VALID_ENTRY_NAME_JAR.toFile(), true)) {\n+            var ze = new InvalidZipEntry2(\"jjavax\/inject\/Singleton.class\");\n+            var ex= expectThrows(ZipException.class,\n+                    () -> jf.getInputStream(ze) );\n+            \/\/ Validate that we receive the expected message from\n+            \/\/ JarFile::verifiableEntry when ZipEntry::getName returns null\n+            assertTrue( ex != null &&\n+                    ex.getMessage().equals(ZIPENTRY_GETNAME_NULL_ERROR_MSG));\n+        }\n+    }\n+\n@@ -985,0 +1030,27 @@\n+\n+    \/**\n+     * Overridden ZipEntry class which will always return an invalid name\n+     * for the Zip entry\n+     *\/\n+    public static class InvalidZipEntry extends ZipEntry {\n+        public InvalidZipEntry(String name) {\n+            super(name);\n+        }\n+        public String getName() {\n+            return \"NameDoesNotExist\";\n+        }\n+    }\n+\n+    \/**\n+     * Overridden ZipEntry class which will always return null\n+     * for the Zip entry name\n+     *\/\n+    public static class InvalidZipEntry2 extends ZipEntry {\n+        public InvalidZipEntry2(String name) {\n+            super(name);\n+        }\n+        public String getName() {\n+            return null;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/GetInputStreamNPETest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"}]}