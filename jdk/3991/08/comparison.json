{"files":[{"patch":"@@ -1804,1 +1804,0 @@\n-    case lir_mul_strictfp: \/\/ fall through\n@@ -1806,1 +1805,0 @@\n-    case lir_div_strictfp: \/\/ fall through\n@@ -1817,1 +1815,0 @@\n-      case lir_mul_strictfp: \/\/ fall through\n@@ -1819,1 +1816,0 @@\n-      case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -425,4 +425,0 @@\n-  LIR_Opr tmp = LIR_OprFact::illegalOpr;\n-  if (x->is_strictfp() && (x->op() == Bytecodes::_dmul || x->op() == Bytecodes::_ddiv)) {\n-    tmp = new_register(T_DOUBLE);\n-  }\n@@ -430,1 +426,1 @@\n-  arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), x->is_strictfp());\n+  arithmetic_op_fpu(x->op(), reg, left.result(), right.result());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1631,1 +1631,0 @@\n-      case lir_mul_strictfp: \/\/ fall through\n@@ -1633,1 +1632,0 @@\n-      case lir_div_strictfp: \/\/ fall through\n@@ -1646,1 +1644,0 @@\n-      case lir_mul_strictfp: \/\/ fall through\n@@ -1648,1 +1645,0 @@\n-      case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -519,1 +519,1 @@\n-      arithmetic_op_fpu(x->op(), x->operand(), left.result(), right.result(), x->is_strictfp());\n+      arithmetic_op_fpu(x->op(), x->operand(), left.result(), right.result());\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1630,4 +1630,2 @@\n-          case lir_mul: \/\/ fall through\n-          case lir_mul_strictfp: __ fmuls(res, lreg, rreg); break;\n-          case lir_div: \/\/ fall through\n-          case lir_div_strictfp: __ fdivs(res, lreg, rreg); break;\n+          case lir_mul: __ fmuls(res, lreg, rreg); break;\n+          case lir_div: __ fdivs(res, lreg, rreg); break;\n@@ -1643,4 +1641,2 @@\n-          case lir_mul: \/\/ fall through\n-          case lir_mul_strictfp: __ fmul(res, lreg, rreg); break;\n-          case lir_div: \/\/ fall through\n-          case lir_div_strictfp: __ fdiv(res, lreg, rreg); break;\n+          case lir_mul: __ fmul(res, lreg, rreg); break;\n+          case lir_div: __ fdiv(res, lreg, rreg); break;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-    arithmetic_op_fpu(x->op(), x->operand(), left.result(), right.result(), x->is_strictfp());\n+    arithmetic_op_fpu(x->op(), x->operand(), left.result(), right.result());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1613,1 +1613,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -1615,1 +1614,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -1623,1 +1621,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -1625,1 +1622,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -1648,1 +1644,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -1650,1 +1645,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -1658,1 +1652,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -1660,1 +1653,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -334,1 +334,1 @@\n-    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), x->is_strictfp(), tmp);\n+    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), tmp);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2207,1 +2207,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -2209,1 +2208,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2226,1 +2224,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -2228,1 +2225,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2243,1 +2239,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -2245,1 +2240,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2262,1 +2256,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -2264,1 +2257,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2296,1 +2288,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -2298,1 +2289,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2307,1 +2297,1 @@\n-    if (code == lir_mul_strictfp || code == lir_div_strictfp) {\n+    if (code == lir_mul || code == lir_div) {\n@@ -2309,1 +2299,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -2333,1 +2323,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n@@ -2335,1 +2324,0 @@\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2341,1 +2329,1 @@\n-    if (code == lir_mul_strictfp || code == lir_div_strictfp) {\n+    if (code == lir_mul || code == lir_div) {\n@@ -2343,1 +2331,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -2418,1 +2406,0 @@\n-    case lir_mul_strictfp: \/\/ fall through\n@@ -2425,1 +2412,0 @@\n-    case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -396,1 +396,1 @@\n-  if (x->is_strictfp() && (x->op() == Bytecodes::_dmul || x->op() == Bytecodes::_ddiv)) {\n+  if (x->op() == Bytecodes::_dmul || x->op() == Bytecodes::_ddiv) {\n@@ -432,1 +432,1 @@\n-    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), x->is_strictfp(), tmp);\n+    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), tmp);\n@@ -452,1 +452,1 @@\n-    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), x->is_strictfp(), tmp);\n+    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -681,5 +681,7 @@\n-    case lir_mul_strictfp:\n-    case lir_div_strictfp: {\n-      assert(op2->tmp1_opr()->is_fpu_register(), \"strict operations need temporary fpu stack slot\");\n-      insert_free_if_dead(op2->tmp1_opr());\n-      assert(sim()->stack_size() <= 7, \"at least one stack slot must be free\");\n+    case lir_mul:\n+    case lir_div: {\n+      if (res->is_double_fpu()) {\n+        assert(op2->tmp1_opr()->is_fpu_register(), \"strict operations need temporary fpu stack slot\");\n+        insert_free_if_dead(op2->tmp1_opr());\n+        assert(sim()->stack_size() <= 7, \"at least one stack slot must be free\");\n+      }\n@@ -689,3 +691,1 @@\n-    case lir_sub:\n-    case lir_mul:\n-    case lir_div: {\n+    case lir_sub: {\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3870,3 +3870,3 @@\n-    StubRoutines::_fpu_subnormal_bias1[0]= 0x00000000; \/\/ 2^(-15360) == 0x03ff 8000 0000 0000 0000\n-    StubRoutines::_fpu_subnormal_bias1[1]= 0x80000000;\n-    StubRoutines::_fpu_subnormal_bias1[2]= 0x03ff;\n+    StubRoutines::x86::_fpu_subnormal_bias1[0]= 0x00000000; \/\/ 2^(-15360) == 0x03ff 8000 0000 0000 0000\n+    StubRoutines::x86::_fpu_subnormal_bias1[1]= 0x80000000;\n+    StubRoutines::x86::_fpu_subnormal_bias1[2]= 0x03ff;\n@@ -3874,3 +3874,3 @@\n-    StubRoutines::_fpu_subnormal_bias2[0]= 0x00000000; \/\/ 2^(+15360) == 0x7bff 8000 0000 0000 0000\n-    StubRoutines::_fpu_subnormal_bias2[1]= 0x80000000;\n-    StubRoutines::_fpu_subnormal_bias2[2]= 0x7bff;\n+    StubRoutines::x86::_fpu_subnormal_bias2[0]= 0x00000000; \/\/ 2^(+15360) == 0x7bff 8000 0000 0000 0000\n+    StubRoutines::x86::_fpu_subnormal_bias2[1]= 0x80000000;\n+    StubRoutines::x86::_fpu_subnormal_bias2[2]= 0x7bff;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6724,10 +6724,0 @@\n-    \/\/ Note: the following two constants are 80-bit values\n-    \/\/       layout is critical for correct loading by FPU.\n-    \/\/ Bias for strict fp multiply\/divide\n-    StubRoutines::_fpu_subnormal_bias1[0]= 0x00000000; \/\/ 2^(-15360) == 0x03ff 8000 0000 0000 0000\n-    StubRoutines::_fpu_subnormal_bias1[1]= 0x80000000;\n-    StubRoutines::_fpu_subnormal_bias1[2]= 0x03ff;\n-    \/\/ Un-Bias for strict fp multiply\/divide\n-    StubRoutines::_fpu_subnormal_bias2[0]= 0x00000000; \/\/ 2^(+15360) == 0x7bff 8000 0000 0000 0000\n-    StubRoutines::_fpu_subnormal_bias2[1]= 0x80000000;\n-    StubRoutines::_fpu_subnormal_bias2[2]= 0x7bff;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -100,0 +100,3 @@\n+  static jint    _fpu_subnormal_bias1[3];\n+  static jint    _fpu_subnormal_bias2[3];\n+\n@@ -103,0 +106,3 @@\n+  static address addr_fpu_subnormal_bias1()   { return (address)&_fpu_subnormal_bias1; }\n+  static address addr_fpu_subnormal_bias2()   { return (address)&_fpu_subnormal_bias2; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+jint StubRoutines::x86::_fpu_subnormal_bias1[3] = { 0, 0, 0 };\n+jint StubRoutines::x86::_fpu_subnormal_bias2[3] = { 0, 0, 0 };\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_32.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1636,11 +1636,2 @@\n-      Label L_strict;\n-      Label L_join;\n-      const Address access_flags      (rcx, Method::access_flags_offset());\n-      __ get_method(rcx);\n-      __ movl(rcx, access_flags);\n-      __ testl(rcx, JVM_ACC_STRICT);\n-      __ jccb(Assembler::notZero, L_strict);\n-      __ fmul_d (at_rsp());\n-      __ jmpb(L_join);\n-      __ bind(L_strict);\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      \/\/ strict semantics\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -1649,1 +1640,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -1651,1 +1642,0 @@\n-      __ bind(L_join);\n@@ -1655,11 +1645,2 @@\n-      Label L_strict;\n-      Label L_join;\n-      const Address access_flags      (rcx, Method::access_flags_offset());\n-      __ get_method(rcx);\n-      __ movl(rcx, access_flags);\n-      __ testl(rcx, JVM_ACC_STRICT);\n-      __ jccb(Assembler::notZero, L_strict);\n-      __ fdivr_d(at_rsp());\n-      __ jmp(L_join);\n-      __ bind(L_strict);\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      \/\/ strict semantics\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -1668,1 +1649,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -1670,1 +1651,0 @@\n-      __ bind(L_join);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2338,1 +2338,1 @@\n-    emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias1() );\n+    emit_d32( cbuf, (int)StubRoutines::x86::addr_fpu_subnormal_bias1() );\n@@ -2346,1 +2346,1 @@\n-    emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias2() );\n+    emit_d32( cbuf, (int)StubRoutines::x86::addr_fpu_subnormal_bias2() );\n@@ -9796,1 +9796,1 @@\n-  predicate( UseSSE<=1 && Compile::current()->has_method() && Compile::current()->method()->is_strict() );\n+  predicate( UseSSE<=1 && Compile::current()->has_method() );\n@@ -9798,1 +9798,1 @@\n-  ins_cost(1);   \/\/ Select this instruction for all strict FP double multiplies\n+  ins_cost(1);   \/\/ Select this instruction for all FP double multiplies\n@@ -9800,1 +9800,1 @@\n-  format %{ \"FLD    StubRoutines::_fpu_subnormal_bias1\\n\\t\"\n+  format %{ \"FLD    StubRoutines::x86::_fpu_subnormal_bias1\\n\\t\"\n@@ -9804,1 +9804,1 @@\n-            \"FLD    StubRoutines::_fpu_subnormal_bias2\\n\\t\"\n+            \"FLD    StubRoutines::x86::_fpu_subnormal_bias2\\n\\t\"\n@@ -9915,1 +9915,1 @@\n-  predicate( UseSSE<=1 && Compile::current()->has_method() && Compile::current()->method()->is_strict() );\n+  predicate( UseSSE<=1 && Compile::current()->has_method() );\n@@ -9918,1 +9918,1 @@\n-  format %{ \"FLD    StubRoutines::_fpu_subnormal_bias1\\n\\t\"\n+  format %{ \"FLD    StubRoutines::x86::_fpu_subnormal_bias1\\n\\t\"\n@@ -9922,1 +9922,1 @@\n-            \"FLD    StubRoutines::_fpu_subnormal_bias2\\n\\t\"\n+            \"FLD    StubRoutines::x86::_fpu_subnormal_bias2\\n\\t\"\n@@ -9932,14 +9932,0 @@\n-instruct divDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{\n-  predicate( UseSSE<=1 && !(Compile::current()->has_method() && Compile::current()->method()->is_strict()) );\n-  match(Set dst (RoundDouble (DivD src1 src2)));\n-\n-  format %{ \"FLD    $src1\\n\\t\"\n-            \"FDIV   ST,$src2\\n\\t\"\n-            \"FSTP_D $dst\\t# D-round\" %}\n-  opcode(0xD8, 0x6); \/* D8 F0+i or D8 \/6 *\/\n-  ins_encode( Push_Reg_DPR(src1),\n-              OpcP, RegOpc(src2), Pop_Mem_DPR(dst) );\n-  ins_pipe( fpu_mem_reg_reg );\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1126,3 +1126,1 @@\n-  \/\/ NOTE: strictfp can be queried from current method since we don't\n-  \/\/ inline methods with differing strictfp bits\n-  Value res = new ArithmeticOp(code, x, y, method()->is_strict(), state_before);\n+  Value res = new ArithmeticOp(code, x, y, state_before);\n@@ -1131,3 +1129,1 @@\n-  if (method()->is_strict()) {\n-    res = round_fp(res);\n-  }\n+  res = round_fp(res);\n@@ -2128,5 +2124,1 @@\n-    if (method()->is_strict()) {\n-      push(result_type, round_fp(result));\n-    } else {\n-      push(result_type, result);\n-    }\n+    push(result_type, round_fp(result));\n@@ -3767,13 +3759,0 @@\n-  if (strict_fp_requires_explicit_rounding &&\n-      method()->is_strict() != callee->is_strict()) {\n-#ifdef IA32\n-    \/\/ If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).\n-    \/\/ When SSE2 is present, no special handling is needed.\n-    if (UseSSE < 2) {\n-      INLINE_BAILOUT(\"caller and callee have different strict fp requirements\");\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -335,1 +335,0 @@\n-  set_flag(TargetIsStrictfpFlag, target_is_loaded() && target->is_strict());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -361,1 +361,0 @@\n-    IsStrictfpFlag,\n@@ -367,1 +366,0 @@\n-    TargetIsStrictfpFlag,\n@@ -1062,1 +1060,1 @@\n-  ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)\n+  ArithmeticOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)\n@@ -1065,1 +1063,0 @@\n-    set_flag(IsStrictfpFlag, is_strictfp);\n@@ -1069,3 +1066,0 @@\n-  \/\/ accessors\n-  bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }\n-\n@@ -1269,2 +1263,0 @@\n-  \/\/ Returns false if target is not loaded\n-  bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -215,1 +215,0 @@\n-    case lir_mul_strictfp:\n@@ -217,1 +216,0 @@\n-    case lir_div_strictfp:\n@@ -567,2 +565,0 @@\n-    case lir_mul:\n-    case lir_div:\n@@ -626,2 +622,2 @@\n-    case lir_mul_strictfp:\n-    case lir_div_strictfp:\n+    case lir_mul:\n+    case lir_div:\n@@ -1678,1 +1674,0 @@\n-     case lir_mul_strictfp:          s = \"mul_strictfp\";  break;\n@@ -1680,1 +1675,0 @@\n-     case lir_div_strictfp:          s = \"div_strictfp\";  break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -934,1 +934,0 @@\n-      , lir_mul_strictfp\n@@ -936,1 +935,0 @@\n-      , lir_div_strictfp\n@@ -2159,1 +2157,1 @@\n-  void mul_strictfp (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_mul_strictfp, left, right, res, tmp)); }\n+  void mul (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_mul, left, right, res, tmp)); }\n@@ -2161,1 +2159,1 @@\n-  void div_strictfp (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_div_strictfp, left, right, res, tmp)); }\n+  void div (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_div, left, right, res, tmp)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -710,1 +710,0 @@\n-    case lir_mul_strictfp:\n@@ -712,1 +711,0 @@\n-    case lir_div_strictfp:\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-void LIRGenerator::arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp_op, CodeEmitInfo* info) {\n+void LIRGenerator::arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp_op, CodeEmitInfo* info) {\n@@ -523,9 +523,1 @@\n-    case Bytecodes::_dmul:\n-      {\n-        if (is_strictfp) {\n-          __ mul_strictfp(left_op, right_op, result_op, tmp_op); break;\n-        } else {\n-          __ mul(left_op, right_op, result_op); break;\n-        }\n-      }\n-      break;\n+    case Bytecodes::_dmul:  __ mul(left_op, right_op, result_op, tmp_op); break;\n@@ -562,9 +554,1 @@\n-    case Bytecodes::_ddiv:\n-      {\n-        if (is_strictfp) {\n-          __ div_strictfp (left_op, right_op, result_op, tmp_op); break;\n-        } else {\n-          __ div (left_op, right_op, result_op); break;\n-        }\n-      }\n-      break;\n+    case Bytecodes::_ddiv: __ div(left_op, right_op, result_op, tmp_op); break;\n@@ -581,1 +565,1 @@\n-  arithmetic_op(code, result, left, right, false, tmp);\n+  arithmetic_op(code, result, left, right, tmp);\n@@ -586,1 +570,1 @@\n-  arithmetic_op(code, result, left, right, false, LIR_OprFact::illegalOpr, info);\n+  arithmetic_op(code, result, left, right, LIR_OprFact::illegalOpr, info);\n@@ -590,2 +574,2 @@\n-void LIRGenerator::arithmetic_op_fpu(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp) {\n-  arithmetic_op(code, result, left, right, is_strictfp, tmp);\n+void LIRGenerator::arithmetic_op_fpu(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp) {\n+  arithmetic_op(code, result, left, right, tmp);\n@@ -2997,11 +2981,0 @@\n-  if (x->type()->is_float() || x->type()->is_double()) {\n-    \/\/ Force rounding of results from non-strictfp when in strictfp\n-    \/\/ scope (or when we don't know the strictness of the callee, to\n-    \/\/ be safe.)\n-    if (method()->is_strict()) {\n-      if (!x->target_is_loaded() || !x->target_is_strictfp()) {\n-        result_register = round_item(result_register);\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -341,2 +341,1 @@\n-  \/\/ is_strictfp is only needed for mul and div (and only generates different code on i486)\n-  void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp, CodeEmitInfo* info = NULL);\n+  void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp, CodeEmitInfo* info = NULL);\n@@ -357,1 +356,1 @@\n-  void arithmetic_op_fpu  (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp = LIR_OprFact::illegalOpr);\n+  void arithmetic_op_fpu  (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp = LIR_OprFact::illegalOpr);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6717,1 +6717,0 @@\n-        case lir_mul_strictfp:\n@@ -6719,1 +6718,0 @@\n-        case lir_div_strictfp:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -533,1 +533,1 @@\n-            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, min_constant, lower_compare, false, NULL);\n+            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, min_constant, lower_compare, NULL);\n@@ -541,1 +541,1 @@\n-            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, max_constant, upper_compare, false, NULL);\n+            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, max_constant, upper_compare, NULL);\n@@ -663,1 +663,1 @@\n-  ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, left, false, NULL);\n+  ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, left, NULL);\n@@ -1552,1 +1552,1 @@\n-      ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, op, false, NULL);\n+      ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, op, NULL);\n@@ -1590,1 +1590,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,3 +89,0 @@\n-  if (is_strict()) {\n-    st->print(\",strict\");\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  bool is_strict               () const { return (_flags & JVM_ACC_STRICT                    ) != 0; }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -345,1 +345,0 @@\n-  bool is_strict      () const                   { return flags().is_strict(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -584,1 +584,0 @@\n-  bool is_strict() const                         { return access_flags().is_strict();      }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -562,4 +562,0 @@\n-  if( IdealizedNumerics && !phase->C->method()->is_strict() ) {\n-    return AddNode::Ideal(phase, can_reshape); \/\/ commutative and associative transforms\n-  }\n-\n@@ -597,4 +593,0 @@\n-  if( IdealizedNumerics && !phase->C->method()->is_strict() ) {\n-    return AddNode::Ideal(phase, can_reshape); \/\/ commutative and associative transforms\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -130,4 +130,0 @@\n-  develop(bool, IdealizedNumerics, false,                                   \\\n-          \"Check performance difference allowing FP \"                       \\\n-          \"associativity and commutativity...\")                             \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -780,4 +780,8 @@\n-#if defined(IA32)\n-  if (!phase->C->method()->is_strict())\n-    \/\/ Can't trust native compilers to properly fold strict double\n-    \/\/ division with round-to-zero on this platform.\n+  \/\/ IA32 would only execute this for non-strict FP, which is never the\n+  \/\/ case now.\n+#if ! defined(IA32)\n+  \/\/ If divisor is a constant and not zero, divide them numbers\n+  if( t1->base() == Type::DoubleCon &&\n+      t2->base() == Type::DoubleCon &&\n+      t2->getd() != 0.0 ) \/\/ could be negative zero\n+    return TypeD::make( t1->getd()\/t2->getd() );\n@@ -785,7 +789,0 @@\n-    {\n-      \/\/ If divisor is a constant and not zero, divide them numbers\n-      if( t1->base() == Type::DoubleCon &&\n-          t2->base() == Type::DoubleCon &&\n-          t2->getd() != 0.0 ) \/\/ could be negative zero\n-        return TypeD::make( t1->getd()\/t2->getd() );\n-    }\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -117,2 +117,0 @@\n-  \/\/ We do this before the strict f.p. check below because the\n-  \/\/ intrinsics handle strict f.p. correctly.\n@@ -155,6 +153,0 @@\n-  \/\/ If explicit rounding is required, do not inline strict into non-strict code (or the reverse).\n-  if (Matcher::strict_fp_requires_explicit_rounding &&\n-      caller->is_strict() != callee->is_strict()) {\n-    allow_inline = false;\n-  }\n-\n@@ -683,3 +675,0 @@\n-    \/\/ Round double result after a call from strict to non-strict code\n-    round_double_result(cg->method());\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2322,17 +2322,0 @@\n-void GraphKit::round_double_result(ciMethod* dest_method) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-    \/\/ If a strict caller invokes a non-strict callee, round a double result.\n-    \/\/ A non-strict method may return a double value which has an extended exponent,\n-    \/\/ but this must not be visible in a caller which is strict.\n-    BasicType result_type = dest_method->return_type()->basic_type();\n-    assert(method() != NULL, \"must have caller context\");\n-    if( result_type == T_DOUBLE && method()->is_strict() && !dest_method->is_strict() ) {\n-      \/\/ Destination method's return value is on top of stack\n-      \/\/ dstore_rounding() does gvn.transform\n-      Node *result = pop_pair();\n-      result = dstore_rounding(result);\n-      push_pair(result);\n-    }\n-  }\n-}\n-\n@@ -2361,1 +2344,1 @@\n-    if (_method->flags().is_strict() && UseSSE == 0) {\n+    if (UseSSE == 0) {\n@@ -2375,1 +2358,1 @@\n-    if (_method->flags().is_strict() && UseSSE < 2) {\n+    if (UseSSE < 2) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -780,1 +780,0 @@\n-  void round_double_result(ciMethod* dest_method);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  if (op == Op_MulD && phase->C->method()->is_strict()) {\n+  if (op == Op_MulD) {\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -467,7 +467,0 @@\n-  \/\/ Not associative because of boundary conditions (infinity)\n-  if (IdealizedNumerics && !phase->C->method()->is_strict() &&\n-      in(2)->is_Add() && in(1) == in(2)->in(1)) {\n-    \/\/ Convert \"x - (x+y)\" into \"-y\"\n-    return new SubFNode(phase->makecon(TypeF::ZERO), in(2)->in(2));\n-  }\n-\n@@ -509,7 +502,0 @@\n-  \/\/ Not associative because of boundary conditions (infinity)\n-  if (IdealizedNumerics && !phase->C->method()->is_strict() &&\n-      in(2)->is_Add() && in(1) == in(2)->in(1)) {\n-    \/\/ Convert \"x - (x+y)\" into \"-y\"\n-    return new SubDNode(phase->makecon(TypeD::ZERO), in(2)->in(2));\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,2 +82,0 @@\n-jint    StubRoutines::_fpu_subnormal_bias1[3]                   = { 0, 0, 0 };\n-jint    StubRoutines::_fpu_subnormal_bias2[3]                   = { 0, 0, 0 };\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,2 +160,0 @@\n-  static jint    _fpu_subnormal_bias1[3];\n-  static jint    _fpu_subnormal_bias2[3];\n@@ -332,2 +330,0 @@\n-  static address addr_fpu_subnormal_bias1()                { return (address)&_fpu_subnormal_bias1; }\n-  static address addr_fpu_subnormal_bias2()                { return (address)&_fpu_subnormal_bias2; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,0 @@\n-  if (is_strict      ()) st->print(\"strict \"      );\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-  bool is_strict      () const         { return (_flags & JVM_ACC_STRICT      ) != 0; }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}