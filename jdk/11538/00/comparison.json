{"files":[{"patch":"@@ -65,0 +65,5 @@\n+\n+#if !defined(WINDOWS) && !defined(MACOSX)\n+   JLI_ReExecLauncher(argc, argv);\n+#endif\n+\n@@ -166,0 +171,1 @@\n+\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-static jboolean relaunch = JNI_FALSE;\n@@ -89,9 +88,1 @@\n-    \/\/ No expansion for relaunch\n-    if (argsCount != 1) {\n-        relaunch = JNI_TRUE;\n-        stopExpansion = JNI_TRUE;\n-        argsCount = 1;\n-    } else {\n-        stopExpansion = disableArgFile;\n-    }\n-\n+    stopExpansion = disableArgFile;\n@@ -475,4 +466,0 @@\n-    if (relaunch) {\n-        return JNI_FALSE;\n-    }\n-\n","filename":"src\/java.base\/share\/native\/libjli\/args.c","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -179,0 +179,3 @@\n+static char jvmpath[MAXPATHLEN];\n+static char jrepath[MAXPATHLEN];\n+static char jvmcfg[MAXPATHLEN];\n@@ -246,3 +249,0 @@\n-    char jvmpath[MAXPATHLEN];\n-    char jrepath[MAXPATHLEN];\n-    char jvmcfg[MAXPATHLEN];\n@@ -342,0 +342,40 @@\n+\n+\/*\n+ * It's required to set or update LD_LIBRARY_PATH by the launcher in some cases:\n+ * LD_LIBRARY_PATH contains libjvm.so of different version, linker doesn't\n+ * support $ORIGIN or not able to solve dependency between libjvm and libjava.\n+ * Runtime linker respects LD_LIBRARY_PATH variable only at the time of runtime\n+ * image loading, so launcher has to re-execute itself if LD_LIBRARY_PATH\n+ * was altered.\n+ *\n+ * All required logic is held within CreateExecutionEnvironment, this function is\n+ * just a shell, that allows us to check for re-execution before any argument\n+ * processing, environment variable or optionfile expansion.\n+ *\/\n+\n+JNIEXPORT void JNICALL\n+JLI_ReExecLauncher(int argc, char **argv) {\n+\n+    \/**\n+     * Fast path for the most common case\n+     *\/\n+#if !defined (MUSL_LIBC) && !defined(AIX)\n+    if (getenv(\"LD_LIBRARY_PATH\") == NULL) {\n+        return;\n+    }\n+#endif\n+\n+    JLI_SetTraceLauncher();\n+    JLI_TraceLauncher(\"Launcher journey begins.\\n\");\n+\n+    \/* Init static variables *\/\n+    jrepath[0] = '\\0';\n+    jvmpath[0] = '\\0';\n+    jvmcfg[0] = '\\0';\n+\n+    CreateExecutionEnvironment(&argc, &argv,\n+                               jrepath, sizeof(jrepath),\n+                               jvmpath, sizeof(jvmpath),\n+                               jvmcfg,  sizeof(jvmcfg));\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":43,"deletions":3,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -103,0 +103,3 @@\n+JNIEXPORT void JNICALL\n+JLI_ReExecLauncher(int argc, char **argv);\n+\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,5 +49,0 @@\n-\/* help jettison the LD_LIBRARY_PATH settings in the future *\/\n-#ifndef SETENV_REQUIRED\n-#define SETENV_REQUIRED\n-#endif\n-\n@@ -164,1 +159,0 @@\n-#ifdef SETENV_REQUIRED\n@@ -183,0 +177,1 @@\n+    char minimalPattern[] = \"lib\/minimal\";\n@@ -188,0 +183,1 @@\n+    jboolean minimalPatternFound;\n@@ -197,1 +193,2 @@\n-    if (clientPatternFound == JNI_FALSE && serverPatternFound == JNI_FALSE) {\n+    minimalPatternFound = JLI_StrStr(env, serverPattern) != NULL;\n+    if (clientPatternFound == JNI_FALSE && serverPatternFound == JNI_FALSE && minimalPatternFound == JNI_FALSE) {\n@@ -292,1 +289,0 @@\n-#endif \/* SETENV_REQUIRED *\/\n@@ -303,1 +299,0 @@\n-#ifdef SETENV_REQUIRED\n@@ -311,1 +306,0 @@\n-#endif  \/* SETENV_REQUIRED *\/\n@@ -318,3 +312,5 @@\n-    if (!GetJREPath(jrepath, so_jrepath, JNI_FALSE)) {\n-        JLI_ReportErrorMessage(JRE_ERROR1);\n-        exit(2);\n+    if (jrepath[0] == '\\0') {\n+        if (!GetJREPath(jrepath, so_jrepath, JNI_FALSE)) {\n+            JLI_ReportErrorMessage(JRE_ERROR1);\n+            exit(2);\n+        }\n@@ -322,6 +318,9 @@\n-    JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%sjvm.cfg\",\n-            jrepath, FILESEP, FILESEP);\n-    \/* Find the specified JVM type *\/\n-    if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {\n-        JLI_ReportErrorMessage(CFG_ERROR7);\n-        exit(1);\n+\n+    if (jvmcfg[0] == '\\0') {\n+        JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%sjvm.cfg\",\n+                jrepath, FILESEP, FILESEP);\n+        \/* Find the specified JVM type *\/\n+        if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {\n+            JLI_ReportErrorMessage(CFG_ERROR7);\n+            exit(1);\n+        }\n@@ -330,0 +329,1 @@\n+    \/* Always repeat this step because arguments can affect choice *\/\n@@ -345,1 +345,0 @@\n-#ifdef SETENV_REQUIRED\n@@ -352,3 +351,0 @@\n-#else\n-    return;\n-#endif \/* SETENV_REQUIRED *\/\n@@ -356,12 +352,3 @@\n-#ifdef SETENV_REQUIRED\n-    if (mustsetenv) {\n-        \/*\n-         * We will set the LD_LIBRARY_PATH as follows:\n-         *\n-         *     o          $JVMPATH (directory portion only)\n-         *     o          $JRE\/lib\n-         *     o          $JRE\/..\/lib\n-         *\n-         * followed by the user's previous effective LD_LIBRARY_PATH, if\n-         * any.\n-         *\/\n+    \/**\n+     * Update execution environment and re-exec the launcher\n+     *\/\n@@ -369,1 +356,12 @@\n-        runpath = getenv(LD_LIBRARY_PATH);\n+    \/*\n+     * We will set the LD_LIBRARY_PATH as follows:\n+     *\n+     *     o          $JVMPATH (directory portion only)\n+     *     o          $JRE\/lib\n+     *     o          $JRE\/..\/lib\n+     *\n+     * followed by the user's previous effective LD_LIBRARY_PATH, if\n+     * any.\n+     *\/\n+\n+    runpath = getenv(LD_LIBRARY_PATH);\n@@ -371,8 +369,8 @@\n-        \/* runpath contains current effective LD_LIBRARY_PATH setting *\/\n-        { \/* New scope to declare local variable *\/\n-            char *new_jvmpath = JLI_StringDup(jvmpath);\n-            new_runpath_size = ((runpath != NULL) ? JLI_StrLen(runpath) : 0) +\n-                    2 * JLI_StrLen(jrepath) +\n-                    JLI_StrLen(new_jvmpath) + 52;\n-            new_runpath = JLI_MemAlloc(new_runpath_size);\n-            newpath = new_runpath + JLI_StrLen(LD_LIBRARY_PATH \"=\");\n+    \/* runpath contains current effective LD_LIBRARY_PATH setting *\/\n+    { \/* New scope to declare local variable *\/\n+        char *new_jvmpath = JLI_StringDup(jvmpath);\n+        new_runpath_size = ((runpath != NULL) ? JLI_StrLen(runpath) : 0) +\n+                2 * JLI_StrLen(jrepath) +\n+                JLI_StrLen(new_jvmpath) + 52;\n+        new_runpath = JLI_MemAlloc(new_runpath_size);\n+        newpath = new_runpath + JLI_StrLen(LD_LIBRARY_PATH \"=\");\n@@ -381,0 +379,20 @@\n+        \/*\n+         * Create desired LD_LIBRARY_PATH value for target data model.\n+         *\/\n+        {\n+            \/* remove the name of the .so from the JVM path *\/\n+            lastslash = JLI_StrRChr(new_jvmpath, '\/');\n+            if (lastslash)\n+                *lastslash = '\\0';\n+\n+            sprintf(new_runpath, LD_LIBRARY_PATH \"=\"\n+                    \"%s:\"\n+                    \"%s\/lib:\"\n+                    \"%s\/..\/lib\",\n+                    new_jvmpath,\n+                    jrepath,\n+                    jrepath\n+                    );\n+\n+            JLI_MemFree(new_jvmpath);\n+\n@@ -382,1 +400,4 @@\n-             * Create desired LD_LIBRARY_PATH value for target data model.\n+             * Check to make sure that the prefix of the current path is the\n+             * desired environment variable setting, though the RequiresSetenv\n+             * checks if the desired runpath exists, this logic does a more\n+             * comprehensive check.\n@@ -384,30 +405,7 @@\n-            {\n-                \/* remove the name of the .so from the JVM path *\/\n-                lastslash = JLI_StrRChr(new_jvmpath, '\/');\n-                if (lastslash)\n-                    *lastslash = '\\0';\n-\n-                sprintf(new_runpath, LD_LIBRARY_PATH \"=\"\n-                        \"%s:\"\n-                        \"%s\/lib:\"\n-                        \"%s\/..\/lib\",\n-                        new_jvmpath,\n-                        jrepath,\n-                        jrepath\n-                        );\n-\n-                JLI_MemFree(new_jvmpath);\n-\n-                \/*\n-                 * Check to make sure that the prefix of the current path is the\n-                 * desired environment variable setting, though the RequiresSetenv\n-                 * checks if the desired runpath exists, this logic does a more\n-                 * comprehensive check.\n-                 *\/\n-                if (runpath != NULL &&\n-                        JLI_StrNCmp(newpath, runpath, JLI_StrLen(newpath)) == 0 &&\n-                        (runpath[JLI_StrLen(newpath)] == 0 ||\n-                        runpath[JLI_StrLen(newpath)] == ':')) {\n-                    JLI_MemFree(new_runpath);\n-                    return;\n-                }\n+            if (runpath != NULL &&\n+                    JLI_StrNCmp(newpath, runpath, JLI_StrLen(newpath)) == 0 &&\n+                    (runpath[JLI_StrLen(newpath)] == 0 ||\n+                    runpath[JLI_StrLen(newpath)] == ':')) {\n+                JLI_MemFree(new_runpath);\n+                JLI_TraceLauncher(\"LD_LIBRARY_PATH is already correct, will not EXEC\");\n+                return;\n@@ -445,1 +443,0 @@\n-#endif \/* SETENV_REQUIRED *\/\n@@ -451,9 +448,2 @@\n-#ifdef SETENV_REQUIRED\n-        if (mustsetenv) {\n-            execve(newexec, argv, newenvp);\n-        } else {\n-            execv(newexec, argv);\n-        }\n-#else \/* !SETENV_REQUIRED *\/\n-        execv(newexec, argv);\n-#endif \/* SETENV_REQUIRED *\/\n+\n+        execve(newexec, argv, newenvp);\n@@ -465,1 +455,0 @@\n-\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":75,"deletions":86,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -218,0 +218,18 @@\n+        }\n+    }\n+\n+    @Test\n+    public void NoOptionsDuplication() {\n+        if (System.getProperty(\"os.family\") == \"windows\") {\n+           \/* This test has no value on windows *\/\n+           return;\n+        }\n+        env.put(JDK_JAVA_OPTIONS, \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005\");\n+        String testJdk = System.getProperty(\"test.jdk\");\n+        String libraryPath = \"\/usr\/bin:\" + testJdk + \"\/lib\/server:\" + testJdk + \"\/lib\/client\";\n+        env.put(\"LD_LIBRARY_PATH\", libraryPath);\n+        TestResult tr = doExec(env, javaCmd, \"-version\");\n+        tr.notContains(\"ERROR: Cannot load this JVM TI agent twice\");\n+        if (!tr.testStatus) {\n+            System.out.println(tr);\n+            throw new RuntimeException(\"test fails\");\n","filename":"test\/jdk\/tools\/launcher\/ArgsEnvVar.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}