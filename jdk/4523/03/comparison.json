{"files":[{"patch":"@@ -640,1 +640,1 @@\n-        boolean haveSourcePath = includeSourcePath && fileManager.hasLocation(SOURCE_PATH);\n+        boolean haveSourcePath = fileManager.hasLocation(SOURCE_PATH);\n@@ -672,6 +672,27 @@\n-        if (wantSourceFiles && !haveSourcePath) {\n-            fillIn(p, CLASS_PATH,\n-                   list(CLASS_PATH,\n-                        p,\n-                        packageName,\n-                        kinds));\n+        if (!haveSourcePath) {\n+            \/\/ The `hasSourcePath` is false, so we have no source path.\n+            \/\/ We always scans source files and class files from class path.\n+            if (wantClassFiles)\n+                fillIn(p, CLASS_PATH,\n+                       list(CLASS_PATH,\n+                            p,\n+                            packageName,\n+                            classKinds));\n+            if (wantSourceFiles)\n+                fillIn(p, CLASS_PATH,\n+                       list(CLASS_PATH,\n+                            p,\n+                            packageName,\n+                            sourceKinds));\n+        } else if (!includeSourcePath) {\n+            \/\/ The `hasSourcePath` is true and the `includeSourcePath` is false.\n+            \/\/ The `hasSourcePath` == true means that we have source path.\n+            \/\/ So we should scan source files from source path instead of class path.\n+            \/\/ And the `includeSourcePath` == false means that we should skip the source path.\n+            \/\/ So we actually don't need the source path and source files here.\n+            if (wantClassFiles)\n+                fillIn(p, CLASS_PATH,\n+                       list(CLASS_PATH,\n+                            p,\n+                            packageName,\n+                            classKinds));\n@@ -679,0 +700,2 @@\n+            \/\/ Both the `hasSourcePath` and `includeSourcePath` are true.\n+            \/\/ We scan source files from source path and scan class files from class path.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8263926\n+ * @summary JavacFileManager.hasExplicitLocation fails with NPE while compiling\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jartool\/sun.tools.jar\n+ * @build toolbox.ToolBox toolbox.JavacTask toolbox.JarTask\n+ * @run main SourceLocationNotExist\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.FileTime;\n+\n+import java.util.List;\n+import java.util.Arrays;\n+\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavacTask;\n+import toolbox.JarTask;\n+import toolbox.Task;\n+\n+public class SourceLocationNotExist extends TestRunner {\n+    ToolBox tb;\n+\n+    private static final String libCode = \"\"\"\n+            package test;\n+            public class TestUnnamedModule {\n+            }\n+            \"\"\";\n+\n+    private static final String moduleInfoWithoutRequires = \"\"\"\n+            module use {\n+            }\n+            \"\"\";\n+\n+    private static final String moduleInfoWithRequires = \"\"\"\n+            module use {\n+                requires test;\n+            }\n+            \"\"\";\n+\n+    private static final String testUseCode = \"\"\"\n+            import test.TestUnnamedModule;\n+            public class TestUse {\n+            }\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        SourceLocationNotExist test = new SourceLocationNotExist();\n+        test.runTests();\n+    }\n+\n+    public SourceLocationNotExist() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    @Test\n+    public void testSourceLocationNotExist() throws Exception {\n+        \/\/ Compile TestUnnamedModule.java into package test.\n+        Path rootPath = Paths.get(\".\");\n+        Path testPath = Paths.get(\"test\");\n+        tb.writeJavaFiles(rootPath, libCode);\n+        new JavacTask(tb)\n+                .files(tb.findJavaFiles(testPath))\n+                .outdir(\".\")\n+                .run();\n+\n+        \/\/ Update the last modified time of the file TestUnnamedModule.java.\n+        FileTime classFileTime = Files.getLastModifiedTime(testPath.resolve(\"TestUnnamedModule.class\"));\n+        FileTime javaFileTime = FileTime.fromMillis(classFileTime.toMillis() + 100000);\n+        Files.setLastModifiedTime(testPath.resolve(\"TestUnnamedModule.java\"), javaFileTime);\n+\n+        \/\/ Construct the jar file: test.jar.\n+        new JarTask(tb).run(\"cf\", \"test.jar\",\n+                            testPath.resolve(\"TestUnnamedModule.class\").toString(),\n+                            testPath.resolve(\"TestUnnamedModule.java\").toString());\n+\n+        \/\/ Construct the module `use` without requires.\n+        Path usePath = Paths.get(\"use\");\n+        tb.writeJavaFiles(usePath, testUseCode, moduleInfoWithoutRequires);\n+        List<Path> withoutRequires = Arrays.asList(tb.findJavaFiles(usePath));\n+\n+        \/\/ Compile the module `use` without requires by using different options.\n+        \/\/ Use `-classpath` instead of `--module-path`.\n+        List<String> options = Arrays.asList(\"-classpath\", \"test.jar\", \"-d\", \"use\", \"-sourcepath\", \"use\", \"-XDrawDiagnostics\");\n+        List<String> expected = Arrays.asList(\n+                \"TestUse.java:1:8: compiler.err.package.not.visible: test, \" +\n+                        \"(compiler.misc.not.def.access.does.not.read.unnamed: test, use)\",\n+                \"1 error\");\n+        \/\/ Before patch JDK-8263926, this compilation make compiler crash with NPE.\n+        \/\/ After patch JDK-8263926, the compiler outputs the corresponding error messages.\n+        testCompileFail(withoutRequires, options, expected);\n+        \/\/ Use `--module-path` instead of `-classpath`.\n+        options = Arrays.asList(\"--module-path\", \"test.jar\", \"-d\", \"use\", \"-sourcepath\", \"use\", \"-XDrawDiagnostics\");\n+        expected = Arrays.asList(\n+                \"TestUse.java:1:8: compiler.err.package.not.visible: test, \" +\n+                        \"(compiler.misc.not.def.access.does.not.read: use, test, test)\",\n+                \"1 error\");\n+        testCompileFail(withoutRequires, options, expected);\n+\n+        \/\/ Remove the module `use`.\n+        Files.walk(usePath).map(Path::toFile).forEach(File::delete);\n+\n+        \/\/ Construct the module `use` with requires.\n+        usePath = Paths.get(\"use\");\n+        tb.writeJavaFiles(usePath, moduleInfoWithRequires, testUseCode);\n+        List<Path> withRequires = Arrays.asList(tb.findJavaFiles(usePath));\n+\n+        \/\/ Compile the module `use` with requires by using different options.\n+        \/\/ Use `-classpath` instead of `--module-path`.\n+        options = Arrays.asList(\"-classpath\", \"test.jar\", \"-d\", \"use\", \"-sourcepath\", \"use\", \"-XDrawDiagnostics\");\n+        expected = Arrays.asList(\"module-info.java:2:14: compiler.err.module.not.found: test\", \"1 error\");\n+        testCompileFail(withRequires, options, expected);\n+        \/\/ Use `--module-path` instead of `-classpath`.\n+        options = Arrays.asList(\"--module-path\", \"test.jar\", \"-d\", \"use\", \"-sourcepath\", \"use\", \"-XDrawDiagnostics\");\n+        expected = Arrays.asList(\"\");\n+        testCompileOK(withRequires, options, expected);\n+    }\n+\n+    public void testCompileOK(List<Path> files, List<String> options, List<String> expected) {\n+        testCompile(Task.Expect.SUCCESS, files, options, expected);\n+    }\n+\n+    public void testCompileFail(List<Path> files, List<String> options, List<String> expected) {\n+        testCompile(Task.Expect.FAIL, files, options, expected);\n+    }\n+\n+    public void testCompile(Task.Expect result, List<Path> files, List<String> options, List<String> expectedOutput) {\n+        List<String> output = new JavacTask(tb)\n+                .files(files)\n+                .options(options)\n+                .run(result)\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+        tb.checkEqual(expectedOutput, output);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/modules\/SourceLocationNotExist.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}