{"files":[{"patch":"@@ -1886,0 +1886,11 @@\n+\/\/ Returns the BasicType of a given convert node and a type, with special handling to ensure that conversions to\n+\/\/ and from half float will return the SHORT basic type, as that wouldn't be returned typically from TypeInt.\n+static BasicType get_convert_type(Node* convert, const Type* type) {\n+  int convert_op = convert->Opcode();\n+  if (type->isa_int() && (convert_op == Op_ConvHF2F || convert_op == Op_ConvF2HF)) {\n+    return T_SHORT;\n+  }\n+\n+  return type->basic_type();\n+}\n+\n@@ -2560,0 +2571,35 @@\n+  \/\/ Try to convert a Phi with two duplicated convert nodes into a phi of the pre-conversion type and the convert node\n+  \/\/ proceeding the phi, to de-duplicate the convert node and compact the IR.\n+  if (can_reshape && progress == nullptr) {\n+    ConvertNode* convert = in(1)->isa_Convert();\n+    if (convert != nullptr) {\n+      int conv_op = convert->Opcode();\n+      bool ok = true;\n+\n+      \/\/ Check the rest of the inputs\n+      for (uint i = 2; i < req(); i++) {\n+        \/\/ Make sure that all inputs are of the same type of convert node\n+        if (in(i)->Opcode() != conv_op) {\n+          ok = false;\n+          break;\n+        }\n+      }\n+\n+      if (ok) {\n+        \/\/ Find the local bottom type to set as the type of the phi\n+        const Type* source_type = Type::get_const_basic_type(convert->in_type()->basic_type());\n+        const Type* dest_type = convert->bottom_type();\n+\n+        PhiNode* newphi = new PhiNode(in(0), source_type, nullptr);\n+        \/\/ Set inputs to the new phi be the inputs of the convert\n+        for (uint i = 1; i < req(); i++) {\n+          newphi->init_req(i, in(i)->in(1));\n+        }\n+\n+        phase->is_IterGVN()->register_new_node_with_optimizer(newphi, this);\n+\n+        return ConvertNode::create_convert(get_convert_type(convert, source_type), get_convert_type(convert, dest_type), newphi);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -91,0 +91,48 @@\n+uint ConvertNode::ideal_reg() const {\n+  return _type->ideal_reg();\n+}\n+\n+Node* ConvertNode::create_convert(BasicType source, BasicType target, Node* input) {\n+  if (source == T_INT) {\n+    if (target == T_LONG) {\n+      return new ConvI2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvI2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvI2DNode(input);\n+    }\n+  } else if (source == T_LONG) {\n+    if (target == T_INT) {\n+      return new ConvL2INode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvL2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvL2DNode(input);\n+    }\n+  } else if (source == T_FLOAT) {\n+    if (target == T_INT) {\n+      return new ConvF2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvF2LNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvF2DNode(input);\n+    } else if (target == T_SHORT) {\n+      return new ConvF2HFNode(input);\n+    }\n+  } else if (source == T_DOUBLE) {\n+    if (target == T_INT) {\n+      return new ConvD2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvD2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvD2FNode(input);\n+    }\n+  } else if (source == T_SHORT) {\n+    if (target == T_FLOAT) {\n+      return new ConvHF2FNode(input);\n+    }\n+  }\n+\n+  assert(false, \"Couldn't create conversion for type %s to %s\", type2name(source), type2name(target));\n+  return nullptr;\n+}\n@@ -196,2 +244,3 @@\n-  if (t == Type::FLOAT) return TypeInt::SHORT;\n-  if (StubRoutines::f2hf_adr() == nullptr) return bottom_type();\n+  if (t == Type::FLOAT || StubRoutines::f2hf_adr() == nullptr) {\n+    return TypeInt::SHORT;\n+  }\n@@ -266,2 +315,3 @@\n-  if (t == TypeInt::SHORT) return Type::FLOAT;\n-  if (StubRoutines::hf2f_adr() == nullptr) return bottom_type();\n+  if (t == TypeInt::SHORT || StubRoutines::hf2f_adr() == nullptr) {\n+    return Type::FLOAT;\n+  }\n@@ -273,1 +323,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -283,1 +333,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -293,1 +343,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -713,1 +763,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -723,1 +773,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -45,0 +45,15 @@\n+class ConvertNode : public TypeNode {\n+protected:\n+  ConvertNode(const Type* t, Node* input) : TypeNode(t, 2) {\n+    init_class_id(Class_Convert);\n+    init_req(1, input);\n+  }\n+public:\n+  virtual const Type* in_type() const = 0;\n+  virtual uint ideal_reg() const;\n+\n+  \/\/ Create a convert node for a given input and output type.\n+  \/\/ Conversions to and from half float are specified via T_SHORT.\n+  static Node* create_convert(BasicType source, BasicType target, Node* input);\n+};\n+\n@@ -48,1 +63,1 @@\n-class ConvD2FNode : public Node {\n+class ConvD2FNode : public ConvertNode {\n@@ -50,1 +65,1 @@\n-  ConvD2FNode( Node *in1 ) : Node(0,in1) {}\n+  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT,in1) {}\n@@ -52,1 +67,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -55,2 +70,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -61,1 +75,1 @@\n-class ConvD2INode : public Node {\n+class ConvD2INode : public ConvertNode {\n@@ -63,1 +77,1 @@\n-  ConvD2INode( Node *in1 ) : Node(0,in1) {}\n+  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT,in1) {}\n@@ -65,1 +79,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -68,2 +82,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -74,1 +87,1 @@\n-class ConvD2LNode : public Node {\n+class ConvD2LNode : public ConvertNode {\n@@ -76,1 +89,1 @@\n-  ConvD2LNode( Node *dbl ) : Node(0,dbl) {}\n+  ConvD2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n@@ -78,1 +91,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -81,10 +94,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint ideal_reg() const { return Op_RegL; }\n-};\n-\n-class RoundDNode : public Node {\n-  public:\n-  RoundDNode( Node *dbl ) : Node(0,dbl) {}\n-  virtual int Opcode() const;\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n-  virtual uint ideal_reg() const { return Op_RegL; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -95,1 +99,1 @@\n-class ConvF2DNode : public Node {\n+class ConvF2DNode : public ConvertNode {\n@@ -97,1 +101,1 @@\n-  ConvF2DNode( Node *in1 ) : Node(0,in1) {}\n+  ConvF2DNode(Node* in1) : ConvertNode(Type::DOUBLE,in1) {}\n@@ -99,1 +103,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return Type::FLOAT; }\n@@ -101,1 +105,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -106,1 +109,1 @@\n-class ConvF2HFNode : public Node {\n+class ConvF2HFNode : public ConvertNode {\n@@ -108,1 +111,1 @@\n-  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  ConvF2HFNode(Node* in1) : ConvertNode(TypeInt::SHORT, in1) {}\n@@ -110,1 +113,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -112,1 +115,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -117,3 +119,3 @@\n-class ConvF2INode : public Node {\n-  public:\n-  ConvF2INode( Node *in1 ) : Node(0,in1) {}\n+class ConvF2INode : public ConvertNode {\n+public:\n+  ConvF2INode(Node* in1) : ConvertNode(TypeInt::INT, in1) {}\n@@ -121,1 +123,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -124,2 +126,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -128,1 +129,0 @@\n-\n@@ -131,3 +131,3 @@\n-class ConvF2LNode : public Node {\n-  public:\n-  ConvF2LNode( Node *in1 ) : Node(0,in1) {}\n+class ConvF2LNode : public ConvertNode {\n+public:\n+  ConvF2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n@@ -135,1 +135,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -138,2 +138,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegL; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -144,3 +143,3 @@\n-class ConvHF2FNode : public Node {\n-  public:\n-  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvHF2FNode : public ConvertNode {\n+public:\n+  ConvHF2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -148,1 +147,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeInt::SHORT; }\n@@ -150,1 +149,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -155,3 +153,3 @@\n-class ConvI2DNode : public Node {\n-  public:\n-  ConvI2DNode( Node *in1 ) : Node(0,in1) {}\n+class ConvI2DNode : public ConvertNode {\n+public:\n+  ConvI2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n@@ -159,1 +157,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -161,1 +159,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -166,3 +163,3 @@\n-class ConvI2FNode : public Node {\n-  public:\n-  ConvI2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvI2FNode : public ConvertNode {\n+public:\n+  ConvI2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -170,1 +167,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -173,9 +170,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n-};\n-\n-class RoundFNode : public Node {\n-  public:\n-  RoundFNode( Node *in1 ) : Node(0,in1) {}\n-  virtual int Opcode() const;\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -186,1 +174,1 @@\n-class ConvI2LNode : public TypeNode {\n+class ConvI2LNode : public ConvertNode {\n@@ -188,3 +176,1 @@\n-  ConvI2LNode(Node *in1, const TypeLong* t = TypeLong::INT)\n-  : TypeNode(t, 2)\n-  { init_req(1, in1); }\n+  ConvI2LNode(Node* in1, const TypeLong* t = TypeLong::INT) : ConvertNode(t, in1) {}\n@@ -192,0 +178,1 @@\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -193,1 +180,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -195,1 +182,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegL; }\n@@ -200,3 +186,3 @@\n-class ConvL2DNode : public Node {\n-  public:\n-  ConvL2DNode( Node *in1 ) : Node(0,in1) {}\n+class ConvL2DNode : public ConvertNode {\n+public:\n+  ConvL2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n@@ -204,1 +190,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -206,1 +192,0 @@\n-  virtual uint ideal_reg() const { return Op_RegD; }\n@@ -211,3 +196,3 @@\n-class ConvL2FNode : public Node {\n-  public:\n-  ConvL2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvL2FNode : public ConvertNode {\n+public:\n+  ConvL2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -215,1 +200,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -217,1 +202,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -222,1 +206,1 @@\n-class ConvL2INode : public TypeNode {\n+class ConvL2INode : public ConvertNode {\n@@ -224,4 +208,1 @@\n-  ConvL2INode(Node *in1, const TypeInt* t = TypeInt::INT)\n-  : TypeNode(t, 2) {\n-    init_req(1, in1);\n-  }\n+  ConvL2INode(Node* in1, const TypeInt* t = TypeInt::INT) : ConvertNode(t, in1) {}\n@@ -229,0 +210,1 @@\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -231,1 +213,16 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n+class RoundDNode : public Node {\n+public:\n+  RoundDNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+class RoundFNode : public Node {\n+public:\n+  RoundFNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":86,"deletions":89,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class ConvertNode;\n@@ -734,0 +735,1 @@\n+      DEFINE_CLASS_ID(Convert, Type, 10)\n@@ -892,0 +894,1 @@\n+  DEFINE_CLASS_QUERY(Convert)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1496,0 +1496,1 @@\n+  declare_c2_type(ConvertNode, TypeNode)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test that patterns involving duplicated conversion nodes behind phi are properly optimized.\n+ * @bug 8316918\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestPhiDuplicatedConversion\n+ *\/\n+public class TestPhiDuplicatedConversion {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float int2Float(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double int2Double(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long int2Long(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int float2Int(boolean c, float a, float b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double float2Double(boolean c, float a, float b) {\n+        return c ? (double)a : (double)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long float2Long(boolean c, float a, float b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int double2Int(boolean c, double a, double b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float double2Float(boolean c, double a, double b) {\n+        return c ? (float)a : (float)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static long double2Long(boolean c, double a, double b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float long2Float(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static double long2Double(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static int long2Int(boolean c, long a, long b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static short float2HalfFloat(boolean c, float a, float b) {\n+        return c ? Float.floatToFloat16(a) : Float.floatToFloat16(b);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"})\n+    public static float halfFloat2Float(boolean c, short a, short b) {\n+        return c ? Float.float16ToFloat(a) : Float.float16ToFloat(b);\n+    }\n+\n+    @Run(test = {\"int2Float\", \"int2Double\", \"int2Long\",\n+                 \"float2Int\", \"float2Double\", \"float2Long\",\n+                 \"double2Int\", \"double2Float\", \"double2Long\",\n+                 \"long2Float\", \"long2Double\", \"long2Int\",\n+                 \"float2HalfFloat\", \"halfFloat2Float\"})\n+    public void runTests() {\n+        assertResults(true, 10, 20, 3.14f, -1.6f, 3.1415, -1.618, 30L, 400L, Float.floatToFloat16(10.5f), Float.floatToFloat16(20.5f));\n+        assertResults(false, 10, 20, 3.14f, -1.6f, 3.1415, -1.618, 30L, 400L, Float.floatToFloat16(10.5f), Float.floatToFloat16(20.5f));\n+    }\n+\n+    @DontCompile\n+    public void assertResults(boolean c, int intA, int intB, float floatA, float floatB, double doubleA, double doubleB, long longA, long longB, short halfFloatA, short halfFloatB) {\n+        Asserts.assertEQ(c ? (float)intA : (float)intB, int2Float(c, intA, intB));\n+        Asserts.assertEQ(c ? (double)intA : (double)intB, int2Double(c, intA, intB));\n+        Asserts.assertEQ(c ? (long)intA : (long)intB, int2Long(c, intA, intB));\n+        Asserts.assertEQ(c ? (int)floatA : (int)floatB, float2Int(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (double)floatA : (double)floatB, float2Double(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (long)floatA : (long)floatB, float2Long(c, floatA, floatB));\n+        Asserts.assertEQ(c ? (int)doubleA : (int)doubleB, double2Int(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (float)doubleA : (float)doubleB, double2Float(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (long)doubleA : (long)doubleB, double2Long(c, doubleA, doubleB));\n+        Asserts.assertEQ(c ? (float)longA : (float)longB, long2Float(c, longA, longB));\n+        Asserts.assertEQ(c ? (double)longA : (double)longB, long2Double(c, longA, longB));\n+        Asserts.assertEQ(c ? (int)longA : (int)longB, long2Int(c, longA, longB));\n+        Asserts.assertEQ(c ? Float.floatToFloat16(floatA) : Float.floatToFloat16(floatB), float2HalfFloat(c, floatA, floatB));\n+        Asserts.assertEQ(c ? Float.float16ToFloat(halfFloatA) : Float.float16ToFloat(halfFloatB), halfFloat2Float(c, halfFloatA, halfFloatB));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPhiDuplicatedConversion.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -445,0 +445,5 @@\n+    public static final String CONV = PREFIX + \"CONV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV, \"Conv\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 4, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class PhiDuplicatedConversion {\n+    public static final int SIZE = 300;\n+\n+    \/\/ Ints\n+\n+    @Benchmark\n+    public void testInt2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2f(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInt2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2d(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInt2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(i2l(state.bools[i], state.ints[i], state.ints[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Floats\n+\n+    @Benchmark\n+    public void testFloat2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2i(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testFloat2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2d(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testFloat2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(f2l(state.bools[i], state.floats[i], state.floats[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Doubles\n+\n+    @Benchmark\n+    public void testDouble2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2i(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDouble2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2f(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDouble2Long(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(d2l(state.bools[i], state.doubles[i], state.doubles[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    \/\/ Longs\n+\n+    @Benchmark\n+    public void testLong2Float(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2f(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLong2Double(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2d(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLong2Int(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(l2i(state.bools[i], state.longs[i], state.longs[SIZE - 1 - i]));\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float i2f(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double i2d(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long i2l(boolean c, int a, int b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int f2i(boolean c, float a, float b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double f2d(boolean c, float a, float b) {\n+        return c ? (double)a : (double)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long f2l(boolean c, float a, float b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int d2i(boolean c, double a, double b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float d2f(boolean c, double a, double b) {\n+        return c ? (float)a : (float)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static long d2l(boolean c, double a, double b) {\n+        return c ? (long)a : (long)b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static float l2f(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static double l2d(boolean c, long a, long b) {\n+        return c ? a : b;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int l2i(boolean c, long a, long b) {\n+        return c ? (int)a : (int)b;\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        public boolean[] bools;\n+        public int[] ints;\n+        public long[] longs;\n+        public float[] floats;\n+        public double[] doubles;\n+        public BenchState() {\n+\n+        }\n+\n+        @Setup(Level.Iteration)\n+        public void setup() {\n+            Random random = new Random(1000);\n+            bools = new boolean[SIZE];\n+            ints = new int[SIZE];\n+            longs = new long[SIZE];\n+            floats = new float[SIZE];\n+            doubles = new double[SIZE];\n+\n+            for (int i = 0; i < SIZE; i++) {\n+                bools[i] = random.nextBoolean();\n+                ints[i] = random.nextInt(100);\n+                longs[i] = random.nextLong(100);\n+                floats[i] = random.nextFloat(100);\n+                doubles[i] = random.nextDouble(100);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/PhiDuplicatedConversion.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"}]}