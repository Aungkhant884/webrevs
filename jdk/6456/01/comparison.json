{"files":[{"patch":"@@ -339,13 +339,14 @@\n-    if (end->as_Goto() != NULL) {\n-      assert(end->number_of_sux() == 1, \"end must have exactly one successor\");\n-      \/\/ Note: It would be sufficient to check for the number of successors (= 1)\n-      \/\/       in order to decide if this block can be merged potentially. That\n-      \/\/       would then also include switch statements w\/ only a default case.\n-      \/\/       However, in that case we would need to make sure the switch tag\n-      \/\/       expression is executed if it can produce observable side effects.\n-      \/\/       We should probably have the canonicalizer simplifying such switch\n-      \/\/       statements and then we are sure we don't miss these merge opportunities\n-      \/\/       here (was bug - gri 7\/7\/99).\n-      BlockBegin* sux = end->default_sux();\n-      if (sux->number_of_preds() == 1 && !sux->is_entry_block() && !end->is_safepoint()) {\n-        \/\/ merge the two blocks\n+    if (end->as_Goto() == NULL) return false;\n+\n+    assert(end->number_of_sux() == 1, \"end must have exactly one successor\");\n+    \/\/ Note: It would be sufficient to check for the number of successors (= 1)\n+    \/\/       in order to decide if this block can be merged potentially. That\n+    \/\/       would then also include switch statements w\/ only a default case.\n+    \/\/       However, in that case we would need to make sure the switch tag\n+    \/\/       expression is executed if it can produce observable side effects.\n+    \/\/       We should probably have the canonicalizer simplifying such switch\n+    \/\/       statements and then we are sure we don't miss these merge opportunities\n+    \/\/       here (was bug - gri 7\/7\/99).\n+    BlockBegin* sux = end->default_sux();\n+    if (sux->number_of_preds() != 1 || sux->is_entry_block() || end->is_safepoint()) return false;\n+    \/\/ merge the two blocks\n@@ -354,20 +355,20 @@\n-        \/\/ verify that state at the end of block and at the beginning of sux are equal\n-        \/\/ no phi functions must be present at beginning of sux\n-        ValueStack* sux_state = sux->state();\n-        ValueStack* end_state = end->state();\n-\n-        assert(end_state->scope() == sux_state->scope(), \"scopes must match\");\n-        assert(end_state->stack_size() == sux_state->stack_size(), \"stack not equal\");\n-        assert(end_state->locals_size() == sux_state->locals_size(), \"locals not equal\");\n-\n-        int index;\n-        Value sux_value;\n-        for_each_stack_value(sux_state, index, sux_value) {\n-          assert(sux_value == end_state->stack_at(index), \"stack not equal\");\n-        }\n-        for_each_local_value(sux_state, index, sux_value) {\n-          Phi* sux_phi = sux_value->as_Phi();\n-          if (sux_phi != NULL && sux_phi->is_illegal()) continue;\n-          assert(sux_value == end_state->local_at(index), \"locals not equal\");\n-        }\n-        assert(sux_state->caller_state() == end_state->caller_state(), \"caller not equal\");\n+    \/\/ verify that state at the end of block and at the beginning of sux are equal\n+    \/\/ no phi functions must be present at beginning of sux\n+    ValueStack* sux_state = sux->state();\n+    ValueStack* end_state = end->state();\n+\n+    assert(end_state->scope() == sux_state->scope(), \"scopes must match\");\n+    assert(end_state->stack_size() == sux_state->stack_size(), \"stack not equal\");\n+    assert(end_state->locals_size() == sux_state->locals_size(), \"locals not equal\");\n+\n+    int index;\n+    Value sux_value;\n+    for_each_stack_value(sux_state, index, sux_value) {\n+      assert(sux_value == end_state->stack_at(index), \"stack not equal\");\n+    }\n+    for_each_local_value(sux_state, index, sux_value) {\n+      Phi* sux_phi = sux_value->as_Phi();\n+      if (sux_phi != NULL && sux_phi->is_illegal()) continue;\n+      assert(sux_value == end_state->local_at(index), \"locals not equal\");\n+    }\n+    assert(sux_state->caller_state() == end_state->caller_state(), \"caller not equal\");\n@@ -376,20 +377,12 @@\n-        \/\/ find instruction before end & append first instruction of sux block\n-        Instruction* prev = end->prev();\n-        Instruction* next = sux->next();\n-        assert(prev->as_BlockEnd() == NULL, \"must not be a BlockEnd\");\n-        prev->set_next(next);\n-        prev->fixup_block_pointers();\n-        sux->disconnect_from_graph();\n-        block->set_end(sux->end());\n-        \/\/ add exception handlers of deleted block, if any\n-        for (int k = 0; k < sux->number_of_exception_handlers(); k++) {\n-          BlockBegin* xhandler = sux->exception_handler_at(k);\n-          block->add_exception_handler(xhandler);\n-\n-          \/\/ also substitute predecessor of exception handler\n-          assert(xhandler->is_predecessor(sux), \"missing predecessor\");\n-          xhandler->remove_predecessor(sux);\n-          if (!xhandler->is_predecessor(block)) {\n-            xhandler->add_predecessor(block);\n-          }\n-        }\n+    \/\/ find instruction before end & append first instruction of sux block\n+    Instruction* prev = end->prev();\n+    Instruction* next = sux->next();\n+    assert(prev->as_BlockEnd() == NULL, \"must not be a BlockEnd\");\n+    prev->set_next(next);\n+    prev->fixup_block_pointers();\n+    sux->disconnect_from_graph();\n+    block->set_end(sux->end());\n+    \/\/ add exception handlers of deleted block, if any\n+    for (int k = 0; k < sux->number_of_exception_handlers(); k++) {\n+      BlockBegin* xhandler = sux->exception_handler_at(k);\n+      block->add_exception_handler(xhandler);\n@@ -397,6 +390,7 @@\n-        \/\/ debugging output\n-        _merge_count++;\n-        if (PrintBlockElimination) {\n-          tty->print_cr(\"%d. merged B%d & B%d (stack size = %d)\",\n-                        _merge_count, block->block_id(), sux->block_id(), sux->state()->stack_size());\n-        }\n+      \/\/ also substitute predecessor of exception handler\n+      assert(xhandler->is_predecessor(sux), \"missing predecessor\");\n+      xhandler->remove_predecessor(sux);\n+      if (!xhandler->is_predecessor(block)) {\n+        xhandler->add_predecessor(block);\n+      }\n+    }\n@@ -404,11 +398,30 @@\n-        _hir->verify();\n-\n-        If* if_ = block->end()->as_If();\n-        if (if_) {\n-          IfOp* ifop    = if_->x()->as_IfOp();\n-          Constant* con = if_->y()->as_Constant();\n-          bool swapped = false;\n-          if (!con || !ifop) {\n-            ifop = if_->y()->as_IfOp();\n-            con  = if_->x()->as_Constant();\n-            swapped = true;\n+    \/\/ debugging output\n+    _merge_count++;\n+    if (PrintBlockElimination) {\n+      tty->print_cr(\"%d. merged B%d & B%d (stack size = %d)\",\n+                    _merge_count, block->block_id(), sux->block_id(), sux->state()->stack_size());\n+    }\n+\n+    _hir->verify();\n+\n+    If* if_ = block->end()->as_If();\n+    if (if_) {\n+      IfOp* ifop    = if_->x()->as_IfOp();\n+      Constant* con = if_->y()->as_Constant();\n+      bool swapped = false;\n+      if (!con || !ifop) {\n+        ifop = if_->y()->as_IfOp();\n+        con  = if_->x()->as_Constant();\n+        swapped = true;\n+      }\n+      if (con && ifop) {\n+        Constant* tval = ifop->tval()->as_Constant();\n+        Constant* fval = ifop->fval()->as_Constant();\n+        if (tval && fval) {\n+          \/\/ Find the instruction before if_, starting with ifop.\n+          \/\/ When if_ and ifop are not in the same block, prev\n+          \/\/ becomes NULL In such (rare) cases it is not\n+          \/\/ profitable to perform the optimization.\n+          Value prev = ifop;\n+          while (prev != NULL && prev->next() != if_) {\n+            prev = prev->next();\n@@ -416,12 +429,0 @@\n-          if (con && ifop) {\n-            Constant* tval = ifop->tval()->as_Constant();\n-            Constant* fval = ifop->fval()->as_Constant();\n-            if (tval && fval) {\n-              \/\/ Find the instruction before if_, starting with ifop.\n-              \/\/ When if_ and ifop are not in the same block, prev\n-              \/\/ becomes NULL In such (rare) cases it is not\n-              \/\/ profitable to perform the optimization.\n-              Value prev = ifop;\n-              while (prev != NULL && prev->next() != if_) {\n-                prev = prev->next();\n-              }\n@@ -429,27 +430,23 @@\n-              if (prev != NULL) {\n-                Instruction::Condition cond = if_->cond();\n-                BlockBegin* tsux = if_->tsux();\n-                BlockBegin* fsux = if_->fsux();\n-                if (swapped) {\n-                  cond = Instruction::mirror(cond);\n-                }\n-\n-                BlockBegin* tblock = tval->compare(cond, con, tsux, fsux);\n-                BlockBegin* fblock = fval->compare(cond, con, tsux, fsux);\n-                if (tblock != fblock && !if_->is_safepoint()) {\n-                  If* newif = new If(ifop->x(), ifop->cond(), false, ifop->y(),\n-                                     tblock, fblock, if_->state_before(), if_->is_safepoint());\n-                  newif->set_state(if_->state()->copy());\n-\n-                  assert(prev->next() == if_, \"must be guaranteed by above search\");\n-                  NOT_PRODUCT(newif->set_printable_bci(if_->printable_bci()));\n-                  prev->set_next(newif);\n-                  block->set_end(newif);\n-\n-                  _merge_count++;\n-                  if (PrintBlockElimination) {\n-                    tty->print_cr(\"%d. replaced If and IfOp at end of B%d with single If\", _merge_count, block->block_id());\n-                  }\n-\n-                  _hir->verify();\n-                }\n+          if (prev != NULL) {\n+            Instruction::Condition cond = if_->cond();\n+            BlockBegin* tsux = if_->tsux();\n+            BlockBegin* fsux = if_->fsux();\n+            if (swapped) {\n+              cond = Instruction::mirror(cond);\n+            }\n+\n+            BlockBegin* tblock = tval->compare(cond, con, tsux, fsux);\n+            BlockBegin* fblock = fval->compare(cond, con, tsux, fsux);\n+            if (tblock != fblock && !if_->is_safepoint()) {\n+              If* newif = new If(ifop->x(), ifop->cond(), false, ifop->y(),\n+                                 tblock, fblock, if_->state_before(), if_->is_safepoint());\n+              newif->set_state(if_->state()->copy());\n+\n+              assert(prev->next() == if_, \"must be guaranteed by above search\");\n+              NOT_PRODUCT(newif->set_printable_bci(if_->printable_bci()));\n+              prev->set_next(newif);\n+              block->set_end(newif);\n+\n+              _merge_count++;\n+              if (PrintBlockElimination) {\n+                tty->print_cr(\"%d. replaced If and IfOp at end of B%d with single If\", _merge_count, block->block_id());\n@@ -457,0 +454,2 @@\n+\n+              _hir->verify();\n@@ -460,2 +459,0 @@\n-\n-        return true;\n@@ -464,1 +461,2 @@\n-    return false;\n+\n+    return true;\n@@ -468,1 +466,0 @@\n-    _hir->verify();\n@@ -470,3 +467,1 @@\n-    while (try_merge(block)) {\n-      _hir->verify();\n-    }\n+    while (try_merge(block)) ;\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":111,"deletions":116,"binary":false,"changes":227,"status":"modified"}]}