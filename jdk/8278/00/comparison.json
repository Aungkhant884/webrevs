{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.InvocationHandler;\n@@ -412,1 +413,6 @@\n-                        cons = getSerializableConstructor(cl);\n+                        if (isProxy) {\n+                            \/\/ proxies are hidden and cannot use bytecode-generated serial constructors\n+                            cons = proxyConstructor(cl);\n+                        } else {\n+                            cons = getSerializableConstructor(cl);\n+                        }\n@@ -1016,0 +1022,3 @@\n+            Object[] args = isProxy ? new Object[] {(InvocationHandler) (proxy, mth, params) -> {\n+                throw new IllegalStateException(\"Pending proxy read by serialization\");\n+            }} : new Object[0];\n@@ -1018,1 +1027,1 @@\n-                    return cons.newInstance();\n+                    return cons.newInstance(args);\n@@ -1023,1 +1032,1 @@\n-                            return cons.newInstance();\n+                            return cons.newInstance(args);\n@@ -1447,0 +1456,21 @@\n+    \/**\n+     * Returns the single-arg (invocation handler) constructor of a dynamic proxy class.\n+     *\n+     * @param cls the dynamic proxy class\n+     * @return the constructor\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private static Constructor<?> proxyConstructor(Class<?> cls) {\n+        assert Proxy.isProxyClass(cls) : \"Expected proxy, got: \" + cls;\n+        PrivilegedAction<Constructor<?>> pa = () -> {\n+            try {\n+                Constructor<?> constructor = cls.getDeclaredConstructor(InvocationHandler.class);\n+                constructor.setAccessible(true);\n+                return constructor;\n+            } catch (NoSuchMethodException ex) {\n+                return null;\n+            }\n+        };\n+        return AccessController.doPrivileged(pa);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1674,0 +1674,9 @@\n+\n+            @Override\n+            public Lookup injectLookup(Class<?> clazz) {\n+                try {\n+                    return MethodHandles.privateLookupIn(clazz, IMPL_LOOKUP);\n+                } catch (IllegalAccessException ex) {\n+                    throw new InternalError(ex);\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.internal.access.JavaLangInvokeAccess;\n@@ -487,0 +488,1 @@\n+        private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n@@ -498,28 +500,3 @@\n-        private static Class<?> defineProxyClass(Module m, List<Class<?>> interfaces) {\n-            String proxyPkg = null;     \/\/ package to define proxy class in\n-            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n-            boolean nonExported = false;\n-\n-            \/*\n-             * Record the package of a non-public proxy interface so that the\n-             * proxy class will be defined in the same package.  Verify that\n-             * all non-public proxy interfaces are in the same package.\n-             *\/\n-            for (Class<?> intf : interfaces) {\n-                int flags = intf.getModifiers();\n-                if (!Modifier.isPublic(flags)) {\n-                    accessFlags = Modifier.FINAL;  \/\/ non-public, final\n-                    String pkg = intf.getPackageName();\n-                    if (proxyPkg == null) {\n-                        proxyPkg = pkg;\n-                    } else if (!pkg.equals(proxyPkg)) {\n-                        throw new IllegalArgumentException(\n-                                \"non-public interfaces from different packages\");\n-                    }\n-                } else {\n-                    if (!intf.getModule().isExported(intf.getPackageName())) {\n-                        \/\/ module-private types\n-                        nonExported = true;\n-                    }\n-                }\n-            }\n+        private static Class<?> defineProxyClass(ProxyContext context, List<Class<?>> interfaces) {\n+            String proxyPkg = context.pkg;\n+            Module m = context.module;\n@@ -527,1 +504,1 @@\n-            if (proxyPkg == null) {\n+            if (!context.packagePrivate) {\n@@ -531,2 +508,0 @@\n-                proxyPkg = nonExported ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n-                                       : m.getName();\n@@ -558,1 +533,2 @@\n-            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, accessFlags);\n+            int accessFlags = (context.packagePrivate ? 0 : Modifier.PUBLIC) | Modifier.FINAL;\n+            var proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, accessFlags);\n@@ -560,2 +536,3 @@\n-                Class<?> pc = JLA.defineClass(loader, proxyName, proxyClassFile,\n-                                              null, \"__dynamic_proxy__\");\n+                Class<?> pc = context.lookup.defineHiddenClassWithClassData(proxyClassFile.bytecode(),\n+                        proxyClassFile.classData(), true,\n+                        MethodHandles.Lookup.ClassOption.STRONG).lookupClass();\n@@ -573,0 +550,2 @@\n+            } catch (IllegalAccessException e) {\n+                throw new InternalError(e); \/\/ The lookup should be powerful enough\n@@ -578,1 +557,1 @@\n-         * {@link #defineProxyClass(Module, List)}\n+         * {@link #defineProxyClass(ProxyContext, List)}\n@@ -634,1 +613,4 @@\n-        private final Module module;\n+        private final ProxyContext context;\n+\n+        private record ProxyContext(Module module, String pkg, boolean packagePrivate, MethodHandles.Lookup lookup) {}\n+\n@@ -651,2 +633,2 @@\n-            this.module = mapToModule(loader, interfaces, refTypes);\n-            assert getLoader(module) == loader;\n+            this.context = determineContext(loader, interfaces, refTypes);\n+            assert getLoader(context.module()) == loader;\n@@ -670,1 +652,2 @@\n-            Class<?> proxyClass = defineProxyClass(module, interfaces);\n+            Class<?> proxyClass = defineProxyClass(context, interfaces);\n+            Module module = context.module;\n@@ -788,3 +771,3 @@\n-        private static Module mapToModule(ClassLoader loader,\n-                                          List<Class<?>> interfaces,\n-                                          Set<Class<?>> refTypes) {\n+        private static ProxyContext determineContext(ClassLoader loader,\n+                                                     List<Class<?>> interfaces,\n+                                                     Set<Class<?>> refTypes) {\n@@ -792,0 +775,1 @@\n+            boolean nonExported = false;\n@@ -796,0 +780,5 @@\n+                } else {\n+                    if (!m.isExported(intf.getPackageName())) {\n+                        \/\/ module-private types\n+                        nonExported = true;\n+                    }\n@@ -807,0 +796,1 @@\n+                Class<?> injectionClass = null;\n@@ -823,1 +813,2 @@\n-                    targetPackageName = e.getKey().getPackageName();\n+                    injectionClass = e.getKey();\n+                    targetPackageName = injectionClass.getPackageName();\n@@ -826,0 +817,2 @@\n+                assert (targetModule != null) && (injectionClass != null) & (targetPackageName != null);\n+\n@@ -841,1 +834,1 @@\n-                return targetModule;\n+                return new ProxyContext(targetModule, targetPackageName, true, JLIA.injectLookup(injectionClass));\n@@ -846,1 +839,2 @@\n-            Module targetModule = getDynamicModule(loader);\n+            ProxyContext context = setupDynamicModule(loader, nonExported);\n+            Module targetModule = context.module;\n@@ -855,1 +849,1 @@\n-            return targetModule;\n+            return context;\n@@ -896,1 +890,6 @@\n-        private static final ClassLoaderValue<Module> dynProxyModules =\n+        private record DynamicModuleInfo(Module module,\n+                                         String exportedPackage,\n+                                         String nonExportedPackage,\n+                                         MethodHandles.Lookup exportedAnchor,\n+                                         MethodHandles.Lookup nonExportedAnchor) {}\n+        private static final ClassLoaderValue<DynamicModuleInfo> dynProxyModules =\n@@ -907,2 +906,2 @@\n-        private static Module getDynamicModule(ClassLoader loader) {\n-            return dynProxyModules.computeIfAbsent(loader, (ld, clv) -> {\n+        private static ProxyContext setupDynamicModule(ClassLoader loader, boolean nonExported) {\n+            var info = dynProxyModules.computeIfAbsent(loader, (ld, clv) -> {\n@@ -923,1 +922,12 @@\n-                return m;\n+\n+                String mAnchorName = mn + \".\" + proxyClassNamePrefix + \"Anchor\";\n+                String pAnchorName = pn + \".\" + proxyClassNamePrefix + \"Anchor\";\n+                var exportedAnchor = JLA.defineClass(loader, mAnchorName,\n+                        ProxyGenerator.generateAnchorClass(mAnchorName), null,\n+                        \"__dynamic_proxy_anchor__\");\n+                var nonExportedAnchor = JLA.defineClass(loader, pAnchorName,\n+                        ProxyGenerator.generateAnchorClass(pAnchorName), null,\n+                        \"__dynamic_proxy_anchor__\");\n+\n+                return new DynamicModuleInfo(m, mn, pn, JLIA.injectLookup(exportedAnchor),\n+                        JLIA.injectLookup(nonExportedAnchor));\n@@ -925,0 +935,6 @@\n+\n+            return nonExported\n+                    ? new ProxyContext(info.module, info.nonExportedPackage,\n+                                       false, info.nonExportedAnchor)\n+                    : new ProxyContext(info.module, info.exportedPackage,\n+                                       false, info.exportedAnchor);\n@@ -1180,1 +1196,0 @@\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n@@ -1184,1 +1199,1 @@\n-                dmh = proxyClassLookup(lookup, proxyClass)\n+                dmh = ProxyBuilder.JLIA.injectLookup(proxyClass)\n@@ -1295,22 +1310,0 @@\n-    \/**\n-     * This method invokes the proxy's proxyClassLookup method to get a\n-     * Lookup on the proxy class.\n-     *\n-     * @return a lookup for proxy class of this proxy instance\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static MethodHandles.Lookup proxyClassLookup(MethodHandles.Lookup caller, Class<?> proxyClass) {\n-        return AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public MethodHandles.Lookup run() {\n-                try {\n-                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", MethodHandles.Lookup.class);\n-                    m.setAccessible(true);\n-                    return (MethodHandles.Lookup) m.invoke(null, caller);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new InternalError(e);\n-                }\n-            }\n-        });\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":67,"deletions":74,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.Handle;\n@@ -33,1 +35,0 @@\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -37,0 +38,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -62,6 +64,0 @@\n-    private static final String JL_CLASS_NOT_FOUND_EX = \"java\/lang\/ClassNotFoundException\";\n-    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n-\n-    private static final String JL_NO_CLASS_DEF_FOUND_ERROR = \"java\/lang\/NoClassDefFoundError\";\n-    private static final String JL_NO_SUCH_METHOD_EX = \"java\/lang\/NoSuchMethodException\";\n-    private static final String JL_NO_SUCH_METHOD_ERROR = \"java\/lang\/NoSuchMethodError\";\n@@ -82,2 +78,3 @@\n-    private static final String NAME_CLINIT = \"<clinit>\";\n-    private static final String NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\";\n+\n+    private static final Handle BSM_CLASS_DATA_AT = new Handle(H_INVOKESTATIC, JLI_METHODHANDLES, \"classDataAt\",\n+            \"(L\" + JLI_LOOKUP + \";Ljava\/lang\/String;\" + LJL_CLASS + \"I)L\" + JL_OBJECT + \";\", false);\n@@ -108,3 +105,3 @@\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), \"m0\");\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), \"m1\");\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), \"m2\");\n+            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"));\n+            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class));\n+            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"));\n@@ -143,6 +140,0 @@\n-    \/**\n-     * Ordinal of next ProxyMethod object added to proxyMethods.\n-     * Indexes are reserved for hashcode(0), equals(1), toString(2).\n-     *\/\n-    private int proxyMethodCount = 3;\n-\n@@ -165,0 +156,19 @@\n+    \/**\n+     * Generates a minimal anchor class for obtaining lookup in a spinned package.\n+     *\n+     * @param name the name of the anchor class\n+     * @return the bytecode of the anchor class\n+     *\/\n+    static byte[] generateAnchorClass(String name) {\n+        ClassWriter cw = new ClassWriter(0); \/\/ No methods, don't need computation\n+        cw.visit(CLASSFILE_VERSION, ACC_SUPER | ACC_FINAL, dotToSlash(name),\n+                null, JL_OBJECT, null);\n+        cw.visitEnd();\n+        return cw.toByteArray();\n+    }\n+\n+    \/**\n+     * The class bytecode and class data for hidden class definition.\n+     *\/\n+    record ClassWithData(byte[] bytecode, Object classData) {}\n+\n@@ -173,4 +183,4 @@\n-    static byte[] generateProxyClass(ClassLoader loader,\n-                                     final String name,\n-                                     List<Class<?>> interfaces,\n-                                     int accessFlags) {\n+    static ClassWithData generateProxyClass(ClassLoader loader,\n+                                            final String name,\n+                                            List<Class<?>> interfaces,\n+                                            int accessFlags) {\n@@ -178,1 +188,2 @@\n-        final byte[] classFile = gen.generateClassFile();\n+        final ClassWithData classDefinition = gen.generateClassFile();\n+        final byte[] classFile = classDefinition.bytecode;\n@@ -204,1 +215,1 @@\n-        return classFile;\n+        return classDefinition;\n@@ -457,1 +468,1 @@\n-    private byte[] generateClassFile() {\n+    private ClassWithData generateClassFile() {\n@@ -461,0 +472,2 @@\n+        visitSource(\"__dynamic_proxy__\", null);\n+\n@@ -468,3 +481,3 @@\n-        addProxyMethod(hashCodeMethod);\n-        addProxyMethod(equalsMethod);\n-        addProxyMethod(toStringMethod);\n+        addObjectProxyMethod(hashCodeMethod);\n+        addObjectProxyMethod(equalsMethod);\n+        addObjectProxyMethod(toStringMethod);\n@@ -478,1 +491,1 @@\n-                    addProxyMethod(m, intf);\n+                    addProxyMethod(m);\n@@ -487,0 +500,1 @@\n+        int methodListSize = 0;\n@@ -488,0 +502,1 @@\n+            methodListSize += sigmethods.size();\n@@ -493,0 +508,2 @@\n+        int index = 0;\n+        Method[] methods = new Method[methodListSize];\n@@ -495,3 +512,5 @@\n-                \/\/ add static field for the Method object\n-                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n-                        LJLR_METHOD, null, null);\n+                \/\/ Make condy for the method and add it to the list\n+                ConstantDynamic condy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME,\n+                        LJLR_METHOD, BSM_CLASS_DATA_AT, index);\n+                methods[index] = pm.method;\n+                index++;\n@@ -500,1 +519,1 @@\n-                pm.generateMethod(this, className);\n+                pm.generateMethod(this, condy);\n@@ -504,3 +523,1 @@\n-        generateStaticInitializer();\n-        generateLookupAccessor();\n-        return toByteArray();\n+        return new ClassWithData(toByteArray(), List.of(methods));\n@@ -522,1 +539,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass) {\n+    private void addProxyMethod(Method m) {\n@@ -547,2 +564,1 @@\n-                exceptionTypes, fromClass,\n-                \"m\" + proxyMethodCount++));\n+                exceptionTypes));\n@@ -556,1 +572,1 @@\n-    private void addProxyMethod(ProxyMethod pm) {\n+    private void addObjectProxyMethod(ProxyMethod pm) {\n@@ -582,95 +598,0 @@\n-    \/**\n-     * Generate the static initializer method for the proxy class.\n-     *\/\n-    private void generateStaticInitializer() {\n-\n-        MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,\n-                \"()V\", null, null);\n-        mv.visitCode();\n-        Label L_startBlock = new Label();\n-        Label L_endBlock = new Label();\n-        Label L_NoMethodHandler = new Label();\n-        Label L_NoClassHandler = new Label();\n-\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,\n-                JL_NO_SUCH_METHOD_EX);\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,\n-                JL_CLASS_NOT_FOUND_EX);\n-\n-        mv.visitLabel(L_startBlock);\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                pm.codeFieldInitialization(mv, className);\n-            }\n-        }\n-        mv.visitInsn(RETURN);\n-        mv.visitLabel(L_endBlock);\n-        \/\/ Generate exception handler\n-\n-        mv.visitLabel(L_NoMethodHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        mv.visitLabel(L_NoClassHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n-    }\n-\n-    \/**\n-     * Generate the static lookup accessor method that returns the Lookup\n-     * on this proxy class if the caller's lookup class is java.lang.reflect.Proxy;\n-     * otherwise, IllegalAccessException is thrown\n-     *\/\n-    private void generateLookupAccessor() {\n-        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n-                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n-                new String[] { JL_ILLEGAL_ACCESS_EX });\n-        mv.visitCode();\n-        Label L_illegalAccess = new Label();\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n-                \"()Ljava\/lang\/Class;\", false);\n-        mv.visitLdcInsn(Type.getType(Proxy.class));\n-        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n-                \"()Z\", false);\n-        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n-        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n-                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n-        mv.visitInsn(ARETURN);\n-\n-        mv.visitLabel(L_illegalAccess);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n-                \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n-    }\n-\n@@ -686,1 +607,0 @@\n-        private final Class<?> fromClass;\n@@ -689,1 +609,0 @@\n-        private final String methodFieldName;\n@@ -693,2 +612,1 @@\n-                            Class<?> returnType, Class<?>[] exceptionTypes,\n-                            Class<?> fromClass, String methodFieldName) {\n+                            Class<?> returnType, Class<?>[] exceptionTypes) {\n@@ -700,2 +618,0 @@\n-            this.fromClass = fromClass;\n-            this.methodFieldName = methodFieldName;\n@@ -708,1 +624,0 @@\n-         * @param methodFieldName the fieldName to generate\n@@ -710,1 +625,1 @@\n-        private ProxyMethod(Method method, String methodFieldName) {\n+        private ProxyMethod(Method method) {\n@@ -713,1 +628,1 @@\n-                    method.getExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                    method.getExceptionTypes());\n@@ -719,1 +634,1 @@\n-        private void generateMethod(ClassWriter cw, String className) {\n+        private void generateMethod(ClassWriter cw, ConstantDynamic methodCondy) {\n@@ -758,2 +673,1 @@\n-            mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,\n-                    LJLR_METHOD);\n+            mv.visitLdcInsn(methodCondy);\n@@ -873,40 +787,0 @@\n-        \/**\n-         * Generate code for initializing the static field that stores\n-         * the Method object for this proxy method.\n-         *\/\n-        private void codeFieldInitialization(MethodVisitor mv, String className) {\n-            codeClassForName(mv, fromClass);\n-\n-            mv.visitLdcInsn(method.getName());\n-\n-            emitIconstInsn(mv, parameterTypes.length);\n-\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);\n-\n-            \/\/ Construct an array with the parameter types mapping primitives to Wrapper types\n-            for (int i = 0; i < parameterTypes.length; i++) {\n-                mv.visitInsn(DUP);\n-                emitIconstInsn(mv, i);\n-\n-                if (parameterTypes[i].isPrimitive()) {\n-                    PrimitiveTypeInfo prim =\n-                            PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    mv.visitFieldInsn(GETSTATIC,\n-                            prim.wrapperClassName, \"TYPE\", LJL_CLASS);\n-                } else {\n-                    codeClassForName(mv, parameterTypes[i]);\n-                }\n-                mv.visitInsn(Opcodes.AASTORE);\n-            }\n-            \/\/ lookup the method\n-            mv.visitMethodInsn(INVOKEVIRTUAL,\n-                    JL_CLASS,\n-                    \"getMethod\",\n-                    \"(Ljava\/lang\/String;[Ljava\/lang\/Class;)Ljava\/lang\/reflect\/Method;\",\n-                    false);\n-\n-            mv.visitFieldInsn(PUTSTATIC,\n-                    dotToSlash(className),\n-                    methodFieldName, LJLR_METHOD);\n-        }\n-\n@@ -917,13 +791,0 @@\n-        \/**\n-         * Generate code to invoke the Class.forName with the name of the given\n-         * class to get its Class object at runtime.  The code is written to\n-         * the supplied stream.  Note that the code generated by this method\n-         * may cause the checked ClassNotFoundException to be thrown.\n-         *\/\n-        private void codeClassForName(MethodVisitor mv, Class<?> cl) {\n-            mv.visitLdcInsn(cl.getName());\n-            mv.visitMethodInsn(INVOKESTATIC,\n-                    JL_CLASS,\n-                    \"forName\", \"(Ljava\/lang\/String;)Ljava\/lang\/Class;\", false);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":61,"deletions":200,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -191,0 +191,8 @@\n+\n+    \/**\n+     * Return a full-privileged lookup for a given class.\n+     *\n+     * @param clazz the class\n+     * @return the lookup\n+     *\/\n+    Lookup injectLookup(Class<?> clazz);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -230,1 +230,0 @@\n-                        new StackTraceElement(\"jdk.proxy1.$Proxy0\", \"hashCode\", null, -1),\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}