{"files":[{"patch":"@@ -267,6 +267,0 @@\n- * <li>The starting physical address of a {@code long[]} array will be 8-byte aligned (e.g. 1000), so that successive long elements\n- * occur at 8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) A heap segment backed by a {@code long[]} array\n- * can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint. In addition, the segment can be\n- * accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target addresses\n- * (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets 0, 2, 4, 6, etc under a\n- * 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n@@ -281,0 +275,12 @@\n+ * <li>The starting physical address of a {@code long[]} array will be 8-byte aligned (e.g. 1000) on 64-bit platforms,\n+ * so that successive long elements occur at 8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) On 64-bit platforms,\n+ * a heap segment backed by a {@code long[]} array can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment\n+ * constraint. In addition, the segment can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ * because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets\n+ * 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n+ * <li>The starting physical address of a {@code long[]} array will be 4-byte aligned (e.g. 1000) on 32-bit platforms,\n+ * so that successive long elements occur at 4-byte aligned addresses (e.g., 1004, 1008, 1012, 1016, etc.) On 32-bit\n+ * platforms, a heap segment backed by a {@code long[]} array can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte\n+ * alignment constraint, because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment\n+ * can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses\n+ * (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n@@ -283,2 +289,2 @@\n- * In other words, heap segments feature a <em>maximum<\/em> alignment which is derived from the size of the elements of\n- * the Java array backing the segment, as shown in the following table:\n+ * In other words, heap segments feature a (platform-dependent) <em>maximum<\/em> alignment which is derived from the\n+ * size of the elements of the Java array backing the segment, as shown in the following table:\n@@ -296,1 +302,1 @@\n- *     <td style=\"text-align:center;\">{@code 1}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_BOOLEAN.byteAlignment()}<\/td><\/tr>\n@@ -298,1 +304,1 @@\n- *     <td style=\"text-align:center;\">{@code 1}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_BYTE.byteAlignment()}<\/td><\/tr>\n@@ -300,1 +306,1 @@\n- *     <td style=\"text-align:center;\">{@code 2}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_CHAR.byteAlignment()}<\/td><\/tr>\n@@ -302,1 +308,1 @@\n- *     <td style=\"text-align:center;\">{@code 2}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_SHORT.byteAlignment()}<\/td><\/tr>\n@@ -304,1 +310,1 @@\n- *     <td style=\"text-align:center;\">{@code 4}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_INT.byteAlignment()}<\/td><\/tr>\n@@ -306,1 +312,1 @@\n- *     <td style=\"text-align:center;\">{@code 4}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_FLOAT.byteAlignment()}<\/td><\/tr>\n@@ -308,1 +314,1 @@\n- *     <td style=\"text-align:center;\">{@code 8}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_LONG.byteAlignment()}<\/td><\/tr>\n@@ -310,1 +316,1 @@\n- *     <td style=\"text-align:center;\">{@code 8}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_DOUBLE.byteAlignment()}<\/td><\/tr>\n@@ -321,1 +327,1 @@\n- * byteSegment.get(ValueLayout.JAVA_INT, 0); \/\/ fails: layout alignment is 4, segment max alignment is 1\n+ * byteSegment.get(ValueLayout.JAVA_INT, 0); \/\/ fails: ValueLayout.JAVA_INT.byteAlignment() > ValueLayout.JAVA_BYTE.byteAlignment()\n@@ -325,1 +331,4 @@\n- * type (e.g. {@code long[]}), capable of supporting greater maximum alignment:\n+ * type (e.g. {@code long[]}), capable of supporting greater maximum alignment. More specifically, the maximum alignment\n+ * associated with {@code long[]} is set to {@code ValueLayout.JAVA_LONG.byteAlignment()} which is a platform-dependent\n+ * value (set to {@code ValueLayout.ADDRESS.byteSize()}). That is, {@code long[]}) is guaranteed to provide at least\n+ * 8-byte alignment in 64-bit platforms, but only 4-byte alignment in 32-bit platforms:\n@@ -329,1 +338,1 @@\n- * longSegment.get(ValueLayout.JAVA_INT, 0); \/\/ ok: layout alignment is 4, segment max alignment is 8\n+ * longSegment.get(ValueLayout.JAVA_INT, 0); \/\/ ok: ValueLayout.JAVA_INT.byteAlignment() <= ValueLayout.JAVA_LONG.byteAlignment()\n@@ -336,1 +345,1 @@\n- * byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n+ * byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, 0); \/\/ ok: ValueLayout.JAVA_INT_UNALIGNED.byteAlignment() == ValueLayout.JAVA_BYTE.byteAlignment()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -488,1 +488,2 @@\n-     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * (platform-dependent) bit alignment set to {@code ADDRESS.bitSize()},\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -500,1 +501,2 @@\n-     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * (platform-dependent) bit alignment set to {@code ADDRESS.bitSize()},\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -55,4 +56,4 @@\n-    private static final long MAX_ALIGN_1 = 1;\n-    private static final long MAX_ALIGN_2 = 2;\n-    private static final long MAX_ALIGN_4 = 4;\n-    private static final long MAX_ALIGN_8 = 8;\n+    private static final long MAX_ALIGN_1 = ValueLayout.JAVA_BYTE.byteAlignment();\n+    private static final long MAX_ALIGN_2 = ValueLayout.JAVA_SHORT.byteAlignment();\n+    private static final long MAX_ALIGN_4 = ValueLayout.JAVA_INT.byteAlignment();\n+    private static final long MAX_ALIGN_8 = ValueLayout.JAVA_LONG.byteAlignment();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-            return new OfLongImpl(order, Long.SIZE, Optional.empty());\n+            return new OfLongImpl(order, ADDRESS_SIZE_BITS, Optional.empty());\n@@ -314,1 +314,1 @@\n-            return new OfDoubleImpl(order, Double.SIZE, Optional.empty());\n+            return new OfDoubleImpl(order, ADDRESS_SIZE_BITS, Optional.empty());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}