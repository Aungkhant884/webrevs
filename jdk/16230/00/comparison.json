{"files":[{"patch":"@@ -5370,2 +5370,0 @@\n-  const char *stubName = \"array_partition_stub\";\n-\n@@ -5380,15 +5378,6 @@\n-  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType bt = elem_type->basic_type();\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_array_partition_function();\n-  \/\/ stub not loaded\n-  if (stubAddr == nullptr) {\n-    return false;\n-  }\n-  \/\/ get the address of the array\n-  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n-  }\n-  Node* obj_adr = make_unsafe_address(obj, offset);\n+  Node* pivotIndices = nullptr;\n+\n+  \/\/ Set the original stack and the reexecute bit for the interpreter to reexecute\n+  \/\/ the bytecode that invokes DualPivotQuicksort.partition() if deoptimization happens.\n+  { PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n@@ -5396,7 +5385,15 @@\n-  \/\/ create the pivotIndices array of type int and size = 2\n-  Node* size = intcon(2);\n-  Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n-  Node* pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n-  guarantee(alloc != nullptr, \"created above\");\n-  Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+    const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+    BasicType bt = elem_type->basic_type();\n+    address stubAddr = nullptr;\n+    stubAddr = StubRoutines::select_array_partition_function();\n+    \/\/ stub not loaded\n+    if (stubAddr == nullptr) {\n+      return false;\n+    }\n+    \/\/ get the address of the array\n+    const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+    if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+      return false; \/\/ failed input validation\n+    }\n+    Node* obj_adr = make_unsafe_address(obj, offset);\n@@ -5404,2 +5401,7 @@\n-  \/\/ pass the basic type enum to the stub\n-  Node* elemType = intcon(bt);\n+    \/\/ create the pivotIndices array of type int and size = 2\n+    Node* size = intcon(2);\n+    Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+    pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+    AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+    guarantee(alloc != nullptr, \"created above\");\n+    Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n@@ -5407,5 +5409,11 @@\n-  \/\/ Call the stub\n-  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n-                    stubAddr, stubName, TypePtr::BOTTOM,\n-                    obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n-                    indexPivot1, indexPivot2);\n+    \/\/ pass the basic type enum to the stub\n+    Node* elemType = intcon(bt);\n+\n+    \/\/ Call the stub\n+    const char *stubName = \"array_partition_stub\";\n+    make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+                      stubAddr, stubName, TypePtr::BOTTOM,\n+                      obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n+                      indexPivot1, indexPivot2);\n+\n+  } \/\/ original reexecute is set back here\n@@ -5424,3 +5432,0 @@\n-  const char *stubName;\n-  stubName = \"arraysort_stub\";\n-\n@@ -5454,0 +5459,1 @@\n+  const char *stubName = \"arraysort_stub\";\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":40,"deletions":34,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build SortingDeoptimizationTest\n+ * @run main\/othervm -Xcomp -ea -esa -XX:CompileThreshold=25 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+DeoptimizeALot SortingDeoptimizationTest 1e-2 100 50\n+ * @summary Exercise Arrays.parallelSort\n+ *\n+ *\/\n+\n+import java.io.PrintStream;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+public class SortingDeoptimizationTest {\n+\n+    private static final PrintStream err = System.err;\n+    private static final PrintStream out = System.out;\n+\n+    public static void main(String[] args) {\n+        int MAX = 2147483647; \/\/ 2^32 - 1\n+        float fraction = Float.parseFloat(args[0]);\n+        int size = (int) (fraction * MAX); \/\/ size is a fraction of the MAX size\n+        int iters = Integer.parseInt(args[1]); \/\/ number of iterations\n+        int max = args.length > 2 ? Integer.parseInt(args[2]) : -1 ; \/\/ max value for the array elements\n+        long seed = 0xC0FFEE;\n+        Random rand = new Random(seed);\n+\n+        for (int i = 0; i < iters; i++) {\n+            boolean isSorted = runSort(size, max, rand);\n+            out.println(\"Iteration \" + i + \": is sorted? -> \"+ isSorted);\n+            if (!isSorted) fail(\"Array is not correctly sorted.\");\n+        }\n+    }\n+\n+    private static void fail(String message) {\n+        err.format(\"\\n*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n+        throw new RuntimeException(\"Test failed\");\n+    }\n+\n+    private static boolean runSort(int size, int max, Random rand) {\n+        int[] a = new int[size];\n+        for (int i = 0; i < a.length; i++) a[i] =  max > 0 ? rand.nextInt(max) : rand.nextInt();\n+        \/\/ call parallel sort\n+        Arrays.parallelSort(a);\n+        \/\/ check if sorted\n+        boolean isSorted = true;\n+        for (int i = 0; i < (a.length -1); i++) isSorted = isSorted && (a[i] <= a[i+1]);\n+        return isSorted;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Arrays\/SortingDeoptimizationTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}