{"files":[{"patch":"@@ -69,0 +69,1 @@\n+NOT_PRODUCT(cflags(TraceEscapeAnalysis, bool, false, TraceEscapeAnalysis)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+NOT_PRODUCT(option(TraceEscapeAnalysis, \"TraceEscapeAnalysis\", Bool)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -666,0 +666,3 @@\n+#ifndef PRODUCT\n+  set_trace_escape_analysis(directive->TraceEscapeAnalysisOption);\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -327,0 +327,1 @@\n+  bool                  _trace_escape_analysis; \/\/ True if we should print escape analysis for this compilation\n@@ -621,0 +622,2 @@\n+  bool              trace_escape_analysis() const{ return _trace_escape_analysis; }\n+  void          set_trace_escape_analysis(bool z){ _trace_escape_analysis = z; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -220,0 +220,14 @@\n+\n+#ifndef PRODUCT\n+  if (_compile->trace_escape_analysis()) {\n+    tty->print(\"+++++ Initial worklist for \");\n+    _compile->method()->print_name();\n+    tty->print_cr(\" (ea_inv=%d)\", _invocation);\n+    for (int i = 0; i < ptnodes_worklist.length(); i++) {\n+      PointsToNode* ptn = ptnodes_worklist.at(i);\n+      ptn->dump();\n+    }\n+    tty->print_cr(\"+++++ Calculating escape states and scalar replaceability\");\n+  }\n+#endif\n+\n@@ -868,1 +882,1 @@\n-    set_escape_state(ptn, PointsToNode::GlobalEscape);\n+    set_escape_state(ptn, PointsToNode::GlobalEscape DEBUG_ONLY(COMMA \"stored at raw address\"));\n@@ -895,0 +909,1 @@\n+    DEBUG_ONLY(const char* nsr_reason = \"\");\n@@ -903,0 +918,1 @@\n+          DEBUG_ONLY(nsr_reason = \"has a non-constant or too big length\");\n@@ -917,0 +933,1 @@\n+          DEBUG_ONLY(nsr_reason = \"has too many fields\");\n@@ -923,1 +940,1 @@\n-      ptn->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(ptn DEBUG_ONLY(COMMA nsr_reason));\n@@ -954,1 +971,1 @@\n-      ptnode_adr(call_idx)->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(ptnode_adr(call_idx) DEBUG_ONLY(COMMA \"is result of multinewarray\"));\n@@ -976,1 +993,1 @@\n-        ptnode_adr(call_idx)->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(ptnode_adr(call_idx) DEBUG_ONLY(COMMA \"is result of call\"));\n@@ -1131,1 +1148,1 @@\n-          set_escape_state(arg_ptn, es);\n+          set_escape_state(arg_ptn, es DEBUG_ONLY(COMMA \"reason unknown (1)\"));\n@@ -1186,1 +1203,1 @@\n-              set_escape_state(arg_ptn, PointsToNode::GlobalEscape);\n+              set_escape_state(arg_ptn, PointsToNode::GlobalEscape DEBUG_ONLY(COMMA trace_arg_escape_message(call)));\n@@ -1188,1 +1205,1 @@\n-              set_escape_state(arg_ptn, PointsToNode::ArgEscape);\n+              set_escape_state(arg_ptn, PointsToNode::ArgEscape DEBUG_ONLY(COMMA trace_arg_escape_message(call)));\n@@ -1191,1 +1208,1 @@\n-                set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape);\n+                set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape DEBUG_ONLY(COMMA trace_arg_escape_message(call)));\n@@ -1220,1 +1237,1 @@\n-          set_escape_state(ptnode_adr(arg->_idx), PointsToNode::GlobalEscape);\n+          set_escape_state(ptnode_adr(arg->_idx), PointsToNode::GlobalEscape DEBUG_ONLY(COMMA trace_arg_escape_message(call)));\n@@ -1404,1 +1421,1 @@\n-          set_fields_escape_state(e, field_es);\n+          set_fields_escape_state(e, field_es DEBUG_ONLY(COMMA trace_propagate_message(ptn)));\n@@ -1410,1 +1427,1 @@\n-          set_escape_state(e, es);\n+          set_escape_state(e, es DEBUG_ONLY(COMMA trace_propagate_message(ptn)));\n@@ -1417,1 +1434,1 @@\n-          set_fields_escape_state(e, field_es);\n+          set_fields_escape_state(e, field_es DEBUG_ONLY(COMMA trace_propagate_message(ptn)));\n@@ -1424,1 +1441,1 @@\n-          set_escape_state(e, field_es);\n+          set_escape_state(e, field_es DEBUG_ONLY(COMMA trace_propagate_message(ptn)));\n@@ -1427,1 +1444,1 @@\n-          set_escape_state(e, es);\n+          set_escape_state(e, es DEBUG_ONLY(COMMA trace_propagate_message(ptn)));\n@@ -1793,1 +1810,1 @@\n-        jobj->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj DEBUG_ONLY(COMMA \"is stored at unknown offset\"));\n@@ -1802,1 +1819,1 @@\n-            jobj->set_scalar_replaceable(false);\n+            set_not_scalar_replaceable(jobj DEBUG_ONLY(COMMA \"is stored into field with potentially null base\"));\n@@ -1814,2 +1831,2 @@\n-        jobj->set_scalar_replaceable(false);\n-         ptn->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj DEBUG_ONLY(COMMA \"is merged with other object\"));\n+        set_not_scalar_replaceable(ptn DEBUG_ONLY(COMMA \"is merged with other object\"));\n@@ -1835,1 +1852,1 @@\n-      jobj->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(jobj DEBUG_ONLY(COMMA \"has field with unknown offset\"));\n@@ -1850,1 +1867,1 @@\n-      jobj->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(jobj DEBUG_ONLY(COMMA \"is used as base of mixed unsafe access\"));\n@@ -1857,1 +1874,1 @@\n-        jobj->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj DEBUG_ONLY(COMMA \"is used in LoadStore or mismatched access\"));\n@@ -1886,2 +1903,2 @@\n-          jobj->set_scalar_replaceable(false);\n-          base->set_scalar_replaceable(false);\n+          set_not_scalar_replaceable(jobj DEBUG_ONLY(COMMA \"may point to more than one object\"));\n+          set_not_scalar_replaceable(base DEBUG_ONLY(COMMA \"may point to more than one object\"));\n@@ -3152,1 +3169,1 @@\n-      set_escape_state(ptnode_adr(n->_idx), es); \/\/ CheckCastPP escape state\n+      set_escape_state(ptnode_adr(n->_idx), es DEBUG_ONLY(COMMA \"reason unknown (2)\")); \/\/ CheckCastPP escape state\n@@ -3627,1 +3644,1 @@\n-void PointsToNode::dump(bool print_state) const {\n+void PointsToNode::dump_header(bool print_state, outputStream* out) const {\n@@ -3629,1 +3646,1 @@\n-  tty->print(\"%s \", node_type_names[(int) nt]);\n+  out->print(\"%s(%d) \", node_type_names[(int) nt], _pidx);\n@@ -3633,1 +3650,1 @@\n-    tty->print(\"%s(%s) \", esc_names[(int)es], esc_names[(int)fields_es]);\n+    out->print(\"%s(%s) \", esc_names[(int)es], esc_names[(int)fields_es]);\n@@ -3635,1 +3652,1 @@\n-      tty->print(\"NSR \");\n+      out->print(\"NSR \");\n@@ -3638,0 +3655,4 @@\n+}\n+\n+void PointsToNode::dump(bool print_state, outputStream* out, bool newline) const {\n+  dump_header(print_state, out);\n@@ -3641,1 +3662,1 @@\n-      tty->print(\"oop \");\n+      out->print(\"oop \");\n@@ -3644,1 +3665,1 @@\n-      tty->print(\"+%d \", f->offset());\n+      out->print(\"+%d \", f->offset());\n@@ -3646,1 +3667,1 @@\n-    tty->print(\"(\");\n+    out->print(\"(\");\n@@ -3649,1 +3670,1 @@\n-      tty->print(\" %d%s\", b->idx(),(b->is_JavaObject() ? \"P\" : \"\"));\n+      out->print(\" %d%s\", b->idx(),(b->is_JavaObject() ? \"P\" : \"\"));\n@@ -3651,1 +3672,1 @@\n-    tty->print(\" )\");\n+    out->print(\" )\");\n@@ -3653,1 +3674,1 @@\n-  tty->print(\"[\");\n+  out->print(\"[\");\n@@ -3656,1 +3677,1 @@\n-    tty->print(\" %d%s%s\", e->idx(),(e->is_JavaObject() ? \"P\" : (e->is_Field() ? \"F\" : \"\")), e->is_Arraycopy() ? \"cp\" : \"\");\n+    out->print(\" %d%s%s\", e->idx(),(e->is_JavaObject() ? \"P\" : (e->is_Field() ? \"F\" : \"\")), e->is_Arraycopy() ? \"cp\" : \"\");\n@@ -3658,1 +3679,1 @@\n-  tty->print(\" [\");\n+  out->print(\" [\");\n@@ -3666,1 +3687,1 @@\n-    tty->print(\" %d%s%s\", u->idx(), is_base ? \"b\" : \"\", u->is_Arraycopy() ? \"cp\" : \"\");\n+    out->print(\" %d%s%s\", u->idx(), is_base ? \"b\" : \"\", u->is_Arraycopy() ? \"cp\" : \"\");\n@@ -3668,1 +3689,1 @@\n-  tty->print(\" ]]  \");\n+  out->print(\" ]]  \");\n@@ -3670,1 +3691,1 @@\n-    tty->print_cr(\"<null>\");\n+    out->print(\"<null>%s\", newline ? \"\\n\" : \"\");\n@@ -3672,1 +3693,1 @@\n-    _node->dump();\n+    _node->dump(newline ? \"\\n\" : \"\", false, out);\n@@ -3715,0 +3736,34 @@\n+\n+void ConnectionGraph::trace_es_update_helper(PointsToNode* ptn, PointsToNode::EscapeState es, bool fields, const char* reason) const {\n+  if (_compile->trace_escape_analysis()) {\n+    assert(ptn != nullptr, \"should not be null\");\n+    assert(reason != nullptr, \"should not be null\");\n+    ptn->dump_header(true);\n+    PointsToNode::EscapeState new_es = fields ? ptn->escape_state() : es;\n+    PointsToNode::EscapeState new_fields_es = fields ? es : ptn->fields_escape_state();\n+    tty->print_cr(\"-> %s(%s) %s\", esc_names[(int)new_es], esc_names[(int)new_fields_es], reason);\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_propagate_message(PointsToNode* from) const {\n+  if (_compile->trace_escape_analysis()) {\n+    stringStream ss;\n+    ss.print(\"propagated from: \");\n+    from->dump(true, &ss, false);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_arg_escape_message(CallNode* call) const {\n+  if (_compile->trace_escape_analysis()) {\n+    stringStream ss;\n+    ss.print(\"escapes as arg to:\");\n+    call->dump(\"\", false, &ss);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":95,"deletions":40,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -235,1 +235,2 @@\n-  void dump(bool print_state=true) const;\n+  void dump(bool print_state=true, outputStream* out=tty, bool newline=true) const;\n+  void dump_header(bool print_state=true, outputStream* out=tty) const;\n@@ -432,1 +433,2 @@\n-  void set_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc) {\n+  void set_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc\n+                        DEBUG_ONLY(COMMA const char* reason=\"reason unknown\")) {\n@@ -436,0 +438,1 @@\n+        DEBUG_ONLY(trace_es_update_helper(ptn, esc, false, reason));\n@@ -439,0 +442,1 @@\n+        DEBUG_ONLY(trace_es_update_helper(ptn, esc, true, reason));\n@@ -443,1 +447,2 @@\n-  void set_fields_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc) {\n+  void set_fields_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc\n+                               DEBUG_ONLY(COMMA const char* reason=\"reason unknown\")) {\n@@ -447,0 +452,1 @@\n+        DEBUG_ONLY(trace_es_update_helper(ptn, esc, true, reason));\n@@ -572,0 +578,17 @@\n+  void set_not_scalar_replaceable(PointsToNode* ptn DEBUG_ONLY(COMMA const char* reason=\"reason unknown\")) const {\n+#ifndef PRODUCT\n+    if (_compile->trace_escape_analysis()) {\n+        assert(ptn != nullptr, \"should not be null\");\n+        ptn->dump_header(true);\n+        tty->print_cr(\"is NSR. %s\", reason);\n+    }\n+#endif\n+    ptn->set_scalar_replaceable(false);\n+  }\n+\n+#ifndef PRODUCT\n+  void trace_es_update_helper(PointsToNode* ptn, PointsToNode::EscapeState es, bool fields, const char* reason) const;\n+  const char* trace_propagate_message(PointsToNode* from) const;\n+  const char* trace_arg_escape_message(CallNode* call) const;\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"}]}