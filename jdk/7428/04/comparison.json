{"files":[{"patch":"@@ -69,0 +69,1 @@\n+NOT_PRODUCT(cflags(TraceEscapeAnalysis, bool, false, TraceEscapeAnalysis)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+NOT_PRODUCT(option(TraceEscapeAnalysis, \"TraceEscapeAnalysis\", Bool)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -220,0 +220,14 @@\n+\n+#ifndef PRODUCT\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    tty->print(\"+++++ Initial worklist for \");\n+    _compile->method()->print_name();\n+    tty->print_cr(\" (ea_inv=%d)\", _invocation);\n+    for (int i = 0; i < ptnodes_worklist.length(); i++) {\n+      PointsToNode* ptn = ptnodes_worklist.at(i);\n+      ptn->dump();\n+    }\n+    tty->print_cr(\"+++++ Calculating escape states and scalar replaceability\");\n+  }\n+#endif\n+\n@@ -868,1 +882,1 @@\n-    set_escape_state(ptn, PointsToNode::GlobalEscape);\n+    set_escape_state(ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA \"stored at raw address\"));\n@@ -895,0 +909,1 @@\n+    NOT_PRODUCT(const char* nsr_reason = \"\");\n@@ -900,2 +915,2 @@\n-        if (length < 0 || length > EliminateAllocationArraySizeLimit) {\n-          \/\/ Not scalar replaceable if the length is not constant or too big.\n+        if (length < 0) {\n+          \/\/ Not scalar replaceable if the length is not constant.\n@@ -903,0 +918,5 @@\n+          NOT_PRODUCT(nsr_reason = \"has a non-constant length\");\n+        } else if (length > EliminateAllocationArraySizeLimit) {\n+          \/\/ Not scalar replaceable if the length is too big.\n+          scalar_replaceable = false;\n+          NOT_PRODUCT(nsr_reason = \"has a length that is too big\");\n@@ -917,0 +937,1 @@\n+          NOT_PRODUCT(nsr_reason = \"has too many fields\");\n@@ -923,1 +944,1 @@\n-      ptn->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA nsr_reason));\n@@ -954,1 +975,1 @@\n-      ptnode_adr(call_idx)->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of multinewarray\"));\n@@ -976,1 +997,1 @@\n-        ptnode_adr(call_idx)->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of call\"));\n@@ -1131,1 +1152,1 @@\n-          set_escape_state(arg_ptn, es);\n+          set_escape_state(arg_ptn, es NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1186,1 +1207,1 @@\n-              set_escape_state(arg_ptn, PointsToNode::GlobalEscape);\n+              set_escape_state(arg_ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1188,1 +1209,1 @@\n-              set_escape_state(arg_ptn, PointsToNode::ArgEscape);\n+              set_escape_state(arg_ptn, PointsToNode::ArgEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1191,1 +1212,1 @@\n-                set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape);\n+                set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1220,1 +1241,1 @@\n-          set_escape_state(ptnode_adr(arg->_idx), PointsToNode::GlobalEscape);\n+          set_escape_state(ptnode_adr(arg->_idx), PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1404,1 +1425,1 @@\n-          set_fields_escape_state(e, field_es);\n+          set_fields_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1410,1 +1431,1 @@\n-          set_escape_state(e, es);\n+          set_escape_state(e, es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1417,1 +1438,1 @@\n-          set_fields_escape_state(e, field_es);\n+          set_fields_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1424,1 +1445,1 @@\n-          set_escape_state(e, field_es);\n+          set_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1427,1 +1448,1 @@\n-          set_escape_state(e, es);\n+          set_escape_state(e, es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1793,1 +1814,1 @@\n-        jobj->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored at unknown offset\"));\n@@ -1802,1 +1823,1 @@\n-            jobj->set_scalar_replaceable(false);\n+            set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored into field with potentially null base\"));\n@@ -1814,2 +1835,2 @@\n-        jobj->set_scalar_replaceable(false);\n-         ptn->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA trace_merged_message(ptn)));\n+        set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA trace_merged_message(jobj)));\n@@ -1835,1 +1856,1 @@\n-      jobj->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"has field with unknown offset\"));\n@@ -1850,1 +1871,1 @@\n-      jobj->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is used as base of mixed unsafe access\"));\n@@ -1857,1 +1878,1 @@\n-        jobj->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is used in LoadStore or mismatched access\"));\n@@ -1886,2 +1907,2 @@\n-          jobj->set_scalar_replaceable(false);\n-          base->set_scalar_replaceable(false);\n+          set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"may point to more than one object\"));\n+          set_not_scalar_replaceable(base NOT_PRODUCT(COMMA \"may point to more than one object\"));\n@@ -3152,1 +3173,1 @@\n-      set_escape_state(ptnode_adr(n->_idx), es); \/\/ CheckCastPP escape state\n+      set_escape_state(ptnode_adr(n->_idx), es NOT_PRODUCT(COMMA trace_propagate_message(ptn))); \/\/ CheckCastPP escape state\n@@ -3627,1 +3648,1 @@\n-void PointsToNode::dump(bool print_state) const {\n+void PointsToNode::dump_header(bool print_state, outputStream* out) const {\n@@ -3629,1 +3650,1 @@\n-  tty->print(\"%s \", node_type_names[(int) nt]);\n+  out->print(\"%s(%d) \", node_type_names[(int) nt], _pidx);\n@@ -3633,1 +3654,1 @@\n-    tty->print(\"%s(%s) \", esc_names[(int)es], esc_names[(int)fields_es]);\n+    out->print(\"%s(%s) \", esc_names[(int)es], esc_names[(int)fields_es]);\n@@ -3635,1 +3656,1 @@\n-      tty->print(\"NSR \");\n+      out->print(\"NSR \");\n@@ -3638,0 +3659,4 @@\n+}\n+\n+void PointsToNode::dump(bool print_state, outputStream* out, bool newline) const {\n+  dump_header(print_state, out);\n@@ -3641,1 +3666,1 @@\n-      tty->print(\"oop \");\n+      out->print(\"oop \");\n@@ -3644,1 +3669,1 @@\n-      tty->print(\"+%d \", f->offset());\n+      out->print(\"+%d \", f->offset());\n@@ -3646,1 +3671,1 @@\n-    tty->print(\"(\");\n+    out->print(\"(\");\n@@ -3649,1 +3674,1 @@\n-      tty->print(\" %d%s\", b->idx(),(b->is_JavaObject() ? \"P\" : \"\"));\n+      out->print(\" %d%s\", b->idx(),(b->is_JavaObject() ? \"P\" : \"\"));\n@@ -3651,1 +3676,1 @@\n-    tty->print(\" )\");\n+    out->print(\" )\");\n@@ -3653,1 +3678,1 @@\n-  tty->print(\"[\");\n+  out->print(\"[\");\n@@ -3656,1 +3681,1 @@\n-    tty->print(\" %d%s%s\", e->idx(),(e->is_JavaObject() ? \"P\" : (e->is_Field() ? \"F\" : \"\")), e->is_Arraycopy() ? \"cp\" : \"\");\n+    out->print(\" %d%s%s\", e->idx(),(e->is_JavaObject() ? \"P\" : (e->is_Field() ? \"F\" : \"\")), e->is_Arraycopy() ? \"cp\" : \"\");\n@@ -3658,1 +3683,1 @@\n-  tty->print(\" [\");\n+  out->print(\" [\");\n@@ -3666,1 +3691,1 @@\n-    tty->print(\" %d%s%s\", u->idx(), is_base ? \"b\" : \"\", u->is_Arraycopy() ? \"cp\" : \"\");\n+    out->print(\" %d%s%s\", u->idx(), is_base ? \"b\" : \"\", u->is_Arraycopy() ? \"cp\" : \"\");\n@@ -3668,1 +3693,1 @@\n-  tty->print(\" ]]  \");\n+  out->print(\" ]]  \");\n@@ -3670,1 +3695,1 @@\n-    tty->print_cr(\"<null>\");\n+    out->print(\"<null>%s\", newline ? \"\\n\" : \"\");\n@@ -3672,1 +3697,1 @@\n-    _node->dump();\n+    _node->dump(newline ? \"\\n\" : \"\", false, out);\n@@ -3715,0 +3740,45 @@\n+\n+void ConnectionGraph::trace_es_update_helper(PointsToNode* ptn, PointsToNode::EscapeState es, bool fields, const char* reason) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    assert(ptn != nullptr, \"should not be null\");\n+    assert(reason != nullptr, \"should not be null\");\n+    ptn->dump_header(true);\n+    PointsToNode::EscapeState new_es = fields ? ptn->escape_state() : es;\n+    PointsToNode::EscapeState new_fields_es = fields ? es : ptn->fields_escape_state();\n+    tty->print_cr(\"-> %s(%s) %s\", esc_names[(int)new_es], esc_names[(int)new_fields_es], reason);\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_propagate_message(PointsToNode* from) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"propagated from: \");\n+    from->dump(true, &ss, false);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_arg_escape_message(CallNode* call) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"escapes as arg to:\");\n+    call->dump(\"\", false, &ss);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_merged_message(PointsToNode* other) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"is merged with other object: \");\n+    other->dump_header(true, &ss);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":112,"deletions":42,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -235,1 +235,2 @@\n-  void dump(bool print_state=true) const;\n+  void dump(bool print_state=true, outputStream* out=tty, bool newline=true) const;\n+  void dump_header(bool print_state=true, outputStream* out=tty) const;\n@@ -432,1 +433,2 @@\n-  void set_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc) {\n+  void set_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc\n+                        NOT_PRODUCT(COMMA const char* reason)) {\n@@ -436,0 +438,1 @@\n+        NOT_PRODUCT(trace_es_update_helper(ptn, esc, false, reason));\n@@ -439,0 +442,1 @@\n+        NOT_PRODUCT(trace_es_update_helper(ptn, esc, true, reason));\n@@ -443,1 +447,2 @@\n-  void set_fields_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc) {\n+  void set_fields_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc\n+                               NOT_PRODUCT(COMMA const char* reason)) {\n@@ -447,0 +452,1 @@\n+        NOT_PRODUCT(trace_es_update_helper(ptn, esc, true, reason));\n@@ -572,0 +578,18 @@\n+  void set_not_scalar_replaceable(PointsToNode* ptn NOT_PRODUCT(COMMA const char* reason)) const {\n+#ifndef PRODUCT\n+    if (_compile->directive()->TraceEscapeAnalysisOption) {\n+        assert(ptn != nullptr, \"should not be null\");\n+        ptn->dump_header(true);\n+        tty->print_cr(\"is NSR. %s\", reason);\n+    }\n+#endif\n+    ptn->set_scalar_replaceable(false);\n+  }\n+\n+#ifndef PRODUCT\n+  void trace_es_update_helper(PointsToNode* ptn, PointsToNode::EscapeState es, bool fields, const char* reason) const;\n+  const char* trace_propagate_message(PointsToNode* from) const;\n+  const char* trace_arg_escape_message(CallNode* call) const;\n+  const char* trace_merged_message(PointsToNode* other) const;\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"}]}