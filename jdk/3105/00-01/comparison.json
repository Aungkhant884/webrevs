{"files":[{"patch":"@@ -159,16 +159,0 @@\n-void PhaseMacroExpand::extract_call_projections(CallNode* call) {\n-  CallProjections projs;\n-\n-  call->extract_projections(&projs, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n-#define PROJ_ASSIGNMENT(dst, src) dst = !src ? nullptr : (src->as_Proj());\n-  PROJ_ASSIGNMENT(_fallthroughproj,      projs.fallthrough_proj);\n-  PROJ_ASSIGNMENT(_fallthroughcatchproj, projs.fallthrough_catchproj);\n-  PROJ_ASSIGNMENT(_ioproj_fallthrough,   projs.fallthrough_ioproj);\n-  PROJ_ASSIGNMENT(_ioproj_catchall,      projs.catchall_ioproj);\n-  PROJ_ASSIGNMENT(_catchallcatchproj,    projs.catchall_catchproj);\n-  PROJ_ASSIGNMENT(_memproj_fallthrough,  projs.fallthrough_memproj);\n-  PROJ_ASSIGNMENT(_memproj_catchall,     projs.catchall_memproj);\n-  PROJ_ASSIGNMENT(_resproj,              projs.resproj);\n-#undef PROJ_ASSIGNMENT\n-}\n-\n@@ -956,1 +940,1 @@\n-  if (_resproj != NULL && _resproj->outcnt() != 0) {\n+  if (_call_projects.resproj != NULL && _call_projects.resproj->outcnt() != 0) {\n@@ -960,2 +944,2 @@\n-    for (DUIterator_Fast jmax, j = _resproj->fast_outs(jmax);  j < jmax; j++) {\n-      Node *use = _resproj->fast_out(j);\n+    for (DUIterator_Fast jmax, j = _call_projects.resproj->fast_outs(jmax);  j < jmax; j++) {\n+      Node *use = _call_projects.resproj->fast_out(j);\n@@ -968,3 +952,3 @@\n-    for (DUIterator_Last jmin, j = _resproj->last_outs(jmin); j >= jmin; ) {\n-      Node *use = _resproj->last_out(j);\n-      uint oc1 = _resproj->outcnt();\n+    for (DUIterator_Last jmin, j = _call_projects.resproj->last_outs(jmin); j >= jmin; ) {\n+      Node *use = _call_projects.resproj->last_out(j);\n+      uint oc1 = _call_projects.resproj->outcnt();\n@@ -980,1 +964,1 @@\n-          assert(tmp == _fallthroughcatchproj, \"allocation control projection\");\n+          assert(tmp == _call_projects.fallthrough_catchproj, \"allocation control projection\");\n@@ -988,1 +972,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _memproj_fallthrough, \"allocation memory projection\");\n+            assert(mem->in(TypeFunc::Memory) == _call_projects.fallthrough_memproj, \"allocation memory projection\");\n@@ -990,1 +974,1 @@\n-            assert(mem == _memproj_fallthrough, \"allocation memory projection\");\n+            assert(mem == _call_projects.fallthrough_memproj, \"allocation memory projection\");\n@@ -998,1 +982,1 @@\n-      j -= (oc1 - _resproj->outcnt());\n+      j -= (oc1 - _call_projects.resproj->outcnt());\n@@ -1001,2 +985,2 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    _igvn.replace_node(_fallthroughcatchproj, alloc->in(TypeFunc::Control));\n+  if (_call_projects.fallthrough_catchproj != NULL) {\n+    _igvn.replace_node(_call_projects.fallthrough_catchproj, alloc->in(TypeFunc::Control));\n@@ -1004,2 +988,2 @@\n-  if (_memproj_fallthrough != NULL) {\n-    _igvn.replace_node(_memproj_fallthrough, alloc->in(TypeFunc::Memory));\n+  if (_call_projects.fallthrough_memproj != NULL) {\n+    _igvn.replace_node(_call_projects.fallthrough_memproj, alloc->in(TypeFunc::Memory));\n@@ -1007,2 +991,2 @@\n-  if (_memproj_catchall != NULL) {\n-    _igvn.replace_node(_memproj_catchall, C->top());\n+  if (_call_projects.catchall_memproj != NULL) {\n+    _igvn.replace_node(_call_projects.catchall_memproj, C->top());\n@@ -1010,2 +994,2 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    _igvn.replace_node(_ioproj_fallthrough, alloc->in(TypeFunc::I_O));\n+  if (_call_projects.fallthrough_ioproj != NULL) {\n+    _igvn.replace_node(_call_projects.fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n@@ -1013,2 +997,2 @@\n-  if (_ioproj_catchall != NULL) {\n-    _igvn.replace_node(_ioproj_catchall, C->top());\n+  if (_call_projects.catchall_ioproj != NULL) {\n+    _igvn.replace_node(_call_projects.catchall_ioproj, C->top());\n@@ -1016,2 +1000,2 @@\n-  if (_catchallcatchproj != NULL) {\n-    _igvn.replace_node(_catchallcatchproj, C->top());\n+  if (_call_projects.catchall_catchproj != NULL) {\n+    _igvn.replace_node(_call_projects.catchall_catchproj, C->top());\n@@ -1042,1 +1026,1 @@\n-  extract_call_projections(alloc);\n+  alloc->extract_projections(&_call_projects, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n@@ -1097,1 +1081,1 @@\n-  extract_call_projections(boxing);\n+  boxing->extract_projections(&_call_projects, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n@@ -1427,1 +1411,1 @@\n-  extract_call_projections(call);\n+  call->extract_projections(&_call_projects, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n@@ -1433,9 +1417,9 @@\n-  if (expand_fast_path && _memproj_fallthrough != NULL) {\n-    migrate_outs(_memproj_fallthrough, result_phi_rawmem);\n-  }\n-  \/\/ Now change uses of _memproj_catchall to use _memproj_fallthrough and delete\n-  \/\/ _memproj_catchall so we end up with a call that has only 1 memory projection.\n-  if (_memproj_catchall != NULL ) {\n-    if (_memproj_fallthrough == NULL) {\n-      _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);\n-      transform_later(_memproj_fallthrough);\n+  if (expand_fast_path && _call_projects.fallthrough_memproj != NULL) {\n+    migrate_outs(_call_projects.fallthrough_memproj, result_phi_rawmem);\n+  }\n+  \/\/ Now change uses of catchall_memproj to use fallthrough_memproj and delete\n+  \/\/ catchall_memproj so we end up with a call that has only 1 memory projection.\n+  if (_call_projects.catchall_memproj != NULL ) {\n+    if (_call_projects.fallthrough_memproj == NULL) {\n+      _call_projects.fallthrough_memproj = new ProjNode(call, TypeFunc::Memory);\n+      transform_later(_call_projects.fallthrough_memproj);\n@@ -1443,2 +1427,2 @@\n-    migrate_outs(_memproj_catchall, _memproj_fallthrough);\n-    _igvn.remove_dead_node(_memproj_catchall);\n+    migrate_outs(_call_projects.catchall_memproj, _call_projects.fallthrough_memproj);\n+    _igvn.remove_dead_node(_call_projects.catchall_memproj);\n@@ -1452,9 +1436,9 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    migrate_outs(_ioproj_fallthrough, result_phi_i_o);\n-  }\n-  \/\/ Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete\n-  \/\/ _ioproj_catchall so we end up with a call that has only 1 i_o projection.\n-  if (_ioproj_catchall != NULL ) {\n-    if (_ioproj_fallthrough == NULL) {\n-      _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);\n-      transform_later(_ioproj_fallthrough);\n+  if (_call_projects.fallthrough_ioproj != NULL) {\n+    migrate_outs(_call_projects.fallthrough_ioproj, result_phi_i_o);\n+  }\n+  \/\/ Now change uses of catchall_ioproj to use fallthrough_ioproj and delete\n+  \/\/ catchall_ioproj so we end up with a call that has only 1 i_o projection.\n+  if (_call_projects.catchall_ioproj != NULL ) {\n+    if (_call_projects.fallthrough_ioproj == NULL) {\n+      _call_projects.fallthrough_ioproj = new ProjNode(call, TypeFunc::I_O);\n+      transform_later(_call_projects.fallthrough_ioproj);\n@@ -1462,2 +1446,2 @@\n-    migrate_outs(_ioproj_catchall, _ioproj_fallthrough);\n-    _igvn.remove_dead_node(_ioproj_catchall);\n+    migrate_outs(_call_projects.catchall_ioproj, _call_projects.fallthrough_ioproj);\n+    _igvn.remove_dead_node(_call_projects.catchall_ioproj);\n@@ -1482,2 +1466,2 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    ctrl = _fallthroughcatchproj->clone();\n+  if (_call_projects.fallthrough_catchproj != NULL) {\n+    ctrl = _call_projects.fallthrough_catchproj->clone();\n@@ -1485,1 +1469,1 @@\n-    _igvn.replace_node(_fallthroughcatchproj, result_region);\n+    _igvn.replace_node(_call_projects.fallthrough_catchproj, result_region);\n@@ -1490,1 +1474,1 @@\n-  if (_resproj == NULL) {\n+  if (_call_projects.resproj == NULL) {\n@@ -1494,1 +1478,1 @@\n-    slow_result = _resproj->clone();\n+    slow_result = _call_projects.resproj->clone();\n@@ -1496,1 +1480,1 @@\n-    _igvn.replace_node(_resproj, result_phi_rawoop);\n+    _igvn.replace_node(_call_projects.resproj, result_phi_rawoop);\n@@ -1506,1 +1490,1 @@\n-  result_phi_rawmem->init_req(slow_result_path, _memproj_fallthrough);\n+  result_phi_rawmem->init_req(slow_result_path, _call_projects.fallthrough_memproj);\n@@ -1518,4 +1502,4 @@\n-  extract_call_projections(alloc);\n-  if (_resproj != NULL) {\n-    for (DUIterator_Fast imax, i = _resproj->fast_outs(imax); i < imax; i++) {\n-      Node* use = _resproj->fast_out(i);\n+  alloc->extract_projections(&_call_projects, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n+  if (_call_projects.resproj != NULL) {\n+    for (DUIterator_Fast imax, i = _call_projects.resproj->fast_outs(imax); i < imax; i++) {\n+      Node* use = _call_projects.resproj->fast_out(i);\n@@ -1526,2 +1510,2 @@\n-    assert(_resproj->outcnt() == 0, \"all uses must be deleted\");\n-    _igvn.remove_dead_node(_resproj);\n+    assert(_call_projects.resproj->outcnt() == 0, \"all uses must be deleted\");\n+    _igvn.remove_dead_node(_call_projects.resproj);\n@@ -1529,3 +1513,3 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    migrate_outs(_fallthroughcatchproj, ctrl);\n-    _igvn.remove_dead_node(_fallthroughcatchproj);\n+  if (_call_projects.fallthrough_catchproj != NULL) {\n+    migrate_outs(_call_projects.fallthrough_catchproj, ctrl);\n+    _igvn.remove_dead_node(_call_projects.fallthrough_catchproj);\n@@ -1533,3 +1517,3 @@\n-  if (_catchallcatchproj != NULL) {\n-    _igvn.rehash_node_delayed(_catchallcatchproj);\n-    _catchallcatchproj->set_req(0, top());\n+  if (_call_projects.catchall_catchproj != NULL) {\n+    _igvn.rehash_node_delayed(_call_projects.catchall_catchproj);\n+    _call_projects.catchall_catchproj->set_req(0, top());\n@@ -1537,2 +1521,2 @@\n-  if (_fallthroughproj != NULL) {\n-    Node* catchnode = _fallthroughproj->unique_ctrl_out();\n+  if (_call_projects.fallthrough_proj != NULL) {\n+    Node* catchnode = _call_projects.fallthrough_proj->unique_ctrl_out();\n@@ -1540,1 +1524,1 @@\n-    _igvn.remove_dead_node(_fallthroughproj);\n+    _igvn.remove_dead_node(_call_projects.fallthrough_proj);\n@@ -1542,3 +1526,3 @@\n-  if (_memproj_fallthrough != NULL) {\n-    migrate_outs(_memproj_fallthrough, mem);\n-    _igvn.remove_dead_node(_memproj_fallthrough);\n+  if (_call_projects.fallthrough_memproj != NULL) {\n+    migrate_outs(_call_projects.fallthrough_memproj, mem);\n+    _igvn.remove_dead_node(_call_projects.fallthrough_memproj);\n@@ -1546,3 +1530,3 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    migrate_outs(_ioproj_fallthrough, i_o);\n-    _igvn.remove_dead_node(_ioproj_fallthrough);\n+  if (_call_projects.fallthrough_ioproj != NULL) {\n+    migrate_outs(_call_projects.fallthrough_ioproj, i_o);\n+    _igvn.remove_dead_node(_call_projects.fallthrough_ioproj);\n@@ -1550,3 +1534,3 @@\n-  if (_memproj_catchall != NULL) {\n-    _igvn.rehash_node_delayed(_memproj_catchall);\n-    _memproj_catchall->set_req(0, top());\n+  if (_call_projects.catchall_memproj != NULL) {\n+    _igvn.rehash_node_delayed(_call_projects.catchall_memproj);\n+    _call_projects.catchall_memproj->set_req(0, top());\n@@ -1554,3 +1538,3 @@\n-  if (_ioproj_catchall != NULL) {\n-    _igvn.rehash_node_delayed(_ioproj_catchall);\n-    _ioproj_catchall->set_req(0, top());\n+  if (_call_projects.catchall_ioproj != NULL) {\n+    _igvn.rehash_node_delayed(_call_projects.catchall_ioproj);\n+    _call_projects.catchall_ioproj->set_req(0, top());\n@@ -2115,1 +2099,1 @@\n-  extract_call_projections(alock);\n+  alock->extract_projections(&_call_projects, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n@@ -2119,2 +2103,2 @@\n-         _fallthroughproj != NULL &&\n-         _memproj_fallthrough != NULL,\n+         _call_projects.fallthrough_proj != NULL &&\n+         _call_projects.fallthrough_memproj != NULL,\n@@ -2123,2 +2107,2 @@\n-  Node* fallthroughproj = _fallthroughproj;\n-  Node* memproj_fallthrough = _memproj_fallthrough;\n+  Node* fallthroughproj = _call_projects.fallthrough_proj;\n+  Node* memproj_fallthrough = _call_projects.fallthrough_memproj;\n@@ -2378,1 +2362,1 @@\n-  extract_call_projections(call);\n+  call->extract_projections(&_call_projects, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n@@ -2384,2 +2368,2 @@\n-  assert ( _ioproj_fallthrough == NULL && _ioproj_catchall == NULL &&\n-           _memproj_catchall == NULL && _catchallcatchproj == NULL, \"Unexpected projection from Lock\");\n+  assert ( _call_projects.fallthrough_ioproj == NULL && _call_projects.catchall_ioproj == NULL &&\n+           _call_projects.catchall_memproj == NULL && _call_projects.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2390,1 +2374,1 @@\n-  Node *slow_ctrl = _fallthroughproj->clone();\n+  Node *slow_ctrl = _call_projects.fallthrough_proj->clone();\n@@ -2392,2 +2376,2 @@\n-  _igvn.hash_delete(_fallthroughproj);\n-  _fallthroughproj->disconnect_inputs(C);\n+  _igvn.hash_delete(_call_projects.fallthrough_proj);\n+  _call_projects.fallthrough_proj->disconnect_inputs(C);\n@@ -2397,1 +2381,1 @@\n-  _igvn.replace_node(_fallthroughproj, region);\n+  _igvn.replace_node(_call_projects.fallthrough_proj, region);\n@@ -2402,1 +2386,1 @@\n-  _igvn.replace_node(_memproj_fallthrough, mem_phi);\n+  _igvn.replace_node(_call_projects.fallthrough_memproj, mem_phi);\n@@ -2449,4 +2433,3 @@\n-  extract_call_projections(call);\n-\n-  assert ( _ioproj_fallthrough == NULL && _ioproj_catchall == NULL &&\n-           _memproj_catchall == NULL && _catchallcatchproj == NULL, \"Unexpected projection from Lock\");\n+  call->extract_projections(&_call_projects, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n+  assert ( _call_projects.fallthrough_ioproj == NULL && _call_projects.catchall_ioproj == NULL &&\n+           _call_projects.catchall_memproj == NULL && _call_projects.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2458,1 +2441,1 @@\n-  Node *slow_ctrl = _fallthroughproj->clone();\n+  Node *slow_ctrl = _call_projects.fallthrough_proj->clone();\n@@ -2460,2 +2443,2 @@\n-  _igvn.hash_delete(_fallthroughproj);\n-  _fallthroughproj->disconnect_inputs(C);\n+  _igvn.hash_delete(_call_projects.fallthrough_proj);\n+  _call_projects.fallthrough_proj->disconnect_inputs(C);\n@@ -2465,1 +2448,1 @@\n-  _igvn.replace_node(_fallthroughproj, region);\n+  _igvn.replace_node(_call_projects.fallthrough_proj, region);\n@@ -2471,1 +2454,1 @@\n-  _igvn.replace_node(_memproj_fallthrough, mem_phi);\n+  _igvn.replace_node(_call_projects.fallthrough_memproj, mem_phi);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":102,"deletions":119,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,8 +85,1 @@\n-  ProjNode *_fallthroughproj;\n-  ProjNode *_fallthroughcatchproj;\n-  ProjNode *_ioproj_fallthrough;\n-  ProjNode *_ioproj_catchall;\n-  ProjNode *_catchallcatchproj;\n-  ProjNode *_memproj_fallthrough;\n-  ProjNode *_memproj_catchall;\n-  ProjNode *_resproj;\n+  CallProjections _call_projects;\n@@ -202,1 +195,0 @@\n-  void extract_call_projections(CallNode *call);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -829,3 +829,3 @@\n-  _igvn.replace_node(_memproj_fallthrough, out_mem);\n-  _igvn.replace_node(_ioproj_fallthrough, *io);\n-  _igvn.replace_node(_fallthroughcatchproj, *ctrl);\n+  _igvn.replace_node(_call_projects.fallthrough_memproj, out_mem);\n+  _igvn.replace_node(_call_projects.fallthrough_ioproj, *io);\n+  _igvn.replace_node(_call_projects.fallthrough_catchproj, *ctrl);\n@@ -1077,2 +1077,2 @@\n-  extract_call_projections(call);\n-  *ctrl = _fallthroughcatchproj->clone();\n+  call->extract_projections(&_call_projects, false\/*separate_io_proj*\/, false\/*do_asserts*\/);\n+  *ctrl = _call_projects.fallthrough_catchproj->clone();\n@@ -1081,1 +1081,1 @@\n-  Node* m = _memproj_fallthrough->clone();\n+  Node* m = _call_projects.fallthrough_memproj->clone();\n@@ -1094,1 +1094,1 @@\n-  *io = _ioproj_fallthrough->clone();\n+  *io = _call_projects.fallthrough_ioproj->clone();\n@@ -1329,3 +1329,3 @@\n-    _igvn.replace_node(_memproj_fallthrough, merge_mem);\n-    _igvn.replace_node(_ioproj_fallthrough, io);\n-    _igvn.replace_node(_fallthroughcatchproj, ctrl);\n+    _igvn.replace_node(_call_projects.fallthrough_memproj, merge_mem);\n+    _igvn.replace_node(_call_projects.fallthrough_ioproj, io);\n+    _igvn.replace_node(_call_projects.fallthrough_catchproj, ctrl);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}