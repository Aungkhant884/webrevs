{"files":[{"patch":"@@ -267,1 +267,1 @@\n-      ri->_dumptime_base = (uintptr_t)mapinfo->start_address_as_decoded_from_archive(r);\n+      ri->_dumptime_base = (uintptr_t)r->dumptime_base();\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-    assert(!UseCompressedOops, \"must be\");\n@@ -166,1 +165,0 @@\n-    assert(!UseCompressedOops, \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+      assert(UseG1GC, \"only UseG1GC supports HeapShared::can_write()\");\n@@ -1552,1 +1553,1 @@\n-void FileMapRegion::init(int region_index, size_t mapping_offset, size_t size, bool read_only,\n+void FileMapRegion::init(int region_index, size_t mapping_offset, char* dumptime_base, size_t size, bool read_only,\n@@ -1556,0 +1557,13 @@\n+\n+  \/\/ _mapping_offset is used only by ro\/rw regions\n+  \/\/ _dumptime_base is used only by heap regions\n+  if (_is_heap_region) {\n+    assert(mapping_offset == 0, \"must be\");\n+  } else if (_is_bitmap_region) {\n+    assert(mapping_offset == 0, \"must be\");\n+    assert(dumptime_base == NULL, \"must be\");\n+  } else {\n+    assert(region_index == MetaspaceShared::ro || region_index == MetaspaceShared::rw, \"must be\");\n+    assert(dumptime_base == NULL, \"must be\");\n+  }\n+\n@@ -1557,0 +1571,1 @@\n+  _dumptime_base = dumptime_base;\n@@ -1621,0 +1636,1 @@\n+  char* dumptime_base = NULL;\n@@ -1630,9 +1646,9 @@\n-    requested_base = base;\n-    if (UseCompressedOops) {\n-      mapping_offset = (size_t)CompressedOops::encode_not_null(cast_to_oop(base));\n-    } else {\n-#if INCLUDE_G1GC\n-      mapping_offset = requested_base - (char*)G1CollectedHeap::heap()->reserved().start();\n-#endif\n-    }\n-    assert(mapping_offset == (size_t)(uint32_t)mapping_offset, \"must be 32-bit only\");\n+    \/\/ For UseCompressedOops == false:\n+    \/\/     For deterministic archive contents, we pretend that the dumptime heap\n+    \/\/     always starts at 0x10000000 (see HeapShared::to_requested_address()), so\n+    \/\/     requested_base and dumptime_base are NOT the actual address used at\n+    \/\/     dumptime for this region. However, the contents of this region are\n+    \/\/     patched as if the it started there.\n+    \/\/ For UseCompressedOops == false, HeapShared::to_requested_address does nothing.\n+    requested_base = (char*)HeapShared::to_requested_address((address)base);\n+    dumptime_base = requested_base;\n@@ -1655,1 +1671,1 @@\n-  r->init(region, mapping_offset, size, read_only, allow_exec, crc);\n+  r->init(region, mapping_offset, dumptime_base, size, read_only, allow_exec, crc);\n@@ -2063,10 +2079,0 @@\n-address FileMapInfo::decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode) {\n-  size_t offset = spc->mapping_offset();\n-  narrowOop n = CompressedOops::narrow_oop_cast(offset);\n-  if (with_current_oop_encoding_mode) {\n-    return cast_from_oop<address>(CompressedOops::decode_raw_not_null(n));\n-  } else {\n-    return cast_from_oop<address>(ArchiveHeapLoader::decode_from_archive(n));\n-  }\n-}\n-\n@@ -2083,5 +2089,2 @@\n-\/\/ Returns the address range of the archived heap regions computed using the\n-\/\/ current oop encoding mode. This range may be different than the one seen at\n-\/\/ dump time due to encoding mode differences. The result is used in determining\n-\/\/ if\/how these regions should be relocated at run time.\n-MemRegion FileMapInfo::get_heap_regions_range_with_current_oop_encoding_mode() {\n+\/\/ Returns the address range of the archived heap regions during dumptime.\n+MemRegion FileMapInfo::dumptime_heap_regions_range() {\n@@ -2097,2 +2100,2 @@\n-      address s = start_address_as_decoded_with_current_oop_encoding_mode(r);\n-      address e = s + size;\n+      address s = (address)r->dumptime_base();\n+      address e = (address)r->dumptime_end();\n@@ -2148,5 +2151,10 @@\n-  log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", narrow_klass_shift = %d\",\n-                p2i(narrow_klass_base()), narrow_klass_shift());\n-  log_info(cds)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n-                narrow_oop_mode(), p2i(narrow_oop_base()), narrow_oop_shift());\n-  log_info(cds)(\"    heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+  if (header()->compressed_class_pointers()) {\n+    log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", narrow_klass_shift = %d\",\n+                  p2i(narrow_klass_base()), narrow_klass_shift());\n+  }\n+  if (header()->compressed_oops()) {\n+    log_info(cds)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n+                  narrow_oop_mode(), p2i(narrow_oop_base()), narrow_oop_shift());\n+  }\n+  log_info(cds)(\"    heap range %s= [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+                header()->compressed_oops() ? \"\" : \"(effective) \",\n@@ -2157,4 +2165,8 @@\n-  log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", narrow_klass_shift = %d\",\n-                p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());\n-  log_info(cds)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n-                CompressedOops::mode(), p2i(CompressedOops::base()), CompressedOops::shift());\n+  if (UseCompressedClassPointers) {\n+    log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", narrow_klass_shift = %d\",\n+                  p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());\n+  }\n+  if (UseCompressedOops) {\n+    log_info(cds)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n+                  CompressedOops::mode(), p2i(CompressedOops::base()), CompressedOops::shift());\n+  }\n@@ -2180,6 +2192,1 @@\n-  if (UseCompressedOops) {\n-    return start_address_as_decoded_from_archive(spc);\n-  } else {\n-    assert(is_aligned(spc->mapping_offset(), sizeof(HeapWord)), \"must be\");\n-    return header()->heap_begin() + spc->mapping_offset() + ArchiveHeapLoader::runtime_delta();\n-  }\n+  return (address)(spc->dumptime_base() + ArchiveHeapLoader::runtime_delta());\n@@ -2191,2 +2198,0 @@\n-  } else {\n-    ArchiveHeapLoader::set_runtime_delta(delta);\n@@ -2194,0 +2199,1 @@\n+  ArchiveHeapLoader::set_runtime_delta(delta);\n@@ -2217,0 +2223,1 @@\n+    MemRegion range = dumptime_heap_regions_range();\n@@ -2218,1 +2225,0 @@\n-      MemRegion range = get_heap_regions_range_with_current_oop_encoding_mode();\n@@ -2229,1 +2235,0 @@\n-      MemRegion range((HeapWord*)header()->heap_begin(), (HeapWord*)header()->heap_end());\n@@ -2602,0 +2607,1 @@\n+  assert(!DumpSharedSpaces, \"runtime only\");\n@@ -2603,7 +2609,1 @@\n-  if (HeapShared::is_heap_region(idx)) {\n-    assert(DumpSharedSpaces, \"The following doesn't work at runtime\");\n-    return r->used() > 0 ?\n-          (char*)start_address_as_decoded_with_current_oop_encoding_mode(r) : NULL;\n-  } else {\n-    return r->mapped_base();\n-  }\n+  return r->mapped_base();\n@@ -2729,34 +2729,0 @@\n-\/\/ Check if a given address is within one of the shared regions\n-bool FileMapInfo::is_in_shared_region(const void* p, int idx) {\n-  assert(idx == MetaspaceShared::ro ||\n-         idx == MetaspaceShared::rw, \"invalid region index\");\n-  char* base = region_addr(idx);\n-  if (p >= base && p < base + region_at(idx)->used()) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-\/\/ Unmap mapped regions of shared space.\n-void FileMapInfo::stop_sharing_and_unmap(const char* msg) {\n-  MetaspaceShared::set_shared_metaspace_range(NULL, NULL, NULL);\n-\n-  FileMapInfo *map_info = FileMapInfo::current_info();\n-  if (map_info) {\n-    map_info->fail_continue(\"%s\", msg);\n-    for (int i = 0; i < MetaspaceShared::num_non_heap_regions; i++) {\n-      if (!HeapShared::is_heap_region(i)) {\n-        map_info->unmap_region(i);\n-      }\n-    }\n-    \/\/ Dealloc the archive heap regions only without unmapping. The regions are part\n-    \/\/ of the java heap. Unmapping of the heap regions are managed by GC.\n-    map_info->dealloc_heap_regions(open_heap_regions,\n-                                   num_open_heap_regions);\n-    map_info->dealloc_heap_regions(closed_heap_regions,\n-                                   num_closed_heap_regions);\n-  } else if (DumpSharedSpaces) {\n-    fail_stop(\"%s\", msg);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":54,"deletions":88,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -161,0 +161,2 @@\n+  char*  dumptime_base()            const { return _dumptime_base; }\n+  char*  dumptime_end()             const { return dumptime_base() + used_aligned(); }\n@@ -162,1 +164,1 @@\n-  char*  mapped_end()               const { return mapped_base()        + used_aligned(); }\n+  char*  mapped_end()               const { return mapped_base() + used_aligned(); }\n@@ -173,1 +175,2 @@\n-  void init(int region_index, size_t mapping_offset, size_t size, bool read_only,\n+  void init(int region_index, size_t mapping_offset, char* dumptime_base,\n+            size_t size, bool read_only,\n@@ -468,1 +471,1 @@\n-  MemRegion get_heap_regions_range_with_current_oop_encoding_mode() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n+  MemRegion dumptime_heap_regions_range();\n@@ -488,4 +491,0 @@\n-  bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);\n-\n-  \/\/ Stop CDS sharing and unmap CDS regions.\n-  static void stop_sharing_and_unmap(const char* msg);\n@@ -589,14 +588,0 @@\n-  address decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode);\n-\n-  \/\/ The starting address of spc, as calculated with CompressedOop::decode_non_null()\n-  address start_address_as_decoded_with_current_oop_encoding_mode(FileMapRegion* spc) {\n-    return decode_start_address(spc, true);\n-  }\n-public:\n-  \/\/ The starting address of spc, as calculated with HeapShared::decode_from_archive()\n-  address start_address_as_decoded_from_archive(FileMapRegion* spc) {\n-    return decode_start_address(spc, false);\n-  }\n-\n-private:\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -958,5 +958,0 @@\n-\/\/ Return true if given address is in the misc data region\n-bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {\n-  return UseSharedSpaces && FileMapInfo::current_info()->is_in_shared_region(p, idx);\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,3 +117,0 @@\n-  \/\/ Return true if given address is in the shared region corresponding to the idx\n-  static bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 16\n+#define CURRENT_CDS_ARCHIVE_VERSION 17\n@@ -53,3 +53,4 @@\n-  size_t  _mapping_offset;    \/\/ This region should be mapped at this offset from the base address\n-                              \/\/ - for non-heap regions, the base address is SharedBaseAddress\n-                              \/\/ - for heap regions, the base address is the compressed oop encoding base\n+  size_t  _mapping_offset;    \/\/ This region should be mapped at this offset from SharedBaseAddress.\n+                              \/\/ (For RO\/RW regions only. Must be zero for all other types of regions.)\n+  char*   _dumptime_base;     \/\/ This region was located at this address during dumptime.\n+                              \/\/ (For heap regions only. Must be zero for all other types of regions.)\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}