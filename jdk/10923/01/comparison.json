{"files":[{"patch":"@@ -267,1 +267,1 @@\n-      ri->_dumptime_base = (uintptr_t)mapinfo->start_address_as_decoded_from_archive(r);\n+      ri->_dumptime_base = (uintptr_t)r->dumptime_base();\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-    assert(!UseCompressedOops, \"must be\");\n@@ -166,1 +165,0 @@\n-    assert(!UseCompressedOops, \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+      assert(UseG1GC, \"only UseG1GC supports HeapShared::can_write()\");\n@@ -1552,1 +1553,1 @@\n-void FileMapRegion::init(int region_index, size_t mapping_offset, size_t size, bool read_only,\n+void FileMapRegion::init(int region_index, size_t mapping_offset, char* dumptime_base, size_t size, bool read_only,\n@@ -1556,0 +1557,13 @@\n+\n+  \/\/ _mapping_offset is used only by ro\/rw regions\n+  \/\/ _dumptime_base is used only by heap regions\n+  if (_is_heap_region) {\n+    assert(mapping_offset == 0, \"must be\");\n+  } else if (_is_bitmap_region) {\n+    assert(mapping_offset == 0, \"must be\");\n+    assert(dumptime_base == NULL, \"must be\");\n+  } else {\n+    assert(region_index == MetaspaceShared::ro || region_index == MetaspaceShared::rw, \"must be\");\n+    assert(dumptime_base == NULL, \"must be\");\n+  }\n+\n@@ -1557,0 +1571,1 @@\n+  _dumptime_base = dumptime_base;\n@@ -1621,0 +1636,1 @@\n+  char* dumptime_base = NULL;\n@@ -1631,8 +1647,1 @@\n-    if (UseCompressedOops) {\n-      mapping_offset = (size_t)CompressedOops::encode_not_null(cast_to_oop(base));\n-    } else {\n-#if INCLUDE_G1GC\n-      mapping_offset = requested_base - (char*)G1CollectedHeap::heap()->reserved().start();\n-#endif\n-    }\n-    assert(mapping_offset == (size_t)(uint32_t)mapping_offset, \"must be 32-bit only\");\n+    dumptime_base = base; \/\/ This is the runtime address of the base (lower end) of this heap region.\n@@ -1655,1 +1664,1 @@\n-  si->init(region, mapping_offset, size, read_only, allow_exec, crc);\n+  si->init(region, mapping_offset, dumptime_base, size, read_only, allow_exec, crc);\n@@ -2063,10 +2072,0 @@\n-address FileMapInfo::decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode) {\n-  size_t offset = spc->mapping_offset();\n-  narrowOop n = CompressedOops::narrow_oop_cast(offset);\n-  if (with_current_oop_encoding_mode) {\n-    return cast_from_oop<address>(CompressedOops::decode_raw_not_null(n));\n-  } else {\n-    return cast_from_oop<address>(ArchiveHeapLoader::decode_from_archive(n));\n-  }\n-}\n-\n@@ -2083,5 +2082,2 @@\n-\/\/ Returns the address range of the archived heap regions computed using the\n-\/\/ current oop encoding mode. This range may be different than the one seen at\n-\/\/ dump time due to encoding mode differences. The result is used in determining\n-\/\/ if\/how these regions should be relocated at run time.\n-MemRegion FileMapInfo::get_heap_regions_range_with_current_oop_encoding_mode() {\n+\/\/ Returns the address range of the archived heap regions during dumptime.\n+MemRegion FileMapInfo::dumptime_heap_regions_range() {\n@@ -2097,2 +2093,2 @@\n-      address s = start_address_as_decoded_with_current_oop_encoding_mode(si);\n-      address e = s + size;\n+      address s = (address)si->dumptime_base();\n+      address e = (address)si->dumptime_end();\n@@ -2180,6 +2176,1 @@\n-  if (UseCompressedOops) {\n-    return start_address_as_decoded_from_archive(spc);\n-  } else {\n-    assert(is_aligned(spc->mapping_offset(), sizeof(HeapWord)), \"must be\");\n-    return header()->heap_begin() + spc->mapping_offset() + ArchiveHeapLoader::runtime_delta();\n-  }\n+  return (address)(spc->dumptime_base() + ArchiveHeapLoader::runtime_delta());\n@@ -2191,2 +2182,0 @@\n-  } else {\n-    ArchiveHeapLoader::set_runtime_delta(delta);\n@@ -2194,0 +2183,1 @@\n+  ArchiveHeapLoader::set_runtime_delta(delta);\n@@ -2217,0 +2207,1 @@\n+    MemRegion range = dumptime_heap_regions_range();\n@@ -2218,1 +2209,0 @@\n-      MemRegion range = get_heap_regions_range_with_current_oop_encoding_mode();\n@@ -2229,1 +2219,0 @@\n-      MemRegion range((HeapWord*)header()->heap_begin(), (HeapWord*)header()->heap_end());\n@@ -2602,0 +2591,1 @@\n+  assert(!DumpSharedSpaces, \"runtime only\");\n@@ -2603,7 +2593,1 @@\n-  if (HeapShared::is_heap_region(idx)) {\n-    assert(DumpSharedSpaces, \"The following doesn't work at runtime\");\n-    return si->used() > 0 ?\n-          (char*)start_address_as_decoded_with_current_oop_encoding_mode(si) : NULL;\n-  } else {\n-    return si->mapped_base();\n-  }\n+  return si->mapped_base();\n@@ -2729,34 +2713,0 @@\n-\/\/ Check if a given address is within one of the shared regions\n-bool FileMapInfo::is_in_shared_region(const void* p, int idx) {\n-  assert(idx == MetaspaceShared::ro ||\n-         idx == MetaspaceShared::rw, \"invalid region index\");\n-  char* base = region_addr(idx);\n-  if (p >= base && p < base + space_at(idx)->used()) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-\/\/ Unmap mapped regions of shared space.\n-void FileMapInfo::stop_sharing_and_unmap(const char* msg) {\n-  MetaspaceShared::set_shared_metaspace_range(NULL, NULL, NULL);\n-\n-  FileMapInfo *map_info = FileMapInfo::current_info();\n-  if (map_info) {\n-    map_info->fail_continue(\"%s\", msg);\n-    for (int i = 0; i < MetaspaceShared::num_non_heap_regions; i++) {\n-      if (!HeapShared::is_heap_region(i)) {\n-        map_info->unmap_region(i);\n-      }\n-    }\n-    \/\/ Dealloc the archive heap regions only without unmapping. The regions are part\n-    \/\/ of the java heap. Unmapping of the heap regions are managed by GC.\n-    map_info->dealloc_heap_regions(open_heap_regions,\n-                                   num_open_heap_regions);\n-    map_info->dealloc_heap_regions(closed_heap_regions,\n-                                   num_closed_heap_regions);\n-  } else if (DumpSharedSpaces) {\n-    fail_stop(\"%s\", msg);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":28,"deletions":78,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -161,0 +161,2 @@\n+  char*  dumptime_base()            const { return _dumptime_base; }\n+  char*  dumptime_end()             const { return dumptime_base() + used_aligned(); }\n@@ -162,1 +164,1 @@\n-  char*  mapped_end()               const { return mapped_base()        + used_aligned(); }\n+  char*  mapped_end()               const { return mapped_base() + used_aligned(); }\n@@ -173,1 +175,2 @@\n-  void init(int region_index, size_t mapping_offset, size_t size, bool read_only,\n+  void init(int region_index, size_t mapping_offset, char* dumptime_base,\n+            size_t size, bool read_only,\n@@ -468,1 +471,1 @@\n-  MemRegion get_heap_regions_range_with_current_oop_encoding_mode() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n+  MemRegion dumptime_heap_regions_range();\n@@ -488,4 +491,0 @@\n-  bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);\n-\n-  \/\/ Stop CDS sharing and unmap CDS regions.\n-  static void stop_sharing_and_unmap(const char* msg);\n@@ -589,14 +588,0 @@\n-  address decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode);\n-\n-  \/\/ The starting address of spc, as calculated with CompressedOop::decode_non_null()\n-  address start_address_as_decoded_with_current_oop_encoding_mode(FileMapRegion* spc) {\n-    return decode_start_address(spc, true);\n-  }\n-public:\n-  \/\/ The starting address of spc, as calculated with HeapShared::decode_from_archive()\n-  address start_address_as_decoded_from_archive(FileMapRegion* spc) {\n-    return decode_start_address(spc, false);\n-  }\n-\n-private:\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -958,5 +958,0 @@\n-\/\/ Return true if given address is in the misc data region\n-bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {\n-  return UseSharedSpaces && FileMapInfo::current_info()->is_in_shared_region(p, idx);\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,3 +117,0 @@\n-  \/\/ Return true if given address is in the shared region corresponding to the idx\n-  static bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 15\n+#define CURRENT_CDS_ARCHIVE_VERSION 16\n@@ -53,3 +53,4 @@\n-  size_t  _mapping_offset;    \/\/ This region should be mapped at this offset from the base address\n-                              \/\/ - for non-heap regions, the base address is SharedBaseAddress\n-                              \/\/ - for heap regions, the base address is the compressed oop encoding base\n+  size_t  _mapping_offset;    \/\/ This region should be mapped at this offset from SharedBaseAddress.\n+                              \/\/ (For RO\/RW regions only. Must be zero for all other types of regions.)\n+  char*   _dumptime_base;     \/\/ This region was located at this address during dumptime.\n+                              \/\/ (For heap regions only. Must be zero for all other types of regions.)\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}