{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.source.tree.VariableTree;\n@@ -559,0 +560,2 @@\n+            JCTree wrappedTree = null;\n+\n@@ -563,0 +566,1 @@\n+                wrappedTree = rewriting.originalTree;\n@@ -566,1 +570,1 @@\n-            deferredAttr.attribSpeculative(treeToAnalyze, rewriting.env, attr.statInfo, new TreeRewriter(rewriting),\n+            deferredAttr.attribSpeculative(treeToAnalyze, rewriting.env, attr.statInfo, new TreeRewriter(rewriting, wrappedTree),\n@@ -771,0 +775,1 @@\n+        JCTree wrappedTree;\n@@ -772,1 +777,1 @@\n-        TreeRewriter(RewritingContext rewriting) {\n+        TreeRewriter(RewritingContext rewriting, JCTree wrappedTree) {\n@@ -774,0 +779,1 @@\n+            this.wrappedTree = wrappedTree;\n@@ -786,0 +792,14 @@\n+\n+        @Override\n+        public JCTree visitVariable(VariableTree node, Void p) {\n+            JCTree result = super.visitVariable(node, p);\n+            if (node == wrappedTree) {\n+                \/\/The current tree is a field and has been wrapped by a block, so it effectivelly\n+                \/\/became local variable. If it has some modifiers (except for final), an error\n+                \/\/would be reported, causing the whole rewrite to fail. Removing the non-final\n+                \/\/modifiers from the variable here:\n+                ((JCVariableDecl) result).mods.flags &= Flags.FINAL;\n+            }\n+            return result;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8266027\n+ * @summary Verify the diamond finder works on fields with modifiers.\n+ * @compile\/ref=DiamondFields.out -XDfind=diamond -XDrawDiagnostics DiamondFields.java\n+ *\/\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class DiamondFields {\n+                List<String> f1 = new LinkedList<String>();\n+    private     List<String> f2 = new LinkedList<String>();\n+    static      List<String> f3 = new LinkedList<String>();\n+    @Deprecated List<String> f4 = new LinkedList<String>();\n+    final       List<String> f5 = new LinkedList<String>();\n+\n+    DiamondFields() {\n+        List<String> l1 = new LinkedList<String>();\n+        final List<String> l2 = new LinkedList<String>();\n+        @Deprecated List<String> l3 = new LinkedList<String>();\n+    }\n+\n+    void t() {\n+        List<String> l1 = new LinkedList<String>();\n+        final List<String> l2 = new LinkedList<String>();\n+        @Deprecated List<String> l3 = new LinkedList<String>();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/analyzer\/DiamondFields.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+DiamondFields.java:12:49: compiler.warn.diamond.redundant.args\n+DiamondFields.java:13:49: compiler.warn.diamond.redundant.args\n+DiamondFields.java:14:49: compiler.warn.diamond.redundant.args\n+DiamondFields.java:15:49: compiler.warn.diamond.redundant.args\n+DiamondFields.java:16:49: compiler.warn.diamond.redundant.args\n+DiamondFields.java:19:41: compiler.warn.diamond.redundant.args\n+DiamondFields.java:20:47: compiler.warn.diamond.redundant.args\n+DiamondFields.java:21:53: compiler.warn.diamond.redundant.args\n+DiamondFields.java:25:41: compiler.warn.diamond.redundant.args\n+DiamondFields.java:26:47: compiler.warn.diamond.redundant.args\n+DiamondFields.java:27:53: compiler.warn.diamond.redundant.args\n+11 warnings\n","filename":"test\/langtools\/tools\/javac\/analyzer\/DiamondFields.out","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"}]}