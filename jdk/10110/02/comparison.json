{"files":[{"patch":"@@ -74,0 +74,6 @@\n+  develop(ccstr, ArchiveHeapTestClass, NULL,                                \\\n+          \"For JVM internal testing only. Not available in \"                \\\n+          \"product builds. This flag specifies a class whose static \"       \\\n+          \"field named \\\"archivedObjects\\\" is stored into the CDS \"         \\\n+          \"archive heap\")                                                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,0 +72,15 @@\n+struct ArchivableStaticFieldInfo {\n+  const char* klass_name;\n+  const char* field_name;\n+  InstanceKlass* klass;\n+  int offset;\n+  BasicType type;\n+\n+  ArchivableStaticFieldInfo(const char* k, const char* f)\n+  : klass_name(k), field_name(f), klass(NULL), offset(0), type(T_ILLEGAL) {}\n+\n+  bool valid() {\n+    return klass_name != NULL;\n+  }\n+};\n+\n@@ -97,0 +112,8 @@\n+#ifndef PRODUCT\n+#define ARCHIVE_TEST_FIELD_NAME \"archivedObjects\"\n+static Array<char>* _archived_ArchiveHeapTestClass = NULL;\n+static const char* _test_class_name = NULL;\n+static const Klass* _test_class = NULL;\n+static const ArchivedKlassSubGraphInfoRecord* _test_class_record = NULL;\n+#endif\n+\n@@ -112,0 +135,1 @@\n+  {NULL, NULL},\n@@ -120,0 +144,4 @@\n+#ifndef PRODUCT\n+  {NULL, NULL}, \/\/ Extra slot for -XX:ArchiveHeapTestClass\n+#endif\n+  {NULL, NULL},\n@@ -127,0 +155,1 @@\n+  {NULL, NULL},\n@@ -129,7 +158,0 @@\n-const static int num_closed_archive_subgraph_entry_fields =\n-  sizeof(closed_archive_subgraph_entry_fields) \/ sizeof(ArchivableStaticFieldInfo);\n-const static int num_open_archive_subgraph_entry_fields =\n-  sizeof(open_archive_subgraph_entry_fields) \/ sizeof(ArchivableStaticFieldInfo);\n-const static int num_fmg_open_archive_subgraph_entry_fields =\n-  sizeof(fmg_open_archive_subgraph_entry_fields) \/ sizeof(ArchivableStaticFieldInfo);\n-\n@@ -147,2 +169,2 @@\n-static bool is_subgraph_root_class_of(ArchivableStaticFieldInfo fields[], int num, InstanceKlass* ik) {\n-  for (int i = 0; i < num; i++) {\n+static bool is_subgraph_root_class_of(ArchivableStaticFieldInfo fields[], InstanceKlass* ik) {\n+  for (int i = 0; fields[i].valid(); i++) {\n@@ -157,6 +179,3 @@\n-  return is_subgraph_root_class_of(closed_archive_subgraph_entry_fields,\n-                                   num_closed_archive_subgraph_entry_fields, ik) ||\n-         is_subgraph_root_class_of(open_archive_subgraph_entry_fields,\n-                                   num_open_archive_subgraph_entry_fields, ik) ||\n-         is_subgraph_root_class_of(fmg_open_archive_subgraph_entry_fields,\n-                                   num_fmg_open_archive_subgraph_entry_fields, ik);\n+  return is_subgraph_root_class_of(closed_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(open_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(fmg_open_archive_subgraph_entry_fields, ik);\n@@ -522,1 +541,0 @@\n-                           num_closed_archive_subgraph_entry_fields,\n@@ -540,1 +558,0 @@\n-                           num_open_archive_subgraph_entry_fields,\n@@ -545,1 +562,0 @@\n-                             num_fmg_open_archive_subgraph_entry_fields,\n@@ -662,0 +678,1 @@\n+    check_allowed_klass(InstanceKlass::cast(orig_k));\n@@ -667,0 +684,1 @@\n+      check_allowed_klass(InstanceKlass::cast(ObjArrayKlass::cast(orig_k)->bottom_klass()));\n@@ -690,0 +708,22 @@\n+void KlassSubGraphInfo::check_allowed_klass(InstanceKlass* ik) {\n+  if (ik->module()->name() == vmSymbols::java_base()) {\n+    assert(ik->package() != NULL, \"classes in java.base cannot be in unnamed package\");\n+    return;\n+  }\n+\n+#ifndef PRODUCT\n+  if (!ik->module()->is_named() && ik->package() == NULL) {\n+    \/\/ This class is loaded by ArchiveHeapTestClass\n+    return;\n+  }\n+  const char* extra_msg = \", or in an unnamed package of an unnamed module\";\n+#else\n+  const char* extra_msg = \"\";\n+#endif\n+\n+  ResourceMark rm;\n+  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s\",\n+                       ik->external_name(), extra_msg);\n+  os::_exit(1);\n+}\n+\n@@ -803,0 +843,9 @@\n+\n+#ifndef PRODUCT\n+  if (ArchiveHeapTestClass != NULL) {\n+    size_t len = strlen(ArchiveHeapTestClass) + 1;\n+    Array<char>* array = ArchiveBuilder::new_ro_array<char>((int)len);\n+    strncpy(array->adr_at(0), ArchiveHeapTestClass, len);\n+    _archived_ArchiveHeapTestClass = array;\n+  }\n+#endif\n@@ -822,0 +871,8 @@\n+#ifndef PRODUCT\n+  soc->do_ptr((void**)&_archived_ArchiveHeapTestClass);\n+  if (soc->reading() && _archived_ArchiveHeapTestClass != NULL) {\n+    _test_class_name = _archived_ArchiveHeapTestClass->adr_at(0);\n+    setup_test_class(_test_class_name);\n+  }\n+#endif\n+\n@@ -859,0 +916,1 @@\n+  assert(UseSharedSpaces, \"runtime only!\");\n@@ -862,9 +920,3 @@\n-  resolve_classes_for_subgraphs(closed_archive_subgraph_entry_fields,\n-                                num_closed_archive_subgraph_entry_fields,\n-                                THREAD);\n-  resolve_classes_for_subgraphs(open_archive_subgraph_entry_fields,\n-                                num_open_archive_subgraph_entry_fields,\n-                                THREAD);\n-  resolve_classes_for_subgraphs(fmg_open_archive_subgraph_entry_fields,\n-                                num_fmg_open_archive_subgraph_entry_fields,\n-                                THREAD);\n+  resolve_classes_for_subgraphs(closed_archive_subgraph_entry_fields,   THREAD);\n+  resolve_classes_for_subgraphs(open_archive_subgraph_entry_fields,     THREAD);\n+  resolve_classes_for_subgraphs(fmg_open_archive_subgraph_entry_fields, THREAD);\n@@ -874,2 +926,2 @@\n-                                               int num, JavaThread* THREAD) {\n-  for (int i = 0; i < num; i++) {\n+                                               JavaThread* THREAD) {\n+  for (int i = 0; fields[i].valid(); i++) {\n@@ -928,0 +980,7 @@\n+#ifndef PRODUCT\n+  if (_test_class_name != NULL && k->name()->equals(_test_class_name) && record != NULL) {\n+    _test_class = k;\n+    _test_class_record = record;\n+  }\n+#endif\n+\n@@ -949,0 +1008,5 @@\n+    if (log_is_enabled(Info, cds, heap)) {\n+      ResourceMark rm;\n+      log_info(cds, heap)(\"%s subgraph %s \", do_init ? \"init\" : \"resolve\", k->external_name());\n+    }\n+\n@@ -1450,4 +1514,5 @@\n-      assert(!_found, \"fields cannot be overloaded\");\n-      assert(is_reference_type(fd->field_type()), \"can archive only fields that are references\");\n-      _found = true;\n-      _offset = fd->offset();\n+      assert(!_found, \"fields can never be overloaded\");\n+      if (is_reference_type(fd->field_type())) {\n+        _found = true;\n+        _offset = fd->offset();\n+      }\n@@ -1461,2 +1526,2 @@\n-                                            int num, TRAPS) {\n-  for (int i = 0; i < num; i++) {\n+                                            TRAPS) {\n+  for (int i = 0; fields[i].valid(); i++) {\n@@ -1467,1 +1532,24 @@\n-    Klass* k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n+#ifndef PRODUCT\n+    bool is_test_class = (ArchiveHeapTestClass != NULL) && (strcmp(info->klass_name, ArchiveHeapTestClass) == 0);\n+#else\n+    bool is_test_class = false;\n+#endif\n+\n+    if (is_test_class) {\n+      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", ArchiveHeapTestClass);\n+    }\n+\n+    Klass* k = SystemDictionary::resolve_or_fail(klass_name, true, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      CLEAR_PENDING_EXCEPTION;\n+      stringStream st;\n+      st.print(\"Fail to initialize archive heap: %s cannot be loaded by the boot loader\", info->klass_name);\n+      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), st.as_string());\n+    }\n+\n+    if (!k->is_instance_klass()) {\n+      stringStream st;\n+      st.print(\"Fail to initialize archive heap: %s is not an instance class\", info->klass_name);\n+      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), st.as_string());\n+    }\n+\n@@ -1471,0 +1559,30 @@\n+\n+    if (is_test_class) {\n+      if (ik->module()->is_named()) {\n+        \/\/ We don't want ArchiveHeapTestClass to be abused to easily load\/initialize arbitrary\n+        \/\/ core-lib classes. You need to at least append to the bootclasspath.\n+        stringStream st;\n+        st.print(\"ArchiveHeapTestClass %s is not in unnamed module\", ArchiveHeapTestClass);\n+        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), st.as_string());\n+      }\n+\n+      if (ik->package() != NULL) {\n+        \/\/ This restriction makes HeapShared::is_a_test_class_in_unnamed_module() easy.\n+        stringStream st;\n+        st.print(\"ArchiveHeapTestClass %s is not in unnamed package\", ArchiveHeapTestClass);\n+        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), st.as_string());\n+      }\n+    } else {\n+      if (ik->module()->name() != vmSymbols::java_base()) {\n+        \/\/ We don't want to deal with cases when a module is unavailable at runtime.\n+        \/\/ FUTURE -- load from archived heap only when module graph has not changed\n+        \/\/           between dump and runtime.\n+        stringStream st;\n+        st.print(\"%s is not in java.base module\", info->klass_name);\n+        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), st.as_string());\n+      }\n+    }\n+\n+    if (is_test_class) {\n+      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", ArchiveHeapTestClass);\n+    }\n@@ -1475,1 +1593,5 @@\n-    assert(finder.found(), \"field must exist\");\n+    if (!finder.found()) {\n+      stringStream st;\n+      st.print(\"Unable to find the static T_OBJECT field %s::%s\", info->klass_name, info->field_name);\n+      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), st.as_string());\n+    }\n@@ -1485,6 +1607,2 @@\n-  init_subgraph_entry_fields(closed_archive_subgraph_entry_fields,\n-                             num_closed_archive_subgraph_entry_fields,\n-                             CHECK);\n-  init_subgraph_entry_fields(open_archive_subgraph_entry_fields,\n-                             num_open_archive_subgraph_entry_fields,\n-                             CHECK);\n+  init_subgraph_entry_fields(closed_archive_subgraph_entry_fields, CHECK);\n+  init_subgraph_entry_fields(open_archive_subgraph_entry_fields, CHECK);\n@@ -1492,3 +1610,1 @@\n-    init_subgraph_entry_fields(fmg_open_archive_subgraph_entry_fields,\n-                               num_fmg_open_archive_subgraph_entry_fields,\n-                               CHECK);\n+    init_subgraph_entry_fields(fmg_open_archive_subgraph_entry_fields, CHECK);\n@@ -1498,0 +1614,63 @@\n+#ifndef PRODUCT\n+void HeapShared::setup_test_class(const char* test_class_name) {\n+  ArchivableStaticFieldInfo* p = open_archive_subgraph_entry_fields;\n+  int num_slots = sizeof(open_archive_subgraph_entry_fields) \/ sizeof(ArchivableStaticFieldInfo);\n+  assert(p[num_slots - 2].klass_name == NULL, \"must have empty slot that's patched below\");\n+  assert(p[num_slots - 1].klass_name == NULL, \"must have empty slot that marks the end of the list\");\n+\n+  if (test_class_name != NULL) {\n+    p[num_slots - 2].klass_name = test_class_name;\n+    p[num_slots - 2].field_name = ARCHIVE_TEST_FIELD_NAME;\n+  }\n+}\n+\n+\/\/ See if ik is one of the test classes that are pulled in by -XX:ArchiveHeapTestClass\n+\/\/ during runtime. This may be called before the module system is initialized so\n+\/\/ we cannot rely on InstanceKlass::module(), etc.\n+bool HeapShared::is_a_test_class_in_unnamed_module(Klass* ik) {\n+  if (_test_class != NULL) {\n+    if (ik == _test_class) {\n+      return true;\n+    }\n+    Array<Klass*>* klasses = _test_class_record->subgraph_object_klasses();\n+    if (klasses == NULL) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < klasses->length(); i++) {\n+      Klass* k = klasses->at(i);\n+      if (k == ik) {\n+        Symbol* name;\n+        if (k->is_instance_klass()) {\n+          name = InstanceKlass::cast(k)->name();\n+        } else if (k->is_objArray_klass()) {\n+          Klass* bk = ObjArrayKlass::cast(k)->bottom_klass();\n+          if (!bk->is_instance_klass()) {\n+            return false;\n+          }\n+          name = bk->name();\n+        } else {\n+          return false;\n+        }\n+\n+        \/\/ See KlassSubGraphInfo::check_allowed_klass() - only two types of\n+        \/\/ classes are allowed:\n+        \/\/   (A) java.base classes (which must not be in the unnamed module)\n+        \/\/   (B) test classes which must be in the unnamed package of the unnamed module.\n+        \/\/ So if we see a '\/' character in the class name, it must be in (A);\n+        \/\/ otherwise it must be in (B).\n+        for (int j = 0; j < name->utf8_length(); j++) {\n+          if (name->char_at(j) == '\/') {\n+            return false; \/\/ (A)\n+          }\n+        }\n+\n+        return true; \/\/ (B)\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+#endif\n+\n@@ -1500,0 +1679,1 @@\n+    setup_test_class(ArchiveHeapTestClass);\n@@ -1506,1 +1686,1 @@\n-                                          int num, bool is_closed_archive,\n+                                          bool is_closed_archive,\n@@ -1521,1 +1701,1 @@\n-  for (i = 0; i < num; ) {\n+  for (int i = 0; fields[i].valid(); ) {\n@@ -1530,1 +1710,1 @@\n-    for (; i < num; i++) {\n+    for (; fields[i].valid(); i++) {\n@@ -1551,1 +1731,1 @@\n-  for (int i = 0; i < num; i++) {\n+  for (int i = 0; fields[i].valid(); i++) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":230,"deletions":50,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -50,7 +50,1 @@\n-struct ArchivableStaticFieldInfo {\n-  const char* klass_name;\n-  const char* field_name;\n-  InstanceKlass* klass;\n-  int offset;\n-  BasicType type;\n-};\n+struct ArchivableStaticFieldInfo;\n@@ -83,1 +77,1 @@\n-\n+  static void check_allowed_klass(InstanceKlass* ik);\n@@ -293,1 +287,0 @@\n-                                       int num,\n@@ -313,2 +306,1 @@\n-  static void init_subgraph_entry_fields(ArchivableStaticFieldInfo fields[],\n-                                         int num, TRAPS);\n+  static void init_subgraph_entry_fields(ArchivableStaticFieldInfo fields[], TRAPS);\n@@ -367,1 +359,1 @@\n-                                            int num, JavaThread* THREAD);\n+                                            JavaThread* THREAD);\n@@ -465,0 +457,1 @@\n+  static void setup_test_class(const char* test_class_name) PRODUCT_RETURN;\n@@ -528,0 +521,1 @@\n+  static bool is_a_test_class_in_unnamed_module(Klass* ik) NOT_CDS_JAVA_HEAP_RETURN_(return false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -640,1 +640,1 @@\n-void ModuleEntryTable::patch_javabase_entries(Handle module_handle) {\n+void ModuleEntryTable::patch_javabase_entries(JavaThread* current, Handle module_handle) {\n@@ -663,1 +663,12 @@\n-    java_lang_Class::fixup_module_field(k, module_handle);\n+#ifndef PRODUCT\n+    if (HeapShared::is_a_test_class_in_unnamed_module(k)) {\n+      \/\/ We allow -XX:ArchiveHeapTestClass to archive additional classes\n+      \/\/ into the CDS heap, but these must be in the unnamed module.\n+      ModuleEntry* unnamed_module = ClassLoaderData::the_null_class_loader_data()->unnamed_module();\n+      Handle unnamed_module_handle(current, unnamed_module->module());\n+      java_lang_Class::fixup_module_field(k, unnamed_module_handle);\n+    } else\n+#endif\n+    {\n+      java_lang_Class::fixup_module_field(k, module_handle);\n+    }\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-  static void patch_javabase_entries(Handle module_handle);\n+  static void patch_javabase_entries(JavaThread* current, Handle module_handle);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-  ModuleEntryTable::patch_javabase_entries(module_handle);\n+  ModuleEntryTable::patch_javabase_entries(THREAD, module_handle);\n@@ -492,1 +492,1 @@\n-  ModuleEntryTable::patch_javabase_entries(java_base_module);\n+  ModuleEntryTable::patch_javabase_entries(THREAD, java_base_module);\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1052,2 +1052,7 @@\n-    assert(scp_entry != NULL && scp_entry->is_modules_image(),\n-           \"Loading non-bootstrap classes before the module system is initialized\");\n+    assert(scp_entry != NULL, \"must be\");\n+    \/\/ At this point, no modules have been defined yet. KlassSubGraphInfo::check_allowed_klass()\n+    \/\/ has restricted the classes can be loaded at this step to be only:\n+    \/\/ [1] scp_entry->is_modules_image(): classes in java.base, or,\n+    \/\/ [2] HeapShared::is_a_test_class_in_unnamed_module(ik): classes in bootstrap\/unnamed module\n+    assert(scp_entry->is_modules_image() || HeapShared::is_a_test_class_in_unnamed_module(ik),\n+           \"only these classes can be loaded before the module system is initialized\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8214781 8293187\n+ * @summary Test for the -XX:ArchiveHeapTestClass flag\n+ * @requires vm.cds.write.archived.java.heap\n+ * @modules java.base\/sun.invoke.util java.logging\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build ArchiveHeapTestClass Hello pkg.ClassInPackage\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar boot.jar\n+ *             CDSTestClassA CDSTestClassA$XX CDSTestClassA$YY\n+ *             CDSTestClassB CDSTestClassC CDSTestClassD\n+ *             CDSTestClassE CDSTestClassF CDSTestClassG\n+ *             pkg.ClassInPackage\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar Hello\n+ * @run driver ArchiveHeapTestClass\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ArchiveHeapTestClass {\n+    static final String bootJar = ClassFileInstaller.getJarPath(\"boot.jar\");\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String[] appClassList = {\"Hello\"};\n+\n+    static final String CDSTestClassA_name = CDSTestClassA.class.getName();\n+    static final String CDSTestClassB_name = CDSTestClassB.class.getName();\n+    static final String CDSTestClassC_name = CDSTestClassC.class.getName();\n+    static final String CDSTestClassD_name = CDSTestClassD.class.getName();\n+    static final String CDSTestClassE_name = CDSTestClassE.class.getName();\n+    static final String CDSTestClassF_name = CDSTestClassF.class.getName();\n+    static final String CDSTestClassG_name = CDSTestClassG.class.getName();\n+    static final String ClassInPackage_name = pkg.ClassInPackage.class.getName().replace('.', '\/');\n+    static final String ARCHIVE_TEST_FIELD_NAME = \"archivedObjects\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (Platform.isDebugBuild()) {\n+            testDebugBuild();\n+        } else {\n+            testProductBuild();\n+        }\n+    }\n+\n+    static OutputAnalyzer dumpHelloOnly(String... extraOpts) throws Exception {\n+        return TestCommon.dump(appJar, appClassList, extraOpts);\n+    }\n+\n+    static OutputAnalyzer dumpBootAndHello(String bootClass, String... extraOpts) throws Exception {\n+        String classlist[] = TestCommon.concat(appClassList, bootClass);\n+        extraOpts = TestCommon.concat(extraOpts,\n+                                      \"-Xbootclasspath\/a:\" + bootJar,\n+                                      \"-XX:ArchiveHeapTestClass=\" + bootClass,\n+                                      \"-Xlog:cds+heap\");\n+        return TestCommon.dump(appJar, classlist, extraOpts);\n+    }\n+\n+    static int caseNum = 0;\n+    static void testCase(String s) {\n+        System.out.println(\"==================================================\");\n+        System.out.println(\" Test \" + (++caseNum) + \": \" + s);\n+    }\n+\n+    static void mustContain(OutputAnalyzer output, String... expectStrs) throws Exception {\n+        for (String s : expectStrs) {\n+            output.shouldContain(s);\n+        }\n+    }\n+\n+    static void mustFail(OutputAnalyzer output, String... expectStrs) throws Exception {\n+        mustContain(output, expectStrs);\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n+    static void mustSucceed(OutputAnalyzer output, String... expectStrs) throws Exception {\n+        mustContain(output, expectStrs);\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testDebugBuild() throws Exception {\n+        OutputAnalyzer output;\n+\n+        testCase(\"Simple positive case\");\n+        output = dumpBootAndHello(CDSTestClassA_name);\n+        mustSucceed(output, CDSTestClassA.getOutput()); \/\/ make sure <clinit> is executed\n+        output.shouldMatch(\"warning.*cds.*Loading ArchiveHeapTestClass \" + CDSTestClassA_name);\n+        output.shouldMatch(\"warning.*cds.*Initializing ArchiveHeapTestClass \" + CDSTestClassA_name);\n+        output.shouldContain(\"Archived field \" + CDSTestClassA_name + \"::\" + ARCHIVE_TEST_FIELD_NAME);\n+        output.shouldMatch(\"Archived object klass CDSTestClassA .*\\\\[LCDSTestClassA;\");\n+        output.shouldMatch(\"Archived object klass CDSTestClassA .*CDSTestClassA\\\\$YY\");\n+\n+        TestCommon.run(\"-Xbootclasspath\/a:\" + bootJar, \"-cp\", appJar, \"-Xlog:cds+heap\", CDSTestClassA_name)\n+            .assertNormalExit(CDSTestClassA.getOutput(),\n+                              \"resolve subgraph \" + CDSTestClassA_name);\n+\n+        testCase(\"Class doesn't exist\");\n+        output = dumpHelloOnly(\"-XX:ArchiveHeapTestClass=NoSuchClass\");\n+        mustFail(output, \"Fail to initialize archive heap: NoSuchClass cannot be loaded\");\n+\n+        testCase(\"Class doesn't exist (objarray)\");\n+        output = dumpHelloOnly(\"-XX:ArchiveHeapTestClass=[LNoSuchClass;\");\n+        mustFail(output, \"Fail to initialize archive heap: [LNoSuchClass; cannot be loaded\");\n+\n+        testCase(\"Not an instance klass\");\n+        output = dumpHelloOnly(\"-XX:ArchiveHeapTestClass=[Ljava\/lang\/Object;\");\n+        mustFail(output, \"Fail to initialize archive heap: [Ljava\/lang\/Object; is not an instance class\");\n+\n+        testCase(\"Not in boot loader\");\n+        output = dumpHelloOnly(\"-XX:ArchiveHeapTestClass=Hello\");\n+        mustFail(output, \"Fail to initialize archive heap: Hello cannot be loaded by the boot loader\");\n+\n+        testCase(\"Not from unnamed module\");\n+        output = dumpHelloOnly(\"-XX:ArchiveHeapTestClass=java\/lang\/Object\");\n+        mustFail(output, \"ArchiveHeapTestClass java\/lang\/Object is not in unnamed module\");\n+\n+        testCase(\"Not from unnamed package\");\n+        output = dumpBootAndHello(ClassInPackage_name);\n+        mustFail(output, \"ArchiveHeapTestClass pkg\/ClassInPackage is not in unnamed package\");\n+\n+        testCase(\"Field not found\");\n+        output = dumpBootAndHello(CDSTestClassB_name);\n+        mustFail(output, \"Unable to find the static T_OBJECT field CDSTestClassB::archivedObjects\");\n+\n+        testCase(\"Not a static field\");\n+        output = dumpBootAndHello(CDSTestClassC_name);\n+        mustFail(output, \"Unable to find the static T_OBJECT field CDSTestClassC::archivedObjects\");\n+\n+        testCase(\"Not a T_OBJECT field\");\n+        output = dumpBootAndHello(CDSTestClassD_name);\n+        mustFail(output, \"Unable to find the static T_OBJECT field CDSTestClassD::archivedObjects\");\n+\n+        testCase(\"Use a disallowed class: in unnamed module but not in unname package\");\n+        output = dumpBootAndHello(CDSTestClassE_name);\n+        mustFail(output, \"Class pkg.ClassInPackage not allowed in archive heap\");\n+\n+        testCase(\"Use a disallowed class: not in java.base module\");\n+        output = dumpBootAndHello(CDSTestClassF_name);\n+        mustFail(output, \"Class java.util.logging.Level not allowed in archive heap\");\n+\n+        if (false) { \/\/ JDK-8293187\n+            testCase(\"sun.invoke.util.Wrapper\");\n+            output = dumpBootAndHello(CDSTestClassG_name);\n+            mustSucceed(output);\n+        }\n+    }\n+\n+    static void testProductBuild() throws Exception {\n+        OutputAnalyzer output;\n+\n+        output = dumpHelloOnly(\"-XX:ArchiveHeapTestClass=NoSuchClass\");\n+        mustFail(output, \"VM option 'ArchiveHeapTestClass' is develop and is available only in debug version of VM.\");\n+    }\n+}\n+\n+class CDSTestClassA {\n+    static final String output = \"CDSTestClassA.<clinit> was executed\";\n+    static Object[] archivedObjects;\n+    static {\n+        archivedObjects = new Object[5];\n+        archivedObjects[0] = output;\n+        archivedObjects[1] = new CDSTestClassA[0];\n+        archivedObjects[2] = new YY();\n+        archivedObjects[3] = new int[0];\n+        archivedObjects[4] = new int[2][2];\n+        System.out.println(output);\n+        System.out.println(\"CDSTestClassA   module  = \" + CDSTestClassA.class.getModule());\n+        System.out.println(\"CDSTestClassA   package = \" + CDSTestClassA.class.getPackage());\n+        System.out.println(\"CDSTestClassA[] module  = \" + archivedObjects[1].getClass().getModule());\n+        System.out.println(\"CDSTestClassA[] package = \" + archivedObjects[1].getClass().getPackage());\n+    }\n+\n+    static String getOutput() {\n+        return output;\n+    }\n+\n+    public static void main(String args[]) {\n+        if (CDSTestClassA.class.getModule().isNamed()) {\n+            throw new RuntimeException(\"CDSTestClassA must be in unnamed module\");\n+        }\n+        if (CDSTestClassA.class.getPackage() != null) {\n+            throw new RuntimeException(\"CDSTestClassA must be in null package\");\n+        }\n+        if (archivedObjects[1].getClass().getModule().isNamed()) {\n+            throw new RuntimeException(\"CDSTestClassA[] must be in unnamed module\");\n+        }\n+        if (archivedObjects[1].getClass().getPackage() != null) {\n+            throw new RuntimeException(\"CDSTestClassA[] must be in null package\");\n+        }\n+        XX.doit();\n+        YY.doit();\n+    }\n+\n+    \/\/ This is an inner class that has NOT been archived.\n+    static class XX {\n+        static void doit() {\n+            System.out.println(\"XX module  = \" + XX.class.getModule());\n+            System.out.println(\"XX package = \" + XX.class.getPackage());\n+\n+            if (XX.class.getModule().isNamed()) {\n+                throw new RuntimeException(\"XX must be in unnamed module\");\n+            }\n+            if (XX.class.getPackage() != null) {\n+                throw new RuntimeException(\"XX must be in null package\");\n+            }\n+        }\n+    }\n+\n+    \/\/ This is an inner class that HAS been archived.\n+    static class YY {\n+        static void doit() {\n+            System.out.println(\"YY module  = \" + YY.class.getModule());\n+            System.out.println(\"YY package = \" + YY.class.getPackage());\n+\n+            if (YY.class.getModule().isNamed()) {\n+                throw new RuntimeException(\"YY must be in unnamed module\");\n+            }\n+            if (YY.class.getPackage() != null) {\n+                throw new RuntimeException(\"YY must be in null package\");\n+            }\n+        }\n+    }\n+}\n+\n+class CDSTestClassB {\n+    \/\/ No field named \"archivedObjects\"\n+}\n+\n+class CDSTestClassC {\n+    Object[] archivedObjects; \/\/ Not a static field\n+}\n+\n+class CDSTestClassD {\n+    static int archivedObjects; \/\/ Not an int field\n+}\n+\n+class CDSTestClassE {\n+    static Object[] archivedObjects;\n+    static {\n+        \/\/ Not in unnamed package of unnamed module\n+        archivedObjects = new Object[1];\n+        archivedObjects[0] = new pkg.ClassInPackage();\n+    }\n+}\n+\n+class CDSTestClassF {\n+    static Object[] archivedObjects;\n+    static {\n+        \/\/ Not in java.base\n+        archivedObjects = new Object[1];\n+        archivedObjects[0] = java.util.logging.Level.OFF;\n+    }\n+}\n+\n+class CDSTestClassG {\n+    static Object[] archivedObjects;\n+    static {\n+        \/\/ Not in java.base\n+        archivedObjects = new Object[1];\n+        archivedObjects[0] = sun.invoke.util.Wrapper.BOOLEAN;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+package pkg;\n+\n+public class ClassInPackage {\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/pkg\/ClassInPackage.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"}]}