{"files":[{"patch":"@@ -213,17 +213,1 @@\n-  if (!_needs_return_buffer) {\n-    \/\/ Unpack native results.\n-    switch (_ret_bt) {\n-      case T_BOOLEAN: __ c2bool(r0);                     break;\n-      case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;\n-      case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;\n-      case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;\n-      case T_INT    : __ sbfx(r0, r0, 0, 32);            break;\n-      case T_DOUBLE :\n-      case T_FLOAT  :\n-        \/\/ Result is in v0 we'll save as needed\n-        break;\n-      case T_VOID: break;\n-      case T_LONG: break;\n-      default       : ShouldNotReachHere();\n-    }\n-  } else {\n+  if (_needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -214,18 +214,1 @@\n-  if (!_needs_return_buffer) {\n-    \/\/ FIXME: this assumes we return in rax\/xmm0, which might not be the case\n-    \/\/ Unpack native results.\n-    switch (_ret_bt) {\n-      case T_BOOLEAN: __ c2bool(rax);            break;\n-      case T_CHAR   : __ movzwl(rax, rax);       break;\n-      case T_BYTE   : __ sign_extend_byte (rax); break;\n-      case T_SHORT  : __ sign_extend_short(rax); break;\n-      case T_INT    : \/* nothing to do *\/        break;\n-      case T_DOUBLE :\n-      case T_FLOAT  :\n-        \/\/ Result is in xmm0 we'll save as needed\n-        break;\n-      case T_VOID: break;\n-      case T_LONG: break;\n-      default       : ShouldNotReachHere();\n-    }\n-  } else {\n+  if (_needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.CharBuffer;\n@@ -944,0 +945,4 @@\n+     * @throws IllegalArgumentException if the provided {@code buffer} is a heap buffer but is not backed by an array.\n+     *                                  For example, buffers directly or indirectly obtained via\n+     *                                  ({@link CharBuffer#wrap(CharSequence)} or {@link CharBuffer#wrap(char[], int, int)}\n+     *                                  are not backed by an array.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -472,1 +472,0 @@\n-        long bbAddress = NIO_ACCESS.getBufferAddress(bb);\n@@ -474,0 +473,4 @@\n+        if (!bb.isDirect() && base == null) {\n+            throw new IllegalArgumentException(\"The provided heap buffer is not backed by an array.\");\n+        }\n+        long bbAddress = NIO_ACCESS.getBufferAddress(bb);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,1 +84,3 @@\n-        if (state == 0 || state - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n+        int asyncCount = (int)ASYNC_RELEASE_COUNT.getVolatile(this);\n+        if ((state == 0 && asyncCount == 0)\n+                || ((state - asyncCount) == 0)) {\n@@ -87,1 +89,1 @@\n-            throw alreadyAcquired(state);\n+            throw alreadyAcquired(state - asyncCount);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n-        emitStore(Object.class, nextScopeLocal); \/\/ store off one to release later\n+        \/\/ call acquire first here. So that if it fails, we don't call release\n@@ -520,0 +520,1 @@\n+        emitStore(Object.class, nextScopeLocal); \/\/ store off one to release later\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}