{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import java.util.Objects;\n-\n@@ -34,6 +32,1 @@\n- * An arena allocates and manages the lifecycle of native segments.\n- * <p>\n- * An arena is a {@linkplain AutoCloseable closeable} segment allocator that has a bounded {@linkplain MemorySession memory session}.\n- * The arena's session starts when the arena is created, and ends when the arena is {@linkplain #close() closed}.\n- * All native segments {@linkplain #allocate(long, long) allocated} by the arena are associated with its session, and\n- * cannot be accessed after the arena is closed.\n+ * An arena controls the lifecycle of one or more memory segments, providing both flexible allocation and timely deallocation.\n@@ -41,1 +34,14 @@\n- * An arena is extremely useful when interacting with foreign code, as shown below:\n+ * An arena has a {@linkplain #scope() scope}, called the arena scope. When the arena is {@linkplain #close() closed},\n+ * the arena scope becomes not {@linkplain SegmentScope#isAlive() alive}. As a result, all the\n+ * segments associated with the arena scope are invalidated, safely and atomically, their backing memory regions are\n+ * deallocated (where applicable) and can no longer be accessed after the arena is closed:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n+ *     ...\n+ * } \/\/ memory released here\n+ *}\n+ *\n+ * Furthermore, an arena is a {@link SegmentAllocator}. All the segments {@linkplain #allocate(long, long) allocated} by the\n+ * arena are associated with the arena scope. This makes arenas extremely useful when interacting with foreign code, as shown below:\n@@ -47,1 +53,1 @@\n- *     MemorySegment upcallStub = linker.upcallStub(handle, desc, arena.session());\n+ *     MemorySegment upcallStub = linker.upcallStub(handle, desc, arena.scope());\n@@ -55,4 +61,4 @@\n- * <em>after<\/em> the arena has been closed. The costs associated with maintaining this safety invariant can vary greatly,\n- * depending on how many threads have access to the memory segments allocated by the arena. For instance, if an arena\n- * is created and closed by one thread, and the segments associated with it are only ever accessed by that very same thread,\n- * then ensuring correctness is simple.\n+ * <em>after<\/em> the arena has been closed. The cost of providing this guarantee varies based on the\n+ * number of threads that have access to the memory segments allocated by the arena. For instance, if an arena\n+ * is always created and closed by one thread, and the memory segments associated with the arena's scope are always\n+ * accessed by that same thread, then ensuring correctness is trivial.\n@@ -61,5 +67,4 @@\n- * by a thread other than the accessing thread, the situation is much more complex. For instance, a segment might be accessed\n- * <em>while<\/em> the associated arena is being closed, concurrently, by another thread. Even in this extreme case,\n- * arenas must provide strong temporal safety guarantees, but doing so can incur in a higher performance impact.\n- * For this reason, arenas can be divided into two categories: <em>thread-confined<\/em> arenas,\n- * and <em>shared<\/em> arenas.\n+ * by a thread other than the accessing thread, then ensuring correctness is much more complex. For example, a segment\n+ * allocated with the arena might be accessed <em>while<\/em> another thread attempts, concurrently, to close the arena.\n+ * To provide the strong temporal safety guarantee without forcing every client, even simple ones, to incur a performance\n+ * impact, arenas are divided into <em>thread-confined<\/em> arenas, and <em>shared<\/em> arenas.\n@@ -69,2 +74,2 @@\n- * The segments created by a confined arena can only be {@linkplain MemorySession#isAccessibleBy(Thread) accessed}\n- * by the thread that created the arena. Moreover, any attempt to close the confined arena from a thread other than the owner thread will\n+ * The segments created by a confined arena can only be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed}\n+ * by the owner thread. Moreover, any attempt to close the confined arena from a thread other than the owner thread will\n@@ -73,2 +78,2 @@\n- * Shared memory sessions, on the other hand, have no owner thread. The segments created by a shared arena\n- * can be {@linkplain MemorySession#isAccessibleBy(Thread) accessed} by multiple threads. This might be useful when\n+ * Shared arenas, on the other hand, have no owner thread. The segments created by a shared arena\n+ * can be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by multiple threads. This might be useful when\n@@ -84,2 +89,2 @@\n-     * Creates a native memory segment with the given size (in bytes) and alignment constraint (in bytes).\n-     * The returned segment is associated with the arena's memory session.\n+     * Returns a native memory segment with the given size (in bytes) and alignment constraint (in bytes).\n+     * The returned segment is associated with the arena scope.\n@@ -92,3 +97,5 @@\n-     * {@snippet lang=java :\n-     * MemorySegment.allocateNative(bytesSize, byteAlignment, session());\n-     * }\n+     * {@snippet lang = java:\n+     * MemorySegment.allocateNative(bytesSize, byteAlignment, scope());\n+     *}\n+     * More generally implementations of this method must return a native method featuring the requested size,\n+     * and that is compatible with the provided alignment constraint.\n@@ -101,1 +108,1 @@\n-     * @throws IllegalStateException if the session associated with this arena is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the arena has already been {@linkplain #close() closed}.\n@@ -103,2 +110,2 @@\n-     * such that {@code session.isAccessibleBy(T) == false}.\n-     * @see MemorySegment#allocateNative(long, long, MemorySession)\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * @see MemorySegment#allocateNative(long, long, SegmentScope)\n@@ -108,1 +115,1 @@\n-        return MemorySegment.allocateNative(byteSize, byteAlignment, session());\n+        return MemorySegment.allocateNative(byteSize, byteAlignment, scope());\n@@ -112,1 +119,1 @@\n-     * {@return the session associated with this arena}\n+     * {@return the arena scope}\n@@ -114,1 +121,1 @@\n-    MemorySession session();\n+    SegmentScope scope();\n@@ -117,1 +124,1 @@\n-     * Closes this arena. If this method completes normally, the arena session becomes not {@linkplain MemorySession#isAlive() alive},\n+     * Closes this arena. If this method completes normally, the arena scope becomes not {@linkplain SegmentScope#isAlive() alive},\n@@ -119,3 +126,3 @@\n-     * segments associated with that memory session are also released.\n-     * @throws IllegalStateException if the session associated with this arena is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws IllegalStateException if this session is {@linkplain MemorySession#whileAlive(Runnable) kept alive} by another client.\n+     * segments associated with that scope are also released.\n+     * @throws IllegalStateException if the arena has already been {@linkplain #close() closed}.\n+     * @throws IllegalStateException if the arena scope is {@linkplain SegmentScope#whileAlive(Runnable) kept alive}.\n@@ -135,2 +142,1 @@\n-     * Creates a new confined arena.\n-     * @return a new confined arena.\n+     * {@return a new confined arena}\n@@ -139,1 +145,1 @@\n-        return makeArena(MemorySessionImpl.createConfined(Thread.currentThread()));\n+        return MemorySessionImpl.createConfined(Thread.currentThread()).asArena();\n@@ -143,2 +149,1 @@\n-     * Creates a new shared arena.\n-     * @return a new shared arena.\n+     * {@return a new shared arena}\n@@ -147,22 +152,1 @@\n-        return makeArena(MemorySessionImpl.createShared());\n-    }\n-\n-    private static Arena makeArena(MemorySessionImpl sessionImpl) {\n-        return new Arena() {\n-            @Override\n-            public MemorySession session() {\n-                return sessionImpl;\n-            }\n-\n-            @Override\n-            public void close() {\n-                sessionImpl.close();\n-            }\n-\n-            @Override\n-            public boolean isCloseableBy(Thread thread) {\n-                Objects.requireNonNull(thread);\n-                return sessionImpl.ownerThread() == null || \/\/ shared\n-                        sessionImpl.ownerThread() == thread;\n-            }\n-        };\n+        return MemorySessionImpl.createShared().asArena();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":49,"deletions":65,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stubs}.\n+ * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stubs}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stubs}.<\/li>\n+ * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stubs}.<\/li>\n@@ -83,1 +83,1 @@\n- * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) Creating an upcall stub} requires a method\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) Creating an upcall stub} requires a method\n@@ -91,1 +91,1 @@\n- * downcall method handles and, they are released via their associated {@linkplain MemorySession memory session}.\n+ * downcall method handles and, they are released via their associated {@linkplain SegmentScope scope}.\n@@ -103,1 +103,1 @@\n- *     <li>The memory session of {@code A} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n+ *     <li>The scope of {@code A} is {@linkplain SegmentScope#isAlive() alive}. Otherwise, the invocation throws\n@@ -105,1 +105,1 @@\n- *     <li>The invocation occurs in a thread {@code T} such that {@code A.session().isAccessibleBy(T) == true}.\n+ *     <li>The invocation occurs in a thread {@code T} such that {@code A.scope().isAccessibleBy(T) == true}.\n@@ -107,1 +107,1 @@\n- *     <li>The memory session of {@code A} is {@linkplain MemorySession#whileAlive(Runnable) kept alive} during the invocation.<\/li>\n+ *     <li>The scope of {@code A} is {@linkplain SegmentScope#whileAlive(Runnable) kept alive} during the invocation.<\/li>\n@@ -111,1 +111,1 @@\n- * the {@linkplain MemorySession#global() global session}. Under normal conditions, the size of the returned segment is {@code 0}.\n+ * the {@linkplain SegmentScope#global() global scope}. Under normal conditions, the size of the returned segment is {@code 0}.\n@@ -124,1 +124,1 @@\n- * is a native segment associated with the {@linkplain MemorySession#global() global session}.\n+ * is a native segment associated with the {@linkplain SegmentScope#global() global scope}.\n@@ -157,1 +157,1 @@\n-     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub}.\n+     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stub}.\n@@ -236,2 +236,2 @@\n-     * Creates a stub which can be passed to other foreign functions as a function pointer, with the given\n-     * memory session. Calling such a function pointer from foreign code will result in the execution of the provided\n+     * Creates a stub which can be passed to other foreign functions as a function pointer, associated with the given\n+     * scope. Calling such a function pointer from foreign code will result in the execution of the provided\n@@ -241,2 +241,2 @@\n-     * the provided memory session. As such, the corresponding upcall stub will be deallocated\n-     * when the session becomes not {@linkplain MemorySession#isAlive() alive}.\n+     * the provided scope. As such, the corresponding upcall stub will be deallocated\n+     * when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n@@ -252,1 +252,1 @@\n-     * @param session the upcall stub memory session.\n+     * @param scope the scope associated with the returned upcall stub segment.\n@@ -257,1 +257,1 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n@@ -259,1 +259,1 @@\n-     * such that {@code session.isAccessibleBy(T) == false}.\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -261,1 +261,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n- * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, MemorySession)}\n+ * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, SegmentScope)}\n@@ -69,1 +69,1 @@\n- * {@link FileChannel#map(MapMode, long, long, MemorySession) mapping} a file into a new off-heap region\n+ * {@link FileChannel#map(MapMode, long, long, SegmentScope) mapping} a file into a new off-heap region\n@@ -94,2 +94,2 @@\n- * (as in {@link MemorySegment#allocateNative(long, MemorySession)}) or derived from a {@link MemoryLayout}\n- * (as in {@link MemorySegment#allocateNative(MemoryLayout, MemorySession)}). The size of a memory segment is typically\n+ * (as in {@link MemorySegment#allocateNative(long, SegmentScope)}) or derived from a {@link MemoryLayout}\n+ * (as in {@link MemorySegment#allocateNative(MemoryLayout, SegmentScope)}). The size of a memory segment is typically\n@@ -102,1 +102,1 @@\n- * Every memory segment is associated with a {@linkplain MemorySession memory session}. This ensures that access operations\n+ * Every memory segment is associated with a {@linkplain SegmentScope scope}. This ensures that access operations\n@@ -104,1 +104,1 @@\n- * (e.g., after the memory session associated with the accessed memory segment is no longer {@linkplain MemorySession#isAlive() alive}).\n+ * (e.g., after the scope associated with the accessed memory segment is no longer {@linkplain SegmentScope#isAlive() alive}).\n@@ -107,3 +107,4 @@\n- * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated memory\n- * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads; if it is\n- * associated with a confined session, it can only be accessed by the thread which owns the memory session.\n+ * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated\n+ * scope; that is, if the segment is the {@linkplain SegmentScope#global() global scope} or an {@linkplain SegmentScope#auto() automatic scope},\n+ * it can be accessed by multiple threads. If the segment is associatd with an arena scope, then it can only be\n+ * accessed compatibly with the <a href=\"Arena.html#thread-confinement\">arena confinement characteristics<\/a>.\n@@ -174,3 +175,3 @@\n- * {@code slice} segment will result in an exception. The {@linkplain MemorySession temporal bounds} of the original segment\n- * are inherited by its slices; that is, when the memory session associated with {@code segment} ends, {@code slice}\n- * will also be become inaccessible.\n+ * {@code slice} segment will result in an exception. The {@linkplain SegmentScope temporal bounds} of the original segment\n+ * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@link SegmentScope#isAlive()},\n+ * {@code slice} will also be become inaccessible.\n@@ -180,2 +181,2 @@\n- * (to do this, the segment has to be associated with a shared memory session). The following code can be used to sum all int\n- * values in a memory segment in parallel:\n+ * (to do this, the segment has to be associated with a scope that allows {@linkplain SegmentScope#isAccessibleBy(Thread) access}\n+ * from multiple threads). The following code can be used to sum all int values in a memory segment in parallel:\n@@ -243,2 +244,2 @@\n- * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, MemorySession)}\n- * or {@link #allocateNative(MemoryLayout, MemorySession)}. These factories ensure that the off-heap region of memory backing\n+ * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, SegmentScope)}\n+ * or {@link #allocateNative(MemoryLayout, SegmentScope)}. These factories ensure that the off-heap region of memory backing\n@@ -357,1 +358,1 @@\n- * {@link MemorySession#global() global} memory session. This is because the Java runtime, in addition to having no insight\n+ * {@link SegmentScope#global() global scope}. This is because the Java runtime, in addition to having no insight\n@@ -359,2 +360,2 @@\n- * into the lifetime intended for said region of memory by the foreign function that allocated it. The global memory\n- * session ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n+ * into the lifetime intended for said region of memory by the foreign function that allocated it. The global scope\n+ * ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n@@ -363,1 +364,1 @@\n- * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) obtain}\n+ * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope) obtain}\n@@ -367,1 +368,1 @@\n- * MemorySession session = ... \/\/ initialize a memory session\n+ * SegmentScope scope = ... \/\/ obtains a scope\n@@ -369,1 +370,1 @@\n- * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, session); \/\/ create new segment (size = 4)\n+ * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, scope); \/\/ create new segment (size = 4)\n@@ -383,1 +384,1 @@\n- * Both {@link #ofAddress(long, long, MemorySession)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n+ * Both {@link #ofAddress(long, long, SegmentScope)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n@@ -420,1 +421,1 @@\n-     * are associated with the same memory session as this segment.\n+     * are associated with the same scope as that associated with this segment.\n@@ -451,1 +452,1 @@\n-     * {@return the memory session associated with this memory segment}\n+     * {@return the scope associated with this memory segment}\n@@ -453,1 +454,1 @@\n-    MemorySession session();\n+    SegmentScope scope();\n@@ -508,1 +509,1 @@\n-     * created e.g. using the {@link #allocateNative(long, MemorySession)} (and related) factory, or by\n+     * created e.g. using the {@link #allocateNative(long, SegmentScope)} (and related) factory, or by\n@@ -516,1 +517,1 @@\n-     * {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)} factory, or by\n+     * {@link FileChannel#map(FileChannel.MapMode, long, long, SegmentScope)} factory, or by\n@@ -582,2 +583,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -585,1 +586,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -601,2 +602,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -604,3 +605,3 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code src} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code src} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -608,1 +609,1 @@\n-     * such that {@code src.session().isAccessibleBy(T) == false}.\n+     * such that {@code src.scope().isAccessibleBy(T) == false}.\n@@ -635,2 +636,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -638,3 +639,3 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code other} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code other} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -642,1 +643,1 @@\n-     * such that {@code other.session().isAccessibleBy(T) == false}.\n+     * such that {@code other.scope().isAccessibleBy(T) == false}.\n@@ -667,2 +668,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -670,1 +671,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -684,2 +685,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -687,1 +688,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -701,2 +702,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -704,1 +705,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -730,2 +731,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -733,1 +734,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -753,4 +754,3 @@\n-     * after the memory session associated with this segment is no longer {@linkplain MemorySession#isAlive() alive}, will\n-     * throw an {@link IllegalStateException}. Similarly, accessing the returned buffer from a thread other than\n-     * the thread {@linkplain MemorySession#isAccessibleBy(Thread) owning} this segment's memory session will throw\n-     * a {@link WrongThreadException}.\n+     * after the scope associated with this segment is no longer {@linkplain SegmentScope#isAlive() alive}, will\n+     * throw an {@link IllegalStateException}. Similarly, accessing the returned buffer from a thread {@code T}\n+     * such that {@code scope().isAccessible(T) == false} will throw a {@link WrongThreadException}.\n@@ -758,2 +758,2 @@\n-     * If this segment is associated with a confined memory session, calling read\/write I\/O operations on the resulting buffer\n-     * might result in an unspecified exception being thrown. Examples of such problematic operations are\n+     * If this segment is associated with a scope that can only be accessed from a single thread, calling read\/write I\/O\n+     * operations on the resulting buffer might result in an unspecified exception being thrown. Examples of such problematic operations are\n@@ -778,2 +778,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -781,1 +781,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -792,2 +792,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -795,1 +795,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -806,2 +806,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -809,1 +809,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -820,2 +820,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -823,1 +823,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -834,2 +834,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -837,1 +837,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -848,2 +848,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -851,1 +851,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -862,2 +862,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -865,1 +865,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -884,2 +884,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -887,1 +887,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -909,2 +909,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -912,1 +912,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -927,2 +927,1 @@\n-     * The memory session {@code S} associated with the returned segment is\n-     * computed as follows:\n+     * The scope {@code S} associated with the returned segment is computed as follows:\n@@ -930,1 +929,1 @@\n-     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose session\n+     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose scope\n@@ -932,3 +931,2 @@\n-     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain MemorySession#global() global session}; or\n-     *     <li>if the buffer is a direct buffer, then {@code S} is an\n-     *     {@linkplain MemorySession#implicit() implicitly-managed} memory session that keeps the buffer reachable.\n+     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain SegmentScope#global() global scope}; or\n+     *     <li>if the buffer is a direct buffer, then {@code S} is a scope that is always alive and which keeps the buffer reachable.\n@@ -952,1 +950,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -964,1 +962,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -976,1 +974,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -988,1 +986,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -1000,1 +998,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -1012,1 +1010,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -1024,1 +1022,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -1041,1 +1039,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}.\n@@ -1056,1 +1054,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}.\n@@ -1060,1 +1058,1 @@\n-     * ofAddress(address, byteSize, MemorySession.global());\n+     * ofAddress(address, byteSize, SegmentScope.global());\n@@ -1077,1 +1075,1 @@\n-        return MemorySegment.ofAddress(address, byteSize, MemorySession.global());\n+        return MemorySegment.ofAddress(address, byteSize, SegmentScope.global());\n@@ -1081,1 +1079,1 @@\n-     * Creates a native segment with the given size, address, and memory session.\n+     * Creates a native segment with the given size, address, and scope.\n@@ -1087,1 +1085,1 @@\n-     * provided memory session.\n+     * provided scope.\n@@ -1091,1 +1089,1 @@\n-     * ofAddress(address, byteSize, session, null);\n+     * ofAddress(address, byteSize, scope, null);\n@@ -1096,2 +1094,2 @@\n-     * @param session the native segment memory session.\n-     * @return a native segment with the given address, size and memory session.\n+     * @param scope the scope associated with the returned native segment.\n+     * @return a native segment with the given address, size and scope.\n@@ -1099,1 +1097,1 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n@@ -1101,1 +1099,1 @@\n-     * such that {@code session.isAccessibleBy(T) == false}.\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1108,1 +1106,1 @@\n-    static MemorySegment ofAddress(long address, long byteSize, MemorySession session) {\n+    static MemorySegment ofAddress(long address, long byteSize, SegmentScope scope) {\n@@ -1110,1 +1108,1 @@\n-        Objects.requireNonNull(session);\n+        Objects.requireNonNull(scope);\n@@ -1112,1 +1110,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session, null);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, scope, null);\n@@ -1116,1 +1114,1 @@\n-     * Creates a native segment with the given size, address, and memory session.\n+     * Creates a native segment with the given size, address, and scope.\n@@ -1122,1 +1120,1 @@\n-     * provided memory session.\n+     * provided scope.\n@@ -1124,1 +1122,1 @@\n-     * The provided cleanup action (if any) will be invoked when the session becomes not {@linkplain MemorySession#isAlive() alive}.\n+     * The provided cleanup action (if any) will be invoked when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n@@ -1138,1 +1136,1 @@\n-     * @param session the native segment memory session.\n+     * @param scope the scope associated with the returned native segment.\n@@ -1140,1 +1138,1 @@\n-     * @return a native segment with the given address, size and memory session.\n+     * @return a native segment with the given address, size and scope.\n@@ -1142,1 +1140,1 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n@@ -1144,1 +1142,1 @@\n-     * such that {@code session.isAccessibleBy(T) == false}.\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1150,1 +1148,1 @@\n-    static MemorySegment ofAddress(long address, long byteSize, MemorySession session, Runnable cleanupAction) {\n+    static MemorySegment ofAddress(long address, long byteSize, SegmentScope scope, Runnable cleanupAction) {\n@@ -1152,1 +1150,1 @@\n-        Objects.requireNonNull(session);\n+        Objects.requireNonNull(scope);\n@@ -1154,1 +1152,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session, cleanupAction);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, scope, cleanupAction);\n@@ -1158,1 +1156,1 @@\n-     * Creates a native segment with the given layout and memory session.\n+     * Creates a native segment with the given layout and scope.\n@@ -1161,2 +1159,2 @@\n-     * provided memory session. The off-heap memory region is deallocated when the session becomes not\n-     * {@linkplain MemorySession#isAlive() alive}. If the session has been obtained using an {@link Arena},\n+     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n@@ -1164,3 +1162,3 @@\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain MemorySession#implicit() implicitly-managed}\n-     * session can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the session is no longer referenced.\n+     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n+     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n+     * automatically released some unspecified time after the scope is no longer referenced.\n@@ -1174,1 +1172,1 @@\n-     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), session);\n+     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), scope);\n@@ -1180,1 +1178,1 @@\n-     * @param session the session to which the returned segment is associated.\n+     * @param scope the scope associated with the returned native segment.\n@@ -1182,1 +1180,1 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n@@ -1184,1 +1182,1 @@\n-     * such that {@code session.isAccessibleBy(T) == false}.\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1186,1 +1184,1 @@\n-    static MemorySegment allocateNative(MemoryLayout layout, MemorySession session) {\n+    static MemorySegment allocateNative(MemoryLayout layout, SegmentScope scope) {\n@@ -1188,2 +1186,2 @@\n-        Objects.requireNonNull(session);\n-        return allocateNative(layout.byteSize(), layout.byteAlignment(), session);\n+        Objects.requireNonNull(scope);\n+        return allocateNative(layout.byteSize(), layout.byteAlignment(), scope);\n@@ -1193,1 +1191,1 @@\n-     * Creates a native segment with the given size (in bytes) and memory session.\n+     * Creates a native segment with the given size (in bytes) and scope.\n@@ -1195,3 +1193,3 @@\n-     * The lifetime of the off-heap region of memory associated with the returned native segment is determined by the\n-     * provided memory session. The off-heap memory region is deallocated when the session becomes not\n-     * {@linkplain MemorySession#isAlive() alive}. If the session has been obtained using an {@link Arena},\n+     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n+     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n@@ -1199,3 +1197,3 @@\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain MemorySession#implicit() implicitly-managed}\n-     * session can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the session is no longer referenced.\n+     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n+     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n+     * automatically released some unspecified time after the scope is no longer referenced.\n@@ -1209,1 +1207,1 @@\n-     * allocateNative(bytesSize, 1, session);\n+     * allocateNative(bytesSize, 1, scope);\n@@ -1215,1 +1213,1 @@\n-     * @param session the session to which the returned segment is associated.\n+     * @param scope the scope associated with the returned native segment.\n@@ -1218,1 +1216,1 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n@@ -1220,1 +1218,1 @@\n-     * such that {@code session.isAccessibleBy(T) == false}.\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1222,2 +1220,2 @@\n-    static MemorySegment allocateNative(long byteSize, MemorySession session) {\n-        return allocateNative(byteSize, 1, session);\n+    static MemorySegment allocateNative(long byteSize, SegmentScope scope) {\n+        return allocateNative(byteSize, 1, scope);\n@@ -1227,1 +1225,1 @@\n-     * Creates a native segment with the given size (in bytes), alignment (in bytes) and session.\n+     * Creates a native segment with the given size (in bytes), alignment (in bytes) and scope.\n@@ -1229,3 +1227,3 @@\n-     * The lifetime of the off-heap region of memory associated with the returned native segment is determined by the\n-     * provided memory session. The off-heap memory region is deallocated when the session becomes not\n-     * {@linkplain MemorySession#isAlive() alive}. If the session has been obtained using an {@link Arena},\n+     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n+     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n@@ -1233,3 +1231,3 @@\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain MemorySession#implicit() implicitly-managed}\n-     * session can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the session is no longer referenced.\n+     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n+     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n+     * automatically released some unspecified time after the scope is no longer referenced.\n@@ -1245,1 +1243,1 @@\n-     * @param session the scope to which the returned segment is associated.\n+     * @param scope the scope associated with the returned native segment.\n@@ -1249,1 +1247,1 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n@@ -1251,1 +1249,1 @@\n-     * such that {@code session.isAccessibleBy(T) == false}.\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1253,2 +1251,2 @@\n-    static MemorySegment allocateNative(long byteSize, long byteAlignment, MemorySession session) {\n-        Objects.requireNonNull(session);\n+    static MemorySegment allocateNative(long byteSize, long byteAlignment, SegmentScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -1256,1 +1254,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, scope);\n@@ -1282,2 +1280,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1285,3 +1283,3 @@\n-     * such that {@code srcSegment.session().isAccessibleBy(T) == false}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1289,1 +1287,1 @@\n-     * such that {@code dstSegment.session().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n@@ -1329,2 +1327,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1332,3 +1330,3 @@\n-     * such that {@code srcSegment.session().isAccessibleBy(T) == false}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1336,1 +1334,1 @@\n-     * such that {@code dstSegment.session().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n@@ -1382,2 +1380,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1385,1 +1383,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1402,2 +1400,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1405,1 +1403,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1423,2 +1421,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1426,1 +1424,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1443,2 +1441,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1446,1 +1444,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1464,2 +1462,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1467,1 +1465,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1484,2 +1482,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1487,1 +1485,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1505,2 +1503,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1508,1 +1506,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1525,2 +1523,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1528,1 +1526,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1546,2 +1544,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1549,1 +1547,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1566,2 +1564,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1569,1 +1567,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1587,2 +1585,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1590,1 +1588,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1607,2 +1605,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1610,1 +1608,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1628,2 +1626,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1631,1 +1629,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1648,2 +1646,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1651,1 +1649,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1669,2 +1667,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1672,1 +1670,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1689,2 +1687,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1692,1 +1690,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1706,1 +1704,1 @@\n-     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * a native segment, associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions,\n@@ -1713,2 +1711,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1716,1 +1714,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1733,2 +1731,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1736,1 +1734,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1755,2 +1753,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1758,1 +1756,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1779,2 +1777,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1782,1 +1780,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1804,2 +1802,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1807,1 +1805,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1828,2 +1826,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1831,1 +1829,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1853,2 +1851,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1856,1 +1854,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1877,2 +1875,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1880,1 +1878,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1902,2 +1900,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1905,1 +1903,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1926,2 +1924,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1929,1 +1927,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1951,2 +1949,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1954,1 +1952,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1975,2 +1973,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -1978,1 +1976,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2000,2 +1998,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -2003,1 +2001,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2024,2 +2022,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -2027,1 +2025,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2044,1 +2042,1 @@\n-     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * a native segment, associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions,\n@@ -2053,2 +2051,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -2056,1 +2054,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2077,2 +2075,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -2080,1 +2078,1 @@\n-     * such that {@code session().isAccessibleBy(T) == false}.\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2138,2 +2136,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -2141,1 +2139,1 @@\n-     * such that {@code srcSegment.session().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n@@ -2172,2 +2170,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -2175,1 +2173,1 @@\n-     * such that {@code dstSegment.session().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n@@ -2214,2 +2212,2 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -2217,3 +2215,3 @@\n-     * such that {@code srcSegment.session().isAccessibleBy(T) == false}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -2221,1 +2219,1 @@\n-     * such that {@code dstSegment.session().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n@@ -2235,0 +2233,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":285,"deletions":286,"binary":false,"changes":571,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.foreign;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.ref.CleanerFactory;\n-\n-\/**\n- * A memory session models the lifetime of a memory segment.\n- * <p>\n- * Segments associated with a memory session can only be accessed while the session is {@linkplain #isAlive() alive}.\n- * <p>\n- * Memory sessions can be <em>unbounded<\/em> or <em>bounded<\/em>. An unbounded memory session is obtained by calling\n- * {@link MemorySession#global()}. An unbounded memory session is always alive. As a result, the segments associated\n- * with an unbounded session are always accessible and their backing regions of memory are never deallocated. Moreover,\n- * memory segments associated with unbounded sessions can be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n- * <p>\n- * Conversely, a bounded memory session has a start and an end. Bounded memory sessions can be managed either\n- * explicitly, (i.e. using an {@linkplain Arena arena}) or implicitly, by the garbage collector. When a bounded memory\n- * session ends, it is no longer {@linkplain #isAlive() alive}, and subsequent operations\n- * on the segments associated with that bounded session (e.g. {@link MemorySegment#get(ValueLayout.OfInt, long)})\n- * will fail with {@link IllegalStateException}. Moreover, to guarantee temporal safety, access to memory segments associated with\n- * bounded sessions might be <a href=\"Arena.html#thread-confinement\">restricted to specific threads<\/a>.\n- *\n- * <h2 id=\"implicit\">Implicitly-managed bounded memory sessions<\/h2>\n- *\n- * Managing bounded memory session explicitly, using arenas, while powerful, must be used with caution. An arena must always\n- * be closed when no longer in use (this is done using {@link Arena#close()}). A failure to do so\n- * might result in memory leaks. To mitigate this problem, clients can {@linkplain MemorySession#implicit() obtain}\n- * bounded memory sessions that are managed implicitly, by the garbage collector. These sessions end at some unspecified\n- * time <em>after<\/em> they become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n- *\n- * {@snippet lang = java:\n- * MemorySegment segment = MemorySegment.allocateNative(100, MemorySession.implicit());\n- * ...\n- * segment = null; \/\/ the session might end after this instruction\n- *}\n- *\n- * Bounded sessions that are managed implicitly can be useful to allocate long-lived segments, where timely deallocation\n- * is not critical, or in unstructured cases where the boundaries of the lifetime associated with a memory session\n- * cannot be easily determined. As shown in the example above, a memory session that is managed implicitly cannot end\n- * if a program references to one or more segments associated with that session. This means that memory segments associated\n- * with implicitly managed sessions can be safely {@linkplain #isAccessibleBy(Thread) accessed} from multiple threads.\n- *\n- * @implSpec\n- * Implementations of this interface are thread-safe.\n- *\n- * @see Arena\n- * @see MemorySegment\n- * @see SymbolLookup\n- * @see Linker\n- * @see VaList\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface MemorySession permits MemorySessionImpl {\n-\n-    \/**\n-     * {@return {@code true}, if this memory session is alive}\n-     *\/\n-    boolean isAlive();\n-\n-    \/**\n-     * {@return {@code true} if the provided thread can access and\/or obtain segments associated with this memory session}\n-     * @param thread the thread to be tested.\n-     *\/\n-    boolean isAccessibleBy(Thread thread);\n-\n-    \/**\n-     * Runs a critical action while this memory session is kept alive.\n-     * @param action the action to be run.\n-     * @throws IllegalStateException if this session is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code isAccessibleBy(T) == false}.\n-     *\/\n-    void whileAlive(Runnable action);\n-\n-    \/**\n-     * Creates a new bounded memory session that is managed, implicitly, by the garbage collector.\n-     * The segments associated with the returned session can be\n-     * {@linkplain MemorySession#isAccessibleBy(Thread) accessed} by multiple threads.\n-     *\n-     * @return a new bounded memory session that is managed, implicitly, by the garbage collector.\n-     *\/\n-    static MemorySession implicit() {\n-        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner());\n-    }\n-\n-    \/**\n-     * Obtains an unbounded memory session. The segments associated with the returned session can be\n-     * {@linkplain MemorySession#isAccessibleBy(Thread) accessed} by multiple threads.\n-     *\n-     * @return an unbounded memory session.\n-     *\/\n-    static MemorySession global() {\n-        return MemorySessionImpl.GLOBAL;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -49,1 +49,1 @@\n- *     <li>{@link #nativeAllocator(MemorySession)} obtains a simple allocator which can\n+ *     <li>{@link #nativeAllocator(SegmentScope)} obtains a simple allocator which can\n@@ -392,3 +392,3 @@\n-     * Each native segment obtained by the returned allocator is associated with the provided session. As such,\n-     * the off-heap region which backs the returned segment is freed when the session becomes not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * Each native segment obtained by the returned allocator is associated with the provided scope. As such,\n+     * the off-heap region which backs the returned segment is freed when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -405,1 +405,1 @@\n-     *     MemorySegment.allocateNative(byteSize, byteAlignment, session);\n+     *     MemorySegment.allocateNative(byteSize, byteAlignment, scope);\n@@ -407,1 +407,1 @@\n-     * @param session the memory session associated with the segments returned by the native allocator.\n+     * @param scope the scope associated with the segments returned by the native allocator.\n@@ -410,3 +410,3 @@\n-    static SegmentAllocator nativeAllocator(MemorySession session) {\n-        Objects.requireNonNull(session);\n-        return (MemorySessionImpl)session;\n+    static SegmentAllocator nativeAllocator(SegmentScope scope) {\n+        Objects.requireNonNull(scope);\n+        return (MemorySessionImpl)scope;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.ref.CleanerFactory;\n+\n+\/**\n+ * A segment scope controls access to a memory segment.\n+ * <p>\n+ * A memory segment can only be accessed while its scope is {@linkplain #isAlive() alive}. Moreoever,\n+ * depending on how the segment scope has been obtained, access might additionally be\n+ * <a href=\"Arena.html#thread-confinement\">restricted to specific threads<\/a>.\n+ * <p>\n+ * The simplest segment scope is the {@linkplain SegmentScope#global() global scope}. The global scope\n+ * is always alive. As a result, segments associated with the global scope are always accessible and their backing\n+ * regions of memory are never deallocated. Moreover, memory segments associated with the global scope\n+ * can be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n+ * {@snippet lang = java:\n+ * MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.global());\n+ * ...\n+ * \/\/ segment is never deallocated!\n+ *}\n+ * <p>\n+ * Alternatively, clients can obtain an {@linkplain SegmentScope#auto() automatic scope}, that is a segment\n+ * scope that is managed, automatically, by the garbage collector. The regions of memory backing memory segments associated\n+ * with an automatic scope are deallocated at some unspecified time <em>after<\/em> they become\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.auto());\n+ * ...\n+ * segment = null; \/\/ the segment region becomes available for deallocation after this point\n+ *}\n+ * Memory segments associated with an automatic scope can also be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n+ * <p>\n+ * Finally, clients can obtain a segment scope from an existing {@linkplain Arena arena}, the arena scope. The regions of memory\n+ * backing memory segments associated with an arena scope are deallocated when the arena is {@linkplain Arena#close() closed}.\n+ * When this happens, the arena scope becomes not {@linkplain #isAlive() alive} and subsequent access operations on segments\n+ * associated with the arena scope will fail {@link IllegalStateException}.\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment segment = null;\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     segment = MemorySegment.allocateNative(100, arena.scope());\n+ *     ...\n+ * } \/\/ segment region deallocated here\n+ * segment.get(ValueLayout.JAVA_BYTE, 0); \/\/ throws IllegalStateException\n+ * }\n+ *\n+ * Which threads can {@link #isAccessibleBy(Thread) access} memory segments associated with an arena scope depends\n+ * on the arena kind. For instance, segments associated with the scope of a {@linkplain Arena#openConfined() confined arena}\n+ * can only be accessed by the thread that created the arena. Conversely, segments associated with the scope of\n+ * {@linkplain Arena#openConfined() shared arena} can be accessed by any thread.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are thread-safe.\n+ *\n+ * @see Arena\n+ * @see MemorySegment\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature =PreviewFeature.Feature.FOREIGN)\n+sealed public interface SegmentScope permits MemorySessionImpl {\n+\n+    \/**\n+     * Creates a new scope that is managed, automatically, by the garbage collector.\n+     * Segments associated with the returned scope can be\n+     * {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by multiple threads.\n+     *\n+     * @return a new scope that is managed, automatically, by the garbage collector.\n+     *\/\n+    static SegmentScope auto() {\n+        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner());\n+    }\n+\n+    \/**\n+     * Obtains the global scope. Segments associated with the global scope can be\n+     * {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by multiple threads.\n+     *\n+     * @return the global scope.\n+     *\/\n+    static SegmentScope global() {\n+        return MemorySessionImpl.GLOBAL;\n+    }\n+\n+    \/**\n+     * {@return {@code true}, if this scope is alive}\n+     *\/\n+    boolean isAlive();\n+\n+    \/**\n+     * {@return {@code true} if the provided thread can access and\/or associated segments with this scope}\n+     * @param thread the thread to be tested.\n+     *\/\n+    boolean isAccessibleBy(Thread thread);\n+\n+    \/**\n+     * Runs a critical action while this scope is kept alive.\n+     * @param action the action to be run.\n+     * @throws IllegalStateException if this scope is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     *\/\n+    void whileAlive(Runnable action);\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentScope.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n- *     {@link MemorySegment#ofAddress(long, long, MemorySession) resizing} the segment first).<\/li>\n+ *     {@link MemorySegment#ofAddress(long, long, SegmentScope) resizing} the segment first).<\/li>\n@@ -62,1 +62,1 @@\n- * The factory methods {@link #libraryLookup(String, MemorySession)} and {@link #libraryLookup(Path, MemorySession)}\n+ * The factory methods {@link #libraryLookup(String, SegmentScope)} and {@link #libraryLookup(Path, SegmentScope)}\n@@ -65,1 +65,1 @@\n- * with a {@linkplain  MemorySession memory session}; when the session ends, the library is unloaded:\n+ * with a {@linkplain  SegmentScope scope}; when the scope becomes not {@link SegmentScope#isAlive()}, the library is unloaded:\n@@ -69,1 +69,1 @@\n- *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena.session()); \/\/ libGL.so loaded here\n+ *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena.scope()); \/\/ libGL.so loaded here\n@@ -95,1 +95,1 @@\n- * libraryLookup(\"libGL.so\", session).find(\"glGetString\").isPresent(); \/\/ true\n+ * libraryLookup(\"libGL.so\", scope).find(\"glGetString\").isPresent(); \/\/ true\n@@ -104,1 +104,1 @@\n- * libraryLookup(\"libGL.so\", session).find(\"glGetString\").isPresent(); \/\/ true\n+ * libraryLookup(\"libGL.so\", scope).find(\"glGetString\").isPresent(); \/\/ true\n@@ -142,1 +142,1 @@\n-     * returned by this method is backed by a shared memory session that is always alive and which keeps the caller's\n+     * returned by this method is backed by a scope that is always alive and which keeps the caller's\n@@ -161,2 +161,2 @@\n-        MemorySession loaderSession = (loader == null || loader instanceof BuiltinClassLoader) ?\n-                MemorySession.global() : \/\/ builtin loaders never go away\n+        SegmentScope loaderScope = (loader == null || loader instanceof BuiltinClassLoader) ?\n+                SegmentScope.global() : \/\/ builtin loaders never go away\n@@ -171,1 +171,1 @@\n-                    Optional.of(MemorySegment.ofAddress(addr, 0L, loaderSession));\n+                    Optional.of(MemorySegment.ofAddress(addr, 0L, loaderScope));\n@@ -177,2 +177,2 @@\n-     * The library will be unloaded when the provided memory session becomes\n-     * not {@linkplain MemorySession#isAlive() alive}, if no other library lookup is still using it.\n+     * The library will be unloaded when the provided scope becomes\n+     * not {@linkplain SegmentScope#isAlive() alive}, if no other library lookup is still using it.\n@@ -189,1 +189,1 @@\n-     * @param session the memory session which controls the library lifecycle.\n+     * @param scope the scope associated with symbols obtained from the returned lookup.\n@@ -197,1 +197,1 @@\n-    static SymbolLookup libraryLookup(String name, MemorySession session) {\n+    static SymbolLookup libraryLookup(String name, SegmentScope scope) {\n@@ -199,1 +199,1 @@\n-        return libraryLookup(name, RawNativeLibraries::load, session);\n+        return libraryLookup(name, RawNativeLibraries::load, scope);\n@@ -204,2 +204,2 @@\n-     * in that library. The library will be unloaded when the provided memory session becomes\n-     * not {@linkplain MemorySession#isAlive() alive}, if no other library lookup is still using it.\n+     * in that library. The library will be unloaded when the provided scope becomes\n+     * not {@linkplain SegmentScope#isAlive() alive}, if no other library lookup is still using it.\n@@ -215,1 +215,1 @@\n-     * @param session the memory session which controls the library lifecycle.\n+     * @param scope the scope associated with symbols obtained from the returned lookup.\n@@ -223,1 +223,1 @@\n-    static SymbolLookup libraryLookup(Path path, MemorySession session) {\n+    static SymbolLookup libraryLookup(Path path, SegmentScope scope) {\n@@ -225,1 +225,1 @@\n-        return libraryLookup(path, RawNativeLibraries::load, session);\n+        return libraryLookup(path, RawNativeLibraries::load, scope);\n@@ -228,1 +228,1 @@\n-    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, MemorySession session) {\n+    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, SegmentScope libScope) {\n@@ -230,1 +230,1 @@\n-        Objects.requireNonNull(session);\n+        Objects.requireNonNull(libScope);\n@@ -237,2 +237,2 @@\n-        \/\/ register hook to unload library when session is closed\n-        ((MemorySessionImpl) session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        \/\/ register hook to unload library when 'libScope' becomes not alive\n+        ((MemorySessionImpl) libScope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -249,1 +249,1 @@\n-                    Optional.of(MemorySegment.ofAddress(addr, 0, session));\n+                    Optional.of(MemorySegment.ofAddress(addr, 0, libScope));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * A variable argument list can be created using the {@link #make(Consumer, MemorySession)} factory, as follows:\n+ * A variable argument list can be created using the {@link #make(Consumer, SegmentScope)} factory, as follows:\n@@ -59,1 +59,1 @@\n- *        VaList vaList = VaList.ofAddress(vaListSegment.address(), arena.session());\n+ *        VaList vaList = VaList.ofAddress(vaListSegment.address(), arena.scope());\n@@ -90,2 +90,2 @@\n- *     <li>Variable argument lists created <em>safely<\/em>, using {@link #make(Consumer, MemorySession)} are capable of detecting out-of-bounds reads;<\/li>\n- *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, MemorySession)} are not capable of detecting out-of-bounds reads<\/li>\n+ *     <li>Variable argument lists created <em>safely<\/em>, using {@link #make(Consumer, SegmentScope)} are capable of detecting out-of-bounds reads;<\/li>\n+ *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, SegmentScope)} are not capable of detecting out-of-bounds reads<\/li>\n@@ -95,1 +95,1 @@\n- * (regardless of the session associated with the variable arity list).\n+ * (regardless of the scope used to obtain the variable arity list).\n@@ -108,2 +108,2 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -111,1 +111,1 @@\n-     * such that {@code segment().session().isAccessibleBy(T) == false}.\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -122,2 +122,2 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -125,1 +125,1 @@\n-     * such that {@code segment().session().isAccessibleBy(T) == false}.\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -136,2 +136,2 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -139,1 +139,1 @@\n-     * such that {@code segment().session().isAccessibleBy(T) == false}.\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -148,1 +148,1 @@\n-     * is associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions, the size of the returned\n+     * is associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions, the size of the returned\n@@ -155,2 +155,2 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -158,1 +158,1 @@\n-     * such that {@code segment().session().isAccessibleBy(T) == false}.\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -178,2 +178,2 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -181,1 +181,1 @@\n-     * such that {@code segment().session().isAccessibleBy(T) == false}.\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -190,2 +190,2 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -193,1 +193,1 @@\n-     * such that {@code segment().session().isAccessibleBy(T) == false}.\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -200,1 +200,1 @@\n-     * with the same memory session as this variable argument list. The behavior of this method is equivalent to the C\n+     * with the same scope as this variable argument list. The behavior of this method is equivalent to the C\n@@ -208,2 +208,2 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -211,1 +211,1 @@\n-     * such that {@code segment().session().isAccessibleBy(T) == false}.\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -219,2 +219,1 @@\n-     * platform-dependent. The returned segment's memory session is the session which manages the lifecycle of this\n-     * variable argument list.\n+     * platform-dependent.\n@@ -226,2 +225,2 @@\n-     * Creates a variable argument list from the give address value and memory session. The address is typically obtained\n-     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided session determines\n+     * Creates a variable argument list from the give address value and scope. The address is typically obtained\n+     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided scope determines\n@@ -229,2 +228,2 @@\n-     * and its associated off-heap memory region will be deallocated when the session becomes not\n-     * {@linkplain MemorySession#isAlive() alive}.\n+     * and its associated off-heap memory region will be deallocated when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -238,1 +237,1 @@\n-     * @param session the memory session to be associated with the returned variable argument list.\n+     * @param scope the scope associated with the returned variable argument list.\n@@ -240,1 +239,1 @@\n-     * @throws IllegalStateException         if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException         if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n@@ -242,1 +241,1 @@\n-     *                                       such that {@code session.isAccessibleBy(T) == false}.\n+     *                                       such that {@code scope.isAccessibleBy(T) == false}.\n@@ -249,1 +248,1 @@\n-    static VaList ofAddress(long address, MemorySession session) {\n+    static VaList ofAddress(long address, SegmentScope scope) {\n@@ -251,2 +250,2 @@\n-        Objects.requireNonNull(session);\n-        return SharedUtils.newVaListOfAddress(address, session);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaListOfAddress(address, scope);\n@@ -257,1 +256,1 @@\n-     * memory session. The provided session determines the lifecycle of the returned variable argument list: the\n+     * scope. The provided scope determines the lifecycle of the returned variable argument list: the\n@@ -259,1 +258,1 @@\n-     * deallocated when the session becomes not {@linkplain MemorySession#isAlive() alive}.\n+     * deallocated when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n@@ -268,1 +267,1 @@\n-     * @param session the memory session to be associated with the new variable arity list.\n+     * @param scope the scope to be associated with the new variable arity list.\n@@ -271,1 +270,1 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n@@ -273,1 +272,1 @@\n-     * such that {@code session.isAccessibleBy(T) == false}.\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -275,1 +274,1 @@\n-    static VaList make(Consumer<Builder> actions, MemorySession session) {\n+    static VaList make(Consumer<Builder> actions, SegmentScope scope) {\n@@ -277,2 +276,2 @@\n-        Objects.requireNonNull(session);\n-        return SharedUtils.newVaList(actions, session);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaList(actions, scope);\n@@ -282,2 +281,2 @@\n-     * Returns an empty variable argument list, associated with the {@linkplain MemorySession#global() global}\n-     * memory session. The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n+     * Returns an empty variable argument list, associated with the {@linkplain SegmentScope#global() global scope}.\n+     * The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":49,"deletions":50,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * MemorySegment segment = MemorySegment.allocateNative(10 * 4, MemorySession.implicit());\n+ * MemorySegment segment = MemorySegment.allocateNative(10 * 4, SegmentScope.auto());\n@@ -53,2 +53,3 @@\n- * The segment is associated with a memory session that is managed, {@linkplain java.lang.foreign.MemorySession#implicit() implicitly},\n- * by the garbage collector. As such, the off-heap memory backing the native segment will be released at some unspecified\n+ * The segment is associated with an {@linkplain java.lang.foreign.SegmentScope#auto() automatic scope}. This\n+ * means that the off-heap region of memory backing the segment is managed, automatically, by the garbage collector.\n+ * As such, the off-heap memory backing the native segment will be released at some unspecified\n@@ -87,1 +88,1 @@\n- * allocated by the arena will be associated with the same {@linkplain java.lang.foreign.MemorySession memory session}.\n+ * allocated by the arena will be associated with the same {@linkplain java.lang.foreign.SegmentScope scope}.\n@@ -101,1 +102,1 @@\n- * the memory session associated with the segment being accessed is still alive.\n+ * the scope associated with the segment being accessed is still alive.\n@@ -181,1 +182,1 @@\n- * MemorySession session = ...\n+ * SegmentScope scope = ...\n@@ -183,1 +184,1 @@\n- *     intCompareHandle, intCompareDescriptor, session);\n+ *     intCompareHandle, intCompareDescriptor, scope);\n@@ -188,1 +189,1 @@\n- * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, MemorySession) create}\n+ * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, SegmentScope) create}\n@@ -192,2 +193,2 @@\n- * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.MemorySession memory session}\n- * provided when the upcall stub is created. This same session is made available by the {@link java.lang.foreign.MemorySegment}\n+ * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.SegmentScope scope}\n+ * provided when the upcall stub is created. This same scope is made available by the {@link java.lang.foreign.MemorySegment}\n@@ -199,1 +200,1 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)}\n+ * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope)}\n@@ -204,1 +205,1 @@\n- * {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)}, if the provided spatial bounds are\n+ * {@link java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope)}, if the provided spatial bounds are\n@@ -230,0 +231,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.MemorySession;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemorySession;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -1060,1 +1060,1 @@\n-     *          {@linkplain MemorySession#isAlive() alive}.\n+     *          {@linkplain SegmentScope#isAlive() alive}.\n@@ -1064,1 +1064,1 @@\n-     *          {@linkplain MemorySession#isAccessibleBy(Thread) owning} the\n+     *          {@linkplain SegmentScope#isAccessibleBy(Thread) owning} the\n@@ -1087,1 +1087,1 @@\n-    public MemorySegment map(MapMode mode, long offset, long size, MemorySession session)\n+    public MemorySegment map(MapMode mode, long offset, long size, SegmentScope session)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -32,0 +31,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -80,1 +80,1 @@\n-    final MemorySession session;\n+    final SegmentScope session;\n@@ -83,1 +83,1 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySession session) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, SegmentScope session) {\n@@ -89,1 +89,1 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session);\n@@ -360,1 +360,1 @@\n-    public MemorySession session() {\n+    public SegmentScope scope() {\n@@ -478,1 +478,1 @@\n-        final MemorySession bufferSession;\n+        final SegmentScope bufferSession;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -49,1 +49,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, MemorySession)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, SegmentScope)}.\n@@ -71,1 +71,1 @@\n-        super(length, readOnly, MemorySession.global());\n+        super(length, readOnly, SegmentScope.global());\n@@ -82,1 +82,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session);\n@@ -102,1 +102,1 @@\n-        OfByte dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfByte dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -135,1 +135,1 @@\n-        OfChar dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfChar dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -168,1 +168,1 @@\n-        OfShort dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfShort dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -201,1 +201,1 @@\n-        OfInt dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfInt dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -234,1 +234,1 @@\n-        OfLong dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfLong dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -267,1 +267,1 @@\n-        OfFloat dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfFloat dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -300,1 +300,1 @@\n-        OfDouble dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfDouble dup(long offset, long size, boolean readOnly, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -46,1 +46,1 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySession session) {\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, SegmentScope session) {\n@@ -58,1 +58,1 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n+    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.Arena;\n@@ -30,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -53,1 +54,1 @@\n-        implements MemorySession, SegmentAllocator\n+        implements SegmentScope, SegmentAllocator\n@@ -79,0 +80,21 @@\n+    public Arena asArena() {\n+        return new Arena() {\n+            @Override\n+            public SegmentScope scope() {\n+                return MemorySessionImpl.this;\n+            }\n+\n+            @Override\n+            public void close() {\n+                MemorySessionImpl.this.close();\n+            }\n+\n+            @Override\n+            public boolean isCloseableBy(Thread thread) {\n+                Objects.requireNonNull(thread);\n+                return ownerThread() == null || \/\/ shared\n+                        ownerThread() == thread;\n+            }\n+        };\n+    }\n+\n@@ -156,1 +178,1 @@\n-    public static boolean sameOwnerThread(MemorySession session1, MemorySession session2) {\n+    public static boolean sameOwnerThread(SegmentScope session1, SegmentScope session2) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -31,0 +30,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -55,1 +55,1 @@\n-    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySession session) {\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, SegmentScope session) {\n@@ -72,1 +72,1 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -104,1 +104,1 @@\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySession session) {\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, SegmentScope session) {\n@@ -141,1 +141,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySession session, Runnable action) {\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope session, Runnable action) {\n@@ -152,1 +152,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySession session) {\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope session) {\n@@ -160,1 +160,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySession.global());\n+        return new NativeMemorySegmentImpl(min, byteSize, false, SegmentScope.global());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -35,1 +35,1 @@\n-        return (MemorySessionImpl) session();\n+        return (MemorySessionImpl) scope();\n@@ -37,1 +37,1 @@\n-    MemorySession session();\n+    SegmentScope scope();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -89,1 +89,1 @@\n-                ADDRESS.byteSize() * numSymbols, MemorySession.global());\n+                ADDRESS.byteSize() * numSymbols, SegmentScope.global());\n@@ -92,1 +92,1 @@\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, MemorySession.global()));\n+                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, SegmentScope.global()));\n@@ -109,1 +109,1 @@\n-                        Optional.of(MemorySegment.ofAddress(addr, 0, MemorySession.global()));\n+                        Optional.of(MemorySegment.ofAddress(addr, 0, SegmentScope.global()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -69,1 +69,1 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession scope) {\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope) {\n@@ -84,1 +84,1 @@\n-                                                   FunctionDescriptor function, MemorySession scope);\n+                                                   FunctionDescriptor function, SegmentScope scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -199,1 +199,1 @@\n-     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link MemorySession} that\n+     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link SegmentScope} that\n@@ -204,1 +204,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -206,1 +206,1 @@\n-        private Context(SegmentAllocator allocator, MemorySession session) {\n+        private Context(SegmentAllocator allocator, SegmentScope session) {\n@@ -215,1 +215,1 @@\n-        public MemorySession session() {\n+        public SegmentScope session() {\n@@ -229,1 +229,1 @@\n-            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.session())), arena.session()) {\n+            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.scope())), arena.scope()) {\n@@ -244,1 +244,1 @@\n-                public MemorySession session() {\n+                public SegmentScope session() {\n@@ -256,1 +256,1 @@\n-            return new Context(null, arena.session()) {\n+            return new Context(null, arena.scope()) {\n@@ -278,1 +278,1 @@\n-            public MemorySession session() {\n+            public SegmentScope session() {\n@@ -679,2 +679,2 @@\n-            MemorySession session = needsSession ?\n-                    context.session() : MemorySession.global();\n+            SegmentScope session = needsSession ?\n+                    context.session() : SegmentScope.global();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -85,1 +85,1 @@\n-    private static final String SESSION_DESC = methodType(MemorySession.class).descriptorString();\n+    private static final String SESSION_DESC = methodType(SegmentScope.class).descriptorString();\n@@ -91,1 +91,1 @@\n-    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, MemorySession.class).descriptorString();\n+    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, SegmentScope.class).descriptorString();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SegmentScope;\n@@ -45,1 +44,0 @@\n-import java.lang.foreign.SequenceLayout;\n@@ -292,1 +290,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n@@ -301,1 +299,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,1 @@\n-    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, MemorySession session) {\n+    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -53,1 +53,1 @@\n-    static MemorySegment makeUpcall(long entry, MemorySession session) {\n+    static MemorySegment makeUpcall(long entry, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -161,1 +161,1 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n@@ -68,1 +68,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n@@ -74,1 +74,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -39,1 +39,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -124,1 +123,1 @@\n-    private static LinuxAArch64VaList readFromAddress(long address, MemorySession session) {\n+    private static LinuxAArch64VaList readFromAddress(long address, SegmentScope session) {\n@@ -133,1 +132,1 @@\n-        MemorySegment ms = MemorySegment.allocateNative(LAYOUT, MemorySession.implicit());\n+        MemorySegment ms = MemorySegment.allocateNative(LAYOUT, SegmentScope.auto());\n@@ -321,1 +320,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.session());\n+                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.scope());\n@@ -365,1 +364,1 @@\n-        ((MemorySessionImpl) segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -388,1 +387,1 @@\n-    static LinuxAArch64VaList.Builder builder(MemorySession session) {\n+    static LinuxAArch64VaList.Builder builder(SegmentScope session) {\n@@ -392,1 +391,1 @@\n-    public static VaList ofAddress(long address, MemorySession session) {\n+    public static VaList ofAddress(long address, SegmentScope session) {\n@@ -398,1 +397,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -436,1 +435,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -444,1 +443,1 @@\n-        Builder(MemorySession session) {\n+        Builder(SegmentScope session) {\n@@ -564,2 +563,2 @@\n-            assert MemorySessionImpl.sameOwnerThread(gpRegs.session(), vaListSegment.session());\n-            assert MemorySessionImpl.sameOwnerThread(fpRegs.session(), vaListSegment.session());\n+            assert MemorySessionImpl.sameOwnerThread(gpRegs.scope(), vaListSegment.scope());\n+            assert MemorySessionImpl.sameOwnerThread(fpRegs.scope(), vaListSegment.scope());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n@@ -68,1 +68,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n@@ -74,1 +74,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -108,1 +108,1 @@\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n@@ -143,1 +143,1 @@\n-        ((MemorySessionImpl) segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -159,1 +159,1 @@\n-    static MacOsAArch64VaList ofAddress(long address, MemorySession session) {\n+    static MacOsAArch64VaList ofAddress(long address, SegmentScope session) {\n@@ -164,1 +164,1 @@\n-    static Builder builder(MemorySession session) {\n+    static Builder builder(SegmentScope session) {\n@@ -170,1 +170,1 @@\n-        ((MemorySessionImpl) segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -182,1 +182,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -185,1 +185,1 @@\n-        public Builder(MemorySession session) {\n+        public Builder(SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -127,1 +127,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -39,1 +39,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -134,1 +133,1 @@\n-    private static SysVVaList readFromAddress(long address, MemorySession session) {\n+    private static SysVVaList readFromAddress(long address, SegmentScope session) {\n@@ -142,1 +141,1 @@\n-        MemorySegment base = MemorySegment.allocateNative(LAYOUT, MemorySession.implicit());\n+        MemorySegment base = MemorySegment.allocateNative(LAYOUT, SegmentScope.auto());\n@@ -310,1 +309,1 @@\n-        ((MemorySessionImpl) segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -326,1 +325,1 @@\n-    static SysVVaList.Builder builder(MemorySession session) {\n+    static SysVVaList.Builder builder(SegmentScope session) {\n@@ -330,1 +329,1 @@\n-    public static VaList ofAddress(long address, MemorySession session) {\n+    public static VaList ofAddress(long address, SegmentScope session) {\n@@ -336,1 +335,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -363,1 +362,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -369,1 +368,1 @@\n-        public Builder(MemorySession session) {\n+        public Builder(SegmentScope session) {\n@@ -476,1 +475,1 @@\n-            assert MemorySessionImpl.sameOwnerThread(reg_save_area.session(), vaListSegment.session());\n+            assert MemorySessionImpl.sameOwnerThread(reg_save_area.scope(), vaListSegment.scope());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -61,1 +61,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n@@ -65,1 +65,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession scope) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n@@ -71,1 +71,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -134,1 +134,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -118,1 +118,1 @@\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n@@ -144,1 +144,1 @@\n-        ((MemorySessionImpl) segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -152,1 +152,1 @@\n-    static WinVaList ofAddress(long address, MemorySession session) {\n+    static WinVaList ofAddress(long address, SegmentScope session) {\n@@ -156,1 +156,1 @@\n-    static Builder builder(MemorySession session) {\n+    static Builder builder(SegmentScope session) {\n@@ -162,1 +162,1 @@\n-        ((MemorySessionImpl) segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -174,1 +174,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -177,1 +177,1 @@\n-        public Builder(MemorySession session) {\n+        public Builder(SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -61,1 +61,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n@@ -65,1 +65,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession scope) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n@@ -71,1 +71,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        @JEP(number=434, title=\"Foreign Function & Memory API\", status=\"Second Preview\")\n+        @JEP(number=424, title=\"Foreign Function & Memory API\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -1211,1 +1211,1 @@\n-                             MemorySession session)\n+                             SegmentScope session)\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -381,1 +382,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -385,1 +386,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1L, MemorySession.implicit());\n+            MemorySegment segment = MemorySegment.allocateNative(1L, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -55,1 +55,1 @@\n-            callFunc(loadLibrary(arena0.session()));\n+            callFunc(loadLibrary(arena0.scope()));\n@@ -57,1 +57,1 @@\n-                callFunc(loadLibrary(arena1.session()));\n+                callFunc(loadLibrary(arena1.scope()));\n@@ -59,1 +59,1 @@\n-                    callFunc(loadLibrary(arena2.session()));\n+                    callFunc(loadLibrary(arena2.scope()));\n@@ -69,1 +69,1 @@\n-            addr = loadLibrary(arena.session());\n+            addr = loadLibrary(arena.scope());\n@@ -74,1 +74,1 @@\n-    private static MemorySegment loadLibrary(MemorySession session) {\n+    private static MemorySegment loadLibrary(SegmentScope session) {\n@@ -77,1 +77,1 @@\n-        assertEquals(addr.session(), session);\n+        assertEquals(addr.scope(), session);\n@@ -97,1 +97,1 @@\n-        SymbolLookup.libraryLookup(\"nonExistent\", MemorySession.global());\n+        SymbolLookup.libraryLookup(\"nonExistent\", SegmentScope.global());\n@@ -102,1 +102,1 @@\n-        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), MemorySession.global());\n+        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), SegmentScope.global());\n@@ -120,1 +120,1 @@\n-                    callFunc(loadLibrary(arena.session()));\n+                    callFunc(loadLibrary(arena.scope()));\n@@ -129,1 +129,1 @@\n-        MemorySegment addr = loadLibrary(arena.session());\n+        MemorySegment addr = loadLibrary(arena.scope());\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -124,1 +124,1 @@\n-            return LINKER.upcallStub(target, descriptor, MemorySession.implicit());\n+            return LINKER.upcallStub(target, descriptor, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -38,0 +37,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,1 @@\n-        assertFalse(segment.session().isAlive());\n+        assertFalse(segment.scope().isAlive());\n@@ -96,1 +96,1 @@\n-                    assertFalse(allocations[j].drop().session().isAlive());\n+                    assertFalse(allocations[j].drop().scope().isAlive());\n@@ -98,1 +98,1 @@\n-                    assertTrue(allocations[j].drop().session().isAlive());\n+                    assertTrue(allocations[j].drop().scope().isAlive());\n@@ -119,1 +119,1 @@\n-            list = VaList.make(b -> b.addVarg(C_INT, 42), arena.session());\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), arena.scope());\n@@ -121,1 +121,1 @@\n-        assertFalse(list.segment().session().isAlive());\n+        assertFalse(list.segment().scope().isAlive());\n@@ -134,1 +134,1 @@\n-            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.session());\n+            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.scope());\n@@ -136,1 +136,1 @@\n-        assertFalse(upcall.session().isAlive());\n+        assertFalse(upcall.scope().isAlive());\n@@ -153,1 +153,1 @@\n-            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), arena.session());\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), arena.scope());\n@@ -178,1 +178,1 @@\n-            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.session());\n+            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.scope());\n@@ -188,1 +188,1 @@\n-            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), MemorySession.implicit());\n+            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena.session());\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena.scope());\n@@ -311,1 +311,1 @@\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, arena)), arena.session());\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, arena)), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -97,1 +97,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -116,1 +116,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -137,1 +137,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -195,1 +195,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.session());\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.scope());\n@@ -206,1 +206,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.session());\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.scope());\n@@ -214,1 +214,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -257,1 +257,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -295,1 +295,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -334,1 +334,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -377,1 +377,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -111,1 +111,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -122,1 +122,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), MemorySession.global());\n+        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), SegmentScope.global());\n@@ -131,1 +131,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), arena.scope());\n@@ -140,1 +140,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -189,1 +189,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(tuples, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(tuples, arena.scope());;\n@@ -235,1 +235,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.scope());\n@@ -241,1 +241,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena.scope());\n@@ -255,1 +255,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena.scope());\n@@ -263,1 +263,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.scope());\n@@ -276,1 +276,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.scope());\n@@ -296,1 +296,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena.session());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena.scope());\n@@ -307,1 +307,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.session());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.scope());\n@@ -327,1 +327,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena.scope());\n@@ -364,1 +364,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n@@ -390,1 +390,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n@@ -424,1 +424,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n@@ -437,1 +437,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n@@ -475,1 +475,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n@@ -486,1 +486,1 @@\n-            leaked = MemorySegment.allocateNative(bytes, arena.session());;\n+            leaked = MemorySegment.allocateNative(bytes, arena.scope());;\n@@ -494,1 +494,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, SegmentScope.auto());\n@@ -504,1 +504,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, MemorySession.implicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, SegmentScope.auto());\n@@ -514,1 +514,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, MemorySession.implicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, SegmentScope.auto());\n@@ -528,1 +528,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena.scope());\n@@ -538,1 +538,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena.session());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena.scope());\n@@ -552,1 +552,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena.scope());\n@@ -564,1 +564,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena.scope());\n@@ -579,1 +579,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, MemorySession.implicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, SegmentScope.auto());\n@@ -588,1 +588,1 @@\n-            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, arena.session());;\n+            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, arena.scope());;\n@@ -601,1 +601,1 @@\n-            MemorySegment nativeArray = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment nativeArray = MemorySegment.allocateNative(seq, arena.scope());;\n@@ -673,1 +673,1 @@\n-            MemorySegment ms = MemorySegment.allocateNative(4, 1, arena.session());;\n+            MemorySegment ms = MemorySegment.allocateNative(4, 1, arena.scope());;\n@@ -683,1 +683,1 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, arena.session());\n+        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, arena.scope());\n@@ -698,1 +698,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.scope());;\n@@ -719,1 +719,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(10, arena.scope());\n@@ -737,1 +737,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(16, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(16, arena.scope());;\n@@ -755,1 +755,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(16, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(16, arena.scope());;\n@@ -765,2 +765,2 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, MemorySession.implicit()) },\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, Arena.openConfined().session()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, SegmentScope.auto()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, Arena.openConfined().scope()) },\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -65,1 +65,1 @@\n-                MemorySession.global());\n+                SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.session()) :\n+                    SegmentAllocator.nativeAllocator(arena.scope()) :\n@@ -76,1 +76,1 @@\n-                    assertEquals(((MemorySegment)res).session(), arena.session());\n+                    assertEquals(((MemorySegment)res).scope(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.session()) :\n+                    SegmentAllocator.nativeAllocator(arena.scope()) :\n@@ -72,1 +72,1 @@\n-                    assertEquals(((MemorySegment)res).session(), arena.session());\n+                    assertEquals(((MemorySegment)res).scope(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, arena.scope());\n@@ -85,1 +85,1 @@\n-            assertTrue(!segment.session().isAlive());\n+            assertTrue(!segment.scope().isAlive());\n@@ -102,1 +102,1 @@\n-            outer: while (segment.session().isAlive()) {\n+            outer: while (segment.scope().isAlive()) {\n@@ -196,1 +196,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.session());\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.scope());\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -103,1 +103,1 @@\n-        NATIVE(MemorySegment.allocateNative(8, MemorySession.implicit()), -1);\n+        NATIVE(MemorySegment.allocateNative(8, SegmentScope.auto()), -1);\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-            var segment = MemorySegment.allocateNative((long) longArrayLength * Long.BYTES, Long.SIZE, arena.session());\n+            var segment = MemorySegment.allocateNative((long) longArrayLength * Long.BYTES, Long.SIZE, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n@@ -472,1 +472,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, arena.session()));\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, arena.scope()));\n@@ -127,1 +127,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.session()));\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.scope()));\n@@ -196,1 +196,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.session()));\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.scope()));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(128, arena.session());;\n+                MemorySegment segment = MemorySegment.allocateNative(128, arena.scope());;\n@@ -96,1 +96,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(64, arena.session());;\n+                MemorySegment segment = MemorySegment.allocateNative(64, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(aligned, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(aligned, arena.scope());;\n@@ -74,1 +74,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, arena.scope());;\n@@ -101,1 +101,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());;\n+                MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());;\n@@ -125,1 +125,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(g, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(g, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -57,1 +57,1 @@\n-            addCloseAction(arena.session(), () -> acc.addAndGet(delta));\n+            addCloseAction(arena.scope(), () -> acc.addAndGet(delta));\n@@ -68,1 +68,1 @@\n-        MemorySession session = sessionSupplier.get();\n+        SegmentScope session = sessionSupplier.get();\n@@ -91,2 +91,2 @@\n-        MemorySession session = sessionSupplier.get();\n-        AtomicReference<MemorySession> sessionRef = new AtomicReference<>(session);\n+        SegmentScope session = sessionSupplier.get();\n+        AtomicReference<SegmentScope> sessionRef = new AtomicReference<>(session);\n@@ -149,1 +149,1 @@\n-            keepAlive(handle.session(), arena.session());\n+            keepAlive(handle.scope(), arena.scope());\n@@ -173,1 +173,1 @@\n-                    keepAlive(handle.session(), arena.session());\n+                    keepAlive(handle.scope(), arena.scope());\n@@ -208,1 +208,1 @@\n-        keepAlive(handle.session(), arena.session());\n+        keepAlive(handle.scope(), arena.scope());\n@@ -229,1 +229,1 @@\n-        MemorySession session = sessionSupplier.get();\n+        SegmentScope session = sessionSupplier.get();\n@@ -235,1 +235,1 @@\n-    private void acquireRecursive(MemorySession session, int acquireCount) {\n+    private void acquireRecursive(SegmentScope session, int acquireCount) {\n@@ -237,1 +237,1 @@\n-            keepAlive(arena.session(), session);\n+            keepAlive(arena.scope(), session);\n@@ -253,1 +253,1 @@\n-            keepAlive(MemorySession.implicit(), root.session());\n+            keepAlive(SegmentScope.auto(), root.scope());\n@@ -266,1 +266,1 @@\n-                        keepAlive(arena.session(), root.session());\n+                        keepAlive(arena.scope(), root.scope());\n@@ -282,1 +282,1 @@\n-            keepAlive(arena.session(), root.session());\n+            keepAlive(arena.scope(), root.scope());\n@@ -289,1 +289,1 @@\n-                keepAlive(arena.session(), root.session());\n+                keepAlive(arena.scope(), root.scope());\n@@ -329,1 +329,1 @@\n-    private void keepAlive(MemorySession child, MemorySession parent) {\n+    private void keepAlive(SegmentScope child, SegmentScope parent) {\n@@ -335,1 +335,1 @@\n-    private void addCloseAction(MemorySession session, Runnable action) {\n+    private void addCloseAction(SegmentScope session, Runnable action) {\n@@ -340,1 +340,1 @@\n-    interface SessionSupplier extends Supplier<MemorySession> {\n+    interface SessionSupplier extends Supplier<SegmentScope> {\n@@ -342,1 +342,1 @@\n-        static void close(MemorySession session) {\n+        static void close(SegmentScope session) {\n@@ -346,1 +346,1 @@\n-        static boolean isImplicit(MemorySession session) {\n+        static boolean isImplicit(SegmentScope session) {\n@@ -351,1 +351,1 @@\n-            return MemorySession::implicit;\n+            return SegmentScope::auto;\n@@ -355,1 +355,1 @@\n-            return () -> arenaSupplier.get().session();\n+            return () -> arenaSupplier.get().scope();\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -176,1 +176,1 @@\n-            var nativeSegment = MemorySegment.allocateNative(4, 4, arena.session());;\n+            var nativeSegment = MemorySegment.allocateNative(4, 4, arena.scope());;\n@@ -188,2 +188,2 @@\n-                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.session());;\n-                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.session());;\n+                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.scope());;\n+                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.scope());;\n@@ -232,2 +232,2 @@\n-            s1 = MemorySegment.allocateNative(4, 1, arena.session());;\n-            s2 = MemorySegment.allocateNative(4, 1, arena.session());;\n+            s1 = MemorySegment.allocateNative(4, 1, arena.scope());;\n+            s2 = MemorySegment.allocateNative(4, 1, arena.scope());;\n@@ -243,1 +243,1 @@\n-            var segment = MemorySegment.allocateNative(4, 1, arena.session());;\n+            var segment = MemorySegment.allocateNative(4, 1, arena.scope());;\n@@ -284,1 +284,1 @@\n-        NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+        NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -37,0 +36,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -149,1 +149,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n@@ -159,1 +159,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(doubles, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(doubles, arena.scope());;\n@@ -173,1 +173,1 @@\n-                    arena.session(), () -> freeMemory(addr));\n+                    arena.scope(), () -> freeMemory(addr));\n@@ -184,1 +184,1 @@\n-                    arena.session(), () -> freeMemory(addr));\n+                    arena.scope(), () -> freeMemory(addr));\n@@ -188,1 +188,1 @@\n-        assertTrue(!mallocSegment.session().isAlive());\n+        assertTrue(!mallocSegment.scope().isAlive());\n@@ -202,2 +202,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(4, 1, arena.session());;\n-            MemorySegment.ofAddress(segment.address(), -1, MemorySession.global());\n+            MemorySegment segment = MemorySegment.allocateNative(4, 1, arena.scope());;\n+            MemorySegment.ofAddress(segment.address(), -1, SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -104,1 +105,1 @@\n-            MemorySession.class,\n+            SegmentScope.class,\n@@ -109,3 +110,3 @@\n-            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.MemorySession,java.lang.Runnable)\/3\/0\",\n-            \"java.lang.foreign.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n-            \"java.lang.foreign.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.SegmentScope,java.lang.Runnable)\/3\/0\",\n+            \"java.lang.foreign.MemorySegment.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySegment.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n@@ -186,1 +187,1 @@\n-        addDefaultMapping(MemorySession.class, MemorySession.implicit());\n+        addDefaultMapping(SegmentScope.class, SegmentScope.auto());\n@@ -201,1 +202,1 @@\n-            }, MemorySession.implicit());\n+            }, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -78,1 +78,1 @@\n-        Z obj = scopedOperation.apply(arena.session());\n+        Z obj = scopedOperation.apply(arena.scope());\n@@ -91,1 +91,1 @@\n-            Z obj = scopedOperation.apply(arena.session());\n+            Z obj = scopedOperation.apply(arena.scope());\n@@ -164,1 +164,1 @@\n-    static class ScopedOperation<X> implements Consumer<X>, Function<MemorySession, X> {\n+    static class ScopedOperation<X> implements Consumer<X>, Function<SegmentScope, X> {\n@@ -166,1 +166,1 @@\n-        final Function<MemorySession, X> factory;\n+        final Function<SegmentScope, X> factory;\n@@ -170,1 +170,1 @@\n-        private ScopedOperation(Function<MemorySession, X> factory, Consumer<X> operation, String name) {\n+        private ScopedOperation(Function<SegmentScope, X> factory, Consumer<X> operation, String name) {\n@@ -182,1 +182,1 @@\n-        public X apply(MemorySession session) {\n+        public X apply(SegmentScope session) {\n@@ -186,1 +186,1 @@\n-        static <Z> void of(Function<MemorySession, Z> factory, Consumer<Z> consumer, String name) {\n+        static <Z> void of(Function<SegmentScope, Z> factory, Consumer<Z> consumer, String name) {\n@@ -190,1 +190,1 @@\n-        static void ofScope(Consumer<MemorySession> scopeConsumer, String name) {\n+        static void ofScope(Consumer<SegmentScope> scopeConsumer, String name) {\n@@ -239,1 +239,1 @@\n-            final Function<MemorySession, MemorySegment> segmentFactory;\n+            final Function<SegmentScope, MemorySegment> segmentFactory;\n@@ -241,1 +241,1 @@\n-            SegmentFactory(Function<MemorySession, MemorySegment> segmentFactory) {\n+            SegmentFactory(Function<SegmentScope, MemorySegment> segmentFactory) {\n@@ -249,1 +249,1 @@\n-            final Function<MemorySession, SegmentAllocator> allocatorFactory;\n+            final Function<SegmentScope, SegmentAllocator> allocatorFactory;\n@@ -251,1 +251,1 @@\n-            AllocatorFactory(Function<MemorySession, SegmentAllocator> allocatorFactory) {\n+            AllocatorFactory(Function<SegmentScope, SegmentAllocator> allocatorFactory) {\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -95,1 +96,1 @@\n-                    assertFalse(address.session().isAlive());\n+                    assertFalse(address.scope().isAlive());\n@@ -190,1 +191,1 @@\n-                return MemorySegment.allocateNative(byteSize, byteAlignment, MemorySession.implicit());\n+                return MemorySegment.allocateNative(byteSize, byteAlignment, SegmentScope.auto());\n@@ -350,2 +351,2 @@\n-        SLICING(true, (size, drop) -> SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, drop.session()))),\n-        NATIVE_ALLOCATOR(false, (size, drop) -> SegmentAllocator.nativeAllocator(drop.session()));\n+        SLICING(true, (size, drop) -> SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, drop.scope()))),\n+        NATIVE_ALLOCATOR(false, (size, drop) -> SegmentAllocator.nativeAllocator(drop.scope()));\n@@ -483,2 +484,2 @@\n-                { SegmentAllocator.nativeAllocator(MemorySession.global()) },\n-                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, MemorySession.global())) },\n+                { SegmentAllocator.nativeAllocator(SegmentScope.global()) },\n+                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, SegmentScope.global())) },\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -147,1 +147,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+            NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -34,0 +34,2 @@\n+\n+import java.lang.foreign.SegmentScope;\n@@ -82,1 +84,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+            NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -39,1 +40,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -64,1 +65,1 @@\n-                () -> MemorySegment.allocateNative(16, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(16, SegmentScope.auto()),\n@@ -67,1 +68,1 @@\n-                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, MemorySession.implicit());\n+                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, SegmentScope.auto());\n@@ -101,1 +102,1 @@\n-        assertEquals(s1.asOverlappingSlice(s2).get().session(), s1.session());\n+        assertEquals(s1.asOverlappingSlice(s2).get().scope(), s1.scope());\n@@ -104,1 +105,1 @@\n-        assertEquals(s2.asOverlappingSlice(s1).get().session(), s2.session());\n+        assertEquals(s2.asOverlappingSlice(s1).get().scope(), s2.scope());\n@@ -120,1 +121,1 @@\n-            assertEquals(s1.asOverlappingSlice(slice).get().session(), s1.session());\n+            assertEquals(s1.asOverlappingSlice(slice).get().scope(), s1.scope());\n@@ -123,1 +124,1 @@\n-            assertEquals(slice.asOverlappingSlice(s1).get().session(), slice.session());\n+            assertEquals(slice.asOverlappingSlice(s1).get().scope(), slice.scope());\n@@ -134,1 +135,1 @@\n-        NATIVE(() -> MemorySegment.allocateNative(16, MemorySession.implicit())),\n+        NATIVE(() -> MemorySegment.allocateNative(16, SegmentScope.auto())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -53,1 +53,1 @@\n-        MemorySegment.allocateNative(size, align, MemorySession.implicit());\n+        MemorySegment.allocateNative(size, align, SegmentScope.auto());\n@@ -59,1 +59,1 @@\n-            MemorySession session = arena.session();\n+            SegmentScope session = arena.scope();\n@@ -78,1 +78,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE, MemorySession.implicit());\n+        MemorySegment.allocateNative(Long.MAX_VALUE, SegmentScope.auto());\n@@ -83,1 +83,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, MemorySession.implicit()); \/\/ 2M\n+        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, SegmentScope.auto()); \/\/ 2M\n@@ -90,1 +90,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1000, 1, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(1000, 1, arena.scope());\n@@ -101,1 +101,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.scope());\n@@ -121,1 +121,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n@@ -126,2 +126,2 @@\n-            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()));\n-            MemorySegment segment2 = MemorySegment.allocateNative(100, arena.session());\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, SegmentScope.global()));\n+            MemorySegment segment2 = MemorySegment.allocateNative(100, arena.scope());\n@@ -146,1 +146,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n@@ -150,1 +150,1 @@\n-            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()).hashCode());\n+            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, SegmentScope.global()).hashCode());\n@@ -165,1 +165,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, MemorySession.implicit());\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, SegmentScope.auto());\n@@ -172,1 +172,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10L, MemorySession.implicit());\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10L, SegmentScope.auto());\n@@ -179,1 +179,1 @@\n-            var segment = MemorySegment.allocateNative(10, MemorySession.global());\n+            var segment = MemorySegment.allocateNative(10, SegmentScope.global());\n@@ -204,6 +204,6 @@\n-                () -> MemorySegment.allocateNative(4L, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(4L, 8, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(4L, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(4L, 8, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, MemorySession.implicit())\n+                () -> MemorySegment.allocateNative(4L, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(4L, 8, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(4L, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(4L, 8, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, SegmentScope.auto())\n@@ -267,1 +267,1 @@\n-        if (segment.session().isAccessibleBy(Thread.currentThread())) {\n+        if (segment.scope().isAccessibleBy(Thread.currentThread())) {\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(layout, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(layout, arena.scope());;\n@@ -98,1 +98,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(4, 1, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(4, 1, arena.scope());;\n@@ -102,1 +102,1 @@\n-            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena.session());\n+            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena.scope());\n@@ -125,1 +125,1 @@\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), arena.session());;\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.scope());;\n@@ -65,1 +65,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -63,1 +63,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());;\n@@ -89,1 +89,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n@@ -65,1 +65,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n@@ -73,1 +73,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n@@ -81,1 +81,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -52,1 +52,1 @@\n-        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), MemorySession.implicit());\n+        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), SegmentScope.auto());\n@@ -57,1 +57,1 @@\n-        VaList.ofAddress(0L, MemorySession.implicit());\n+        VaList.ofAddress(0L, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -45,0 +44,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -68,1 +68,1 @@\n-            Object[] args = makeArgs(MemorySession.implicit(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(SegmentScope.auto(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -75,1 +75,1 @@\n-            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena.session());\n+            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena.scope());\n@@ -81,1 +81,1 @@\n-                    ? invoker.invoke(arena.session(), callback)\n+                    ? invoker.invoke(arena.scope(), callback)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -68,1 +68,1 @@\n-        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), MemorySession.implicit());\n+        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), SegmentScope.auto());\n@@ -84,1 +84,1 @@\n-    static Object[] makeArgs(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n@@ -88,1 +88,1 @@\n-    static Object[] makeArgs(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n@@ -101,1 +101,1 @@\n-    static MemorySegment makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+    static MemorySegment makeCallback(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -155,1 +155,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.implicit());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -47,0 +46,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -90,1 +90,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.implicit());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), SegmentScope.auto());\n@@ -106,1 +106,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena.session());\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-            Object[] args = makeArgs(arena.session(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(arena.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -60,1 +60,1 @@\n-            Object[] args = makeArgsStack(arena.session(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgsStack(arena.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -74,1 +74,1 @@\n-    static Object[] makeArgsStack(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+    static Object[] makeArgsStack(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena.session());\n-            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, arena.session());;\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena.scope());\n+            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, arena.scope());;\n@@ -99,1 +99,1 @@\n-        assertFalse(captured.session().isAlive());\n+        assertFalse(captured.scope().isAlive());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,3 +75,3 @@\n-            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena.session());\n-            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, arena.session());;\n-            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), arena.session());;\n+            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena.scope());\n+            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, arena.scope());;\n+            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), arena.scope());;\n@@ -129,1 +129,1 @@\n-            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena.session());\n+            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -69,1 +69,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1L, 2, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(1L, 2, SegmentScope.auto());\n@@ -106,1 +106,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), arena.session());\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), arena.scope());\n@@ -89,1 +89,1 @@\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.session());\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -71,1 +71,1 @@\n-    static ByteBuffer segmentBufferOfSize(MemorySession session, int size) {\n+    static ByteBuffer segmentBufferOfSize(SegmentScope session, int size) {\n@@ -79,1 +79,1 @@\n-    static ByteBuffer[] segmentBuffersOfSize(int len, MemorySession session, int size) {\n+    static ByteBuffer[] segmentBuffersOfSize(int len, SegmentScope session, int size) {\n@@ -91,1 +91,1 @@\n-    static ByteBuffer[] mixedBuffersOfSize(int len, MemorySession session, int size) {\n+    static ByteBuffer[] mixedBuffersOfSize(int len, SegmentScope session, int size) {\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -79,1 +78,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -112,2 +111,2 @@\n-            ByteBuffer bb = segmentBufferOfSize(drop.session(), 64);\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.session(), 32);\n+            ByteBuffer bb = segmentBufferOfSize(drop.scope(), 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.scope(), 32);\n@@ -164,2 +163,2 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.session());\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.session());\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.scope());\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -188,2 +187,2 @@\n-                var writeBuffers = mixedBuffersOfSize(16, drop.session(), 32);\n-                var readBuffers = mixedBuffersOfSize(16, drop.session(), 32);\n+                var writeBuffers = mixedBuffersOfSize(16, drop.scope(), 32);\n+                var readBuffers = mixedBuffersOfSize(16, drop.scope(), 32);\n@@ -211,1 +210,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -225,1 +224,1 @@\n-                assertTrue(drop.session().isAlive());\n+                assertTrue(drop.scope().isAlive());\n@@ -232,1 +231,1 @@\n-                assertTrue(drop.session().isAlive());\n+                assertTrue(drop.scope().isAlive());\n@@ -256,1 +255,1 @@\n-            var bba = segmentBuffersOfSize(32, drop.session(), 128);\n+            var bba = segmentBuffersOfSize(32, drop.scope(), 128);\n@@ -265,1 +264,1 @@\n-                                var bba = segmentBuffersOfSize(32, drop.session(), 128);\n+                                var bba = segmentBuffersOfSize(32, drop.scope(), 128);\n@@ -276,1 +275,1 @@\n-            assertTrue(drop.session().isAlive());\n+            assertTrue(drop.scope().isAlive());\n@@ -284,1 +283,1 @@\n-            assertTrue(drop.session().isAlive());\n+            assertTrue(drop.scope().isAlive());\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -68,1 +68,1 @@\n-            ByteBuffer bb = segmentBufferOfSize(drop.session(), 16);\n+            ByteBuffer bb = segmentBufferOfSize(drop.scope(), 16);\n@@ -87,1 +87,1 @@\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.session(), 16);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.scope(), 16);\n@@ -105,2 +105,2 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.session());\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.session());\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.scope());\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -144,1 +144,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -174,2 +174,2 @@\n-            var writeBuffers = mixedBuffersOfSize(32, drop.session(), 64);\n-            var readBuffers = mixedBuffersOfSize(32, drop.session(), 64);\n+            var writeBuffers = mixedBuffersOfSize(32, drop.scope(), 64);\n+            var readBuffers = mixedBuffersOfSize(32, drop.scope(), 64);\n@@ -192,1 +192,1 @@\n-            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1.session(), 64), mixedBuffersOfSize(16, drop2.session(), 64))\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1.scope(), 64), mixedBuffersOfSize(16, drop2.scope(), 64))\n@@ -195,1 +195,1 @@\n-            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1.session(), 64), mixedBuffersOfSize(16, drop2.session(), 64))\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1.scope(), 64), mixedBuffersOfSize(16, drop2.scope(), 64))\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -55,1 +54,1 @@\n-            arena.session().whileAlive(() -> {\n+            arena.scope().whileAlive(() -> {\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -42,1 +43,1 @@\n-        MemorySegment.ofAddress(0, 4000, MemorySession.global());\n+        MemorySegment.ofAddress(0, 4000, SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -46,2 +47,2 @@\n-                MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class));\n-        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, MemorySession.global());\n+                MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class));\n+        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -44,2 +45,2 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, MemorySession.class);\n-        method.invoke(null, 0L, 4000L, MemorySession.global());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, SegmentScope.class);\n+        method.invoke(null, 0L, 4000L, SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -75,1 +75,1 @@\n-        addDefaultMapping(MemorySession.class, MemorySession.implicit());\n+        addDefaultMapping(SegmentScope.class, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -54,1 +54,1 @@\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class)),\n+                            MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class)),\n@@ -57,1 +57,1 @@\n-                            MethodType.methodType(SymbolLookup.class, String.class, MemorySession.class)),\n+                            MethodType.methodType(SymbolLookup.class, String.class, SegmentScope.class)),\n@@ -60,1 +60,1 @@\n-                            MethodType.methodType(SymbolLookup.class, Path.class, MemorySession.class)),\n+                            MethodType.methodType(SymbolLookup.class, Path.class, SegmentScope.class)),\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena.session());\n+            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena.scope());\n@@ -189,1 +189,1 @@\n-            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena.session());\n+            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.session());\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.session());\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena.session());\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -129,1 +130,1 @@\n-            = actions -> Windowsx64Linker.newVaList(actions, MemorySession.implicit());\n+            = actions -> Windowsx64Linker.newVaList(actions, SegmentScope.auto());\n@@ -131,1 +132,1 @@\n-            = actions -> SysVx64Linker.newVaList(actions, MemorySession.implicit());\n+            = actions -> SysVx64Linker.newVaList(actions, SegmentScope.auto());\n@@ -133,1 +134,1 @@\n-            = actions -> LinuxAArch64Linker.newVaList(actions, MemorySession.implicit());\n+            = actions -> LinuxAArch64Linker.newVaList(actions, SegmentScope.auto());\n@@ -135,1 +136,1 @@\n-            = actions -> MacOsAArch64Linker.newVaList(actions, MemorySession.implicit());\n+            = actions -> MacOsAArch64Linker.newVaList(actions, SegmentScope.auto());\n@@ -137,1 +138,1 @@\n-            = (builder) -> VaList.make(builder, MemorySession.implicit());\n+            = (builder) -> VaList.make(builder, SegmentScope.auto());\n@@ -139,1 +140,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> winVaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> winVaListScopedFactory\n@@ -141,1 +142,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> sysvVaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> sysvVaListScopedFactory\n@@ -143,1 +144,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> linuxAArch64VaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> linuxAArch64VaListScopedFactory\n@@ -145,1 +146,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> macAArch64VaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> macAArch64VaListScopedFactory\n@@ -147,1 +148,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> platformVaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> platformVaListScopedFactory\n@@ -229,1 +230,1 @@\n-            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, arena.session());;\n+            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, arena.scope());;\n@@ -247,1 +248,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, SegmentScope.auto());\n@@ -284,1 +285,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, arena.session());;\n+            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, arena.scope());;\n@@ -300,1 +301,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -337,1 +338,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, arena.session());;\n+            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, arena.scope());;\n@@ -353,1 +354,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, SegmentScope.auto());\n@@ -391,1 +392,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, arena.session());;\n+            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, arena.scope());;\n@@ -411,1 +412,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, SegmentScope.auto());\n@@ -455,1 +456,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, arena.session());;\n+            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, arena.scope());;\n@@ -507,2 +508,2 @@\n-            MemorySegment longSum = MemorySegment.allocateNative(longLayout, arena.session());;\n-            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, arena.session());;\n+            MemorySegment longSum = MemorySegment.allocateNative(longLayout, arena.scope());;\n+            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, arena.scope());;\n@@ -535,1 +536,1 @@\n-            MemorySegment stub = abi.upcallStub(callback, desc, arena.session());\n+            MemorySegment stub = abi.upcallStub(callback, desc, arena.scope());\n@@ -571,1 +572,1 @@\n-    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory,\n+    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory,\n@@ -577,1 +578,1 @@\n-                    .addVarg(intLayout, 8), arena.session());\n+                    .addVarg(intLayout, 8), arena.scope());\n@@ -582,1 +583,1 @@\n-        assertFalse(listLeaked.segment().session().isAlive());\n+        assertFalse(listLeaked.segment().scope().isAlive());\n@@ -592,1 +593,1 @@\n-                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerArena.session());;\n+                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerArena.scope());;\n@@ -596,1 +597,1 @@\n-                pointOut = MemorySegment.allocateNative(Point_LAYOUT, arena.session());;\n+                pointOut = MemorySegment.allocateNative(Point_LAYOUT, arena.scope());;\n@@ -600,1 +601,1 @@\n-                assertTrue(pointOut.session().isAlive()); \/\/ after VaList freed\n+                assertTrue(pointOut.scope().isAlive()); \/\/ after VaList freed\n@@ -602,1 +603,1 @@\n-            assertTrue(pointOut.session().isAlive()); \/\/ after inner session freed\n+            assertTrue(pointOut.scope().isAlive()); \/\/ after inner session freed\n@@ -604,1 +605,1 @@\n-        assertFalse(pointOut.session().isAlive()); \/\/ after outer session freed\n+        assertFalse(pointOut.scope().isAlive()); \/\/ after outer session freed\n@@ -618,1 +619,1 @@\n-    public void testCopy(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n+    public void testCopy(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n@@ -621,1 +622,1 @@\n-                    .addVarg(intLayout, 8), arena.session());\n+                    .addVarg(intLayout, 8), arena.scope());\n@@ -640,1 +641,1 @@\n-    public void testCopyUnusableAfterOriginalClosed(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory,\n+    public void testCopyUnusableAfterOriginalClosed(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory,\n@@ -645,1 +646,1 @@\n-                    .addVarg(intLayout, 8), arena.session());\n+                    .addVarg(intLayout, 8), arena.scope());\n@@ -683,1 +684,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -690,1 +691,1 @@\n-                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -704,1 +705,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -716,1 +717,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, SegmentScope.auto());\n@@ -722,1 +723,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, SegmentScope.auto());\n@@ -729,1 +730,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, SegmentScope.auto());\n@@ -774,1 +775,1 @@\n-                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -824,1 +825,1 @@\n-        return VaList.ofAddress(segment.address(), MemorySession.implicit());\n+        return VaList.ofAddress(segment.address(), SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":43,"deletions":42,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment.MemorySession;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -133,1 +132,1 @@\n-        mismatchSegmentLarge1.session().whileAlive(() -> {\n+        mismatchSegmentLarge1.scope().whileAlive(() -> {\n@@ -155,1 +154,1 @@\n-        mismatchSegmentLarge1.session().whileAlive(() -> {\n+        mismatchSegmentLarge1.scope().whileAlive(() -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n@@ -75,2 +75,2 @@\n-    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.session());\n-    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.session());;\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.scope());\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.scope());;\n@@ -81,2 +81,2 @@\n-    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, arena.session());;\n-    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, arena.session());;\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, arena.scope());;\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, arena.scope());;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -31,0 +30,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -84,2 +84,2 @@\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openShared().session());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openConfined().session());\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openShared().scope());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openConfined().scope());\n@@ -87,1 +87,1 @@\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.implicit());\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, SegmentScope.auto());\n@@ -89,1 +89,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.implicit()));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, SegmentScope.auto()));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -67,1 +67,1 @@\n-        return LINKER.upcallStub(BLANK, BLANK_DESC, MemorySession.implicit());\n+        return LINKER.upcallStub(BLANK, BLANK_DESC, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -40,0 +39,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -72,1 +72,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.implicit());\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -29,1 +30,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -64,1 +64,1 @@\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, arena.session()));\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, arena.scope()));\n@@ -138,1 +138,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,2 +76,2 @@\n-        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n-        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -40,0 +40,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -78,1 +79,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, MemorySession.implicit());\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena.session());\n+        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.session());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -38,0 +38,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -72,1 +73,1 @@\n-            res += MemorySegment.ofAddress(i, i % 100, MemorySession.global()).address();\n+            res += MemorySegment.ofAddress(i, i % 100, SegmentScope.global()).address();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, confinedArena.session());\n-        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, sharedArena.session());\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, confinedArena.scope());\n+        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, sharedArena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -41,0 +40,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -121,1 +121,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n@@ -127,1 +127,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.session());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+    MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n@@ -90,1 +90,1 @@\n-        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena.session());\n+        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -39,0 +39,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -67,1 +68,1 @@\n-        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), MemorySession.global());\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), SegmentScope.global());\n@@ -85,1 +86,1 @@\n-                    MemorySession.global()\n+                    SegmentScope.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -63,1 +63,1 @@\n-    SegmentAllocator arenaAllocator = new RingAllocator(arena.session());\n+    SegmentAllocator arenaAllocator = new RingAllocator(arena.scope());\n@@ -84,1 +84,1 @@\n-        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, arena.session()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, arena.scope()));\n@@ -151,1 +151,1 @@\n-        public RingAllocator(MemorySession session) {\n+        public RingAllocator(SegmentScope session) {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -40,0 +40,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -70,1 +71,1 @@\n-        srcSegmentImplicit = MemorySegment.allocateNative(size, MemorySession.implicit());\n+        srcSegmentImplicit = MemorySegment.allocateNative(size, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -69,2 +70,2 @@\n-            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, MemorySession.global());\n-            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, MemorySession.global());\n+            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, SegmentScope.global());\n+            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, SegmentScope.global());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -38,0 +38,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -133,1 +134,1 @@\n-            fd, MemorySession.global()\n+            fd, SegmentScope.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                            .addVarg(C_LONG_LONG, 3L), arena.session());\n+                            .addVarg(C_LONG_LONG, 3L), arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        data = MemorySegment.allocateNative(JAVA_INT, arena.session());\n+        data = MemorySegment.allocateNative(JAVA_INT, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        this.segment = MemorySegment.allocateNative(LAYOUT, arena.session());\n+        this.segment = MemorySegment.allocateNative(LAYOUT, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -72,2 +72,2 @@\n-    nativeIn = MemorySegment.allocateNative(size, MemorySession.implicit());\n-    nativeOut = MemorySegment.allocateNative(size, MemorySession.implicit());\n+    nativeIn = MemorySegment.allocateNative(size, SegmentScope.auto());\n+    nativeOut = MemorySegment.allocateNative(size, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -88,2 +88,2 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n@@ -167,2 +167,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.session());\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.session());\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.scope());\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -93,2 +93,2 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n@@ -165,2 +165,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.session());\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.session());\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.scope());\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}