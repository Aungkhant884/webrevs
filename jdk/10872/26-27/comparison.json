{"files":[{"patch":"@@ -132,1 +132,9 @@\n-     * @throws IllegalStateException if the arena has already been {@linkplain #close() closed}.\n+     *\n+     * @apiNote This operation is not idempotent; that is, closing an already closed arena <em>always<\/em> results in an\n+     * exception being thrown. This reflects a deliberate design choice: arena state transitions should be\n+     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n+     * logic.\n+     *\n+     * @see SegmentScope#isAlive()\n+     *\n+     * @throws IllegalStateException if the arena has already been closed.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n- * it can be accessed by multiple threads. If the segment is associatd with an arena scope, then it can only be\n+ * it can be accessed by multiple threads. If the segment is associated with an arena scope, then it can only be\n@@ -1283,1 +1283,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.scope().isAccessibleBy(T) == false}.\n@@ -1287,1 +1287,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.scope().isAccessibleBy(T) == false}.\n@@ -1330,1 +1330,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment().scope().isAccessibleBy(T) == false}.\n@@ -1334,1 +1334,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment().scope().isAccessibleBy(T) == false}.\n@@ -2215,1 +2215,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.scope().isAccessibleBy(T) == false}.\n@@ -2219,1 +2219,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.scope().isAccessibleBy(T) == false}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * A segment scope controls access to a memory segment.\n+ * A segment scope controls access to memory segments.\n@@ -10,1 +10,1 @@\n- * A memory segment can only be accessed while its scope is {@linkplain #isAlive() alive}. Moreoever,\n+ * A memory segment can only be accessed while its scope is {@linkplain #isAlive() alive}. Moreover,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        } catch (Throwable ex) {\n+        } catch (Exception ex) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}