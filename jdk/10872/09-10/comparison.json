{"files":[{"patch":"@@ -36,2 +36,2 @@\n- * An arena is a {@linkplain AutoCloseable closeable} segment allocator that has a bounded {@link #session() memory session}.\n- * The arena's session is created when the arena is created, and ends when the arena is {@linkplain #close() closed}.\n+ * An arena is a {@linkplain AutoCloseable closeable} segment allocator that has a bounded {@linkplain MemorySession memory session}.\n+ * The arena's session starts when the arena is created, and ends when the arena is {@linkplain #close() closed}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -59,0 +62,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,9 +71,1 @@\n- * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n- * as described below:\n- * <ul>\n- * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n- * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n- * <\/ul>\n- * <p>\n- * The downcall method handle type, derived as above, might be decorated by additional leading parameters,\n- * in the given order if both are present:\n+ * The downcall method handle type, might then be decorated by additional leading parameters, in the given order if both are present:\n@@ -95,8 +87,3 @@\n- * The type of the provided method handle has to {@linkplain FunctionDescriptor#toMethodType() match} the Java\n- * {@linkplain java.lang.invoke.MethodType method type} associated with the upcall stub, which is derived from the argument\n- * and return layouts in the function descriptor. More specifically, given each layout {@code L} in the function descriptor,\n- * a corresponding carrier {@code C} is inferred, as described below:\n- * <ul>\n- * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n- * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n- * <\/ul>\n+ * The type of the provided method handle's type has to match the method type associated with the upcall stub,\n+ * which is {@linkplain FunctionDescriptor#toMethodType() derived} from the provided function descriptor.\n+ * <p>\n@@ -119,3 +106,3 @@\n- *     <li>The invocation occurs in same thread as the one {@linkplain MemorySession#isAccessibleBy(Thread) owning} the memory session of {@code R},\n- *     if said session is confined. Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n- *     <li>The memory session of {@code R} is <em>kept alive<\/em> (and cannot be closed) during the invocation.<\/li>\n+ *     <li>The invocation occurs in a thread {@code T} such that {@code A.session().isAccessibleBy(T) == true}.\n+ *     Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n+ *     <li>The memory session of {@code A} is <em>kept alive<\/em> (and cannot be closed) during the invocation.<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -644,1 +644,4 @@\n-    long mismatch(MemorySegment other);\n+    default long mismatch(MemorySegment other) {\n+        Objects.requireNonNull(other);\n+        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n- * Segments associated with a memory session can only be accessed while the session is {@linkplain #isAlive() alive},\n- * and by the {@linkplain #isAccessibleBy(Thread) thread} associated with the session (if any).\n+ * Segments associated with a memory session can only be accessed while the session is {@linkplain #isAlive() alive}.\n@@ -41,1 +40,1 @@\n- * memory segments associated with unbounded sessions can be accessed from any thread.\n+ * memory segments associated with unbounded sessions can be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n@@ -67,2 +66,2 @@\n- * if a program references to one or more segments associated with that session. This means that implicitly managed\n- * session can naturally support safe access from multiple threads.\n+ * if a program references to one or more segments associated with that session. This means that memory segments associated\n+ * with implicitly managed can be safely {@linkplain #isAccessibleBy(Thread) accessed} from multiple threads.\n@@ -90,1 +89,1 @@\n-     * {@return {@code true} if the provided thread can access segments associated with this memory session}\n+     * {@return {@code true} if the provided thread can access and\/or obtain segments associated with this memory session}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        ((MemorySessionImpl) session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -45,0 +48,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * A variable argument list segment can be created using the {@link #make(Consumer, MemorySession)} factory, as follows:\n+ * A variable argument list can be created using the {@link #make(Consumer, MemorySession)} factory, as follows:\n@@ -50,1 +50,1 @@\n- * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated a variable\n+ * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated with a variable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -136,0 +139,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -150,0 +156,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -153,0 +162,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -156,0 +168,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -171,0 +186,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -174,0 +192,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -177,0 +198,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -192,0 +216,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -195,0 +222,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -198,0 +228,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -213,0 +246,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -216,0 +252,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -219,0 +258,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -234,0 +276,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -237,0 +282,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -240,0 +288,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -255,0 +306,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -258,0 +312,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -261,0 +318,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -276,0 +336,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -279,0 +342,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -282,0 +348,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -297,0 +366,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -300,0 +372,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -303,0 +378,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -318,0 +396,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -321,0 +402,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -324,0 +408,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -356,2 +443,1 @@\n-     * ADDRESS.of(ByteOrder.nativeOrder())\n-     *             .withBitAlignment(<address size>);\n+     * MemoryLayout.valueLayout(MemorySegment.class, ByteOrder.nativeOrder());\n@@ -367,1 +453,1 @@\n-     * JAVA_BYTE.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder());\n@@ -377,1 +463,1 @@\n-     * JAVA_BOOLEAN.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder());\n@@ -387,1 +473,1 @@\n-     * JAVA_CHAR.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder());\n@@ -397,1 +483,1 @@\n-     * JAVA_SHORT.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder());\n@@ -407,1 +493,1 @@\n-     * JAVA_INT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder());\n@@ -417,1 +503,1 @@\n-     * JAVA_LONG.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder());\n@@ -427,1 +513,1 @@\n-     * JAVA_FLOAT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n@@ -437,1 +523,1 @@\n-     * JAVA_DOUBLE.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":96,"deletions":10,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -154,6 +154,0 @@\n-    @Override\n-    public long mismatch(MemorySegment other) {\n-        Objects.requireNonNull(other);\n-        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.ref.Reference;\n@@ -38,1 +37,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -159,2 +157,2 @@\n-        return MemorySessionImpl.toSessionImpl(session1).ownerThread() ==\n-                MemorySessionImpl.toSessionImpl(session2).ownerThread();\n+        return ((MemorySessionImpl) session1).ownerThread() ==\n+                ((MemorySessionImpl) session2).ownerThread();\n@@ -177,5 +175,0 @@\n-    @ForceInline\n-    public static MemorySessionImpl toSessionImpl(MemorySession session) {\n-        return (MemorySessionImpl)session;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n@@ -142,1 +142,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n@@ -153,1 +153,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        return MemorySessionImpl.toSessionImpl(session());\n+        return (MemorySessionImpl) session();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        ((MemorySessionImpl) session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -134,3 +133,1 @@\n-        long ptr = UNSAFE.allocateMemory(LAYOUT.byteSize());\n-        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(),\n-                MemorySession.implicit(), () -> UNSAFE.freeMemory(ptr));\n+        MemorySegment ms = MemorySegment.allocateNative(LAYOUT, MemorySession.implicit());\n@@ -142,1 +139,1 @@\n-        return ms;\n+        return ms.asSlice(0, 0);\n@@ -368,1 +365,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.session()).checkValidState();\n@@ -408,0 +405,1 @@\n+        \/\/ make sure that returned segment cannot be accessed\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.session()).checkValidState();\n@@ -170,1 +170,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.session()).checkValidState();\n@@ -176,0 +176,1 @@\n+        \/\/ make sure that returned segment cannot be accessed\n@@ -185,1 +186,1 @@\n-            MemorySessionImpl.toSessionImpl(session).checkValidState();\n+            ((MemorySessionImpl) session).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-    private static final Unsafe U = Unsafe.getUnsafe();\n@@ -143,3 +142,1 @@\n-        long ptr = U.allocateMemory(LAYOUT.byteSize());\n-        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(),\n-                MemorySession.implicit(), () -> U.freeMemory(ptr));\n+        MemorySegment base = MemorySegment.allocateNative(LAYOUT, MemorySession.implicit());\n@@ -150,1 +147,1 @@\n-        return base;\n+        return base.asSlice(0, 0);\n@@ -313,1 +310,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.session()).checkValidState();\n@@ -346,0 +343,1 @@\n+        \/\/ make sure that returned segment cannot be accessed\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.session()).checkValidState();\n@@ -162,1 +162,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.session()).checkValidState();\n@@ -168,0 +168,1 @@\n+        \/\/ make sure that returned segment cannot be accessed\n@@ -177,1 +178,1 @@\n-            MemorySessionImpl.toSessionImpl(session).checkValidState();\n+            ((MemorySessionImpl) session).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1216,1 +1216,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-        MemorySessionImpl parentImpl = MemorySessionImpl.toSessionImpl(parent);\n+        MemorySessionImpl parentImpl = (MemorySessionImpl) parent;\n@@ -336,1 +336,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-            { 0b01,          true  }, \/\/ zero least significant bit, but non-zero first byte\n+            { 0b10,          true  }, \/\/ zero least significant bit, but non-zero first byte\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}