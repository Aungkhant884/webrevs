{"files":[{"patch":"@@ -32,1 +32,1 @@\n- * An arena controls the lifecycle of one or more memory segments, providing both flexible allocation and timely deallocation.\n+ * An arena controls the lifecycle of memory segments, providing both flexible allocation and timely deallocation.\n@@ -35,1 +35,1 @@\n- * the arena scope becomes not {@linkplain SegmentScope#isAlive() alive}. As a result, all the\n+ * the arena scope is no longer {@linkplain SegmentScope#isAlive() alive}. As a result, all the\n@@ -79,1 +79,1 @@\n- * can be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by multiple threads. This might be useful when\n+ * can be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread. This might be useful when\n@@ -100,2 +100,7 @@\n-     * More generally implementations of this method must return a native method featuring the requested size,\n-     * and that is compatible with the provided alignment constraint.\n+     * More generally implementations of this method must return a native segment featuring the requested size,\n+     * and that is compatible with the provided alignment constraint. Furthermore, for any two segments\n+     * {@code S1, S2} returned by this method, the following invariant must hold:\n+     *\n+     * {@snippet lang = java:\n+     * S1.overlappingSlice(S2).isEmpty() == true\n+     *}\n@@ -124,1 +129,1 @@\n-     * Closes this arena. If this method completes normally, the arena scope becomes not {@linkplain SegmentScope#isAlive() alive},\n+     * Closes this arena. If this method completes normally, the arena scope is no longer {@linkplain SegmentScope#isAlive() alive},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"}]}