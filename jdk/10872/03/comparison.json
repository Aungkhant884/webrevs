{"files":[{"patch":"@@ -213,17 +213,1 @@\n-  if (!_needs_return_buffer) {\n-    \/\/ Unpack native results.\n-    switch (_ret_bt) {\n-      case T_BOOLEAN: __ c2bool(r0);                     break;\n-      case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;\n-      case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;\n-      case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;\n-      case T_INT    : __ sbfx(r0, r0, 0, 32);            break;\n-      case T_DOUBLE :\n-      case T_FLOAT  :\n-        \/\/ Result is in v0 we'll save as needed\n-        break;\n-      case T_VOID: break;\n-      case T_LONG: break;\n-      default       : ShouldNotReachHere();\n-    }\n-  } else {\n+  if (_needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -214,18 +214,1 @@\n-  if (!_needs_return_buffer) {\n-    \/\/ FIXME: this assumes we return in rax\/xmm0, which might not be the case\n-    \/\/ Unpack native results.\n-    switch (_ret_bt) {\n-      case T_BOOLEAN: __ c2bool(rax);            break;\n-      case T_CHAR   : __ movzwl(rax, rax);       break;\n-      case T_BYTE   : __ sign_extend_byte (rax); break;\n-      case T_SHORT  : __ sign_extend_short(rax); break;\n-      case T_INT    : \/* nothing to do *\/        break;\n-      case T_DOUBLE :\n-      case T_FLOAT  :\n-        \/\/ Result is in xmm0 we'll save as needed\n-        break;\n-      case T_VOID: break;\n-      case T_LONG: break;\n-      default       : ShouldNotReachHere();\n-    }\n-  } else {\n+  if (_needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -59,0 +60,1 @@\n+import jdk.internal.module.ModuleBootstrap;\n@@ -259,1 +261,1 @@\n-    Module implAddEnableNativeAccess() {\n+    synchronized Module implAddEnableNativeAccess() {\n@@ -265,1 +267,4 @@\n-     * Update all unnamed modules to allow access to restricted methods.\n+     * Returns {@code true} if this module can access\n+     * <a href=\"foreign\/package-summary.html#restricted\"><em>restricted<\/em><\/a> methods.\n+     *\n+     * @return {@code true} if this module can access <em>restricted<\/em> methods.\n@@ -267,2 +272,48 @@\n-    static void implAddEnableNativeAccessAllUnnamed() {\n-        ALL_UNNAMED_MODULE.enableNativeAccess = true;\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public boolean isNativeAccessEnabled() {\n+        Module target = moduleForNativeAccess();\n+        synchronized(target) {\n+            return target.enableNativeAccess;\n+        }\n+    }\n+\n+    \/\/ Returns the Module object that holds the enableNativeAccess\n+    \/\/ flag for this module.\n+    private Module moduleForNativeAccess() {\n+        return isNamed() ? this : ALL_UNNAMED_MODULE;\n+    }\n+\n+    \/\/ This is invoked from Reflection.ensureNativeAccess\n+    void ensureNativeAccess(Class<?> owner, String methodName) {\n+        \/\/ The target module whose enableNativeAccess flag is ensured\n+        Module target = moduleForNativeAccess();\n+        \/\/ racy read of the enable native access flag\n+        boolean isNativeAccessEnabled = target.enableNativeAccess;\n+        if (!isNativeAccessEnabled) {\n+            synchronized (target) {\n+                \/\/ safe read of the enableNativeAccess of the target module\n+                isNativeAccessEnabled = target.enableNativeAccess;\n+\n+                \/\/ check again with the safely read flag\n+                if (isNativeAccessEnabled) {\n+                    \/\/ another thread beat us to it - nothing to do\n+                    return;\n+                } else if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n+                    throw new IllegalCallerException(\"Illegal native access from: \" + this);\n+                } else {\n+                    \/\/ warn and set flag, so that only one warning is reported per module\n+                    String cls = owner.getName();\n+                    String mtd = cls + \"::\" + methodName;\n+                    String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n+                    String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n+                    System.err.printf(\"\"\"\n+                        WARNING: A restricted method in %s has been called\n+                        WARNING: %s has been called by %s\n+                        WARNING: Use --enable-native-access=%s to avoid a warning for this module\n+                        %n\"\"\", cls, mtd, mod, modflag);\n+\n+                    \/\/ set the flag\n+                    target.enableNativeAccess = true;\n+                }\n+            }\n+        }\n@@ -271,0 +322,1 @@\n+\n@@ -272,1 +324,1 @@\n-     * Returns true if module m can access restricted methods.\n+     * Update all unnamed modules to allow access to restricted methods.\n@@ -274,4 +326,4 @@\n-    boolean implIsEnableNativeAccess() {\n-        return isNamed() ?\n-                enableNativeAccess :\n-                ALL_UNNAMED_MODULE.enableNativeAccess;\n+    static void implAddEnableNativeAccessToAllUnnamed() {\n+        synchronized (ALL_UNNAMED_MODULE) {\n+            ALL_UNNAMED_MODULE.enableNativeAccess = true;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":61,"deletions":9,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -52,0 +53,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -55,1 +58,0 @@\n-\n@@ -300,0 +302,31 @@\n+\n+        \/**\n+         * Enables native access for a module in the layer if the caller's module\n+         * has native access.\n+         *\n+         * <p> This method is <a href=\"foreign\/package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain\n+         * from depending on restricted methods, and use safe and supported functionalities,\n+         * where possible.\n+         *\n+         * @param  target\n+         *         The module to update\n+         *\n+         * @return This controller\n+         *\n+         * @throws IllegalArgumentException\n+         *         If {@code target} is not in the module layer\n+         *\n+         * @throws IllegalCallerException\n+         *         If the caller is in a module that does not have native access enabled\n+         *\/\n+         @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+         @CallerSensitive\n+         public Controller enableNativeAccess(Module target) {\n+             ensureInLayer(target);\n+             Reflection.ensureNativeAccess(Reflection.getCallerClass(), Module.class,\n+                 \"enableNativeAccess\");\n+             target.implAddEnableNativeAccess();\n+             return this;\n+         }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2434,2 +2434,2 @@\n-            public void addEnableNativeAccessAllUnnamed() {\n-                Module.implAddEnableNativeAccessAllUnnamed();\n+            public void addEnableNativeAccessToAllUnnamed() {\n+                Module.implAddEnableNativeAccessToAllUnnamed();\n@@ -2437,2 +2437,2 @@\n-            public boolean isEnableNativeAccess(Module m) {\n-                return m.implIsEnableNativeAccess();\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName) {\n+                m.ensureNativeAccess(owner, methodName);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package java.lang.foreign;\n-\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-abstract non-sealed class AbstractLayout implements MemoryLayout {\n-\n-    private final long size;\n-    final long alignment;\n-    private final Optional<String> name;\n-    @Stable\n-    long cachedSize;\n-\n-    public AbstractLayout(long size, long alignment, Optional<String> name) {\n-        this.size = size;\n-        this.alignment = alignment;\n-        this.name = name;\n-    }\n-\n-    @Override\n-    public AbstractLayout withName(String name) {\n-        Objects.requireNonNull(name);\n-        return dup(alignment, Optional.of(name));\n-    }\n-\n-    @Override\n-    public final Optional<String> name() {\n-        return name;\n-    }\n-\n-    abstract AbstractLayout dup(long alignment, Optional<String> name);\n-\n-    @Override\n-    public AbstractLayout withBitAlignment(long alignmentBits) {\n-        checkAlignment(alignmentBits);\n-        return dup(alignmentBits, name);\n-    }\n-\n-    void checkAlignment(long alignmentBitCount) {\n-        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n-                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n-            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n-        }\n-    }\n-\n-    static void checkSize(long size) {\n-        checkSize(size, false);\n-    }\n-\n-    static void checkSize(long size, boolean includeZero) {\n-        if (size < 0 || (!includeZero && size == 0)) {\n-            throw new IllegalArgumentException(\"Invalid size for layout: \" + size);\n-        }\n-    }\n-\n-    @Override\n-    public final long bitAlignment() {\n-        return alignment;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public long byteSize() {\n-        if (cachedSize == 0) {\n-            cachedSize = Utils.bitsToBytesOrThrow(bitSize(),\n-                    () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n-        }\n-        return cachedSize;\n-    }\n-\n-    @Override\n-    public long bitSize() {\n-        return size;\n-    }\n-\n-    String decorateLayoutString(String s) {\n-        if (name().isPresent()) {\n-            s = String.format(\"%s(%s)\", s, name().get());\n-        }\n-        if (!hasNaturalAlignment()) {\n-            s = alignment + \"%\" + s;\n-        }\n-        return s;\n-    }\n-\n-    boolean hasNaturalAlignment() {\n-        return size == alignment;\n-    }\n-\n-    @Override\n-    public boolean isPadding() {\n-        return this instanceof PaddingLayout;\n-    }\n-\n-    \/\/ the following methods have to copy the same Javadoc as in MemoryLayout, or subclasses will just show\n-    \/\/ the Object methods javadoc\n-\n-    \/**\n-     * {@return the hash code value for this layout}\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(name, size, alignment);\n-    }\n-\n-    \/**\n-     * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified\n-     * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of\n-     * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional\n-     * conditions must be satisfied:\n-     * <ul>\n-     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n-     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n-     *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and\n-     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal<\/li>\n-     *     <li>two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},\n-     *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n-     * <\/ul>\n-     *\n-     * @param other the object to be compared for equality with this layout.\n-     * @return {@code true} if the specified object is equal to this layout.\n-     *\/\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-\n-        return other instanceof AbstractLayout otherLayout &&\n-                name.equals(otherLayout.name) &&\n-                size == otherLayout.size &&\n-                alignment == otherLayout.alignment;\n-    }\n-\n-    \/**\n-     * {@return the string representation of this layout}\n-     *\/\n-    public abstract String toString();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AbstractLayout.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.foreign;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * An object that may be projected down to a {@linkplain #address() memory address}.\n- * Examples of addressable types are {@link MemorySegment}, {@link MemoryAddress} and {@link VaList}.\n- * <p>\n- * The {@link Addressable} type is used by a {@linkplain Linker linker} to model the types of\n- * {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n- * (e.g. memory addresses, variable argument lists and upcall stubs).\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface Addressable permits MemorySegment, MemoryAddress, VaList {\n-\n-    \/**\n-     * {@return the {@linkplain MemoryAddress memory address} associated with this addressable}\n-     *\/\n-    MemoryAddress address();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Addressable.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -28,4 +28,1 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n+import java.lang.invoke.MethodType;\n@@ -34,3 +31,3 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n+import java.util.List;\n+\n+import jdk.internal.foreign.FunctionDescriptorImpl;\n@@ -42,1 +39,1 @@\n- * {@linkplain Linker#downcallHandle(Addressable, FunctionDescriptor) downcall method handles} or\n+ * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor, Linker.Option...) downcall method handles} or\n@@ -46,1 +43,1 @@\n- * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -52,9 +49,1 @@\n-public sealed class FunctionDescriptor permits FunctionDescriptor.VariadicFunction {\n-\n-    private final MemoryLayout resLayout;\n-    private final List<MemoryLayout> argLayouts;\n-\n-    private FunctionDescriptor(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n-        this.resLayout = resLayout;\n-        this.argLayouts = argLayouts;\n-    }\n+public sealed interface FunctionDescriptor permits FunctionDescriptorImpl {\n@@ -65,3 +54,1 @@\n-    public Optional<MemoryLayout> returnLayout() {\n-        return Optional.ofNullable(resLayout);\n-    }\n+    Optional<MemoryLayout> returnLayout();\n@@ -72,51 +59,1 @@\n-    public List<MemoryLayout> argumentLayouts() {\n-        return Collections.unmodifiableList(argLayouts);\n-    }\n-\n-    \/**\n-     * Creates a function descriptor with the given return and argument layouts.\n-     * @param resLayout the return layout.\n-     * @param argLayouts the argument layouts.\n-     * @return the new function descriptor.\n-     *\/\n-    public static FunctionDescriptor of(MemoryLayout resLayout, MemoryLayout... argLayouts) {\n-        Objects.requireNonNull(resLayout);\n-        Objects.requireNonNull(argLayouts);\n-        Arrays.stream(argLayouts).forEach(Objects::requireNonNull);\n-        return new FunctionDescriptor(resLayout, List.of(argLayouts));\n-    }\n-\n-    \/**\n-     * Creates a function descriptor with the given argument layouts and no return layout.\n-     * @param argLayouts the argument layouts.\n-     * @return the new function descriptor.\n-     *\/\n-    public static FunctionDescriptor ofVoid(MemoryLayout... argLayouts) {\n-        Objects.requireNonNull(argLayouts);\n-        Arrays.stream(argLayouts).forEach(Objects::requireNonNull);\n-        return new FunctionDescriptor(null, List.of(argLayouts));\n-    }\n-\n-    \/**\n-     * Creates a specialized variadic function descriptor, by appending given variadic layouts to this\n-     * function descriptor argument layouts. The resulting function descriptor can report the position\n-     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n-     * in any way: for instance, calling {@link #changeReturnLayout(MemoryLayout)} on the resulting descriptor\n-     * will throw an {@link UnsupportedOperationException}.\n-     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n-     * @return a variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n-     *\/\n-    public FunctionDescriptor asVariadic(MemoryLayout... variadicLayouts) {\n-        Objects.requireNonNull(variadicLayouts);\n-        Arrays.stream(variadicLayouts).forEach(Objects::requireNonNull);\n-        return variadicLayouts.length == 0 ? this : new VariadicFunction(this, variadicLayouts);\n-    }\n-\n-    \/**\n-     * The index of the first variadic argument layout (where defined).\n-     * @return The index of the first variadic argument layout, or {@code -1} if this is not a\n-     * {@linkplain #asVariadic(MemoryLayout...) variadic} layout.\n-     *\/\n-    public int firstVariadicArgumentIndex() {\n-        return -1;\n-    }\n+    List<MemoryLayout> argumentLayouts();\n@@ -130,3 +67,1 @@\n-    public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {\n-        return insertArgumentLayouts(argLayouts.size(), addedLayouts);\n-    }\n+    FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts);\n@@ -142,10 +77,1 @@\n-    public FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n-        if (index < 0 || index > argLayouts.size())\n-            throw new IllegalArgumentException(\"Index out of bounds: \" + index);\n-        List<MemoryLayout> added = List.of(addedLayouts); \/\/ null check on array and its elements\n-        List<MemoryLayout> newLayouts = new ArrayList<>(argLayouts.size() + addedLayouts.length);\n-        newLayouts.addAll(argLayouts.subList(0, index));\n-        newLayouts.addAll(added);\n-        newLayouts.addAll(argLayouts.subList(index, argLayouts.size()));\n-        return new FunctionDescriptor(resLayout, newLayouts);\n-    }\n+    FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts);\n@@ -158,4 +84,1 @@\n-    public FunctionDescriptor changeReturnLayout(MemoryLayout newReturn) {\n-        Objects.requireNonNull(newReturn);\n-        return new FunctionDescriptor(newReturn, argLayouts);\n-    }\n+    FunctionDescriptor changeReturnLayout(MemoryLayout newReturn);\n@@ -168,3 +91,1 @@\n-    public FunctionDescriptor dropReturnLayout() {\n-        return new FunctionDescriptor(null, argLayouts);\n-    }\n+    FunctionDescriptor dropReturnLayout();\n@@ -173,15 +94,3 @@\n-     * {@return the string representation of this function descriptor}\n-     *\/\n-    @Override\n-    public String toString() {\n-        return String.format(\"(%s)%s\",\n-                IntStream.range(0, argLayouts.size())\n-                        .mapToObj(i -> (i == firstVariadicArgumentIndex() ?\n-                                \"...\" : \"\") + argLayouts.get(i))\n-                        .collect(Collectors.joining()),\n-                returnLayout().map(Object::toString).orElse(\"v\"));\n-    }\n-\n-    \/**\n-     * Compares the specified object with this function descriptor for equality. Returns {@code true} if and only if the specified\n-     * object is also a function descriptor, and all the following conditions are met:\n+     * Returns the method type consisting of the carrier types of the layouts in this function descriptor.\n+     * <p>\n+     * The carrier type of a layout is determined as follows:\n@@ -189,3 +98,3 @@\n-     *     <li>the two function descriptors have equals return layouts (see {@link MemoryLayout#equals(Object)}), or both have no return layout;<\/li>\n-     *     <li>the two function descriptors have argument layouts that are pair-wise {@linkplain MemoryLayout#equals(Object) equal}; and<\/li>\n-     *     <li>the two function descriptors have the same leading {@linkplain #firstVariadicArgumentIndex() variadic argument index}<\/li>\n+     * <li>If the layout is a {@link ValueLayout} the carrier type is determined through {@link ValueLayout#carrier()}.<\/li>\n+     * <li>If the layout is a {@link GroupLayout} the carrier type is {@link MemorySegment}.<\/li>\n+     * <li>If the layout is a {@link PaddingLayout}, or {@link SequenceLayout} an {@link IllegalArgumentException} is thrown.<\/li>\n@@ -194,2 +103,3 @@\n-     * @param other the object to be compared for equality with this function descriptor.\n-     * @return {@code true} if the specified object is equal to this function descriptor.\n+     * @return the method type consisting of the carrier types of the layouts in this function descriptor\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor can not be mapped to carrier\n+     *                                  types (e.g. if they are sequence layouts or padding layouts).\n@@ -197,7 +107,1 @@\n-    @Override\n-    public boolean equals(Object other) {\n-        return other instanceof FunctionDescriptor f &&\n-                Objects.equals(resLayout, f.resLayout) &&\n-                Objects.equals(argLayouts, f.argLayouts) &&\n-                firstVariadicArgumentIndex() == f.firstVariadicArgumentIndex();\n-    }\n+    MethodType toMethodType();\n@@ -206,1 +110,4 @@\n-     * {@return the hash code value for this function descriptor}\n+     * Creates a function descriptor with the given return and argument layouts.\n+     * @param resLayout the return layout.\n+     * @param argLayouts the argument layouts.\n+     * @return the new function descriptor.\n@@ -208,3 +115,4 @@\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(argLayouts, resLayout, firstVariadicArgumentIndex());\n+    static FunctionDescriptor of(MemoryLayout resLayout, MemoryLayout... argLayouts) {\n+        Objects.requireNonNull(resLayout);\n+        \/\/ Null checks are implicit in List.of(argLayouts)\n+        return FunctionDescriptorImpl.of(resLayout, List.of(argLayouts));\n@@ -213,34 +121,8 @@\n-    static final class VariadicFunction extends FunctionDescriptor {\n-\n-        private final int firstVariadicIndex;\n-\n-        public VariadicFunction(FunctionDescriptor descriptor, MemoryLayout... argLayouts) {\n-            super(descriptor.returnLayout().orElse(null),\n-                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toList());\n-            this.firstVariadicIndex = descriptor.argumentLayouts().size();\n-        }\n-\n-        @Override\n-        public int firstVariadicArgumentIndex() {\n-            return firstVariadicIndex;\n-        }\n-\n-        @Override\n-        public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public FunctionDescriptor changeReturnLayout(MemoryLayout newReturn) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public FunctionDescriptor dropReturnLayout() {\n-            throw new UnsupportedOperationException();\n-        }\n+    \/**\n+     * Creates a function descriptor with the given argument layouts and no return layout.\n+     * @param argLayouts the argument layouts.\n+     * @return the new function descriptor.\n+     *\/\n+    static FunctionDescriptor ofVoid(MemoryLayout... argLayouts) {\n+        \/\/ Null checks are implicit in List.of(argLayouts)\n+        return FunctionDescriptorImpl.ofVoid(List.of(argLayouts));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":39,"deletions":157,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Collections;\n@@ -30,4 +29,0 @@\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.LongBinaryOperator;\n-import java.util.stream.Collectors;\n@@ -48,49 +43,1 @@\n-public final class GroupLayout extends AbstractLayout implements MemoryLayout {\n-\n-    \/**\n-     * The group kind.\n-     *\/\n-    enum Kind {\n-        \/**\n-         * A 'struct' kind.\n-         *\/\n-        STRUCT(\"\", Math::addExact),\n-        \/**\n-         * A 'union' kind.\n-         *\/\n-        UNION(\"|\", Math::max);\n-\n-        final String delimTag;\n-        final LongBinaryOperator sizeOp;\n-\n-        Kind(String delimTag, LongBinaryOperator sizeOp) {\n-            this.delimTag = delimTag;\n-            this.sizeOp = sizeOp;\n-        }\n-\n-        long sizeof(List<MemoryLayout> elems) {\n-            long size = 0;\n-            for (MemoryLayout elem : elems) {\n-                size = sizeOp.applyAsLong(size, elem.bitSize());\n-            }\n-            return size;\n-        }\n-\n-        long alignof(List<MemoryLayout> elems) {\n-            return elems.stream().mapToLong(MemoryLayout::bitAlignment).max() \/\/ max alignment in case we have member layouts\n-                    .orElse(1); \/\/ or minimal alignment if no member layout is given\n-        }\n-    }\n-\n-    private final Kind kind;\n-    private final List<MemoryLayout> elements;\n-\n-    GroupLayout(Kind kind, List<MemoryLayout> elements) {\n-        this(kind, elements, kind.alignof(elements), Optional.empty());\n-    }\n-\n-    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Optional<String> name) {\n-        super(kind.sizeof(elements), alignment, name);\n-        this.kind = kind;\n-        this.elements = elements;\n-    }\n+public sealed interface GroupLayout extends MemoryLayout permits StructLayout, UnionLayout {\n@@ -107,3 +54,1 @@\n-    public List<MemoryLayout> memberLayouts() {\n-        return Collections.unmodifiableList(elements);\n-    }\n+    List<MemoryLayout> memberLayouts();\n@@ -111,3 +56,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -115,12 +57,1 @@\n-    public String toString() {\n-        return decorateLayoutString(elements.stream()\n-                .map(Object::toString)\n-                .collect(Collectors.joining(kind.delimTag, \"[\", \"]\")));\n-    }\n-\n-    \/**\n-     * {@return {@code true}, if this group layout is a struct layout}\n-     *\/\n-    public boolean isStruct() {\n-        return kind == Kind.STRUCT;\n-    }\n+    GroupLayout withName(String name);\n@@ -128,55 +59,0 @@\n-    \/**\n-     * {@return {@code true}, if this group layout is a union layout}\n-     *\/\n-    public boolean isUnion() {\n-        return kind == Kind.UNION;\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof GroupLayout otherGroup &&\n-                kind == otherGroup.kind &&\n-                elements.equals(otherGroup.elements);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), kind, elements);\n-    }\n-\n-    @Override\n-    GroupLayout dup(long alignment, Optional<String> name) {\n-        return new GroupLayout(kind, elements, alignment, name);\n-    }\n-\n-    @Override\n-    boolean hasNaturalAlignment() {\n-        return alignment == kind.alignof(elements);\n-    }\n-\n-    \/\/hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout\n-    \/\/but that causes issues with javadoc, see JDK-8224052\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public GroupLayout withName(String name) {\n-        return (GroupLayout)super.withName(name);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -184,3 +60,1 @@\n-    public GroupLayout withBitAlignment(long alignmentBits) {\n-        return (GroupLayout)super.withBitAlignment(alignmentBits);\n-    }\n+    GroupLayout withBitAlignment(long bitAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":4,"deletions":130,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -35,1 +36,0 @@\n-import java.lang.invoke.MethodType;\n@@ -50,1 +50,1 @@\n- * {@linkplain #downcallHandle(Addressable, FunctionDescriptor) downcall method handles}; and<\/li>\n+ * {@linkplain #downcallHandle(MemorySegment, FunctionDescriptor, Option...) downcall method handles}; and<\/li>\n@@ -65,1 +65,1 @@\n- * {@linkplain #downcallHandle(FunctionDescriptor) Linking a foreign function} is a process which requires a function descriptor,\n+ * {@linkplain #downcallHandle(FunctionDescriptor, Option...) Linking a foreign function} is a process which requires a function descriptor,\n@@ -70,1 +70,1 @@\n- * {@linkplain #downcallType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n+ * {@linkplain FunctionDescriptor#toMethodType() derived} from the argument and return layouts in the function descriptor.\n@@ -74,7 +74,2 @@\n- * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n- *     <ul>\n- *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code MemoryAddress.class},\n- *         then {@code C = Addressable.class};<\/li>\n- *         <li>otherwise, {@code C = E};\n- *     <\/ul><\/li>\n- * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n+ * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n@@ -86,2 +81,2 @@\n- * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a target address},\n- * the downcall method handle type features a leading parameter of type {@link Addressable}, from which the\n+ * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor, Option...) without specifying a target address},\n+ * the downcall method handle type features a leading parameter of type {@link MemorySegment}, from which the\n@@ -100,1 +95,1 @@\n- * The type of the provided method handle has to {@linkplain #upcallType(FunctionDescriptor) match} the Java\n+ * The type of the provided method handle has to {@linkplain FunctionDescriptor#toMethodType() match} the Java\n@@ -105,7 +100,2 @@\n- * <li>If {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n- *     <ul>\n- *         <li>If {@code L} occurs in a return position and {@code E} is {@code MemoryAddress.class},\n- *         then {@code C = Addressable.class};<\/li>\n- *         <li>Otherwise, {@code C = E};\n- *     <\/ul><\/li>\n- * <li>Or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n+ * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n@@ -114,2 +104,2 @@\n- * downcall method handles (as {@link MemorySegment} implements the {@link Addressable} interface) and,\n- * when no longer required, they can be {@linkplain MemorySession#close() released}, via their associated {@linkplain MemorySession session}.\n+ * downcall method handles and, when no longer required, they can be {@linkplain MemorySession#close() released},\n+ * via their associated {@linkplain MemorySession memory session}.\n@@ -124,2 +114,2 @@\n- * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment}\n- * or {@link VaList}):\n+ * the linker runtime guarantees the following for any argument {@code A} of type {@link MemorySegment} whose corresponding\n+ * layout is {@link ValueLayout#ADDRESS}:\n@@ -127,1 +117,1 @@\n- *     <li>The memory session of {@code R} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n+ *     <li>The memory session of {@code A} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n@@ -131,1 +121,1 @@\n- *     <li>The memory session of {@code R} is {@linkplain MemorySession#whileAlive(Runnable) kept alive} (and cannot be closed) during the invocation.<\/li>\n+ *     <li>The memory session of {@code R} is <em>kept alive<\/em> (and cannot be closed) during the invocation.<\/li>\n@@ -133,0 +123,5 @@\n+ * A downcall method handle created from a function descriptor whose return layout is an\n+ * {@linkplain ValueLayout.OfAddress address layout} returns a native segment associated with\n+ * the {@linkplain MemorySession#global() global session}. Under normal conditions, the size of the returned segment is {@code 0}.\n+ * However, if the return layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout,\n+ * then the size of the returned segment is {@code Long.MAX_VALUE}.\n@@ -138,1 +133,1 @@\n- * handle associated with an upcall stub returns a {@linkplain MemoryAddress memory address}, clients must ensure\n+ * handle associated with an upcall stub returns a {@linkplain MemorySegment memory segment}, clients must ensure\n@@ -141,0 +136,6 @@\n+ * <p>\n+ * An upcall stub argument whose corresponding layout is an {@linkplain ValueLayout.OfAddress address layout}\n+ * is a native segment associated with the {@linkplain MemorySession#global() global session}.\n+ * Under normal conditions, the size of this segment argument is {@code 0}. However, if the layout associated with\n+ * the upcall stub argument is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout,\n+ * then the size of the segment argument is {@code Long.MAX_VALUE}.\n@@ -162,2 +163,2 @@\n-     *     to the size and alignment constraints of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n-     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemoryAddress}.\n+     *     to the size and alignment constraint of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n+     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemorySegment}.\n@@ -169,1 +170,1 @@\n-     * {@link #downcallHandle(Addressable, FunctionDescriptor) downcall method handle} or an\n+     * {@link #downcallHandle(MemorySegment, FunctionDescriptor, Option...) downcall method handle} or an\n@@ -174,4 +175,4 @@\n-     * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>}\n-     * function descriptor, in which the specialized signature of a given variable arity callsite is described in full.\n-     * Alternatively, where the foreign library allows it, clients might be able to interact with variadic functions by\n-     * passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n+     * variadic function by using {@linkplain Linker.Option#firstVariadicArg(int) a linker option} to indicate\n+     * the start of the list of variadic arguments, together with a specialized function descriptor describing a\n+     * given variable arity callsite. Alternatively, where the foreign library allows it, clients might be able to\n+     * interact with variadic functions by passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n@@ -202,1 +203,1 @@\n-     * Creates a method handle which can be used to call a target foreign function with the given signature and address.\n+     * Creates a method handle which can be used to call a foreign function with the given signature and address.\n@@ -205,2 +206,2 @@\n-     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker runtime\n-     * to allocate structs returned by-value.\n+     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker to allocate\n+     * structs returned by-value.\n@@ -213,1 +214,1 @@\n-     * @param symbol the address of the target function.\n+     * @param symbol   the address of the target function.\n@@ -215,0 +216,1 @@\n+     * @param options  any linker options.\n@@ -217,1 +219,2 @@\n-     * or if the symbol is {@link MemoryAddress#NULL}\n+     *                                  or if the symbol is {@link MemorySegment#NULL}\n+     * @throws IllegalArgumentException if an invalid combination of linker options is given.\n@@ -219,1 +222,1 @@\n-    default MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function) {\n+    default MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function, Option... options) {\n@@ -221,1 +224,1 @@\n-        return downcallHandle(function).bindTo(symbol);\n+        return downcallHandle(function, options).bindTo(symbol);\n@@ -225,1 +228,1 @@\n-     * Creates a method handle which can be used to call a target foreign function with the given signature.\n+     * Creates a method handle which can be used to call a foreign function with the given signature.\n@@ -227,1 +230,1 @@\n-     * entry point, of type {@link Addressable}, which is used to specify the address of the target function\n+     * entry point, of type {@link MemorySegment}, which is used to specify the address of the target function\n@@ -232,1 +235,1 @@\n-     * which will be used by the linker runtime to allocate structs returned by-value.\n+     * which will be used by the linker to allocate structs returned by-value.\n@@ -234,2 +237,2 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link Addressable} parameter passed to it is\n-     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link MemorySegment} parameter passed to it is\n+     * associated with the {@link MemorySegment#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n@@ -238,0 +241,1 @@\n+     * @param options  any linker options.\n@@ -241,0 +245,1 @@\n+     * @throws IllegalArgumentException if an invalid combination of linker options is given.\n@@ -242,1 +247,1 @@\n-    MethodHandle downcallHandle(FunctionDescriptor function);\n+    MethodHandle downcallHandle(FunctionDescriptor function, Option... options);\n@@ -249,1 +254,1 @@\n-     * The returned memory segment's base address points to the newly allocated upcall stub, and is associated with\n+     * The returned memory segment's address points to the newly allocated upcall stub, and is associated with\n@@ -261,1 +266,1 @@\n-     * @return a zero-length segment whose base address is the address of the upcall stub.\n+     * @return a zero-length segment whose address is the address of the upcall stub.\n@@ -287,4 +292,3 @@\n-     * {@return the downcall method handle {@linkplain MethodType type} associated with the given function descriptor}\n-     * @param functionDescriptor a function descriptor.\n-     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n-     * (e.g. if they are sequence layouts or padding layouts).\n+     * A linker option that can be used to indicate additional linking requirements to the linker,\n+     * besides what is described by a function descriptor.\n+     * @since 20\n@@ -292,3 +296,3 @@\n-    static MethodType downcallType(FunctionDescriptor functionDescriptor) {\n-        return SharedUtils.inferMethodType(functionDescriptor, false);\n-    }\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    sealed interface Option\n+            permits LinkerOptions.FirstVariadicArg {\n@@ -296,8 +300,8 @@\n-    \/**\n-     * {@return the method handle {@linkplain MethodType type} associated with an upcall stub with the given function descriptor}\n-     * @param functionDescriptor a function descriptor.\n-     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n-     * (e.g. if they are sequence layouts or padding layouts).\n-     *\/\n-    static MethodType upcallType(FunctionDescriptor functionDescriptor) {\n-        return SharedUtils.inferMethodType(functionDescriptor, true);\n+        \/**\n+         * {@return A linker option used to denote the index of the first variadic argument layout in a\n+         *          foreign function call}\n+         * @param index the index of the first variadic argument in a downcall handle linkage request.\n+         *\/\n+        static Option firstVariadicArg(int index) {\n+            return new LinkerOptions.FirstVariadicArg(index);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":69,"deletions":65,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -1,854 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package java.lang.foreign;\n-\n-import java.nio.ByteOrder;\n-\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.reflect.CallerSensitive;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * A memory address models a reference into a memory location. Memory addresses are typically obtained in one of the following ways:\n- * <ul>\n- *     <li>By calling {@link Addressable#address()} on an instance of type {@link Addressable} (e.g. a memory segment);<\/li>\n- *     <li>By invoking a {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle} which returns a pointer;<\/li>\n- *     <li>By reading an address from memory, e.g. via {@link MemorySegment#get(ValueLayout.OfAddress, long)}; and<\/li>\n- *     <li>By the invocation of an {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub} which accepts a pointer.<\/li>\n- * <\/ul>\n- * A memory address is backed by a raw machine pointer, expressed as a {@linkplain #toRawLongValue() long value}.\n- *\n- * <h2 id=\"dereferencing\">Dereferencing memory addresses<\/h2>\n- *\n- * A memory address can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n- * Each dereference method takes a {@linkplain ValueLayout value layout}, which specifies the size,\n- * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n- * For instance, to read an int from a segment, using {@linkplain ByteOrder#nativeOrder() default endianness}, the following code can be used:\n- * {@snippet lang=java :\n- * MemoryAddress address = ...\n- * int value = address.get(ValueLayout.JAVA_INT, 0);\n- * }\n- *\n- * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n- * can be expressed as follows:\n- * {@snippet lang=java :\n- * MemoryAddress address = ...\n- * int value = address.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n- * }\n- *\n- * All the dereference methods in this class are <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>: since\n- * a memory address does not feature temporal nor spatial bounds, the runtime has no way to check the correctness\n- * of the memory dereference operation.\n- *\n- * @implSpec\n- * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface MemoryAddress extends Addressable permits MemoryAddressImpl {\n-\n-    \/**\n-     * {@return the raw long value associated with this memory address}\n-     *\/\n-    long toRawLongValue();\n-\n-    \/**\n-     * Returns a memory address at given offset from this address.\n-     * @param offset specified offset (in bytes), relative to this address, which should be used to create the new address.\n-     *               Might be negative.\n-     * @return a memory address with the given offset from current one.\n-     *\/\n-    MemoryAddress addOffset(long offset);\n-\n-    \/**\n-     * Reads a UTF-8 encoded, null-terminated string from this address at the given offset.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a Java string constructed from the bytes read from the given starting address ({@code toRawLongValue() + offset})\n-     * up to (but not including) the first {@code '\\0'} terminator character (assuming one is found).\n-     * @throws IllegalArgumentException if the size of the UTF-8 string is greater than the largest string supported by the platform.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    String getUtf8String(long offset);\n-\n-    \/**\n-     * Writes the given string to this address at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param str the Java string to be written at this address.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setUtf8String(long offset, String str);\n-\n-    \/**\n-     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n-     * object is also an address, and it refers to the same memory location as this address.\n-     *\n-     * @param that the object to be compared for equality with this address.\n-     * @return {@code true} if the specified object is equal to this address.\n-     *\/\n-    @Override\n-    boolean equals(Object that);\n-\n-    \/**\n-     * {@return the hash code value for this address}\n-     *\/\n-    @Override\n-    int hashCode();\n-\n-    \/**\n-     * The memory address instance modelling the {@code NULL} address.\n-     *\/\n-    MemoryAddress NULL = new MemoryAddressImpl(0L);\n-\n-    \/**\n-     * Creates a memory address from the given long value.\n-     * @param value the long value representing a raw address.\n-     * @return a memory address with the given raw long value.\n-     *\/\n-    static MemoryAddress ofLong(long value) {\n-        return value == 0 ?\n-                NULL :\n-                new MemoryAddressImpl(value);\n-    }\n-\n-    \/**\n-     * Reads a byte from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a byte value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    byte get(ValueLayout.OfByte layout, long offset);\n-\n-    \/**\n-     * Writes a byte into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the byte value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfByte layout, long offset, byte value);\n-\n-    \/**\n-     * Reads a boolean from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a boolean value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    boolean get(ValueLayout.OfBoolean layout, long offset);\n-\n-    \/**\n-     * Writes a boolean into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the boolean value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfBoolean layout, long offset, boolean value);\n-\n-    \/**\n-     * Reads a char from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a char value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    char get(ValueLayout.OfChar layout, long offset);\n-\n-    \/**\n-     * Writes a char into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the char value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfChar layout, long offset, char value);\n-\n-    \/**\n-     * Reads a short from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a short value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    short get(ValueLayout.OfShort layout, long offset);\n-\n-    \/**\n-     * Writes a short into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the short value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfShort layout, long offset, short value);\n-\n-    \/**\n-     * Reads an int from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return an int value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    int get(ValueLayout.OfInt layout, long offset);\n-\n-    \/**\n-     * Writes an int into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the int value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfInt layout, long offset, int value);\n-\n-    \/**\n-     * Reads a float from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a float value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    float get(ValueLayout.OfFloat layout, long offset);\n-\n-    \/**\n-     * Writes a float into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the float value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfFloat layout, long offset, float value);\n-\n-    \/**\n-     * Reads a long from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a long value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    long get(ValueLayout.OfLong layout, long offset);\n-\n-    \/**\n-     * Writes a long into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the long value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfLong layout, long offset, long value);\n-\n-    \/**\n-     * Reads a double from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a double value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    double get(ValueLayout.OfDouble layout, long offset);\n-\n-    \/**\n-     * Writes a double into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the double value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfDouble layout, long offset, double value);\n-\n-    \/**\n-     * Reads an address from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return an address value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    MemoryAddress get(ValueLayout.OfAddress layout, long offset);\n-\n-    \/**\n-     * Writes an address into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the address value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfAddress layout, long offset, Addressable value);\n-\n-    \/**\n-     * Reads a char from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a char value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    char getAtIndex(ValueLayout.OfChar layout, long index);\n-\n-    \/**\n-     * Writes a char into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the char value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfChar layout, long index, char value);\n-\n-    \/**\n-     * Reads a short from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a short value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    short getAtIndex(ValueLayout.OfShort layout, long index);\n-\n-    \/**\n-     * Writes a short into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the short value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfShort layout, long index, short value);\n-\n-    \/**\n-     * Reads an int from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return an int value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    int getAtIndex(ValueLayout.OfInt layout, long index);\n-\n-    \/**\n-     * Writes an int into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the int value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfInt layout, long index, int value);\n-\n-    \/**\n-     * Reads a float from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a float value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    float getAtIndex(ValueLayout.OfFloat layout, long index);\n-\n-    \/**\n-     * Writes a float into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the float value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfFloat layout, long index, float value);\n-\n-    \/**\n-     * Reads a long from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a long value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    long getAtIndex(ValueLayout.OfLong layout, long index);\n-\n-    \/**\n-     * Writes a long into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the long value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfLong layout, long index, long value);\n-\n-    \/**\n-     * Reads a double from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a double value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    double getAtIndex(ValueLayout.OfDouble layout, long index);\n-\n-    \/**\n-     * Writes a double into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the double value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfDouble layout, long index, double value);\n-\n-    \/**\n-     * Reads an address from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return an address value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index);\n-\n-    \/**\n-     * Writes an address into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the address value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value);\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":0,"deletions":854,"binary":false,"changes":854,"status":"deleted"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.stream.Collectors;\n@@ -43,0 +42,6 @@\n+import jdk.internal.foreign.layout.MemoryLayoutUtil;\n+import jdk.internal.foreign.layout.PaddingLayoutImpl;\n+import jdk.internal.foreign.layout.SequenceLayoutImpl;\n+import jdk.internal.foreign.layout.StructLayoutImpl;\n+import jdk.internal.foreign.layout.UnionLayoutImpl;\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -168,1 +173,1 @@\n-public sealed interface MemoryLayout permits AbstractLayout, SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n+public sealed interface MemoryLayout permits SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n@@ -188,1 +193,1 @@\n-     * Returns a memory layout with the same size and alignment constraints as this layout,\n+     * Returns a memory layout of the same type with the same size and alignment constraint as this layout,\n@@ -238,2 +243,2 @@\n-     * Returns a memory layout with the same size and name as this layout,\n-     * but with the specified alignment constraints (in bits).\n+     * Returns a memory layout of the same type with the same size and name as this layout,\n+     * but with the specified alignment constraint (in bits).\n@@ -242,1 +247,1 @@\n-     * @return a memory layout with the given alignment constraints.\n+     * @return a memory layout with the given alignment constraint.\n@@ -310,1 +315,1 @@\n-        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.bitsToBytesThrowOffset);\n+        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.BITS_TO_BYTES_THROW_OFFSET);\n@@ -346,1 +351,1 @@\n-        mh = MethodHandles.filterReturnValue(mh, Utils.MH_bitsToBytesOrThrowForOffset);\n+        mh = MethodHandles.filterReturnValue(mh, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET);\n@@ -351,1 +356,1 @@\n-     * Creates an access var handle that can be used to dereference memory at the layout selected by the given layout path,\n+     * Creates an access var handle that can be used to access a memory segment at the layout selected by the given layout path,\n@@ -354,1 +359,1 @@\n-     * The final memory location accessed by the returned var handle can be computed as follows:\n+     * The final address accessed by the returned var handle can be computed as follows:\n@@ -357,1 +362,1 @@\n-     * address = base + offset\n+     * address = base(segment) + offset\n@@ -360,3 +365,4 @@\n-     * where {@code base} denotes the base address expressed by the {@link MemorySegment} access coordinate\n-     * (see {@link MemorySegment#address()} and {@link MemoryAddress#toRawLongValue()}) and {@code offset}\n-     * can be expressed in the following form:\n+     * Where {@code base(segment)} denotes a function that returns the physical base address of the accessed\n+     * memory segment. For native segments, this function just returns the native segment's\n+     * {@linkplain MemorySegment#address() address}. For heap segments, this function is more complex, as the address\n+     * of heap segments is virtualized. The {@code offset} coordinate can be expressed in the following form:\n@@ -381,2 +387,2 @@\n-     * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.\n-     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints.\n+     * @return a var handle which can be used to access a memory segment at the (possibly nested) layout selected by the layout path in {@code elements}.\n+     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraint.\n@@ -461,5 +467,0 @@\n-    \/**\n-     * {@return true, if this layout is a padding layout}\n-     *\/\n-    boolean isPadding();\n-\n@@ -584,1 +585,1 @@\n-     * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional\n+     * the same kind, have the same size, name and alignment constraint. Furthermore, depending on the layout kind, additional\n@@ -591,2 +592,2 @@\n-     *     <li>two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},\n-     *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n+     *     <li>two group layouts are considered equal if they are of the same type (see {@link StructLayout},\n+     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n@@ -618,3 +619,3 @@\n-    static MemoryLayout paddingLayout(long size) {\n-        AbstractLayout.checkSize(size);\n-        return new PaddingLayout(size);\n+    static PaddingLayout paddingLayout(long size) {\n+        MemoryLayoutUtil.checkSize(size);\n+        return PaddingLayoutImpl.of(size);\n@@ -635,1 +636,1 @@\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemoryAddress.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n@@ -646,1 +647,1 @@\n-            return new ValueLayout.OfBoolean(order);\n+            return ValueLayouts.OfBooleanImpl.of(order);\n@@ -648,1 +649,1 @@\n-            return new ValueLayout.OfChar(order);\n+            return ValueLayouts.OfCharImpl.of(order);\n@@ -650,1 +651,1 @@\n-            return new ValueLayout.OfByte(order);\n+            return ValueLayouts.OfByteImpl.of(order);\n@@ -652,1 +653,1 @@\n-            return new ValueLayout.OfShort(order);\n+            return ValueLayouts.OfShortImpl.of(order);\n@@ -654,1 +655,1 @@\n-            return new ValueLayout.OfInt(order);\n+            return ValueLayouts.OfIntImpl.of(order);\n@@ -656,1 +657,1 @@\n-            return new ValueLayout.OfFloat(order);\n+            return ValueLayouts.OfFloatImpl.of(order);\n@@ -658,1 +659,1 @@\n-            return new ValueLayout.OfLong(order);\n+            return ValueLayouts.OfLongImpl.of(order);\n@@ -660,3 +661,3 @@\n-            return new ValueLayout.OfDouble(order);\n-        } else if (carrier == MemoryAddress.class) {\n-            return new ValueLayout.OfAddress(order);\n+            return ValueLayouts.OfDoubleImpl.of(order);\n+        } else if (carrier == MemorySegment.class) {\n+            return ValueLayouts.OfAddressImpl.of(order);\n@@ -669,7 +670,1 @@\n-     * Creates a sequence layout with the given element layout and element count. If the element count has the\n-     * special value {@code -1}, the element count is inferred to be the biggest possible count such that\n-     * the sequence layout size does not overflow, using the following formula:\n-     *\n-     * <blockquote><pre>{@code\n-     * inferredElementCount = Long.MAX_VALUE \/ elementLayout.bitSize();\n-     * }<\/pre><\/blockquote>\n+     * Creates a sequence layout with the given element layout and element count.\n@@ -677,1 +672,1 @@\n-     * @param elementCount the sequence element count; if set to {@code -1}, the sequence element count is inferred.\n+     * @param elementCount the sequence element count.\n@@ -680,2 +675,1 @@\n-     * @throws IllegalArgumentException if {@code elementCount < -1}.\n-     * @throws IllegalArgumentException if {@code elementCount != -1} and the computation {@code elementCount * elementLayout.bitSize()} overflows.\n+     * @throws IllegalArgumentException if {@code elementCount } is negative.\n@@ -684,10 +678,21 @@\n-        if (elementCount == -1) {\n-            \/\/ inferred element count\n-            long inferredElementCount = Long.MAX_VALUE \/ elementLayout.bitSize();\n-            return new SequenceLayout(inferredElementCount, elementLayout);\n-        } else {\n-            \/\/ explicit element count\n-            AbstractLayout.checkSize(elementCount, true);\n-            return wrapOverflow(() ->\n-                    new SequenceLayout(elementCount, Objects.requireNonNull(elementLayout)));\n-        }\n+        MemoryLayoutUtil.checkSize(elementCount, true);\n+        Objects.requireNonNull(elementLayout);\n+        return wrapOverflow(() ->\n+                SequenceLayoutImpl.of(elementCount, elementLayout));\n+    }\n+\n+    \/**\n+     * Creates a sequence layout with the given element layout and the maximum element\n+     * count such that it does not overflow a {@code long}.\n+     *\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n+     * }\n+     *\n+     * @param elementLayout the sequence element layout.\n+     * @return a new sequence layout with the given element layout and maximum element count.\n+     *\/\n+    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n+        Objects.requireNonNull(elementLayout);\n+        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n@@ -704,1 +709,1 @@\n-    static GroupLayout structLayout(MemoryLayout... elements) {\n+    static StructLayout structLayout(MemoryLayout... elements) {\n@@ -707,4 +712,3 @@\n-                new GroupLayout(GroupLayout.Kind.STRUCT,\n-                        Stream.of(elements)\n-                                .map(Objects::requireNonNull)\n-                                .collect(Collectors.toList())));\n+                StructLayoutImpl.of(Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .toList()));\n@@ -719,1 +723,1 @@\n-    static GroupLayout unionLayout(MemoryLayout... elements) {\n+    static UnionLayout unionLayout(MemoryLayout... elements) {\n@@ -721,4 +725,3 @@\n-        return new GroupLayout(GroupLayout.Kind.UNION,\n-                Stream.of(elements)\n-                        .map(Objects::requireNonNull)\n-                        .collect(Collectors.toList()));\n+        return UnionLayoutImpl.of(Stream.of(elements)\n+                .map(Objects::requireNonNull)\n+                .toList());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":71,"deletions":68,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.ref.Cleaner;\n@@ -35,0 +36,1 @@\n+import java.nio.CharBuffer;\n@@ -36,0 +38,1 @@\n+import java.nio.channels.FileChannel.*;\n@@ -37,0 +40,1 @@\n+import java.util.Arrays;\n@@ -46,0 +50,1 @@\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -53,0 +58,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -54,6 +61,3 @@\n- * A memory segment models a contiguous region of memory. A memory segment is associated with both spatial\n- * and temporal bounds (e.g. a {@link MemorySession}). Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location\n- * which falls <em>outside<\/em> the boundaries of the memory segment being accessed. Temporal bounds ensure that memory access\n- * operations on a segment cannot occur after the memory session associated with a memory segment has been closed (see {@link MemorySession#close()}).\n- *\n- * There are many kinds of memory segments:\n+ * A memory segment provides access to a contiguous region of memory.\n+ * <p>\n+ * There are two kinds of memory segments:\n@@ -61,9 +65,2 @@\n- *     <li>{@linkplain MemorySegment#allocateNative(long, long, MemorySession) native memory segments}, backed by off-heap memory;<\/li>\n- *     <li>{@linkplain FileChannel#map(FileChannel.MapMode, long, long, MemorySession) mapped memory segments}, obtained by mapping\n- * a file into main memory ({@code mmap}); the contents of a mapped memory segments can be {@linkplain #force() persisted} and\n- * {@linkplain #load() loaded} to and from the underlying memory-mapped file;<\/li>\n- *     <li>{@linkplain MemorySegment#ofArray(int[]) array segments}, wrapping an existing, heap-allocated Java array; and<\/li>\n- *     <li>{@linkplain MemorySegment#ofBuffer(Buffer) buffer segments}, wrapping an existing {@link Buffer} instance;\n- * buffer memory segments might be backed by either off-heap memory or on-heap memory, depending on the characteristics of the\n- * wrapped buffer instance. For instance, a buffer memory segment obtained from a byte buffer created with the\n- * {@link ByteBuffer#allocateDirect(int)} method will be backed by off-heap memory.<\/li>\n+ *     <li>A <em>heap segment<\/em> is backed by, and provides access to, a region of memory inside the Java heap (an \"on-heap\" region).<\/li>\n+ *     <li>A <em>native segment<\/em> is backed by, and provides access to, a region of memory outside the Java heap (an \"off-heap\" region).<\/li>\n@@ -71,0 +68,13 @@\n+ * Heap segments can be obtained by calling one of the {@link MemorySegment#ofArray(int[])} factory methods.\n+ * These methods return a memory segment backed by the on-heap region that holds the specified Java array.\n+ * <p>\n+ * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, MemorySession)}\n+ * factory methods, which return a memory segment backed by a newly allocated off-heap region with the given size\n+ * and aligned to the given alignment constraint. Alternatively, native segments can be obtained by\n+ * {@link FileChannel#map(MapMode, long, long, MemorySession) mapping} a file into a new off-heap region\n+ * (in some systems, this operation is sometimes referred to as {@code mmap}).\n+ * Segments obtained in this way are called <em>mapped<\/em> segments, and their contents can be {@linkplain #force() persisted} and\n+ * {@linkplain #load() loaded} to and from the underlying memory-mapped file.\n+ * <p>\n+ * Both kinds of segments are read and written using the same methods, known as <a href=\"#segment-deref\">access operations<\/a>.\n+ * An access operation on a memory segment always and only provides access to the region for which the segment was obtained.\n@@ -72,1 +82,1 @@\n- * <h2 id=\"lifecyle-confinement\">Lifecycle and confinement<\/h2>\n+ * <h2 id=\"segment-characteristics\">Characteristics of memory segments<\/h2>\n@@ -74,13 +84,22 @@\n- * Memory segments are associated with a {@linkplain MemorySegment#session() memory session}. As for all resources associated\n- * with a memory session, a segment cannot be accessed after its underlying session has been closed. For instance,\n- * the following code will result in an exception:\n- * {@snippet lang=java :\n- * MemorySegment segment = null;\n- * try (MemorySession session = MemorySession.openConfined()) {\n- *     segment = MemorySegment.allocateNative(8, session);\n- * }\n- * segment.get(ValueLayout.JAVA_LONG, 0); \/\/ already closed!\n- * }\n- * Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning memory\n- * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads;\n- * if it is associated with a confined session, it can only be accessed by the thread which owns the memory session.\n+ * Every memory segment has an {@linkplain #address() address}, expressed as a {@code long} value.\n+ * The nature of a segment's address depends on the kind of the segment:\n+ * <ul>\n+ * <li>The address of a heap segment is not a physical address, but rather an offset within the region of memory\n+ * which backs the segment. The region is inside the Java heap, so garbage collection might cause the region to be\n+ * relocated in physical memory over time, but this is not exposed to clients of the {@code MemorySegment} API who\n+ * see a stable <em>virtualized<\/em> address for a heap segment backed by the region.\n+ * A heap segment obtained from one of the {@link #ofArray(int[])} factory methods has an address of zero.<\/li>\n+ * <li>The address of a native segment (including mapped segments) denotes the physical address of the region of\n+ * memory which backs the segment.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Every memory segment has a {@linkplain #byteSize() size}. The size of a heap segment is derived from the Java array\n+ * from which it is obtained. This size is predictable across Java runtimes.\n+ * The size of a native segment is either passed explicitly\n+ * (as in {@link MemorySegment#allocateNative(long, MemorySession)}) or derived from a {@link MemoryLayout}\n+ * (as in {@link MemorySegment#allocateNative(MemoryLayout, MemorySession)}). The size of a memory segment is typically\n+ * a positive number but may be <a href=\"#wrapping-addresses\">zero<\/a>, but never negative.\n+ * <p>\n+ * The address and size of a memory segment jointly ensure that access operations on the segment cannot fall\n+ * <em>outside<\/em> the boundaries of the region of memory which backs the segment.\n+ * That is, a memory segment has <em>spatial bounds<\/em>.\n@@ -88,5 +107,9 @@\n- * Heap segments are always associated with the {@linkplain MemorySession#global() global} memory session.\n- * This session cannot be closed, and segments associated with it can be considered as <em>always alive<\/em>.\n- * Buffer segments are typically associated with the global memory session, with one exception: buffer segments created\n- * from byte buffer instances obtained calling the {@link #asByteBuffer()} method on a memory segment {@code S}\n- * are associated with the same memory session as {@code S}.\n+ * Every memory segment is associated with a {@linkplain MemorySession memory session}. This ensures that access operations\n+ * on a memory segment cannot occur when the region of memory which backs the memory segment is no longer available\n+ * (e.g. after the memory session associated with the accessed memory segment has been {@linkplain MemorySession#close() closed}).\n+ * That is, a memory segment has <em>temporal bounds<\/em>.\n+ * <p>\n+ * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated memory\n+ * session; that is, if the segment is associated with a {@linkplain MemorySession#openShared() shared session},\n+ * it can be accessed by multiple threads; if it is associated with a {@linkplain MemorySession#openConfined() confined session},\n+ * it can only be accessed by the thread which owns the memory session.\n@@ -94,1 +117,1 @@\n- * <h2 id=\"segment-deref\">Dereferencing memory segments<\/h2>\n+ * <h2 id=\"segment-deref\">Accessing memory segments<\/h2>\n@@ -96,3 +119,3 @@\n- * A memory segment can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n- * Each dereference method takes a {@linkplain ValueLayout value layout}, which specifies the size,\n- * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n+ * A memory segment can be read or written using various access operations provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n+ * Each access operation takes a {@linkplain ValueLayout value layout}, which specifies the size and shape of the value,\n+ * and an offset, expressed in bytes.\n@@ -105,1 +128,1 @@\n- * If the value to be read is stored in memory using {@linkplain ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * If the value to be read is stored in memory using {@linkplain ByteOrder#BIG_ENDIAN big-endian} encoding, the access operation\n@@ -112,1 +135,1 @@\n- * For more complex dereference operations (e.g. structured memory access), clients can obtain a\n+ * For more complex access operations (e.g. structured memory access), clients can obtain a\n@@ -141,3 +164,5 @@\n- * Memory segments support <em>slicing<\/em>. A memory segment can be used to {@linkplain MemorySegment#asSlice(long, long) obtain}\n- * other segments backed by the same underlying memory region, but with <em>stricter<\/em> spatial bounds than the ones\n- * of the original segment:\n+ * Memory segments support {@linkplain MemorySegment#asSlice(long, long) slicing}. Slicing a memory segment\n+ * returns a new memory segment that is backed by the same region of memory as the original. The address of the sliced\n+ * segment is derived from the address of the original segment, by adding an offset (expressed in bytes). The size of\n+ * the sliced segment is either derived implicitly (by subtracting the specified offset from the size of the original segment),\n+ * or provided explicitly. In other words, a sliced segment has <em>stricter<\/em> spatial bounds than those of the original segment:\n@@ -153,1 +178,2 @@\n- * of {@code segment}, and is 10 bytes long. As a result, attempting to read an int value at offset 20 of the\n+ * of {@code segment}, and is 10 bytes long. That is, the address of the {@code slice} is {@code segment.address() + 50},\n+ * and its size is 10. As a result, attempting to read an int value at offset 20 of the\n@@ -175,4 +201,16 @@\n- * When dereferencing a memory segment using a layout, the runtime must check that the segment address being dereferenced\n- * matches the layout's {@linkplain MemoryLayout#byteAlignment() alignment constraints}. If the segment being\n- * dereferenced is a native segment, then it has a concrete {@linkplain #address() base address}, which can\n- * be used to perform the alignment check. The pseudo-function below demonstrates this:\n+ * Access operations on a memory segment are constrained not only by the spatial and temporal bounds of the segment,\n+ * but also by the <em>alignment constraint<\/em> of the value layout specified to the operation. An access operation can\n+ * access only those offsets in the segment that denote addresses in physical memory which are <em>aligned<\/em> according\n+ * to the layout. An address in physical memory is <em>aligned<\/em> according to a layout if the address is an integer\n+ * multiple of the layout's alignment constraint. For example, the address 1000 is aligned according to an 8-byte alignment\n+ * constraint (because 1000 is an integer multiple of 8), and to a 4-byte alignment constraint, and to a 2-byte alignment\n+ * constraint; in contrast, the address 1004 is aligned according to a 4-byte alignment constraint, and to a 2-byte alignment\n+ * constraint, but not to an 8-byte alignment constraint.\n+ * Access operations are required to respect alignment because it can impact the performance of access operations, and\n+ * can also determine which access operations are available at a given physical address. For instance,\n+ * {@linkplain java.lang.invoke.VarHandle#compareAndSet(Object...) atomic access operations} operations using\n+ * {@link java.lang.invoke.VarHandle} are only permitted at aligned addresses. In addition, alignment\n+ * applies to an access operation whether the segment being accessed is a native segment or a heap segment.\n+ * <p>\n+ * If the segment being accessed is a native segment, then its {@linkplain #address() address} in physical memory can be\n+ * combined with the offset to obtain the <em>target address<\/em> in physical memory. The pseudo-function below demonstrates this:\n@@ -180,1 +218,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -182,1 +220,1 @@\n- *   return ((segment.address().toRawLongValue() + offset) % layout.byteAlignment()) == 0\n+ *   return ((segment.address() + offset) % layout.byteAlignment()) == 0;\n@@ -186,4 +224,65 @@\n- * If, however, the segment being dereferenced is a heap segment, the above function will not work: a heap\n- * segment's base address is <em>virtualized<\/em> and, as such, cannot be used to construct an alignment check. Instead,\n- * heap segments are assumed to produce addresses which are never more aligned than the element size of the Java array from which\n- * they have originated from, as shown in the following table:\n+ * For example:\n+ * <ul>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint,\n+ * because the target addresses (1000, 1008, 1016, 1024) are 8-byte aligned.\n+ * Access at offsets 1-7 or 9-15 or 17-23 is disallowed because the target addresses would not be 8-byte aligned.<\/li>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ * because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned.\n+ * Access at offsets 1-3 or 5-7 or 9-11 is disallowed because the target addresses would not be 4-byte aligned.<\/li>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint,\n+ * because the target addresses (1000, 1002, 1004, 1006) are 2-byte aligned.\n+ * Access at offsets 1 or 3 or 5 is disallowed because the target addresses would not be 2-byte aligned.<\/li>\n+ * <li>A native segment with address 1004 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ * and at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint.\n+ * Under an 8-byte alignment constraint, it can be accessed at offsets 4, 12, 20, 28, etc.<\/li>\n+ * <li>A native segment with address 1006 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint.\n+ * Under a 4-byte alignment constraint, it can be accessed at offsets 2, 6, 10, 14, etc.\n+ * Under an 8-byte alignment constraint, it can be accessed at offsets 2, 10, 18, 26, etc.\n+ * <li>A native segment with address 1007 can be accessed at offsets 0, 1, 2, 3, etc under a 1-byte alignment constraint.\n+ * Under a 2-byte alignment constraint, it can be accessed at offsets 1, 3, 5, 7, etc.\n+ * Under a 4-byte alignment constraint, it can be accessed at offsets 1, 5, 9, 13, etc.\n+ * Under an 8-byte alignment constraint, it can be accessed at offsets 1, 9, 17, 25, etc.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * The alignment constraint used to access a segment is typically dictated by the shape of the data structure stored\n+ * in the segment. For example, if the programmer wishes to store a sequence of 8-byte values in a native segment, then\n+ * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, MemorySession)}\n+ * or {@link #allocateNative(MemoryLayout, MemorySession)}. These factories ensure that the off-heap region of memory backing\n+ * the returned segment has a starting address that is 8-byte aligned. Subsequently, the programmer can access the\n+ * segment at the offsets of interest -- 0, 8, 16, 24, etc -- in the knowledge that every such access is aligned.\n+ * <p>\n+ * If the segment being accessed is a heap segment, then determining whether access is aligned is more complex.\n+ * The address of the segment in physical memory is not known, and is not even fixed (it may change when the segment\n+ * is relocated during garbage collection). This means that the address cannot be combined with the specified offset to\n+ * determine a target address in physical memory. Since the alignment constraint <em>always<\/em> refers to alignment of\n+ * addresses in physical memory, it is not possible in principle to determine if any offset in a heap segment is aligned.\n+ * For example, suppose the programmer chooses a 8-byte alignment constraint and tries\n+ * to access offset 16 in a heap segment. If the heap segment's address 0 corresponds to physical address 1000,\n+ * then the target address (1016) would be aligned, but if address 0 corresponds to physical address 1004,\n+ * then the target address (1020) would not be aligned. It is undesirable to allow access to target addresses that are\n+ * aligned according to the programmer's chosen alignment constraint, but might not be predictably aligned in physical memory\n+ * (e.g. because of platform considerations and\/or garbage collection behavior).\n+ * <p>\n+ * In practice, the Java runtime lays out arrays in memory so that each n-byte element occurs at an n-byte\n+ * aligned physical address. The runtime preserves this invariant even if the array is relocated during garbage\n+ * collection. Access operations rely on this invariant to determine if the specified offset in a heap segment refers\n+ * to an aligned address in physical memory. For example:\n+ * <ul>\n+ * <li>The starting physical address of a {@code long[]} array will be 8-byte aligned (e.g. 1000), so that successive long elements\n+ * occur at 8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) A heap segment backed by a {@code long[]} array\n+ * can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint. In addition, the segment can be\n+ * accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target addresses\n+ * (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets 0, 2, 4, 6, etc under a\n+ * 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n+ * <li>The starting physical address of a {@code short[]} array will be 2-byte aligned (e.g. 1006) so that successive\n+ * short elements occur at 2-byte aligned addresses (e.g. 1006, 1008, 1010, 1012, etc). A heap segment backed by a\n+ * {@code short[]} array can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint. The segment cannot\n+ * be accessed at <em>any<\/em> offset under a 4-byte alignment constraint, because there is no guarantee that the target\n+ * address would be 4-byte aligned, e.g., offset 0 would correspond to physical address 1006 while offset 1 would correspond\n+ * to physical address 1007. Similarly, the segment cannot be accessed at any offset under an 8-byte alignment constraint,\n+ * because because there is no guarantee that the target address would be 8-byte aligned, e.g., offset 2 would correspond\n+ * to physical address 1008 but offset 4 would correspond to physical address 1010.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * In other words, heap segments feature a <em>maximum<\/em> alignment which is derived from the size of the elements of\n+ * the Java array backing the segment, as shown in the following table:\n@@ -192,1 +291,1 @@\n- * <caption style=\"display:none\">Array type of an array backing a segment and its address alignment<\/caption>\n+ * <caption style=\"display:none\">Maximum alignment of heap segments<\/caption>\n@@ -195,2 +294,2 @@\n- *     <th scope=\"col\">Array type<\/th>\n- *     <th scope=\"col\">Alignment<\/th>\n+ *     <th scope=\"col\">Array type (of backing region)<\/th>\n+ *     <th scope=\"col\">Maximum supported alignment (in bytes)<\/th>\n@@ -219,3 +318,17 @@\n- * Note that the above definition is conservative: it might be possible, for instance, that a heap segment\n- * constructed from a {@code byte[]} might have a subset of addresses {@code S} which happen to be 8-byte aligned. But determining\n- * which segment addresses belong to {@code S} requires reasoning about details which are ultimately implementation-dependent.\n+ * Heap segment can only be accessed using a layout whose alignment is smaller or equal to the\n+ * maximum alignment associated with the heap segment. Attempting to access a heap segment using a layout\n+ * whose alignment is greater than the maximum alignment associated with the heap segment will fail,\n+ * as demonstrated in the following example:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);\n+ * byteSegment.get(ValueLayout.JAVA_INT, 0); \/\/ fails: layout alignment is 4, segment max alignment is 1\n+ * }\n+ *\n+ * In such circumstances, clients have two options. They can use a heap segment backed by a different array\n+ * type (e.g. {@code long[]}), capable of supporting greater maximum alignment:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment longSegment = MemorySegment.ofArray(new long[10]);\n+ * longSegment.get(ValueLayout.JAVA_INT, 0); \/\/ ok: layout alignment is 4, segment max alignment is 8\n+ * }\n@@ -223,7 +336,56 @@\n- * <h2 id=\"restricted-segments\">Restricted memory segments<\/h2>\n- * Sometimes it is necessary to turn a memory address obtained from native code into a memory segment with\n- * full spatial, temporal and confinement bounds. To do this, clients can {@linkplain #ofAddress(MemoryAddress, long, MemorySession) obtain}\n- * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain MemorySession session}.\n- * This is a <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> operation and should be used with\n- * caution: for instance, an incorrect segment size could result in a VM crash when attempting to dereference\n- * the memory segment.\n+ * Alternatively, they can invoke the access operation with a layout whose alignment is smaller:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);\n+ * byteSegment.get(ValueLayout.JAVA_INT.withBitAlignment(8), 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n+ * }\n+ *\n+ * <h2 id=\"wrapping-addresses\">Zero-length memory segments<\/h2>\n+ *\n+ * When interacting with <a href=\"package-summary.html#ffa\">foreign functions<\/a>, it is common for those functions\n+ * to allocate a region of memory and return a pointer to that region. Modeling the region of memory with a memory segment\n+ * is challenging because the Java runtime has no insight into the size of the region. Only the address of the start of\n+ * the region, stored in the pointer, is available. For example, a C function with return type {@code char*} might return\n+ * a pointer to a region containing a single {@code char} value, or to a region containing an array of {@code char} values,\n+ * where the size of the array might be provided in a separate parameter. The size of the array is not readily apparent\n+ * to the code calling the foreign function and hoping to use its result.\n+ * <p>\n+ * The {@link Linker} represents a pointer returned from a foreign function with a <em>zero-length memory segment<\/em>.\n+ * The address of the segment is the address stored in the pointer. The size of the segment is zero. Similarly, when a\n+ * client reads an <em>address<\/em> from a memory segment, a zero-length memory segment is returned.\n+ * <p>\n+ * Since a zero-length segment features trivial spatial bounds, any attempt to access these segments will fail with\n+ * {@link IndexOutOfBoundsException}. This is a crucial safety feature: as these segments are associated with a region\n+ * of memory whose size is not known, any access operations involving these segments cannot be validated.\n+ * In effect, a zero-length memory segment <em>wraps<\/em> an address, and it cannot be used without explicit intent.\n+ * <p>\n+ * Zero-length memory segments obtained when interacting with foreign functions are associated with the\n+ * {@link MemorySession#global() global} memory session. This is because the Java runtime, in addition to having no insight\n+ * into the size of the region of memory backing a pointer returned from a foreign function, also has no insight\n+ * into the lifetime intended for said region of memory by the foreign function that allocated it. The global memory\n+ * session ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n+ * <p>\n+ * To access native zero-length memory segments, clients have two options, both of which are <em>unsafe<\/em>. Clients\n+ * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) obtain}\n+ * a <em>new<\/em> native segment, with new spatial and temporal bounds, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySession session = ... \/\/ initialize a memory session\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n+ * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, session); \/\/ create new segment (size = 4)\n+ * int x = segment.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n+ *\n+ * Alternatively, clients can obtain an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n+ * address value layout. When an access operation, or a function descriptor that is passed to a downcall method handle,\n+ * uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments\n+ * with <em>maximal<\/em> size (i.e. {@linkplain java.lang.Long#MAX_VALUE}). As such, these segments can be accessed directly, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ wrap address into segment (size = Long.MAX_VALUE)\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n+ *\n+ * Both {@link #ofAddress(long, long, MemorySession)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n+ * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should be used with caution:\n+ * for instance, sizing a segment incorrectly could result in a VM crash when attempting to access the memory segment.\n@@ -231,4 +393,5 @@\n- * Clients requiring sophisticated, low-level control over mapped memory segments, might consider writing\n- * custom mapped memory segment factories; using {@link Linker}, e.g. on Linux, it is possible to call {@code mmap}\n- * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n- * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddress(MemoryAddress, long, MemorySession)}.\n+ * Which approach is taken largely depends on the information that a client has available when obtaining a memory segment\n+ * wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the\n+ * segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API).\n+ * In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should\n+ * be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n@@ -239,0 +402,1 @@\n+ * @sealedGraph\n@@ -242,1 +406,1 @@\n-public sealed interface MemorySegment extends Addressable permits AbstractMemorySegmentImpl {\n+public sealed interface MemorySegment permits AbstractMemorySegmentImpl {\n@@ -245,6 +409,1 @@\n-     * {@return the base memory address associated with this native memory segment}\n-     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * {@return the address of this memory segment}\n@@ -252,2 +411,6 @@\n-    @Override\n-    MemoryAddress address();\n+    long address();\n+\n+    \/**\n+     * {@return the Java array associated with this memory segment, if any}\n+     *\/\n+    Optional<Object> array();\n@@ -273,1 +436,1 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -289,1 +452,1 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -305,1 +468,1 @@\n-     * Returns a slice of this memory segment, at the given offset. The returned segment's base address is the base address\n+     * Returns a slice of this memory segment, at the given offset. The returned segment's address is the address\n@@ -310,1 +473,1 @@\n-     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n@@ -318,1 +481,1 @@\n-     * Returns a slice of this memory segment, at the given offset. The returned segment's base address is the base address\n+     * Returns a slice of this memory segment, at the given offset. The returned segment's address is the address\n@@ -328,1 +491,1 @@\n-     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n@@ -351,4 +514,3 @@\n-     * Returns {@code true} if this segment is a native segment. A native memory segment is\n-     * created using the {@link #allocateNative(long, MemorySession)} (and related) factory, or a buffer segment\n-     * derived from a {@linkplain ByteBuffer#allocateDirect(int) direct byte buffer} using the {@link #ofBuffer(Buffer)} factory,\n-     * or if this is a {@linkplain #isMapped() mapped} segment.\n+     * Returns {@code true} if this segment is a native segment. A native segment is\n+     * created e.g. using the {@link #allocateNative(long, MemorySession)} (and related) factory, or by\n+     * {@linkplain #ofBuffer(Buffer) wrapping} a {@linkplain ByteBuffer#allocateDirect(int) direct buffer}.\n@@ -360,3 +522,3 @@\n-     * Returns {@code true} if this segment is a mapped segment. A mapped memory segment is\n-     * created using the {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)} factory, or a buffer segment\n-     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofBuffer(Buffer)} factory.\n+     * Returns {@code true} if this segment is a mapped segment. A mapped memory segment is created e.g. using the\n+     * {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)} factory, or by\n+     * {@linkplain #ofBuffer(Buffer) wrapping} a {@linkplain java.nio.MappedByteBuffer mapped byte buffer}.\n@@ -373,1 +535,1 @@\n-     * same memory region. As such, it is not possible for a\n+     * same region of memory. As such, it is not possible for a\n@@ -386,1 +548,1 @@\n-     * <p>The offset is relative to the base address of this segment and can be\n+     * <p>The offset is relative to the address of this segment and can be\n@@ -388,1 +550,2 @@\n-     * segments, the resulting offset can be computed as follows:\n+     * segments, or heap segments backed by the same array, the resulting offset\n+     * can be computed as follows:\n@@ -391,1 +554,1 @@\n-     * other.baseAddress().toRawLongValue() - segment.baseAddress().toRawLongValue()\n+     * other.address() - segment.address()\n@@ -394,1 +557,1 @@\n-     * If the segments share the same base address, {@code 0} is returned. If\n+     * If the segments share the same address, {@code 0} is returned. If\n@@ -399,0 +562,2 @@\n+     * @throws UnsupportedOperationException if the two segments cannot be compared, e.g. because they are of\n+     * a different kind, or because they are backed by different Java arrays.\n@@ -462,1 +627,1 @@\n-     * {@linkplain #address() base address} of each segment and will be in the\n+     * {@linkplain #address() address} of each segment and will be in the\n@@ -583,1 +748,1 @@\n-     * (see {@link ByteBuffer#isReadOnly()}). Additionally, if this is a native memory segment, the resulting buffer is\n+     * (see {@link ByteBuffer#isReadOnly()}). Additionally, if this is a native segment, the resulting buffer is\n@@ -717,2 +882,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -722,1 +886,1 @@\n-     * @throws IndexOutOfBoundsException if {@code S + offset > byteSize()}, where {@code S} is the size of the UTF-8\n+     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code S + offset > byteSize()}, where {@code S} is the size of the UTF-8\n@@ -745,3 +909,2 @@\n-     *\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -749,1 +912,1 @@\n-     * @throws IndexOutOfBoundsException if {@code str.getBytes().length() + offset >= byteSize()}.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code str.getBytes().length() + offset >= byteSize()}.\n@@ -761,1 +924,1 @@\n-     * Creates a buffer memory segment that models the memory associated with the given {@link Buffer} instance.\n+     * Creates a memory segment that is backed by the same region of memory that backs the given {@link Buffer} instance.\n@@ -764,4 +927,3 @@\n-     * If the buffer is {@linkplain ByteBuffer#isReadOnly() read-only}, the resulting segment will also be\n-     * {@linkplain ByteBuffer#isReadOnly() read-only}. The memory session associated with this segment can either be the\n-     * {@linkplain MemorySession#global() global} memory session, in case the buffer has been created independently,\n-     * or some other memory session, in case the buffer has been obtained using {@link #asByteBuffer()}.\n+     * If the buffer is {@linkplain Buffer#isReadOnly() read-only}, the resulting segment will also be\n+     * {@linkplain ByteBuffer#isReadOnly() read-only}. Moreover, if the buffer is a {@linkplain Buffer#isDirect() direct buffer},\n+     * the returned segment is a native segment; otherwise the returned memory segment is a heap segment.\n@@ -769,1 +931,11 @@\n-     * The resulting memory segment keeps a reference to the backing buffer, keeping it <em>reachable<\/em>.\n+     * The memory session {@code S} associated with the returned segment is\n+     * computed as follows:\n+     * <ul>\n+     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose session\n+     *     is {@code S'}, then {@code S = S'}; or<\/li>\n+     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain MemorySession#global() global session}; or\n+     *     <li>if the buffer is a direct buffer, then {@code S} is an\n+     *     {@linkplain MemorySession#openImplicit() implicit session} that keeps the buffer reachable.\n+     *     Therefore, the off-heap region of memory backing the buffer instance will remain available as long as the\n+     *     returned segment is reachable.<\/li>\n+     * <\/ul>\n@@ -771,2 +943,6 @@\n-     * @param buffer the buffer instance backing the buffer memory segment.\n-     * @return a buffer memory segment.\n+     * @param buffer the buffer instance to be turned into a new memory segment.\n+     * @return a memory segment, derived from the given buffer instance.\n+     * @throws IllegalArgumentException if the provided {@code buffer} is a heap buffer but is not backed by an array.\n+     *                                  For example, buffers directly or indirectly obtained via\n+     *                                  ({@link CharBuffer#wrap(CharSequence)} or {@link CharBuffer#wrap(char[], int, int)}\n+     *                                  are not backed by an array.\n@@ -779,2 +955,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated byte array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given byte array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -782,2 +959,2 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param byteArray the primitive array backing the heap memory segment.\n+     * @return a heap memory segment backed by a byte array.\n@@ -785,2 +962,2 @@\n-    static MemorySegment ofArray(byte[] arr) {\n-        return HeapMemorySegmentImpl.OfByte.fromArray(arr);\n+    static MemorySegment ofArray(byte[] byteArray) {\n+        return HeapMemorySegmentImpl.OfByte.fromArray(byteArray);\n@@ -790,2 +967,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated char array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given char array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -793,2 +971,2 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param charArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a char array.\n@@ -796,2 +974,2 @@\n-    static MemorySegment ofArray(char[] arr) {\n-        return HeapMemorySegmentImpl.OfChar.fromArray(arr);\n+    static MemorySegment ofArray(char[] charArray) {\n+        return HeapMemorySegmentImpl.OfChar.fromArray(charArray);\n@@ -801,2 +979,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated short array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given short array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -804,2 +983,2 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param shortArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a short array.\n@@ -807,2 +986,2 @@\n-    static MemorySegment ofArray(short[] arr) {\n-        return HeapMemorySegmentImpl.OfShort.fromArray(arr);\n+    static MemorySegment ofArray(short[] shortArray) {\n+        return HeapMemorySegmentImpl.OfShort.fromArray(shortArray);\n@@ -812,2 +991,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated int array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given int array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -815,2 +995,2 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param intArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by an int array.\n@@ -818,2 +998,2 @@\n-    static MemorySegment ofArray(int[] arr) {\n-        return HeapMemorySegmentImpl.OfInt.fromArray(arr);\n+    static MemorySegment ofArray(int[] intArray) {\n+        return HeapMemorySegmentImpl.OfInt.fromArray(intArray);\n@@ -823,2 +1003,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated float array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given float array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -826,2 +1007,2 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param floatArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a float array.\n@@ -829,2 +1010,2 @@\n-    static MemorySegment ofArray(float[] arr) {\n-        return HeapMemorySegmentImpl.OfFloat.fromArray(arr);\n+    static MemorySegment ofArray(float[] floatArray) {\n+        return HeapMemorySegmentImpl.OfFloat.fromArray(floatArray);\n@@ -834,2 +1015,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated long array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given long array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -837,2 +1019,2 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param longArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a long array.\n@@ -840,2 +1022,2 @@\n-    static MemorySegment ofArray(long[] arr) {\n-        return HeapMemorySegmentImpl.OfLong.fromArray(arr);\n+    static MemorySegment ofArray(long[] longArray) {\n+        return HeapMemorySegmentImpl.OfLong.fromArray(longArray);\n@@ -845,2 +1027,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated double array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given double array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -848,2 +1031,2 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param doubleArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a double array.\n@@ -851,2 +1034,2 @@\n-    static MemorySegment ofArray(double[] arr) {\n-        return HeapMemorySegmentImpl.OfDouble.fromArray(arr);\n+    static MemorySegment ofArray(double[] doubleArray) {\n+        return HeapMemorySegmentImpl.OfDouble.fromArray(doubleArray);\n@@ -855,0 +1038,4 @@\n+    \/**\n+     * A zero-length native segment modelling the {@code NULL} address.\n+     *\/\n+    MemorySegment NULL = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(0L, 0);\n@@ -857,1 +1044,42 @@\n-     * Creates a native memory segment with the given size, base address, and memory session.\n+     * Creates a zero-length native segment from the given {@linkplain #address() address value}.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, 0);\n+     *}\n+     * @param address the address of the returned native segment.\n+     * @return a zero-length native segment with the given address.\n+     *\/\n+    static MemorySegment ofAddress(long address) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given size and {@linkplain #address() address value}.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, byteSize, MemorySession.global());\n+     *}\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param address the address of the returned native segment.\n+     * @param byteSize the size (in bytes) of the returned native segment.\n+     * @return a zero-length native segment with the given address and size.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static MemorySegment ofAddress(long address, long byteSize) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n+        return MemorySegment.ofAddress(address, byteSize, MemorySession.global());\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given size, address, and memory session.\n@@ -859,1 +1087,1 @@\n-     * where an address to some underlying memory region is typically obtained from foreign code\n+     * where an address to some underlying region of memory is typically obtained from foreign code\n@@ -866,1 +1094,1 @@\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * if appropriate, writing; an attempt to access an invalid address from Java code will either return an arbitrary value,\n@@ -875,2 +1103,2 @@\n-     * @param address the returned segment's base address.\n-     * @param bytesSize the desired size.\n+     * @param address the returned segment's address.\n+     * @param byteSize the desired size.\n@@ -878,2 +1106,2 @@\n-     * @return a native memory segment with the given base address, size and memory session.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n+     * @return a native segment with the given address, size and memory session.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n@@ -888,1 +1116,1 @@\n-    static MemorySegment ofAddress(MemoryAddress address, long bytesSize, MemorySession session) {\n+    static MemorySegment ofAddress(long address, long byteSize, MemorySession session) {\n@@ -890,1 +1118,0 @@\n-        Objects.requireNonNull(address);\n@@ -892,2 +1119,2 @@\n-        Utils.checkAllocationSizeAndAlign(bytesSize, 1);\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, bytesSize, session);\n+        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session);\n@@ -897,3 +1124,11 @@\n-     * Creates a native memory segment with the given layout and memory session.\n-     * A client is responsible for ensuring that the memory session associated with the returned segment is closed\n-     * when the segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n+     * Creates a native segment with the given layout and memory session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative to explicitly invoke {@link MemorySession#close()}, sessions backed with a {@link Cleaner}\n+     * (such as {@linkplain MemorySession#openImplicit()}) can be used, allowing the returned segment to be\n+     * automatically released some unspecified time after the session is no longer referenced.\n+     * <p>\n+     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n+     * of the returned segment will be aligned according to the alignment constraint of the provided layout.\n@@ -906,1 +1141,1 @@\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n@@ -908,3 +1143,3 @@\n-     * @param layout the layout of the off-heap memory block backing the native memory segment.\n-     * @param session the segment memory session.\n-     * @return a new native memory segment.\n+     * @param layout the layout of the off-heap memory region backing the native segment.\n+     * @param session the session to which the returned segment is associated.\n+     * @return a new native segment.\n@@ -914,0 +1149,1 @@\n+     * @see MemorySession#allocate(MemoryLayout)\n@@ -922,3 +1158,11 @@\n-     * Creates a native memory segment with the given size (in bytes) and memory session.\n-     * A client is responsible for ensuring that the memory session associated with the returned segment is closed\n-     * when the segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n+     * Creates a native segment with the given size (in bytes) and memory session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative to explicitly invoke {@link MemorySession#close()}, sessions backed with a {@link Cleaner}\n+     * (such as {@linkplain MemorySession#openImplicit()}) can be used, allowing the returned segment to be\n+     * automatically released some unspecified time after the session is no longer referenced.\n+     * <p>\n+     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n+     * of the returned segment is guaranteed to be at least 1-byte aligned.\n@@ -931,1 +1175,3 @@\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n+     * <p>\n+     * This method corresponds to the {@link ByteBuffer#allocateDirect(int)} method and has similar behavior.\n@@ -933,2 +1179,2 @@\n-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param session the segment temporal bounds.\n+     * @param byteSize the size (in bytes) of the off-heap memory region of memory backing the native memory segment.\n+     * @param session the session to which the returned segment is associated.\n@@ -936,1 +1182,1 @@\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n@@ -939,1 +1185,2 @@\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     *  {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     * @see MemorySession#allocate(long)\n@@ -941,2 +1188,2 @@\n-    static MemorySegment allocateNative(long bytesSize, MemorySession session) {\n-        return allocateNative(bytesSize, 1, session);\n+    static MemorySegment allocateNative(long byteSize, MemorySession session) {\n+        return allocateNative(byteSize, 1, session);\n@@ -946,3 +1193,11 @@\n-     * Creates a native memory segment with the given size (in bytes), alignment constraint (in bytes) and memory session.\n-     * A client is responsible for ensuring that the memory session associated with the returned segment is closed when the\n-     * segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n+     * Creates a native segment with the given size (in bytes), alignment (in bytes) and session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative to explicitly invoke {@link MemorySession#close()}, sessions backed with a {@link Cleaner}\n+     * (such as {@linkplain MemorySession#openImplicit()}) can be used, allowing the returned segment to be\n+     * automatically released some unspecified time after the session is no longer referenced.\n+     * <p>\n+     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n+     * of the returned segment will be aligned according to the provided alignment constraint.\n@@ -950,1 +1205,1 @@\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n@@ -952,3 +1207,3 @@\n-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param session the segment memory session.\n+     * @param byteSize the size (in bytes) of the off-heap region of memory backing the native memory segment.\n+     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n+     * @param session the session to which the returned segment is associated.\n@@ -956,2 +1211,2 @@\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n-     * is not a power of 2.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}, {@code byteAlignment <= 0}, or if {@code byteAlignment}\n+     *                                  is not a power of 2.\n@@ -961,0 +1216,1 @@\n+     * @see MemorySession#allocate(long, long)\n@@ -962,1 +1218,1 @@\n-    static MemorySegment allocateNative(long bytesSize, long alignmentBytes, MemorySession session) {\n+    static MemorySegment allocateNative(long byteSize, long byteAlignment, MemorySession session) {\n@@ -964,2 +1220,2 @@\n-        Utils.checkAllocationSizeAndAlign(bytesSize, alignmentBytes);\n-        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes, session);\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session);\n@@ -1036,1 +1292,1 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the source\n@@ -1088,4 +1344,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a byte value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return a byte value read from this segment.\n@@ -1096,3 +1351,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1103,1 +1358,1 @@\n-        return (byte)layout.accessHandle().get(this, offset);\n+        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n@@ -1109,3 +1364,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1117,3 +1371,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1125,1 +1379,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n@@ -1131,4 +1385,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a boolean value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return a boolean value read from this segment.\n@@ -1139,3 +1392,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1146,1 +1399,1 @@\n-        return (boolean)layout.accessHandle().get(this, offset);\n+        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n@@ -1152,3 +1405,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1160,3 +1412,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1168,1 +1420,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n@@ -1174,4 +1426,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a char value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return a char value read from this segment.\n@@ -1182,3 +1433,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1189,1 +1440,1 @@\n-        return (char)layout.accessHandle().get(this, offset);\n+        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n@@ -1195,3 +1446,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1203,3 +1453,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1211,1 +1461,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n@@ -1217,4 +1467,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a short value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return a short value read from this segment.\n@@ -1225,3 +1474,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1232,1 +1481,1 @@\n-        return (short)layout.accessHandle().get(this, offset);\n+        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n@@ -1238,3 +1487,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1246,3 +1494,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1254,1 +1502,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n@@ -1260,4 +1508,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return an int value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return an int value read from this segment.\n@@ -1268,3 +1515,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1275,1 +1522,1 @@\n-        return (int)layout.accessHandle().get(this, offset);\n+        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n@@ -1281,3 +1528,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1289,3 +1535,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1297,1 +1543,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n@@ -1303,4 +1549,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a float value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return a float value read from this segment.\n@@ -1311,3 +1556,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1318,1 +1563,1 @@\n-        return (float)layout.accessHandle().get(this, offset);\n+        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n@@ -1324,3 +1569,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1332,3 +1576,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1340,1 +1584,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n@@ -1346,4 +1590,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a long value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return a long value read from this segment.\n@@ -1354,3 +1597,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1361,1 +1604,1 @@\n-        return (long)layout.accessHandle().get(this, offset);\n+        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n@@ -1367,3 +1610,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1375,3 +1617,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1383,1 +1625,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n@@ -1389,4 +1631,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a double value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return a double value read from this segment.\n@@ -1397,3 +1638,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1404,1 +1645,1 @@\n-        return (double)layout.accessHandle().get(this, offset);\n+        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n@@ -1410,3 +1651,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1418,3 +1658,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1426,1 +1666,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n@@ -1430,6 +1670,8 @@\n-     * Reads an address from this segment at the given offset, with the given layout.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return an address value read from this address.\n+     * Reads an address from this segment at the given offset, with the given layout. The read address is wrapped in\n+     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n+     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n+     * segment is {@code Long.MAX_VALUE}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @return a native segment wrapping an address read from this segment.\n@@ -1440,3 +1682,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1446,2 +1688,2 @@\n-    default MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n-        return (MemoryAddress)layout.accessHandle().get(this, offset);\n+    default MemorySegment get(ValueLayout.OfAddress layout, long offset) {\n+        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n@@ -1453,3 +1695,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1461,3 +1702,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1468,2 +1709,2 @@\n-    default void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n-        layout.accessHandle().set(this, offset, value.address());\n+    default void set(ValueLayout.OfAddress layout, long offset, MemorySegment value) {\n+        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n@@ -1475,4 +1716,4 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a char value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a char value read from this segment.\n@@ -1483,2 +1724,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1486,1 +1727,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1493,1 +1734,1 @@\n-        return (char)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1499,3 +1740,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1507,2 +1748,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1510,1 +1751,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1518,1 +1759,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1524,4 +1765,4 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a short value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a short value read from this segment.\n@@ -1532,2 +1773,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1535,1 +1776,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1542,1 +1783,1 @@\n-        return (short)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1548,3 +1789,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1556,2 +1797,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1559,1 +1800,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1567,1 +1808,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1573,4 +1814,4 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return an int value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return an int value read from this segment.\n@@ -1581,2 +1822,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1584,1 +1825,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1591,1 +1832,1 @@\n-        return (int)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1597,3 +1838,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1605,2 +1846,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1608,1 +1849,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1616,1 +1857,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1622,4 +1863,4 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a float value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a float value read from this segment.\n@@ -1630,2 +1871,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1633,1 +1874,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1640,1 +1881,1 @@\n-        return (float)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1646,3 +1887,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1654,2 +1895,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1657,1 +1898,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1665,1 +1906,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1671,4 +1912,4 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a long value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a long value read from this segment.\n@@ -1679,2 +1920,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1682,1 +1923,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1689,1 +1930,1 @@\n-        return (long)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1695,3 +1936,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1703,2 +1944,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1706,1 +1947,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1714,1 +1955,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1720,4 +1961,4 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a double value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a double value read from this segment.\n@@ -1728,2 +1969,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1731,1 +1972,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1738,1 +1979,1 @@\n-        return (double)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1744,3 +1985,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1752,2 +1993,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1755,1 +1996,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1763,1 +2004,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1767,1 +2008,5 @@\n-     * Reads an address from this segment at the given index, scaled by the given layout size.\n+     * Reads an address from this segment at the given at the given index, scaled by the given layout size. The read address is wrapped in\n+     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n+     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n+     * segment is {@code Long.MAX_VALUE}.\n@@ -1769,4 +2014,4 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return an address value read from this address.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a native segment wrapping an address read from this segment.\n@@ -1777,2 +2022,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1780,1 +2025,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1784,1 +2029,1 @@\n-    default MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n+    default MemorySegment getAtIndex(ValueLayout.OfAddress layout, long index) {\n@@ -1787,1 +2032,1 @@\n-        return (MemoryAddress)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1793,3 +2038,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1801,2 +2046,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1804,1 +2049,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1809,1 +2054,1 @@\n-    default void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n+    default void setAtIndex(ValueLayout.OfAddress layout, long index, MemorySegment value) {\n@@ -1812,1 +2057,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value.address());\n+        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1817,2 +2062,2 @@\n-     * object is also a memory segment, and if that segment refers to the same memory region as this segment. More specifically,\n-     * for two segments to be considered equals, all the following must be true:\n+     * object is also a memory segment, and if the two segments refer to the same location, in some region of memory.\n+     * More specifically, for two segments {@code s1} and {@code s2} to be considered equals, all the following must be true:\n@@ -1820,7 +2065,6 @@\n-     *     <li>the two segments must be of the same kind; either both are {@linkplain #isNative() native segments},\n-     *     backed by off-heap memory, or both are backed by on-heap memory;\n-     *     <li>if the two segments are {@linkplain #isNative() native segments}, their {@link #address() base address}\n-     *     must be {@linkplain MemoryAddress#equals(Object) equal}. Otherwise, the two segments must wrap the\n-     *     same Java array instance, at the same starting offset;<\/li>\n-     *     <li>the two segments must have the same {@linkplain #byteSize() size}; and<\/li>\n-     *     <li>the two segments must have the {@linkplain MemorySession#equals(Object) same} {@linkplain #session() temporal bounds}.\n+     *     <li>{@code s1.array().equals(s2.array())}, that is, the two segments must be of the same kind;\n+     *     either both are {@linkplain #isNative() native segments}, backed by off-heap memory, or both are backed by\n+     *     the same on-heap Java array;\n+     *     <li>{@code s1.address() == s2.address()}, that is, the address of the two segments should be the same.\n+     *     This means that the two segments either refer to the same location in some off-heap region, or they refer\n+     *     to the same position inside their associated Java array instance.<\/li>\n@@ -1829,1 +2073,3 @@\n-     * compare memory segments structurally by using the {@link #mismatch(MemorySegment)} method instead.\n+     * compare memory segments structurally by using the {@link #mismatch(MemorySegment)} method instead. Note that this\n+     * method does <em>not<\/em> compare the temporal and spatial bounds of two segments. As such it is suitable\n+     * to perform address checks, such as checking if a native segment has the {@code NULL} address.\n@@ -1834,1 +2080,0 @@\n-     * @see #asOverlappingSlice(MemorySegment)\n@@ -1864,1 +2109,1 @@\n-     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source element layout,\n+     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the source element layout,\n@@ -1874,22 +2119,4 @@\n-        long baseAndScale = getBaseAndScale(dstArray.getClass());\n-        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n-            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n-        }\n-        int dstBase = (int)baseAndScale;\n-        int dstWidth = (int)(baseAndScale >> 32);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        Utils.checkElementAlignment(srcLayout, \"Source layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n-        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n-        }\n+\n+        AbstractMemorySegmentImpl.copy(srcSegment, srcLayout, srcOffset,\n+                dstArray, dstIndex,\n+                elementCount);\n@@ -1916,1 +2143,1 @@\n-     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the destination element layout,\n+     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the destination element layout,\n@@ -1926,22 +2153,4 @@\n-        long baseAndScale = getBaseAndScale(srcArray.getClass());\n-        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n-            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n-        }\n-        int srcBase = (int)baseAndScale;\n-        int srcWidth = (int)(baseAndScale >> 32);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        Utils.checkElementAlignment(dstLayout, \"Destination layout alignment greater than its size\");\n-        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n-        }\n+\n+        AbstractMemorySegmentImpl.copy(srcArray, srcIndex,\n+                dstSegment, dstLayout, dstOffset,\n+                elementCount);\n@@ -1950,18 +2159,40 @@\n-    private static long getBaseAndScale(Class<?> arrayType) {\n-        if (arrayType.equals(byte[].class)) {\n-            return (long)Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+    \/**\n+     * Finds and returns the relative offset, in bytes, of the first mismatch between the source and the destination\n+     * segments. More specifically, the bytes at offset {@code srcFromOffset} through {@code srcToOffset - 1} in the\n+     * source segment are compared against the bytes at offset {@code dstFromOffset} through {@code dstToOffset - 1}\n+     * in the destination segment.\n+     * <p>\n+     * If the two segments, over the specified ranges, share a common prefix then the returned offset is the length\n+     * of the common prefix, and it follows that there is a mismatch between the two segments at that relative offset\n+     * within the respective segments. If one segment is a proper prefix of the other, over the specified ranges,\n+     * then the returned offset is the smallest range, and it follows that the relative offset is only\n+     * valid for the segment with the larger range. Otherwise, there is no mismatch and {@code -1} is returned.\n+     *\n+     * @param srcSegment the source segment.\n+     * @param srcFromOffset the offset (inclusive) of the first byte in the source segment to be tested.\n+     * @param srcToOffset the offset (exclusive) of the last byte in the source segment to be tested.\n+     * @param dstSegment the destination segment.\n+     * @param dstFromOffset the offset (inclusive) of the first byte in the destination segment to be tested.\n+     * @param dstToOffset the offset (exclusive) of the last byte in the destination segment to be tested.\n+     * @return the relative offset, in bytes, of the first mismatch between the source and destination segments,\n+     * otherwise -1 if no mismatch.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code srcSegment}.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IndexOutOfBoundsException if {@code srcFromOffset < 0}, {@code srcToOffset < srcFromOffset} or\n+     * {@code srcToOffset > srcSegment.byteSize()}\n+     * @throws IndexOutOfBoundsException if {@code dstFromOffset < 0}, {@code dstToOffset < dstFromOffset} or\n+     * {@code dstToOffset > dstSegment.byteSize()}\n+     *\n+     * @see MemorySegment#mismatch(MemorySegment)\n+     * @see Arrays#mismatch(Object[], int, int, Object[], int, int)\n+     *\/\n+    static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n+                         MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n+        return AbstractMemorySegmentImpl.mismatch(srcSegment, srcFromOffset, srcToOffset,\n+                dstSegment, dstFromOffset, dstToOffset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":751,"deletions":520,"binary":false,"changes":1271,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n@@ -47,2 +49,2 @@\n- * one or more {@linkplain MemorySegment#allocateNative(long, long, MemorySession) native memory segments} results in releasing\n- * the off-heap memory associated with said segments.\n+ * one or more {@linkplain MemorySession#allocate(long, long) native memory segments} results in releasing\n+ * the off-heap memory backing said segments.\n@@ -79,2 +81,2 @@\n- *    MemorySegment segment1 = MemorySegment.allocateNative(100);\n- *    MemorySegment segment1 = MemorySegment.allocateNative(200);\n+ *    MemorySegment segment1 = session.allocate(100);\n+ *    MemorySegment segment1 = session.allocate(200);\n@@ -214,3 +216,8 @@\n-    \/**\n-     * Allocates a native segment, using this session. Equivalent to the following code:\n-     * {@snippet lang=java :\n+     \/**\n+     * Creates a native memory segment with the given size (in bytes), alignment constraint (in bytes) associated with\n+     * this memory session. The {@link MemorySegment#address()} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n+     * of the returned segment will be aligned according the provided alignment constraint.\n+     * <p>\n+     * Equivalent to the following code:\n+     * {@snippet lang = java:\n@@ -219,0 +226,5 @@\n+     * <p>\n+     * A client is responsible for ensuring that this memory session is closed when the\n+     * segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n+     * <p>\n+     * The off-heap region of memory backing the returned native memory segment is initialized to zero.\n@@ -220,1 +232,6 @@\n-     * @throws IllegalStateException if this memory session is not {@linkplain #isAlive() alive}.\n+     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n+     * is not a power of 2.\n+     * @throws IllegalStateException if this session is not {@linkplain MemorySession#isAlive() alive}.\n@@ -222,2 +239,2 @@\n-     * {@linkplain #ownerThread() owning} this memory session.\n-     * @return a new native segment, associated with this session.\n+     * {@linkplain MemorySession#ownerThread() owning} this session.\n+     * @see MemorySegment#allocateNative(long, long, MemorySession)\n@@ -226,2 +243,2 @@\n-    default MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n+    default MemorySegment allocate(long byteSize, long byteAlignment) {\n+        return MemorySegment.allocateNative(byteSize, byteAlignment, this);\n@@ -231,2 +248,8 @@\n-     * Creates a closeable confined memory session.\n-     * @return a new closeable confined memory session.\n+     * Creates a new closeable, thread-confined memory session.\n+     * <p>\n+     * The returned memory session is confined to the current thread.\n+     * <p>\n+     * The returned memory session <em>must<\/em> eventually be {@linkplain #close() closed}\n+     * to prevent memory leaks.\n+     *\n+     * @return a new closeable, thread-confined memory session\n@@ -239,3 +262,7 @@\n-     * Creates a closeable confined memory session, managed by the provided cleaner instance.\n-     * @param cleaner the cleaner to be associated with the returned memory session.\n-     * @return a new closeable confined memory session, managed by {@code cleaner}.\n+     * Creates a new closeable, thread-confined memory session, managed by\n+     * the provided {@code cleaner}.\n+     * <p>\n+     * The returned memory session is confined to the current thread.\n+     *\n+     * @param cleaner the cleaner to be associated with the returned memory session\n+     * @return a new closeable thread-confined memory session, managed by the provided {@code cleaner}\n@@ -249,2 +276,9 @@\n-     * Creates a closeable shared memory session.\n-     * @return a new closeable shared memory session.\n+     * Creates a new closeable memory session that can be shared across threads.\n+     * <p>\n+     * The returned memory session can be used by any thread. Users are responsible for\n+     * assuring thread-safety across threads that use objects associated with this memory session.\n+     * <p>\n+     * The returned memory session <em>must<\/em> eventually be {@linkplain #close() closed}\n+     * to prevent memory leaks.\n+     *\n+     * @return a new closeable memory session that can be shared across threads\n@@ -257,3 +291,9 @@\n-     * Creates a closeable shared memory session, managed by the provided cleaner instance.\n-     * @param cleaner the cleaner to be associated with the returned memory session.\n-     * @return a new closeable shared memory session, managed by {@code cleaner}.\n+     * Creates a new closeable memory session that can be shared across threads,\n+     * managed by the provided {@code cleaner}.\n+     * <p>\n+     * The returned memory session can be used by any thread. Users are responsible for\n+     * assuring thread-safety across threads that use objects associated with this memory session.\n+     *\n+     * @param cleaner the cleaner to be associated with the returned memory session\n+     * @return a new closeable memory session that can be shared across threads, managed\n+     * by the provided {@code cleaner}\n@@ -267,2 +307,4 @@\n-     * Creates a non-closeable shared memory session, managed by a private {@link Cleaner} instance.\n-     * Equivalent to (but likely more efficient than) the following code:\n+     * Creates a new non-closeable memory session that can be shared across threads,\n+     * manage by a private {@link Cleaner} instance.\n+     * <p>\n+     * This is equivalent to (but likely more efficient than) the following code:\n@@ -272,1 +314,3 @@\n-     * @return a non-closeable shared memory session, managed by a private {@link Cleaner} instance.\n+     *\n+     * @return a new closeable memory session that can be shared across threads, managed\n+     * by a private {@link Cleaner} instance\n@@ -279,2 +323,1 @@\n-     * Returns the global memory session.\n-     * @return the global memory session.\n+     * {@return the global memory session}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":70,"deletions":27,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import java.util.Objects;\n-import java.util.Optional;\n+import jdk.internal.foreign.layout.PaddingLayoutImpl;\n+import jdk.internal.javac.PreviewFeature;\n@@ -36,1 +36,3 @@\n- * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 20\n@@ -38,46 +40,2 @@\n-\/* package-private *\/ final class PaddingLayout extends AbstractLayout implements MemoryLayout {\n-\n-    PaddingLayout(long size) {\n-        this(size, 1, Optional.empty());\n-    }\n-\n-    PaddingLayout(long size, long alignment, Optional<String> name) {\n-        super(size, alignment, name);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return decorateLayoutString(\"x\" + bitSize());\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        if (!(other instanceof PaddingLayout p)) {\n-            return false;\n-        }\n-        return bitSize() == p.bitSize();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), bitSize());\n-    }\n-\n-    @Override\n-    PaddingLayout dup(long alignment, Optional<String> name) {\n-        return new PaddingLayout(bitSize(), alignment, name);\n-    }\n-\n-    @Override\n-    public boolean hasNaturalAlignment() {\n-        return true;\n-    }\n-\n-    \/\/hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout\n-    \/\/but that causes issues with javadoc, see JDK-8224052\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface PaddingLayout extends MemoryLayout permits PaddingLayoutImpl {\n@@ -89,3 +47,1 @@\n-    public PaddingLayout withName(String name) {\n-        return (PaddingLayout)super.withName(name);\n-    }\n+    PaddingLayout withName(String name);\n@@ -97,3 +53,1 @@\n-    public PaddingLayout withBitAlignment(long alignmentBits) {\n-        return (PaddingLayout)super.withBitAlignment(alignmentBits);\n-    }\n+    PaddingLayout withBitAlignment(long bitAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":9,"deletions":55,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- *     <li>{@link #implicitAllocator()} obtains an allocator which allocates native memory segment in independent,\n+ *     <li>{@link #implicitAllocator()} obtains an allocator which allocates native segment in independent,\n@@ -58,1 +58,1 @@\n- * {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handles} can accept an additional\n+ * {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handles} can accept an additional\n@@ -83,1 +83,1 @@\n-     * @return a new native memory segment containing the converted C string.\n+     * @return a new native segment containing the converted C string.\n@@ -203,1 +203,1 @@\n-    default MemorySegment allocate(ValueLayout.OfAddress layout, Addressable value) {\n+    default MemorySegment allocate(ValueLayout.OfAddress layout, MemorySegment value) {\n@@ -207,1 +207,1 @@\n-        layout.varHandle().set(segment, value.address());\n+        layout.varHandle().set(segment, value);\n@@ -290,4 +290,2 @@\n-        Objects.requireNonNull(array);\n-        Objects.requireNonNull(elementLayout);\n-        int size = Array.getLength(array);\n-        MemorySegment addr = allocateArray(elementLayout, size);\n+        int size = Array.getLength(Objects.requireNonNull(array));\n+        MemorySegment addr = allocateArray(Objects.requireNonNull(elementLayout), size);\n@@ -330,2 +328,2 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(bytesSize, 1)}.\n-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(byteSize, 1)}.\n+     * @param byteSize the size (in bytes) of the block of memory to be allocated.\n@@ -333,1 +331,1 @@\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}\n+     * @throws IllegalArgumentException if {@code byteSize < 0}\n@@ -335,2 +333,2 @@\n-    default MemorySegment allocate(long bytesSize) {\n-        return allocate(bytesSize, 1);\n+    default MemorySegment allocate(long byteSize) {\n+        return allocate(byteSize, 1);\n@@ -340,3 +338,3 @@\n-     * Allocates a memory segment with the given size and alignment constraints.\n-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n-     * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.\n+     * Allocates a memory segment with the given size and alignment constraint.\n+     * @param byteSize the size (in bytes) of the block of memory to be allocated.\n+     * @param byteAlignment the alignment (in bytes) of the block of memory to be allocated.\n@@ -344,1 +342,1 @@\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes <= 0},\n+     * @throws IllegalArgumentException if {@code byteSize < 0}, {@code byteAlignment <= 0},\n@@ -347,1 +345,1 @@\n-    MemorySegment allocate(long bytesSize, long bytesAlignment);\n+    MemorySegment allocate(long byteSize, long byteAlignment);\n@@ -388,1 +386,1 @@\n-     * Creates an arena-based allocator used to allocate native memory segments. The returned allocator features\n+     * Creates an arena-based allocator used to allocate native segments. The returned allocator features\n@@ -392,2 +390,2 @@\n-     * The allocator arena is first initialized by {@linkplain MemorySegment#allocateNative(long, MemorySession) allocating} a\n-     * native memory segment {@code S} of size {@code B}. The allocator then responds to allocation requests in one of the following ways:\n+     * The allocator arena is first initialized by {@linkplain MemorySession#allocate(long) allocating} a\n+     * native segment {@code S} of size {@code B}. The allocator then responds to allocation requests in one of the following ways:\n@@ -452,2 +450,1 @@\n-        Objects.requireNonNull(segment);\n-        return (AbstractMemorySegmentImpl)segment;\n+        return (AbstractMemorySegmentImpl)Objects.requireNonNull(segment);\n@@ -460,1 +457,2 @@\n-     * SegmentAllocator implicitAllocator = (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n+     * SegmentAllocator implicitAllocator = (byteSize, byteAlignment) ->\n+     *         MemorySegment.allocateNative(byteSize, byteAlignment, MemorySession.openImplicit());\n@@ -466,3 +464,3 @@\n-        class Holder {\n-            static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) ->\n-                    MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n+        final class Holder {\n+            static final SegmentAllocator IMPLICIT_ALLOCATOR = (byteSize, byteAlignment) -> MemorySession.openImplicit()\n+                    .allocate(byteSize, byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":26,"deletions":28,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.util.Objects;\n-import java.util.Optional;\n-\n+import jdk.internal.foreign.layout.SequenceLayoutImpl;\n@@ -58,8 +56,1 @@\n-public final class SequenceLayout extends AbstractLayout implements MemoryLayout {\n-\n-    private final long elemCount;\n-    private final MemoryLayout elementLayout;\n-\n-    SequenceLayout(long elemCount, MemoryLayout elementLayout) {\n-        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n-    }\n+public sealed interface SequenceLayout extends MemoryLayout permits SequenceLayoutImpl {\n@@ -67,5 +58,0 @@\n-    SequenceLayout(long elemCount, MemoryLayout elementLayout, long alignment, Optional<String> name) {\n-        super(Math.multiplyExact(elemCount, elementLayout.bitSize()), alignment, name);\n-        this.elemCount = elemCount;\n-        this.elementLayout = elementLayout;\n-    }\n@@ -76,3 +62,1 @@\n-    public MemoryLayout elementLayout() {\n-        return elementLayout;\n-    }\n+    MemoryLayout elementLayout();\n@@ -83,3 +67,1 @@\n-    public long elementCount() {\n-        return elemCount;\n-    }\n+    long elementCount();\n@@ -88,1 +70,1 @@\n-     * Returns a sequence layout with the same element layout, alignment constraints and name as this sequence layout,\n+     * Returns a sequence layout with the same element layout, alignment constraint and name as this sequence layout,\n@@ -94,4 +76,1 @@\n-    public SequenceLayout withElementCount(long elementCount) {\n-        AbstractLayout.checkSize(elementCount, true);\n-        return new SequenceLayout(elementCount, elementLayout, alignment, name());\n-    }\n+    SequenceLayout withElementCount(long elementCount);\n@@ -132,41 +111,1 @@\n-    public SequenceLayout reshape(long... elementCounts) {\n-        Objects.requireNonNull(elementCounts);\n-        if (elementCounts.length == 0) {\n-            throw new IllegalArgumentException();\n-        }\n-        SequenceLayout flat = flatten();\n-        long expectedCount = flat.elementCount();\n-\n-        long actualCount = 1;\n-        int inferPosition = -1;\n-        for (int i = 0 ; i < elementCounts.length ; i++) {\n-            if (elementCounts[i] == -1) {\n-                if (inferPosition == -1) {\n-                    inferPosition = i;\n-                } else {\n-                    throw new IllegalArgumentException(\"Too many unspecified element counts\");\n-                }\n-            } else if (elementCounts[i] <= 0) {\n-                throw new IllegalArgumentException(\"Invalid element count: \" + elementCounts[i]);\n-            } else {\n-                actualCount = elementCounts[i] * actualCount;\n-            }\n-        }\n-\n-        \/\/ infer an unspecified element count (if any)\n-        if (inferPosition != -1) {\n-            long inferredCount = expectedCount \/ actualCount;\n-            elementCounts[inferPosition] = inferredCount;\n-            actualCount = actualCount * inferredCount;\n-        }\n-\n-        if (actualCount != expectedCount) {\n-            throw new IllegalArgumentException(\"Element counts do not match expected size: \" + expectedCount);\n-        }\n-\n-        MemoryLayout res = flat.elementLayout();\n-        for (int i = elementCounts.length - 1 ; i >= 0 ; i--) {\n-            res = MemoryLayout.sequenceLayout(elementCounts[i], res);\n-        }\n-        return (SequenceLayout)res;\n-    }\n+    SequenceLayout reshape(long... elementCounts);\n@@ -190,28 +129,1 @@\n-    public SequenceLayout flatten() {\n-        long count = elementCount();\n-        MemoryLayout elemLayout = elementLayout();\n-        while (elemLayout instanceof SequenceLayout elemSeq) {\n-            count = count * elemSeq.elementCount();\n-            elemLayout = elemSeq.elementLayout();\n-        }\n-        return MemoryLayout.sequenceLayout(count, elemLayout);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return decorateLayoutString(String.format(\"[%s:%s]\",\n-                elemCount, elementLayout));\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof SequenceLayout otherSeq &&\n-                elemCount == otherSeq.elemCount &&\n-                elementLayout.equals(otherSeq.elementLayout);\n-    }\n+    SequenceLayout flatten();\n@@ -220,3 +132,1 @@\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), elemCount, elementLayout);\n-    }\n+    SequenceLayout withName(String name);\n@@ -225,27 +135,1 @@\n-    SequenceLayout dup(long alignment, Optional<String> name) {\n-        return new SequenceLayout(elementCount(), elementLayout, alignment, name);\n-    }\n-\n-    @Override\n-    boolean hasNaturalAlignment() {\n-        return alignment == elementLayout.bitAlignment();\n-    }\n-\n-    \/\/hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout\n-    \/\/but that causes issues with javadoc, see JDK-8224052\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public SequenceLayout withName(String name) {\n-        return (SequenceLayout)super.withName(name);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public SequenceLayout withBitAlignment(long alignmentBits) {\n-        return (SequenceLayout)super.withBitAlignment(alignmentBits);\n-    }\n+    SequenceLayout withBitAlignment(long bitAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":10,"deletions":126,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.layout.StructLayoutImpl;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A <em>struct<\/em> layout where member layouts are laid out one after the other (see {@link MemoryLayout#structLayout(MemoryLayout...)}).\n+ *\n+ * @implSpec\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface StructLayout extends GroupLayout permits StructLayoutImpl {\n+\n+    @Override\n+    StructLayout withName(String name);\n+\n+    @Override\n+    StructLayout withBitAlignment(long bitAlignment);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -48,1 +48,1 @@\n- * A symbol lookup is created with respect to a particular library (or libraries). Subsequently, the {@link SymbolLookup#lookup(String)}\n+ * A symbol lookup is created with respect to a particular library (or libraries). Subsequently, the {@link SymbolLookup#find(String)}\n@@ -53,5 +53,5 @@\n- *     <li>It can be passed to a {@link Linker} to create a downcall method handle, which can then be used to call the foreign function at the segment's base address.<\/li>\n- *     <li>It can be passed to an existing {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle}, as an argument to the underlying foreign function.<\/li>\n- *     <li>It can be {@linkplain MemorySegment#set(ValueLayout.OfAddress, long, Addressable) stored} inside another memory segment.<\/li>\n- *     <li>It can be used to dereference memory associated with a global variable (this might require\n- *     {@link MemorySegment#ofAddress(MemoryAddress, long, MemorySession) resizing} the segment first).<\/li>\n+ *     <li>It can be passed to a {@link Linker} to create a downcall method handle, which can then be used to call the foreign function at the segment's address.<\/li>\n+ *     <li>It can be passed to an existing {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handle}, as an argument to the underlying foreign function.<\/li>\n+ *     <li>It can be {@linkplain MemorySegment#set(ValueLayout.OfAddress, long, MemorySegment) stored} inside another memory segment.<\/li>\n+ *     <li>It can be used to access the region of memory backing a global variable (this might require\n+ *     {@link MemorySegment#ofAddress(long, long, MemorySession) resizing} the segment first).<\/li>\n@@ -67,1 +67,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -70,1 +70,1 @@\n- *     MemorySegment glGetString = libGL.lookup(\"glGetString\").orElseThrow();\n+ *     MemorySegment glGetString = libGL.find(\"glGetString\").orElseThrow();\n@@ -73,1 +73,1 @@\n- * }\n+ *}\n@@ -83,1 +83,1 @@\n- * MemorySegment glGetString = libGL.lookup(\"glGetString\").orElseThrow();\n+ * MemorySegment glGetString = libGL.find(\"glGetString\").orElseThrow();\n@@ -94,4 +94,4 @@\n- * {@snippet lang=java :\n- * libraryLookup(\"libGL.so\", session).lookup(\"glGetString\").isPresent(); \/\/ true\n- * loaderLookup().lookup(\"glGetString\").isPresent(); \/\/ false\n- * }\n+ * {@snippet lang = java:\n+ * libraryLookup(\"libGL.so\", session).find(\"glGetString\").isPresent(); \/\/ true\n+ * loaderLookup().find(\"glGetString\").isPresent(); \/\/ false\n+ *}\n@@ -102,1 +102,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -104,2 +104,2 @@\n- * libraryLookup(\"libGL.so\", session).lookup(\"glGetString\").isPresent(); \/\/ true\n- * }\n+ * libraryLookup(\"libGL.so\", session).find(\"glGetString\").isPresent(); \/\/ true\n+ *}\n@@ -113,1 +113,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -116,2 +116,2 @@\n- * MemorySegment malloc = stdlib.lookup(\"malloc\").orElseThrow();\n- * }\n+ * MemorySegment malloc = stdlib.find(\"malloc\").orElseThrow();\n+ *}\n@@ -126,1 +126,1 @@\n-     * @return a zero-length memory segment whose base address indicates the address of the symbol, if found.\n+     * @return a zero-length memory segment whose address indicates the address of the symbol, if found.\n@@ -128,1 +128,1 @@\n-    Optional<MemorySegment> lookup(String name);\n+    Optional<MemorySegment> find(String name);\n@@ -168,2 +168,2 @@\n-            MemoryAddress addr = MemoryAddress.ofLong(javaLangAccess.findNative(loader, name));\n-            return addr == MemoryAddress.NULL ?\n+            long addr = javaLangAccess.findNative(loader, name);\n+            return addr == 0L ?\n@@ -246,4 +246,4 @@\n-            MemoryAddress addr = MemoryAddress.ofLong(library.find(name));\n-            return addr == MemoryAddress.NULL\n-                    ? Optional.empty() :\n-                    Optional.of(MemorySegment.ofAddress(addr, 0L, session));\n+            long addr = library.find(name);\n+            return addr == 0L ?\n+                    Optional.empty() :\n+                    Optional.of(MemorySegment.ofAddress(addr, 0, session));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.layout.UnionLayoutImpl;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A <em>union<\/em> layout where member layouts are laid out at the same starting offset (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ *\n+ * @implSpec\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface UnionLayout extends GroupLayout permits UnionLayoutImpl {\n+\n+    @Override\n+    UnionLayout withName(String name);\n+\n+    @Override\n+    UnionLayout withBitAlignment(long bitAlignment);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * A variable argument list, similar in functionality to a C {@code va_list}.\n+ * Helper class to create and manipulate variable argument lists, similar in functionality to a C {@code va_list}.\n@@ -44,2 +44,32 @@\n- * A variable argument list is a stateful cursor used to iterate over a set of arguments. A variable argument list\n- * can be passed by reference e.g. to a {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle}.\n+ * A variable argument list segment can be created using the {@link #make(Consumer, MemorySession)} factory, as follows:\n+ * {@snippet lang = java:\n+ * VaList vaList = VaList.make(builder ->\n+ *                                    builder.addVarg(C_INT, 42)\n+ *                                           .addVarg(C_DOUBLE, 3.8d));\n+ *}\n+ * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated a variable\n+ * argument list, which can then be passed to {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handles}\n+ * targeting native functions using the C {@code va_list} type.\n+ * <p>\n+ * The contents of a foreign memory segment modelling a variable argument list can be accessed by <em>unsafely<\/em> creating\n+ * a variable argument list, as follows:\n+ * {@snippet lang = java:\n+ * void upcall(int n, MemorySegment vaListSegment) {\n+ *    try (MemorySession session = MemorySession.openConfined()) {\n+ *        VaList vaList = VaList.ofAddress(vaListSegment.address(), session);\n+ *        VaList copy = vaList.copy();\n+ *        int i = vaList.nextVarg(C_INT);\n+ *        double d = vaList.nextVarg(C_DOUBLE);\n+ *        \/\/ and again\n+ *        int i = copy.nextVarg(C_INT);\n+ *        double d = copy.nextVarg(C_DOUBLE);\n+ *     }\n+ * }\n+ *}\n+ * The above method receives a foreign segment modelling a variable argument list; the contents of the segment are accessed by creating\n+ * a new variable argument list, from the segment address. Note that the variable argument list is first copied into\n+ * a second list before any element is accessed: this will allow us to iterate through the elements twice. Elements in\n+ * the variable argument list are accessed using {@link #nextVarg(ValueLayout.OfInt)} and\n+ * {@link #nextVarg(ValueLayout.OfDouble)}. These methods (as well as other access methods in the {@link VaList} class)\n+ * take the layout of the element that needs to be accessed and perform all the necessary alignment checks as well\n+ * as endianness conversions.\n@@ -61,1 +91,1 @@\n- *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(MemoryAddress, MemorySession)} are not capable of detecting out-of-bounds reads<\/li>\n+ *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, MemorySession)} are not capable of detecting out-of-bounds reads<\/li>\n@@ -65,1 +95,1 @@\n- * (regardless of the memory session associated with the variable arity list).\n+ * (regardless of the session associated with the variable arity list).\n@@ -70,6 +100,1 @@\n-sealed public interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n-\n-    \/**\n-     * {@return the memory session associated with this variable argument list}\n-     *\/\n-    MemorySession session();\n+public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n@@ -83,1 +108,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -86,1 +111,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -97,1 +122,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -100,1 +125,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -111,1 +136,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -114,1 +139,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -120,2 +145,6 @@\n-     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function.\n+     * Reads the next address value, wraps it into a native segment, and advances this variable argument list's position.\n+     * The behavior of this method is equivalent to the C {@code va_arg} function. The returned segment's base\n+     * {@linkplain MemorySegment#address()} is set to the value read from the variable argument list, and the segment\n+     * is associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions, the size of the returned\n+     * segment is {@code 0}. However, if the provided layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded}\n+     * address layout, then the size of the returned segment is {@code Long.MAX_VALUE}.\n@@ -124,2 +153,3 @@\n-     * @return the {@code MemoryAddress} value read from this variable argument list.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @return a native segment whose {@linkplain MemorySegment#address() address} is the value read from\n+     * this variable argument list.\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -128,1 +158,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -131,1 +161,1 @@\n-    MemoryAddress nextVarg(ValueLayout.OfAddress layout);\n+    MemorySegment nextVarg(ValueLayout.OfAddress layout);\n@@ -134,3 +164,3 @@\n-     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function. The provided group layout must correspond to a C struct or union\n-     * type.\n+     * Reads the next composite value into a new {@code MemorySegment}, allocated with the provided allocator,\n+     * and advances this variable argument list's position. The behavior of this method is equivalent to the C\n+     * {@code va_arg} function. The provided group layout must correspond to a C struct or union type.\n@@ -148,1 +178,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -151,1 +181,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -160,1 +190,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -163,1 +193,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -178,1 +208,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -181,1 +211,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -186,5 +216,6 @@\n-     * {@return the {@linkplain MemoryAddress memory address} associated with this variable argument list}\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * Returns a zero-length {@linkplain MemorySegment memory segment} associated with this variable argument list.\n+     * The contents of the returned memory segment are platform-dependent. Whether and how the contents of\n+     * the returned segment are updated when iterating the contents of a variable argument list is also\n+     * platform-dependent. The returned segment's memory session is the session which manages the lifecycle of this\n+     * variable argument list.\n+     * @return a zero-length {@linkplain MemorySegment memory segment} associated with this variable argument list.\n@@ -192,2 +223,1 @@\n-    @Override\n-    MemoryAddress address();\n+    MemorySegment segment();\n@@ -196,2 +226,4 @@\n-     * Creates a variable argument list from a memory address pointing to an existing variable argument list,\n-     * with the given memory session.\n+     * Creates a variable argument list from the give address value and memory session. The address is typically obtained\n+     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided session determines\n+     * the lifecycle of the returned variable argument list: when the session is {@linkplain MemorySession#close() closed},\n+     * the returned variable argument list will no longer be accessible.\n@@ -204,3 +236,1 @@\n-     * @implNote variable argument lists created using this method can not detect <a href=VaList.html#safety>out-of-bounds<\/a> reads.\n-     *\n-     * @param address a memory address pointing to an existing variable argument list.\n+     * @param address the address of the variable argument list.\n@@ -208,4 +238,4 @@\n-     * @return a new variable argument list backed by the memory region at {@code address}.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     * @return a new variable argument list backed by an off-heap region of memory starting at the given address value.\n+     * @throws IllegalStateException         if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread other than the thread\n+     *                                       {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -218,1 +248,1 @@\n-    static VaList ofAddress(MemoryAddress address, MemorySession session) {\n+    static VaList ofAddress(long address, MemorySession session) {\n@@ -220,1 +250,0 @@\n-        Objects.requireNonNull(address);\n@@ -230,1 +259,1 @@\n-     * memory session, and will be released when the memory session is {@linkplain MemorySession#close closed}.\n+     * session, and will be released when the session is {@linkplain MemorySession#close closed}.\n@@ -255,1 +284,1 @@\n-     * on all operations, except for {@link VaList#address()}, {@link VaList#copy()} and {@link VaList#session()}.\n+     * on all operations, except for {@link VaList#segment()}, {@link VaList#copy()}.\n@@ -299,1 +328,2 @@\n-         * Writes an {@code Addressable} value to the variable argument list being constructed.\n+         * Writes the {@linkplain MemorySegment#address() address} of the provided native segment\n+         * to the variable argument list being constructed.\n@@ -302,1 +332,1 @@\n-         * @param value the {@code Addressable} value to be written.\n+         * @param segment the segment whose {@linkplain MemorySegment#address() address} is to be written.\n@@ -305,1 +335,1 @@\n-        Builder addVarg(ValueLayout.OfAddress layout, Addressable value);\n+        Builder addVarg(ValueLayout.OfAddress layout, MemorySegment segment);\n@@ -308,1 +338,1 @@\n-         * Writes a {@code MemorySegment} value, with the given layout, to the variable argument list being constructed.\n+         * Writes a {@code MemorySegment}, with the given layout, to the variable argument list being constructed.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":86,"deletions":56,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -31,4 +31,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -36,1 +32,1 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -38,4 +34,1 @@\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-import sun.invoke.util.Wrapper;\n+import jdk.internal.reflect.CallerSensitive;\n@@ -47,1 +40,1 @@\n- * {@linkplain MemorySegment#get(OfInt, long) accessing} a memory region using the value layout.\n+ * {@linkplain MemorySegment#get(OfInt, long) accessing} a region of memory using the value layout.\n@@ -54,2 +47,1 @@\n- * @implSpec\n- * This class and its subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * @implSpec implementing classes and subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -60,17 +52,1 @@\n-public sealed class ValueLayout extends AbstractLayout implements MemoryLayout {\n-\n-    private final Class<?> carrier;\n-    private final ByteOrder order;\n-\n-    private static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n-\n-    ValueLayout(Class<?> carrier, ByteOrder order, long size) {\n-        this(carrier, order, size, size, Optional.empty());\n-    }\n-\n-    ValueLayout(Class<?> carrier, ByteOrder order, long size, long alignment, Optional<String> name) {\n-        super(size, alignment, name);\n-        this.carrier = carrier;\n-        this.order = order;\n-        checkCarrierSize(carrier, size);\n-    }\n+public sealed interface ValueLayout extends MemoryLayout {\n@@ -81,3 +57,1 @@\n-    public ByteOrder order() {\n-        return order;\n-    }\n+    ByteOrder order();\n@@ -86,1 +60,1 @@\n-     * Returns a value layout with the same carrier, alignment constraints and name as this value layout,\n+     * Returns a value layout with the same carrier, alignment constraint and name as this value layout,\n@@ -92,3 +66,1 @@\n-    public ValueLayout withOrder(ByteOrder order) {\n-        return new ValueLayout(carrier, Objects.requireNonNull(order), bitSize(), alignment, name());\n-    }\n+    ValueLayout withOrder(ByteOrder order);\n@@ -97,30 +69,2 @@\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public String toString() {\n-        char descriptor = carrier == MemoryAddress.class ? 'A' : carrier.descriptorString().charAt(0);\n-        if (order == ByteOrder.LITTLE_ENDIAN) {\n-            descriptor = Character.toLowerCase(descriptor);\n-        }\n-        return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof ValueLayout otherValue &&\n-                carrier.equals(otherValue.carrier) &&\n-                order.equals(otherValue.order);\n-    }\n-\n-    \/**\n-     * Creates a <em>strided<\/em> access var handle that can be used to dereference a multi-dimensional array. The\n-     * layout of this array is a sequence layout with {@code shape.length} nested sequence layouts. The element\n+     * Creates a <em>strided<\/em> access var handle that can be used to access a memory segment as multi-dimensional\n+     * array. The layout of this array is a sequence layout with {@code shape.length} nested sequence layouts. The element\n@@ -141,2 +85,2 @@\n-     * {@snippet lang=java :\n-     * SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(-1,\n+     * {@snippet lang = java:\n+     * SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(\n@@ -145,1 +89,1 @@\n-     * }\n+     *}\n@@ -149,1 +93,1 @@\n-     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset dereferenced by the var handle can be\n+     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset accessed by the var handle can be\n@@ -173,1 +117,2 @@\n-     * @return a var handle which can be used to dereference a multi-dimensional array, featuring {@code shape.length + 1}\n+     * @return a var handle which can be used to access a memory segment as a multi-dimensional array,\n+     * featuring {@code shape.length + 1}\n@@ -181,14 +126,1 @@\n-    public VarHandle arrayElementVarHandle(int... shape) {\n-        Objects.requireNonNull(shape);\n-        MemoryLayout layout = this;\n-        List<PathElement> path = new ArrayList<>();\n-        for (int i = shape.length ; i > 0 ; i--) {\n-            int size = shape[i - 1];\n-            if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n-            layout = MemoryLayout.sequenceLayout(size, layout);\n-            path.add(PathElement.sequenceElement());\n-        }\n-        layout = MemoryLayout.sequenceLayout(-1, layout);\n-        path.add(PathElement.sequenceElement());\n-        return layout.varHandle(path.toArray(new PathElement[0]));\n-    }\n+    VarHandle arrayElementVarHandle(int... shape);\n@@ -199,19 +131,1 @@\n-    public Class<?> carrier() {\n-        return carrier;\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), order, carrier);\n-    }\n-\n-    @Override\n-    ValueLayout dup(long alignment, Optional<String> name) {\n-        return new ValueLayout(carrier, order, bitSize(), alignment, name());\n-    }\n-\n-    \/\/hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout\n-    \/\/but that causes issues with javadoc, see JDK-8224052\n+    Class<?> carrier();\n@@ -219,3 +133,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -223,3 +134,1 @@\n-    public ValueLayout withName(String name) {\n-        return (ValueLayout)super.withName(name);\n-    }\n+    ValueLayout withName(String name);\n@@ -227,3 +136,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -231,3 +137,0 @@\n-    public ValueLayout withBitAlignment(long alignmentBits) {\n-        return (ValueLayout)super.withBitAlignment(alignmentBits);\n-    }\n@@ -235,38 +138,1 @@\n-    static void checkCarrierSize(Class<?> carrier, long size) {\n-        if (!isValidCarrier(carrier)) {\n-            throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n-        }\n-        if (carrier == MemoryAddress.class && size != ADDRESS_SIZE_BITS) {\n-            throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n-        }\n-        if (carrier.isPrimitive()) {\n-            int expectedSize =  carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n-            if (size != expectedSize) {\n-                throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n-            }\n-        }\n-    }\n-\n-    static boolean isValidCarrier(Class<?> carrier) {\n-        return carrier == boolean.class\n-                || carrier == byte.class\n-                || carrier == short.class\n-                || carrier == char.class\n-                || carrier == int.class\n-                || carrier == long.class\n-                || carrier == float.class\n-                || carrier == double.class\n-                || carrier == MemoryAddress.class;\n-    }\n-\n-    @Stable\n-    private VarHandle handle;\n-\n-    @ForceInline\n-    VarHandle accessHandle() {\n-        if (handle == null) {\n-            \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n-            handle = Utils.makeSegmentViewVarHandle(this);\n-        }\n-        return handle;\n-    }\n+    ValueLayout withBitAlignment(long bitAlignment);\n@@ -276,0 +142,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_BOOLEAN}.\n@@ -279,9 +147,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfBoolean extends ValueLayout {\n-        OfBoolean(ByteOrder order) {\n-            super(boolean.class, order, 8);\n-        }\n-\n-        OfBoolean(ByteOrder order, long alignment, Optional<String> name) {\n-            super(boolean.class, order, 8, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n@@ -290,3 +151,1 @@\n-        OfBoolean dup(long alignment, Optional<String> name) {\n-            return new OfBoolean(order(), alignment, name);\n-        }\n+        OfBoolean withName(String name);\n@@ -295,3 +154,1 @@\n-        public OfBoolean withName(String name) {\n-            return (OfBoolean)super.withName(name);\n-        }\n+        OfBoolean withBitAlignment(long bitAlignment);\n@@ -300,3 +157,1 @@\n-        public OfBoolean withBitAlignment(long alignmentBits) {\n-            return (OfBoolean)super.withBitAlignment(alignmentBits);\n-        }\n+        OfBoolean withOrder(ByteOrder order);\n@@ -304,5 +159,0 @@\n-        @Override\n-        public OfBoolean withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfBoolean(order, alignment, name());\n-        }\n@@ -313,0 +163,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_BYTE}.\n@@ -316,9 +168,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfByte extends ValueLayout {\n-        OfByte(ByteOrder order) {\n-            super(byte.class, order, 8);\n-        }\n-\n-        OfByte(ByteOrder order, long alignment, Optional<String> name) {\n-            super(byte.class, order, 8, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n@@ -327,3 +172,1 @@\n-        OfByte dup(long alignment, Optional<String> name) {\n-            return new OfByte(order(), alignment, name);\n-        }\n+        OfByte withName(String name);\n@@ -332,3 +175,1 @@\n-        public OfByte withName(String name) {\n-            return (OfByte)super.withName(name);\n-        }\n+        OfByte withBitAlignment(long bitAlignment);\n@@ -337,3 +178,1 @@\n-        public OfByte withBitAlignment(long alignmentBits) {\n-            return (OfByte)super.withBitAlignment(alignmentBits);\n-        }\n+        OfByte withOrder(ByteOrder order);\n@@ -341,5 +180,0 @@\n-        @Override\n-        public OfByte withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfByte(order, alignment, name());\n-        }\n@@ -350,0 +184,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_CHAR}.\n@@ -353,9 +189,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfChar extends ValueLayout {\n-        OfChar(ByteOrder order) {\n-            super(char.class, order, 16);\n-        }\n-\n-        OfChar(ByteOrder order, long alignment, Optional<String> name) {\n-            super(char.class, order, 16, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n@@ -364,3 +193,1 @@\n-        OfChar dup(long alignment, Optional<String> name) {\n-            return new OfChar(order(), alignment, name);\n-        }\n+        OfChar withName(String name);\n@@ -369,3 +196,1 @@\n-        public OfChar withName(String name) {\n-            return (OfChar)super.withName(name);\n-        }\n+        OfChar withBitAlignment(long bitAlignment);\n@@ -374,3 +199,1 @@\n-        public OfChar withBitAlignment(long alignmentBits) {\n-            return (OfChar)super.withBitAlignment(alignmentBits);\n-        }\n+        OfChar withOrder(ByteOrder order);\n@@ -378,5 +201,0 @@\n-        @Override\n-        public OfChar withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfChar(order, alignment, name());\n-        }\n@@ -387,0 +205,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_SHORT}.\n@@ -390,9 +210,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfShort extends ValueLayout {\n-        OfShort(ByteOrder order) {\n-            super(short.class, order, 16);\n-        }\n-\n-        OfShort(ByteOrder order, long alignment, Optional<String> name) {\n-            super(short.class, order, 16, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n@@ -401,3 +214,1 @@\n-        OfShort dup(long alignment, Optional<String> name) {\n-            return new OfShort(order(), alignment, name);\n-        }\n+        OfShort withName(String name);\n@@ -406,3 +217,1 @@\n-        public OfShort withName(String name) {\n-            return (OfShort)super.withName(name);\n-        }\n+        OfShort withBitAlignment(long bitAlignment);\n@@ -411,3 +220,1 @@\n-        public OfShort withBitAlignment(long alignmentBits) {\n-            return (OfShort)super.withBitAlignment(alignmentBits);\n-        }\n+        OfShort withOrder(ByteOrder order);\n@@ -415,5 +222,0 @@\n-        @Override\n-        public OfShort withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfShort(order, alignment, name());\n-        }\n@@ -424,0 +226,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_INT}.\n@@ -427,9 +231,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfInt extends ValueLayout {\n-        OfInt(ByteOrder order) {\n-            super(int.class, order, 32);\n-        }\n-\n-        OfInt(ByteOrder order, long alignment, Optional<String> name) {\n-            super(int.class, order, 32, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n@@ -438,3 +235,1 @@\n-        OfInt dup(long alignment, Optional<String> name) {\n-            return new OfInt(order(), alignment, name);\n-        }\n+        OfInt withName(String name);\n@@ -443,3 +238,1 @@\n-        public OfInt withName(String name) {\n-            return (OfInt)super.withName(name);\n-        }\n+        OfInt withBitAlignment(long bitAlignment);\n@@ -448,3 +241,1 @@\n-        public OfInt withBitAlignment(long alignmentBits) {\n-            return (OfInt)super.withBitAlignment(alignmentBits);\n-        }\n+        OfInt withOrder(ByteOrder order);\n@@ -452,5 +243,0 @@\n-        @Override\n-        public OfInt withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfInt(order, alignment, name());\n-        }\n@@ -461,0 +247,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_FLOAT}.\n@@ -464,9 +252,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfFloat extends ValueLayout {\n-        OfFloat(ByteOrder order) {\n-            super(float.class, order, 32);\n-        }\n-\n-        OfFloat(ByteOrder order, long alignment, Optional<String> name) {\n-            super(float.class, order, 32, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n@@ -475,3 +256,1 @@\n-        OfFloat dup(long alignment, Optional<String> name) {\n-            return new OfFloat(order(), alignment, name);\n-        }\n+        OfFloat withName(String name);\n@@ -480,3 +259,1 @@\n-        public OfFloat withName(String name) {\n-            return (OfFloat)super.withName(name);\n-        }\n+        OfFloat withBitAlignment(long bitAlignment);\n@@ -485,3 +262,1 @@\n-        public OfFloat withBitAlignment(long alignmentBits) {\n-            return (OfFloat)super.withBitAlignment(alignmentBits);\n-        }\n+        OfFloat withOrder(ByteOrder order);\n@@ -489,5 +264,0 @@\n-        @Override\n-        public OfFloat withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfFloat(order, alignment, name());\n-        }\n@@ -498,0 +268,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_LONG}.\n@@ -501,9 +273,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfLong extends ValueLayout {\n-        OfLong(ByteOrder order) {\n-            super(long.class, order, 64);\n-        }\n-\n-        OfLong(ByteOrder order, long alignment, Optional<String> name) {\n-            super(long.class, order, 64, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n@@ -512,3 +277,1 @@\n-        OfLong dup(long alignment, Optional<String> name) {\n-            return new OfLong(order(), alignment, name);\n-        }\n+        OfLong withName(String name);\n@@ -517,3 +280,1 @@\n-        public OfLong withName(String name) {\n-            return (OfLong)super.withName(name);\n-        }\n+        OfLong withBitAlignment(long bitAlignment);\n@@ -522,3 +283,1 @@\n-        public OfLong withBitAlignment(long alignmentBits) {\n-            return (OfLong)super.withBitAlignment(alignmentBits);\n-        }\n+        OfLong withOrder(ByteOrder order);\n@@ -526,5 +285,0 @@\n-        @Override\n-        public OfLong withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfLong(order, alignment, name());\n-        }\n@@ -535,0 +289,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_LONG}.\n@@ -538,9 +294,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfDouble extends ValueLayout {\n-        OfDouble(ByteOrder order) {\n-            super(double.class, order, 64);\n-        }\n-\n-        OfDouble(ByteOrder order, long alignment, Optional<String> name) {\n-            super(double.class, order, 64, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n@@ -549,3 +298,1 @@\n-        OfDouble dup(long alignment, Optional<String> name) {\n-            return new OfDouble(order(), alignment, name);\n-        }\n+        OfDouble withName(String name);\n@@ -554,3 +301,1 @@\n-        public OfDouble withName(String name) {\n-            return (OfDouble)super.withName(name);\n-        }\n+        OfDouble withBitAlignment(long bitAlignment);\n@@ -559,3 +304,1 @@\n-        public OfDouble withBitAlignment(long alignmentBits) {\n-            return (OfDouble)super.withBitAlignment(alignmentBits);\n-        }\n+        OfDouble withOrder(ByteOrder order);\n@@ -563,5 +306,0 @@\n-        @Override\n-        public OfDouble withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfDouble(order, alignment, name());\n-        }\n@@ -571,1 +309,3 @@\n-     * A value layout whose carrier is {@code MemoryAddress.class}.\n+     * A value layout whose carrier is {@code MemorySegment.class}.\n+     * <p>\n+     * New instances of this type can be created using {@link #ADDRESS}.\n@@ -575,9 +315,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfAddress extends ValueLayout {\n-        OfAddress(ByteOrder order) {\n-            super(MemoryAddress.class, order, ADDRESS_SIZE_BITS);\n-        }\n-\n-        OfAddress(ByteOrder order, long size, long alignment, Optional<String> name) {\n-            super(MemoryAddress.class, order, size, alignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfAddress extends ValueLayout permits ValueLayouts.OfAddressImpl {\n@@ -586,3 +319,1 @@\n-        OfAddress dup(long alignment, Optional<String> name) {\n-            return new OfAddress(order(), bitSize(), alignment, name);\n-        }\n+        OfAddress withName(String name);\n@@ -591,3 +322,1 @@\n-        public OfAddress withName(String name) {\n-            return (OfAddress)super.withName(name);\n-        }\n+        OfAddress withBitAlignment(long bitAlignment);\n@@ -596,3 +325,23 @@\n-        public OfAddress withBitAlignment(long alignmentBits) {\n-            return (OfAddress)super.withBitAlignment(alignmentBits);\n-        }\n+        OfAddress withOrder(ByteOrder order);\n+\n+        \/**\n+         * Returns an <em>unbounded<\/em> address layout with the same carrier, alignment constraint, name and order as this address layout,\n+         * but with the specified pointee layout. An unbounded address layouts allow raw addresses to be accessed\n+         * as {@linkplain MemorySegment memory segments} whose size is set to {@link Long#MAX_VALUE}. As such,\n+         * these segments can be used in subsequent access operations.\n+         * <p>\n+         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+         * restricted methods, and use safe and supported functionalities, where possible.\n+         *\n+         * @return an unbounded address layout with same characteristics as this layout.\n+         * @see #isUnbounded()\n+         *\/\n+        @CallerSensitive\n+        OfAddress asUnbounded();\n+\n+        \/**\n+         * {@return {@code true}, if this address layout is an {@linkplain #asUnbounded() unbounded address layout}}.\n+         *\/\n+        boolean isUnbounded();\n@@ -600,5 +349,0 @@\n-        @Override\n-        public OfAddress withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfAddress(order, bitSize(), alignment, name());\n-        }\n@@ -609,1 +353,1 @@\n-     * bit alignment set to {@code sizeof(size_t) * 8}, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * bit alignment set to {@code sizeof(size_t) * 8}, byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -612,1 +356,1 @@\n-     * MemoryLayout.valueLayout(MemoryAddress.class, ByteOrder.nativeOrder())\n+     * ADDRESS.of(ByteOrder.nativeOrder())\n@@ -616,2 +360,1 @@\n-    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder())\n-            .withBitAlignment(ValueLayout.ADDRESS_SIZE_BITS);\n+    OfAddress ADDRESS = ValueLayouts.OfAddressImpl.of(ByteOrder.nativeOrder());\n@@ -624,1 +367,1 @@\n-     * MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * JAVA_BYTE.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n@@ -627,1 +370,1 @@\n-    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder()).withBitAlignment(8);\n+    OfByte JAVA_BYTE = ValueLayouts.OfByteImpl.of(ByteOrder.nativeOrder());\n@@ -634,1 +377,1 @@\n-     * MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * JAVA_BOOLEAN.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n@@ -637,1 +380,1 @@\n-    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder()).withBitAlignment(8);\n+    OfBoolean JAVA_BOOLEAN = ValueLayouts.OfBooleanImpl.of(ByteOrder.nativeOrder());\n@@ -644,1 +387,1 @@\n-     * MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * JAVA_CHAR.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n@@ -647,1 +390,1 @@\n-    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder()).withBitAlignment(16);\n+    OfChar JAVA_CHAR = ValueLayouts.OfCharImpl.of(ByteOrder.nativeOrder());\n@@ -654,1 +397,1 @@\n-     * MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * JAVA_SHORT.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n@@ -657,1 +400,1 @@\n-    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder()).withBitAlignment(16);\n+    OfShort JAVA_SHORT = ValueLayouts.OfShortImpl.of(ByteOrder.nativeOrder());\n@@ -664,1 +407,1 @@\n-     * MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * JAVA_INT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n@@ -667,1 +410,1 @@\n-    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder()).withBitAlignment(32);\n+    OfInt JAVA_INT = ValueLayouts.OfIntImpl.of(ByteOrder.nativeOrder());\n@@ -674,1 +417,1 @@\n-     * MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * JAVA_LONG.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n@@ -677,2 +420,1 @@\n-    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder())\n-            .withBitAlignment(64);\n+    OfLong JAVA_LONG = ValueLayouts.OfLongImpl.of(ByteOrder.nativeOrder());\n@@ -685,1 +427,1 @@\n-     * MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * JAVA_FLOAT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n@@ -688,1 +430,1 @@\n-    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder()).withBitAlignment(32);\n+    OfFloat JAVA_FLOAT = ValueLayouts.OfFloatImpl.of(ByteOrder.nativeOrder());\n@@ -695,1 +437,1 @@\n-     * MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * JAVA_DOUBLE.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n@@ -698,1 +440,86 @@\n-    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder()).withBitAlignment(64);\n+    OfDouble JAVA_DOUBLE = ValueLayouts.OfDoubleImpl.of(ByteOrder.nativeOrder());\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a machine address ({@code size_t}),\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * ADDRESS.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code char}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_CHAR.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code short}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_SHORT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code int}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_INT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code long}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_LONG.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code float}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_FLOAT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code double}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_DOUBLE.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":210,"deletions":383,"binary":false,"changes":593,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * models a contiguous memory region, residing either inside or outside the Java heap. The contents of a memory\n+ * models a contiguous region of memory, residing either inside or outside the Java heap. The contents of a memory\n@@ -37,1 +37,1 @@\n- * an alternate, more abstract way, to <a href=MemorySegment.html#segment-deref>dereference memory segments<\/a>\n+ * an alternate, more abstract way, to <a href=MemorySegment.html#segment-deref>access memory segments<\/a>\n@@ -41,2 +41,2 @@\n- * For example, to allocate an off-heap memory region big enough to hold 10 values of the primitive type {@code int}, and fill it with values\n- * ranging from {@code 0} to {@code 9}, we can use the following code:\n+ * For example, to allocate an off-heap region of memory big enough to hold 10 values of the primitive type {@code int},\n+ * and fill it with values ranging from {@code 0} to {@code 9}, we can use the following code:\n@@ -53,0 +53,5 @@\n+ * The off-heap memory backing the native segment will be released when the segment becomes\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>; this is similar to what happens\n+ * with direct buffers created via {@link java.nio.ByteBuffer#allocateDirect(int)}. It is also possible to manage\n+ * the lifecycle of allocated native segments more directly, as shown in a later section.\n+ * <p>\n@@ -54,3 +59,3 @@\n- * {@linkplain java.lang.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) dereference method}\n- * accepts a {@linkplain java.lang.foreign.ValueLayout value layout}, which specifies the size, alignment constraints,\n- * byte order as well as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+ * {@linkplain java.lang.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) access method}\n+ * accepts a {@linkplain java.lang.foreign.ValueLayout value layout}, which specifies the size, alignment constraint,\n+ * byte order as well as the Java type ({@code int}, in this case) associated with the access operation. More specifically,\n@@ -67,2 +72,2 @@\n- * Clients that operate under these assumptions might want to programmatically release the memory associated\n- * with a memory segment. This can be done, using the {@link java.lang.foreign.MemorySession} abstraction, as shown below:\n+ * Clients that operate under these assumptions might want to programmatically release the memory backing a memory segment.\n+ * This can be done, using the {@link java.lang.foreign.MemorySession} abstraction, as shown below:\n@@ -72,1 +77,1 @@\n- *     MemorySegment segment = MemorySegment.allocateNative(10 * 4, session);\n+ *     MemorySegment segment = session.allocate(10 * 4);\n@@ -88,1 +93,1 @@\n- * <em>outside<\/em> the boundaries of the memory segment used by the dereference operation. We call this guarantee <em>spatial safety<\/em>;\n+ * <em>outside<\/em> the boundaries of the memory segment used by the access operation. We call this guarantee <em>spatial safety<\/em>;\n@@ -95,1 +100,1 @@\n- * operation either succeeds - and accesses a valid memory location - or fails.\n+ * operation either succeeds - and accesses a valid location of the region of memory backing the memory segment - or fails.\n@@ -108,1 +113,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -112,1 +117,1 @@\n- *     stdlib.lookup(\"strlen\").get(),\n+ *     stdlib.find(\"strlen\").get(),\n@@ -117,1 +122,1 @@\n- *     MemorySegment cString = MemorySegment.allocateNative(5 + 1, session);\n+ *     MemorySegment cString = session.allocate(5 + 1);\n@@ -121,1 +126,1 @@\n- * }\n+ *}\n@@ -124,1 +129,1 @@\n- * to {@linkplain java.lang.foreign.SymbolLookup#lookup(java.lang.String) look up} the {@code strlen} symbol in the\n+ * to {@linkplain java.lang.foreign.SymbolLookup#find(java.lang.String) look up} the {@code strlen} symbol in the\n@@ -126,1 +131,1 @@\n- * {@linkplain java.lang.foreign.Linker#downcallHandle(java.lang.foreign.FunctionDescriptor) obtained}.\n+ * {@linkplain java.lang.foreign.Linker#downcallHandle(FunctionDescriptor, Linker.Option...) obtained}.\n@@ -137,31 +142,0 @@\n- * <h3 id=\"addresses\">Foreign addresses<\/h3>\n- *\n- * When a memory segment is created from Java code, the segment properties (spatial bounds, temporal bounds and confinement)\n- * are fully known at segment creation. But when interacting with foreign functions, clients will often receive <em>raw<\/em> pointers.\n- * Such pointers have no spatial bounds. For example, the C type {@code char*} can refer to a single {@code char} value,\n- * or an array of {@code char} values, of given size. Nor do said pointers have any notion of temporal bounds or thread-confinement.\n- * <p>\n- * Raw pointers are modelled using the {@link java.lang.foreign.MemoryAddress} class. When clients receive a\n- * memory address instance from a foreign function call, they can perform memory dereference on it directly,\n- * using one of the many <em>unsafe<\/em>\n- * {@linkplain java.lang.foreign.MemoryAddress#get(java.lang.foreign.ValueLayout.OfInt, long) dereference methods}\n- * provided:\n- *\n- * {@snippet lang=java :\n- * MemoryAddress addr = ... \/\/ obtain address from foreign function call\n- * int x = addr.get(ValueLayout.JAVA_INT, 0);\n- * }\n- *\n- * Alternatively, the client can\n- * {@linkplain java.lang.foreign.MemorySegment#ofAddress(java.lang.foreign.MemoryAddress, long, java.lang.foreign.MemorySession) create}\n- * a memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial bounds which might,\n- * for instance, be available in the documentation of the foreign function which produced the native address.\n- * Here is how an unsafe segment can be created from a memory address:\n- *\n- * {@snippet lang=java :\n- * MemorySession session = ... \/\/ initialize a memory session object\n- * MemoryAddress addr = ... \/\/ obtain address from foreign function call\n- * MemorySegment segment = MemorySegment.ofAddress(addr, 4, session); \/\/ segment is 4 bytes long\n- * int x = segment.get(ValueLayout.JAVA_INT, 0);\n- * }\n- *\n@@ -170,1 +144,1 @@\n- * to a Java method) into a memory address, so that Java code can effectively be passed to other foreign functions.\n+ * to a Java method) into a memory segment, so that Java code can effectively be passed to other foreign functions.\n@@ -175,2 +149,4 @@\n- *     static int intCompare(MemoryAddress addr1, MemoryAddress addr2) {\n- *         return addr1.get(ValueLayout.JAVA_INT, 0) - addr2.get(ValueLayout.JAVA_INT, 0);\n+ *     static int intCompare(MemorySegment addr1, MemorySegment addr2) {\n+ *         return addr1.get(ValueLayout.JAVA_INT, 0) -\n+ *                addr2.get(ValueLayout.JAVA_INT, 0);\n+ *\n@@ -181,1 +157,1 @@\n- * The above method dereferences two memory addresses containing an integer value, and performs a simple comparison\n+ * The above method accesses two foreign memory segments containing an integer value, and performs a simple comparison\n@@ -185,2 +161,4 @@\n- * {@snippet lang=java :\n- * FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);\n+ * {@snippet lang = java:\n+ * FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT,\n+ *                                                                 ValueLayout.ADDRESS.asUnbounded(),\n+ *                                                                 ValueLayout.ADDRESS.asUnbounded());\n@@ -190,1 +168,1 @@\n- * }\n+ *}\n@@ -194,1 +172,1 @@\n- * {@linkplain java.lang.foreign.Linker#upcallType(java.lang.foreign.FunctionDescriptor) derive} a method type\n+ * {@linkplain java.lang.foreign.FunctionDescriptor#toMethodType() derive} a method type\n@@ -200,1 +178,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -202,1 +180,1 @@\n- * Addressable comparFunc = Linker.nativeLinker().upcallStub(\n+ * MemorySegment comparFunc = Linker.nativeLinker().upcallStub(\n@@ -205,1 +183,1 @@\n- * }\n+ *}\n@@ -208,1 +186,1 @@\n- * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, java.lang.foreign.FunctionDescriptor, java.lang.foreign.MemorySession) create}\n+ * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, MemorySession) create}\n@@ -219,1 +197,1 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, MemorySession)}\n+ * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)}\n@@ -223,1 +201,1 @@\n- * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, MemorySession)},\n+ * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)},\n@@ -225,1 +203,1 @@\n- * memory when attempting to dereference said segment. For these reasons, it is crucial for code that calls a restricted method\n+ * memory when attempting to access said segment. For these reasons, it is crucial for code that calls a restricted method\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":42,"deletions":64,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -50,0 +49,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -7913,1 +7913,1 @@\n-     *     {@code float}, {@code double} or {@link MemoryAddress}.\n+     *     {@code float}, {@code double} or {@link MemorySegment}.\n@@ -7916,1 +7916,1 @@\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n+     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n@@ -7919,1 +7919,1 @@\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n+     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n@@ -7924,1 +7924,1 @@\n-     * If {@code T} is {@code float}, {@code double} or {@link MemoryAddress} then atomic\n+     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n@@ -7927,1 +7927,1 @@\n-     * {@link Double#doubleToRawLongBits} and {@link MemoryAddress#toRawLongValue()}, respectively).\n+     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-        if (!allTypesPrimitive(type))\n-            throw new IllegalArgumentException(\"Type must only contain primitives: \" + type);\n+        if (hasIllegalType(type))\n+            throw new IllegalArgumentException(\"Illegal type(s) found: \" + type);\n@@ -63,3 +63,3 @@\n-    private static boolean allTypesPrimitive(MethodType type) {\n-        if (!type.returnType().isPrimitive())\n-            return false;\n+    private static boolean hasIllegalType(MethodType type) {\n+        if (isIllegalType(type.returnType()))\n+            return true;\n@@ -68,2 +68,2 @@\n-            if (!pType.isPrimitive())\n-                return false;\n+            if (isIllegalType(pType))\n+                return true;\n@@ -72,1 +72,9 @@\n-        return true;\n+        return false;\n+    }\n+\n+    private static boolean isIllegalType(Class<?> pType) {\n+        return !(pType == long.class\n+              || pType == int.class\n+              || pType == float.class\n+              || pType == double.class\n+              || pType == void.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1005,2 +1005,3 @@\n-     * Maps a region of this channel's file into a new mapped memory segment,\n-     * with the given offset, size and memory session.\n+     * Maps a region of this channel's file into a new mapped memory segment, with the given offset,\n+     * size and memory session. The {@linkplain MemorySegment#address() address} of the returned memory segment\n+     * is the starting address of the mapped off-heap region backing the segment.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-    void addEnableNativeAccessAllUnnamed();\n+    void addEnableNativeAccessToAllUnnamed();\n@@ -276,1 +276,2 @@\n-     * Returns true if module m can access restricted methods.\n+     * Ensure that the given module has native access. If not, warn or\n+     * throw exception depending on the configuration.\n@@ -278,1 +279,1 @@\n-    boolean isEnableNativeAccess(Module m);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySession;\n@@ -31,1 +31,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -34,0 +33,1 @@\n+import java.lang.reflect.Array;\n@@ -54,0 +54,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -69,1 +70,3 @@\n-public abstract non-sealed class AbstractMemorySegmentImpl implements MemorySegment, SegmentAllocator, Scoped, BiFunction<String, List<Number>, RuntimeException> {\n+public abstract sealed class AbstractMemorySegmentImpl\n+        implements MemorySegment, SegmentAllocator, Scoped, BiFunction<String, List<Number>, RuntimeException>\n+        permits HeapMemorySegmentImpl, NativeMemorySegmentImpl {\n@@ -73,3 +76,1 @@\n-    static final long NONCE = new Random().nextLong();\n-\n-    static final JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n@@ -148,3 +149,3 @@\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        Utils.checkAllocationSizeAndAlign(bytesSize, bytesAlignment);\n-        return asSlice(0, bytesSize);\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return asSlice(0, byteSize);\n@@ -155,33 +156,2 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n-        final long thisSize = this.byteSize();\n-        final long thatSize = that.byteSize();\n-        final long length = Math.min(thisSize, thatSize);\n-        this.checkAccess(0, length, true);\n-        that.checkAccess(0, length, true);\n-        if (this == other) {\n-            checkValidState();\n-            return -1;\n-        }\n-\n-        long i = 0;\n-        if (length > 7) {\n-            if (get(JAVA_BYTE, 0) != that.get(JAVA_BYTE, 0)) {\n-                return 0;\n-            }\n-            i = vectorizedMismatchLargeForBytes(sessionImpl(), that.sessionImpl(),\n-                    this.unsafeGetBase(), this.unsafeGetOffset(),\n-                    that.unsafeGetBase(), that.unsafeGetOffset(),\n-                    length);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = length - remaining;\n-        }\n-        for (; i < length; i++) {\n-            if (get(JAVA_BYTE, i) != that.get(JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return thisSize != thatSize ? length : -1;\n+        Objects.requireNonNull(other);\n+        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n@@ -193,1 +163,1 @@\n-    private static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n+    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n@@ -222,5 +192,0 @@\n-    @Override\n-    public MemoryAddress address() {\n-        throw new UnsupportedOperationException(\"Cannot obtain address of on-heap segment\");\n-    }\n-\n@@ -282,1 +247,1 @@\n-        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+        throw notAMappedSegment();\n@@ -287,1 +252,1 @@\n-        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+        throw notAMappedSegment();\n@@ -292,1 +257,1 @@\n-        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+        throw notAMappedSegment();\n@@ -297,0 +262,4 @@\n+        throw notAMappedSegment();\n+    }\n+\n+    private static UnsupportedOperationException notAMappedSegment() {\n@@ -406,5 +375,0 @@\n-    protected int id() {\n-        \/\/compute a stable and random id for this memory segment\n-        return Math.abs(Objects.hash(unsafeGetBase(), unsafeGetOffset(), NONCE));\n-    }\n-\n@@ -489,1 +453,1 @@\n-        return \"MemorySegment{ id=0x\" + Long.toHexString(id()) + \" limit: \" + length + \" }\";\n+        return \"MemorySegment{ array: \" + array() + \" address:\" + address() + \" limit: \" + length + \" }\";\n@@ -495,2 +459,0 @@\n-                isNative() == that.isNative() &&\n-                unsafeGetOffset() == that.unsafeGetOffset() &&\n@@ -498,2 +460,1 @@\n-                length == that.length &&\n-                session.equals(that.session);\n+                unsafeGetOffset() == that.unsafeGetOffset();\n@@ -505,1 +466,0 @@\n-                isNative(),\n@@ -507,4 +467,1 @@\n-                unsafeGetBase(),\n-                length,\n-                session\n-        );\n+                unsafeGetBase());\n@@ -515,3 +472,6 @@\n-        long bbAddress = nioAccess.getBufferAddress(bb);\n-        Object base = nioAccess.getBufferBase(bb);\n-        UnmapperProxy unmapper = nioAccess.unmapper(bb);\n+        Object base = NIO_ACCESS.getBufferBase(bb);\n+        if (!bb.isDirect() && base == null) {\n+            throw new IllegalArgumentException(\"The provided heap buffer is not backed by an array.\");\n+        }\n+        long bbAddress = NIO_ACCESS.getBufferAddress(bb);\n+        UnmapperProxy unmapper = NIO_ACCESS.unmapper(bb);\n@@ -523,1 +483,1 @@\n-        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);\n+        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl) NIO_ACCESS.bufferSegment(bb);\n@@ -577,0 +537,148 @@\n+\n+    @ForceInline\n+    public static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+                            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,\n+                            long elementCount) {\n+\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n+        }\n+        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n+        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void copy(MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n+                            Object dstArray, int dstIndex,\n+                            int elementCount) {\n+\n+        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n+        }\n+        int dstBase = (int)baseAndScale;\n+        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        Utils.checkElementAlignment(srcLayout, \"Source layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void copy(Object srcArray, int srcIndex,\n+                            MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset,\n+                            int elementCount) {\n+\n+        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n+        }\n+        int srcBase = (int)baseAndScale;\n+        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        Utils.checkElementAlignment(dstLayout, \"Destination layout alignment greater than its size\");\n+        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n+    }\n+\n+    public static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n+                                MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n+        long srcBytes = srcToOffset - srcFromOffset;\n+        long dstBytes = dstToOffset - dstFromOffset;\n+        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n+        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n+        if (dstImpl == srcImpl) {\n+            srcImpl.checkValidState();\n+            return -1;\n+        }\n+\n+        long bytes = Math.min(srcBytes, dstBytes);\n+        long i = 0;\n+        if (bytes > 7) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n+                return 0;\n+            }\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n+                    bytes);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = bytes - remaining;\n+        }\n+        for (; i < bytes; i++) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n+                return i;\n+            }\n+        }\n+        return srcBytes != dstBytes ? bytes : -1;\n+    }\n+\n+    private static long getBaseAndScale(Class<?> arrayType) {\n+        if (arrayType.equals(byte[].class)) {\n+            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(char[].class)) {\n+            return (long) Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(short[].class)) {\n+            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(int[].class)) {\n+            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(float[].class)) {\n+            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(long[].class)) {\n+            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(double[].class)) {\n+            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n+        } else {\n+            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":178,"deletions":70,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -51,4 +51,4 @@\n-    MemorySegment trySlice(long bytesSize, long bytesAlignment) {\n-        long min = segment.address().toRawLongValue();\n-        long start = Utils.alignUp(min + sp, bytesAlignment) - min;\n-        if (segment.byteSize() - start < bytesSize) {\n+    MemorySegment trySlice(long byteSize, long byteAlignment) {\n+        long min = segment.address();\n+        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+        if (segment.byteSize() - start < byteSize) {\n@@ -57,2 +57,2 @@\n-            MemorySegment slice = segment.asSlice(start, bytesSize);\n-            sp = start + bytesSize;\n+            MemorySegment slice = segment.asSlice(start, byteSize);\n+            sp = start + byteSize;\n@@ -63,2 +63,2 @@\n-    private MemorySegment newSegment(long bytesSize, long bytesAlignment) {\n-        long allocatedSize = Utils.alignUp(bytesSize, bytesAlignment);\n+    private MemorySegment newSegment(long byteSize, long byteAlignment) {\n+        long allocatedSize = Utils.alignUp(byteSize, byteAlignment);\n@@ -69,1 +69,1 @@\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, session);\n+        return session.allocate(byteSize, byteAlignment);\n@@ -73,2 +73,3 @@\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        Utils.checkAllocationSizeAndAlign(bytesSize, bytesAlignment);\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        MemorySessionImpl.toSessionImpl(session).checkValidState();\n@@ -76,1 +77,1 @@\n-        MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+        MemorySegment slice = trySlice(byteSize, byteAlignment);\n@@ -80,1 +81,1 @@\n-            long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n+            long maxPossibleAllocationSize = byteSize + byteAlignment - 1;\n@@ -85,1 +86,1 @@\n-                return newSegment(bytesSize, bytesAlignment);\n+                return newSegment(byteSize, byteAlignment);\n@@ -90,1 +91,1 @@\n-                slice = trySlice(bytesSize, bytesAlignment);\n+                slice = trySlice(byteSize, byteAlignment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,4 +32,4 @@\n-    SysV,\n-    Win64,\n-    LinuxAArch64,\n-    MacOsAArch64;\n+    SYS_V,\n+    WIN_64,\n+    LINUX_AARCH_64,\n+    MAC_OS_AARCH_64;\n@@ -50,1 +50,1 @@\n-                ABI = Win64;\n+                ABI = WIN_64;\n@@ -52,1 +52,1 @@\n-                ABI = SysV;\n+                ABI = SYS_V;\n@@ -56,1 +56,1 @@\n-                ABI = MacOsAArch64;\n+                ABI = MAC_OS_AARCH_64;\n@@ -59,1 +59,1 @@\n-                ABI = LinuxAArch64;\n+                ABI = LINUX_AARCH_64;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -84,1 +84,3 @@\n-        if (state == 0 || state - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n+        int asyncCount = (int)ASYNC_RELEASE_COUNT.getVolatile(this);\n+        if ((state == 0 && asyncCount == 0)\n+                || ((state - asyncCount) == 0)) {\n@@ -87,1 +89,1 @@\n-            throw alreadyAcquired(state);\n+            throw alreadyAcquired(state - asyncCount);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * @implSpec This class and its subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public final class FunctionDescriptorImpl implements FunctionDescriptor {\n+\n+    private final MemoryLayout resLayout; \/\/ Nullable\n+    private final List<MemoryLayout> argLayouts;\n+\n+    private FunctionDescriptorImpl(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n+        this.resLayout = resLayout;\n+        this.argLayouts = List.copyOf(argLayouts);\n+    }\n+\n+    \/**\n+     * {@return the return layout (if any) associated with this function descriptor}\n+     *\/\n+    public final Optional<MemoryLayout> returnLayout() {\n+        return Optional.ofNullable(resLayout);\n+    }\n+\n+    \/**\n+     * {@return the argument layouts associated with this function descriptor (as an immutable list)}.\n+     *\/\n+    public final List<MemoryLayout> argumentLayouts() {\n+        return argLayouts;\n+    }\n+\n+    \/**\n+     * Returns a function descriptor with the given argument layouts appended to the argument layout array\n+     * of this function descriptor.\n+     *\n+     * @param addedLayouts the argument layouts to append.\n+     * @return the new function descriptor.\n+     *\/\n+    public final FunctionDescriptorImpl appendArgumentLayouts(MemoryLayout... addedLayouts) {\n+        return insertArgumentLayouts(argLayouts.size(), addedLayouts);\n+    }\n+\n+    \/**\n+     * Returns a function descriptor with the given argument layouts inserted at the given index, into the argument\n+     * layout array of this function descriptor.\n+     *\n+     * @param index        the index at which to insert the arguments\n+     * @param addedLayouts the argument layouts to insert at given index.\n+     * @return the new function descriptor.\n+     * @throws IllegalArgumentException if {@code index < 0 || index > argumentLayouts().size()}.\n+     *\/\n+    public FunctionDescriptorImpl insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n+        if (index < 0 || index > argLayouts.size())\n+            throw new IllegalArgumentException(\"Index out of bounds: \" + index);\n+        List<MemoryLayout> added = List.of(addedLayouts); \/\/ null check on array and its elements\n+        List<MemoryLayout> newLayouts = new ArrayList<>(argLayouts.size() + addedLayouts.length);\n+        newLayouts.addAll(argLayouts.subList(0, index));\n+        newLayouts.addAll(added);\n+        newLayouts.addAll(argLayouts.subList(index, argLayouts.size()));\n+        return new FunctionDescriptorImpl(resLayout, newLayouts);\n+    }\n+\n+    \/**\n+     * Returns a function descriptor with the given memory layout as the new return layout.\n+     *\n+     * @param newReturn the new return layout.\n+     * @return the new function descriptor.\n+     *\/\n+    public FunctionDescriptorImpl changeReturnLayout(MemoryLayout newReturn) {\n+        requireNonNull(newReturn);\n+        return new FunctionDescriptorImpl(newReturn, argLayouts);\n+    }\n+\n+    \/**\n+     * Returns a function descriptor with the return layout dropped. This is useful to model functions\n+     * which return no values.\n+     *\n+     * @return the new function descriptor.\n+     *\/\n+    public FunctionDescriptorImpl dropReturnLayout() {\n+        return new FunctionDescriptorImpl(null, argLayouts);\n+    }\n+\n+    private static Class<?> carrierTypeFor(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n+        } else if (layout instanceof GroupLayout) {\n+            return MemorySegment.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        }\n+    }\n+\n+    @Override\n+    public MethodType toMethodType() {\n+        Class<?> returnValue = resLayout != null ? carrierTypeFor(resLayout) : void.class;\n+        Class<?>[] argCarriers = new Class<?>[argLayouts.size()];\n+        for (int i = 0; i < argCarriers.length; i++) {\n+            argCarriers[i] = carrierTypeFor(argLayouts.get(i));\n+        }\n+        return MethodType.methodType(returnValue, argCarriers);\n+    }\n+\n+    \/**\n+     * {@return the string representation of this function descriptor}\n+     *\/\n+    @Override\n+    public final String toString() {\n+        return String.format(\"(%s)%s\",\n+                argLayouts.stream().map(Object::toString)\n+                        .collect(Collectors.joining()),\n+                returnLayout()\n+                        .map(Object::toString)\n+                        .orElse(\"v\"));\n+    }\n+\n+    \/**\n+     * Compares the specified object with this function descriptor for equality. Returns {@code true} if and only if the specified\n+     * object is also a function descriptor, and all the following conditions are met:\n+     * <ul>\n+     *     <li>the two function descriptors have equals return layouts (see {@link MemoryLayout#equals(Object)}), or both have no return layout;<\/li>\n+     *     <li>the two function descriptors have argument layouts that are pair-wise {@linkplain MemoryLayout#equals(Object) equal}; and<\/li>\n+     * <\/ul>\n+     *\n+     * @param other the object to be compared for equality with this function descriptor.\n+     * @return {@code true} if the specified object is equal to this function descriptor.\n+     *\/\n+    @Override\n+    public final boolean equals(Object other) {\n+        return other instanceof FunctionDescriptorImpl f &&\n+                Objects.equals(resLayout, f.resLayout) &&\n+                Objects.equals(argLayouts, f.argLayouts);\n+    }\n+\n+    \/**\n+     * {@return the hash code value for this function descriptor}\n+     *\/\n+    @Override\n+    public final int hashCode() {\n+        return Objects.hash(argLayouts, resLayout);\n+    }\n+\n+    public static FunctionDescriptor of(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n+        return new FunctionDescriptorImpl(resLayout, argLayouts);\n+    }\n+\n+    public static FunctionDescriptor ofVoid(List<MemoryLayout> argLayouts) {\n+        return new FunctionDescriptorImpl(null, argLayouts);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/FunctionDescriptorImpl.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.Optional;\n+\n@@ -47,1 +49,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, int, MemorySession)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, MemorySession)}.\n@@ -49,1 +51,1 @@\n-public abstract class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n+public abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n@@ -62,0 +64,5 @@\n+    @Override\n+    public Optional<Object> array() {\n+        return Optional.of(base);\n+    }\n+\n@@ -64,1 +71,1 @@\n-        super(length, readOnly, MemorySessionImpl.GLOBAL);\n+        super(length, readOnly, MemorySession.global());\n@@ -88,1 +95,1 @@\n-    public static class OfByte extends HeapMemorySegmentImpl {\n+    public static final class OfByte extends HeapMemorySegmentImpl {\n@@ -114,0 +121,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        }\n@@ -116,1 +128,1 @@\n-    public static class OfChar extends HeapMemorySegmentImpl {\n+    public static final class OfChar extends HeapMemorySegmentImpl {\n@@ -142,0 +154,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+        }\n@@ -144,1 +161,1 @@\n-    public static class OfShort extends HeapMemorySegmentImpl {\n+    public static final class OfShort extends HeapMemorySegmentImpl {\n@@ -170,0 +187,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+        }\n@@ -172,1 +194,1 @@\n-    public static class OfInt extends HeapMemorySegmentImpl {\n+    public static final class OfInt extends HeapMemorySegmentImpl {\n@@ -198,0 +220,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_INT_BASE_OFFSET;\n+        }\n@@ -200,1 +227,1 @@\n-    public static class OfLong extends HeapMemorySegmentImpl {\n+    public static final class OfLong extends HeapMemorySegmentImpl {\n@@ -226,0 +253,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_LONG_BASE_OFFSET;\n+        }\n@@ -228,1 +260,1 @@\n-    public static class OfFloat extends HeapMemorySegmentImpl {\n+    public static final class OfFloat extends HeapMemorySegmentImpl {\n@@ -254,0 +286,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+        }\n@@ -256,1 +293,1 @@\n-    public static class OfDouble extends HeapMemorySegmentImpl {\n+    public static final class OfDouble extends HeapMemorySegmentImpl {\n@@ -282,0 +319,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":52,"deletions":10,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.StructLayout;\n@@ -53,0 +54,3 @@\n+    private static final long[] EMPTY_STRIDES = new long[0];\n+    private static final long[] EMPTY_BOUNDS = new long[0];\n+\n@@ -126,1 +130,1 @@\n-            } else if (g.isStruct()) {\n+            } else if (g instanceof StructLayout) {\n@@ -183,1 +187,1 @@\n-            Utils.bitsToBytesOrThrow(offset, Utils.bitsToBytesThrowOffset);\n+            Utils.bitsToBytesOrThrow(offset, Utils.BITS_TO_BYTES_THROW_OFFSET);\n@@ -187,1 +191,1 @@\n-        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_bitsToBytesOrThrowForOffset); \/\/ byte offset\n+        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET); \/\/ byte offset\n@@ -260,3 +264,0 @@\n-    private static final long[] EMPTY_STRIDES = new long[0];\n-    private static final long[] EMPTY_BOUNDS = new long[0];\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n+public sealed class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n@@ -44,1 +44,1 @@\n-    static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -53,1 +53,1 @@\n-        return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null,\n+        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null,\n@@ -96,1 +96,1 @@\n-    public static class EmptyMappedMemorySegmentImpl extends MappedMemorySegmentImpl {\n+    public static final class EmptyMappedMemorySegmentImpl extends MappedMemorySegmentImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,389 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.ValueLayout;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * This class provides an immutable implementation for the {@code MemoryAddress} interface. This class contains information\n- * about the segment this address is associated with, as well as an offset into such segment.\n- *\/\n-public final class MemoryAddressImpl implements MemoryAddress, Scoped {\n-\n-    private final long offset;\n-\n-    public MemoryAddressImpl(long offset) {\n-        this.offset = offset;\n-    }\n-\n-    \/\/ MemoryAddress methods\n-\n-    @Override\n-    public MemoryAddress addOffset(long offset) {\n-        return new MemoryAddressImpl(this.offset + offset);\n-    }\n-\n-    @Override\n-    public long toRawLongValue() {\n-        return offset;\n-    }\n-\n-    @Override\n-    public final MemoryAddress address() {\n-        return this;\n-    }\n-\n-    \/\/ Object methods\n-\n-    @Override\n-    public int hashCode() {\n-        return (int) toRawLongValue();\n-    }\n-\n-    @Override\n-    public boolean equals(Object that) {\n-        return (that instanceof MemoryAddressImpl addressImpl &&\n-            offset == addressImpl.offset);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"MemoryAddress{ offset=0x\" + Long.toHexString(offset) + \" }\";\n-    }\n-\n-    public static MemorySegment ofLongUnchecked(long value) {\n-        return ofLongUnchecked(value, Long.MAX_VALUE);\n-    }\n-\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize, MemorySession session) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, session);\n-    }\n-\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, MemorySessionImpl.GLOBAL);\n-    }\n-\n-    @Override\n-    public MemorySessionImpl session() {\n-        return MemorySessionImpl.GLOBAL;\n-    }\n-\n-    @Override\n-    @CallerSensitive\n-    @ForceInline\n-    public String getUtf8String(long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getUtf8String\");\n-        SharedUtils.checkAddress(this);\n-        return NativeMemorySegmentImpl.EVERYTHING.getUtf8String(toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @CallerSensitive\n-    @ForceInline\n-    public void setUtf8String(long offset, String str) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setUtf8String\");\n-        SharedUtils.checkAddress(this);\n-        NativeMemorySegmentImpl.EVERYTHING.setUtf8String(toRawLongValue() + offset, str);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public byte get(ValueLayout.OfByte layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfByte layout, long offset, byte value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public boolean get(ValueLayout.OfBoolean layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public char get(ValueLayout.OfChar layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfChar layout, long offset, char value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public short get(ValueLayout.OfShort layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfShort layout, long offset, short value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public int get(ValueLayout.OfInt layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfInt layout, long offset, int value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public float get(ValueLayout.OfFloat layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfFloat layout, long offset, float value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public long get(ValueLayout.OfLong layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfLong layout, long offset, long value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public double get(ValueLayout.OfDouble layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfDouble layout, long offset, double value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value.address());\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public char getAtIndex(ValueLayout.OfChar layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public short getAtIndex(ValueLayout.OfShort layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public int getAtIndex(ValueLayout.OfInt layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public float getAtIndex(ValueLayout.OfFloat layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public long getAtIndex(ValueLayout.OfLong layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public double getAtIndex(ValueLayout.OfDouble layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value.address());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":0,"deletions":389,"binary":false,"changes":389,"status":"deleted"},{"patch":"@@ -55,5 +55,3 @@\n-public abstract non-sealed class MemorySessionImpl implements MemorySession, SegmentAllocator {\n-    final ResourceList resourceList;\n-    final Cleaner.Cleanable cleanable;\n-    final Thread owner;\n-\n+public abstract sealed class MemorySessionImpl\n+        implements MemorySession, SegmentAllocator\n+        permits ConfinedSession, MemorySessionImpl.GlobalSessionImpl, SharedSession {\n@@ -64,2 +62,0 @@\n-    int state = OPEN;\n-\n@@ -67,0 +63,11 @@\n+    static final int MAX_FORKS = Integer.MAX_VALUE;\n+\n+    public static final MemorySessionImpl GLOBAL = new GlobalSessionImpl(null);\n+\n+    static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n+    static final ScopedMemoryAccess.ScopedAccessError WRONG_THREAD = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::wrongThread);\n+\n+    final ResourceList resourceList;\n+    final Cleaner.Cleanable cleanable;\n+    final Thread owner;\n+    int state = OPEN;\n@@ -76,2 +83,0 @@\n-    static final int MAX_FORKS = Integer.MAX_VALUE;\n-\n@@ -134,2 +139,3 @@\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, this);\n@@ -259,1 +265,1 @@\n-    static class GlobalSessionImpl extends MemorySessionImpl {\n+    static final class GlobalSessionImpl extends MemorySessionImpl {\n@@ -296,2 +302,0 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSessionImpl(null);\n-\n@@ -310,1 +314,1 @@\n-    static class ImplicitSession extends SharedSession {\n+    static final class ImplicitSession extends SharedSession {\n@@ -344,1 +348,1 @@\n-    public final static class NonCloseableView implements MemorySession {\n+    public static final class NonCloseableView implements MemorySession {\n@@ -467,3 +471,0 @@\n-    static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n-\n-    static final ScopedMemoryAccess.ScopedAccessError WRONG_THREAD = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::wrongThread);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemorySegment;\n@@ -32,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -33,0 +32,2 @@\n+import java.util.Optional;\n+\n@@ -42,1 +43,1 @@\n-public class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl {\n+public sealed class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl permits MappedMemorySegmentImpl {\n@@ -44,13 +45,1 @@\n-    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, false, MemorySessionImpl.GLOBAL) {\n-        @Override\n-        void checkBounds(long offset, long length) {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n-            throw new IllegalStateException();\n-        }\n-    };\n-\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -61,2 +50,1 @@\n-\n-    private static final boolean skipZeroMemory = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.skipZeroMemory\");\n+    private static final boolean SKIP_ZERO_MEMORY = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.skipZeroMemory\");\n@@ -72,1 +60,0 @@\n-    @ForceInline\n@@ -74,3 +61,7 @@\n-    public MemoryAddress address() {\n-        checkValidState();\n-        return MemoryAddress.ofLong(unsafeGetOffset());\n+    public long address() {\n+        return min;\n+    }\n+\n+    @Override\n+    public Optional<Object> array() {\n+        return Optional.empty();\n@@ -79,0 +70,1 @@\n+    @ForceInline\n@@ -86,1 +78,1 @@\n-        return nioAccess.newDirectByteBuffer(min, (int) this.length, null,\n+        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null,\n@@ -112,1 +104,1 @@\n-    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes, MemorySession session) {\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySession session) {\n@@ -116,1 +108,1 @@\n-            alignmentBytes = Math.max(alignmentBytes, nioAccess.pageSize());\n+            byteAlignment = Math.max(byteAlignment, NIO_ACCESS.pageSize());\n@@ -118,3 +110,3 @@\n-        long alignedSize = Math.max(1L, alignmentBytes > MAX_MALLOC_ALIGN ?\n-                bytesSize + (alignmentBytes - 1) :\n-                bytesSize);\n+        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n+                byteSize + (byteAlignment - 1) :\n+                byteSize);\n@@ -122,1 +114,1 @@\n-        nioAccess.reserveMemory(alignedSize, bytesSize);\n+        NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n@@ -124,3 +116,3 @@\n-        long buf = unsafe.allocateMemory(alignedSize);\n-        if (!skipZeroMemory) {\n-            unsafe.setMemory(buf, alignedSize, (byte)0);\n+        long buf = UNSAFE.allocateMemory(alignedSize);\n+        if (!SKIP_ZERO_MEMORY) {\n+            UNSAFE.setMemory(buf, alignedSize, (byte)0);\n@@ -128,1 +120,1 @@\n-        long alignedBuf = Utils.alignUp(buf, alignmentBytes);\n+        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n@@ -134,2 +126,2 @@\n-                unsafe.freeMemory(buf);\n-                nioAccess.unreserveMemory(alignedSize, bytesSize);\n+                UNSAFE.freeMemory(buf);\n+                NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n@@ -138,1 +130,1 @@\n-        if (alignedSize != bytesSize) {\n+        if (alignedSize != byteSize) {\n@@ -140,1 +132,1 @@\n-            segment = segment.asSlice(delta, bytesSize);\n+            segment = segment.asSlice(delta, byteSize);\n@@ -145,4 +137,13 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, MemorySession session) {\n-        MemorySessionImpl.toSessionImpl(session).checkValidState();\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, false, session);\n-        return segment;\n+    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n+    \/\/ associated with MemorySegment::ofAddress.\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySession session) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        sessionImpl.checkValidState();\n+        return new NativeMemorySegmentImpl(min, byteSize, false, session);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySession.global());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":42,"deletions":41,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -31,1 +30,5 @@\n-public class PlatformLayouts {\n+public final class PlatformLayouts {\n+\n+    private PlatformLayouts() {\n+        \/\/just the one\n+    }\n@@ -84,1 +87,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n@@ -143,1 +146,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n@@ -203,1 +206,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-class SharedSession extends MemorySessionImpl {\n+sealed class SharedSession extends MemorySessionImpl permits MemorySessionImpl.ImplicitSession {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -44,1 +43,1 @@\n-public class SystemLookup implements SymbolLookup {\n+public final class SystemLookup implements SymbolLookup {\n@@ -48,1 +47,1 @@\n-    static final SystemLookup INSTANCE = new SystemLookup();\n+    private static final SystemLookup INSTANCE = new SystemLookup();\n@@ -51,1 +50,1 @@\n-    private static final SymbolLookup fallbackLookup = name -> Optional.empty();\n+    private static final SymbolLookup FALLBACK_LOOKUP = name -> Optional.empty();\n@@ -57,1 +56,1 @@\n-    private static final SymbolLookup syslookup = makeSystemLookup();\n+    private static final SymbolLookup SYSTEM_LOOKUP = makeSystemLookup();\n@@ -59,1 +58,1 @@\n-    private static final SymbolLookup makeSystemLookup() {\n+    private static SymbolLookup makeSystemLookup() {\n@@ -62,2 +61,2 @@\n-                case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n-                case Win64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n+                case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+                case WIN_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n@@ -69,1 +68,1 @@\n-            return fallbackLookup;\n+            return FALLBACK_LOOKUP;\n@@ -89,1 +88,1 @@\n-            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n+            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.find(\"funcs\").orElseThrow().address(),\n@@ -93,1 +92,1 @@\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()), 0L, MemorySession.global()));\n+                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, MemorySession.global()));\n@@ -96,1 +95,1 @@\n-            lookup = name -> finalLookup.lookup(name).or(() -> fallbackLookup.apply(name));\n+            lookup = name -> finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n@@ -110,1 +109,1 @@\n-                        Optional.of(MemorySegment.ofAddress(MemoryAddress.ofLong(addr), 0, MemorySession.global()));\n+                        Optional.of(MemorySegment.ofAddress(addr, 0, MemorySession.global()));\n@@ -123,2 +122,2 @@\n-            case SysV, LinuxAArch64, MacOsAArch64 -> \"lib\";\n-            case Win64 -> \"bin\";\n+            case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64 -> \"lib\";\n+            case WIN_64 -> \"bin\";\n@@ -136,2 +135,2 @@\n-    public Optional<MemorySegment> lookup(String name) {\n-        return syslookup.lookup(name);\n+    public Optional<MemorySegment> find(String name) {\n+        return SYSTEM_LOOKUP.find(name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -52,2 +51,3 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n-    public static final MethodHandle MH_bitsToBytesOrThrowForOffset;\n+    private static final MethodHandle LONG_TO_ADDRESS_SAFE;\n+    private static final MethodHandle LONG_TO_ADDRESS_UNSAFE;\n+    public static final MethodHandle MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET;\n@@ -55,2 +55,2 @@\n-    public static final Supplier<RuntimeException> bitsToBytesThrowOffset\n-        = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n+    public static final Supplier<RuntimeException> BITS_TO_BYTES_THROW_OFFSET\n+            = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n@@ -65,1 +65,1 @@\n-            ADDRESS_TO_LONG = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+            ADDRESS_TO_LONG = lookup.findVirtual(MemorySegment.class, \"address\",\n@@ -67,7 +67,9 @@\n-            LONG_TO_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n-                    MethodType.methodType(MemoryAddress.class, long.class));\n-            MH_bitsToBytesOrThrowForOffset = MethodHandles.insertArguments(\n-                lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n-                    MethodType.methodType(long.class, long.class, Supplier.class)),\n-                1,\n-                bitsToBytesThrowOffset);\n+            LONG_TO_ADDRESS_SAFE = lookup.findStatic(Utils.class, \"longToAddressSafe\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n+            LONG_TO_ADDRESS_UNSAFE = lookup.findStatic(Utils.class, \"longToAddressUnsafe\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n+            MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET = MethodHandles.insertArguments(\n+                    lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n+                            MethodType.methodType(long.class, long.class, Supplier.class)),\n+                    1,\n+                    BITS_TO_BYTES_THROW_OFFSET);\n@@ -83,5 +85,0 @@\n-    public static MemoryAddress alignUp(MemoryAddress ma, long alignment) {\n-        long offset = ma.toRawLongValue();\n-        return ma.addOffset(alignUp(offset, alignment) - offset);\n-    }\n-\n@@ -89,1 +86,1 @@\n-        long offset = ms.address().toRawLongValue();\n+        long offset = ms.address();\n@@ -111,1 +108,1 @@\n-        if (layout.carrier() == MemoryAddress.class) {\n+        if (layout.carrier() == MemorySegment.class) {\n@@ -126,1 +123,1 @@\n-        } else if (layout.carrier() == MemoryAddress.class) {\n+        } else if (layout instanceof ValueLayout.OfAddress addressLayout) {\n@@ -128,2 +125,3 @@\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n-                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n+                    MethodHandles.explicitCastArguments(addressLayout.isUnbounded() ?\n+                            LONG_TO_ADDRESS_UNSAFE : LONG_TO_ADDRESS_SAFE, MethodType.methodType(MemorySegment.class, baseCarrier)));\n@@ -134,1 +132,1 @@\n-    private static boolean byteToBoolean(byte b) {\n+    public static boolean byteToBoolean(byte b) {\n@@ -142,0 +140,10 @@\n+    @ForceInline\n+    private static MemorySegment longToAddressSafe(long addr) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, 0);\n+    }\n+\n+    @ForceInline\n+    private static MemorySegment longToAddressUnsafe(long addr) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, Long.MAX_VALUE);\n+    }\n+\n@@ -166,1 +174,9 @@\n-    public static void checkAllocationSizeAndAlign(long bytesSize, long alignmentBytes) {\n+    public static long pointeeSize(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout.OfAddress addressLayout) {\n+            return addressLayout.isUnbounded() ? Long.MAX_VALUE : 0L;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static void checkAllocationSizeAndAlign(long byteSize, long byteAlignment) {\n@@ -168,2 +184,2 @@\n-        if (bytesSize < 0) {\n-            throw new IllegalArgumentException(\"Invalid allocation size : \" + bytesSize);\n+        if (byteSize < 0) {\n+            throw new IllegalArgumentException(\"Invalid allocation size : \" + byteSize);\n@@ -173,3 +189,3 @@\n-        if (alignmentBytes <= 0 ||\n-                ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {\n-            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + alignmentBytes);\n+        if (byteAlignment <= 0 ||\n+                ((byteAlignment & (byteAlignment - 1)) != 0L)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + byteAlignment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":46,"deletions":30,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.layout.AbstractLayout;\n@@ -33,0 +34,3 @@\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySession;\n@@ -36,1 +40,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SequenceLayout;\n@@ -44,1 +48,2 @@\n-    private final SoftReferenceCache<FunctionDescriptor, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();\n+    private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {}\n+    private final SoftReferenceCache<LinkRequest, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();\n@@ -47,1 +52,1 @@\n-    public MethodHandle downcallHandle(FunctionDescriptor function) {\n+    public MethodHandle downcallHandle(FunctionDescriptor function, Option... options) {\n@@ -49,0 +54,3 @@\n+        Objects.requireNonNull(options);\n+        checkHasNaturalAlignment(function);\n+        LinkerOptions optionSet = LinkerOptions.of(options);\n@@ -50,4 +58,5 @@\n-        return DOWNCALL_CACHE.get(function, fd -> {\n-            MethodType type = SharedUtils.inferMethodType(fd, false);\n-            MethodHandle handle = arrangeDowncall(type, fd);\n-            handle = SharedUtils.maybeInsertAllocator(handle);\n+        return DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n+            FunctionDescriptor fd = linkRequest.descriptor();\n+            MethodType type = fd.toMethodType();\n+            MethodHandle handle = arrangeDowncall(type, fd, linkRequest.options());\n+            handle = SharedUtils.maybeInsertAllocator(fd, handle);\n@@ -57,1 +66,1 @@\n-    protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function);\n+    protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options);\n@@ -64,0 +73,1 @@\n+        checkHasNaturalAlignment(function);\n@@ -66,1 +76,1 @@\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n+        MethodType type = function.toMethodType();\n@@ -80,0 +90,25 @@\n+\n+    \/\/ Current limitation of the implementation:\n+    \/\/ We don't support packed structs on some platforms,\n+    \/\/ so reject them here explicitly\n+    private static void checkHasNaturalAlignment(FunctionDescriptor descriptor) {\n+        descriptor.returnLayout().ifPresent(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+        descriptor.argumentLayouts().forEach(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+    }\n+\n+    private static void checkHasNaturalAlignmentRecursive(MemoryLayout layout) {\n+        checkHasNaturalAlignment(layout);\n+        if (layout instanceof GroupLayout gl) {\n+            for (MemoryLayout member : gl.memberLayouts()) {\n+                checkHasNaturalAlignmentRecursive(member);\n+            }\n+        } else if (layout instanceof SequenceLayout sl) {\n+            checkHasNaturalAlignmentRecursive(sl.elementLayout());\n+        }\n+    }\n+\n+    private static void checkHasNaturalAlignment(MemoryLayout layout) {\n+        if (!((AbstractLayout<?>) layout).hasNaturalAlignment()) {\n+            throw new IllegalArgumentException(\"Layout bit alignment must be natural alignment: \" + layout);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+\n@@ -33,3 +33,0 @@\n-import java.lang.foreign.ValueLayout;\n-import jdk.internal.foreign.MemoryAddressImpl;\n-\n@@ -42,6 +39,0 @@\n-import java.util.Objects;\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-\n-import static java.lang.invoke.MethodType.methodType;\n@@ -202,1 +193,1 @@\n-public abstract class Binding {\n+public interface Binding {\n@@ -207,1 +198,1 @@\n-     * the allocation operation, or {@link ToSegment} bindings, by providing the {@link MemorySession} that\n+     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link MemorySession} that\n@@ -210,1 +201,1 @@\n-    public static class Context implements AutoCloseable {\n+    class Context implements AutoCloseable {\n@@ -296,8 +287,2 @@\n-        TO_SEGMENT,\n-        DUP\n-    }\n-\n-    private final Tag tag;\n-\n-    private Binding(Tag tag) {\n-        this.tag = tag;\n+        DUP,\n+        CAST\n@@ -306,3 +291,1 @@\n-    public Tag tag() {\n-        return tag;\n-    }\n+    Tag tag();\n@@ -310,1 +293,1 @@\n-    public abstract void verify(Deque<Class<?>> stack);\n+    void verify(Deque<Class<?>> stack);\n@@ -312,2 +295,2 @@\n-    public abstract void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                                   BindingInterpreter.LoadFunc loadFunc, Context context);\n+    void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                   BindingInterpreter.LoadFunc loadFunc, Context context);\n@@ -325,1 +308,1 @@\n-    public static VMStore vmStore(VMStorage storage, Class<?> type) {\n+    static VMStore vmStore(VMStorage storage, Class<?> type) {\n@@ -330,1 +313,1 @@\n-    public static VMLoad vmLoad(VMStorage storage, Class<?> type) {\n+    static VMLoad vmLoad(VMStorage storage, Class<?> type) {\n@@ -335,1 +318,1 @@\n-    public static BufferStore bufferStore(long offset, Class<?> type) {\n+    static BufferStore bufferStore(long offset, Class<?> type) {\n@@ -341,1 +324,1 @@\n-    public static BufferLoad bufferLoad(long offset, Class<?> type) {\n+    static BufferLoad bufferLoad(long offset, Class<?> type) {\n@@ -347,1 +330,1 @@\n-    public static Copy copy(MemoryLayout layout) {\n+    static Copy copy(MemoryLayout layout) {\n@@ -351,1 +334,1 @@\n-    public static Allocate allocate(MemoryLayout layout) {\n+    static Allocate allocate(MemoryLayout layout) {\n@@ -355,6 +338,2 @@\n-    public static BoxAddress boxAddress() {\n-        return BoxAddress.INSTANCE;\n-    }\n-\n-    public static UnboxAddress unboxAddress() {\n-        return UnboxAddress.INSTANCE.get(MemoryAddress.class);\n+    static BoxAddress boxAddressRaw(long size) {\n+        return new BoxAddress(size, false);\n@@ -363,2 +342,2 @@\n-    public static UnboxAddress unboxAddress(Class<?> carrier) {\n-        return UnboxAddress.INSTANCE.get(carrier);\n+    static BoxAddress boxAddress(MemoryLayout layout) {\n+        return new BoxAddress(layout.byteSize(), true);\n@@ -367,2 +346,2 @@\n-    public static ToSegment toSegment(MemoryLayout layout) {\n-        return new ToSegment(layout.byteSize());\n+    static BoxAddress boxAddress(long byteSize) {\n+        return new BoxAddress(byteSize, true);\n@@ -371,2 +350,2 @@\n-    public static ToSegment toSegment(long byteSize) {\n-        return new ToSegment(byteSize);\n+    static UnboxAddress unboxAddress() {\n+        return UnboxAddress.INSTANCE;\n@@ -375,1 +354,1 @@\n-    public static Dup dup() {\n+    static Dup dup() {\n@@ -379,3 +358,2 @@\n-\n-    public static Binding.Builder builder() {\n-        return new Binding.Builder();\n+    static Binding cast(Class<?> fromType, Class<?> toType) {\n+        return new Cast(fromType, toType);\n@@ -384,7 +362,0 @@\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        Binding binding = (Binding) o;\n-        return tag == binding.tag;\n-    }\n@@ -392,3 +363,2 @@\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(tag);\n+    static Binding.Builder builder() {\n+        return new Binding.Builder();\n@@ -400,1 +370,1 @@\n-    public static class Builder {\n+    class Builder {\n@@ -403,0 +373,4 @@\n+        private static boolean isSubIntType(Class<?> type) {\n+            return type == boolean.class || type == byte.class || type == short.class || type == char.class;\n+        }\n+\n@@ -404,0 +378,4 @@\n+            if (isSubIntType(type)) {\n+                bindings.add(Binding.cast(type, int.class));\n+                type = int.class;\n+            }\n@@ -409,1 +387,8 @@\n-            bindings.add(Binding.vmLoad(storage, type));\n+            Class<?> loadType = type;\n+            if (isSubIntType(type)) {\n+                loadType = int.class;\n+            }\n+            bindings.add(Binding.vmLoad(storage, loadType));\n+            if (isSubIntType(type)) {\n+                bindings.add(Binding.cast(int.class, type));\n+            }\n@@ -433,2 +418,2 @@\n-        public Binding.Builder boxAddress() {\n-            bindings.add(Binding.boxAddress());\n+        public Binding.Builder boxAddressRaw(long size) {\n+            bindings.add(Binding.boxAddressRaw(size));\n@@ -438,7 +423,2 @@\n-        public Binding.Builder unboxAddress() {\n-            bindings.add(Binding.unboxAddress());\n-            return this;\n-        }\n-\n-        public Binding.Builder unboxAddress(Class<?> carrier) {\n-            bindings.add(Binding.unboxAddress(carrier));\n+        public Binding.Builder boxAddress(MemoryLayout layout) {\n+            bindings.add(Binding.boxAddress(layout));\n@@ -448,2 +428,2 @@\n-        public Binding.Builder toSegment(MemoryLayout layout) {\n-            bindings.add(Binding.toSegment(layout));\n+        public Binding.Builder unboxAddress() {\n+            bindings.add(Binding.unboxAddress());\n@@ -459,1 +439,1 @@\n-            return new ArrayList<>(bindings);\n+            return List.copyOf(bindings);\n@@ -463,32 +443,3 @@\n-    abstract static class Move extends Binding {\n-        private final VMStorage storage;\n-        private final Class<?> type;\n-\n-        private Move(Tag tag, VMStorage storage, Class<?> type) {\n-            super(tag);\n-            this.storage = storage;\n-            this.type = type;\n-        }\n-\n-        public VMStorage storage() {\n-            return storage;\n-        }\n-\n-        public Class<?> type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            if (!super.equals(o)) return false;\n-            Move move = (Move) o;\n-            return Objects.equals(storage, move.storage) &&\n-                    Objects.equals(type, move.type);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), storage, type);\n-        }\n+    interface Move extends Binding {\n+        VMStorage storage();\n+        Class<?> type();\n@@ -502,3 +453,4 @@\n-    public static class VMStore extends Move {\n-        private VMStore(VMStorage storage, Class<?> type) {\n-            super(Tag.VM_STORE, storage, type);\n+    record VMStore(VMStorage storage, Class<?> type) implements Move {\n+        @Override\n+        public Tag tag() {\n+            return Tag.VM_STORE;\n@@ -519,8 +471,0 @@\n-\n-        @Override\n-        public String toString() {\n-            return \"VMStore{\" +\n-                    \"storage=\" + storage() +\n-                    \", type=\" + type() +\n-                    '}';\n-        }\n@@ -534,3 +478,4 @@\n-    public static class VMLoad extends Move {\n-        private VMLoad(VMStorage storage, Class<?> type) {\n-            super(Tag.VM_LOAD, storage, type);\n+    record VMLoad(VMStorage storage, Class<?> type) implements Move {\n+        @Override\n+        public Tag tag() {\n+            return Tag.VM_LOAD;\n@@ -549,8 +494,0 @@\n-\n-        @Override\n-        public String toString() {\n-            return \"VMLoad{\" +\n-                    \"storage=\" + storage() +\n-                    \", type=\" + type() +\n-                    '}';\n-        }\n@@ -559,40 +496,3 @@\n-    private abstract static class Dereference extends Binding {\n-        private final long offset;\n-        private final Class<?> type;\n-\n-        private Dereference(Tag tag, long offset, Class<?> type) {\n-            super(tag);\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        public long offset() {\n-            return offset;\n-        }\n-\n-        public Class<?> type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            if (!super.equals(o)) return false;\n-            Dereference that = (Dereference) o;\n-            return offset == that.offset &&\n-                    Objects.equals(type, that.type);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), offset, type);\n-        }\n-\n-        public VarHandle varHandle() {\n-            \/\/ alignment is set to 1 byte here to avoid exceptions for cases where we do super word\n-            \/\/ copies of e.g. 2 int fields of a struct as a single long, while the struct is only\n-            \/\/ 4-byte-aligned (since it only contains ints)\n-            ValueLayout layout = MemoryLayout.valueLayout(type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n-            return MethodHandles.insertCoordinates(MethodHandles.memorySegmentViewVarHandle(layout), 1, offset);\n-        }\n+    interface Dereference extends Binding {\n+        long offset();\n+        Class<?> type();\n@@ -607,3 +507,4 @@\n-    public static class BufferStore extends Dereference {\n-        private BufferStore(long offset, Class<?> type) {\n-            super(Tag.BUFFER_STORE, offset, type);\n+    record BufferStore(long offset, Class<?> type) implements Dereference {\n+        @Override\n+        public Tag tag() {\n+            return Tag.BUFFER_STORE;\n@@ -628,8 +529,0 @@\n-\n-        @Override\n-        public String toString() {\n-            return \"BufferStore{\" +\n-                    \"offset=\" + offset() +\n-                    \", type=\" + type() +\n-                    '}';\n-        }\n@@ -644,3 +537,4 @@\n-    public static class BufferLoad extends Dereference {\n-        private BufferLoad(long offset, Class<?> type) {\n-            super(Tag.BUFFER_LOAD, offset, type);\n+    record BufferLoad(long offset, Class<?> type) implements Dereference {\n+        @Override\n+        public Tag tag() {\n+            return Tag.BUFFER_LOAD;\n@@ -664,8 +558,0 @@\n-\n-        @Override\n-        public String toString() {\n-            return \"BufferLoad{\" +\n-                    \"offset=\" + offset() +\n-                    \", type=\" + type() +\n-                    '}';\n-        }\n@@ -680,10 +566,1 @@\n-    public static class Copy extends Binding {\n-        private final long size;\n-        private final long alignment;\n-\n-        private Copy(long size, long alignment) {\n-            super(Tag.COPY_BUFFER);\n-            this.size = size;\n-            this.alignment = alignment;\n-        }\n-\n+    record Copy(long size, long alignment) implements Binding {\n@@ -695,8 +572,0 @@\n-        public long size() {\n-            return size;\n-        }\n-\n-        public long alignment() {\n-            return alignment;\n-        }\n-\n@@ -704,6 +573,2 @@\n-        public String toString() {\n-            return \"Copy{\" +\n-                    \"tag=\" + tag() +\n-                    \", size=\" + size +\n-                    \", alignment=\" + alignment +\n-                    '}';\n+        public Tag tag() {\n+            return Tag.COPY_BUFFER;\n@@ -726,15 +591,0 @@\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            if (!super.equals(o)) return false;\n-            Copy copy = (Copy) o;\n-            return size == copy.size &&\n-                    alignment == copy.alignment;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), size, alignment);\n-        }\n@@ -747,10 +597,1 @@\n-    public static class Allocate extends Binding {\n-        private final long size;\n-        private final long alignment;\n-\n-        private Allocate(long size, long alignment) {\n-            super(Tag.ALLOC_BUFFER);\n-            this.size = size;\n-            this.alignment = alignment;\n-        }\n-\n+    record Allocate(long size, long alignment) implements Binding {\n@@ -761,8 +602,0 @@\n-        public long size() {\n-            return size;\n-        }\n-\n-        public long alignment() {\n-            return alignment;\n-        }\n-\n@@ -770,6 +603,2 @@\n-        public String toString() {\n-            return \"AllocateBuffer{\" +\n-                    \"tag=\" + tag() +\n-                    \"size=\" + size +\n-                    \", alignment=\" + alignment +\n-                    '}';\n+        public Tag tag() {\n+            return Tag.ALLOC_BUFFER;\n@@ -788,15 +617,0 @@\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            if (!super.equals(o)) return false;\n-            Allocate allocate = (Allocate) o;\n-            return size == allocate.size &&\n-                    alignment == allocate.alignment;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), size, alignment);\n-        }\n@@ -808,1 +622,1 @@\n-     *     and pushes that onto the operand stack.\n+     * with the given size, and pushes that onto the operand stack\n@@ -810,1 +624,2 @@\n-    public static class UnboxAddress extends Binding {\n+    record UnboxAddress() implements Binding {\n+        static final UnboxAddress INSTANCE = new UnboxAddress();\n@@ -812,18 +627,3 @@\n-        static final ClassValue<UnboxAddress> INSTANCE = new ClassValue<>() {\n-            @Override\n-            protected UnboxAddress computeValue(Class<?> type) {\n-                return new UnboxAddress(type);\n-            }\n-        };\n-\n-        final Class<?> carrier;\n-        final MethodHandle toAddress;\n-\n-        private UnboxAddress(Class<?> carrier) {\n-            super(Tag.UNBOX_ADDRESS);\n-            this.carrier = carrier;\n-            try {\n-                this.toAddress = MethodHandles.lookup().findVirtual(carrier, \"address\", MethodType.methodType(MemoryAddress.class));\n-            } catch (Throwable ex) {\n-                throw new IllegalArgumentException(ex);\n-            }\n+        @Override\n+        public Tag tag() {\n+            return Tag.UNBOX_ADDRESS;\n@@ -835,1 +635,1 @@\n-            SharedUtils.checkType(actualType, carrier);\n+            SharedUtils.checkType(actualType, MemorySegment.class);\n@@ -842,6 +642,1 @@\n-            stack.push(((Addressable)stack.pop()).address().toRawLongValue());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"UnboxAddress{}\";\n+            stack.push(((MemorySegment)stack.pop()).address());\n@@ -853,2 +648,2 @@\n-     * Pops a 'long' from the operand stack, converts it to a 'MemoryAddress',\n-     *     and pushes that onto the operand stack.\n+     * Pops a 'long' from the operand stack, converts it to a 'MemorySegment', with the given size and memory session\n+     * (either the context session, or the global session), and pushes that onto the operand stack.\n@@ -856,4 +651,5 @@\n-    public static class BoxAddress extends Binding {\n-        private static final BoxAddress INSTANCE = new BoxAddress();\n-        private BoxAddress() {\n-            super(Tag.BOX_ADDRESS);\n+    record BoxAddress(long size, boolean needsSession) implements Binding {\n+\n+        @Override\n+        public Tag tag() {\n+            return Tag.BOX_ADDRESS;\n@@ -866,1 +662,1 @@\n-            stack.push(MemoryAddress.class);\n+            stack.push(MemorySegment.class);\n@@ -872,6 +668,3 @@\n-            stack.push(MemoryAddress.ofLong((long) stack.pop()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"BoxAddress{}\";\n+            MemorySession session = needsSession ?\n+                    context.session() : MemorySession.global();\n+            stack.push(NativeMemorySegmentImpl.makeNativeSegmentUnchecked((long) stack.pop(), size, session));\n@@ -882,3 +675,3 @@\n-     * TO_SEGMENT([size])\n-     *   Pops a MemoryAddress from the operand stack, and converts it to a MemorySegment\n-     *   with the given size, and pushes that onto the operand stack\n+     * DUP()\n+     *   Duplicates the value on the top of the operand stack (without popping it!),\n+     *   and pushes the duplicate onto the operand stack\n@@ -886,8 +679,2 @@\n-    public static class ToSegment extends Binding {\n-        private final long size;\n-        \/\/ FIXME alignment?\n-\n-        public ToSegment(long size) {\n-            super(Tag.TO_SEGMENT);\n-            this.size = size;\n-        }\n+    record Dup() implements Binding {\n+        static final Dup INSTANCE = new Dup();\n@@ -895,6 +682,3 @@\n-        public long size() {\n-            return size;\n-        }\n-\n-        private static MemorySegment toSegment(MemoryAddress operand, long size, Context context) {\n-            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size, context.session);\n+        @Override\n+        public Tag tag() {\n+            return Tag.DUP;\n@@ -905,3 +689,1 @@\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemoryAddress.class);\n-            stack.push(MemorySegment.class);\n+            stack.push(stack.peekLast());\n@@ -913,24 +695,1 @@\n-            MemoryAddress operand = (MemoryAddress) stack.pop();\n-            MemorySegment segment = toSegment(operand, size, context);\n-            stack.push(segment);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"ToSegemnt{\" +\n-                    \"size=\" + size +\n-                    '}';\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            if (!super.equals(o)) return false;\n-            ToSegment toSegemnt = (ToSegment) o;\n-            return size == toSegemnt.size;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), size);\n+            stack.push(stack.peekLast());\n@@ -941,3 +700,4 @@\n-     * DUP()\n-     *   Duplicates the value on the top of the operand stack (without popping it!),\n-     *   and pushes the duplicate onto the operand stack\n+     * CAST([fromType], [toType])\n+     *   Pop a [fromType] from the stack, convert it to [toType], and push the resulting\n+     *   value onto the stack.\n+     *\n@@ -945,4 +705,5 @@\n-    public static class Dup extends Binding {\n-        private static final Dup INSTANCE = new Dup();\n-        private Dup() {\n-            super(Tag.DUP);\n+    record Cast(Class<?> fromType, Class<?> toType) implements Binding {\n+\n+        @Override\n+        public Tag tag() {\n+            return Tag.CAST;\n@@ -953,1 +714,3 @@\n-            stack.push(stack.peekLast());\n+            Class<?> actualType = stack.pop();\n+            SharedUtils.checkType(actualType, fromType);\n+            stack.push(toType);\n@@ -959,12 +722,9 @@\n-            stack.push(stack.peekLast());\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            return o != null && getClass() == o.getClass();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Dup{}\";\n+            Object arg = stack.pop();\n+            MethodHandle converter = MethodHandles.explicitCastArguments(MethodHandles.identity(toType),\n+                    MethodType.methodType(toType, fromType));\n+            try {\n+                Object result = converter.invoke(arg);\n+                stack.push(result);\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":132,"deletions":372,"binary":false,"changes":504,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -29,0 +28,1 @@\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -46,1 +47,0 @@\n-import java.lang.foreign.Addressable;\n@@ -48,1 +48,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n@@ -63,1 +63,0 @@\n-import java.util.function.BiPredicate;\n@@ -65,1 +64,0 @@\n-import static java.lang.foreign.ValueLayout.*;\n@@ -90,1 +88,1 @@\n-    private static final String ADDRESS_DESC = methodType(MemoryAddress.class).descriptorString();\n+    private static final String UNBOX_SEGMENT_DESC = methodType(long.class, MemorySegment.class).descriptorString();\n@@ -92,2 +90,1 @@\n-    private static final String TO_RAW_LONG_VALUE_DESC = methodType(long.class).descriptorString();\n-    private static final String OF_LONG_DESC = methodType(MemoryAddress.class, long.class).descriptorString();\n+    private static final String OF_LONG_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n@@ -134,1 +131,1 @@\n-    private int CONTEXT_IDX = -1;\n+    private int contextIdx = -1;\n@@ -251,6 +248,2 @@\n-        return popType(expected, ASSERT_EQUALS);\n-    }\n-\n-    private Class<?> popType(Class<?> expected, BiPredicate<Class<?>, Class<?>> typePredicate) {\n-        Class<?> found;\n-        if (!typePredicate.test(expected, found = typeStack.pop())) {\n+        Class<?> found = typeStack.pop();\n+        if (!expected.equals(found)) {\n@@ -264,3 +257,0 @@\n-    private static final BiPredicate<Class<?>, Class<?>> ASSERT_EQUALS = Class::equals;\n-    private static final BiPredicate<Class<?>, Class<?>> ASSERT_ASSIGNABLE = Class::isAssignableFrom;\n-\n@@ -291,1 +281,1 @@\n-                if (shouldAcquire(callerMethodType.parameterType(i))) {\n+                if (shouldAcquire(i)) {\n@@ -311,2 +301,2 @@\n-        CONTEXT_IDX = newLocal(Object.class);\n-        emitStore(Object.class, CONTEXT_IDX);\n+        contextIdx = newLocal(Object.class);\n+        emitStore(Object.class, contextIdx);\n@@ -446,1 +436,4 @@\n-        return callingSequence.argumentBindings().anyMatch(Binding.ToSegment.class::isInstance);\n+        return callingSequence.argumentBindings()\n+                .filter(Binding.BoxAddress.class::isInstance)\n+                .map(Binding.BoxAddress.class::cast)\n+                .anyMatch(Binding.BoxAddress::needsSession);\n@@ -449,2 +442,14 @@\n-    private static boolean shouldAcquire(Class<?> type) {\n-        return type == Addressable.class;\n+    private boolean shouldAcquire(int paramIndex) {\n+        if (!callingSequence.forDowncall() || \/\/ we only acquire in downcalls\n+                paramIndex == 0) { \/\/ the first parameter in a downcall is SegmentAllocator\n+            return false;\n+        }\n+\n+        \/\/ if call needs return buffer, the descriptor has an extra leading layout\n+        int offset = callingSequence.needsReturnBuffer() ? 0 : 1;\n+        MemoryLayout paramLayout =  callingSequence.functionDesc()\n+                                              .argumentLayouts()\n+                                              .get(paramIndex - offset);\n+\n+        \/\/ is this an address layout?\n+        return paramLayout instanceof ValueLayout.OfAddress;\n@@ -469,1 +474,1 @@\n-                case BOX_ADDRESS -> emitBoxAddress();\n+                case BOX_ADDRESS -> emitBoxAddress((Binding.BoxAddress) binding);\n@@ -471,1 +476,0 @@\n-                case TO_SEGMENT -> emitToSegment((Binding.ToSegment) binding);\n@@ -473,0 +477,1 @@\n+                case CAST -> emitCast((Binding.Cast) binding);\n@@ -486,1 +491,1 @@\n-        if (shouldAcquire(highLevelType)) {\n+        if (shouldAcquire(paramIndex)) {\n@@ -513,1 +518,1 @@\n-        emitStore(Object.class, nextScopeLocal); \/\/ store off one to release later\n+        \/\/ call acquire first here. So that if it fails, we don't call release\n@@ -515,0 +520,1 @@\n+        emitStore(Object.class, nextScopeLocal); \/\/ store off one to release later\n@@ -556,2 +562,2 @@\n-        assert CONTEXT_IDX != -1;\n-        emitLoad(Object.class, CONTEXT_IDX);\n+        assert contextIdx != -1;\n+        emitLoad(Object.class, contextIdx);\n@@ -562,2 +568,2 @@\n-        assert CONTEXT_IDX != -1;\n-        emitLoad(Object.class, CONTEXT_IDX);\n+        assert contextIdx != -1;\n+        emitLoad(Object.class, contextIdx);\n@@ -568,2 +574,2 @@\n-        assert CONTEXT_IDX != -1;\n-        emitLoad(Object.class, CONTEXT_IDX);\n+        assert contextIdx != -1;\n+        emitLoad(Object.class, contextIdx);\n@@ -573,17 +579,1 @@\n-    private void emitToSegment(Binding.ToSegment binding) {\n-        long size = binding.size();\n-        popType(MemoryAddress.class);\n-\n-        emitToRawLongValue();\n-        emitConst(size);\n-        emitLoadInternalSession();\n-        emitInvokeStatic(MemoryAddressImpl.class, \"ofLongUnchecked\", OF_LONG_UNCHECKED_DESC);\n-\n-        pushType(MemorySegment.class);\n-    }\n-\n-    private void emitToRawLongValue() {\n-        emitInvokeInterface(MemoryAddress.class, \"toRawLongValue\", TO_RAW_LONG_VALUE_DESC);\n-    }\n-\n-    private void emitBoxAddress() {\n+    private void emitBoxAddress(Binding.BoxAddress boxAddress) {\n@@ -591,2 +581,8 @@\n-        emitInvokeStatic(MemoryAddress.class, \"ofLong\", OF_LONG_DESC);\n-        pushType(MemoryAddress.class);\n+        emitConst(boxAddress.size());\n+        if (needsSession()) {\n+            emitLoadInternalSession();\n+            emitInvokeStatic(NativeMemorySegmentImpl.class, \"makeNativeSegmentUnchecked\", OF_LONG_UNCHECKED_DESC);\n+        } else {\n+            emitInvokeStatic(NativeMemorySegmentImpl.class, \"makeNativeSegmentUnchecked\", OF_LONG_DESC);\n+        }\n+        pushType(MemorySegment.class);\n@@ -622,1 +618,0 @@\n-\n@@ -673,0 +668,1 @@\n+\n@@ -679,0 +675,40 @@\n+    private void emitCast(Binding.Cast cast) {\n+        Class<?> fromType = cast.fromType();\n+        Class<?> toType = cast.toType();\n+\n+        if (fromType == int.class) {\n+            popType(int.class);\n+\n+            if (toType == boolean.class) {\n+                \/\/ implement least significant byte non-zero test\n+\n+                \/\/ select first byte\n+                emitConst(0xFF);\n+                mv.visitInsn(IAND);\n+\n+                \/\/ convert to boolean\n+                emitInvokeStatic(Utils.class, \"byteToBoolean\", \"(B)Z\");\n+            } else if (toType == byte.class) {\n+                mv.visitInsn(I2B);\n+            } else if (toType == short.class) {\n+                mv.visitInsn(I2S);\n+            } else {\n+                assert toType == char.class;\n+                mv.visitInsn(I2C);\n+            }\n+\n+            pushType(toType);\n+        } else {\n+            popType(fromType);\n+\n+            assert fromType == boolean.class\n+                    || fromType == byte.class\n+                    || fromType == short.class\n+                    || fromType == char.class;\n+            \/\/ no-op in bytecode\n+\n+            assert toType == int.class;\n+            pushType(int.class);\n+        }\n+    }\n+\n@@ -680,3 +716,2 @@\n-        popType(Addressable.class, ASSERT_ASSIGNABLE);\n-        emitInvokeInterface(Addressable.class, \"address\", ADDRESS_DESC);\n-        emitToRawLongValue();\n+        popType(MemorySegment.class);\n+        emitInvokeStatic(SharedUtils.class, \"unboxSegment\", UNBOX_SEGMENT_DESC);\n@@ -733,1 +768,1 @@\n-        emitGetStatic(BindingSpecializer.Runtime.class, valueLayoutConstantName, valueLayoutType.descriptorString());\n+        emitGetStatic(ValueLayout.class, valueLayoutConstantName, valueLayoutType.descriptorString());\n@@ -739,1 +774,1 @@\n-            return \"JAVA_BOOLEAN_UNALIGNED\";\n+            return \"JAVA_BOOLEAN\";\n@@ -741,1 +776,1 @@\n-            return \"JAVA_BYTE_UNALIGNED\";\n+            return \"JAVA_BYTE\";\n@@ -754,1 +789,1 @@\n-        } else if (type == MemoryAddress.class) {\n+        } else if (type == MemorySegment.class) {\n@@ -778,1 +813,1 @@\n-        } else if (type == MemoryAddress.class) {\n+        } else if (type == MemorySegment.class) {\n@@ -923,14 +958,0 @@\n-    \/\/ constants that are accessed from the generated bytecode\n-    \/\/ see emitLoadLayoutConstant\n-    static class Runtime {\n-        \/\/ unaligned constants\n-        static final ValueLayout.OfBoolean JAVA_BOOLEAN_UNALIGNED = JAVA_BOOLEAN;\n-        static final ValueLayout.OfByte JAVA_BYTE_UNALIGNED = JAVA_BYTE;\n-        static final ValueLayout.OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n-        static final ValueLayout.OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n-        static final ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-        static final ValueLayout.OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n-        static final ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-        static final ValueLayout.OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n-        static final ValueLayout.OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":97,"deletions":76,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.Addressable;\n@@ -99,2 +98,2 @@\n-            addArgumentBinding(0, Addressable.class, ValueLayout.ADDRESS, List.of(\n-                Binding.unboxAddress(Addressable.class),\n+            addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                Binding.unboxAddress(),\n@@ -104,1 +103,1 @@\n-                    Binding.unboxAddress(MemorySegment.class),\n+                    Binding.unboxAddress(),\n@@ -114,2 +113,1 @@\n-                        Binding.boxAddress(),\n-                        Binding.toSegment(returnBufferSize)));\n+                        Binding.boxAddress(returnBufferSize)));\n@@ -198,2 +196,2 @@\n-        \/\/TO_SEGMENT,\n-        DUP\n+        DUP,\n+        CAST\n@@ -226,2 +224,2 @@\n-        TO_SEGMENT,\n-        DUP\n+        DUP,\n+        CAST\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.Addressable;\n@@ -63,1 +62,1 @@\n-                    methodType(void.class, Addressable.class));\n+                    methodType(void.class, MemorySegment.class));\n@@ -113,1 +112,1 @@\n-        assert handle.type().parameterType(1) == Addressable.class;\n+        assert handle.type().parameterType(1) == MemorySegment.class;\n@@ -172,3 +171,1 @@\n-                        (storage, type, value) -> {\n-                            leafArgs[invData.argIndexMap.get(storage)] = value;\n-                        }, unboxContext);\n+                        (storage, type, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxContext);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.foreign.Linker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class LinkerOptions {\n+\n+    private static final LinkerOptions EMPTY = LinkerOptions.of();\n+    private final Map<Class<?>, Linker.Option> optionsMap;\n+\n+    private LinkerOptions(Map<Class<?>, Linker.Option> optionsMap) {\n+        this.optionsMap = optionsMap;\n+    }\n+\n+    public static LinkerOptions of(Linker.Option... options) {\n+        Map<Class<?>, Linker.Option> optionMap = new HashMap<>();\n+\n+        for (Linker.Option option : options) {\n+            if (optionMap.containsKey(option.getClass())) {\n+                throw new IllegalArgumentException(\"Duplicate option: \" + option);\n+            }\n+            optionMap.put(option.getClass(), option);\n+        }\n+\n+        return new LinkerOptions(optionMap);\n+    }\n+\n+    public static LinkerOptions empty() {\n+        return EMPTY;\n+    }\n+\n+    private <T extends Linker.Option> T getOption(Class<T> type) {\n+        return type.cast(optionsMap.get(type));\n+    }\n+\n+    public boolean isVarargsIndex(int argIndex) {\n+        FirstVariadicArg fva = getOption(FirstVariadicArg.class);\n+        return fva != null && argIndex >= fva.index();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof LinkerOptions that\n+                && Objects.equals(optionsMap, that.optionsMap);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(optionsMap);\n+    }\n+\n+    public record FirstVariadicArg(int index) implements Linker.Option { }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -31,3 +31,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.Scoped;\n@@ -38,0 +35,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -39,1 +37,0 @@\n-import java.lang.foreign.Addressable;\n@@ -43,1 +40,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -47,0 +43,1 @@\n+import java.lang.foreign.PaddingLayout;\n@@ -69,1 +66,4 @@\n-public class SharedUtils {\n+public final class SharedUtils {\n+\n+    private SharedUtils() {\n+    }\n@@ -75,1 +75,0 @@\n-    private static final MethodHandle MH_BASEADDRESS;\n@@ -77,1 +76,1 @@\n-    private static final MethodHandle MH_REACHBILITY_FENCE;\n+    private static final MethodHandle MH_REACHABILITY_FENCE;\n@@ -84,2 +83,0 @@\n-            MH_BASEADDRESS = lookup.findVirtual(MemorySegment.class, \"address\",\n-                    methodType(MemoryAddress.class));\n@@ -87,2 +84,2 @@\n-                    methodType(MemoryAddress.class, MemoryAddress.class, MemorySegment.class));\n-            MH_REACHBILITY_FENCE = lookup.findStatic(Reference.class, \"reachabilityFence\",\n+                    methodType(MemorySegment.class, MemorySegment.class, MemorySegment.class));\n+            MH_REACHABILITY_FENCE = lookup.findStatic(Reference.class, \"reachabilityFence\",\n@@ -100,8 +97,0 @@\n-    \/**\n-     * Align the specified type from a given address\n-     * @return The address the data should be at based on alignment requirement\n-     *\/\n-    public static long align(MemoryLayout t, boolean isVar, long addr) {\n-        return alignUp(addr, alignment(t, isVar));\n-    }\n-\n@@ -113,43 +102,1 @@\n-     * The alignment requirement for a given type\n-     * @param isVar indicate if the type is a standalone variable. This change how\n-     * array is aligned. for example.\n-     *\/\n-    public static long alignment(MemoryLayout t, boolean isVar) {\n-        if (t instanceof ValueLayout) {\n-            return alignmentOfScalar((ValueLayout) t);\n-        } else if (t instanceof SequenceLayout) {\n-            \/\/ when array is used alone\n-            return alignmentOfArray((SequenceLayout) t, isVar);\n-        } else if (t instanceof GroupLayout) {\n-            return alignmentOfContainer((GroupLayout) t);\n-        } else if (t.isPadding()) {\n-            return 1;\n-        } else {\n-            throw new IllegalArgumentException(\"Invalid type: \" + t);\n-        }\n-    }\n-\n-    private static long alignmentOfScalar(ValueLayout st) {\n-        return st.byteSize();\n-    }\n-\n-    private static long alignmentOfArray(SequenceLayout ar, boolean isVar) {\n-        if (ar.elementCount() == 0) {\n-            \/\/ VLA or incomplete\n-            return 16;\n-        } else if ((ar.byteSize()) >= 16 && isVar) {\n-            return 16;\n-        } else {\n-            \/\/ align as element type\n-            MemoryLayout elementType = ar.elementLayout();\n-            return alignment(elementType, false);\n-        }\n-    }\n-\n-    private static long alignmentOfContainer(GroupLayout ct) {\n-        \/\/ Most strict member\n-        return ct.memberLayouts().stream().mapToLong(t -> alignment(t, false)).max().orElse(1);\n-    }\n-\n-    \/**\n-     * Takes a MethodHandle that takes an input buffer as a first argument (a MemoryAddress), and returns nothing,\n+     * Takes a MethodHandle that takes an input buffer as a first argument (a MemorySegment), and returns nothing,\n@@ -169,2 +116,2 @@\n-        if (handle.type().parameterType(2) != MemoryAddress.class)\n-            throw new IllegalArgumentException(\"MemoryAddress expected as third param: \" + handle.type());\n+        if (handle.type().parameterType(2) != MemorySegment.class)\n+            throw new IllegalArgumentException(\"MemorySegment expected as third param: \" + handle.type());\n@@ -175,6 +122,5 @@\n-        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, Addressable, SegmentAllocator, MemoryAddress, ...) MemorySegment\n-        handle = collectArguments(handle, 3, MH_BASEADDRESS); \/\/ (MemorySegment, Addressable, SegmentAllocator, MemorySegment, ...) MemorySegment\n-        handle = mergeArguments(handle, 0, 3);  \/\/ (MemorySegment, Addressable, SegmentAllocator, ...) MemorySegment\n-        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 1, cDesc.returnLayout().get())); \/\/ (SegmentAllocator, Addressable, SegmentAllocator, ...) MemoryAddress\n-        handle = mergeArguments(handle, 0, 2);  \/\/ (SegmentAllocator, Addressable, ...) MemoryAddress\n-        handle = swapArguments(handle, 0, 1); \/\/ (Addressable, SegmentAllocator, ...) MemoryAddress\n+        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, MemorySegment, SegmentAllocator, MemorySegment, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 3);  \/\/ (MemorySegment, MemorySegment, SegmentAllocator, ...) MemorySegment\n+        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 1, cDesc.returnLayout().get())); \/\/ (SegmentAllocator, MemorySegment, SegmentAllocator, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 2);  \/\/ (SegmentAllocator, MemorySegment, ...) MemorySegment\n+        handle = swapArguments(handle, 0, 1); \/\/ (MemorySegment, SegmentAllocator, ...) MemorySegment\n@@ -186,1 +132,1 @@\n-     * (a MemoryAddress), and upon invocation, copies the contents of the returned MemorySegment into the input buffer\n+     * (a MemorySegment), and upon invocation, copies the contents of the returned MemorySegment into the input buffer\n@@ -196,1 +142,1 @@\n-        target = collectArguments(MH_BUFFER_COPY, 1, target); \/\/ (MemoryAddress, ...) MemoryAddress\n+        target = collectArguments(MH_BUFFER_COPY, 1, target); \/\/ (MemorySegment, ...) MemorySegment\n@@ -203,1 +149,1 @@\n-            target = target.asType(target.type().changeReturnType(Addressable.class));\n+            target = target.asType(target.type().changeReturnType(MemorySegment.class));\n@@ -209,3 +155,2 @@\n-    private static MemoryAddress bufferCopy(MemoryAddress dest, MemorySegment buffer) {\n-        MemoryAddressImpl.ofLongUnchecked(dest.toRawLongValue(), buffer.byteSize()).copyFrom(buffer);\n-        return dest;\n+    private static MemorySegment bufferCopy(MemorySegment dest, MemorySegment buffer) {\n+        return dest.copyFrom(buffer);\n@@ -238,4 +183,4 @@\n-            case Win64 -> Windowsx64Linker.getInstance();\n-            case SysV -> SysVx64Linker.getInstance();\n-            case LinuxAArch64 -> LinuxAArch64Linker.getInstance();\n-            case MacOsAArch64 -> MacOsAArch64Linker.getInstance();\n+            case WIN_64 -> Windowsx64Linker.getInstance();\n+            case SYS_V -> SysVx64Linker.getInstance();\n+            case LINUX_AARCH_64 -> LinuxAArch64Linker.getInstance();\n+            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.getInstance();\n@@ -308,1 +253,1 @@\n-        return MH_REACHBILITY_FENCE.asType(MethodType.methodType(void.class, type));\n+        return MH_REACHABILITY_FENCE.asType(MethodType.methodType(void.class, type));\n@@ -318,0 +263,7 @@\n+    static long unboxSegment(MemorySegment segment) {\n+        if (!segment.isNative()) {\n+            throw new IllegalArgumentException(\"Heap segment not allowed: \" + segment);\n+        }\n+        return segment.address();\n+    }\n+\n@@ -325,2 +277,2 @@\n-    public static MethodHandle maybeInsertAllocator(MethodHandle handle) {\n-        if (!handle.type().returnType().equals(MemorySegment.class)) {\n+    public static MethodHandle maybeInsertAllocator(FunctionDescriptor descriptor, MethodHandle handle) {\n+        if (descriptor.returnLayout().isEmpty() || !(descriptor.returnLayout().get() instanceof GroupLayout)) {\n@@ -333,9 +285,2 @@\n-    public static void checkSymbol(Addressable symbol) {\n-        checkAddressable(symbol, \"Symbol is NULL\");\n-    }\n-\n-    public static void checkAddress(MemoryAddress address) {\n-        checkAddressable(address, \"Address is NULL\");\n-    }\n-\n-    private static void checkAddressable(Addressable symbol, String msg) {\n+    @ForceInline\n+    public static void checkSymbol(MemorySegment symbol) {\n@@ -343,1 +288,1 @@\n-        if (symbol.address().toRawLongValue() == 0)\n+        if (symbol.equals(MemorySegment.NULL))\n@@ -349,4 +294,4 @@\n-            case Win64 -> Windowsx64Linker.newVaList(actions, session);\n-            case SysV -> SysVx64Linker.newVaList(actions, session);\n-            case LinuxAArch64 -> LinuxAArch64Linker.newVaList(actions, session);\n-            case MacOsAArch64 -> MacOsAArch64Linker.newVaList(actions, session);\n+            case WIN_64 -> Windowsx64Linker.newVaList(actions, session);\n+            case SYS_V -> SysVx64Linker.newVaList(actions, session);\n+            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaList(actions, session);\n+            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaList(actions, session);\n@@ -356,1 +301,1 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n@@ -358,4 +303,4 @@\n-            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma, session);\n-            case SysV -> SysVx64Linker.newVaListOfAddress(ma, session);\n-            case LinuxAArch64 -> LinuxAArch64Linker.newVaListOfAddress(ma, session);\n-            case MacOsAArch64 -> MacOsAArch64Linker.newVaListOfAddress(ma, session);\n+            case WIN_64 -> Windowsx64Linker.newVaListOfAddress(address, session);\n+            case SYS_V -> SysVx64Linker.newVaListOfAddress(address, session);\n+            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaListOfAddress(address, session);\n+            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaListOfAddress(address, session);\n@@ -367,4 +312,4 @@\n-            case Win64 -> Windowsx64Linker.emptyVaList();\n-            case SysV -> SysVx64Linker.emptyVaList();\n-            case LinuxAArch64 -> LinuxAArch64Linker.emptyVaList();\n-            case MacOsAArch64 -> MacOsAArch64Linker.emptyVaList();\n+            case WIN_64 -> Windowsx64Linker.emptyVaList();\n+            case SYS_V -> SysVx64Linker.emptyVaList();\n+            case LINUX_AARCH_64 -> LinuxAArch64Linker.emptyVaList();\n+            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.emptyVaList();\n@@ -381,5 +326,0 @@\n-    public static boolean isVarargsIndex(FunctionDescriptor descriptor, int argIndex) {\n-        int firstPos = descriptor.firstVariadicArgumentIndex();\n-        return firstPos != -1 && argIndex >= firstPos;\n-    }\n-\n@@ -390,1 +330,1 @@\n-    public static class SimpleVaArg {\n+    public static final class SimpleVaArg {\n@@ -404,1 +344,1 @@\n-    public static non-sealed class EmptyVaList implements VaList, Scoped {\n+    public static final class EmptyVaList implements VaList {\n@@ -406,1 +346,1 @@\n-        private final MemoryAddress address;\n+        private final MemorySegment address;\n@@ -408,1 +348,1 @@\n-        public EmptyVaList(MemoryAddress address) {\n+        public EmptyVaList(MemorySegment address) {\n@@ -432,1 +372,1 @@\n-        public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n+        public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n@@ -446,5 +386,0 @@\n-        @Override\n-        public MemorySession session() {\n-            return MemorySessionImpl.GLOBAL;\n-        }\n-\n@@ -457,1 +392,1 @@\n-        public MemoryAddress address() {\n+        public MemorySegment segment() {\n@@ -529,28 +464,0 @@\n-\n-    \/\/ unaligned constants\n-    public final static ValueLayout.OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n-    public final static ValueLayout.OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n-    public final static ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-    public final static ValueLayout.OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n-    public final static ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-    public final static ValueLayout.OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n-\n-    public static MethodType inferMethodType(FunctionDescriptor descriptor, boolean upcall) {\n-        MethodType type = MethodType.methodType(descriptor.returnLayout().isPresent() ?\n-                carrierFor(descriptor.returnLayout().get(), upcall) : void.class);\n-        for (MemoryLayout argLayout : descriptor.argumentLayouts()) {\n-            type = type.appendParameterTypes(carrierFor(argLayout, !upcall));\n-        }\n-        return type;\n-    }\n-\n-    static Class<?> carrierFor(MemoryLayout layout, boolean forArg) {\n-        if (layout instanceof ValueLayout valueLayout) {\n-            return (forArg && valueLayout.carrier().equals(MemoryAddress.class)) ?\n-                    Addressable.class : valueLayout.carrier();\n-        } else if (layout instanceof GroupLayout) {\n-            return MemorySegment.class;\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":58,"deletions":151,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    private class Node {\n+    private final class Node {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SoftReferenceCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-    private static record CallRegs(VMStorage[] argRegs, VMStorage[] retRegs) {}\n+    private record CallRegs(VMStorage[] argRegs, VMStorage[] retRegs) {}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -33,1 +32,4 @@\n-public class UpcallStubs {\n+public final class UpcallStubs {\n+\n+    private UpcallStubs() {\n+    }\n@@ -58,1 +60,1 @@\n-        return MemorySegment.ofAddress(MemoryAddress.ofLong(entry), 0, session);\n+        return MemorySegment.ofAddress(entry, 0, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -38,0 +37,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -95,9 +95,2 @@\n-    \/\/ record\n-    public static class Bindings {\n-        public final CallingSequence callingSequence;\n-        public final boolean isInMemoryReturn;\n-\n-        Bindings(CallingSequence callingSequence, boolean isInMemoryReturn) {\n-            this.callingSequence = callingSequence;\n-            this.isInMemoryReturn = isInMemoryReturn;\n-        }\n+    public record Bindings(CallingSequence callingSequence,\n+                           boolean isInMemoryReturn) {\n@@ -125,0 +118,4 @@\n+        return getBindings(mt, cDesc, forUpcall, LinkerOptions.empty());\n+    }\n+\n+    public Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, LinkerOptions options) {\n@@ -132,1 +129,1 @@\n-            csb.addArgumentBindings(MemoryAddress.class, AArch64.C_POINTER,\n+            csb.addArgumentBindings(MemorySegment.class, AArch64.C_POINTER,\n@@ -143,1 +140,1 @@\n-            if (varArgsOnStack() && SharedUtils.isVarargsIndex(cDesc, i)) {\n+            if (varArgsOnStack() && options.isVarargsIndex(i)) {\n@@ -152,2 +149,2 @@\n-    public MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n+    public MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, false, options);\n@@ -217,1 +214,1 @@\n-            return stackAlloc(layout.byteSize(), SharedUtils.alignment(layout, true));\n+            return stackAlloc(layout.byteSize(), layout.byteAlignment());\n@@ -356,1 +353,1 @@\n-                            .unboxAddress(MemorySegment.class);\n+                            .unboxAddress();\n@@ -387,1 +384,1 @@\n-                    bindings.unboxAddress(carrier);\n+                    bindings.unboxAddress();\n@@ -421,1 +418,1 @@\n-                .boxAddress()\n+                .boxAddressRaw(Long.MAX_VALUE)\n@@ -430,1 +427,1 @@\n-                case STRUCT_REGISTER: {\n+                case STRUCT_REGISTER -> {\n@@ -434,1 +431,1 @@\n-                        StorageClasses.INTEGER, layout);\n+                            StorageClasses.INTEGER, layout);\n@@ -451,1 +448,0 @@\n-                    break;\n@@ -453,1 +449,1 @@\n-                case STRUCT_REFERENCE: {\n+                case STRUCT_REFERENCE -> {\n@@ -456,1 +452,1 @@\n-                        StorageClasses.INTEGER, AArch64.C_POINTER);\n+                            StorageClasses.INTEGER, AArch64.C_POINTER);\n@@ -458,3 +454,1 @@\n-                            .boxAddress()\n-                            .toSegment(layout);\n-                    break;\n+                            .boxAddress(layout);\n@@ -462,1 +456,1 @@\n-                case STRUCT_HFA: {\n+                case STRUCT_HFA -> {\n@@ -465,1 +459,1 @@\n-                    GroupLayout group = (GroupLayout)layout;\n+                    GroupLayout group = (GroupLayout) layout;\n@@ -467,1 +461,1 @@\n-                        StorageClasses.VECTOR, group.memberLayouts().size());\n+                            StorageClasses.VECTOR, group.memberLayouts().size());\n@@ -483,1 +477,0 @@\n-                    break;\n@@ -485,1 +478,1 @@\n-                case POINTER: {\n+                case POINTER -> {\n@@ -487,1 +480,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                            storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n@@ -489,2 +482,1 @@\n-                            .boxAddress();\n-                    break;\n+                            .boxAddressRaw(Utils.pointeeSize(layout));\n@@ -492,1 +484,1 @@\n-                case INTEGER: {\n+                case INTEGER -> {\n@@ -494,1 +486,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                            storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n@@ -496,1 +488,0 @@\n-                    break;\n@@ -498,1 +489,1 @@\n-                case FLOAT: {\n+                case FLOAT -> {\n@@ -500,1 +491,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                            storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n@@ -502,1 +493,0 @@\n-                    break;\n@@ -504,2 +494,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":31,"deletions":42,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -31,1 +30,1 @@\n-import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.MemorySegment;\n@@ -51,1 +50,1 @@\n-        } else if (carrier == MemoryAddress.class) {\n+        } else if (carrier == MemorySegment.class) {\n@@ -63,1 +62,1 @@\n-        if (!(type instanceof GroupLayout))\n+        if (!(type instanceof GroupLayout groupLayout))\n@@ -66,2 +65,0 @@\n-        GroupLayout groupLayout = (GroupLayout)type;\n-\n@@ -110,2 +107,0 @@\n-        } else if (type instanceof SequenceLayout) {\n-            return TypeClass.INTEGER;\n@@ -113,1 +108,1 @@\n-            throw new IllegalArgumentException(\"Unhandled type \" + type);\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -31,0 +32,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -32,1 +34,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -34,1 +35,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -45,1 +45,0 @@\n-    private static LinuxAArch64Linker instance;\n@@ -48,2 +47,2 @@\n-        if (instance == null) {\n-            instance = new LinuxAArch64Linker();\n+        final class Holder {\n+            private static final LinuxAArch64Linker INSTANCE = new LinuxAArch64Linker();\n@@ -51,1 +50,6 @@\n-        return instance;\n+\n+        return Holder.INSTANCE;\n+    }\n+\n+    private LinuxAArch64Linker() {\n+        \/\/ Ensure there is only one instance\n@@ -55,2 +59,2 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n-        return CallArranger.LINUX.arrangeDowncall(inferredMethodType, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.LINUX.arrangeDowncall(inferredMethodType, function, options);\n@@ -70,2 +74,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n-        return LinuxAArch64VaList.ofAddress(ma, session);\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return LinuxAArch64VaList.ofAddress(address, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.SegmentAllocator;\n@@ -31,1 +37,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -52,2 +57,2 @@\n-public non-sealed class LinuxAArch64VaList implements VaList, Scoped {\n-    private static final Unsafe U = Unsafe.getUnsafe();\n+public non-sealed class LinuxAArch64VaList implements VaList {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -120,9 +125,5 @@\n-    private static LinuxAArch64VaList readFromSegment(MemorySegment segment) {\n-        MemorySegment stack = MemorySegment.ofAddress(stackPtr(segment),\n-                Long.MAX_VALUE, segment.session()); \/\/ size unknown\n-\n-        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).addOffset(-MAX_GP_OFFSET),\n-                MAX_GP_OFFSET, segment.session());\n-\n-        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).addOffset(-MAX_FP_OFFSET),\n-                MAX_FP_OFFSET, segment.session());\n+    private static LinuxAArch64VaList readFromAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n+        MemorySegment stack = stackPtr(segment); \/\/ size unknown\n+        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).address() - MAX_GP_OFFSET, MAX_GP_OFFSET, session);\n+        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).address() - MAX_FP_OFFSET, MAX_FP_OFFSET, session);\n@@ -132,9 +133,7 @@\n-    private static MemoryAddress emptyListAddress() {\n-        long ptr = U.allocateMemory(LAYOUT.byteSize());\n-        MemorySession session = MemorySession.openImplicit();\n-        session.addCloseAction(() -> U.freeMemory(ptr));\n-        MemorySegment ms = MemorySegment.ofAddress(MemoryAddress.ofLong(ptr),\n-                LAYOUT.byteSize(), session);\n-        VH_stack.set(ms, MemoryAddress.NULL);\n-        VH_gr_top.set(ms, MemoryAddress.NULL);\n-        VH_vr_top.set(ms, MemoryAddress.NULL);\n+    private static MemorySegment emptyListAddress() {\n+        long ptr = UNSAFE.allocateMemory(LAYOUT.byteSize());\n+        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n+        ms.session().addCloseAction(() -> UNSAFE.freeMemory(ptr));\n+        VH_stack.set(ms, MemorySegment.NULL);\n+        VH_gr_top.set(ms, MemorySegment.NULL);\n+        VH_vr_top.set(ms, MemorySegment.NULL);\n@@ -143,1 +142,1 @@\n-        return ms.address();\n+        return ms;\n@@ -150,1 +149,1 @@\n-    private MemoryAddress grTop() {\n+    private MemorySegment grTop() {\n@@ -154,2 +153,2 @@\n-    private static MemoryAddress grTop(MemorySegment segment) {\n-        return (MemoryAddress) VH_gr_top.get(segment);\n+    private static MemorySegment grTop(MemorySegment segment) {\n+        return (MemorySegment) VH_gr_top.get(segment);\n@@ -158,1 +157,1 @@\n-    private MemoryAddress vrTop() {\n+    private MemorySegment vrTop() {\n@@ -162,2 +161,2 @@\n-    private static MemoryAddress vrTop(MemorySegment segment) {\n-        return (MemoryAddress) VH_vr_top.get(segment);\n+    private static MemorySegment vrTop(MemorySegment segment) {\n+        return (MemorySegment) VH_vr_top.get(segment);\n@@ -178,2 +177,2 @@\n-    private static MemoryAddress stackPtr(MemorySegment segment) {\n-        return (MemoryAddress) VH_stack.get(segment);\n+    private static MemorySegment stackPtr(MemorySegment segment) {\n+        return (MemorySegment) VH_stack.get(segment);\n@@ -182,1 +181,1 @@\n-    private MemoryAddress stackPtr() {\n+    private MemorySegment stackPtr() {\n@@ -188,1 +187,1 @@\n-        VH_stack.set(segment, stack.address());\n+        VH_stack.set(segment, stack);\n@@ -220,1 +219,1 @@\n-            long addr = stack.address().toRawLongValue();\n+            long addr = stack.address();\n@@ -250,2 +249,2 @@\n-    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemoryAddress) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n@@ -321,1 +320,1 @@\n-                    MemoryAddress ptr = (MemoryAddress) ptrReader.get(\n+                    MemorySegment ptr = (MemorySegment) ptrReader.get(\n@@ -325,1 +324,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(ptr, layout.byteSize(), session());\n+                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.session());\n@@ -369,1 +368,1 @@\n-        sessionImpl().checkValidState();\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n@@ -396,7 +395,2 @@\n-    public static VaList ofAddress(MemoryAddress ma, MemorySession session) {\n-        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), session));\n-    }\n-\n-    @Override\n-    public MemorySession session() {\n-        return segment.session();\n+    public static VaList ofAddress(long address, MemorySession session) {\n+        return readFromAddress(address, session);\n@@ -407,1 +401,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n+        MemorySegment copy = segment.session().allocate(LAYOUT);\n@@ -413,2 +407,2 @@\n-    public MemoryAddress address() {\n-        return segment.address();\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -454,2 +448,2 @@\n-            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, session);\n-            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, session);\n+            this.gpRegs = session.allocate(LAYOUT_GP_REGS);\n+            this.fpRegs = session.allocate(LAYOUT_FP_REGS);\n@@ -474,2 +468,2 @@\n-        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n-            return arg(layout, value.address());\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n@@ -521,1 +515,1 @@\n-                                   valueSegment.address());\n+                                   valueSegment);\n@@ -548,2 +542,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-            MemorySegment vaListSegment = allocator.allocate(LAYOUT);\n+            MemorySegment vaListSegment = session.allocate(LAYOUT);\n@@ -554,1 +547,1 @@\n-                stackArgsSegment = allocator.allocate(stackArgsSize, 16);\n+                stackArgsSegment = session.allocate(stackArgsSize, 16);\n@@ -564,1 +557,1 @@\n-                stackArgsSegment = MemorySegment.ofAddress(MemoryAddress.NULL, 0, session);\n+                stackArgsSegment = MemorySegment.NULL;\n@@ -567,3 +560,3 @@\n-            VH_gr_top.set(vaListSegment, gpRegs.asSlice(gpRegs.byteSize()).address());\n-            VH_vr_top.set(vaListSegment, fpRegs.asSlice(fpRegs.byteSize()).address());\n-            VH_stack.set(vaListSegment, stackArgsSegment.address());\n+            VH_gr_top.set(vaListSegment, gpRegs.asSlice(gpRegs.byteSize()));\n+            VH_vr_top.set(vaListSegment, fpRegs.asSlice(fpRegs.byteSize()));\n+            VH_stack.set(vaListSegment, stackArgsSegment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":54,"deletions":61,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -45,1 +45,0 @@\n-    private static MacOsAArch64Linker instance;\n@@ -48,2 +47,2 @@\n-        if (instance == null) {\n-            instance = new MacOsAArch64Linker();\n+        final class Holder {\n+            private static final MacOsAArch64Linker INSTANCE = new MacOsAArch64Linker();\n@@ -51,1 +50,6 @@\n-        return instance;\n+\n+        return Holder.INSTANCE;\n+    }\n+\n+    private MacOsAArch64Linker() {\n+        \/\/ Ensure there is only one instance\n@@ -55,2 +59,2 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n-        return CallArranger.MACOS.arrangeDowncall(inferredMethodType, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.MACOS.arrangeDowncall(inferredMethodType, function, options);\n@@ -70,2 +74,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n-        return MacOsAArch64VaList.ofAddress(ma, session);\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return MacOsAArch64VaList.ofAddress(address, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -31,1 +37,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -48,1 +53,1 @@\n-public non-sealed class MacOsAArch64VaList implements VaList, Scoped {\n+public non-sealed class MacOsAArch64VaList implements VaList {\n@@ -52,1 +57,1 @@\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n@@ -55,1 +60,0 @@\n-    private final MemorySession session;\n@@ -57,1 +61,1 @@\n-    private MacOsAArch64VaList(MemorySegment segment, MemorySession session) {\n+    private MacOsAArch64VaList(MemorySegment segment) {\n@@ -59,1 +63,0 @@\n-        this.session = session;\n@@ -62,1 +65,1 @@\n-    public static final VaList empty() {\n+    public static VaList empty() {\n@@ -82,2 +85,2 @@\n-    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemoryAddress) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n@@ -104,2 +107,2 @@\n-                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), session());\n+                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n@@ -140,1 +143,1 @@\n-        sessionImpl().checkValidState();\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n@@ -156,3 +159,3 @@\n-    static MacOsAArch64VaList ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, session);\n-        return new MacOsAArch64VaList(segment, session);\n+    static MacOsAArch64VaList ofAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, session);\n+        return new MacOsAArch64VaList(segment);\n@@ -165,5 +168,0 @@\n-    @Override\n-    public MemorySession session() {\n-        return session;\n-    }\n-\n@@ -172,2 +170,2 @@\n-        sessionImpl().checkValidState();\n-        return new MacOsAArch64VaList(segment, session);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        return new MacOsAArch64VaList(segment);\n@@ -177,2 +175,2 @@\n-    public MemoryAddress address() {\n-        return segment.address();\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -214,2 +212,2 @@\n-        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n-            return arg(layout, value.address());\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n@@ -228,2 +226,0 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-\n@@ -231,1 +227,1 @@\n-            MemorySegment segment = allocator.allocate(allocationSize);\n+            MemorySegment segment = session.allocate(allocationSize);\n@@ -240,1 +236,1 @@\n-                            MemorySegment copy = allocator.allocate(arg.layout);\n+                            MemorySegment copy = session.allocate(arg.layout);\n@@ -242,1 +238,1 @@\n-                            VH_address.set(cursor, copy.address());\n+                            VH_address.set(cursor, copy);\n@@ -257,1 +253,1 @@\n-            return new MacOsAArch64VaList(segment, session);\n+            return new MacOsAArch64VaList(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":29,"deletions":33,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -37,0 +38,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -39,1 +41,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -42,1 +43,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -76,11 +76,4 @@\n-    \/\/ record\n-    public static class Bindings {\n-        public final CallingSequence callingSequence;\n-        public final boolean isInMemoryReturn;\n-        public final int nVectorArgs;\n-\n-        Bindings(CallingSequence callingSequence, boolean isInMemoryReturn, int nVectorArgs) {\n-            this.callingSequence = callingSequence;\n-            this.isInMemoryReturn = isInMemoryReturn;\n-            this.nVectorArgs = nVectorArgs;\n-        }\n+    public record Bindings(\n+            CallingSequence callingSequence,\n+            boolean isInMemoryReturn,\n+            int nVectorArgs) {\n@@ -97,1 +90,1 @@\n-            Class<?> carrier = MemoryAddress.class;\n+            Class<?> carrier = MemorySegment.class;\n@@ -215,8 +208,5 @@\n-            switch (type) {\n-                case StorageClasses.INTEGER:\n-                    return nIntegerReg;\n-                case StorageClasses.VECTOR:\n-                    return nVectorReg;\n-                default:\n-                    throw new IllegalStateException();\n-            }\n+            return switch (type) {\n+                case StorageClasses.INTEGER -> nIntegerReg;\n+                case StorageClasses.VECTOR -> nVectorReg;\n+                default -> throw new IllegalStateException();\n+            };\n@@ -227,8 +217,3 @@\n-                case StorageClasses.INTEGER:\n-                    nIntegerReg++;\n-                    break;\n-                case StorageClasses.VECTOR:\n-                    nVectorReg++;\n-                    break;\n-                default:\n-                    throw new IllegalStateException();\n+                case StorageClasses.INTEGER -> nIntegerReg++;\n+                case StorageClasses.VECTOR -> nVectorReg++;\n+                default -> throw new IllegalStateException();\n@@ -260,1 +245,1 @@\n-                case STRUCT: {\n+                case STRUCT -> {\n@@ -277,1 +262,0 @@\n-                    break;\n@@ -279,2 +263,2 @@\n-                case POINTER: {\n-                    bindings.unboxAddress(carrier);\n+                case POINTER -> {\n+                    bindings.unboxAddress();\n@@ -283,3 +267,2 @@\n-                    break;\n-                }\n-                case INTEGER: {\n+                                    }\n+                case INTEGER -> {\n@@ -288,1 +271,0 @@\n-                    break;\n@@ -290,1 +272,1 @@\n-                case FLOAT: {\n+                case FLOAT -> {\n@@ -293,1 +275,0 @@\n-                    break;\n@@ -295,2 +276,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n@@ -313,1 +293,1 @@\n-                case STRUCT: {\n+                case STRUCT -> {\n@@ -329,1 +309,0 @@\n-                    break;\n@@ -331,1 +310,1 @@\n-                case POINTER: {\n+                case POINTER -> {\n@@ -334,2 +313,1 @@\n-                            .boxAddress();\n-                    break;\n+                            .boxAddressRaw(Utils.pointeeSize(layout));\n@@ -337,1 +315,1 @@\n-                case INTEGER: {\n+                case INTEGER -> {\n@@ -340,1 +318,0 @@\n-                    break;\n@@ -342,1 +319,1 @@\n-                case FLOAT: {\n+                case FLOAT -> {\n@@ -345,1 +322,0 @@\n-                    break;\n@@ -347,2 +323,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":28,"deletions":53,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -31,1 +37,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -48,1 +53,1 @@\n-public non-sealed class SysVVaList implements VaList, Scoped {\n+public non-sealed class SysVVaList implements VaList {\n@@ -130,1 +135,2 @@\n-    private static SysVVaList readFromSegment(MemorySegment segment) {\n+    private static SysVVaList readFromAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n@@ -136,1 +142,1 @@\n-    private static MemoryAddress emptyListAddress() {\n+    private static MemorySegment emptyListAddress() {\n@@ -138,4 +144,2 @@\n-        MemorySession session = MemorySession.openImplicit();\n-        session.addCloseAction(() -> U.freeMemory(ptr));\n-        MemorySegment base = MemorySegment.ofAddress(MemoryAddress.ofLong(ptr),\n-                LAYOUT.byteSize(), session);\n+        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n+        base.session().addCloseAction(() -> U.freeMemory(ptr));\n@@ -144,3 +148,3 @@\n-        VH_overflow_arg_area.set(base, MemoryAddress.NULL);\n-        VH_reg_save_area.set(base, MemoryAddress.NULL);\n-        return base.address();\n+        VH_overflow_arg_area.set(base, MemorySegment.NULL);\n+        VH_reg_save_area.set(base, MemorySegment.NULL);\n+        return base;\n@@ -170,2 +174,2 @@\n-        return MemorySegment.ofAddress(((MemoryAddress)VH_reg_save_area.get(segment)),\n-                LAYOUT_REG_SAVE_AREA.byteSize(), segment.session());\n+        return ((MemorySegment)VH_reg_save_area.get(segment))\n+                .asSlice(0, LAYOUT_REG_SAVE_AREA.byteSize());\n@@ -175,2 +179,1 @@\n-        return MemorySegment.ofAddress(((MemoryAddress)VH_overflow_arg_area.get(segment)),\n-                Long.MAX_VALUE, segment.session()); \/\/ size unknown\n+        return (MemorySegment)VH_overflow_arg_area.get(segment); \/\/ size unknown\n@@ -182,1 +185,1 @@\n-            long addr = overflowArgArea.address().toRawLongValue();\n+            long addr = overflowArgArea.address();\n@@ -190,1 +193,1 @@\n-        VH_overflow_arg_area.set(segment, overflowArgArea.address());\n+        VH_overflow_arg_area.set(segment, overflowArgArea);\n@@ -217,2 +220,2 @@\n-    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemoryAddress) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n@@ -310,1 +313,1 @@\n-        sessionImpl().checkValidState();\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n@@ -330,7 +333,2 @@\n-    public static VaList ofAddress(MemoryAddress ma, MemorySession session) {\n-        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), session));\n-    }\n-\n-    @Override\n-    public MemorySession session() {\n-        return segment.session();\n+    public static VaList ofAddress(long address, MemorySession session) {\n+        return readFromAddress(address, session);\n@@ -341,1 +339,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n+        MemorySegment copy = segment.session().allocate(LAYOUT);\n@@ -347,2 +345,2 @@\n-    public MemoryAddress address() {\n-        return segment.address();\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -375,1 +373,1 @@\n-            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, session);\n+            this.reg_save_area = session.allocate(LAYOUT_REG_SAVE_AREA);\n@@ -394,2 +392,2 @@\n-        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n-            return arg(layout, value.address());\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n@@ -454,2 +452,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-            MemorySegment vaListSegment = allocator.allocate(LAYOUT);\n+            MemorySegment vaListSegment = session.allocate(LAYOUT);\n@@ -460,1 +457,1 @@\n-                stackArgsSegment = allocator.allocate(stackArgsSize, 16);\n+                stackArgsSegment = session.allocate(stackArgsSize, 16);\n@@ -466,1 +463,1 @@\n-                    if (arg.value instanceof MemorySegment) {\n+                    if (arg.layout instanceof GroupLayout) {\n@@ -475,1 +472,1 @@\n-                stackArgsSegment = MemorySegment.ofAddress(MemoryAddress.NULL, 0, session);\n+                stackArgsSegment = MemorySegment.NULL;\n@@ -479,2 +476,2 @@\n-            VH_overflow_arg_area.set(vaListSegment, stackArgsSegment.address());\n-            VH_reg_save_area.set(vaListSegment, reg_save_area.address());\n+            VH_overflow_arg_area.set(vaListSegment, stackArgsSegment);\n+            VH_reg_save_area.set(vaListSegment, reg_save_area);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":38,"deletions":41,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -30,0 +31,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -31,1 +33,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -33,1 +34,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -43,1 +43,0 @@\n-    private static SysVx64Linker instance;\n@@ -46,2 +45,2 @@\n-        if (instance == null) {\n-            instance = new SysVx64Linker();\n+        final class Holder {\n+            private static final SysVx64Linker INSTANCE = new SysVx64Linker();\n@@ -49,1 +48,2 @@\n-        return instance;\n+\n+        return Holder.INSTANCE;\n@@ -52,0 +52,3 @@\n+    private SysVx64Linker() {\n+        \/\/ Ensure there is only one instance\n+    }\n@@ -53,1 +56,1 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n@@ -68,2 +71,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n-        return SysVVaList.ofAddress(ma, session);\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return SysVVaList.ofAddress(address, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -30,0 +29,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n@@ -31,0 +32,1 @@\n+import java.lang.foreign.StructLayout;\n@@ -109,2 +111,2 @@\n-    private static ArgumentClassImpl argumentClassFor(MemoryLayout layout) {\n-        Class<?> carrier = ((ValueLayout)layout).carrier();\n+    private static ArgumentClassImpl argumentClassFor(ValueLayout layout) {\n+        Class<?> carrier = layout.carrier();\n@@ -116,1 +118,1 @@\n-        } else if (carrier == MemoryAddress.class) {\n+        } else if (carrier == MemorySegment.class) {\n@@ -181,1 +183,1 @@\n-                throw new IllegalArgumentException(\"Unhandled type \" + type);\n+                throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n@@ -196,1 +198,1 @@\n-            if (group.isStruct()) {\n+            if (group instanceof StructLayout) {\n@@ -204,2 +206,1 @@\n-        if (l instanceof GroupLayout) {\n-            GroupLayout group = (GroupLayout)l;\n+        if (l instanceof GroupLayout group) {\n@@ -208,1 +209,1 @@\n-                if (group.isStruct()) {\n+                if (group instanceof StructLayout) {\n@@ -212,1 +213,1 @@\n-        } else if (l.isPadding()) {\n+        } else if (l instanceof PaddingLayout) {\n@@ -214,2 +215,1 @@\n-        } else if (l instanceof SequenceLayout) {\n-            SequenceLayout seq = (SequenceLayout)l;\n+        } else if (l instanceof SequenceLayout seq) {\n@@ -221,1 +221,1 @@\n-        } else if (l instanceof ValueLayout) {\n+        } else if (l instanceof ValueLayout vl) {\n@@ -228,2 +228,2 @@\n-            ArgumentClassImpl argumentClass = (offset % l.byteAlignment()) == 0 ?\n-                    argumentClassFor(l) :\n+            ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n+                    argumentClassFor(vl) :\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -38,0 +39,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -40,1 +42,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -43,1 +44,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -76,9 +76,3 @@\n-    \/\/ record\n-    public static class Bindings {\n-        public final CallingSequence callingSequence;\n-        public final boolean isInMemoryReturn;\n-\n-        Bindings(CallingSequence callingSequence, boolean isInMemoryReturn) {\n-            this.callingSequence = callingSequence;\n-            this.isInMemoryReturn = isInMemoryReturn;\n-        }\n+    public record Bindings(\n+            CallingSequence callingSequence,\n+            boolean isInMemoryReturn) {\n@@ -88,0 +82,4 @@\n+        return getBindings(mt, cDesc, forUpcall, LinkerOptions.empty());\n+    }\n+\n+    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, LinkerOptions options) {\n@@ -107,1 +105,1 @@\n-            Class<?> carrier = MemoryAddress.class;\n+            Class<?> carrier = MemorySegment.class;\n@@ -118,1 +116,1 @@\n-            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i), SharedUtils.isVarargsIndex(cDesc, i));\n+            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i), options.isVarargsIndex(i));\n@@ -124,2 +122,2 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, false, options);\n@@ -167,1 +165,1 @@\n-                long alignment = Math.max(SharedUtils.alignment(layout, true), STACK_SLOT_SIZE);\n+                long alignment = Math.max(layout.byteAlignment(), STACK_SLOT_SIZE);\n@@ -213,1 +211,1 @@\n-                            .unboxAddress(MemorySegment.class);\n+                            .unboxAddress();\n@@ -219,1 +217,1 @@\n-                    bindings.unboxAddress(carrier);\n+                    bindings.unboxAddress();\n@@ -278,2 +276,1 @@\n-                            .boxAddress()\n-                            .toSegment(layout);\n+                            .boxAddress(layout);\n@@ -285,1 +282,1 @@\n-                            .boxAddress();\n+                            .boxAddressRaw(Utils.pointeeSize(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -30,0 +29,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -41,1 +41,1 @@\n-        \/\/ No 128 bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but they act just\n+        \/\/ No 128-bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but they act just\n@@ -60,1 +60,1 @@\n-        } else if (carrier == MemoryAddress.class) {\n+        } else if (carrier == MemorySegment.class) {\n@@ -88,1 +88,1 @@\n-            throw new IllegalArgumentException(\"Unhandled type \" + type);\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -31,1 +37,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -39,1 +44,0 @@\n-import java.util.stream.Stream;\n@@ -59,1 +63,1 @@\n-public non-sealed class WinVaList implements VaList, Scoped {\n+public non-sealed class WinVaList implements VaList {\n@@ -63,1 +67,1 @@\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n@@ -66,1 +70,0 @@\n-    private final MemorySession session;\n@@ -68,1 +71,1 @@\n-    private WinVaList(MemorySegment segment, MemorySession session) {\n+    private WinVaList(MemorySegment segment) {\n@@ -70,1 +73,0 @@\n-        this.session = session;\n@@ -93,2 +95,2 @@\n-    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemoryAddress) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n@@ -115,2 +117,2 @@\n-                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), session());\n+                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n@@ -142,1 +144,1 @@\n-        sessionImpl().checkValidState();\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n@@ -150,3 +152,2 @@\n-    static WinVaList ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, session);\n-        return new WinVaList(segment, session);\n+    static WinVaList ofAddress(long address, MemorySession session) {\n+        return new WinVaList(MemorySegment.ofAddress(address, Long.MAX_VALUE, session));\n@@ -159,5 +160,0 @@\n-    @Override\n-    public MemorySession session() {\n-        return session;\n-    }\n-\n@@ -166,2 +162,2 @@\n-        sessionImpl().checkValidState();\n-        return new WinVaList(segment, session);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        return new WinVaList(segment);\n@@ -171,2 +167,2 @@\n-    public MemoryAddress address() {\n-        return segment.address();\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -208,2 +204,2 @@\n-        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n-            return arg(layout, value.address());\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n@@ -221,2 +217,2 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-            MemorySegment segment = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size());\n+\n+            MemorySegment segment = session.allocate(VA_SLOT_SIZE_BYTES * args.size());\n@@ -231,1 +227,1 @@\n-                            MemorySegment copy = allocator.allocate(arg.layout);\n+                            MemorySegment copy = session.allocate(arg.layout);\n@@ -233,1 +229,1 @@\n-                            VH_address.set(cursor, copy.address());\n+                            VH_address.set(cursor, copy);\n@@ -246,1 +242,1 @@\n-            return new WinVaList(segment, session);\n+            return new WinVaList(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":28,"deletions":32,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -30,1 +31,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -42,1 +42,0 @@\n-    private static Windowsx64Linker instance;\n@@ -45,2 +44,2 @@\n-        if (instance == null) {\n-            instance = new Windowsx64Linker();\n+        final class Holder {\n+            private static final Windowsx64Linker INSTANCE = new Windowsx64Linker();\n@@ -48,1 +47,6 @@\n-        return instance;\n+\n+        return Holder.INSTANCE;\n+    }\n+\n+    private Windowsx64Linker() {\n+        \/\/ Ensure there is only one instance\n@@ -52,2 +56,2 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n-        return CallArranger.arrangeDowncall(inferredMethodType, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeDowncall(inferredMethodType, function, options);\n@@ -67,2 +71,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n-        return WinVaList.ofAddress(ma, session);\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return WinVaList.ofAddress(address, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.LongBinaryOperator;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A compound layout that aggregates multiple <em>member layouts<\/em>. There are two ways in which member layouts\n+ * can be combined: if member layouts are laid out one after the other, the resulting group layout is said to be a <em>struct<\/em>\n+ * (see {@link MemoryLayout#structLayout(MemoryLayout...)}); conversely, if all member layouts are laid out at the same starting offset,\n+ * the resulting group layout is said to be a <em>union<\/em> (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ *\n+ * @implSpec\n+ * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 19\n+ *\/\n+public sealed abstract class AbstractGroupLayout<L extends AbstractGroupLayout<L> & MemoryLayout>\n+        extends AbstractLayout<L>\n+        permits StructLayoutImpl, UnionLayoutImpl {\n+\n+    private final Kind kind;\n+    private final List<MemoryLayout> elements;\n+\n+    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements) {\n+        this(kind, elements, kind.alignof(elements), Optional.empty());\n+    }\n+\n+    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+        super(kind.sizeof(elements), bitAlignment, name); \/\/ Subclassing creates toctou problems here\n+        this.kind = kind;\n+        this.elements = List.copyOf(elements);\n+    }\n+\n+    \/**\n+     * Returns the member layouts associated with this group.\n+     *\n+     * @apiNote the order in which member layouts are returned is the same order in which member layouts have\n+     * been passed to one of the group layout factory methods (see {@link MemoryLayout#structLayout(MemoryLayout...)},\n+     * {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+     *\n+     * @return the member layouts associated with this group.\n+     *\/\n+    public final List<MemoryLayout> memberLayouts() {\n+        return elements; \/\/ \"elements\" are already unmodifiable.\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public final String toString() {\n+        return decorateLayoutString(elements.stream()\n+                .map(Object::toString)\n+                .collect(Collectors.joining(kind.delimTag, \"[\", \"]\")));\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public final boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!super.equals(other)) {\n+            return false;\n+        }\n+        return other instanceof AbstractGroupLayout<?> otherGroup &&\n+                kind == otherGroup.kind &&\n+                elements.equals(otherGroup.elements);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public final int hashCode() {\n+        return Objects.hash(super.hashCode(), kind, elements);\n+    }\n+\n+    @Override\n+    public final boolean hasNaturalAlignment() {\n+        return bitAlignment() == kind.alignof(elements);\n+    }\n+\n+    \/**\n+     * The group kind.\n+     *\/\n+    enum Kind {\n+        \/**\n+         * A 'struct' kind.\n+         *\/\n+        STRUCT(\"\", Math::addExact),\n+        \/**\n+         * A 'union' kind.\n+         *\/\n+        UNION(\"|\", Math::max);\n+\n+        final String delimTag;\n+        final LongBinaryOperator sizeOp;\n+\n+        Kind(String delimTag, LongBinaryOperator sizeOp) {\n+            this.delimTag = delimTag;\n+            this.sizeOp = sizeOp;\n+        }\n+\n+        long sizeof(List<MemoryLayout> elems) {\n+            long size = 0;\n+            for (MemoryLayout elem : elems) {\n+                size = sizeOp.applyAsLong(size, elem.bitSize());\n+            }\n+            return size;\n+        }\n+\n+        long alignof(List<MemoryLayout> elems) {\n+            return elems.stream()\n+                    .mapToLong(MemoryLayout::bitAlignment)\n+                    .max() \/\/ max alignment in case we have member layouts\n+                    .orElse(1); \/\/ or minimal alignment if no member layout is given\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public abstract sealed class AbstractLayout<L extends AbstractLayout<L> & MemoryLayout>\n+        permits AbstractGroupLayout, PaddingLayoutImpl, SequenceLayoutImpl, ValueLayouts.AbstractValueLayout {\n+\n+    private final long bitSize;\n+    private final long bitAlignment;\n+    private final Optional<String> name;\n+    @Stable\n+    private long byteSize;\n+\n+    AbstractLayout(long bitSize, long bitAlignment, Optional<String> name) {\n+        this.bitSize = bitSize;\n+        this.bitAlignment = bitAlignment;\n+        this.name = name;\n+    }\n+\n+    public final L withName(String name) {\n+        Objects.requireNonNull(name);\n+        return dup(bitAlignment, Optional.of(name));\n+    }\n+\n+    public final Optional<String> name() {\n+        return name;\n+    }\n+\n+    public final L withBitAlignment(long bitAlignment) {\n+        checkAlignment(bitAlignment);\n+        return dup(bitAlignment, name);\n+    }\n+\n+    public final long bitAlignment() {\n+        return bitAlignment;\n+    }\n+\n+    @ForceInline\n+    public final long byteSize() {\n+        if (byteSize == 0) {\n+            byteSize = Utils.bitsToBytesOrThrow(bitSize(),\n+                    () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n+        }\n+        return byteSize;\n+    }\n+\n+    public final long bitSize() {\n+        return bitSize;\n+    }\n+\n+    public boolean hasNaturalAlignment() {\n+        return bitSize == bitAlignment;\n+    }\n+\n+    \/\/ the following methods have to copy the same Javadoc as in MemoryLayout, or subclasses will just show\n+    \/\/ the Object methods javadoc\n+\n+    \/**\n+     * {@return the hash code value for this layout}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, bitSize, bitAlignment);\n+    }\n+\n+    \/**\n+     * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified\n+     * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of\n+     * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional\n+     * conditions must be satisfied:\n+     * <ul>\n+     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n+     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n+     *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and\n+     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal<\/li>\n+     *     <li>two group layouts are considered equal if they are of the same type (see {@link StructLayout},\n+     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n+     * <\/ul>\n+     *\n+     * @param other the object to be compared for equality with this layout.\n+     * @return {@code true} if the specified object is equal to this layout.\n+     *\/\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        return other instanceof AbstractLayout<?> otherLayout &&\n+                name.equals(otherLayout.name) &&\n+                bitSize == otherLayout.bitSize &&\n+                bitAlignment == otherLayout.bitAlignment;\n+    }\n+\n+    \/**\n+     * {@return the string representation of this layout}\n+     *\/\n+    public abstract String toString();\n+\n+    abstract L dup(long alignment, Optional<String> name);\n+\n+    String decorateLayoutString(String s) {\n+        if (name().isPresent()) {\n+            s = String.format(\"%s(%s)\", s, name().get());\n+        }\n+        if (!hasNaturalAlignment()) {\n+            s = bitAlignment + \"%\" + s;\n+        }\n+        return s;\n+    }\n+\n+    private static void checkAlignment(long alignmentBitCount) {\n+        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n+                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n+            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n+        }\n+    }\n+\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+public final class MemoryLayoutUtil {\n+\n+    private MemoryLayoutUtil() {\n+    }\n+\n+    public static void checkSize(long size) {\n+        checkSize(size, false);\n+    }\n+\n+    public static void checkSize(long size, boolean includeZero) {\n+        if (size < 0 || (!includeZero && size == 0)) {\n+            throw new IllegalArgumentException(\"Invalid size for layout: \" + size);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/MemoryLayoutUtil.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.PaddingLayout;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public final class PaddingLayoutImpl extends AbstractLayout<PaddingLayoutImpl> implements PaddingLayout {\n+\n+    private PaddingLayoutImpl(long bitSize) {\n+        this(bitSize, 1, Optional.empty());\n+    }\n+\n+    private PaddingLayoutImpl(long bitSize, long bitAlignment, Optional<String> name) {\n+        super(bitSize, bitAlignment, name);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorateLayoutString(\"x\" + bitSize());\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!super.equals(other)) {\n+            return false;\n+        }\n+        if (!(other instanceof PaddingLayoutImpl p)) {\n+            return false;\n+        }\n+        return bitSize() == p.bitSize();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), bitSize());\n+    }\n+\n+    @Override\n+    PaddingLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new PaddingLayoutImpl(bitSize(), bitAlignment, name);\n+    }\n+\n+    @Override\n+    public boolean hasNaturalAlignment() {\n+        return true;\n+    }\n+\n+    public static PaddingLayout of(long bitSize) {\n+        return new PaddingLayoutImpl(bitSize);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/PaddingLayoutImpl.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public final class SequenceLayoutImpl extends AbstractLayout<SequenceLayoutImpl> implements SequenceLayout {\n+\n+    private final long elemCount;\n+    private final MemoryLayout elementLayout;\n+\n+    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout) {\n+        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n+    }\n+\n+    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout, long bitAlignment, Optional<String> name) {\n+        super(Math.multiplyExact(elemCount, elementLayout.bitSize()), bitAlignment, name);\n+        this.elemCount = elemCount;\n+        this.elementLayout = elementLayout;\n+    }\n+\n+    \/**\n+     * {@return the element layout associated with this sequence layout}\n+     *\/\n+    public MemoryLayout elementLayout() {\n+        return elementLayout;\n+    }\n+\n+    \/**\n+     * {@return the element count of this sequence layout}\n+     *\/\n+    public long elementCount() {\n+        return elemCount;\n+    }\n+\n+    \/**\n+     * Returns a sequence layout with the same element layout, alignment constraints and name as this sequence layout,\n+     * but with the specified element count.\n+     *\n+     * @param elementCount the new element count.\n+     * @return a sequence layout with the given element count.\n+     * @throws IllegalArgumentException if {@code elementCount < 0}.\n+     *\/\n+    public SequenceLayout withElementCount(long elementCount) {\n+        MemoryLayoutUtil.checkSize(elementCount, true);\n+        return new SequenceLayoutImpl(elementCount, elementLayout, bitAlignment(), name());\n+    }\n+\n+    \/**\n+     * Re-arrange the elements in this sequence layout into a multi-dimensional sequence layout.\n+     * The resulting layout is a sequence layout where element layouts in the flattened projection of this\n+     * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts\n+     * according to the provided element counts. This transformation preserves the layout size;\n+     * that is, multiplying the provided element counts must yield the same element count\n+     * as the flattened projection of this sequence layout.\n+     * <p>\n+     * For instance, given a sequence layout of the kind:\n+     * {@snippet lang = java:\n+     * var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n+     *}\n+     * calling {@code seq.reshape(2, 6)} will yield the following sequence layout:\n+     * {@snippet lang = java:\n+     * var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, ValueLayout.JAVA_INT));\n+     *}\n+     * <p>\n+     * If one of the provided element count is the special value {@code -1}, then the element\n+     * count in that position will be inferred from the remaining element counts and the\n+     * element count of the flattened projection of this layout. For instance, a layout equivalent to\n+     * the above {@code reshapeSeq} can also be computed in the following ways:\n+     * {@snippet lang = java:\n+     * var reshapeSeqImplicit1 = seq.reshape(-1, 6);\n+     * var reshapeSeqImplicit2 = seq.reshape(2, -1);\n+     *}\n+     *\n+     * @param elementCounts an array of element counts, of which at most one can be {@code -1}.\n+     * @return a sequence layout where element layouts in the flattened projection of this\n+     * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts.\n+     * @throws IllegalArgumentException if two or more element counts are set to {@code -1}, or if one\n+     *                                  or more element count is {@code <= 0} (but other than {@code -1}) or, if, after any required inference,\n+     *                                  multiplying the element counts does not yield the same element count as the flattened projection of this\n+     *                                  sequence layout.\n+     *\/\n+    public SequenceLayout reshape(long... elementCounts) {\n+        Objects.requireNonNull(elementCounts);\n+        if (elementCounts.length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        SequenceLayout flat = flatten();\n+        long expectedCount = flat.elementCount();\n+\n+        long actualCount = 1;\n+        int inferPosition = -1;\n+        for (int i = 0; i < elementCounts.length; i++) {\n+            if (elementCounts[i] == -1) {\n+                if (inferPosition == -1) {\n+                    inferPosition = i;\n+                } else {\n+                    throw new IllegalArgumentException(\"Too many unspecified element counts\");\n+                }\n+            } else if (elementCounts[i] <= 0) {\n+                throw new IllegalArgumentException(\"Invalid element count: \" + elementCounts[i]);\n+            } else {\n+                actualCount = elementCounts[i] * actualCount;\n+            }\n+        }\n+\n+        \/\/ infer an unspecified element count (if any)\n+        if (inferPosition != -1) {\n+            long inferredCount = expectedCount \/ actualCount;\n+            elementCounts[inferPosition] = inferredCount;\n+            actualCount = actualCount * inferredCount;\n+        }\n+\n+        if (actualCount != expectedCount) {\n+            throw new IllegalArgumentException(\"Element counts do not match expected size: \" + expectedCount);\n+        }\n+\n+        MemoryLayout res = flat.elementLayout();\n+        for (int i = elementCounts.length - 1; i >= 0; i--) {\n+            res = MemoryLayout.sequenceLayout(elementCounts[i], res);\n+        }\n+        return (SequenceLayoutImpl) res;\n+    }\n+\n+    \/**\n+     * Returns a flattened sequence layout. The element layout of the returned sequence layout\n+     * is the first non-sequence element layout found by recursively traversing the element layouts of this sequence layout.\n+     * This transformation preserves the layout size; nested sequence layout in this sequence layout will\n+     * be dropped and their element counts will be incorporated into that of the returned sequence layout.\n+     * For instance, given a sequence layout of the kind:\n+     * {@snippet lang = java:\n+     * var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n+     *}\n+     * calling {@code seq.flatten()} will yield the following sequence layout:\n+     * {@snippet lang = java:\n+     * var flattenedSeq = MemoryLayout.sequenceLayout(12, ValueLayout.JAVA_INT);\n+     *}\n+     *\n+     * @return a sequence layout with the same size as this layout (but, possibly, with different\n+     * element count), whose element layout is not a sequence layout.\n+     *\/\n+    public SequenceLayout flatten() {\n+        long count = elementCount();\n+        MemoryLayout elemLayout = elementLayout();\n+        while (elemLayout instanceof SequenceLayoutImpl elemSeq) {\n+            count = count * elemSeq.elementCount();\n+            elemLayout = elemSeq.elementLayout();\n+        }\n+        return MemoryLayout.sequenceLayout(count, elemLayout);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorateLayoutString(String.format(\"[%s:%s]\",\n+                elemCount, elementLayout));\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!super.equals(other)) {\n+            return false;\n+        }\n+        return other instanceof SequenceLayoutImpl otherSeq &&\n+                elemCount == otherSeq.elemCount &&\n+                elementLayout.equals(otherSeq.elementLayout);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), elemCount, elementLayout);\n+    }\n+\n+    @Override\n+    SequenceLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new SequenceLayoutImpl(elementCount(), elementLayout, bitAlignment, name);\n+    }\n+\n+    @Override\n+    public boolean hasNaturalAlignment() {\n+        return bitAlignment() == elementLayout.bitAlignment();\n+    }\n+\n+    public static SequenceLayout of(long elementCount, MemoryLayout elementLayout) {\n+        return new SequenceLayoutImpl(elementCount, elementLayout);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public final class StructLayoutImpl extends AbstractGroupLayout<StructLayoutImpl> implements StructLayout {\n+\n+    private StructLayoutImpl(List<MemoryLayout> elements) {\n+        super(Kind.STRUCT, elements);\n+    }\n+\n+    private StructLayoutImpl(List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+        super(Kind.STRUCT, elements, bitAlignment, name);\n+    }\n+\n+    @Override\n+    StructLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new StructLayoutImpl(memberLayouts(), bitAlignment, name);\n+    }\n+\n+    public static StructLayout of(List<MemoryLayout> elements) {\n+        return new StructLayoutImpl(elements);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/StructLayoutImpl.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public final class UnionLayoutImpl extends AbstractGroupLayout<UnionLayoutImpl> implements UnionLayout {\n+\n+    private UnionLayoutImpl(List<MemoryLayout> elements) {\n+        super(Kind.UNION, elements);\n+    }\n+\n+    private UnionLayoutImpl(List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+        super(Kind.UNION, elements, bitAlignment, name);\n+    }\n+\n+    @Override\n+    UnionLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new UnionLayoutImpl(memberLayouts(), bitAlignment, name);\n+    }\n+\n+    public static UnionLayout of(List<MemoryLayout> elements) {\n+        return new UnionLayoutImpl(elements);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/UnionLayoutImpl.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,457 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * A value layout. A value layout is used to model the memory layout associated with values of basic data types, such as <em>integral<\/em> types\n+ * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment (in bits),\n+ * a {@linkplain ByteOrder byte order}, and a <em>carrier<\/em>, that is, the Java type that should be used when\n+ * {@linkplain MemorySegment#get(ValueLayout.OfInt, long) accessing} a memory region using the value layout.\n+ * <p>\n+ * This class defines useful value layout constants for Java primitive types and addresses.\n+ * The layout constants in this class make implicit alignment and byte-ordering assumption: all layout\n+ * constants in this class are byte-aligned, and their byte order is set to the {@linkplain ByteOrder#nativeOrder() platform default},\n+ * thus making it easy to work with other APIs, such as arrays and {@link java.nio.ByteBuffer}.\n+ *\n+ * @implSpec This class and its subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public final class ValueLayouts {\n+\n+    private ValueLayouts() {\n+    }\n+\n+    abstract sealed static class AbstractValueLayout<V extends AbstractValueLayout<V> & ValueLayout> extends AbstractLayout<V> {\n+\n+        static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n+\n+        private final Class<?> carrier;\n+        private final ByteOrder order;\n+        @Stable\n+        private VarHandle handle;\n+\n+        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize) {\n+            this(carrier, order, bitSize, bitSize, Optional.empty());\n+        }\n+\n+        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize, long bitAlignment, Optional<String> name) {\n+            super(bitSize, bitAlignment, name);\n+            this.carrier = carrier;\n+            this.order = order;\n+            checkCarrierSize(carrier, bitSize);\n+        }\n+\n+        \/**\n+         * {@return the value's byte order}\n+         *\/\n+        public final ByteOrder order() {\n+            return order;\n+        }\n+\n+        \/**\n+         * Returns a value layout with the same carrier, alignment constraints and name as this value layout,\n+         * but with the specified byte order.\n+         *\n+         * @param order the desired byte order.\n+         * @return a value layout with the given byte order.\n+         *\/\n+        abstract V withOrder(ByteOrder order);\n+\n+        @Override\n+        public final String toString() {\n+            char descriptor = carrier == MemorySegment.class ? 'A' : carrier.descriptorString().charAt(0);\n+            if (order == ByteOrder.LITTLE_ENDIAN) {\n+                descriptor = Character.toLowerCase(descriptor);\n+            }\n+            return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (!super.equals(other)) {\n+                return false;\n+            }\n+            return other instanceof AbstractValueLayout<?> otherValue &&\n+                    carrier.equals(otherValue.carrier) &&\n+                    order.equals(otherValue.order);\n+        }\n+\n+        public final VarHandle arrayElementVarHandle(int... shape) {\n+            Objects.requireNonNull(shape);\n+            MemoryLayout layout = self();\n+            List<MemoryLayout.PathElement> path = new ArrayList<>();\n+            for (int i = shape.length; i > 0; i--) {\n+                int size = shape[i - 1];\n+                if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n+                layout = MemoryLayout.sequenceLayout(size, layout);\n+                path.add(MemoryLayout.PathElement.sequenceElement());\n+            }\n+            layout = MemoryLayout.sequenceLayout(layout);\n+            path.add(MemoryLayout.PathElement.sequenceElement());\n+            return layout.varHandle(path.toArray(new MemoryLayout.PathElement[0]));\n+        }\n+\n+        \/**\n+         * {@return the carrier associated with this value layout}\n+         *\/\n+        public final Class<?> carrier() {\n+            return carrier;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), order, carrier);\n+        }\n+\n+        @Override\n+        abstract V dup(long bitAlignment, Optional<String> name);\n+\n+        static void checkCarrierSize(Class<?> carrier, long size) {\n+            if (!isValidCarrier(carrier)) {\n+                throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n+            }\n+            if (carrier == MemorySegment.class && size != ADDRESS_SIZE_BITS) {\n+                throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n+            }\n+            if (carrier.isPrimitive()) {\n+                int expectedSize = carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n+                if (size != expectedSize) {\n+                    throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+                }\n+            }\n+        }\n+\n+        static boolean isValidCarrier(Class<?> carrier) {\n+            return carrier == boolean.class\n+                    || carrier == byte.class\n+                    || carrier == short.class\n+                    || carrier == char.class\n+                    || carrier == int.class\n+                    || carrier == long.class\n+                    || carrier == float.class\n+                    || carrier == double.class\n+                    || carrier == MemorySegment.class;\n+        }\n+\n+\n+        @ForceInline\n+        public final VarHandle accessHandle() {\n+            if (handle == null) {\n+                \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n+                handle = Utils.makeSegmentViewVarHandle(self());\n+            }\n+            return handle;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final V self() {\n+            return (V) this;\n+        }\n+    }\n+\n+    public static final class OfBooleanImpl extends AbstractValueLayout<OfBooleanImpl> implements ValueLayout.OfBoolean {\n+\n+        private OfBooleanImpl(ByteOrder order) {\n+            super(boolean.class, order, 8);\n+        }\n+\n+        private OfBooleanImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(boolean.class, order, 8, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfBooleanImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfBooleanImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfBooleanImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfBooleanImpl(order, bitAlignment(), name());\n+        }\n+\n+        public static OfBoolean of(ByteOrder order) {\n+            return new OfBooleanImpl(order);\n+        }\n+    }\n+\n+    public static final class OfByteImpl extends AbstractValueLayout<OfByteImpl> implements ValueLayout.OfByte {\n+\n+        private OfByteImpl(ByteOrder order) {\n+            super(byte.class, order, 8);\n+        }\n+\n+        private OfByteImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(byte.class, order, 8, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfByteImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfByteImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfByteImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfByteImpl(order, bitAlignment(), name());\n+        }\n+\n+        public static OfByte of(ByteOrder order) {\n+            return new OfByteImpl(order);\n+        }\n+    }\n+\n+    public static final class OfCharImpl extends AbstractValueLayout<OfCharImpl> implements ValueLayout.OfChar {\n+\n+        private OfCharImpl(ByteOrder order) {\n+            super(char.class, order, 16);\n+        }\n+\n+        private OfCharImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(char.class, order, 16, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfCharImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfCharImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfCharImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfCharImpl(order, bitAlignment(), name());\n+        }\n+\n+        public static OfChar of(ByteOrder order) {\n+            return new OfCharImpl(order);\n+        }\n+    }\n+\n+    public static final class OfShortImpl extends AbstractValueLayout<OfShortImpl> implements ValueLayout.OfShort {\n+\n+        private OfShortImpl(ByteOrder order) {\n+            super(short.class, order, 16);\n+        }\n+\n+        private OfShortImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(short.class, order, 16, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfShortImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfShortImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfShortImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfShortImpl(order, bitAlignment(), name());\n+        }\n+\n+        public static OfShort of(ByteOrder order) {\n+            return new OfShortImpl(order);\n+        }\n+    }\n+\n+    public static final class OfIntImpl extends AbstractValueLayout<OfIntImpl> implements ValueLayout.OfInt {\n+\n+        private OfIntImpl(ByteOrder order) {\n+            super(int.class, order, 32);\n+        }\n+\n+        private OfIntImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(int.class, order, 32, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfIntImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfIntImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfIntImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfIntImpl(order, bitAlignment(), name());\n+        }\n+\n+        public static OfInt of(ByteOrder order) {\n+            return new OfIntImpl(order);\n+        }\n+    }\n+\n+    public static final class OfFloatImpl extends AbstractValueLayout<OfFloatImpl> implements ValueLayout.OfFloat {\n+\n+        private OfFloatImpl(ByteOrder order) {\n+            super(float.class, order, 32);\n+        }\n+\n+        private OfFloatImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(float.class, order, 32, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfFloatImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfFloatImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfFloatImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfFloatImpl(order, bitAlignment(), name());\n+        }\n+\n+        public static OfFloat of(ByteOrder order) {\n+            return new OfFloatImpl(order);\n+        }\n+    }\n+\n+    public static final class OfLongImpl extends AbstractValueLayout<OfLongImpl> implements ValueLayout.OfLong {\n+\n+        private OfLongImpl(ByteOrder order) {\n+            super(long.class, order, 64);\n+        }\n+\n+        private OfLongImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(long.class, order, 64, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfLongImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfLongImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfLongImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfLongImpl(order, bitAlignment(), name());\n+        }\n+\n+        public static OfLong of(ByteOrder order) {\n+            return new OfLongImpl(order);\n+        }\n+    }\n+\n+    public static final class OfDoubleImpl extends AbstractValueLayout<OfDoubleImpl> implements ValueLayout.OfDouble {\n+\n+        private OfDoubleImpl(ByteOrder order) {\n+            super(double.class, order, 64);\n+        }\n+\n+        private OfDoubleImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(double.class, order, 64, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfDoubleImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfDoubleImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfDoubleImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfDoubleImpl(order, bitAlignment(), name());\n+        }\n+\n+        public static OfDouble of(ByteOrder order) {\n+            return new OfDoubleImpl(order);\n+        }\n+\n+    }\n+\n+    public static final class OfAddressImpl extends AbstractValueLayout<OfAddressImpl> implements ValueLayout.OfAddress {\n+\n+        private final boolean isUnbounded;\n+\n+        private OfAddressImpl(ByteOrder order) {\n+            super(MemorySegment.class, order, ADDRESS_SIZE_BITS);\n+            this.isUnbounded = false; \/\/ safe\n+        }\n+\n+        private OfAddressImpl(ByteOrder order, long size, long bitAlignment, boolean isUnbounded, Optional<String> name) {\n+            super(MemorySegment.class, order, size, bitAlignment, name);\n+            this.isUnbounded = isUnbounded;\n+        }\n+\n+        @Override\n+        OfAddressImpl dup(long alignment, Optional<String> name) {\n+            return new OfAddressImpl(order(), bitSize(), alignment, isUnbounded, name);\n+        }\n+\n+        @Override\n+        public OfAddressImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfAddressImpl(order, bitSize(), bitAlignment(), isUnbounded, name());\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            return super.equals(other) &&\n+                    ((OfAddressImpl) other).isUnbounded == this.isUnbounded;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), isUnbounded);\n+        }\n+\n+        @Override\n+        @CallerSensitive\n+        public OfAddress asUnbounded() {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), OfAddress.class, \"asUnbounded\");\n+            return new OfAddressImpl(order(), bitSize(), bitAlignment(), true, name());\n+        }\n+\n+        @Override\n+        public boolean isUnbounded() {\n+            return isUnbounded;\n+        }\n+\n+        public static OfAddress of(ByteOrder order) {\n+            return new OfAddressImpl(order);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"@@ -792,1 +792,1 @@\n-                JLA.addEnableNativeAccessAllUnnamed();\n+                JLA.addEnableNativeAccessToAllUnnamed();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,27 +118,1 @@\n-        boolean isNativeAccessEnabled = SharedSecrets.getJavaLangAccess().isEnableNativeAccess(module);\n-        if (!isNativeAccessEnabled) {\n-            synchronized(module) {\n-                isNativeAccessEnabled = SharedSecrets.getJavaLangAccess().isEnableNativeAccess(module);\n-                if (isNativeAccessEnabled) {\n-                    \/\/ some other thread got to it, do nothing\n-                } else if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n-                    throw new IllegalCallerException(\"Illegal native access from: \" + module);\n-                } else {\n-                    \/\/ warn and set flag, so that only one warning is reported per module\n-                    String cls = owner.getName();\n-                    String mtd = cls + \"::\" + methodName;\n-                    String mod = module.isNamed() ? \"module \" + module.getName() : \"the unnamed module\";\n-                    String modflag = module.isNamed() ? module.getName() : \"ALL-UNNAMED\";\n-                    System.err.printf(\"\"\"\n-                            WARNING: A restricted method in %s has been called\n-                            WARNING: %s has been called by %s\n-                            WARNING: Use --enable-native-access=%s to avoid a warning for this module\n-                            %n\"\"\", cls, mtd, mod, modflag);\n-                    if (module.isNamed()) {\n-                        SharedSecrets.getJavaLangAccess().addEnableNativeAccess(module);\n-                    } else {\n-                        SharedSecrets.getJavaLangAccess().addEnableNativeAccessAllUnnamed();\n-                    }\n-                }\n-            }\n-        }\n+        SharedSecrets.getJavaLangAccess().ensureNativeAccess(module, owner, methodName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    final static MethodHandle foo = abi.downcallHandle(lookup.lookup(\"foo\").get(),\n+    final static MethodHandle foo = abi.downcallHandle(lookup.find(\"foo\").get(),\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private static final Class<?> PREVIEW_API = java.lang.foreign.MemoryAddress.class;\n+    private static final Class<?> PREVIEW_API = java.lang.foreign.MemorySegment.class;\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            lookup.lookup(\"GetLastError\").orElseThrow(),\n+            lookup.find(\"GetLastError\").orElseThrow(),\n@@ -60,1 +60,1 @@\n-            lookup.lookup(\"SetLastError\").orElseThrow(),\n+            lookup.find(\"SetLastError\").orElseThrow(),\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbLastErrorTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,10 +25,1 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -394,1 +385,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1, MemorySession.openImplicit());\n+            MemorySegment segment = MemorySegment.allocateNative(1L, MemorySession.openImplicit());\n@@ -398,1 +389,1 @@\n-                        assertEquals(o, segment.address());\n+                        assertEquals(o, segment);\n@@ -404,1 +395,1 @@\n-            return segment.address();\n+            return segment;\n@@ -429,1 +420,1 @@\n-            if (l.isPadding()) continue;\n+            if (l instanceof PaddingLayout) continue;\n@@ -450,1 +441,1 @@\n-    static Class<?> carrier(MemoryLayout layout, boolean param) {\n+    static Class<?> carrier(MemoryLayout layout) {\n@@ -453,3 +444,1 @@\n-        } if (isPointer(layout)) {\n-            return param ? Addressable.class : MemoryAddress.class;\n-        } else if (layout instanceof ValueLayout valueLayout) {\n+        } if (layout instanceof ValueLayout valueLayout) {\n@@ -462,1 +451,1 @@\n-    MethodHandle downcallHandle(Linker abi, Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+    MethodHandle downcallHandle(Linker abi, MemorySegment symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -67,1 +66,1 @@\n-        Addressable addr;\n+        MemorySegment addr;\n@@ -74,1 +73,1 @@\n-    private static Addressable loadLibrary(MemorySession session) {\n+    private static MemorySegment loadLibrary(MemorySession session) {\n@@ -76,1 +75,1 @@\n-        MemorySegment addr = lib.lookup(\"inc\").get();\n+        MemorySegment addr = lib.find(\"inc\").get();\n@@ -81,1 +80,1 @@\n-    private static void callFunc(Addressable addr) {\n+    private static void callFunc(MemorySegment addr) {\n@@ -129,1 +128,1 @@\n-        Addressable addr = loadLibrary(session);\n+        MemorySegment addr = loadLibrary(session);\n@@ -149,1 +148,1 @@\n-        final Addressable addr;\n+        final MemorySegment addr;\n@@ -151,1 +150,1 @@\n-        LibraryAccess(Addressable addr) {\n+        LibraryAccess(MemorySegment addr) {\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng\/othervm MemoryLayoutPrincipalTotalityTest\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+public class MemoryLayoutPrincipalTotalityTest extends NativeTestHelper {\n+\n+    \/\/ The tests in this class is mostly there to ensure compile-time pattern matching totality.\n+\n+    @Test\n+    public void testBasicTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        int v0 = switch (memoryLayout) {\n+            case MemoryLayout ml -> 1;\n+        };\n+        assertEquals(v0, 1);\n+    }\n+\n+    @Test\n+    public void testMLRemovedTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        var v1 = switch (memoryLayout) {\n+            case GroupLayout gl -> 0;\n+            case PaddingLayout pl -> 0; \/\/ leaf\n+            case SequenceLayout sl -> 0; \/\/ leaf\n+            case ValueLayout vl -> 1;\n+        };\n+        assertEquals(v1, 1);\n+    }\n+\n+    @Test\n+    public void testMLGLRemovedTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        var v2 = switch (memoryLayout) {\n+            case PaddingLayout pl -> 0; \/\/ leaf\n+            case SequenceLayout sl -> 0; \/\/ leaf\n+            case ValueLayout vl -> 1;\n+            case StructLayout sl -> 0; \/\/ leaf\n+            case UnionLayout ul -> 0; \/\/ leaf\n+        };\n+        assertEquals(v2, 1);\n+    }\n+\n+    @Test\n+    public void testMLGLVLRemovedTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        var v3 = switch (memoryLayout) {\n+            case PaddingLayout pl -> 0; \/\/ leaf\n+            case SequenceLayout sl -> 0; \/\/ leaf\n+            case StructLayout sl -> 0; \/\/ leaf\n+            case UnionLayout ul -> 0; \/\/ leaf\n+            case OfAddress oa -> 0; \/\/ leaf\n+            case OfBoolean ob -> 0; \/\/ leaf\n+            case OfByte ob -> 0; \/\/ leaf\n+            case OfChar oc -> 0; \/\/ leaf\n+            case OfDouble od -> 0; \/\/ leaf\n+            case OfFloat of -> 0; \/\/ leaf\n+            case OfInt oi -> 1; \/\/ leaf\n+            case OfLong ol -> 0; \/\/ leaf\n+            case OfShort os -> 0; \/\/ leaf\n+        };\n+        assertEquals(v3, 1);\n+    }\n+\n+    @Test\n+    public void testMLVLRemovedTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        var v4 = switch (memoryLayout) {\n+            case GroupLayout gl -> 0;\n+            case PaddingLayout pl -> 0; \/\/ leaf\n+            case SequenceLayout sl -> 0; \/\/ leaf\n+            case OfAddress oa -> 0; \/\/ leaf\n+            case OfBoolean ob -> 0; \/\/ leaf\n+            case OfByte ob -> 0; \/\/ leaf\n+            case OfChar oc -> 0; \/\/ leaf\n+            case OfDouble od -> 0; \/\/ leaf\n+            case OfFloat of -> 0; \/\/ leaf\n+            case OfInt oi -> 1; \/\/ leaf\n+            case OfLong ol -> 0; \/\/ leaf\n+            case OfShort os -> 0; \/\/ leaf\n+        };\n+        assertEquals(v4, 1);\n+    }\n+\n+    private static MemoryLayout javaIntMemoryLayout() {\n+        return JAVA_INT;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng\/othervm MemoryLayoutTypeRetentionTest\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+public class MemoryLayoutTypeRetentionTest extends NativeTestHelper {\n+\n+    \/\/ These tests check both compile-time and runtime properties.\n+    \/\/ withName() et al. should return the same type as the original object.\n+\n+    private static final String NAME = \"a\";\n+    private static final long BIT_ALIGNMENT = 64;\n+    private static final ByteOrder BYTE_ORDER = ByteOrder.LITTLE_ENDIAN;\n+\n+    @Test\n+    public void testOfBoolean() {\n+        OfBoolean v = JAVA_BOOLEAN\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfByte() {\n+        OfByte v = JAVA_BYTE\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfShort() {\n+        OfShort v = JAVA_SHORT\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfInt() {\n+        OfInt v = JAVA_INT\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfChar() {\n+        OfChar v = JAVA_CHAR\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfLong() {\n+        OfLong v = JAVA_LONG\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfFloat() {\n+        OfFloat v = JAVA_FLOAT\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfDouble() {\n+        OfDouble v = JAVA_DOUBLE\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfAddress() {\n+        OfAddress v = ADDRESS\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+        assertFalse(v.isUnbounded());\n+        OfAddress v2 = v.asUnbounded();\n+        assertTrue(v2.isUnbounded());\n+    }\n+\n+    @Test\n+    public void testPaddingLayout() {\n+        PaddingLayout v = MemoryLayout.paddingLayout(8)\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testGroupLayout() {\n+        GroupLayout v = MemoryLayout.structLayout(JAVA_INT, JAVA_LONG)\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testStructLayout() {\n+        StructLayout v = MemoryLayout.structLayout(JAVA_INT, JAVA_LONG)\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testUnionLayout() {\n+        UnionLayout v = MemoryLayout.unionLayout(JAVA_INT, JAVA_LONG)\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME);\n+        check(v);\n+    }\n+\n+    public void check(ValueLayout v) {\n+        check((MemoryLayout) v);\n+        assertEquals(v.order(), BYTE_ORDER);\n+    }\n+\n+    public void check(MemoryLayout v) {\n+        assertEquals(v.name().orElseThrow(), NAME);\n+        assertEquals(v.bitAlignment(), BIT_ALIGNMENT);\n+        assertEquals(v.byteSize() * 8, v.bitSize());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -28,1 +27,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -30,0 +28,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -47,1 +48,1 @@\n-        return layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemoryAddress.class;\n+        return layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemorySegment.class;\n@@ -84,1 +85,1 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n@@ -86,1 +87,1 @@\n-    private static Linker LINKER = Linker.nativeLinker();\n+    private static final Linker LINKER = Linker.nativeLinker();\n@@ -89,1 +90,1 @@\n-            LINKER.defaultLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.defaultLookup().find(\"free\").get(), FunctionDescriptor.ofVoid(C_POINTER));\n@@ -92,1 +93,1 @@\n-            LINKER.defaultLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().find(\"malloc\").get(), FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n@@ -94,1 +95,1 @@\n-    public static void freeMemory(Addressable address) {\n+    public static void freeMemory(MemorySegment address) {\n@@ -102,1 +103,1 @@\n-    public static MemoryAddress allocateMemory(long size) {\n+    public static MemorySegment allocateMemory(long size) {\n@@ -104,1 +105,1 @@\n-            return (MemoryAddress)MALLOC.invokeExact(size);\n+            return (MemorySegment) MALLOC.invokeExact(size);\n@@ -110,2 +111,15 @@\n-    public static Addressable findNativeOrThrow(String name) {\n-        return SymbolLookup.loaderLookup().lookup(name).orElseThrow();\n+    public static MemorySegment findNativeOrThrow(String name) {\n+        return SymbolLookup.loaderLookup().find(name).orElseThrow();\n+    }\n+\n+    public static MethodHandle downcallHandle(String symbol, FunctionDescriptor desc) {\n+        return LINKER.downcallHandle(findNativeOrThrow(symbol), desc);\n+    }\n+\n+    public static MemorySegment upcallStub(Class<?> holder, String name, FunctionDescriptor descriptor) {\n+        try {\n+            MethodHandle target = MethodHandles.lookup().findStatic(holder, name, descriptor.toMethodType());\n+            return LINKER.upcallStub(target, descriptor, MemorySession.openImplicit());\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -36,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemoryLayout;\n@@ -60,1 +59,1 @@\n-            segment = MemorySegment.allocateNative(POINT, session);\n+            segment = session.allocate(POINT);\n@@ -77,6 +76,6 @@\n-                    MemorySegment.allocateNative(POINT, MemorySession.openShared()),\n-                    MemorySegment.allocateNative(POINT, MemorySession.openShared()),\n-                    MemorySegment.allocateNative(POINT, MemorySession.openShared()),\n-                    MemorySegment.allocateNative(POINT, MemorySession.openShared()),\n-                    MemorySegment.allocateNative(POINT, MemorySession.openShared()),\n-                    MemorySegment.allocateNative(POINT, MemorySession.openShared())\n+                    MemorySession.openShared().allocate(POINT),\n+                    MemorySession.openShared().allocate(POINT),\n+                    MemorySession.openShared().allocate(POINT),\n+                    MemorySession.openShared().allocate(POINT),\n+                    MemorySession.openShared().allocate(POINT),\n+                    MemorySession.openShared().allocate(POINT)\n@@ -113,1 +112,1 @@\n-        assertFalse(list.session().isAlive());\n+        assertFalse(list.segment().session().isAlive());\n@@ -118,1 +117,1 @@\n-        handle.invokeExact((Addressable)list);\n+        handle.invokeExact(list.segment());\n@@ -133,1 +132,1 @@\n-        handle.invokeExact((Addressable)upcall);\n+        handle.invokeExact(upcall);\n@@ -146,1 +145,1 @@\n-            handle.invoke(list, sessionChecker(session));\n+            handle.invokeExact(list.segment(), sessionChecker(session));\n@@ -157,2 +156,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(POINT, session);\n-            handle.invoke(segment, sessionChecker(session));\n+            MemorySegment segment = session.allocate(POINT);\n+            handle.invokeExact(segment, sessionChecker(session));\n@@ -171,1 +170,1 @@\n-            handle.invoke(upcall, sessionChecker(session));\n+            handle.invokeExact(upcall, sessionChecker(session));\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -155,3 +155,2 @@\n-        final static MethodHandle strcat = abi.downcallHandle(abi.defaultLookup().lookup(\"strcat\").get(),\n-                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER))\n-                .asType(MethodType.methodType(MemoryAddress.class, MemorySegment.class, MemorySegment.class)); \/\/ exact signature match\n+        final static MethodHandle strcat = abi.downcallHandle(abi.defaultLookup().find(\"strcat\").get(),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));\n@@ -159,2 +158,1 @@\n-\n-        final static MethodHandle strcmp = abi.downcallHandle(abi.defaultLookup().lookup(\"strcmp\").get(),\n+        final static MethodHandle strcmp = abi.downcallHandle(abi.defaultLookup().find(\"strcmp\").get(),\n@@ -163,1 +161,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(abi.defaultLookup().lookup(\"puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(abi.defaultLookup().find(\"puts\").get(),\n@@ -166,1 +164,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(abi.defaultLookup().lookup(\"strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n@@ -169,1 +167,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(abi.defaultLookup().lookup(\"gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(abi.defaultLookup().find(\"gmtime\").get(),\n@@ -172,1 +170,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(abi.defaultLookup().lookup(\"qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(abi.defaultLookup().find(\"qsort\").get(),\n@@ -179,1 +177,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(abi.defaultLookup().lookup(\"rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(abi.defaultLookup().find(\"rand\").get(),\n@@ -182,1 +180,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(abi.defaultLookup().lookup(\"vprintf\").get(),\n+        final static MethodHandle vprintf = abi.downcallHandle(abi.defaultLookup().find(\"vprintf\").get(),\n@@ -185,1 +183,1 @@\n-        final static Addressable printfAddr = abi.defaultLookup().lookup(\"printf\").get();\n+        final static MemorySegment printfAddr = abi.defaultLookup().find(\"printf\").get();\n@@ -193,1 +191,1 @@\n-                        Linker.upcallType(qsortComparFunction));\n+                        qsortComparFunction.toMethodType());\n@@ -200,1 +198,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -204,1 +202,1 @@\n-                return ((MemoryAddress)strcat.invokeExact(buf, other)).getUtf8String(0);\n+                return ((MemorySegment)strcat.invokeExact(buf, other)).getUtf8String(0);\n@@ -209,1 +207,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -212,1 +210,1 @@\n-                return (int)strcmp.invoke(ns1, ns2);\n+                return (int)strcmp.invokeExact(ns1, ns2);\n@@ -217,1 +215,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -219,1 +217,1 @@\n-                return (int)puts.invoke(s);\n+                return (int)puts.invokeExact(s);\n@@ -224,1 +222,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -226,1 +224,1 @@\n-                return (int)strlen.invoke(s);\n+                return (int)strlen.invokeExact(s);\n@@ -234,1 +232,1 @@\n-                return new Tm((MemoryAddress)gmtime.invoke(time));\n+                return new Tm((MemorySegment)gmtime.invokeExact(time));\n@@ -245,2 +243,2 @@\n-            Tm(MemoryAddress addr) {\n-                this.base = MemorySegment.ofAddress(addr, SIZE, MemorySession.global());\n+            Tm(MemorySegment addr) {\n+                this.base = addr.asSlice(0, SIZE);\n@@ -280,1 +278,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -284,1 +282,1 @@\n-                Addressable qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, session);\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, session);\n@@ -286,1 +284,1 @@\n-                qsort.invoke(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                qsort.invokeExact(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n@@ -293,1 +291,1 @@\n-        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+        static int qsortCompare(MemorySegment addr1, MemorySegment addr2) {\n@@ -303,1 +301,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -305,1 +303,1 @@\n-                return (int)specializedPrintf(args).invoke(formatStr,\n+                return (int)specializedPrintf(args).invokeExact(formatStr,\n@@ -311,1 +309,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -314,1 +312,1 @@\n-                return (int)vprintf.invoke(formatStr, vaList);\n+                return (int)vprintf.invokeExact(formatStr, vaList.segment());\n@@ -320,1 +318,1 @@\n-            MethodType mt = MethodType.methodType(int.class, MemoryAddress.class);\n+            MethodType mt = MethodType.methodType(int.class, MemorySegment.class);\n@@ -327,0 +325,1 @@\n+            Linker.Option varargIndex = Linker.Option.firstVariadicArg(fd.argumentLayouts().size());\n@@ -328,1 +327,2 @@\n-                    fd.asVariadic(variadicLayouts.toArray(new MemoryLayout[args.size()])));\n+                    fd.appendArgumentLayouts(variadicLayouts.toArray(new MemoryLayout[args.size()])),\n+                    varargIndex);\n@@ -390,4 +390,2 @@\n-        STRING(MemoryAddress.class, C_POINTER, \"%s\", session -> {\n-            var segment = MemorySegment.allocateNative(4, session);\n-            segment.setUtf8String(0, \"str\");\n-            return segment.address();\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", session -> {\n+            return session.allocateUtf8String(\"str\");\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, session);\n+            MemorySegment seg = session.allocate(ValueLayout.JAVA_INT);\n@@ -205,1 +205,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, session);\n+            MemorySegment seg = session.allocate(ValueLayout.JAVA_INT);\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -122,1 +121,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, seq.byteSize(), MemorySession.global());\n+        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), MemorySession.global());\n@@ -131,1 +130,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), session);\n+            MemorySegment segment = session.allocate(layout.byteSize() + 1, layout.byteSize());\n@@ -139,1 +138,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openConfined());\n+        MemorySegment segment = MemorySession.openConfined().allocate(layout);\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -190,1 +189,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(tuples, session);\n+            MemorySegment segment = session.allocate(tuples);\n@@ -365,1 +364,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, session);\n+            MemorySegment segment = session.allocate(bytes);\n@@ -391,1 +390,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, session);\n+            MemorySegment segment = session.allocate(bytes);\n@@ -425,1 +424,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, session);\n+            MemorySegment segment = session.allocate(bytes);\n@@ -429,1 +428,1 @@\n-            assertEquals(directBuffer.address(), segment.address().toRawLongValue());\n+            assertEquals(directBuffer.address(), segment.address());\n@@ -438,1 +437,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, session);\n+            MemorySegment segment = session.allocate(seq);\n@@ -476,1 +475,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, session);\n+            MemorySegment segment = session.allocate(seq);\n@@ -487,1 +486,1 @@\n-            leaked = MemorySegment.allocateNative(bytes, session);\n+            leaked = session.allocate(bytes);\n@@ -495,1 +494,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, MemorySession.openImplicit());\n+        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, MemorySession.openImplicit());\n@@ -589,1 +588,1 @@\n-            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, session);\n+            MemorySegment nativeArray = session.allocate(bytes, 1);\n@@ -602,1 +601,1 @@\n-            MemorySegment nativeArray = MemorySegment.allocateNative(seq, session);\n+            MemorySegment nativeArray = session.allocate(seq);\n@@ -674,1 +673,1 @@\n-            MemorySegment ms = MemorySegment.allocateNative(4, 1, session);\n+            MemorySegment ms = session.allocate(4, 1);\n@@ -683,1 +682,1 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, MemorySession.openConfined());\n+        MemorySegment s1 = MemorySession.openConfined().allocate(JAVA_INT);\n@@ -699,1 +698,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, session);\n+            MemorySegment segment = session.allocate(10, 1);\n@@ -719,1 +718,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, sessionSupplier.get());\n+            MemorySegment segment = sessionSupplier.get().allocate(10);\n@@ -737,1 +736,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(16, session);\n+            MemorySegment segment = session.allocate(16);\n@@ -755,1 +754,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(16, session);\n+            MemorySegment segment = session.allocate(16);\n@@ -765,2 +764,2 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, MemorySession.openImplicit()) },\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, MemorySession.openConfined()) },\n+                { (Supplier<MemorySegment>) () -> MemorySession.openImplicit().allocate(16) },\n+                { (Supplier<MemorySegment>) () -> MemorySession.openConfined().allocate(16) },\n@@ -774,2 +773,2 @@\n-                { (Supplier<MemorySession>) () -> MemorySession.openShared()   },\n-                { (Supplier<MemorySession>) () -> MemorySession.openConfined() },\n+                { (Supplier<MemorySession>) MemorySession::openShared},\n+                { (Supplier<MemorySession>) MemorySession::openConfined},\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        assertFalse(SymbolLookup.loaderLookup().lookup(\"f\").isEmpty());\n+        assertFalse(SymbolLookup.loaderLookup().find(\"f\").isEmpty());\n@@ -57,1 +57,1 @@\n-        assertTrue(SymbolLookup.loaderLookup().lookup(\"nonExistent\").isEmpty());\n+        assertTrue(SymbolLookup.loaderLookup().find(\"nonExistent\").isEmpty());\n@@ -63,1 +63,1 @@\n-                SymbolLookup.loaderLookup().lookup(\"c\").get().address(),\n+                SymbolLookup.loaderLookup().find(\"c\").get().address(),\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -28,0 +27,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -39,1 +39,1 @@\n-    Object doCall(Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+    Object doCall(MemorySegment symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/TestDowncallBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.foreign.Addressable;\n@@ -64,1 +63,1 @@\n-        Addressable addr = findNativeOrThrow(fName);\n+        MemorySegment addr = findNativeOrThrow(fName);\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.Addressable;\n@@ -60,1 +59,1 @@\n-        Addressable addr = findNativeOrThrow(\"s\" + fName);\n+        MemorySegment addr = findNativeOrThrow(\"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        assertTrue(Linker.nativeLinker().defaultLookup().lookup(\"nonExistentSymbol\").isEmpty());\n+        assertTrue(Linker.nativeLinker().defaultLookup().find(\"nonExistentSymbol\").isEmpty());\n","filename":"test\/jdk\/java\/foreign\/TestFallbackLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemoryLayout;\n@@ -36,1 +34,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -41,4 +38,0 @@\n-    private static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements) {\n-        return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), MemorySession.global());\n-    }\n-\n@@ -47,5 +40,4 @@\n-        MemoryAddress addr = allocateMemory(str.length() + 1);\n-        MemorySegment seg = asArray(addr, C_CHAR, str.length() + 1);\n-        seg.copyFrom(MemorySegment.ofArray(str.getBytes()));\n-        seg.set(C_CHAR, str.length(), (byte)0);\n-        assertEquals(str, seg.getUtf8String(0));\n+        MemorySegment addr = allocateMemory(str.length() + 1);\n+        addr.copyFrom(MemorySegment.ofArray(str.getBytes()));\n+        addr.set(C_CHAR, str.length(), (byte)0);\n+        assertEquals(str, addr.getUtf8String(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodType;\n@@ -101,2 +103,0 @@\n-        FunctionDescriptor fd_va1 = FunctionDescriptor.of(C_INT).asVariadic(C_INT, C_INT);\n-        FunctionDescriptor fd_va2 = FunctionDescriptor.of(C_INT, C_INT).asVariadic(C_INT);\n@@ -104,2 +104,19 @@\n-        assertNotEquals(fd, fd_va1);\n-        assertNotEquals(fd, fd_va2);\n+    }\n+\n+    @Test\n+    public void testCarrierMethodType() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n+                C_INT,\n+                MemoryLayout.structLayout(C_INT, C_INT));\n+        MethodType cmt = fd.toMethodType();\n+        assertEquals(cmt, MethodType.methodType(int.class, int.class, MemorySegment.class));\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadCarrierMethodType() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n+                C_INT,\n+                MemoryLayout.structLayout(C_INT, C_INT),\n+                MemoryLayout.sequenceLayout(3, C_INT),\n+                MemoryLayout.paddingLayout(32));\n+        fd.toMethodType(); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, session);\n+            MemorySegment segment = session.allocate(SEGMENT_SIZE, 1);\n@@ -196,1 +196,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.session());\n+            this.copy = segment.session().allocate(SEGMENT_SIZE, 1);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -127,1 +126,1 @@\n-            layouts.add(new Object[] { testCase.segment, testCase.align, MemoryAddress.ofLong(42), null, ADDRESS_ALIGNED, null });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, MemorySegment.ofAddress(42), null, ADDRESS_ALIGNED, null });\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.Addressable;\n@@ -35,1 +34,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -37,0 +36,2 @@\n+import java.nio.ByteOrder;\n+\n@@ -45,1 +46,1 @@\n-    private static final Addressable DUMMY_TARGET = MemoryAddress.ofLong(1);\n+    private static final MemorySegment DUMMY_TARGET = MemorySegment.ofAddress(1);\n@@ -54,1 +55,2 @@\n-            assertTrue(e.getMessage().contains(expectedExceptionMessage));\n+            assertTrue(e.getMessage().contains(expectedExceptionMessage),\n+                    e.getMessage() + \" != \" + expectedExceptionMessage);\n@@ -62,2 +64,2 @@\n-                FunctionDescriptor.of(MemoryLayout.paddingLayout(64)),\n-                \"Unsupported layout: x64\"\n+                    FunctionDescriptor.of(MemoryLayout.paddingLayout(64)),\n+                    \"Unsupported layout: x64\"\n@@ -66,2 +68,2 @@\n-                FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(64)),\n-                \"Unsupported layout: x64\"\n+                    FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(64)),\n+                    \"Unsupported layout: x64\"\n@@ -77,0 +79,36 @@\n+            {\n+                    FunctionDescriptor.ofVoid(C_INT.withBitAlignment(16)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(C_POINTER.withBitAlignment(16)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(32)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            C_CHAR.withName(\"x\").withBitAlignment(8),\n+                            C_SHORT.withName(\"y\").withBitAlignment(8),\n+                            C_INT.withName(\"z\").withBitAlignment(8)\n+                            ).withBitAlignment(8)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            MemoryLayout.structLayout(\n+                                C_CHAR.withName(\"x\").withBitAlignment(8),\n+                                C_SHORT.withName(\"y\").withBitAlignment(8),\n+                                C_INT.withName(\"z\").withBitAlignment(8)\n+                            ))),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            MemoryLayout.sequenceLayout(\n+                                C_INT.withBitAlignment(8)\n+                            ))),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":46,"deletions":8,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.Addressable;\n@@ -39,0 +38,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -40,1 +40,0 @@\n-import java.lang.invoke.MethodType;\n@@ -47,0 +46,1 @@\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n@@ -87,2 +87,1 @@\n-            Addressable ma = findNativeOrThrow(name);\n-            MethodType mt = methodType(carrier, carrier);\n+            MemorySegment ma = findNativeOrThrow(name);\n@@ -96,2 +95,1 @@\n-            Addressable ma = findNativeOrThrow(\"empty\");\n-            MethodType mt = methodType(void.class);\n+            MemorySegment ma = findNativeOrThrow(\"empty\");\n@@ -111,4 +109,4 @@\n-            Addressable ma = findNativeOrThrow(\"identity_va\");\n-            MethodType mt = methodType(int.class, int.class, double.class, int.class, float.class, long.class);\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT).asVariadic(C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n-            tests.add(abi.downcallHandle(ma, fd), 1, 1, 10D, 2, 3F, 4L);\n+            MemorySegment ma = findNativeOrThrow(\"identity_va\");\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT,\n+                                                                 C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3F, 4L);\n@@ -118,2 +116,0 @@\n-            MethodType baseMT = methodType(void.class, int.class, double.class, long.class, float.class, byte.class,\n-                    short.class, char.class);\n@@ -124,2 +120,1 @@\n-                Addressable ma = findNativeOrThrow(\"invoke_high_arity\" + i);\n-                MethodType mt = baseMT.changeReturnType(baseMT.parameterType(i));\n+                MemorySegment ma = findNativeOrThrow(\"invoke_high_arity\" + i);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @bug 8292851\n+ * @run testng\/othervm -Xmx4G TestLargeSegmentCopy\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static org.testng.Assert.*;\n+\n+public class TestLargeSegmentCopy {\n+\n+    @Test\n+    public void testLargeSegmentCopy() {\n+        \/\/ Make sure the byte size is bigger than Integer.MAX_VALUE\n+        final int longArrayLength = Integer.MAX_VALUE \/ Long.BYTES + 100;\n+        final long[] array = new long[longArrayLength];\n+\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate((long) longArrayLength * Long.BYTES, Long.SIZE);\n+            \/\/ Should not throw an exception or error\n+            MemorySegment.copy(segment, JAVA_LONG, 0, array, 0, longArrayLength);\n+            \/\/ Should not throw an exception or error\n+            MemorySegment.copy(array,0, segment, JAVA_LONG, 0, longArrayLength);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n@@ -42,9 +42,0 @@\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -57,1 +48,1 @@\n-        ValueLayout newLayout = valueLayoutForCarrier(layout.carrier());\n+        ValueLayout newLayout = MemoryLayout.valueLayout(layout.carrier(), layout.order());\n@@ -59,1 +50,3 @@\n-        newLayout = newLayout.withOrder(layout.order());\n+        if (layout instanceof ValueLayout.OfAddress addressLayout && addressLayout.isUnbounded()) {\n+            newLayout = ((ValueLayout.OfAddress)newLayout).asUnbounded();\n+        }\n@@ -87,24 +80,0 @@\n-\n-    static ValueLayout valueLayoutForCarrier(Class<?> carrier) {\n-        if (carrier == boolean.class) {\n-            return JAVA_BOOLEAN;\n-        } else if (carrier == char.class) {\n-            return JAVA_CHAR;\n-        } else if (carrier == byte.class) {\n-            return JAVA_BYTE;\n-        } else if (carrier == short.class) {\n-            return JAVA_SHORT;\n-        } else if (carrier == int.class) {\n-            return JAVA_INT;\n-        } else if (carrier == long.class) {\n-            return JAVA_LONG;\n-        } else if (carrier == float.class) {\n-            return JAVA_FLOAT;\n-        } else if (carrier == double.class) {\n-            return JAVA_DOUBLE;\n-        } else if (carrier == MemoryAddress.class) {\n-            return ADDRESS;\n-        } else {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":5,"deletions":36,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, session);\n+            MemorySegment segment = session.allocate(layout);\n@@ -439,1 +439,1 @@\n-            assertEquals(slice.address().toRawLongValue() - segment.address().toRawLongValue(), expectedBitOffset \/ 8);\n+            assertEquals(slice.address() - segment.address(), expectedBitOffset \/ 8);\n@@ -472,1 +472,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, session);\n+            MemorySegment segment = session.allocate(layout);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, session);\n+            MemorySegment segment = session.allocate(seq);\n@@ -141,1 +141,1 @@\n-        assertEquals(MemoryLayout.sequenceLayout(-1, layout),\n+        assertEquals(MemoryLayout.sequenceLayout(layout),\n@@ -145,0 +145,5 @@\n+    public void testSequenceNegativeElementCount() {\n+        assertThrows(IllegalArgumentException.class, \/\/ negative\n+                () -> MemoryLayout.sequenceLayout(-1, JAVA_SHORT));\n+    }\n+\n@@ -166,1 +171,1 @@\n-        assertEquals(kind == LayoutKind.PADDING, kind.layout.isPadding());\n+        assertEquals(kind == LayoutKind.PADDING, kind.layout instanceof PaddingLayout);\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLinker\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.testng.Assert.assertNotSame;\n+\n+public class TestLinker extends NativeTestHelper {\n+\n+    @Test\n+    public void testLinkerOptionsCache() {\n+        Linker linker = Linker.nativeLinker();\n+        FunctionDescriptor descriptor = FunctionDescriptor.ofVoid(C_INT, C_INT);\n+        MethodHandle mh1 = linker.downcallHandle(descriptor);\n+        MethodHandle mh2 = linker.downcallHandle(descriptor, Linker.Option.firstVariadicArg(1));\n+        \/\/ assert that these are 2 distinct link request. No caching allowed\n+        assertNotSame(mh1, mh2);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -96,1 +95,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, session));\n+            MemorySegment segment = viewFactory.apply(session.allocate(layout));\n@@ -128,1 +127,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, session));\n+            MemorySegment segment = viewFactory.apply(session.allocate(seq));\n@@ -197,1 +196,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, session));\n+            MemorySegment segment = viewFactory.apply(session.allocate(seq));\n@@ -468,2 +467,2 @@\n-            handle.set(segment, r, c, MemoryAddress.ofLong(r + c));\n-            assertEquals(MemoryAddress.ofLong(r + c), (MemoryAddress)handle.get(segment, r, c));\n+            handle.set(segment, r, c, MemorySegment.ofAddress(r + c));\n+            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, r, c));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -84,1 +83,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(128, session);\n+                MemorySegment segment = session.allocate(128);\n@@ -97,1 +96,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(64, session);\n+                MemorySegment segment = session.allocate(64);\n@@ -120,6 +119,0 @@\n-\n-        static <L extends ValueLayout, X> Accessor<MemoryAddress, X, L> ofAddress(L layout, X value,\n-                                                              SegmentGetter<MemoryAddress, X, L> segmentGetter, SegmentSetter<MemoryAddress, X, L> segmentSetter,\n-                                                              BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n-            return new Accessor<>(MemorySegment::address, layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n-        }\n@@ -133,5 +126,0 @@\n-    @Test(dataProvider = \"addressAccessors\")\n-    public void testAddressAccess(String testName, Accessor<?, ?, ?> accessor) {\n-        accessor.test();\n-    }\n-\n@@ -147,9 +135,0 @@\n-    @Test(dataProvider = \"addressAccessors\")\n-    public void testAddressAccessHyper(String testName, Accessor<?, ?, ?> accessor) {\n-        if (testName.contains(\"index\")) {\n-            accessor.testHyperAligned();\n-        } else {\n-            throw new SkipException(\"Skipping\");\n-        }\n-    }\n-\n@@ -190,1 +169,1 @@\n-                { \"address\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                { \"address\", Accessor.ofSegment(ValueLayout.ADDRESS, MemorySegment.ofAddress(42),\n@@ -196,1 +175,1 @@\n-                            return MemoryAddress.ofLong(addr);\n+                            return MemorySegment.ofAddress(addr);\n@@ -201,1 +180,1 @@\n-                                nb.putLong(pos, v.toRawLongValue());\n+                                nb.putLong(pos, v.address());\n@@ -203,1 +182,1 @@\n-                                nb.putInt(pos, (int)v.toRawLongValue());\n+                                nb.putInt(pos, (int)v.address());\n@@ -228,1 +207,1 @@\n-                { \"address\/index\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                { \"address\/index\", Accessor.ofSegment(ValueLayout.ADDRESS, MemorySegment.ofAddress(42),\n@@ -234,1 +213,1 @@\n-                            return MemoryAddress.ofLong(addr);\n+                            return MemorySegment.ofAddress(addr);\n@@ -239,1 +218,1 @@\n-                                nb.putLong(pos * 8, v.toRawLongValue());\n+                                nb.putLong(pos * 8, v.address());\n@@ -241,1 +220,1 @@\n-                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n+                                nb.putInt(pos * 4, (int)v.address());\n@@ -247,89 +226,0 @@\n-\n-    @DataProvider(name = \"addressAccessors\")\n-    static Object[][] addressAccessors() {\n-        return new Object[][]{\n-\n-                {\"byte\", Accessor.ofAddress(ValueLayout.JAVA_BYTE, (byte) 42,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        ByteBuffer::get, ByteBuffer::put)\n-                },\n-                {\"bool\", Accessor.ofAddress(ValueLayout.JAVA_BOOLEAN, false,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.get(pos) != 0, (bb, pos, v) -> bb.put(pos, v ? (byte)1 : (byte)0))\n-                },\n-                {\"char\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getChar(pos), (bb, pos, v) -> bb.order(NE).putChar(pos, v))\n-                },\n-                {\"int\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getInt(pos), (bb, pos, v) -> bb.order(NE).putInt(pos, v))\n-                },\n-                {\"float\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getFloat(pos), (bb, pos, v) -> bb.order(NE).putFloat(pos, v))\n-                },\n-                {\"long\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getLong(pos), (bb, pos, v) -> bb.order(NE).putLong(pos, v))\n-                },\n-                {\"double\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getDouble(pos), (bb, pos, v) -> bb.order(NE).putDouble(pos, v))\n-                },\n-                { \"address\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(pos) : nb.getInt(pos);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, pos, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(pos, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(pos, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-                {\"char\/index\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getChar(pos * 2), (bb, pos, v) -> bb.order(NE).putChar(pos * 2, v))\n-                },\n-                {\"int\/index\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getInt(pos * 4), (bb, pos, v) -> bb.order(NE).putInt(pos * 4, v))\n-                },\n-                {\"float\/index\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getFloat(pos * 4), (bb, pos, v) -> bb.order(NE).putFloat(pos * 4, v))\n-                },\n-                {\"long\/index\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getLong(pos * 8), (bb, pos, v) -> bb.order(NE).putLong(pos * 8, v))\n-                },\n-                {\"double\/index\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getDouble(pos * 8), (bb, pos, v) -> bb.order(NE).putDouble(pos * 8, v))\n-                },\n-                { \"address\/index\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(pos * 8) : nb.getInt(pos * 4);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, pos, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(pos * 8, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                }\n-        };\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":10,"deletions":120,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(aligned, session);\n+            MemorySegment segment = session.allocate(aligned);\n@@ -74,1 +74,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, session);\n+            MemorySegment segment = session.allocate(alignedGroup);\n@@ -101,1 +101,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(layout, session);\n+                MemorySegment segment = session.allocate(layout);\n@@ -125,1 +125,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(g, session);\n+            MemorySegment segment = session.allocate(g);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -39,8 +38,1 @@\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -101,8 +93,0 @@\n-    \/\/ unaligned constants\n-    public final static ValueLayout.OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n-    public final static ValueLayout.OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n-    public final static ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-    public final static ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-    public final static ValueLayout.OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n-    public final static ValueLayout.OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n-\n@@ -207,1 +191,1 @@\n-                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n+                { \"address\/offset\", new Accessor<>(MemorySegment.ofAddress(42),\n@@ -213,1 +197,1 @@\n-                            return MemoryAddress.ofLong(addr);\n+                            return MemorySegment.ofAddress(addr);\n@@ -218,1 +202,1 @@\n-                                nb.putLong(8, v.toRawLongValue());\n+                                nb.putLong(8, v.address());\n@@ -220,1 +204,1 @@\n-                                nb.putInt(8, (int)v.toRawLongValue());\n+                                nb.putInt(8, (int)v.address());\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -39,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -48,2 +48,0 @@\n-    final static VarHandle BYTE_HANDLE = ValueLayout.JAVA_BYTE.varHandle();\n-\n@@ -53,1 +51,1 @@\n-            BYTE_HANDLE.set(segment.asSlice(i), (byte)i);\n+            segment.set(ValueLayout.JAVA_BYTE, i, (byte)i);\n@@ -58,0 +56,30 @@\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeSrcFromOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, -1, 0, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstFromOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, -1, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeSrcToOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, -1, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstToOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, 0, -1);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeSrcLength(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 3, 2, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstLength(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, 3, 2);\n+    }\n+\n@@ -77,0 +105,20 @@\n+    @Test(dataProvider = \"slicesStatic\")\n+    public void testSameValuesStatic(SliceOffsetAndSize ss1, SliceOffsetAndSize ss2) {\n+        out.format(\"testSameValuesStatic s1:%s, s2:%s\\n\", ss1, ss2);\n+        MemorySegment s1 = initializeSegment(ss1.toSlice());\n+        MemorySegment s2 = initializeSegment(ss2.toSlice());\n+\n+        for (long i = ss2.offset ; i < ss2.size ; i++) {\n+            long bytes = i - ss2.offset;\n+            long expected = (bytes == ss1.size) ?\n+                    -1 : Long.min(ss1.size, bytes);\n+            assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss1.endOffset(), ss2.segment, ss2.offset, i), expected);\n+        }\n+        for (long i = ss1.offset ; i < ss1.size ; i++) {\n+            long bytes = i - ss1.offset;\n+            long expected = (bytes == ss2.size) ?\n+                    -1 : Long.min(ss2.size, bytes);\n+            assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss2.endOffset(), ss1.segment, ss1.offset, i), expected);\n+        }\n+    }\n+\n@@ -85,1 +133,1 @@\n-            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);\n+            s2.set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n@@ -102,0 +150,20 @@\n+    @Test(dataProvider = \"slicesStatic\")\n+    public void testDifferentValuesStatic(SliceOffsetAndSize ss1, SliceOffsetAndSize ss2) {\n+        out.format(\"testDifferentValues s1:%s, s2:%s\\n\", ss1, ss2);\n+\n+        for (long i = ss2.size - 1 ; i >= 0; i--) {\n+            if (i >= ss1.size) continue;\n+            initializeSegment(ss1.toSlice());\n+            initializeSegment(ss2.toSlice());\n+            long expectedMismatchOffset = i;\n+            ss2.toSlice().set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n+\n+            for (long j = expectedMismatchOffset + 1 ; j < ss2.size ; j++) {\n+                assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss1.endOffset(), ss2.segment, ss2.offset, j + ss2.offset), expectedMismatchOffset);\n+            }\n+            for (long j = expectedMismatchOffset + 1 ; j < ss1.size ; j++) {\n+                assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss2.endOffset(), ss1.segment, ss1.offset, j + ss1.offset), expectedMismatchOffset);\n+            }\n+        }\n+    }\n+\n@@ -107,1 +175,1 @@\n-            var nativeSegment = MemorySegment.allocateNative(4, 4, session);\n+            var nativeSegment = session.allocate(4, 4);\n@@ -119,2 +187,2 @@\n-                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, session);\n-                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, session);\n+                var s1 = session.allocate((long) Integer.MAX_VALUE + 10L, 8);\n+                var s2 = session.allocate((long) Integer.MAX_VALUE + 10L, 8);\n@@ -136,0 +204,1 @@\n+            \/\/ instance\n@@ -139,0 +208,4 @@\n+            \/\/ static\n+            assertEquals(MemorySegment.mismatch(s1, 0, s1.byteSize(), s1, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s2, 0, s1.byteSize(), s1, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s1, 0, s1.byteSize(), s2, 0, i), -1);\n@@ -144,1 +217,1 @@\n-            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);\n+            s2.set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n@@ -158,2 +231,2 @@\n-            s1 = MemorySegment.allocateNative(4, 1, session);\n-            s2 = MemorySegment.allocateNative(4, 1, session);\n+            s1 = session.allocate(4, 1);\n+            s2 = session.allocate(4, 1);\n@@ -169,1 +242,1 @@\n-            var segment = MemorySegment.allocateNative(4, 1, session);\n+            var segment = session.allocate(4, 1);\n@@ -224,2 +297,11 @@\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n+    record SliceOffsetAndSize(MemorySegment segment, long offset, long size) {\n+        MemorySegment toSlice() {\n+            return segment.asSlice(offset, size);\n+        }\n+        long endOffset() {\n+            return offset + size;\n+        }\n+    };\n+\n+    @DataProvider(name = \"slicesStatic\")\n+    static Object[][] slicesStatic() {\n@@ -227,3 +309,3 @@\n-        List<MemorySegment> aSlices = new ArrayList<>();\n-        List<MemorySegment> bSlices = new ArrayList<>();\n-        for (List<MemorySegment> slices : List.of(aSlices, bSlices)) {\n+        List<SliceOffsetAndSize> aSliceOffsetAndSizes = new ArrayList<>();\n+        List<SliceOffsetAndSize> bSliceOffsetAndSizes = new ArrayList<>();\n+        for (List<SliceOffsetAndSize> slices : List.of(aSliceOffsetAndSizes, bSliceOffsetAndSizes)) {\n@@ -235,2 +317,1 @@\n-                        MemorySegment slice = segment.asSlice(index, size);\n-                        slices.add(slice);\n+                        slices.add(new SliceOffsetAndSize(segment, index, size));\n@@ -241,5 +322,5 @@\n-        assert aSlices.size() == bSlices.size();\n-        Object[][] sliceArray = new Object[aSlices.size() * bSlices.size()][];\n-        for (int i = 0 ; i < aSlices.size() ; i++) {\n-            for (int j = 0 ; j < bSlices.size() ; j++) {\n-                sliceArray[i * aSlices.size() + j] = new Object[] { aSlices.get(i), bSlices.get(j) };\n+        assert aSliceOffsetAndSizes.size() == bSliceOffsetAndSizes.size();\n+        Object[][] sliceArray = new Object[aSliceOffsetAndSizes.size() * bSliceOffsetAndSizes.size()][];\n+        for (int i = 0 ; i < aSliceOffsetAndSizes.size() ; i++) {\n+            for (int j = 0 ; j < bSliceOffsetAndSizes.size() ; j++) {\n+                sliceArray[i * aSliceOffsetAndSizes.size() + j] = new Object[] { aSliceOffsetAndSizes.get(i), bSliceOffsetAndSizes.get(j) };\n@@ -250,0 +331,10 @@\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] slices() {\n+        Object[][] slicesStatic = slicesStatic();\n+        return Stream.of(slicesStatic)\n+                .map(arr -> new Object[]{\n+                        ((SliceOffsetAndSize) arr[0]).toSlice(),\n+                        ((SliceOffsetAndSize) arr[1]).toSlice()\n+                }).toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":115,"deletions":24,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.Addressable;\n@@ -38,1 +37,3 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n@@ -41,0 +42,2 @@\n+import static org.testng.Assert.*;\n+\n@@ -43,0 +46,4 @@\n+    static {\n+        System.loadLibrary(\"Null\");\n+    }\n+\n@@ -48,1 +55,1 @@\n-                MemoryAddress.NULL,\n+                MemorySegment.NULL,\n@@ -56,1 +63,1 @@\n-        mh.invokeExact((Addressable)MemoryAddress.NULL);\n+        mh.invokeExact(MemorySegment.NULL);\n@@ -59,3 +66,6 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testNULLgetString() {\n-        MemoryAddress.NULL.getUtf8String(0);\n+    @Test\n+    public void testNULLReturn_unbounded() throws Throwable {\n+        MethodHandle mh = LINKER.downcallHandle(SymbolLookup.loaderLookup().find(\"get_null\").get(),\n+                FunctionDescriptor.of(ValueLayout.ADDRESS.asUnbounded()));\n+        MemorySegment ret = (MemorySegment)mh.invokeExact();\n+        assertTrue(ret.equals(MemorySegment.NULL));\n@@ -64,3 +74,6 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testNULLsetString() {\n-        MemoryAddress.NULL.setUtf8String(0, \"hello\");\n+    @Test\n+    public void testNULLReturn_plain() throws Throwable {\n+        MethodHandle mh = LINKER.downcallHandle(SymbolLookup.loaderLookup().find(\"get_null\").get(),\n+                FunctionDescriptor.of(ValueLayout.ADDRESS));\n+        MemorySegment ret = (MemorySegment)mh.invokeExact();\n+        assertTrue(ret.equals(MemorySegment.NULL));\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n@@ -35,2 +36,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n@@ -115,1 +114,1 @@\n-            Object rawValue = nativeRawExtractor.apply(base.address().toRawLongValue(), (int)i);\n+            Object rawValue = nativeRawExtractor.apply(base.address(), (int)i);\n@@ -149,1 +148,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, session);\n+            MemorySegment segment = session.allocate(seq);\n@@ -159,1 +158,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(doubles, session);\n+            MemorySegment segment = session.allocate(doubles);\n@@ -170,1 +169,1 @@\n-        MemoryAddress addr = allocateMemory(12);\n+        MemorySegment addr = allocateMemory(12);\n@@ -173,1 +172,1 @@\n-            MemorySegment mallocSegment = MemorySegment.ofAddress(addr, 12, session);\n+            MemorySegment mallocSegment = MemorySegment.ofAddress(addr.address(), 12, session);\n@@ -180,1 +179,1 @@\n-        MemoryAddress addr = allocateMemory(12);\n+        MemorySegment addr = allocateMemory(12);\n@@ -184,1 +183,1 @@\n-            mallocSegment = MemorySegment.ofAddress(addr, 12, session);\n+            mallocSegment = MemorySegment.ofAddress(addr.address(), 12, session);\n@@ -193,1 +192,1 @@\n-        MemoryAddress addr = allocateMemory(4);\n+        MemorySegment addr = allocateMemory(4);\n@@ -202,1 +201,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(4, 1, session);\n+            MemorySegment segment = session.allocate(4, 1);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-            MemoryAddress.class,\n@@ -98,1 +97,0 @@\n-            Addressable.class,\n@@ -165,2 +163,0 @@\n-        addDefaultMapping(MemoryAddress.class, MemoryAddress.ofLong(1));\n-        addDefaultMapping(Addressable.class, MemoryAddress.ofLong(1));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.CharBuffer;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8294621\n+ * @summary test that StringCharBuffer is not accepted by MemorySegment::ofBuffer\n+ * @enablePreview\n+ * @run testng TestOfBufferIssue\n+ *\/\n+\n+public class TestOfBufferIssue {\n+\n+    @Test\n+    public void ensure8294621Fixed() {\n+        try {\n+            final CharBuffer cb = CharBuffer.wrap(\"Hello\");\n+            MemorySegment src2 = MemorySegment.ofBuffer(cb);\n+            fail(\"A StringCharBuffer is not allowed as an argument.\");\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ Ignored. Happy path\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestOfBufferIssue.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -115,1 +114,1 @@\n-        ScopedOperation.ofScope(session -> MemorySegment.allocateNative(100, session), \"MemorySegment::allocateNative\");\n+        ScopedOperation.ofScope(session -> session.allocate(100), \"MemorySession::allocate\");\n@@ -124,1 +123,1 @@\n-        ScopedOperation.ofScope(session -> VaList.ofAddress(MemoryAddress.ofLong(42), session), \"VaList::make\");\n+        ScopedOperation.ofScope(session -> VaList.ofAddress(42, session), \"VaList::make\");\n@@ -128,1 +127,0 @@\n-        ScopedOperation.ofSegment(MemorySegment::address, \"MemorySegment::address\");\n@@ -133,1 +131,0 @@\n-        ScopedOperation.ofVaList(VaList::address, \"VaList::address\");\n@@ -223,1 +220,1 @@\n-            NATIVE(session -> MemorySegment.allocateNative(10, session)),\n+            NATIVE(session -> session.allocate(10)),\n@@ -231,1 +228,1 @@\n-            UNSAFE(session -> MemorySegment.ofAddress(MemoryAddress.NULL, 10, session));\n+            UNSAFE(session -> MemorySegment.ofAddress(0, 10, session));\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-                assertEquals(address.address().toRawLongValue() % i, 0);\n+                assertEquals(address.address() % i, 0);\n@@ -179,1 +179,1 @@\n-            public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            public MemorySegment allocate(long bytesSize, long byteAlignment) {\n@@ -204,2 +204,3 @@\n-            public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-                return MemorySegment.allocateNative(bytesSize, bytesAlignment, MemorySession.openImplicit());\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return MemorySegment.allocateNative(byteSize, byteAlignment, MemorySession.openImplicit());\n@@ -262,1 +263,1 @@\n-            scalarAllocations.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { MemorySegment.ofAddress(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -285,1 +286,1 @@\n-            scalarAllocations.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { MemorySegment.ofAddress(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -353,1 +354,1 @@\n-        interface OfAddress extends AllocationFunction<MemoryAddress, ValueLayout.OfAddress> { }\n+        interface OfAddress extends AllocationFunction<MemorySegment, ValueLayout.OfAddress> { }\n@@ -495,28 +496,0 @@\n-\n-        ToArrayHelper<MemoryAddress[]> toAddressArray = new ToArrayHelper<>() {\n-            @Override\n-            public MemoryAddress[] array() {\n-                return switch ((int) ValueLayout.ADDRESS.byteSize()) {\n-                    case 4 -> wrap(toIntArray.array());\n-                    case 8 -> wrap(toLongArray.array());\n-                    default -> throw new IllegalStateException(\"Cannot get here\");\n-                };\n-            }\n-\n-            @Override\n-            public MemoryAddress[] toArray(MemorySegment segment, ValueLayout layout) {\n-                return switch ((int)layout.byteSize()) {\n-                    case 4 -> wrap(toIntArray.toArray(segment, layout));\n-                    case 8 -> wrap(toLongArray.toArray(segment, layout));\n-                    default -> throw new IllegalStateException(\"Cannot get here\");\n-                };\n-            }\n-\n-            private MemoryAddress[] wrap(int[] ints) {\n-                return IntStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n-            }\n-\n-            private MemoryAddress[] wrap(long[] ints) {\n-                return LongStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n-            }\n-        };\n@@ -530,1 +503,1 @@\n-                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, MemorySession.global())) },\n+                { SegmentAllocator.prefixAllocator(MemorySession.global().allocate(10)) },\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":9,"deletions":36,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.openConfined())),\n+            NATIVE(i -> MemorySession.openConfined().allocate(i)),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                () -> MemorySegment.allocateNative(16, MemorySession.openConfined()),\n+                () -> MemorySession.openConfined().allocate(16),\n@@ -126,1 +126,1 @@\n-                assertEquals(s1.asOverlappingSlice(slice).get().address(), s1.address().addOffset(offset));\n+                assertEquals(s1.asOverlappingSlice(slice).get().address(), s1.address() + offset);\n@@ -134,1 +134,1 @@\n-        NATIVE(() -> MemorySegment.allocateNative(16, MemorySession.openConfined())),\n+        NATIVE(() -> MemorySession.openConfined().allocate(16)),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            var segment = MemorySegment.allocateNative(0, session);\n+            var segment = session.allocate(0);\n@@ -62,1 +62,1 @@\n-            segment = MemorySegment.allocateNative(seq, session);\n+            segment = session.allocate(seq);\n@@ -64,2 +64,2 @@\n-            assertEquals(segment.address().toRawLongValue() % seq.byteAlignment(), 0);\n-            segment = MemorySegment.allocateNative(0, 4, session);\n+            assertEquals(segment.address() % seq.byteAlignment(), 0);\n+            segment = session.allocate(0, 4);\n@@ -67,4 +67,4 @@\n-            assertEquals(segment.address().toRawLongValue() % 4, 0);\n-            segment = MemorySegment.ofAddress(segment.address(), 0, session);\n-            assertEquals(segment.byteSize(), 0);\n-            assertEquals(segment.address().toRawLongValue() % 4, 0);\n+            assertEquals(segment.address() % 4, 0);\n+            MemorySegment rawAddress = MemorySegment.ofAddress(segment.address(), 0, session);\n+            assertEquals(rawAddress.byteSize(), 0);\n+            assertEquals(rawAddress.address() % 4, 0);\n@@ -82,1 +82,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, MemorySession.openImplicit()); \/\/ 2M\n+        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, MemorySession.openImplicit()); \/\/ 2M\n@@ -89,1 +89,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1000, 1, session);\n+            MemorySegment segment = session.allocate(1000, 1);\n@@ -100,1 +100,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, session);\n+            MemorySegment segment = session.allocate(10, 1);\n@@ -120,1 +120,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(100, session);\n+            MemorySegment segment = session.allocate(100);\n@@ -124,4 +124,3 @@\n-            assertNotEquals(segment, segment.asSlice(0, 90));\n-            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, session.asNonCloseable()));\n-            assertNotEquals(segment, MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()));\n-            MemorySegment segment2 = MemorySegment.allocateNative(100, session);\n+            assertEquals(segment, segment.asSlice(0, 90));\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()));\n+            MemorySegment segment2 = session.allocate(100);\n@@ -138,1 +137,1 @@\n-        assertNotEquals(segment, segment.asSlice(0, 90));\n+        assertEquals(segment, segment.asSlice(0, 90));\n@@ -143,0 +142,19 @@\n+    @Test\n+    public void testHashCodeOffHeap() {\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = session.allocate(100);\n+            assertEquals(segment.hashCode(), segment.asReadOnly().hashCode());\n+            assertEquals(segment.hashCode(), segment.asSlice(0, 100).hashCode());\n+            assertEquals(segment.hashCode(), segment.asSlice(0, 90).hashCode());\n+            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()).hashCode());\n+        }\n+    }\n+\n+    @Test\n+    public void testHashCodeOnHeap() {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[100]);\n+        assertEquals(segment.hashCode(), segment.asReadOnly().hashCode());\n+        assertEquals(segment.hashCode(), segment.asSlice(0, 100).hashCode());\n+        assertEquals(segment.hashCode(), segment.asSlice(0, 90).hashCode());\n+    }\n+\n@@ -145,1 +163,1 @@\n-        long offset = (long)Integer.MAX_VALUE + (long)Integer.MAX_VALUE + 2L + 6L; \/\/ overflows to 6 when casted to int\n+        long offset = (long)Integer.MAX_VALUE + (long)Integer.MAX_VALUE + 2L + 6L; \/\/ overflows to 6 when cast to int\n@@ -152,2 +170,2 @@\n-        long offset = ((long)Integer.MIN_VALUE * 2L) + 6L; \/\/ underflows to 6 when casted to int\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, MemorySession.openImplicit());\n+        long offset = ((long)Integer.MIN_VALUE * 2L) + 6L; \/\/ underflows to 6 when cast to int\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10L, MemorySession.openImplicit());\n@@ -160,1 +178,1 @@\n-            var segment = MemorySegment.allocateNative(10, MemorySession.global());\n+            var segment = MemorySession.global().allocate(10);\n@@ -192,2 +210,2 @@\n-                () -> MemorySegment.allocateNative(4, MemorySession.openImplicit()),\n-                () -> MemorySegment.allocateNative(4, 8, MemorySession.openImplicit()),\n+                () -> MemorySegment.allocateNative(4L, MemorySession.openImplicit()),\n+                () -> MemorySegment.allocateNative(4L, 8, MemorySession.openImplicit()),\n@@ -195,2 +213,2 @@\n-                () -> MemorySegment.allocateNative(4, MemorySession.openImplicit()),\n-                () -> MemorySegment.allocateNative(4, 8, MemorySession.openImplicit()),\n+                () -> MemorySegment.allocateNative(4L, MemorySession.openImplicit()),\n+                () -> MemorySegment.allocateNative(4L, 8, MemorySession.openImplicit()),\n@@ -274,6 +292,1 @@\n-        try {\n-            segment.address();\n-            assertTrue(segment.isNative());\n-        } catch (UnsupportedOperationException exception) {\n-            assertFalse(segment.isNative());\n-        }\n+        assertEquals(segment.isNative(), !segment.array().isPresent());\n@@ -324,4 +337,5 @@\n-    public void testBigHeapSegments(IntFunction<MemorySegment> heapSegmentFactory, int factor) {\n-        int bigSize = (Integer.MAX_VALUE \/ factor) + 1;\n-        MemorySegment segment = heapSegmentFactory.apply(bigSize);\n-        assertTrue(segment.byteSize() > 0);\n+    public void testVirtualizedBaseAddress(IntFunction<MemorySegment> heapSegmentFactory, int factor) {\n+        MemorySegment segment = heapSegmentFactory.apply(10);\n+        assertEquals(segment.address(), 0); \/\/ base address should be zero (no leaking of impl details)\n+        MemorySegment end = segment.asSlice(segment.byteSize(), 0);\n+        assertEquals(end.address(), segment.byteSize()); \/\/ end address should be equal to segment byte size\n@@ -354,0 +368,1 @@\n+                { (IntFunction<MemorySegment>) size -> MemorySegment.ofArray(new byte[size]), 1 },\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":50,"deletions":35,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(layout, session);\n+            MemorySegment s = session.allocate(layout);\n@@ -97,1 +97,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(4, 1, session);\n+            MemorySegment s = session.allocate(4, 1);\n@@ -124,1 +124,1 @@\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), session);\n+            MemorySegment s1 = session.allocate(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT));\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, session);\n+            MemorySegment segment = session.allocate(LAYOUT);\n@@ -65,1 +65,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, session);\n+            MemorySegment segment = session.allocate(LAYOUT);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, session);\n+            MemorySegment segment = session.allocate(layout);\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, session);\n-            String address = (String)ADDR_HANDLE.get(s.address());\n+            MemorySegment s = session.allocate(8, 8);\n+            String address = (String)ADDR_HANDLE.get(s);\n@@ -65,2 +65,2 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, session);\n-            ADDR_HANDLE.set(s.address(), \"string\");\n+            MemorySegment s = session.allocate(8, 8);\n+            ADDR_HANDLE.set(s, \"string\");\n@@ -73,2 +73,2 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, session);\n-            int address = (int)ADDR_HANDLE.get(s.address());\n+            MemorySegment s = session.allocate(8, 8);\n+            int address = (int)ADDR_HANDLE.get(s);\n@@ -81,2 +81,2 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, session);\n-            ADDR_HANDLE.set(s.address(), 1);\n+            MemorySegment s = session.allocate(8, 8);\n+            ADDR_HANDLE.set(s, 1);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -58,1 +57,1 @@\n-        VaList.ofAddress(MemoryAddress.NULL, MemorySession.openImplicit());\n+        VaList.ofAddress(0L, MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.Linker;\n@@ -39,0 +37,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -64,1 +63,1 @@\n-        Addressable addr = findNativeOrThrow(fName);\n+        MemorySegment addr = findNativeOrThrow(fName);\n@@ -76,1 +75,1 @@\n-            Addressable callback = ABI.upcallStub(mh.asType(Linker.upcallType(callbackDesc)), callbackDesc, session);\n+            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, session);\n@@ -80,2 +79,3 @@\n-            Object res = invoker.type().returnType() == MemorySegment.class\n-                    ? invoker.invoke(allocator, callback)\n+            Object res = (descriptor.returnLayout().isPresent() &&\n+                         descriptor.returnLayout().get() instanceof GroupLayout)\n+                    ? invoker.invoke(session, callback)\n@@ -105,1 +105,1 @@\n-            Addressable invokerSymbol = findNativeOrThrow(symbol);\n+            MemorySegment invokerSymbol = findNativeOrThrow(symbol);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.GroupLayout;\n@@ -37,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -57,1 +58,1 @@\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class, List.class));\n@@ -63,1 +64,1 @@\n-    private static Addressable DUMMY_STUB;\n+    private static MemorySegment DUMMY_STUB;\n@@ -100,1 +101,1 @@\n-    static Addressable makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+    static MemorySegment makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -106,1 +107,6 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n+        List<MemoryLayout> layouts = new ArrayList<>();\n+        layouts.addAll(prefix);\n+        for (int i = 0 ; i < params.size() ; i++) {\n+            layouts.add(params.get(i).layout(fields));\n+        }\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size(), layouts);\n@@ -110,1 +116,1 @@\n-            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n+            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i))));\n@@ -116,1 +122,1 @@\n-            Class<?> carrier = carrier(layout, false);\n+            Class<?> carrier = carrier(layout);\n@@ -120,1 +126,1 @@\n-            if (carrier == MemorySegment.class) {\n+            if (layout instanceof GroupLayout) {\n@@ -129,3 +135,2 @@\n-        Class<?> firstCarrier = carrier(firstlayout, true);\n-\n-        if (firstCarrier == MemorySegment.class) {\n+        Class<?> firstCarrier = carrier(firstlayout);\n+        if (firstlayout instanceof GroupLayout) {\n@@ -146,1 +151,1 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg, List<MemoryLayout> layouts) {\n@@ -148,1 +153,1 @@\n-            if (o[i] instanceof MemorySegment) {\n+            if (layouts.get(i) instanceof GroupLayout) {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.test.lib.Utils;\n+import org.testng.annotations.DataProvider;\n@@ -39,1 +39,0 @@\n-import java.io.BufferedReader;\n@@ -41,4 +40,0 @@\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.nio.file.Paths;\n-import java.util.List;\n@@ -46,3 +41,1 @@\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNotEquals;\n-import static org.testng.Assert.assertTrue;\n+public class TestUpcallException extends UpcallTestHelper {\n@@ -50,46 +43,4 @@\n-public class TestUpcallException {\n-\n-    @Test\n-    public void testExceptionInterpreted() throws InterruptedException, IOException {\n-        run(\/* useSpec = *\/ false, \/* isVoid = *\/ true);\n-        run(\/* useSpec = *\/ false, \/* isVoid = *\/ false);\n-    }\n-\n-    @Test\n-    public void testExceptionSpecialized() throws IOException, InterruptedException {\n-        run(\/* useSpec = *\/ true, \/* isVoid = *\/ true);\n-        run(\/* useSpec = *\/ true, \/* isVoid = *\/ false);\n-    }\n-\n-    private void run(boolean useSpec, boolean isVoid) throws IOException, InterruptedException {\n-        Process process = new ProcessBuilder()\n-            .command(\n-                Paths.get(Utils.TEST_JDK)\n-                     .resolve(\"bin\")\n-                     .resolve(\"java\")\n-                     .toAbsolutePath()\n-                     .toString(),\n-                \"--enable-preview\",\n-                \"--enable-native-access=ALL-UNNAMED\",\n-                \"-Djava.library.path=\" + System.getProperty(\"java.library.path\"),\n-                \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n-                \"-cp\", Utils.TEST_CLASS_PATH,\n-                \"ThrowingUpcall\",\n-                isVoid ? \"void\" : \"non-void\")\n-            .start();\n-\n-        int result = process.waitFor();\n-        assertNotEquals(result, 0);\n-\n-        List<String> outLines = linesFromStream(process.getInputStream());\n-        outLines.forEach(System.out::println);\n-        List<String> errLines = linesFromStream(process.getErrorStream());\n-        errLines.forEach(System.err::println);\n-\n-        \/\/ Exception message would be found in stack trace\n-        String shouldInclude = \"Testing upcall exceptions\";\n-        assertTrue(linesContain(errLines, shouldInclude), \"Did not find '\" + shouldInclude + \"' in stderr\");\n-    }\n-\n-    private boolean linesContain(List<String> errLines, String shouldInclude) {\n-        return errLines.stream().anyMatch(line -> line.contains(shouldInclude));\n+    @Test(dataProvider = \"cases\")\n+    public void testException(boolean useSpec, boolean isVoid) throws InterruptedException, IOException {\n+        runInNewProcess(ThrowingUpcall.class, useSpec, isVoid ? \"void\" : \"\")\n+                .assertStdErrContains(\"Testing upcall exceptions\");\n@@ -98,4 +49,8 @@\n-    private static List<String> linesFromStream(InputStream stream) throws IOException {\n-        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\n-            return reader.lines().toList();\n-        }\n+    @DataProvider\n+    public static Object[][] cases() {\n+        return new Object[][]{\n+            { false, true,  },\n+            { false, false, },\n+            { true,  true,  },\n+            { true,  false, }\n+        };\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":14,"deletions":59,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.Linker;\n@@ -39,1 +37,2 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.Linker;\n@@ -43,0 +42,1 @@\n+\n@@ -79,1 +79,1 @@\n-                    MethodType.methodType(void.class, Object[].class, AtomicReference.class));\n+                    MethodType.methodType(void.class, Object[].class, AtomicReference.class, List.class));\n@@ -85,1 +85,1 @@\n-    static void passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static void passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemoryLayout> layouts) {\n@@ -87,1 +87,1 @@\n-            if (o[i] instanceof MemorySegment) {\n+            if (layouts.get(i) instanceof GroupLayout) {\n@@ -101,1 +101,1 @@\n-        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs)\n+        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs, upcallDescriptor.argumentLayouts())\n@@ -105,1 +105,1 @@\n-            Addressable upcallStub = LINKER.upcallStub(target, upcallDescriptor, session);\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, session);\n@@ -117,1 +117,1 @@\n-                if (upcallType.parameterType(i) == MemorySegment.class) {\n+                if (upcallDescriptor.argumentLayouts().get(i) instanceof GroupLayout) {\n@@ -131,4 +131,4 @@\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class),\n+                    MemorySegment.class, int.class, double.class, MemorySegment.class,\n+                    MemorySegment.class, int.class, double.class, MemorySegment.class,\n+                    MemorySegment.class, int.class, double.class, MemorySegment.class,\n+                    MemorySegment.class, int.class, double.class, MemorySegment.class),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -55,1 +55,1 @@\n-        Addressable addr = findNativeOrThrow(fName);\n+        MemorySegment addr = findNativeOrThrow(fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.Addressable;\n@@ -37,0 +36,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -56,1 +56,1 @@\n-        Addressable addr = findNativeOrThrow(\"s\" + fName);\n+        MemorySegment addr = findNativeOrThrow(\"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -45,1 +45,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -93,2 +93,2 @@\n-            Addressable upcallStub = LINKER.upcallStub(target, upcallDesc, session);\n-            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, session);\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, session);\n+            MemorySegment argSegment = session.allocate(S_PDI_LAYOUT);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ * @run testng TestValueLayouts\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import jdk.internal.misc.Unsafe;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+public class TestValueLayouts {\n+\n+    @Test\n+    public void testByte() {\n+        testAligned(JAVA_BYTE, byte.class, Byte.SIZE);\n+    }\n+\n+    @Test\n+    public void testBoolean() {\n+        testAligned(JAVA_BOOLEAN, boolean.class, Byte.SIZE);\n+    }\n+\n+    @Test\n+    public void testShort() {\n+        testAligned(JAVA_SHORT, short.class, Short.SIZE);\n+    }\n+\n+    @Test\n+    public void testShortUnaligned() {\n+        testUnaligned(JAVA_SHORT_UNALIGNED, short.class, Short.SIZE);\n+    }\n+\n+    @Test\n+    public void testInt() {\n+        testAligned(JAVA_INT, int.class, Integer.SIZE);\n+    }\n+\n+    @Test\n+    public void testIntUnaligned() {\n+        testUnaligned(JAVA_INT_UNALIGNED, int.class, Integer.SIZE);\n+    }\n+\n+    @Test\n+    public void testLong() {\n+        testAligned(JAVA_LONG, long.class, Long.SIZE);\n+    }\n+\n+    @Test\n+    public void testLongUnaligned() {\n+        testUnaligned(JAVA_LONG_UNALIGNED, long.class, Long.SIZE);\n+    }\n+\n+    @Test\n+    public void testFloat() {\n+        testAligned(JAVA_FLOAT, float.class, Float.SIZE);\n+    }\n+\n+    @Test\n+    public void testFloatUnaligned() {\n+        testUnaligned(JAVA_FLOAT_UNALIGNED, float.class, Float.SIZE);\n+    }\n+\n+    @Test\n+    public void testDouble() {\n+        testAligned(JAVA_DOUBLE, double.class, Double.SIZE);\n+    }\n+\n+    @Test\n+    public void testDoubleUnaligned() {\n+        testUnaligned(JAVA_DOUBLE_UNALIGNED, double.class, Double.SIZE);\n+    }\n+\n+    @Test\n+    public void testChar() {\n+        testAligned(JAVA_CHAR, char.class, Character.SIZE);\n+    }\n+\n+    @Test\n+    public void testCharUnaligned() {\n+        testUnaligned(JAVA_CHAR_UNALIGNED, char.class, Character.SIZE);\n+    }\n+\n+    @Test\n+    public void testAddress() {\n+        testAligned(ADDRESS, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+    }\n+\n+    @Test\n+    public void testAddressUnaligned() {\n+        testUnaligned(ADDRESS_UNALIGNED, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+    }\n+\n+    void testAligned(ValueLayout layout,\n+                     Class<?> carrier,\n+                     long bitSize) {\n+        test(layout, carrier, bitSize, bitSize);\n+    }\n+\n+    void testUnaligned(ValueLayout layout,\n+                       Class<?> carrier,\n+                       long bitSize) {\n+        test(layout, carrier, bitSize, Byte.SIZE);\n+    }\n+\n+    void test(ValueLayout layout,\n+              Class<?> carrier,\n+              long bitSize,\n+              long bitAlignment) {\n+        assertEquals(layout.carrier(), carrier);\n+        assertEquals(layout.bitSize(), bitSize);\n+        assertEquals(layout.order(), ByteOrder.nativeOrder());\n+        assertEquals(layout.bitAlignment(), bitAlignment);\n+        assertTrue(layout.name().isEmpty());\n+        assertEquals(layout.byteSize(), layout.bitSize() \/ 8);\n+        assertEquals(layout.byteAlignment(), layout.bitAlignment() \/ 8);\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -35,1 +35,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -38,1 +37,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -62,1 +60,1 @@\n-                    MethodType.methodType(void.class, int.class, MemoryAddress.class, List.class));\n+                    MethodType.methodType(void.class, int.class, MemorySegment.class, List.class));\n@@ -68,1 +66,1 @@\n-    static final Addressable VARARGS_ADDR = findNativeOrThrow(\"varargs\");\n+    static final MemorySegment VARARGS_ADDR = findNativeOrThrow(\"varargs\");\n@@ -78,2 +76,2 @@\n-            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, session);\n-            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), session);\n+            MemorySegment callInfo = session.allocate(CallInfo.LAYOUT);\n+            MemorySegment argIDs = session.allocate(MemoryLayout.sequenceLayout(args.size(), C_INT));\n@@ -81,1 +79,1 @@\n-            MemoryAddress callInfoPtr = callInfo.address();\n+            MemorySegment callInfoPtr = callInfo;\n@@ -94,2 +92,3 @@\n-            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.toArray(MemoryLayout[]::new))\n-                    .asVariadic(args.stream().map(a -> a.layout).toArray(MemoryLayout[]::new));\n+            FunctionDescriptor baseDesc = FunctionDescriptor.ofVoid(argLayouts.toArray(MemoryLayout[]::new));\n+            Linker.Option varargIndex = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+            FunctionDescriptor desc = baseDesc.appendArgumentLayouts(args.stream().map(a -> a.layout).toArray(MemoryLayout[]::new));\n@@ -97,1 +96,1 @@\n-            MethodHandle downcallHandle = LINKER.downcallHandle(VARARGS_ADDR, desc);\n+            MethodHandle downcallHandle = LINKER.downcallHandle(VARARGS_ADDR, desc, varargIndex);\n@@ -124,1 +123,1 @@\n-    private static void check(int index, MemoryAddress ptr, List<Arg> args) {\n+    private static void check(int index, MemorySegment ptr, List<Arg> args) {\n@@ -130,1 +129,1 @@\n-            MemorySegment seg = MemorySegment.ofAddress(ptr, layout.byteSize(), session);\n+            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), session);\n@@ -146,2 +145,2 @@\n-        static void writeback(MemorySegment seg, Addressable addr) {\n-            VH_writeback.set(seg, addr.address());\n+        static void writeback(MemorySegment seg, MemorySegment addr) {\n+            VH_writeback.set(seg, addr);\n@@ -149,2 +148,2 @@\n-        static void argIDs(MemorySegment seg, Addressable addr) {\n-            VH_argIDs.set(seg, addr.address());\n+        static void argIDs(MemorySegment seg, MemorySegment addr) {\n+            VH_argIDs.set(seg, addr);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1, 2, MemorySession.openImplicit());\n+        MemorySegment segment = MemorySegment.allocateNative(1L, 2, MemorySession.openImplicit());\n@@ -105,1 +105,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, session);\n+            MemorySegment segment = session.allocate(inner_size * outer_size * 8, 4);\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n@@ -76,1 +76,1 @@\n-            Addressable stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n@@ -89,1 +89,1 @@\n-            Addressable stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class UpcallTestHelper extends NativeTestHelper {\n+    public record Output(List<String> stdout, List<String> stderr) {\n+        private static void assertContains(List<String> lines, String shouldInclude) {\n+            assertTrue(lines.stream().anyMatch(line -> line.contains(shouldInclude)),\n+                \"Did not find '\" + shouldInclude + \"' in stderr\");\n+        }\n+\n+        public void assertStdErrContains(String shouldInclude) {\n+            assertContains(stderr, shouldInclude);\n+        }\n+    }\n+\n+    public Output runInNewProcess(Class<?> target, boolean useSpec, String... programArgs) throws IOException, InterruptedException {\n+        assert !target.isArray();\n+\n+        List<String> command = new ArrayList<>(List.of(\n+            Paths.get(Utils.TEST_JDK)\n+                    .resolve(\"bin\")\n+                    .resolve(\"java\")\n+                    .toAbsolutePath()\n+                    .toString(),\n+            \"--enable-preview\",\n+            \"--enable-native-access=ALL-UNNAMED\",\n+            \"-Djava.library.path=\" + System.getProperty(\"java.library.path\"),\n+            \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n+            \"-cp\", Utils.TEST_CLASS_PATH,\n+            target.getName()\n+        ));\n+        command.addAll(Arrays.asList(programArgs));\n+        Process process = new ProcessBuilder()\n+            .command(command)\n+            .start();\n+\n+        int result = process.waitFor();\n+        assertNotEquals(result, 0);\n+\n+        List<String> outLines = linesFromStream(process.getInputStream());\n+        outLines.forEach(System.out::println);\n+        List<String> errLines = linesFromStream(process.getErrorStream());\n+        errLines.forEach(System.err::println);\n+\n+        return new Output(outLines, errLines);\n+    }\n+\n+    private static List<String> linesFromStream(InputStream stream) throws IOException {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\n+            return reader.lines().toList();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.Addressable;\n@@ -37,1 +36,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -42,0 +40,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -48,0 +47,1 @@\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n@@ -52,0 +52,1 @@\n+\n@@ -64,3 +65,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -70,1 +71,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) }\n+            { unboxAddress(), vmStore(r9, long.class) }\n@@ -88,3 +89,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -94,1 +95,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n@@ -118,3 +119,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -124,1 +125,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n@@ -140,3 +141,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -146,1 +147,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n@@ -168,1 +169,1 @@\n-                unboxAddress(MemorySegment.class),\n+                unboxAddress(),\n@@ -200,3 +201,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -206,1 +207,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n@@ -209,1 +210,1 @@\n-                unboxAddress(MemorySegment.class),\n+                unboxAddress(),\n@@ -214,1 +215,1 @@\n-                unboxAddress(MemorySegment.class),\n+                unboxAddress(),\n@@ -231,3 +232,3 @@\n-        assertTrue(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -237,1 +238,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n@@ -255,3 +256,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n@@ -261,2 +262,2 @@\n-            { unboxAddress(MemorySegment.class), vmStore(r10, long.class) },\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) }\n+            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) }\n@@ -284,3 +285,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n@@ -290,2 +291,2 @@\n-            { unboxAddress(MemorySegment.class), vmStore(r10, long.class) },\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n@@ -322,3 +323,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -328,1 +329,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n@@ -376,3 +377,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -382,3 +383,3 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n-            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r0, long.class) },\n-            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r1, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r0, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r1, long.class) },\n@@ -391,1 +392,1 @@\n-            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(0), long.class) },\n@@ -401,1 +402,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n@@ -403,1 +404,1 @@\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(1)));\n@@ -405,3 +406,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -412,1 +413,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n@@ -424,1 +425,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n@@ -426,1 +427,1 @@\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(1)));\n@@ -428,3 +429,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -435,1 +436,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":63,"deletions":62,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -46,1 +45,0 @@\n-import java.lang.foreign.Addressable;\n@@ -53,0 +51,1 @@\n+\n@@ -65,3 +64,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -71,1 +70,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -77,1 +76,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -93,3 +92,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -99,1 +98,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -107,1 +106,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -124,3 +123,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -130,1 +129,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -138,1 +137,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -154,3 +153,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -160,1 +159,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -168,1 +167,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -184,3 +183,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -190,1 +189,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -198,1 +197,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -209,3 +208,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -215,1 +214,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -227,1 +226,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -240,3 +239,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -246,1 +245,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -260,1 +259,1 @@\n-        assertEquals(bindings.nVectorArgs, 8);\n+        assertEquals(bindings.nVectorArgs(), 8);\n@@ -275,3 +274,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -281,1 +280,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -305,1 +304,1 @@\n-        assertEquals(bindings.nVectorArgs, 8);\n+        assertEquals(bindings.nVectorArgs(), 8);\n@@ -332,3 +331,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -338,1 +337,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -358,1 +357,1 @@\n-        assertEquals(bindings.nVectorArgs, 3);\n+        assertEquals(bindings.nVectorArgs(), 3);\n@@ -371,1 +370,1 @@\n-        MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n@@ -375,3 +374,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -381,1 +380,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -388,1 +387,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -397,3 +396,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -403,1 +402,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -410,1 +409,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -456,3 +455,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n@@ -462,2 +461,2 @@\n-            { unboxAddress(MemorySegment.class), vmStore(r11, long.class) },\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r11, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -477,1 +476,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -488,3 +487,3 @@\n-        assertTrue(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class, long.class));\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, long.class));\n@@ -494,1 +493,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -501,1 +500,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -512,2 +511,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -525,1 +524,1 @@\n-        assertEquals(bindings.nVectorArgs, 1);\n+        assertEquals(bindings.nVectorArgs(), 1);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":71,"deletions":72,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -40,1 +39,0 @@\n-import java.lang.foreign.Addressable;\n@@ -43,0 +41,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -48,0 +47,1 @@\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n@@ -53,0 +53,1 @@\n+\n@@ -63,3 +64,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -69,1 +70,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) }\n+            { unboxAddress(), vmStore(r10, long.class) }\n@@ -80,3 +81,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -86,1 +87,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -102,3 +103,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -108,1 +109,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -126,3 +127,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -132,1 +133,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -157,3 +158,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -163,1 +164,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -168,1 +169,1 @@\n-                unboxAddress(MemorySegment.class),\n+                unboxAddress(),\n@@ -189,1 +190,1 @@\n-                C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n+                C_INT, C_DOUBLE, C_INT, C_DOUBLE, C_DOUBLE);\n@@ -192,1 +193,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(2)));\n@@ -194,3 +195,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -200,1 +201,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -228,3 +229,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -234,1 +235,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -258,3 +259,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -264,1 +265,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -267,1 +268,1 @@\n-                unboxAddress(MemorySegment.class),\n+                unboxAddress(),\n@@ -285,1 +286,1 @@\n-        MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n@@ -289,3 +290,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -295,1 +296,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -310,3 +311,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -316,1 +317,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -334,3 +335,3 @@\n-        assertTrue(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -340,1 +341,1 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n@@ -352,4 +353,4 @@\n-            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-            MemorySegment.class, int.class, double.class, MemoryAddress.class);\n+            MemorySegment.class, int.class, double.class, MemorySegment.class,\n+            MemorySegment.class, int.class, double.class, MemorySegment.class,\n+            MemorySegment.class, int.class, double.class, MemorySegment.class,\n+            MemorySegment.class, int.class, double.class, MemorySegment.class);\n@@ -363,3 +364,3 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -369,2 +370,2 @@\n-            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n-            { copy(struct), unboxAddress(MemorySegment.class), vmStore(rcx, long.class) },\n+            { unboxAddress(), vmStore(r10, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(rcx, long.class) },\n@@ -374,1 +375,1 @@\n-            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(0), long.class) },\n@@ -378,1 +379,1 @@\n-            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(4), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(4), long.class) },\n@@ -382,1 +383,1 @@\n-            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(8), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(8), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":64,"deletions":63,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-        var segment = MemorySegment.allocateNative(size, 1, session);\n+        var segment = session.allocate(size, 1);\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, session);\n+            var segment = session.allocate(10, 1);\n@@ -163,2 +163,2 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, session);\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, session);\n+            MemorySegment segment1 = session.allocate(10, 1);\n+            MemorySegment segment2 = session.allocate(10, 1);\n@@ -210,1 +210,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, session);\n+            var segment = session.allocate(10, 1);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, session);\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, session);\n+            MemorySegment segment1 = session.allocate(10, 1);\n+            MemorySegment segment2 = session.allocate(10, 1);\n@@ -143,1 +143,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, session);\n+            var segment = session.allocate(10, 1);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestDontRelease\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestDontRelease extends NativeTestHelper  {\n+\n+    static {\n+        System.loadLibrary(\"DontRelease\");\n+    }\n+\n+    @Test\n+    public void testDontRelease() {\n+        MethodHandle handle = downcallHandle(\"test_ptr\", FunctionDescriptor.ofVoid(ADDRESS));\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = session.allocate(JAVA_INT);\n+            session.whileAlive(() -> {\n+                Thread t = new Thread(() -> {\n+                    try {\n+                        \/\/ acquire of the segment should fail here,\n+                        \/\/ due to wrong thread\n+                        handle.invokeExact(segment);\n+                    } catch (Throwable e) {\n+                        \/\/ catch the exception.\n+                        assertTrue(e instanceof WrongThreadException);\n+                        assertTrue(e.getMessage().matches(\".*Attempted access outside owning thread.*\"));\n+                    }\n+                });\n+                t.start();\n+                try {\n+                    t.join();\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                \/\/ the downcall above should not have called release on the session\n+                \/\/ so doing it here should succeed without error\n+            });\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void test_ptr(void* ptr) {}\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/libDontRelease.c","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.lang.Module;\n+import java.lang.ModuleLayer;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.io.File;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+\n+\/\/ This class creates a dynamic module layer and loads the\n+\/\/ panama_module in it. enableNativeAccess on that dynamic\n+\/\/ module is called depending on the command line option.\n+\/\/\n+\/\/ Usage:\n+\/\/   java --enable-native-access=ALL-UNNAMED NativeAccessDynamicMain <module-path> <mod\/class> <true|false> [main-args]\n+public class NativeAccessDynamicMain {\n+    public static void main(String[] args) throws Exception {\n+        String modulePath = args[0];\n+        String moduleAndClsName = args[1];\n+        boolean enableNativeAccess = Boolean.parseBoolean(args[2]);\n+        String[] mainArgs = args.length > 2? Arrays.copyOfRange(args, 3, args.length) : new String[0];\n+\n+        int idx = moduleAndClsName.indexOf('\/');\n+        String moduleName = moduleAndClsName.substring(0, idx);\n+        String className = moduleAndClsName.substring(idx+1);\n+\n+        Path[] paths = Stream.of(modulePath.split(File.pathSeparator))\n+            .map(Paths::get)\n+            .toArray(Path[]::new);\n+        ModuleFinder mf = ModuleFinder.of(paths);\n+        var mrefs = mf.findAll();\n+        if (mrefs.isEmpty()) {\n+            throw new RuntimeException(\"No modules module path: \" + modulePath);\n+        }\n+\n+        var rootMods = mrefs.stream().\n+            map(mr->mr.descriptor().name()).\n+            collect(Collectors.toSet());\n+\n+        ModuleLayer boot = ModuleLayer.boot();\n+        var conf = boot.configuration().\n+            resolve(mf, ModuleFinder.of(), rootMods);\n+        String firstMod = rootMods.iterator().next();\n+        URLClassLoader cl = new URLClassLoader(new URL[] { paths[0].toFile().toURL() });\n+        ModuleLayer.Controller controller = boot.defineModulesWithOneLoader(conf, List.of(boot), cl);\n+        ModuleLayer layer = controller.layer();\n+        Module mod = layer.findModule(firstMod).get();\n+\n+        \/\/ conditionally grant native access to the dynamic module created\n+        if (enableNativeAccess) {\n+            controller.enableNativeAccess(mod);\n+        }\n+        Class mainCls = Class.forName(mod, className);\n+        var main = mainCls.getMethod(\"main\", String[].class);\n+        main.invoke(null, (Object)mainArgs);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/NativeAccessDynamicMain.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires !vm.musl\n+ *\n+ * @library \/test\/lib\n+ * @build TestEnableNativeAccessDynamic\n+ *        panama_module\/*\n+          NativeAccessDynamicMain\n+ * @run testng\/othervm\/timeout=180 TestEnableNativeAccessDynamic\n+ * @summary Test for dynamically setting --enable-native-access flag for a module\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class TestEnableNativeAccessDynamic {\n+\n+    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n+\n+    static final String PANAMA_MAIN = \"panama_module\/org.openjdk.foreigntest.PanamaMainDirect\";\n+    static final String PANAMA_REFLECTION = \"panama_module\/org.openjdk.foreigntest.PanamaMainReflection\";\n+    static final String PANAMA_INVOKE = \"panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\";\n+    static final String PANAMA_JNI = \"panama_module\/org.openjdk.foreigntest.PanamaMainJNI\";\n+\n+    \/**\n+     * Represents the expected result of a test.\n+     *\/\n+    static final class Result {\n+        private final boolean success;\n+        private final List<String> expectedOutput = new ArrayList<>();\n+        private final List<String> notExpectedOutput = new ArrayList<>();\n+\n+        Result(boolean success) {\n+            this.success = success;\n+        }\n+\n+        Result expect(String msg) {\n+            expectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        Result doNotExpect(String msg) {\n+            notExpectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        boolean shouldSucceed() {\n+            return success;\n+        }\n+\n+        Stream<String> expectedOutput() {\n+            return expectedOutput.stream();\n+        }\n+\n+        Stream<String> notExpectedOutput() {\n+            return notExpectedOutput.stream();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = (success) ? \"success\" : \"failure\";\n+            for (String msg : expectedOutput) {\n+                s += \"\/\" + msg;\n+            }\n+            return s;\n+        }\n+    }\n+\n+    static Result success() {\n+        return new Result(true);\n+    }\n+\n+    static Result successNoWarning() {\n+        return success().doNotExpect(\"WARNING\");\n+    }\n+\n+    static Result failWithError(String expectedOutput) {\n+        return new Result(false).expect(expectedOutput);\n+    }\n+\n+    @DataProvider(name = \"succeedCases\")\n+    public Object[][] succeedCases() {\n+        return new Object[][] {\n+                { \"panama_enable_native_access\", PANAMA_MAIN, successNoWarning() },\n+                { \"panama_enable_native_access_reflection\", PANAMA_REFLECTION, successNoWarning() },\n+                { \"panama_enable_native_access_invoke\", PANAMA_INVOKE, successNoWarning() },\n+        };\n+    }\n+\n+    @DataProvider(name = \"failureCases\")\n+    public Object[][] failureCases() {\n+        String errMsg = \"Illegal native access from: module panama_module\";\n+        return new Object[][] {\n+                { \"panama_enable_native_access_fail\", PANAMA_MAIN, failWithError(errMsg) },\n+                { \"panama_enable_native_access_fail_reflection\", PANAMA_REFLECTION, failWithError(errMsg) },\n+                { \"panama_enable_native_access_fail_invoke\", PANAMA_INVOKE, failWithError(errMsg) },\n+        };\n+    }\n+\n+    \/**\n+     * Checks an expected result with the output captured by the given\n+     * OutputAnalyzer.\n+     *\/\n+    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n+        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n+        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n+        int exitValue = outputAnalyzer.getExitValue();\n+        if (expectedResult.shouldSucceed()) {\n+            assertTrue(exitValue == 0);\n+        } else {\n+            assertTrue(exitValue != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test to execute the given test action. The VM is run with the\n+     * given VM options and the output checked to see that it matches the\n+     * expected result.\n+     *\/\n+    OutputAnalyzer run(String action, String moduleAndCls, boolean enableNativeAccess,\n+            Result expectedResult, boolean panamaModuleInBootLayer) throws Exception\n+    {\n+        List<String> list = new ArrayList<>();\n+        list.add(\"--enable-preview\");\n+        if (panamaModuleInBootLayer) {\n+            list.addAll(List.of(\"-p\", MODULE_PATH));\n+            list.add(\"--add-modules=panama_module\");\n+            list.add(\"--enable-native-access=panama_module\");\n+        } else {\n+            list.add(\"--enable-native-access=ALL-UNNAMED\");\n+        }\n+        list.addAll(List.of(\"NativeAccessDynamicMain\", MODULE_PATH,\n+                moduleAndCls, Boolean.toString(enableNativeAccess), action));\n+        String[] opts = list.toArray(String[]::new);\n+        OutputAnalyzer outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        checkResult(expectedResult, outputAnalyzer);\n+        return outputAnalyzer;\n+    }\n+\n+    @Test(dataProvider = \"succeedCases\")\n+    public void testSucceed(String action, String moduleAndCls,\n+            Result expectedResult) throws Exception {\n+        run(action, moduleAndCls, true, expectedResult, false);\n+    }\n+\n+    @Test(dataProvider = \"failureCases\")\n+    public void testFailures(String action, String moduleAndCls,\n+            Result expectedResult) throws Exception {\n+        run(action, moduleAndCls, false, expectedResult, false);\n+    }\n+\n+    \/\/ make sure that having a same named module in boot layer with native access\n+    \/\/ does not influence same named dynamic module.\n+    @Test(dataProvider = \"failureCases\")\n+    public void testFailuresWithPanamaModuleInBootLayer(String action, String moduleAndCls,\n+            Result expectedResult) throws Exception {\n+        run(action, moduleAndCls, false, expectedResult, true);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n-        MemorySegment.ofAddress(MemoryAddress.NULL, 4000, MemorySession.global());\n+        MemorySegment.ofAddress(0, 4000, MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-                MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, MemorySession.class));\n-        var seg = (MemorySegment)mh.invokeExact(MemoryAddress.NULL, 4000L, MemorySession.global());\n+                MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class));\n+        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", MemoryAddress.class, long.class, MemorySession.class);\n-        method.invoke(null, MemoryAddress.NULL, 4000L, MemorySession.global());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, MemorySession.class);\n+        method.invoke(null, 0L, 4000L, MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -32,1 +31,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -74,2 +72,1 @@\n-        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n-        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemorySegment.class, MemorySegment.NULL);\n@@ -78,1 +75,1 @@\n-        addDefaultMapping(MemorySession.class, MemorySession.openImplicit());\n+        addDefaultMapping(MemorySession.class, MemorySession.openShared());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -32,2 +33,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -35,1 +34,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -37,2 +35,0 @@\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n@@ -57,3 +53,0 @@\n-                    { MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\",\n-                            MethodType.methodType(VaList.class, MemoryAddress.class, MemorySession.class)),\n-                            \"VaList::ofAddress\/1\" },\n@@ -61,2 +54,2 @@\n-                            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, MemorySession.class)),\n-                            \"MemorySegment::ofAddress\" },\n+                            MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class)),\n+                            \"MemorySegment::ofAddressNative\" },\n@@ -69,102 +62,0 @@\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getUtf8String\",\n-                            MethodType.methodType(String.class, long.class)),\n-                            \"MemoryAddress::getUtf8String\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setUtf8String\",\n-                            MethodType.methodType(void.class, long.class, String.class)),\n-                            \"MemoryAddress::setUtf8String\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(byte.class, ValueLayout.OfByte.class, long.class)),\n-                            \"MemoryAddress::get\/byte\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(boolean.class, ValueLayout.OfBoolean.class, long.class)),\n-                            \"MemoryAddress::get\/boolean\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(char.class, ValueLayout.OfChar.class, long.class)),\n-                            \"MemoryAddress::get\/char\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(short.class, ValueLayout.OfShort.class, long.class)),\n-                            \"MemoryAddress::get\/short\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class)),\n-                            \"MemoryAddress::get\/int\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(float.class, ValueLayout.OfFloat.class, long.class)),\n-                            \"MemoryAddress::get\/float\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(long.class, ValueLayout.OfLong.class, long.class)),\n-                            \"MemoryAddress::get\/long\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(double.class, ValueLayout.OfDouble.class, long.class)),\n-                            \"MemoryAddress::get\/double\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(MemoryAddress.class, ValueLayout.OfAddress.class, long.class)),\n-                            \"MemoryAddress::get\/address\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfByte.class, long.class, byte.class)),\n-                            \"MemoryAddress::set\/byte\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfBoolean.class, long.class, boolean.class)),\n-                            \"MemoryAddress::set\/boolean\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfChar.class, long.class, char.class)),\n-                            \"MemoryAddress::set\/char\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfShort.class, long.class, short.class)),\n-                            \"MemoryAddress::set\/short\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfInt.class, long.class, int.class)),\n-                            \"MemoryAddress::set\/int\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfFloat.class, long.class, float.class)),\n-                            \"MemoryAddress::set\/float\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfLong.class, long.class, long.class)),\n-                            \"MemoryAddress::set\/long\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfDouble.class, long.class, double.class)),\n-                            \"MemoryAddress::set\/double\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfAddress.class, long.class, Addressable.class)),\n-                            \"MemoryAddress::set\/address\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(char.class, ValueLayout.OfChar.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/char\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(short.class, ValueLayout.OfShort.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/short\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/int\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(float.class, ValueLayout.OfFloat.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/float\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(long.class, ValueLayout.OfLong.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/long\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(double.class, ValueLayout.OfDouble.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/double\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(MemoryAddress.class, ValueLayout.OfAddress.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/address\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfChar.class, long.class, char.class)),\n-                            \"MemoryAddress::setAtIndex\/char\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfShort.class, long.class, short.class)),\n-                            \"MemoryAddress::setAtIndex\/short\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfInt.class, long.class, int.class)),\n-                            \"MemoryAddress::setAtIndex\/int\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfFloat.class, long.class, float.class)),\n-                            \"MemoryAddress::setAtIndex\/float\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfLong.class, long.class, long.class)),\n-                            \"MemoryAddress::set\/long\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfDouble.class, long.class, double.class)),\n-                            \"MemoryAddress::set\/double\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfAddress.class, long.class, Addressable.class)),\n-                            \"MemoryAddress::set\/address\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":3,"deletions":112,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#include <stddef.h>\n+\n+EXPORT void* get_null() { return NULL; }\n","filename":"test\/jdk\/java\/foreign\/libNull.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -45,1 +45,1 @@\n-        Addressable foo = (Addressable)fooSymbol.invoke(null);\n+        MemorySegment foo = (MemorySegment) fooSymbol.invoke(null);\n@@ -49,1 +49,1 @@\n-        Method invoke = invoker.getDeclaredMethod(\"invoke\", Addressable.class);\n+        Method invoke = invoker.getDeclaredMethod(\"invoke\", MemorySegment.class);\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        assertTrue(loaderLookup.lookup(\"Java_TestLoaderLookupJNI_loaderLookup0\").isPresent());\n+        assertTrue(loaderLookup.find(\"Java_TestLoaderLookupJNI_loaderLookup0\").isPresent());\n@@ -48,1 +48,1 @@\n-        assertTrue(loaderLookup.lookup(\"Java_TestLoaderLookupJNI_loaderLookup0\").isPresent());\n+        assertTrue(loaderLookup.find(\"Java_TestLoaderLookupJNI_loaderLookup0\").isPresent());\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookupJNI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    public static void invoke(Addressable symbol) throws Throwable {\n+    public static void invoke(MemorySegment symbol) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/invoker\/Invoker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -34,2 +34,2 @@\n-    public static Addressable fooSymbol() {\n-        return SymbolLookup.loaderLookup().lookup(\"foo\").get();\n+    public static MemorySegment fooSymbol() {\n+        return SymbolLookup.loaderLookup().find(\"foo\").get();\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/Lookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -36,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -57,2 +56,1 @@\n-        MemoryAddress ma = (MemoryAddress) MH_my_malloc.invokeExact(4L);\n-        MemorySegment seg = MemorySegment.ofAddress(ma, 4L, MemorySession.openImplicit());\n+        MemorySegment seg = (MemorySegment) MH_my_malloc.invokeExact(4L);\n@@ -63,1 +61,1 @@\n-        freeMemory(ma);\n+        freeMemory(seg);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:CompileCommand=dontinline,TestNormalize::doCall*\n+ *   TestNormalize\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static org.testng.Assert.assertEquals;\n+\n+\/\/ test normalization of smaller than int primitive types\n+public class TestNormalize extends NativeTestHelper {\n+\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final MethodHandle SAVE_BOOLEAN_AS_INT;\n+    private static final MethodHandle SAVE_BYTE_AS_INT;\n+    private static final MethodHandle SAVE_SHORT_AS_INT;\n+    private static final MethodHandle SAVE_CHAR_AS_INT;\n+\n+    private static final MethodHandle BOOLEAN_TO_INT;\n+    private static final MethodHandle BYTE_TO_INT;\n+    private static final MethodHandle SHORT_TO_INT;\n+    private static final MethodHandle CHAR_TO_INT;\n+\n+    private static final MethodHandle NATIVE_BOOLEAN_TO_INT;\n+\n+    private static final int BOOLEAN_HOB_MASK = ~0b1;\n+    private static final int BYTE_HOB_MASK    = ~0xFF;\n+    private static final int SHORT_HOB_MASK   = ~0xFFFF;\n+    private static final int CHAR_HOB_MASK    = ~0xFFFF;\n+\n+    private static final MethodHandle SAVE_BOOLEAN;\n+\n+    static {\n+        System.loadLibrary(\"Normalize\");\n+\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            SAVE_BOOLEAN_AS_INT = lookup.findStatic(TestNormalize.class, \"saveBooleanAsInt\", MethodType.methodType(void.class, boolean.class, int[].class));\n+            SAVE_BYTE_AS_INT = lookup.findStatic(TestNormalize.class, \"saveByteAsInt\", MethodType.methodType(void.class, byte.class, int[].class));\n+            SAVE_SHORT_AS_INT = lookup.findStatic(TestNormalize.class, \"saveShortAsInt\", MethodType.methodType(void.class, short.class, int[].class));\n+            SAVE_CHAR_AS_INT = lookup.findStatic(TestNormalize.class, \"saveCharAsInt\", MethodType.methodType(void.class, char.class, int[].class));\n+\n+            BOOLEAN_TO_INT = lookup.findStatic(TestNormalize.class, \"booleanToInt\", MethodType.methodType(int.class, boolean.class));\n+            BYTE_TO_INT = lookup.findStatic(TestNormalize.class, \"byteToInt\", MethodType.methodType(int.class, byte.class));\n+            SHORT_TO_INT = lookup.findStatic(TestNormalize.class, \"shortToInt\", MethodType.methodType(int.class, short.class));\n+            CHAR_TO_INT = lookup.findStatic(TestNormalize.class, \"charToInt\", MethodType.methodType(int.class, char.class));\n+\n+            NATIVE_BOOLEAN_TO_INT = LINKER.downcallHandle(findNativeOrThrow(\"int_identity\"), FunctionDescriptor.of(JAVA_INT, JAVA_BOOLEAN));\n+\n+            SAVE_BOOLEAN = lookup.findStatic(TestNormalize.class, \"saveBoolean\", MethodType.methodType(void.class, boolean.class, boolean[].class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/\/ The idea of this test is that we pass a 'dirty' int value down to native code, and then receive it back\n+    \/\/ as the argument to an upcall, as well as the result of the downcall, but with a sub-int type (boolean, byte, short, char).\n+    \/\/ When we do either of those, argument normalization should take place, so that the resulting value is sane (1).\n+    \/\/ After that we convert the value back to int again, the JVM can\/will skip value normalization here.\n+    \/\/ We then check the high order bits of the resulting int. If argument normalization took place at (1), they should all be 0.\n+    @Test(dataProvider = \"cases\")\n+    public void testNormalize(ValueLayout layout, int testValue, int hobMask, MethodHandle toInt, MethodHandle saver) throws Throwable {\n+        \/\/ use actual type as parameter type to test upcall arg normalization\n+        FunctionDescriptor upcallDesc = FunctionDescriptor.ofVoid(layout);\n+        \/\/ use actual type as return type to test downcall return normalization\n+        FunctionDescriptor downcallDesc = FunctionDescriptor.of(layout, ADDRESS, JAVA_INT);\n+\n+        MemorySegment target = findNativeOrThrow(\"test\");\n+        MethodHandle downcallHandle = LINKER.downcallHandle(target, downcallDesc);\n+        downcallHandle = MethodHandles.filterReturnValue(downcallHandle, toInt);\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            int[] box = new int[1];\n+            saver = MethodHandles.insertArguments(saver, 1, box);\n+            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, session);\n+            int dirtyValue = testValue | hobMask; \/\/ set all bits that should not be set\n+\n+            \/\/ test after JIT as well\n+            for (int i = 0; i < 20_000; i++) {\n+                doCall(downcallHandle, upcallStub, box, dirtyValue, hobMask);\n+            }\n+        }\n+    }\n+\n+    private static void doCall(MethodHandle downcallHandle, MemorySegment upcallStub,\n+                               int[] box, int dirtyValue, int hobMask) throws Throwable {\n+        int result = (int) downcallHandle.invokeExact(upcallStub, dirtyValue);\n+        assertEquals(box[0] & hobMask, 0); \/\/ check normalized upcall arg\n+        assertEquals(result & hobMask, 0); \/\/ check normalized downcall return value\n+    }\n+\n+    public static void saveBooleanAsInt(boolean b, int[] box) {\n+        box[0] = booleanToInt(b);\n+    }\n+    public static void saveByteAsInt(byte b, int[] box) {\n+        box[0] = byteToInt(b);\n+    }\n+    public static void saveShortAsInt(short s, int[] box) {\n+        box[0] = shortToInt(s);\n+    }\n+    public static void saveCharAsInt(char c, int[] box) {\n+        box[0] = charToInt(c);\n+    }\n+\n+    public static int booleanToInt(boolean b) {\n+        try {\n+            return (int) NATIVE_BOOLEAN_TO_INT.invokeExact(b); \/\/ FIXME do in pure Java?\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public static int byteToInt(byte b) {\n+        return b;\n+    }\n+    public static int charToInt(char c) {\n+        return c;\n+    }\n+    public static int shortToInt(short s) {\n+        return s;\n+    }\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        return new Object[][] {\n+            { JAVA_BOOLEAN, booleanToInt(true),     BOOLEAN_HOB_MASK, BOOLEAN_TO_INT, SAVE_BOOLEAN_AS_INT },\n+            { JAVA_BYTE,    byteToInt((byte) 42),   BYTE_HOB_MASK,    BYTE_TO_INT,    SAVE_BYTE_AS_INT    },\n+            { JAVA_SHORT,   shortToInt((short) 42), SHORT_HOB_MASK,   SHORT_TO_INT,   SAVE_SHORT_AS_INT   },\n+            { JAVA_CHAR,    charToInt('a'),         CHAR_HOB_MASK,    CHAR_TO_INT,    SAVE_CHAR_AS_INT    }\n+        };\n+    }\n+\n+    \/\/ test which int values are considered true and false\n+    \/\/ we currently convert any int with a non-zero first byte to true, otherwise false.\n+    @Test(dataProvider = \"bools\")\n+    public void testBool(int testValue, boolean expected) throws Throwable {\n+        MemorySegment addr = findNativeOrThrow(\"test\");\n+        MethodHandle target = LINKER.downcallHandle(addr, FunctionDescriptor.of(JAVA_BOOLEAN, ADDRESS, JAVA_INT));\n+\n+        boolean[] box = new boolean[1];\n+        MethodHandle upcallTarget = MethodHandles.insertArguments(SAVE_BOOLEAN, 1, box);\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), session);\n+            boolean result = (boolean) target.invokeExact(callback, testValue);\n+            assertEquals(box[0], expected);\n+            assertEquals(result, expected);\n+        }\n+    }\n+\n+    private static void saveBoolean(boolean b, boolean[] box) {\n+        box[0] = b;\n+    }\n+\n+    @DataProvider\n+    public static Object[][] bools() {\n+        return new Object[][]{\n+            { 0b01,          true  }, \/\/ zero least significant bit, but non-zero first byte\n+            { 0b1_0000_0000, false }  \/\/ zero first byte\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/\/ we use 'int' here to make sure the native code doesn't touch any of the bits\n+\/\/ the important part is that our Java code performs argument normalization\n+EXPORT int test(void (*cb)(int), int x) {\n+    cb(x); \/\/ check upcall arg normalization\n+    return x; \/\/ check return value normalization\n+}\n+\n+EXPORT int int_identity(int x) {\n+    return x;\n+}\n","filename":"test\/jdk\/java\/foreign\/normalize\/libNormalize.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPassHeapSegment\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+\n+public class TestPassHeapSegment extends UpcallTestHelper  {\n+\n+    static {\n+        System.loadLibrary(\"PassHeapSegment\");\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp = \".*Heap segment not allowed.*\")\n+    public void testNoHeapArgs() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"test_args\", FunctionDescriptor.ofVoid(ADDRESS));\n+        MemorySegment segment = MemorySegment.ofArray(new byte[]{ 0, 1, 2 });\n+        handle.invoke(segment); \/\/ should throw\n+    }\n+\n+    @Test(dataProvider = \"specs\")\n+    public void testNoHeapReturns(boolean spec) throws IOException, InterruptedException {\n+        runInNewProcess(Runner.class, spec).assertStdErrContains(\"Heap segment not allowed\");\n+    }\n+\n+    public static class Runner {\n+\n+        static {\n+            System.loadLibrary(\"PassHeapSegment\");\n+        }\n+\n+        public static void main(String[] args) throws Throwable {\n+            MethodHandle handle = downcallHandle(\"test_return\", FunctionDescriptor.ofVoid(ADDRESS));\n+            MemorySegment upcallStub = upcallStub(Runner.class, \"target\", FunctionDescriptor.of(ADDRESS));\n+            handle.invoke(upcallStub);\n+        }\n+\n+        public static MemorySegment target() {\n+            return MemorySegment.ofArray(new byte[]{ 0, 1, 2 }); \/\/ should throw\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] specs() {\n+        return new Object[][]{\n+            { true },\n+            { false }\n+        };\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void test_args(void* ptr) {}\n+\n+EXPORT void test_return(void* (*cb)(void)) {\n+    cb();\n+}\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/libPassHeapSegment.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -81,1 +81,0 @@\n-import java.lang.foreign.Addressable;\n@@ -84,1 +83,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -86,0 +85,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -89,1 +89,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -120,2 +119,1 @@\n-            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n-            MemoryAddress stubAddress = stub.address();\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n@@ -124,1 +122,1 @@\n-            payload(stubAddress);\n+            payload(stub);\n@@ -129,1 +127,1 @@\n-    static void payload(MemoryAddress cb) throws Throwable {\n+    static void payload(MemorySegment cb) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-import java.lang.foreign.Addressable;\n@@ -84,1 +83,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -119,2 +118,1 @@\n-            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n-            MemoryAddress stubAddress = stub.address();\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n@@ -123,1 +121,1 @@\n-                payload(stubAddress); \/\/ warmup\n+                payload(stub); \/\/ warmup\n@@ -127,1 +125,1 @@\n-            payload(stubAddress); \/\/ test\n+            payload(stub); \/\/ test\n@@ -131,1 +129,1 @@\n-    static void payload(MemoryAddress cb) throws Throwable {\n+    static void payload(MemorySegment cb) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -46,1 +46,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n@@ -83,1 +83,1 @@\n-            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), session);\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), session);\n@@ -94,2 +94,2 @@\n-    static void payload(Addressable cb) throws Throwable {\n-        MH_foo.invokeExact((Addressable) cb, 0, 1, 2, 3);\n+    static void payload(MemorySegment cb) throws Throwable {\n+        MH_foo.invokeExact(cb, 0, 1, 2, 3);\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,2 +66,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n@@ -69,1 +67,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n@@ -72,1 +69,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -83,1 +79,2 @@\n-    private static final MethodHandle ADDRESS_TO_VALIST;\n+    private static final MethodHandle VALIST_TO_ADDRESS;\n+    private static final MethodHandle SEGMENT_TO_VALIST;\n@@ -87,1 +84,2 @@\n-            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class, MemorySession.class));\n+            VALIST_TO_ADDRESS = MethodHandles.lookup().findVirtual(VaList.class, \"segment\", MethodType.methodType(MemorySegment.class));\n+            SEGMENT_TO_VALIST = MethodHandles.lookup().findStatic(VaListTest.class, \"segmentToValist\", MethodType.methodType(VaList.class, MemorySegment.class));\n@@ -116,1 +114,1 @@\n-        return linkInternal(symbol, fd);\n+        return MethodHandles.filterArguments(linkInternal(symbol, fd), fd.argumentLayouts().size() - 1, VALIST_TO_ADDRESS);\n@@ -173,3 +171,3 @@\n-            b.addVarg(intLayout, 10)\n-                    .addVarg(intLayout, 15)\n-                    .addVarg(intLayout, 20));\n+                b.addVarg(intLayout, 10)\n+                        .addVarg(intLayout, 15)\n+                        .addVarg(intLayout, 20));\n@@ -201,3 +199,3 @@\n-            b.addVarg(doubleLayout, 3.0D)\n-                    .addVarg(doubleLayout, 4.0D)\n-                    .addVarg(doubleLayout, 5.0D));\n+                b.addVarg(doubleLayout, 3.0D)\n+                        .addVarg(doubleLayout, 4.0D)\n+                        .addVarg(doubleLayout, 5.0D));\n@@ -213,1 +211,1 @@\n-                    MemoryAddress ma = list.nextVarg(layout);\n+                    MemorySegment ma = list.nextVarg(layout);\n@@ -227,1 +225,1 @@\n-    public void testVaListMemoryAddress(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n+    public void testVaListMemorySegment(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n@@ -231,1 +229,1 @@\n-            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, session);\n+            MemorySegment msInt = session.allocate(JAVA_INT);\n@@ -233,1 +231,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt.address()));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt));\n@@ -286,1 +284,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, session);\n+            MemorySegment struct = session.allocate(Point_LAYOUT);\n@@ -339,1 +337,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, session);\n+            MemorySegment struct = session.allocate(BigPoint_LAYOUT);\n@@ -393,1 +391,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, session);\n+            MemorySegment struct = session.allocate(FloatPoint_LAYOUT);\n@@ -457,1 +455,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, session);\n+            MemorySegment struct = session.allocate(HugePoint_LAYOUT);\n@@ -489,1 +487,1 @@\n-                MH_sumStack.invoke(longSum, doubleSum, list);\n+                MH_sumStack.invokeExact(longSum, doubleSum, list);\n@@ -509,2 +507,2 @@\n-            MemorySegment longSum = MemorySegment.allocateNative(longLayout, session);\n-            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, session);\n+            MemorySegment longSum = session.allocate(longLayout);\n+            MemorySegment doubleSum = session.allocate(doubleLayout);\n@@ -537,2 +535,2 @@\n-            Addressable stub = abi.upcallStub(callback, desc, session);\n-            target.invoke(stub);\n+            MemorySegment stub = abi.upcallStub(callback, desc, session);\n+            target.invokeExact(stub);\n@@ -579,1 +577,1 @@\n-                            .addVarg(intLayout, 8), session);\n+                    .addVarg(intLayout, 8), session);\n@@ -584,1 +582,1 @@\n-        assertFalse(listLeaked.session().isAlive());\n+        assertFalse(listLeaked.segment().session().isAlive());\n@@ -594,1 +592,1 @@\n-                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerSession);\n+                MemorySegment pointIn = innerSession.allocate(Point_LAYOUT);\n@@ -598,1 +596,1 @@\n-                pointOut = MemorySegment.allocateNative(Point_LAYOUT, session);\n+                pointOut = session.allocate(Point_LAYOUT);\n@@ -692,1 +690,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.openImplicit());\n+                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.openImplicit());\n@@ -737,3 +735,2 @@\n-                    MemoryAddress intPtr = vaList.nextVarg(C_POINTER);\n-                    MemorySegment ms = MemorySegment.ofAddress(intPtr, C_INT.byteSize(), MemorySession.global());\n-                    int x = ms.get(JAVA_INT, 0);\n+                    MemorySegment intPtr = vaList.nextVarg(C_POINTER);\n+                    int x = intPtr.get(JAVA_INT, 0);\n@@ -819,1 +816,1 @@\n-                        MethodHandles.insertArguments(ADDRESS_TO_VALIST, 1, MemorySession.openConfined()));\n+                        SEGMENT_TO_VALIST);\n@@ -826,0 +823,4 @@\n+    static VaList segmentToValist(MemorySegment segment) {\n+        return VaList.ofAddress(segment.address(), MemorySession.openImplicit());\n+    }\n+\n@@ -871,1 +872,1 @@\n-                 builder.addVarg(ofAddress, MemoryAddress.ofLong(1));\n+                 builder.addVarg(ofAddress, MemorySegment.ofAddress(1));\n@@ -893,1 +894,1 @@\n-            assertEquals(vaList.nextVarg(ofAddress), MemoryAddress.ofLong(1));\n+            assertEquals(vaList.nextVarg(ofAddress), MemorySegment.ofAddress(1));\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":38,"deletions":37,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.Addressable;\n@@ -38,0 +37,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -49,3 +49,3 @@\n-    static final Addressable funcA;\n-    static final Addressable funcB;\n-    static final Addressable funcC;\n+    static final MemorySegment funcA;\n+    static final MemorySegment funcB;\n+    static final MemorySegment funcC;\n@@ -72,1 +72,1 @@\n-        int x = (int) func.invokeExact((Addressable) null);\n+        int x = (int) func.invokeExact((MemorySegment)null);\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        MemorySegment symbol = symbolLookup.lookup(\"start_threads\").orElseThrow();\n+        MemorySegment symbol = symbolLookup.find(\"start_threads\").orElseThrow();\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(8, session);\n+            MemorySegment seg = session.allocate(8);\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, session);\n+            MemorySegment segment = session.allocate(layout);\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,10 +39,8 @@\n-            withToString(\"HB:RW:NE\", (int s) -> {\n-                return ByteBuffer.allocate(s)\n-                        .order(ByteOrder.nativeOrder());\n-            }),\n-            withToString(\"DB:RW:NE\", (int s) -> {\n-                return ByteBuffer.allocateDirect(s)\n-                        .order(ByteOrder.nativeOrder());\n-            }),\n-            withToString(\"MS:RW:NE\", (int s) -> {\n-                return MemorySegment.allocateNative(s, MemorySession.openImplicit())\n+            withToString(\"HB:RW:NE\", (int s) ->\n+                    ByteBuffer.allocate(s)\n+                        .order(ByteOrder.nativeOrder())),\n+            withToString(\"DB:RW:NE\", (int s) ->\n+                    ByteBuffer.allocateDirect(s)\n+                        .order(ByteOrder.nativeOrder())),\n+            withToString(\"MS:RW:NE\", (int s) ->\n+                    MemorySession.openImplicit().allocate(s)\n@@ -50,2 +48,2 @@\n-                        .order(ByteOrder.nativeOrder());\n-            })\n+                        .order(ByteOrder.nativeOrder())\n+            )\n@@ -55,3 +53,3 @@\n-            withToString(\"HMS\", (int s) -> {\n-                return MemorySegment.allocateNative(s, MemorySession.openImplicit());\n-            }),\n+            withToString(\"HMS\", (int s) ->\n+                    MemorySession.openImplicit().allocate(s)\n+            ),\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+  gen_perf_tests=true\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-        mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, session);\n-        mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, session);\n+        mismatchSegmentLarge1 = session.allocate(SIZE_WITH_TAIL);\n+        mismatchSegmentLarge2 = session.allocate(SIZE_WITH_TAIL);\n@@ -95,2 +95,2 @@\n-        mismatchSegmentSmall1 = MemorySegment.allocateNative(7, session);\n-        mismatchSegmentSmall2 = MemorySegment.allocateNative(7, session);\n+        mismatchSegmentSmall1 = session.allocate(7);\n+        mismatchSegmentSmall2 = session.allocate(7);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.openConfined());\n+    final MemorySegment segment = MemorySession.openConfined().allocate(ALLOC_SIZE);\n@@ -75,2 +75,2 @@\n-    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, session);\n-    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, session);\n+    final MemorySegment mismatchSegmentLarge1 = session.allocate(SIZE_WITH_TAIL);\n+    final MemorySegment mismatchSegmentLarge2 = session.allocate(SIZE_WITH_TAIL);\n@@ -81,2 +81,2 @@\n-    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, session);\n-    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, session);\n+    final MemorySegment mismatchSegmentSmall1 = session.allocate(7);\n+    final MemorySegment mismatchSegmentSmall2 = session.allocate(7);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.foreign.Addressable;\n@@ -29,1 +28,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -70,1 +69,1 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.asUnbounded();\n@@ -75,1 +74,1 @@\n-            LINKER.defaultLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.defaultLookup().find(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -78,1 +77,1 @@\n-            LINKER.defaultLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().find(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS.asUnbounded(), ValueLayout.JAVA_LONG));\n@@ -80,1 +79,1 @@\n-    public static void freeMemory(Addressable address) {\n+    public static void freeMemory(MemorySegment address) {\n@@ -88,1 +87,1 @@\n-    public static MemoryAddress allocateMemory(long size) {\n+    public static MemorySegment allocateMemory(long size) {\n@@ -90,1 +89,1 @@\n-            return (MemoryAddress)MALLOC.invokeExact(size);\n+            return (MemorySegment)MALLOC.invokeExact(size);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -90,2 +88,2 @@\n-    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint.address());\n+    public MemorySegment panama_identity_memory_address_shared() throws Throwable {\n+        return (MemorySegment) identity_memory_address.invokeExact(sharedPoint);\n@@ -95,2 +93,2 @@\n-    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint.address());\n+    public MemorySegment panama_identity_memory_address_confined() throws Throwable {\n+        return (MemorySegment) identity_memory_address.invokeExact(confinedPoint);\n@@ -100,2 +98,2 @@\n-    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    public MemorySegment panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3.invokeExact(sharedPoint, sharedPoint, sharedPoint);\n@@ -105,2 +103,2 @@\n-    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n+    public MemorySegment panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3.invokeExact(confinedPoint, confinedPoint, confinedPoint);\n@@ -110,2 +108,2 @@\n-    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint);\n+    public MemorySegment panama_identity_memory_address_null() throws Throwable {\n+        return (MemorySegment) identity_memory_address.invokeExact(MemorySegment.NULL);\n@@ -115,2 +113,2 @@\n-    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint);\n+    public MemorySegment panama_identity_memory_address_null_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3.invokeExact(MemorySegment.NULL, MemorySegment.NULL, MemorySegment.NULL);\n@@ -120,17 +118,2 @@\n-    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)MemoryAddress.NULL);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_memory_address_null_non_exact() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invoke(MemoryAddress.NULL);\n+    public MemorySegment panama_identity_memory_address_null_non_exact() throws Throwable {\n+        return (MemorySegment) identity_memory_address.invoke(MemorySegment.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":14,"deletions":31,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n@@ -29,2 +30,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n@@ -45,1 +44,1 @@\n-    static Addressable func_addr;\n+    static MemorySegment func_addr;\n@@ -48,1 +47,1 @@\n-    static Addressable identity_addr;\n+    static MemorySegment identity_addr;\n@@ -51,1 +50,1 @@\n-    static Addressable identity_struct_addr;\n+    static MemorySegment identity_struct_addr;\n@@ -54,1 +53,1 @@\n-    static Addressable identity_struct_3_addr;\n+    static MemorySegment identity_struct_3_addr;\n@@ -57,1 +56,1 @@\n-    static Addressable identity_memory_address_addr;\n+    static MemorySegment identity_memory_address_addr;\n@@ -60,1 +59,1 @@\n-    static Addressable identity_memory_address_3_addr;\n+    static MemorySegment identity_memory_address_3_addr;\n@@ -63,1 +62,1 @@\n-    static Addressable args1_addr;\n+    static MemorySegment args1_addr;\n@@ -66,1 +65,1 @@\n-    static Addressable args2_addr;\n+    static MemorySegment args2_addr;\n@@ -69,1 +68,1 @@\n-    static Addressable args3_addr;\n+    static MemorySegment args3_addr;\n@@ -72,1 +71,1 @@\n-    static Addressable args4_addr;\n+    static MemorySegment args4_addr;\n@@ -75,1 +74,1 @@\n-    static Addressable args5_addr;\n+    static MemorySegment args5_addr;\n@@ -78,1 +77,1 @@\n-    static Addressable args10_addr;\n+    static MemorySegment args10_addr;\n@@ -84,2 +83,2 @@\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.openShared());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.openConfined());\n+    static final MemorySegment sharedPoint = MemorySession.openShared().allocate(POINT_LAYOUT);\n+    static final MemorySegment confinedPoint = MemorySession.openConfined().allocate(POINT_LAYOUT);\n@@ -97,1 +96,1 @@\n-            func_addr = loaderLibs.lookup(\"func\").orElseThrow();\n+            func_addr = loaderLibs.find(\"func\").orElseThrow();\n@@ -104,1 +103,1 @@\n-            identity_addr = loaderLibs.lookup(\"identity\").orElseThrow();\n+            identity_addr = loaderLibs.find(\"identity\").orElseThrow();\n@@ -109,1 +108,1 @@\n-        identity_struct_addr = loaderLibs.lookup(\"identity_struct\").orElseThrow();\n+        identity_struct_addr = loaderLibs.find(\"identity_struct\").orElseThrow();\n@@ -114,1 +113,1 @@\n-        identity_struct_3_addr = loaderLibs.lookup(\"identity_struct_3\").orElseThrow();\n+        identity_struct_3_addr = loaderLibs.find(\"identity_struct_3\").orElseThrow();\n@@ -119,1 +118,1 @@\n-        identity_memory_address_addr = loaderLibs.lookup(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_addr = loaderLibs.find(\"identity_memory_address\").orElseThrow();\n@@ -124,1 +123,1 @@\n-        identity_memory_address_3_addr = loaderLibs.lookup(\"identity_memory_address_3\").orElseThrow();\n+        identity_memory_address_3_addr = loaderLibs.find(\"identity_memory_address_3\").orElseThrow();\n@@ -129,1 +128,1 @@\n-        args1_addr = loaderLibs.lookup(\"args1\").orElseThrow();\n+        args1_addr = loaderLibs.find(\"args1\").orElseThrow();\n@@ -134,1 +133,1 @@\n-        args2_addr = loaderLibs.lookup(\"args2\").orElseThrow();\n+        args2_addr = loaderLibs.find(\"args2\").orElseThrow();\n@@ -139,1 +138,1 @@\n-        args3_addr = loaderLibs.lookup(\"args3\").orElseThrow();\n+        args3_addr = loaderLibs.find(\"args3\").orElseThrow();\n@@ -144,1 +143,1 @@\n-        args4_addr = loaderLibs.lookup(\"args4\").orElseThrow();\n+        args4_addr = loaderLibs.find(\"args4\").orElseThrow();\n@@ -149,1 +148,1 @@\n-        args5_addr = loaderLibs.lookup(\"args5\").orElseThrow();\n+        args5_addr = loaderLibs.find(\"args5\").orElseThrow();\n@@ -154,1 +153,1 @@\n-        args10_addr = loaderLibs.lookup(\"args10\").orElseThrow();\n+        args10_addr = loaderLibs.find(\"args10\").orElseThrow();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":28,"deletions":29,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -84,2 +82,2 @@\n-    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)sharedPoint.address());\n+    public MemorySegment panama_identity_memory_address_shared() throws Throwable {\n+        return (MemorySegment) identity_memory_address_v.invokeExact(identity_memory_address_addr, sharedPoint);\n@@ -89,2 +87,2 @@\n-    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)confinedPoint.address());\n+    public MemorySegment panama_identity_memory_address_confined() throws Throwable {\n+        return (MemorySegment) identity_memory_address_v.invokeExact(identity_memory_address_addr, confinedPoint);\n@@ -94,2 +92,2 @@\n-    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    public MemorySegment panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, sharedPoint, sharedPoint, sharedPoint);\n@@ -99,22 +97,2 @@\n-    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_struct_addr, (Addressable)sharedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_struct_addr, (Addressable)confinedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_struct_3_addr, (Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_struct_3_addr, (Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n+    public MemorySegment panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, confinedPoint, confinedPoint, confinedPoint);\n@@ -134,2 +112,2 @@\n-    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)MemoryAddress.NULL);\n+    public MemorySegment panama_identity_memory_address_null() throws Throwable {\n+        return (MemorySegment) identity_memory_address_v.invokeExact(identity_memory_address_addr, MemorySegment.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":10,"deletions":32,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,3 +29,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -37,5 +35,0 @@\n-    static final ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-\n-    static final ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-\n-    static final ValueLayout.OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n@@ -47,7 +40,0 @@\n-    static final VarHandle VH_FLOAT_UNALIGNED = JAVA_FLOAT_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_FLOAT = JAVA_FLOAT.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -62,1 +62,1 @@\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, session));\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(session.allocate(ALLOC_LAYOUT));\n@@ -81,1 +81,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n+            MemorySegment segment = session.allocate(ALLOC_SIZE, 4);\n@@ -91,1 +91,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n+            MemorySegment segment = session.allocate(ALLOC_SIZE, 4);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNewHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -69,1 +69,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.openConfined());\n+        segment = MemorySession.openConfined().allocate(ALLOC_SIZE);\n@@ -160,18 +160,0 @@\n-    @Benchmark\n-    public int segment_loop_instance_address() {\n-        int sum = 0;\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            sum += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public int segment_loop_instance_address_index() {\n-        int sum = 0;\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            sum += segment.address().getAtIndex(JAVA_INT, i);\n-        }\n-        return sum;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n-        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, session);\n-        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, session);\n+        segmentIn = session.allocate(ALLOC_SIZE);\n+        segmentOut = session.allocate(ALLOC_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,4 +44,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -81,1 +78,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, MemorySession.openConfined());\n+            MemorySegment s = MemorySession.openConfined().allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -50,1 +51,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -97,1 +98,1 @@\n-        unsafe_addr = segment.address().toRawLongValue();\n+        unsafe_addr = segment.address();\n@@ -152,9 +153,0 @@\n-    @Benchmark\n-    public int segment_loop_instance_address() {\n-        int res = 0;\n-        for (int i = 0; i < ELEM_SIZE; i ++) {\n-            res += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n-        }\n-        return res;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, MemorySession.openConfined());\n+        segment = MemorySession.openConfined().allocate(ALLOC_SIZE, CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+public class LoopOverOfAddress extends JavaLayouts {\n+\n+    static final int ITERATIONS = 1_000_000;\n+\n+    @Benchmark\n+    public long segment_loop_addr() {\n+        long res = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            res += MemorySegment.ofAddress(i % 100).address();\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public long segment_loop_addr_size() {\n+        long res = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            res += MemorySegment.ofAddress(i, i % 100).address();\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public long segment_loop_addr_size_session() {\n+        long res = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            res += MemorySegment.ofAddress(i, i % 100, MemorySession.global()).address();\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -70,2 +70,3 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, session = MemorySession.openConfined());\n-        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n+        session = MemorySession.openConfined();\n+        nativeSegment = session.allocate(ALLOC_SIZE, 4);\n+        nativeSharedSegment = session.allocate(ALLOC_SIZE, 4); \/\/ <- This segment is not shared!\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.openConfined());\n+        nativeSegment = MemorySession.openConfined().allocate(ALLOC_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-            return MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n+            return session.allocate(ALLOC_SIZE, 4);\n@@ -115,1 +115,1 @@\n-            return MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n+            return session.allocate(ALLOC_SIZE, 4);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, MemorySession.openShared());\n+        segment = MemorySession.openShared().allocate(ALLOC_SIZE, CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.Addressable;\n@@ -32,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -36,2 +35,0 @@\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.Param;\n@@ -45,0 +42,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -58,1 +56,1 @@\n-    MemorySegment segment = MemorySegment.allocateNative(100, session);\n+    MemorySegment segment = session.allocate(100);\n@@ -69,1 +67,1 @@\n-        F_LONG = abi.downcallHandle(loaderLibs.lookup(\"func_as_long\").get(),\n+        F_LONG = abi.downcallHandle(loaderLibs.find(\"func_as_long\").get(),\n@@ -71,1 +69,1 @@\n-        F_PTR = abi.downcallHandle(loaderLibs.lookup(\"func_as_ptr\").get(),\n+        F_PTR = abi.downcallHandle(loaderLibs.find(\"func_as_ptr\").get(),\n@@ -82,1 +80,1 @@\n-        return (int)F_LONG.invokeExact(segment.address().toRawLongValue());\n+        return (int)F_LONG.invokeExact(segment.address());\n@@ -87,6 +85,1 @@\n-        return (int)F_PTR.invokeExact((Addressable)segment.address());\n-    }\n-\n-    @Benchmark\n-    public int panama_call_as_segment() throws Throwable {\n-        return (int)F_PTR.invokeExact((Addressable)segment);\n+        return (int)F_PTR.invokeExact(segment);\n@@ -98,1 +91,1 @@\n-        return (int)F_PTR.invokeExact((Addressable)newSegment);\n+        return (int)F_PTR.invokeExact(newSegment);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -28,1 +27,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -59,2 +57,2 @@\n-    static final Addressable native_compar;\n-    static final Addressable panama_upcall_compar;\n+    static final MemorySegment native_compar;\n+    static final MemorySegment panama_upcall_compar;\n@@ -66,1 +64,1 @@\n-    static Addressable qsort_addr = abi.defaultLookup().lookup(\"qsort\").get();\n+    static MemorySegment qsort_addr = abi.defaultLookup().find(\"qsort\").get();\n@@ -69,1 +67,1 @@\n-        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), MemorySession.global());\n+        INPUT_SEGMENT = MemorySession.global().allocate(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT));\n@@ -81,1 +79,1 @@\n-            native_compar = SymbolLookup.loaderLookup().lookup(\"compar\").orElseThrow();\n+            native_compar = SymbolLookup.loaderLookup().find(\"compar\").orElseThrow();\n@@ -85,1 +83,1 @@\n-                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)),\n+                            MethodType.methodType(int.class, MemorySegment.class, MemorySegment.class)),\n@@ -106,1 +104,1 @@\n-         clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)native_compar);\n+         clib_qsort.invokeExact(INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), native_compar);\n@@ -121,1 +119,1 @@\n-        clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)panama_upcall_compar);\n+        clib_qsort.invokeExact(INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), panama_upcall_compar);\n@@ -124,6 +122,2 @@\n-    private static int getIntAbsolute(MemoryAddress addr) {\n-        return addr.get(JAVA_INT, 0);\n-    }\n-\n-    static int panama_upcall_compar(MemoryAddress e0, MemoryAddress e1) {\n-        return Integer.compare(getIntAbsolute(e0), getIntAbsolute(e1));\n+    static int panama_upcall_compar(MemorySegment e0, MemorySegment e1) {\n+        return Integer.compare(e0.get(JAVA_INT, 0), e1.get(JAVA_INT, 0));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.Addressable;\n@@ -31,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -35,0 +33,1 @@\n+\n@@ -77,1 +76,1 @@\n-        STRLEN = abi.downcallHandle(abi.defaultLookup().lookup(\"strlen\").get(),\n+        STRLEN = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n@@ -84,1 +83,1 @@\n-        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, MemorySession.openConfined()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySession.openConfined().allocate(size + 1));\n@@ -100,1 +99,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(str.length() + 1, session);\n+            MemorySegment segment = session.allocate(str.length() + 1);\n@@ -102,1 +101,1 @@\n-            return (int)STRLEN.invokeExact((Addressable)segment);\n+            return (int)STRLEN.invokeExact(segment);\n@@ -108,1 +107,1 @@\n-        return (int)STRLEN.invokeExact((Addressable)arenaAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(arenaAllocator.allocateUtf8String(str));\n@@ -113,1 +112,1 @@\n-        return (int)STRLEN.invokeExact((Addressable)segmentAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(segmentAllocator.allocateUtf8String(str));\n@@ -118,2 +117,2 @@\n-        MemoryAddress address = makeStringUnsafe(str);\n-        int res = (int) STRLEN.invokeExact((Addressable)address);\n+        MemorySegment address = makeStringUnsafe(str);\n+        int res = (int) STRLEN.invokeExact(address);\n@@ -124,1 +123,1 @@\n-    static MemoryAddress makeStringUnsafe(String s) {\n+    static MemorySegment makeStringUnsafe(String s) {\n@@ -127,2 +126,2 @@\n-        MemoryAddress address = allocateMemory(len + 1);\n-        MemorySegment str = MemorySegment.ofAddress(address, len + 1, MemorySession.global());\n+        MemorySegment address = allocateMemory(len + 1);\n+        MemorySegment str = address.asSlice(0, len + 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -34,1 +35,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -46,0 +47,4 @@\n+    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n+\n+    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n+\n@@ -64,2 +69,2 @@\n-            this.inputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(inputAddress), 8*SIZE, MemorySession.global());\n-            this.outputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(outputAddress), 8*SIZE, MemorySession.global());\n+            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, MemorySession.global());\n+            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, MemorySession.global());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -59,4 +59,4 @@\n-    static final Addressable cb_blank;\n-    static final Addressable cb_identity;\n-    static final Addressable cb_args5;\n-    static final Addressable cb_args10;\n+    static final MemorySegment cb_blank;\n+    static final MemorySegment cb_identity;\n+    static final MemorySegment cb_args5;\n+    static final MemorySegment cb_args10;\n@@ -125,1 +125,1 @@\n-                SymbolLookup.loaderLookup().lookup(name).orElseThrow(),\n+                SymbolLookup.loaderLookup().find(name).orElseThrow(),\n@@ -130,1 +130,1 @@\n-    static Addressable makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+    static MemorySegment makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n@@ -150,1 +150,1 @@\n-        blank.invokeExact((Addressable)cb_blank);\n+        blank.invokeExact(cb_blank);\n@@ -170,1 +170,1 @@\n-        return (int) identity.invokeExact(10, (Addressable)cb_identity);\n+        return (int) identity.invokeExact(10, cb_identity);\n@@ -175,1 +175,1 @@\n-        args5.invokeExact(1L, 2D, 3L, 4D, 5L, (Addressable)cb_args5);\n+        args5.invokeExact(1L, 2D, 3L, 4D, 5L, cb_args5);\n@@ -180,1 +180,1 @@\n-        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, (Addressable)cb_args10);\n+        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -60,3 +60,4 @@\n-        MH_ellipsis = linker.downcallHandle(loaderLibs.lookup(\"ellipsis\").get(),\n-                FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_DOUBLE, C_LONG_LONG));\n-        MH_vaList = linker.downcallHandle(loaderLibs.lookup(\"vaList\").get(),\n+        MH_ellipsis = linker.downcallHandle(loaderLibs.find(\"ellipsis\").get(),\n+                FunctionDescriptor.ofVoid(C_INT, C_INT, C_DOUBLE, C_LONG_LONG),\n+                Linker.Option.firstVariadicArg(1));\n+        MH_vaList = linker.downcallHandle(loaderLibs.find(\"vaList\").get(),\n@@ -80,1 +81,1 @@\n-                    (Addressable)vaList);\n+                    vaList.segment());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        data = MemorySegment.allocateNative(JAVA_INT, MemorySession.openConfined());\n+        data = MemorySession.openConfined().allocate(JAVA_INT);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+public sealed abstract class NativeType<X> {\n+\n+    public abstract MemoryLayout layout();\n+\n+    public non-sealed static abstract class OfInt<X> extends NativeType<X> {\n+        public abstract ValueLayout.OfInt layout();\n+    }\n+    public non-sealed static abstract class OfDouble<X> extends NativeType<X> {\n+        public abstract ValueLayout.OfDouble layout();\n+    }\n+\n+    private static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS.asUnbounded();\n+\n+    public final static class OfPointer<X> extends NativeType<X> {\n+        public ValueLayout.OfAddress layout() {\n+            return UNSAFE_ADDRESS;\n+        }\n+    }\n+\n+    public non-sealed static abstract class OfStruct<X> extends NativeType<X> {\n+        public abstract GroupLayout layout();\n+        public abstract X make(Pointer<X> ptr);\n+    }\n+\n+    public static final OfInt<Integer> C_INT = new OfInt<>() {\n+        @Override\n+        public ValueLayout.OfInt layout() {\n+            return ValueLayout.JAVA_INT;\n+        }\n+    };\n+\n+    public static final OfDouble<Double> C_DOUBLE = new OfDouble<>() {\n+        @Override\n+        public ValueLayout.OfDouble layout() {\n+            return ValueLayout.JAVA_DOUBLE;\n+        }\n+    };\n+\n+    @SuppressWarnings(\"unchecked\")\n+    final static OfPointer C_VOID_PTR = new OfPointer();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static final OfPointer<Pointer<Integer>> C_INT_PTR = NativeType.C_VOID_PTR;\n+    @SuppressWarnings(\"unchecked\")\n+    public static final OfPointer<Pointer<Double>> C_DOUBLE_PTR = NativeType.C_VOID_PTR;\n+\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <Z> OfPointer<Pointer<Z>> ptr(NativeType<Z> type) {\n+        return NativeType.C_VOID_PTR;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+public class Point extends Struct<Point> {\n+\n+    Point(Pointer<Point> ptr) {\n+        super(ptr);\n+    }\n+\n+    int x() {\n+        return ptr.segment.get(NativeType.C_INT.layout(),  0);\n+    }\n+    int y() {\n+        return ptr.segment.get(NativeType.C_INT.layout(),  4);\n+    }\n+\n+    static Point wrap(MemorySegment segment) {\n+        return new Point(Pointer.wrap(TYPE, segment));\n+    }\n+\n+    static final NativeType.OfStruct<Point> TYPE = new NativeType.OfStruct<Point>() {\n+        static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"));\n+\n+        @Override\n+        public GroupLayout layout() {\n+            return LAYOUT;\n+        }\n+\n+        @Override\n+        public Point make(Pointer<Point> pointer) {\n+            return new Point(pointer);\n+        }\n+    };\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Point.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+\n+public class Pointer<X> {\n+\n+    final MemorySegment segment;\n+\n+    Pointer(MemorySegment segment) {\n+        this.segment = segment;\n+    }\n+\n+    public <Z extends NativeType.OfInt<X>> int get(Z type, long index) {\n+        return segment.getAtIndex(type.layout(), index);\n+    }\n+\n+    public <Z extends NativeType.OfDouble<X>> double get(Z type, long index) {\n+        return segment.getAtIndex(type.layout(), index);\n+    }\n+\n+    public <Z extends NativeType.OfStruct<X>> X get(Z type, long index) {\n+        return type.make(addOffset(index * type.layout().byteSize()));\n+    }\n+\n+    public Pointer<X> addOffset(long offset) {\n+        return new Pointer<>(segment.asSlice(offset));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <Z extends NativeType.OfPointer<X>> X get(Z type, long index) {\n+        MemorySegment address = segment.getAtIndex(type.layout(), index);\n+        return (X)new Pointer<>(address);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public X get(NativeType<X> type, long offset) {\n+        if (type instanceof NativeType.OfInt intType) {\n+            return (X) (Object) get(intType, offset);\n+        } else if (type instanceof NativeType.OfDouble doubleType) {\n+            return (X) (Object) get(doubleType, offset);\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public MemorySegment segment() {\n+        return segment;\n+    }\n+\n+    public static <X> Pointer<X> allocate(NativeType<X> type, SegmentAllocator allocator) {\n+        MemorySegment segment = allocator.allocate(type.layout());\n+        return new Pointer<>(segment);\n+    }\n+\n+    public static <X> Pointer<X> allocate(NativeType<X> type, long size, SegmentAllocator allocator) {\n+        MemorySegment segment = allocator.allocateArray(type.layout(), size);\n+        return new Pointer<>(segment);\n+    }\n+\n+    public static <X> Pointer<X> wrap(NativeType<X> type, MemorySegment segment) {\n+        return new Pointer<>(segment);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Pointer.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@State(Scope.Benchmark)\n+public class PointerBench {\n+\n+    final MemorySession session = MemorySession.openConfined();\n+    static final int ELEM_SIZE = 1_000_000;\n+    Pointer<Integer> intPointer = Pointer.allocate(NativeType.C_INT, ELEM_SIZE, session);\n+    Pointer<Pointer<Integer>> intPointerPointer = Pointer.allocate(NativeType.C_INT_PTR, ELEM_SIZE, session);\n+    Pointer<Point> pointPointer = Pointer.allocate(Point.TYPE, ELEM_SIZE, session);\n+    MemorySegment intSegment = intPointer.segment();\n+    MemorySegment intPointerSegment = intPointerPointer.segment();\n+    MemorySegment pointSegment = pointPointer.segment();\n+\n+    public static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS.asUnbounded();\n+\n+    @Setup\n+    public void setup() {\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            intSegment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n+            intPointerSegment.setAtIndex(ValueLayout.ADDRESS, i, intSegment.asSlice(4 * i));\n+            pointSegment.setAtIndex(ValueLayout.JAVA_INT, (i * 2), i);\n+            pointSegment.setAtIndex(ValueLayout.JAVA_INT, (i * 2) + 1, i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        session.close();\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerInt_ptr() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += intPointer.get(NativeType.C_INT, i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerPointerInt_ptr() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += intPointerPointer.get(NativeType.C_INT_PTR, i)\n+                                    .get(NativeType.C_INT, 0);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerPoint_ptr() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += pointPointer.get(Point.TYPE, i).x();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerInt_ptr_generic() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += genericGet(intPointer, NativeType.C_INT, i);\n+        }\n+        return sum;\n+    }\n+\n+    static <Z> Z genericGet(Pointer<Z> pz, NativeType<Z> type, long offset) {\n+        return pz.get(type, offset);\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerInt_segment() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += intSegment.getAtIndex(ValueLayout.JAVA_INT, i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerPointerInt_segment() {\n+        int sum = 0;\n+        for (long i = 0 ; i < ELEM_SIZE ; i++) {\n+            var segment = intPointerSegment.getAtIndex(UNSAFE_ADDRESS, i);\n+            sum += segment.get(ValueLayout.JAVA_INT, 0);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerPoint_segment() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += pointSegment.getAtIndex(ValueLayout.JAVA_INT, i * 2);\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+public abstract class Struct<X extends Struct<X>> {\n+    protected final Pointer<X> ptr;\n+\n+    public Struct(Pointer<X> ptr) {\n+        this.ptr = ptr;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Struct.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -56,1 +55,1 @@\n-                loaderLibs.lookup(\"distance\").get(),\n+                loaderLibs.find(\"distance\").get(),\n@@ -60,1 +59,1 @@\n-                loaderLibs.lookup(\"distance_ptrs\").get(),\n+                loaderLibs.find(\"distance_ptrs\").get(),\n@@ -68,1 +67,1 @@\n-        this.segment = MemorySegment.allocateNative(LAYOUT, MemorySession.openConfined());\n+        this.segment = MemorySession.openConfined().allocate(LAYOUT);\n@@ -99,1 +98,1 @@\n-            return (double) MH_distance_ptrs.invokeExact((Addressable)segment, (Addressable)other.segment);\n+            return (double) MH_distance_ptrs.invokeExact(segment, other.segment);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -46,2 +45,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-\n@@ -73,3 +70,0 @@\n-\n-  private MemorySession implicitScope;\n-\n@@ -80,5 +74,0 @@\n-\n-  private MemoryAddress srcAddress;\n-\n-  private MemoryAddress dstAddress;\n-\n@@ -98,6 +87,2 @@\n-    implicitScope = MemorySession.openImplicit();\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-\n-    srcAddress = srcSegment.address();\n-    dstAddress = dstSegment.address();\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.openImplicit());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.openImplicit());\n@@ -181,2 +166,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcAddress, size, session);\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstAddress, size, session);\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, session);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, session);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -29,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -74,3 +74,0 @@\n-\n-  private MemorySession implicitScope;\n-\n@@ -81,5 +78,0 @@\n-\n-  private MemoryAddress srcAddress;\n-\n-  private MemoryAddress dstAddress;\n-\n@@ -100,6 +92,2 @@\n-    implicitScope = MemorySession.openImplicit();\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-\n-    srcAddress = srcSegment.address();\n-    dstAddress = dstSegment.address();\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.openImplicit());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.openImplicit());\n@@ -176,2 +164,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcAddress, size, session);\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstAddress, size, session);\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, session);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, session);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"}]}