{"files":[{"patch":"@@ -37,2 +37,2 @@\n- * A function descriptor is made up of zero or more argument layouts and zero or one return layout. A function descriptor\n- * is used to model the signature of foreign functions when creating\n+ * A function descriptor models the signature of foreign functions. A function descriptor is made up of zero or more\n+ * argument layouts and zero or one return layout. A function descriptor is typically used when creating\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * can be combined: if member layouts are laid out one after the other, the resulting group layout is said to be a <em>struct<\/em>\n+ * can be combined: if member layouts are laid out one after the other, the resulting group layout is said to be a <em>struct layout<\/em>\n@@ -35,1 +35,1 @@\n- * the resulting group layout is said to be a <em>union<\/em> (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ * the resulting group layout is said to be a <em>union layout<\/em> (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-     * A linker option that can be used to indicate additional linking requirements to the linker,\n+     * A linker option is used to indicate additional linking requirements to the linker,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * A memory layout can be used to describe the contents of a memory segment.\n+ * A memory layout describes the contents of a memory segment.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n- * scope; that is, if the segment is the {@linkplain SegmentScope#global() global scope} or an {@linkplain SegmentScope#auto() automatic scope},\n+ * scope; that is, if the segment is associated with the {@linkplain SegmentScope#global() global scope} or an {@linkplain SegmentScope#auto() automatic scope},\n@@ -131,2 +131,2 @@\n- * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view var handle},\n- * that is, a var handle that accepts a segment and a {@code long} offset. More complex access var handles\n+ * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) var handle}\n+ * that accepts a segment and a {@code long} offset. More complex var handles\n@@ -147,1 +147,1 @@\n- * Alternatively, complex access var handles can can be obtained\n+ * Alternatively, complex var handles can can be obtained\n@@ -176,1 +176,1 @@\n- * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@link SegmentScope#isAlive()},\n+ * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@linkplain SegmentScope#isAlive() alive},\n@@ -331,2 +331,2 @@\n- * Alternatively, they can invoke the access operation with a layout whose alignment is smaller:\n- *\n+ * Alternatively, they can invoke the access operation with an <em>unaligned layout<\/em>.\n+ * All unaligned layout constants (e.g. {@link ValueLayout#JAVA_INT_UNALIGNED}) have their alignment constraint set to 1:\n@@ -335,1 +335,1 @@\n- * byteSegment.get(ValueLayout.JAVA_INT.withBitAlignment(8), 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n+ * byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * A <em>struct<\/em> layout where member layouts are laid out one after the other (see {@link MemoryLayout#structLayout(MemoryLayout...)}).\n+ * A group layout whose member layouts are laid out one after the other.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * A <em>symbol lookup<\/em> is an object that may be used to retrieve the address of a symbol in one or more libraries.\n+ * A <em>symbol lookup<\/em> retrieves the address of a symbol in one or more libraries.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * A <em>union<\/em> layout where member layouts are laid out at the same starting offset (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ * A group layout whose member layouts are laid out at the same starting offset.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,5 @@\n- * A value layout. A value layout is used to model the memory layout associated with values of basic data types, such as <em>integral<\/em> types\n- * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment (in bits),\n+ * A layout that models values of basic data types. Examples of values modelled by a value layout are\n+ * <em>integral<\/em> values (either signed or unsigned), <em>floating-point<\/em> values and\n+ * <em>address<\/em> values.\n+ * <p>\n+ * Each value layout has a size, an alignment (in bits),\n@@ -69,1 +72,1 @@\n-     * Creates a <em>strided<\/em> access var handle that can be used to access a memory segment as multi-dimensional\n+     * Creates a <em>strided<\/em> var handle that can be used to access a memory segment as multi-dimensional\n@@ -148,2 +151,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_BOOLEAN}.\n@@ -151,0 +152,1 @@\n+     * @see #JAVA_BOOLEAN\n@@ -178,2 +180,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_BYTE}.\n@@ -181,0 +181,1 @@\n+     * @see #JAVA_BYTE\n@@ -208,2 +209,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_CHAR}.\n@@ -211,0 +210,2 @@\n+     * @see #JAVA_CHAR\n+     * @see #JAVA_CHAR_UNALIGNED\n@@ -238,2 +239,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_SHORT}.\n@@ -241,0 +240,2 @@\n+     * @see #JAVA_SHORT\n+     * @see #JAVA_SHORT_UNALIGNED\n@@ -268,2 +269,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_INT}.\n@@ -271,0 +270,2 @@\n+     * @see #JAVA_INT\n+     * @see #JAVA_INT_UNALIGNED\n@@ -298,2 +299,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_FLOAT}.\n@@ -301,0 +300,2 @@\n+     * @see #JAVA_FLOAT\n+     * @see #JAVA_FLOAT_UNALIGNED\n@@ -328,2 +329,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_LONG}.\n@@ -331,0 +330,2 @@\n+     * @see #JAVA_LONG\n+     * @see #JAVA_LONG_UNALIGNED\n@@ -358,2 +359,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_LONG}.\n@@ -361,0 +360,2 @@\n+     * @see #JAVA_DOUBLE\n+     * @see #JAVA_DOUBLE_UNALIGNED\n@@ -388,2 +389,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #ADDRESS}.\n@@ -391,0 +390,2 @@\n+     * @see #ADDRESS\n+     * @see #ADDRESS_UNALIGNED\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * using {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) access var handles},\n+ * using {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) var handles},\n@@ -170,1 +170,1 @@\n- *                                                 Linker.upcallType(comparFunction));\n+ *                                                 intCompareDescriptor.toMethodType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}