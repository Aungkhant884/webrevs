{"files":[{"patch":"@@ -3942,1 +3942,1 @@\n-static void warn_on_commit_special_failure(char* req_addr, size_t bytes,\n+static void log_on_commit_special_failure(char* req_addr, size_t bytes,\n@@ -3946,13 +3946,4 @@\n-  bool warn_on_failure = UseLargePages &&\n-      (!FLAG_IS_DEFAULT(UseLargePages) ||\n-       !FLAG_IS_DEFAULT(UseHugeTLBFS) ||\n-       !FLAG_IS_DEFAULT(LargePageSizeInBytes));\n-\n-  if (warn_on_failure) {\n-    char msg[128];\n-    jio_snprintf(msg, sizeof(msg), \"Failed to reserve and commit memory. req_addr: \"\n-                                   PTR_FORMAT \" bytes: \" SIZE_FORMAT \" page size: \"\n-                                   SIZE_FORMAT \" (errno = %d).\",\n-                                   req_addr, bytes, page_size, error);\n-    warning(\"%s\", msg);\n-  }\n+  log_info(pagesize)(\"Failed to reserve and commit memory with given page size. req_addr: \" PTR_FORMAT\n+                     \" size: \" SIZE_FORMAT \"%s, page size: \" SIZE_FORMAT \"%s, (errno = %d)\",\n+                     p2i(req_addr), byte_size_in_exact_unit(bytes), exact_unit_for_byte_size(bytes),\n+                     byte_size_in_exact_unit(page_size), exact_unit_for_byte_size(page_size), error);\n@@ -3980,1 +3971,1 @@\n-    warn_on_commit_special_failure(req_addr, bytes, page_size, errno);\n+    log_on_commit_special_failure(req_addr, bytes, page_size, errno);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -142,0 +142,13 @@\n+static void log_on_large_pages_failure(char* req_addr, size_t bytes) {\n+  if (large_pages_requested()) {\n+    \/\/ Compressed oops logging.\n+    log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n+    \/\/ JVM style warning that we did not succeed in using large pages.\n+    char msg[128];\n+    jio_snprintf(msg, sizeof(msg), \"Failed to reserve and commit memory using large pages. \"\n+                                   \"req_addr: \" PTR_FORMAT \" bytes: \" SIZE_FORMAT,\n+                                   req_addr, bytes);\n+    warning(\"%s\", msg);\n+  }\n+}\n+\n@@ -186,4 +199,0 @@\n-  } else {\n-    if (large_pages_requested()) {\n-      log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n-    }\n@@ -238,0 +247,10 @@\n+    size_t used_page_size = page_size;\n+    char* base = NULL;\n+\n+    do {\n+      base = reserve_memory_special(requested_address, size, alignment, used_page_size, executable);\n+      if (base != NULL) {\n+        break;\n+      }\n+      used_page_size = os::page_sizes().next_smaller(used_page_size);\n+    } while (used_page_size > (size_t) os::vm_page_size());\n@@ -239,1 +258,0 @@\n-    char* base = reserve_memory_special(requested_address, size, alignment, page_size, executable);\n@@ -242,1 +260,1 @@\n-      initialize_members(base, size, alignment, page_size, true, executable);\n+      initialize_members(base, size, alignment, used_page_size, true, executable);\n@@ -245,1 +263,3 @@\n-    \/\/ Failed to reserve explicit large pages, fall back to normal reservation.\n+    \/\/ Failed to reserve explicit large pages, do proper logging.\n+    log_on_large_pages_failure(requested_address, size);\n+    \/\/ Now fall back to normal reservation.\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.os;\n+\n+\/* @test\n+ * @bug 8271195\n+ * @summary Use largest available large page size smaller than LargePageSizeInBytes when available.\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc != \"Z\"\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI\n+ *      runtime.os.TestExplicitPageAllocation\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Utils;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import java.util.List;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.util.Scanner;\n+import java.io.FileWriter;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestExplicitPageAllocation {\n+\n+    private static final String DIR_HUGE_PAGES = \"\/sys\/kernel\/mm\/hugepages\/\";\n+    private static final int HEAP_SIZE_IN_KB = 1 * 1024 * 1024;\n+\n+    private static final Pattern HEAP_PATTERN = Pattern.compile(\"Heap:\");\n+    private static final Pattern PAGE_SIZE_PATTERN = Pattern.compile(\".*page_size=([^ ]+).*\");\n+    private static final Pattern HUGEPAGE_PATTERN = Pattern.compile(\".*hugepages-([^ ]+).*kB\");\n+\n+    private static FileInputStream fis;\n+    private static DataInputStream dis;\n+    private static String errorMessage = null;\n+\n+    private static final int MAX_NUMBER_OF_PAGESIZE = 64;\n+    private static boolean[] pageSizes = new boolean[MAX_NUMBER_OF_PAGESIZE];\n+    private static int[] pageCount = new int[MAX_NUMBER_OF_PAGESIZE];\n+    private static int vmPageSizeIndex;\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String args[]) {\n+        try {\n+            doSetup();\n+            for (int i = MAX_NUMBER_OF_PAGESIZE - 1; i > vmPageSizeIndex; i--) {\n+                if (pageSizes[i]) {\n+                    testCase(i);\n+                    break;\n+                }\n+            }\n+        } catch (Exception e) {\n+           System.out.println(\"Exception \" + e);\n+        }\n+\n+    }\n+\n+    private static int requiredPageCount(int index) {\n+        int pageSizeInKB = 1 << (index - 10);\n+        return HEAP_SIZE_IN_KB \/ pageSizeInKB;\n+    }\n+\n+    private static String sizeFromIndex(int index) {\n+        int k = 1024;\n+        int m = 1024 * 1024;\n+        int g = 1024 * 1024 * 1024;\n+        int sizeInBytes = 1 << index;\n+        if (sizeInBytes < m)\n+           return Integer.toString(sizeInBytes \/ k) + \"K\";\n+        if (sizeInBytes < g)\n+           return Integer.toString(sizeInBytes \/ m) + \"M\";\n+        else\n+           return Integer.toString(sizeInBytes \/ g) + \"G\";\n+    }\n+\n+    private static boolean checkOutput(OutputAnalyzer out, String pageSize) throws Exception {\n+        List<String> lines = out.asLines();\n+        for (int i = 0; i < lines.size(); ++i) {\n+            String line = lines.get(i);\n+            System.out.println(line);\n+            if (HEAP_PATTERN.matcher(line).find()) {\n+                Matcher trace = PAGE_SIZE_PATTERN.matcher(line);\n+                trace.find();\n+                String tracePageSize = trace.group(1);\n+                if (pageSize.contains(tracePageSize)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static int checkAndReadFile(String filename, String pageSize) throws Exception {\n+        fis = new FileInputStream(filename);\n+        dis = new DataInputStream(fis);\n+        int pagecount = Integer.parseInt(dis.readLine());\n+        dis.close();\n+        fis.close();\n+        return pagecount;\n+    }\n+\n+    public static void doSetup() throws Exception {\n+        \/\/ Large page sizes\n+        File[] directories = new File(DIR_HUGE_PAGES).listFiles(File::isDirectory);\n+        for (File dir : directories) {\n+            String pageSizeFileName = dir.getName();\n+            Matcher matcher = HUGEPAGE_PATTERN.matcher(pageSizeFileName);\n+            matcher.find();\n+            String pageSize = matcher.group(1);\n+            assert pageSize != null;\n+            int availablePages = checkAndReadFile(DIR_HUGE_PAGES + pageSizeFileName + \"\/free_hugepages\", pageSize);\n+            if (availablePages == 0) {\n+                System.out.println(\"No Pages configured for \" + pageSize + \"kB\");\n+            }\n+            int index = Integer.numberOfTrailingZeros(Integer.parseInt(pageSize) * 1024);\n+            pageSizes[index] = true;\n+            pageCount[index] = availablePages;\n+        }\n+        \/\/ OS vm page size\n+        vmPageSizeIndex = Integer.numberOfTrailingZeros(wb.getVMPageSize());\n+        pageSizes[vmPageSizeIndex] = true;\n+        pageCount[vmPageSizeIndex] = Integer.MAX_VALUE;\n+    }\n+\n+    public static void testCase(int index) throws Exception {\n+        String pageSize = sizeFromIndex(index);\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:pagesize\",\n+                                                                  \"-XX:LargePageSizeInBytes=\"+ pageSize,\n+                                                                  \"-XX:+UseParallelGC\",\n+                                                                  \"-XX:+UseLargePages\",\n+                                                                  \"-Xmx2g\",\n+                                                                  \"-Xms1g\",\n+                                                                  \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        for (int i = index; i >= vmPageSizeIndex; i--) {\n+            if (pageSizes[i]) {\n+                String size = sizeFromIndex(i);\n+                System.out.println(\"Checking allocation for \" + size);\n+                if (!checkOutput(output, size)) {\n+                    if (requiredPageCount(i) > pageCount[i]) {\n+                       continue;\n+                    }\n+                    errorMessage += \"TestCase Failed for \" + size + \" page allocation\\n\";\n+                } else {\n+                    System.out.println(\"TestCase Passed for pagesize: \" + pageSize + \", allocated pagesize: \" + size);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (errorMessage != null) {\n+            throw new AssertionError(errorMessage);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestExplicitPageAllocation.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/\/\n+\/\/ Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.vm.gc;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MINUTES)\n+@State(Scope.Thread)\n+public class MicroLargePages {\n+\n+    @Param({\"1073741824\"})\n+    public int ARRAYSIZE;\n+\n+    @Param({\"1\", \"2\", \"4\"})\n+    public int NUM;\n+\n+    public static final int ITERS = 100;\n+\n+    public long[][] INP;\n+    public long[][] OUT;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        INP = new long[NUM][ARRAYSIZE];\n+        OUT = new long[NUM][ARRAYSIZE];\n+\n+        for (int i = 0; i < NUM; i++) {\n+            Arrays.fill(INP[i], 10);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void micro_HOP_DIST_4KB() {\n+        for (int i = 0; i < ITERS ; i++) {\n+            for (int j = 0; j < NUM; j += 1) {\n+                for (int k = 0; k < ARRAYSIZE; k += 512) {\n+                    OUT[j][k] = INP[j][k];\n+                }\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/MicroLargePages.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}