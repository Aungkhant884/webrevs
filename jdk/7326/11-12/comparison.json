{"files":[{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package runtime.os;\n-\n-\/* @test\n- * @bug 8271195\n- * @summary Use largest available large page size smaller than LargePageSizeInBytes when available.\n- * @requires os.family == \"linux\"\n- * @requires vm.bits == 64\n- * @requires vm.gc != \"Z\"\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI runtime.os.TestExplicitPageAllocation\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Utils;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import java.util.*;\n-import java.io.*;\n-import java.util.Scanner;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class TestExplicitPageAllocation {\n-\n-    private static final String DIR_HUGE_PAGES = \"\/sys\/kernel\/mm\/hugepages\/\";\n-    private static final long HEAP_SIZE_IN_KB = 2 * 1024 * 1024;\n-    private static final long CODE_CACHE_SIZE_IN_KB = 256 * 1024;\n-    private static final Pattern HEAP_PATTERN = Pattern.compile(\"Heap:\");\n-    private static final Pattern PAGE_SIZE_PATTERN = Pattern.compile(\".*page_size=([^ ]+).*\");\n-    private static final Pattern HUGEPAGE_PATTERN = Pattern.compile(\".*hugepages-([^ ]+).*kB\");\n-    private static TreeMap<Long, Integer> treeMap = new TreeMap<Long, Integer>(Collections.reverseOrder());\n-    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-    public static void main(String args[]) throws Exception {\n-        try {\n-            doSetup();\n-        } catch (Exception e) {\n-            System.out.println(\"Setup Exception \" + e);\n-            return;\n-        }\n-        testCase(treeMap.firstKey());\n-    }\n-\n-    \/\/ Calculates the required page count needed to accomodate both code cache and heap for the given page size index.\n-    private static long requiredPageCount(long pageSizeInKb) {\n-        long codeCacheAddened = CODE_CACHE_SIZE_IN_KB >= pageSizeInKb ? CODE_CACHE_SIZE_IN_KB : 0;\n-        return (long) Math.ceil((double) (HEAP_SIZE_IN_KB + codeCacheAddened) \/ pageSizeInKb);\n-    }\n-\n-    public static String pageSizeToString(long pageSizeInKb) {\n-        int m = 1024;\n-        int g = 1024 * 1024;\n-        if (pageSizeInKb < m) {\n-            return Long.toString(pageSizeInKb) + \"K\";\n-        } else if (pageSizeInKb < g) {\n-            return Long.toString(pageSizeInKb \/ m) + \"M\";\n-        } else {\n-            return Long.toString(pageSizeInKb \/ g) + \"G\";\n-        }\n-    }\n-\n-    private static boolean checkOutput(OutputAnalyzer out, String pageSize) {\n-        List<String> lines = out.asLines();\n-        for (int i = 0; i < lines.size(); ++i) {\n-            String line = lines.get(i);\n-            System.out.println(line);\n-            if (HEAP_PATTERN.matcher(line).find()) {\n-                Matcher trace = PAGE_SIZE_PATTERN.matcher(line);\n-                trace.find();\n-                String tracePageSize = trace.group(1);\n-                if (pageSize.equals(tracePageSize)) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public static int readPageCount(String filename, String pageSize) throws Exception {\n-        BufferedReader d = new BufferedReader(new FileReader(filename));\n-        int pageCount = Integer.parseInt(d.readLine());\n-        if (pageCount == 0) {\n-            System.out.println(\"No pages configured for \" + pageSize + \"kB\");\n-        }\n-        return pageCount;\n-    }\n-\n-    public static void doSetup() throws Exception {\n-        \/\/ Large page sizes\n-        File[] directories = new File(DIR_HUGE_PAGES).listFiles(File::isDirectory);\n-        for (File dir : directories) {\n-            String pageSizeFileName = dir.getName();\n-            Matcher matcher = HUGEPAGE_PATTERN.matcher(pageSizeFileName);\n-            matcher.find();\n-            String pageSize = matcher.group(1);\n-            assert pageSize != null;\n-            int availablePages = readPageCount(DIR_HUGE_PAGES + pageSizeFileName + \"\/free_hugepages\", pageSize);\n-            treeMap.put(Long.parseLong(pageSize), availablePages);\n-        }\n-        \/\/ OS vm page size\n-        treeMap.put(wb.getVMPageSize() \/ 1024L, Integer.MAX_VALUE);\n-    }\n-\n-    public static void testCase(long pageSize) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:pagesize\",\n-                                                                  \"-XX:ReservedCodeCacheSize=\" + CODE_CACHE_SIZE_IN_KB + \"k\",\n-                                                                  \"-XX:InitialCodeCacheSize=160k\",\n-                                                                  \"-XX:LargePageSizeInBytes=\" + pageSizeToString(pageSize),\n-                                                                  \"-XX:+UseParallelGC\",\n-                                                                  \"-XX:+UseLargePages\",\n-                                                                  \"-Xmx\" + HEAP_SIZE_IN_KB + \"k\",\n-                                                                  \"-Xms\" + HEAP_SIZE_IN_KB + \"k\",\n-                                                                  \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldHaveExitValue(0);\n-        for (Map.Entry<Long, Integer> entry : treeMap.entrySet()) {\n-            long pageSizeInKb = entry.getKey();\n-            int pageCount = entry.getValue();\n-            String size = pageSizeToString(pageSizeInKb);\n-            System.out.println(\"Checking allocation for \" + size);\n-            if (checkOutput(output, size)) {\n-                System.out.println(\"TestCase Passed for pagesize: \" + pageSizeToString(pageSize) + \", allocated pagesize: \" + size);\n-                \/\/ Page allocation succeeded no need to check any more page sizes.\n-                return;\n-            } else {\n-                \/\/ Only consider this a test failure if there are enough configured\n-                \/\/ pages to allow this reservation to succeeded.\n-                if (requiredPageCount(pageSizeInKb) <= pageCount) {\n-                    throw new AssertionError(\"TestCase Failed for \" + size + \" page allocation. \" +\n-                                             \"Required pages: \" + requiredPageCount(pageSizeInKb) + \", \" +\n-                                             \"Configured pages: \" + pageCount);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestExplicitPageAllocation.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"}]}