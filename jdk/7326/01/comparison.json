{"files":[{"patch":"@@ -3475,0 +3475,1 @@\n+static size_t _large_page_size = 0;\n@@ -3476,2 +3477,1 @@\n-bool os::Linux::hugetlbfs_sanity_check(bool warn, size_t page_size) {\n-  \/\/ Include the page size flag to ensure we sanity check the correct page size.\n+bool os::Linux::try_commit_using_large_page(size_t page_size) {\n@@ -3480,1 +3480,0 @@\n-\n@@ -3483,0 +3482,3 @@\n+    log_info(pagesize)(\"Large page size (\" SIZE_FORMAT \"%s) passed sanity check\",\n+                        byte_size_in_exact_unit(page_size),\n+                        exact_unit_for_byte_size(page_size));\n@@ -3485,19 +3487,16 @@\n-  } else {\n-      log_info(pagesize)(\"Large page size (\" SIZE_FORMAT \"%s) failed sanity check, \"\n-                         \"checking if smaller large page sizes are usable\",\n-                         byte_size_in_exact_unit(page_size),\n-                         exact_unit_for_byte_size(page_size));\n-      for (size_t page_size_ = _page_sizes.next_smaller(page_size);\n-          page_size_ != (size_t)os::vm_page_size();\n-          page_size_ = _page_sizes.next_smaller(page_size_)) {\n-        flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_HUGETLB | hugetlbfs_page_size_flag(page_size_);\n-        p = mmap(NULL, page_size_, PROT_READ|PROT_WRITE, flags, -1, 0);\n-        if (p != MAP_FAILED) {\n-          \/\/ Mapping succeeded, sanity check passed.\n-          munmap(p, page_size_);\n-          log_info(pagesize)(\"Large page size (\" SIZE_FORMAT \"%s) passed sanity check\",\n-                             byte_size_in_exact_unit(page_size_),\n-                             exact_unit_for_byte_size(page_size_));\n-          return true;\n-        }\n-      }\n+  }\n+  log_info(pagesize)(\"Large page size (\" SIZE_FORMAT \"%s) failed sanity check, \"\n+                     \"checking if smaller large page sizes are usable\",\n+                     byte_size_in_exact_unit(page_size),\n+                     exact_unit_for_byte_size(page_size));\n+  return false;\n+}\n+\n+bool os::Linux::hugetlbfs_sanity_check(bool warn, size_t page_size) {\n+   bool large_page_found = false;\n+  \/\/ Include the page size flag to ensure we sanity check the correct page size.\n+  for (size_t local_page_size = page_size; local_page_size != (size_t)os::vm_page_size(); local_page_size = _page_sizes.next_smaller(local_page_size)) {\n+    if (os::Linux::try_commit_using_large_page(local_page_size) && !large_page_found) {\n+      _large_page_size = local_page_size;\n+      large_page_found = true;\n+    }\n@@ -3510,1 +3509,1 @@\n-  return false;\n+  return large_page_found;\n@@ -3576,2 +3575,0 @@\n-static size_t _large_page_size = 0;\n-\n@@ -4031,3 +4028,2 @@\n-    \/\/ Failed to commit large pages, so we need to unmap the\n-    \/\/ reminder of the orinal reservation.\n-    ::munmap(small_start, small_size);\n+    \/\/ Failed to commit large pages, so we need to unmap the whole reservation.\n+    ::munmap(aligned_start, bytes);\n@@ -4040,3 +4036,2 @@\n-    \/\/ Failed to commit the remaining size, need to unmap\n-    \/\/ the large pages part of the reservation.\n-    ::munmap(aligned_start, large_bytes);\n+    \/\/ Failed to commit the remaining size, need to unmap the whole reservation\n+    ::munmap(aligned_start, bytes);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  static bool try_commit_using_large_page(size_t page_size);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1406,1 +1406,1 @@\n-    for (size_t page_size = page_sizes().largest(); page_size != 0;\n+    for (size_t page_size = os::large_page_size(); page_size != 0;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8271195\n+ * @summary Use largest available large page size smaller than LargePageSizeInBytes when available.\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc != \"Z\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver runtime.os.TestExplicitPageAllocation\n+ *\/\n+\n+package runtime.os;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Collections;\n+import jdk.test.lib.Utils;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.Scanner;\n+import java.io.FileWriter;\n+\n+public class TestExplicitPageAllocation {\n+    private static String file1GHugePages = \"\/sys\/kernel\/mm\/hugepages\/hugepages-1048576kB\/free_hugepages\";\n+    private static String file2MHugePages = \"\/sys\/kernel\/mm\/hugepages\/hugepages-2048kB\/free_hugepages\";\n+    private static String file1GHugePagesResv = \"\/sys\/kernel\/mm\/hugepages\/hugepages-1048576kB\/resv_hugepages\";\n+    private static String file2MHugePagesResv = \"\/sys\/kernel\/mm\/hugepages\/hugepages-2048kB\/resv_hugepages\";\n+\n+    private static String heapPrefix = \"Heap:\";\n+    private static Pattern heapPattern = Pattern.compile(heapPrefix);\n+    private static FileInputStream fis;\n+    private static DataInputStream dis;\n+    private static int orig1GPageCount;\n+    private static int orig2MPageCount;\n+    private static int resv1GPageCount;\n+    private static int resv2MPageCount;\n+\n+    private static String errorMessage = null;\n+\n+\n+    public static void main(String args[]) throws Exception {\n+        try {\n+            doSetup();\n+            testCase1();\n+            testCase2();\n+            testCase3();\n+            testCase4();\n+        } catch(Exception e) {\n+           System.out.println(\"Exception\"+e);\n+        }\n+        if (errorMessage!=null) {\n+            throw new AssertionError(errorMessage);\n+        }\n+\n+    }\n+\n+    private static boolean matchPattern(String line, Pattern regex) {\n+        return regex.matcher(line).find();\n+    }\n+    private static boolean matchPattern(String line) {\n+        return matchPattern(line, heapPattern);\n+    }\n+\n+    private static boolean checkOutput(OutputAnalyzer out, String pageSize) throws Exception {\n+        List<String> lines = out.asLines();\n+        String traceLinePatternString = \".*page_size=([^ ]+).*\";\n+        Pattern traceLinePattern = Pattern.compile(traceLinePatternString);\n+        for (int i = 0; i < lines.size(); ++i) {\n+            String line = lines.get(i);\n+            System.out.println(line);\n+            if (matchPattern(line)) {\n+                Matcher trace = traceLinePattern.matcher(line);\n+                trace.find();\n+                String tracePageSize = trace.group(1);\n+                if(pageSize.contains(tracePageSize)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static int checkAndReadFile(String filename, String errorstr) throws Exception {\n+        try {\n+            fis = new FileInputStream(filename);\n+            dis = new DataInputStream(fis);\n+            int pagecount = Integer.parseInt(dis.readLine());\n+            dis.close();\n+            fis.close();\n+            return pagecount;\n+        } catch (Exception e) {\n+            System.out.println(errorstr);\n+        }\n+        return -1;\n+    }\n+\n+    public static void doSetup() throws Exception{\n+        File file;\n+        \/\/ Legality check for 1G , 2M pages.\n+        orig1GPageCount = checkAndReadFile(file1GHugePages, \"System does not support 1G pages\");\n+        if (orig1GPageCount >= 0) {\n+            System.out.println(\"Number of 1G pages = \" + orig1GPageCount + \"\\n\");\n+        }\n+        orig2MPageCount =  checkAndReadFile(file2MHugePages, \"System does not support 2M pages\");\n+        if (orig2MPageCount >= 0) {\n+            System.out.println(\"Number of 2M pages = \" + orig2MPageCount + \"\\n\");\n+        }\n+        resv1GPageCount = checkAndReadFile(file1GHugePagesResv, \"System does not support 1G pages\");\n+        if (resv2MPageCount >= 0) {\n+            System.out.println(\"Number of reserved 1G pages = \" + resv1GPageCount + \"\\n\");\n+        }\n+        resv2MPageCount =  checkAndReadFile(file2MHugePagesResv, \"System does not support 2M pages\");\n+        if (resv2MPageCount >= 0) {\n+            System.out.println(\"Number of reserved 2M pages = \" + resv2MPageCount + \"\\n\");\n+        }\n+\n+    }\n+\n+    public static void testCase1() throws Exception {\n+        if((orig1GPageCount - resv1GPageCount)  < 2) {\n+            System.out.println(\"TestCase1 skipped\\n\");\n+            return;\n+        }\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:pagesize\",\n+                                                                  \"-XX:LargePageSizeInBytes=1G\",\n+                                                                  \"-XX:+UseParallelGC\",\n+                                                                  \"-XX:+UseLargePages\",\n+                                                                  \"-Xmx2g\",\n+                                                                  \"-Xms1g\",\n+                                                                  TestExplicitPageAllocation.class.getName());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        if(!checkOutput(output,\"1G\")) {\n+           errorMessage = \"Failed 1G page allocation\\n\";\n+        } else {\n+           System.out.println(\"TestCase1 Passed\\n\");\n+        }\n+    }\n+\n+    public static void testCase2() throws Exception {\n+        if((orig1GPageCount - resv1GPageCount) > 0 || (orig2MPageCount - resv2MPageCount) < 1280) {\n+            System.out.println(\"TestCase2 skipped\\n\");\n+            return;\n+        }\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:pagesize\",\n+                                                                  \"-XX:LargePageSizeInBytes=1G\",\n+                                                                  \"-XX:+UseParallelGC\",\n+                                                                  \"-XX:+UseLargePages\",\n+                                                                  \"-Xmx2g\",\n+                                                                  \"-Xms1g\",\n+                                                                  TestExplicitPageAllocation.class.getName());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        if(!checkOutput(output,\"2M\")) {\n+           errorMessage = \"Failed 2M page allocation\\n\";\n+        } else {\n+           System.out.println(\"TestCase2 Passed\\n\");\n+        }\n+    }\n+\n+    public static void testCase3() throws Exception {\n+        if((orig1GPageCount - resv1GPageCount) > 0 || (orig2MPageCount - resv2MPageCount) > 0) {\n+            System.out.println(\"TestCase3 skipped\\n\");\n+            return;\n+        }\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:pagesize\",\n+                                                                 \"-XX:LargePageSizeInBytes=1G\",\n+                                                                 \"-XX:+UseParallelGC\",\n+                                                                 \"-XX:+UseLargePages\",\n+                                                                 \"-Xmx2g\",\n+                                                                 \"-Xms1g\",\n+                                                                 TestExplicitPageAllocation.class.getName());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        if(!checkOutput(output,\"4K\")) {\n+           errorMessage = \"Failed 4K page allocation\\n\";\n+        } else {\n+           System.out.println(\"TestCase3 Passed\\n\");\n+        }\n+    }\n+\n+    public static void testCase4() throws Exception {\n+        if((orig2MPageCount - resv2MPageCount) < 1280) {\n+            System.out.println(\"TestCase4 skipped\\n\");\n+            return;\n+        }\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:pagesize\",\n+                                                                 \"-XX:LargePageSizeInBytes=2M\",\n+                                                                 \"-XX:+UseParallelGC\",\n+                                                                 \"-XX:+UseLargePages\",\n+                                                                 \"-Xmx2g\",\n+                                                                 \"-Xms1g\",\n+                                                                 TestExplicitPageAllocation.class.getName());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        if(!checkOutput(output,\"2M\")) {\n+           errorMessage = \"Failed 2M page allocation\\n\";\n+        } else {\n+           System.out.println(\"TestCase4 Passed\\n\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestExplicitPageAllocation.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/\/\n+\/\/ Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.vm.gc;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MINUTES)\n+@State(Scope.Thread)\n+public class MicroLargePages {\n+\n+    @Param({\"1073741824\"})\n+    public int ARRAYSIZE;\n+\n+    @Param({\"1\",\"2\",\"4\"})\n+    public int NUM;\n+\n+    public static final int ITERS = 100;\n+\n+    public long[][] INP;\n+    public long[][]  OUT;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        INP = new long[NUM][ARRAYSIZE];\n+        OUT = new long[NUM][ARRAYSIZE];\n+\n+        for (int i = 0; i < NUM; i++) {\n+            Arrays.fill(INP[i], 10);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void micro_HOP_DIST_4KB() {\n+        for (int i = 0; i < ITERS ; i++) {\n+            for (int j = 0; j < NUM; j += 1) {\n+                for (int k = 0; k < ARRAYSIZE; k += 512) {\n+                    OUT[j][k] = INP[j][k];\n+                }\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/MicroLargePages.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}