{"files":[{"patch":"@@ -1808,0 +1808,1 @@\n+    bool patch_call = false;\n@@ -1820,0 +1821,2 @@\n+    \/\/ Check relocations for the matching call to 1) avoid false positives,\n+    \/\/ and 2) determine the type.\n@@ -1821,0 +1824,2 @@\n+      \/\/ On x86 the logic for finding a call instruction is blindly checking for a call opcode 5\n+      \/\/ bytes back in the instruction stream so we must also check for reloc info.\n@@ -1824,25 +1829,25 @@\n-        assert(iter.addr() == call_addr, \"must find call\");\n-        if (iter.type() == relocInfo::static_call_type) {\n-          is_static_call = true;\n-        } else {\n-          assert(iter.type() == relocInfo::virtual_call_type ||\n-                 iter.type() == relocInfo::opt_virtual_call_type\n-                , \"unexpected relocInfo. type\");\n-        }\n-      } else {\n-        assert(!UseInlineCaches, \"relocation info. must exist for this address\");\n-      }\n-\n-      \/\/ Cleaning the inline cache will force a new resolve. This is more robust\n-      \/\/ than directly setting it to the new destination, since resolving of calls\n-      \/\/ is always done through the same code path. (experience shows that it\n-      \/\/ leads to very hard to track down bugs, if an inline cache gets updated\n-      \/\/ to a wrong method). It should not be performance critical, since the\n-      \/\/ resolve is only done once.\n-\n-      for (;;) {\n-        ICRefillVerifier ic_refill_verifier;\n-        if (!clear_ic_at_addr(caller_nm, call_addr, is_static_call)) {\n-          InlineCacheBuffer::refill_ic_stubs();\n-        } else {\n-          break;\n+        bool is_static_call = false;\n+        switch (iter.type()) {\n+          case relocInfo::static_call_type:\n+            is_static_call = true;\n+\n+          case relocInfo::virtual_call_type:\n+          case relocInfo::opt_virtual_call_type:\n+            \/\/ Cleaning the inline cache will force a new resolve. This is more robust\n+            \/\/ than directly setting it to the new destination, since resolving of calls\n+            \/\/ is always done through the same code path. (experience shows that it\n+            \/\/ leads to very hard to track down bugs, if an inline cache gets updated\n+            \/\/ to a wrong method). It should not be performance critical, since the\n+            \/\/ resolve is only done once.\n+            guarantee(iter.addr() == call_addr, \"must find call\");\n+            for (;;) {\n+              ICRefillVerifier ic_refill_verifier;\n+              if (!clear_ic_at_addr(caller_nm, call_addr, is_static_call)) {\n+                InlineCacheBuffer::refill_ic_stubs();\n+              } else {\n+                break;\n+              }\n+            }\n+            break;\n+          default:\n+            break;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":30,"deletions":25,"binary":false,"changes":55,"status":"modified"}]}