{"files":[{"patch":"@@ -1,142 +1,142 @@\n-\/*\r\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package compiler.c2.irTests;\r\n-\r\n-import jdk.test.lib.Asserts;\r\n-import compiler.lib.ir_framework.*;\r\n-import java.util.Random;\r\n-import jdk.test.lib.Utils;\r\n-\r\n-\/*\r\n- * @test\r\n- * @summary Test that patterns leading to Conv2B are correctly expanded.\r\n- * @bug 8312213\r\n- * @library \/test\/lib \/\r\n- * @requires vm.compiler2.enabled\r\n- * @requires os.arch == \"x86_64\" | os.arch == \"amd64\"\r\n- * @run driver compiler.c2.irTests.TestTestRemovalPeephole\r\n- *\/\r\n-public class TestTestRemovalPeephole {\r\n-    public static void main(String[] args) {\r\n-        TestFramework.run();\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testIntAddtionEquals0(int x, int y) {\r\n-        int result = x + y;\r\n-        return result == 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testIntAddtionNotEquals0(int x, int y) {\r\n-        int result = x + y;\r\n-        return result != 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testLongAddtionEquals0(long x, long y) {\r\n-        long result = x + y;\r\n-        return result == 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testLongAddtionNotEquals0(long x, long y) {\r\n-        long result = x + y;\r\n-        return result != 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testIntAndEquals0(int x, int y) {\r\n-        int result = x & y;\r\n-        return result == 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testIntAndNotEquals0(int x, int y) {\r\n-        int result = x & y;\r\n-        return result != 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testLongAndEquals0(long x, long y) {\r\n-        long result = x & y;\r\n-        return result == 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testLongAndNotEquals0(long x, long y) {\r\n-        long result = x & y;\r\n-        return result != 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.NUMBER_42, Argument.NUMBER_42}) \/\/ TODO switch to Argument.RANDOM_EACH once conditional moving works with the peephole\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testIntAndGreater0(int x, int y) {\r\n-        int result = x & y;\r\n-        return result > 0;\r\n-    }\r\n-\r\n-    @Test\r\n-    @Arguments({Argument.NUMBER_42, Argument.NUMBER_42}) \/\/ TODO switch to Argument.RANDOM_EACH once conditional moving works with the peephole\r\n-    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\r\n-    public boolean testLongAndGreater0(long x, long y) {\r\n-        long result = x & y;\r\n-        return result > 0;\r\n-    }\r\n-\r\n-\r\n-    @DontCompile\r\n-    public void assertResult(int x, int y) {\r\n-        Asserts.assertEQ((x + y) == 0, testIntAddtionEquals0(x, y));\r\n-        Asserts.assertEQ((x + y) != 0, testIntAddtionNotEquals0(x, y));\r\n-        Asserts.assertEQ((x & y) == 0, testIntAndEquals0(x, y));\r\n-        Asserts.assertEQ((x & y) != 0, testIntAndNotEquals0(x, y));\r\n-        Asserts.assertEQ((x & y) > 0, testIntAndGreater0(x, y));\r\n-    }\r\n-\r\n-    @DontCompile\r\n-    public void assertResult(long x, long y) {\r\n-        Asserts.assertEQ((x + y) == 0, testLongAddtionEquals0(x, y));\r\n-        Asserts.assertEQ((x + y) != 0, testLongAddtionNotEquals0(x, y));\r\n-        Asserts.assertEQ((x & y) == 0, testLongAddtionEquals0(x, y));\r\n-        Asserts.assertEQ((x & y) != 0, testLongAddtionNotEquals0(x, y));\r\n-        Asserts.assertEQ((x & y) > 0, testLongAndGreater0(x, y));\r\n-    }\r\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test that patterns leading to Conv2B are correctly expanded.\n+ * @bug 8312213\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires os.arch == \"x86_64\" | os.arch == \"amd64\"\n+ * @run driver compiler.c2.irTests.TestTestRemovalPeephole\n+ *\/\n+public class TestTestRemovalPeephole {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testIntAddtionEquals0(int x, int y) {\n+        int result = x + y;\n+        return result == 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testIntAddtionNotEquals0(int x, int y) {\n+        int result = x + y;\n+        return result != 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testLongAddtionEquals0(long x, long y) {\n+        long result = x + y;\n+        return result == 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testLongAddtionNotEquals0(long x, long y) {\n+        long result = x + y;\n+        return result != 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testIntAndEquals0(int x, int y) {\n+        int result = x & y;\n+        return result == 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testIntAndNotEquals0(int x, int y) {\n+        int result = x & y;\n+        return result != 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testLongAndEquals0(long x, long y) {\n+        long result = x & y;\n+        return result == 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testLongAndNotEquals0(long x, long y) {\n+        long result = x & y;\n+        return result != 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.NUMBER_42, Argument.NUMBER_42}) \/\/ TODO switch to Argument.RANDOM_EACH once conditional moving works with the peephole\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testIntAndGreater0(int x, int y) {\n+        int result = x & y;\n+        return result > 0;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.NUMBER_42, Argument.NUMBER_42}) \/\/ TODO switch to Argument.RANDOM_EACH once conditional moving works with the peephole\n+    @IR(failOn = {IRNode.X86_TESTI_REG, IRNode.X86_TESTL_REG}, phase = CompilePhase.FINAL_CODE)\n+    public boolean testLongAndGreater0(long x, long y) {\n+        long result = x & y;\n+        return result > 0;\n+    }\n+\n+\n+    @DontCompile\n+    public void assertResult(int x, int y) {\n+        Asserts.assertEQ((x + y) == 0, testIntAddtionEquals0(x, y));\n+        Asserts.assertEQ((x + y) != 0, testIntAddtionNotEquals0(x, y));\n+        Asserts.assertEQ((x & y) == 0, testIntAndEquals0(x, y));\n+        Asserts.assertEQ((x & y) != 0, testIntAndNotEquals0(x, y));\n+        Asserts.assertEQ((x & y) > 0, testIntAndGreater0(x, y));\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long x, long y) {\n+        Asserts.assertEQ((x + y) == 0, testLongAddtionEquals0(x, y));\n+        Asserts.assertEQ((x + y) != 0, testLongAddtionNotEquals0(x, y));\n+        Asserts.assertEQ((x & y) == 0, testLongAddtionEquals0(x, y));\n+        Asserts.assertEQ((x & y) != 0, testLongAddtionNotEquals0(x, y));\n+        Asserts.assertEQ((x & y) > 0, testLongAndGreater0(x, y));\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestTestRemovalPeephole.java","additions":142,"deletions":142,"binary":false,"changes":284,"status":"modified"}]}