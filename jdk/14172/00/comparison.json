{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"adfiles\/ad_x86.hpp\"\n@@ -135,0 +136,101 @@\n+\/\/ This helper func takes a condition and returns the flags that need to be set for the condition\n+\/\/ It uses the same flags as the test instruction, so if the e.g. the overflow bit is required,\n+\/\/ this func returns clears_overflow, as that is what the test instruction does and what the downstream path expects\n+juint map_condition_to_required_test_flags(Assembler::Condition condition) {\n+  switch (condition) {\n+    case Assembler::Condition::zero: \/\/ Same value as equal\n+    case Assembler::Condition::notZero: \/\/ Same value as notEqual\n+      return Node::PD::Flag_sets_zero_flag;\n+    case Assembler::Condition::less:\n+    case Assembler::Condition::greaterEqual:\n+      return Node::PD::Flag_sets_sign_flag | Node::PD::Flag_clears_overflow_flag;\n+    case Assembler::Condition::lessEqual:\n+    case Assembler::Condition::greater:\n+      return Node::PD::Flag_sets_sign_flag | Node::PD::Flag_clears_overflow_flag | Node::PD::Flag_sets_zero_flag;\n+    case Assembler::Condition::below: \/\/ Same value as carrySet\n+    case Assembler::Condition::aboveEqual: \/\/ Same value as carryClear\n+      return Node::PD::Flag_clears_carry_flag;\n+    case Assembler::Condition::belowEqual:\n+    case Assembler::Condition::above:\n+      return Node::PD::Flag_clears_carry_flag | Node::PD::Flag_sets_zero_flag;\n+    case Assembler::Condition::overflow:\n+    case Assembler::Condition::noOverflow:\n+      return Node::PD::Flag_clears_overflow_flag;\n+    case Assembler::Condition::negative:\n+    case Assembler::Condition::positive:\n+      return Node::PD::Flag_sets_sign_flag;\n+    case Assembler::Condition::parity:\n+    case Assembler::Condition::noParity:\n+      return Node::PD::Flag_sets_parity_flag;\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+\n+\/\/ This function removes the TEST instruction when it detected shapes likes AND r1, r2; TEST r1, r1\n+\/\/ It checks the required EFLAGS for the downstream instructions of the TEST\n+\/\/ and removes the TEST if the preceding instructions already sets all these flags\n+bool Peephole::test_may_remove(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                            MachNode* (*new_root)(), uint inst0_rule) {\n+  MachNode* test_to_check = block->get_node(block_index)->as_Mach();\n+  assert(test_to_check->rule() == inst0_rule, \"sanity\");\n+\n+  Node* inst1 = test_to_check->in(1);\n+  \/\/ Only remove test if the block order is inst1 -> MachProjNode (because the node to match must specify KILL cr) -> test_to_check\n+  \/\/ So inst1 must be at index - 2\n+  if (block_index < 2 || block->get_node(block_index - 2) != inst1) {\n+    return false;\n+  }\n+  if (inst1 != nullptr) {\n+    MachNode* prevNode = inst1->isa_Mach();\n+    if (prevNode != nullptr) {\n+      \/\/ Includes other flags as well, but that doesn't matter here\n+      juint all_node_flags = prevNode->flags();\n+      if (all_node_flags == 0) {\n+        \/\/ We can return early - there is no way the test can be removed, the preceding node does not set any flags\n+        return false;\n+      }\n+      juint required_flags = 0;\n+      \/\/ Search for the uses of the node and compute which flags are required\n+      for (DUIterator i = test_to_check->outs(); test_to_check->has_out(i); i++) {\n+        MachNode* node_out = test_to_check->out(i)->isa_Mach();\n+        bool found_correct_oper = false;\n+        for (uint16_t j = 0; j < node_out->_num_opnds; ++j) {\n+          MachOper* operand = node_out->_opnds[j];\n+          if (operand->opcode() == cmpOp_rule || operand->opcode() == cmpOpU_rule) {\n+            auto condition = static_cast<Assembler::Condition>(operand->ccode());\n+            juint flags_for_inst = map_condition_to_required_test_flags(condition);\n+            required_flags = required_flags | flags_for_inst;\n+            found_correct_oper = true;\n+            break;\n+          }\n+        }\n+        if (!found_correct_oper) {\n+          \/\/ We could not find one the required flags for one of the dependencies. Keep the test as it might set flags needed for that node\n+          return false;\n+        }\n+      }\n+      assert(required_flags != 0, \"No flags required, should be impossible!\");\n+      bool sets_all_required_flags = (required_flags & ~all_node_flags) == 0;\n+      if (sets_all_required_flags) {\n+        \/\/ All flags are covered are clear to remove this test\n+        MachProjNode* machProjNode = block->get_node(block_index - 1)->isa_MachProj();\n+        assert(machProjNode != nullptr, \"Expected a MachProj node here!\");\n+        \/\/ Remove the original test node and replace it with the pseudo test node. The AND node already sets ZF\n+        test_to_check->replace_by(machProjNode);\n+\n+        \/\/ Modify the block\n+        test_to_check->set_removed();\n+        block->remove_node(block_index);\n+\n+        \/\/ Modify the control flow\n+        cfg_->map_node_to_block(test_to_check, nullptr);\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.cpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+  static bool test_may_remove(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                              MachNode* (*new_root)(), uint inst0_rule);\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1257,2 +1257,12 @@\n-    Flag_intel_jcc_erratum = Node::_last_flag << 1,\n-    _last_flag             = Flag_intel_jcc_erratum\n+    Flag_intel_jcc_erratum    = Node::_last_flag << 1,\n+    Flag_sets_carry_flag      = Node::_last_flag << 2,\n+    Flag_sets_parity_flag     = Node::_last_flag << 3,\n+    Flag_sets_zero_flag       = Node::_last_flag << 4,\n+    Flag_sets_overflow_flag   = Node::_last_flag << 5,\n+    Flag_sets_sign_flag       = Node::_last_flag << 6,\n+    Flag_clears_carry_flag    = Node::_last_flag << 7,\n+    Flag_clears_parity_flag   = Node::_last_flag << 8,\n+    Flag_clears_zero_flag     = Node::_last_flag << 9,\n+    Flag_clears_overflow_flag = Node::_last_flag << 10,\n+    Flag_clears_sign_flag     = Node::_last_flag << 11,\n+    _last_flag                = Flag_clears_sign_flag\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -7652,0 +7652,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7664,0 +7665,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7676,0 +7678,2 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n@@ -7689,0 +7693,2 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n@@ -7702,0 +7708,2 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n@@ -7822,0 +7830,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7834,0 +7843,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7846,0 +7856,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7859,0 +7870,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7872,0 +7884,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7992,0 +8005,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8004,0 +8018,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8557,0 +8572,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8569,0 +8585,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8582,0 +8599,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8595,0 +8613,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8607,0 +8626,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8620,0 +8640,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8646,0 +8667,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8658,0 +8680,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8670,0 +8693,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8682,0 +8706,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8694,0 +8719,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8706,0 +8732,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -9187,0 +9214,1 @@\n+\n@@ -9841,0 +9869,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9917,0 +9946,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9930,0 +9960,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9944,0 +9975,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9957,0 +9989,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9971,0 +10004,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9985,0 +10019,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9999,0 +10034,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10012,0 +10048,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10025,0 +10062,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10040,0 +10078,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10055,0 +10094,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10070,0 +10110,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10085,0 +10126,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10102,0 +10144,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10115,0 +10158,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10128,0 +10172,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10142,0 +10187,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10155,0 +10201,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10169,0 +10216,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10184,0 +10232,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10208,0 +10257,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10221,0 +10271,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10235,0 +10286,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10248,0 +10300,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10262,0 +10315,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10280,0 +10334,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10319,0 +10374,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10332,0 +10388,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10346,0 +10403,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10360,0 +10418,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10391,0 +10450,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10405,0 +10465,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10418,0 +10479,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10431,0 +10493,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10446,0 +10509,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10461,0 +10525,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10476,0 +10541,2 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n@@ -10491,0 +10558,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10508,0 +10576,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10520,0 +10589,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10534,0 +10604,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10547,0 +10618,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10561,0 +10633,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10575,0 +10648,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10607,0 +10681,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10631,0 +10706,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10644,0 +10720,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10658,0 +10735,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10672,0 +10750,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -13866,0 +13945,18 @@\n+\/\/ These peephole rules matches instructions which set flags and are followed by a testI\/L_reg\n+\/\/ The test instruction is redudanent in case the downstream instuctions (like JCC or CMOV) only use flags that are already set by the previous instruction\n+\n+\/\/int variant\n+peephole\n+%{\n+  peepmatch (testI_reg);\n+  peepprocedure (test_may_remove);\n+%}\n+\n+\/\/long variant\n+peephole\n+%{\n+  peepmatch (testL_reg);\n+  peepprocedure (test_may_remove);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -232,0 +232,1 @@\n+    else if (!strcmp(ident, \"flag\"))             instr->_flag = flag_parse(instr);\n@@ -4129,0 +4130,40 @@\n+\/\/-------------------------------flag_parse------------------------------------\n+Flag* ADLParser::flag_parse(InstructForm *instr) {\n+  char* ident = nullptr;\n+  Flag* result = nullptr;\n+\n+  skipws();                      \/\/ Skip whitespace\n+  if (_curchar != '(') {\n+    parse_err(SYNERR, \"missing '(' in flag definition\\n\");\n+    return nullptr;\n+  }\n+  do {\n+    next_char();\n+    skipws();\n+    if (_curchar == ')') break;\n+\n+    ident = get_ident();\n+    if (ident == nullptr) {\n+      parse_err(SYNERR, \"flag name expected at %c\\n\", _curchar);\n+      return nullptr;\n+    }\n+    Flag* newflag = new Flag(ident);\n+    if (result == nullptr) result = newflag;\n+    else result->append_flag(newflag);\n+    if (_AD._adl_debug > 1) fprintf(stderr, \"\\tFlag Name: %s\\n\", ident);\n+    skipws();\n+  } while (_curchar == ',');\n+  if (_curchar != ')') parse_err(SYNERR, \"missing ')'\\n\");\n+  else {\n+    next_char();  \/\/ set current character position past the close paren\n+  }\n+\n+  \/\/ Debug Stuff\n+  if (_curchar != ';') {\n+    parse_err(SYNERR, \"missing ';' in Flag definition\\n\");\n+  }\n+  \/\/ Skip ';'\n+  next_char();\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class Flag;\n@@ -180,0 +181,1 @@\n+  Flag          *flag_parse(InstructForm *instr); \/\/ Parse flag rule\n","filename":"src\/hotspot\/share\/adlc\/adlparse.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+class Flag;\n@@ -240,0 +241,1 @@\n+    FLG,\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class Flag;\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+      _flag                 = nullptr;\n@@ -89,0 +90,1 @@\n+      _flag                  = instr->_flag;\n@@ -1896,0 +1898,28 @@\n+\/\/---------------------------------Flag----------------------------------------\n+Flag::Flag(const char *name) : _name(name) {\n+  _ftype = Form::FLG;\n+}\n+\n+Flag::~Flag() {\n+}\n+\n+void Flag::append_flag(Flag *next_flag) {\n+  if( _next == nullptr ) {\n+    _next = next_flag;\n+  } else {\n+    _next->append_flag( next_flag );\n+  }\n+}\n+\n+Flag* Flag::next() {\n+  return _next;\n+}\n+\n+void Flag::dump() {\n+  output(stderr);\n+}\n+\n+void Flag::output(FILE *fp) {          \/\/ Write info to output files\n+  fprintf(fp,\"Flag: %s\\n\", (_name?_name:\"\"));\n+}\n+\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+class Flag;\n@@ -111,0 +112,1 @@\n+  Flag          *_flag;               \/\/ List of Flags that should be set by default for this node\n@@ -518,0 +520,20 @@\n+\/\/---------------------------------Flag----------------------------------------\n+class Flag : public Form {\n+private:\n+    Flag* _next = nullptr;\n+public:\n+  const char *_name; \/\/ Name of the flag (See Node::<flag_name> or Node::Pd::<flag_name>\n+\n+  \/\/ Public Methods\n+  Flag(const char *name);      \/\/ Constructor\n+  ~Flag();                     \/\/ Destructor\n+\n+  \/\/ Append a flag rule for the same instruction\n+  void append_flag(Flag *next_flag);\n+\n+  Flag* next();\n+\n+  void dump();                   \/\/ Debug printer\n+  void output(FILE *fp);         \/\/ Write info to output files\n+};\n+\n","filename":"src\/hotspot\/share\/adlc\/formssel.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1472,4 +1472,8 @@\n-      const char* replace_inst = nullptr;\n-      preplace->next_instruction(replace_inst);\n-      \/\/ Generate the target instruction\n-      fprintf(fp, \"    auto replacing = [](){ return static_cast<MachNode*>(new %sNode()); };\\n\", replace_inst);\n+      if (preplace != nullptr) {\n+        const char *replace_inst = nullptr;\n+        preplace->next_instruction(replace_inst);\n+        \/\/ Generate the target instruction\n+        fprintf(fp, \"    auto replacing = [](){ return static_cast<MachNode*>(new %sNode()); };\\n\", replace_inst);\n+      } else {\n+        fprintf(fp, \"    auto replacing = nullptr;\\n\");\n+      }\n@@ -4013,0 +4017,16 @@\n+  if (inst->_flag != nullptr) {\n+    Flag* node = inst->_flag;\n+    const char* prefix = \"Node::\";\n+    bool node_flags_set = false;\n+    do {\n+      if (!node_flags_set) {\n+        fprintf(fp_cpp, \"%s node->add_flag(%s%s\", indent, strncmp(node->_name, prefix, strlen(prefix)) != 0 ? prefix : \"\", node->_name);\n+        node_flags_set = true;\n+      } else {\n+        fprintf(fp_cpp, \" | %s%s\", strncmp(node->_name, prefix, strlen(prefix)) != 0 ? prefix : \"\", node->_name);\n+      }\n+    } while ((node = node->next()) != nullptr);\n+    if (node_flags_set) {\n+      fprintf(fp_cpp, \");\\n\");\n+    }\n+  }\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 2)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class TestRemovalPeephole {\n+    long[] valuesLong1;\n+    long[] valuesLong2;\n+    int[] valuesInt1;\n+    int[] valuesInt2;\n+    long valueLong1;\n+    long valueLong2;\n+    int valueInt1;\n+    int valueInt2;\n+\n+    @Setup\n+    public void setup() {\n+        Random random = new Random(42);\n+        valuesLong1 = new long[128];\n+        valuesLong2 = new long[128];\n+        for (int i = 0; i < valuesLong1.length; i++) {\n+            valuesLong1[i] = random.nextLong();\n+        }\n+        for (int i = 0; i < valuesLong2.length; i++) {\n+            valuesLong2[i] = random.nextLong();\n+        }\n+\n+        valuesInt1 = new int[128];\n+        valuesInt2 = new int[128];\n+        for (int i = 0; i < valuesInt1.length; i++) {\n+            valuesInt1[i] = random.nextInt();\n+        }\n+        for (int i = 0; i < valuesInt2.length; i++) {\n+            valuesInt2[i] = random.nextInt();\n+        }\n+        valueLong1 = random.nextLong();\n+        valueLong2 = random.nextLong();\n+        valueInt1 = random.nextInt();\n+        valueInt2 = random.nextInt();\n+    }\n+\n+    @Benchmark\n+    public void benchmarkAndTestFusableInt(Blackhole bh) {\n+        for (int i = 0; i < valuesInt1.length; i++) {\n+            int value1 = valuesInt1[i];\n+            int value2 = valuesInt2[i];\n+            int withAnd1 = value1 & 0xF;\n+            int withAnd2 = value2 & 0xF;\n+\n+            bh.consume(withAnd1 > 0x0 && withAnd2 > 0x0 && withAnd1 < 0xF && withAnd2 < 0xF);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmarkAndTestFusableLong(Blackhole bh) {\n+        for (int i = 0; i < valuesLong1.length; i++) {\n+            long value1 = valuesLong1[i];\n+            long value2 = valuesLong2[i];\n+            long withAnd1 = value1 & 0xFFFFFFFFFFL;\n+            long withAnd2 = value2 & 0xFFFFFFFFFFL;\n+\n+            bh.consume(withAnd1 > 0x0L && withAnd2 > 0x0L && withAnd1 < 0xFFFFFFFFFFL && withAnd2 < 0xFFFFFFFFFFL);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmarkOrTestFusableInt(Blackhole bh) {\n+        for (int i = 0; i < valuesInt1.length; i++) {\n+            int value1 = valuesInt1[i];\n+            int value2 = valuesInt2[i];\n+            int withAnd1 = value1 | 0xF;\n+            int withAnd2 = value2 | 0xF;\n+\n+            bh.consume(withAnd1 > 0x0 && withAnd2 > 0x0 && withAnd1 < 0xF && withAnd2 < 0xF);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmarkOrTestFusableLong(Blackhole bh) {\n+        for (int i = 0; i < valuesLong1.length; i++) {\n+            long value1 = valuesLong1[i];\n+            long value2 = valuesLong2[i];\n+            long withAnd1 = value1 | 0xFFFFFFFFFFL;\n+            long withAnd2 = value2 | 0xFFFFFFFFFFL;\n+\n+            bh.consume(withAnd1 > 0x0L && withAnd2 > 0x0L && withAnd1 < 0xFFFFFFFFFFL && withAnd2 < 0xFFFFFFFFFFL);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmarkXorTestFusableInt(Blackhole bh) {\n+        for (int i = 0; i < valuesInt1.length; i++) {\n+            int value1 = valuesInt1[i];\n+            int value2 = valuesInt2[i];\n+            int withAnd1 = value1 ^ 0xF;\n+            int withAnd2 = value2 ^ 0xF;\n+\n+            bh.consume(withAnd1 > 0x0 && withAnd2 > 0x0 && withAnd1 < 0xF && withAnd2 < 0xF);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmarkXorTestFusableLong(Blackhole bh) {\n+        for (int i = 0; i < valuesLong1.length; i++) {\n+            long value1 = valuesLong1[i];\n+            long value2 = valuesLong2[i];\n+            long withAnd1 = value1 ^ 0xFFFFFFFFFFL;\n+            long withAnd2 = value2 ^ 0xFFFFFFFFFFL;\n+\n+            bh.consume(withAnd1 > 0x0L && withAnd2 > 0x0L && withAnd1 < 0xFFFFFFFFFFL && withAnd2 < 0xFFFFFFFFFFL);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void benchmarkAndTestFusableIntSingle(Blackhole bh) {\n+        int withAnd1 = valueInt1 & 0xF;\n+        int withAnd2 = valueInt2 & 0xF;\n+\n+        bh.consume(withAnd1 > 0x0 && withAnd2 > 0x0 && withAnd1 < 0xF && withAnd2 < 0xF);\n+    }\n+\n+    @Benchmark\n+    public void benchmarkAndTestFusableLongSingle(Blackhole bh) {\n+        long withAnd1 = valueLong1 & 0xFFFFFFFFFFL;\n+        long withAnd2 = valueLong2 & 0xFFFFFFFFFFL;\n+\n+        bh.consume(withAnd1 > 0x0L && withAnd2 > 0x0L && withAnd1 < 0xFFFFFFFFFFL && withAnd2 < 0xFFFFFFFFFFL);\n+    }\n+\n+    @Benchmark\n+    public void benchmarkOrTestFusableIntSingle(Blackhole bh) {\n+        int withAnd1 = valueInt1 | 0xF;\n+        int withAnd2 = valueInt2 | 0xF;\n+\n+        bh.consume(withAnd1 > 0x0 && withAnd2 > 0x0 && withAnd1 < 0xF && withAnd2 < 0xF);\n+    }\n+\n+    @Benchmark\n+    public void benchmarkOrTestFusableLongSingle(Blackhole bh) {\n+        long withAnd1 = valueLong1 | 0xFFFFFFFFFFL;\n+        long withAnd2 = valueLong2 | 0xFFFFFFFFFFL;\n+\n+        bh.consume(withAnd1 > 0x0L && withAnd2 > 0x0L && withAnd1 < 0xFFFFFFFFFFL && withAnd2 < 0xFFFFFFFFFFL);\n+    }\n+\n+    @Benchmark\n+    public void benchmarkXorTestFusableIntSingle(Blackhole bh) {\n+        int withAnd1 = valueInt1 ^ 0xF;\n+        int withAnd2 = valueInt2 ^ 0xF;\n+\n+        bh.consume(withAnd1 > 0x0 && withAnd2 > 0x0 && withAnd1 < 0xF && withAnd2 < 0xF);\n+    }\n+\n+    @Benchmark\n+    public void benchmarkXorTestFusableLongSingle(Blackhole bh) {\n+        long withAnd1 = valueLong1 ^ 0xFFFFFFFFFFL;\n+        long withAnd2 = valueLong2 ^ 0xFFFFFFFFFFL;\n+\n+        bh.consume(withAnd1 > 0x0L && withAnd2 > 0x0L && withAnd1 < 0xFFFFFFFFFFL && withAnd2 < 0xFFFFFFFFFFL);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/TestRemovalPeephole.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"}]}