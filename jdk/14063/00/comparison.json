{"files":[{"patch":"@@ -26,0 +26,2 @@\n+\n+import java.nio.ByteOrder;\n@@ -36,8 +38,9 @@\n-    OTHER,      \/\/ An unknown architecture not specifically named\n-    X64,        \/\/ Represents AMD64 and X86_64\n-    X86,\n-    AARCH64,\n-    ARM,\n-    RISCV64,\n-    S390,\n-    PPC64,\n+    OTHER(0, null),          \/\/ An unknown architecture not specifically named\n+    X64(64, ByteOrder.LITTLE_ENDIAN),  \/\/ Represents AMD64 and X86_64\n+    X86(32, ByteOrder.LITTLE_ENDIAN),\n+    AARCH64(64, ByteOrder.LITTLE_ENDIAN),\n+    ARM(32, ByteOrder.LITTLE_ENDIAN),\n+    RISCV64(64, ByteOrder.LITTLE_ENDIAN),\n+    S390(64, ByteOrder.BIG_ENDIAN),\n+    PPC64(64, ByteOrder.BIG_ENDIAN),\n+    PPC64LE(64, ByteOrder.LITTLE_ENDIAN),\n@@ -46,0 +49,48 @@\n+    private final int addrSize;\n+    private final ByteOrder byteOrder;\n+\n+    \/**\n+     * Construct an Arctecture with number of address bits and byte order.\n+     * @param addrSize number of address bits, typically 64 or 32\n+     * @param byteOrder the byte order, big-endian or little-endian\n+     *\/\n+    Architecture(int addrSize, ByteOrder byteOrder) {\n+        this.addrSize = addrSize;\n+        this.byteOrder = byteOrder;\n+    }\n+\n+    \/**\n+     * {@return the number of address bits, typically 64 or 32}\n+     *\/\n+    public int addressSize() {\n+        return addrSize;\n+    }\n+\n+    \/**\n+     * {@return the byte order, {@link ByteOrder#BIG_ENDIAN} or {@link ByteOrder#LITTLE_ENDIAN}}\n+     *\/\n+    public ByteOrder byteOrder() {\n+        return byteOrder;\n+    }\n+\n+    \/**\n+     * {@return the Architecture by name or an alias for the architecture}\n+     * The names are mapped to upper case before mapping to an Architecture.\n+     * @param archName an Architecture name or alias for the architecture.\n+     * @throws IllegalArgumentException if the name is not an alias or an Architecture name\n+     *\/\n+    public static Architecture lookupByName(String archName) {\n+        archName = OperatingSystem.toUpperCase(archName); \/\/ normalize to uppercase\n+        try {\n+            return Architecture.valueOf(archName);\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ Map well known aliases (UPPER case)\n+            return switch (archName) {\n+                case \"X86_64\", \"AMD64\" -> X64;\n+                case \"I386\" -> X86;\n+                case \"S390X\" -> S390;\n+                default -> throw iae;\n+            };\n+        }\n+    }\n+\n@@ -81,2 +132,1 @@\n-     * {@return {@code true} if the current architecture is PPC64}\n-     * Use {@link #isLittleEndian()} to determine big or little endian.\n+     * {@return {@code true} if the current architecture is PPC64, big-endian}\n@@ -89,0 +139,8 @@\n+    \/**\n+     * {@return {@code true} if the current architecture is PPC64, little-endian}\n+     *\/\n+    @ForceInline\n+    public static boolean isPPC64LE() {\n+        return PlatformProps.TARGET_ARCH_IS_PPC64LE;\n+    }\n+\n@@ -132,1 +190,1 @@\n-     * Names not recognized are mapped to Architecture.OTHER.\n+     * Aliases and Names not recognized are mapped to Architecture.OTHER.\n@@ -136,1 +194,1 @@\n-            return Architecture.valueOf(archName.toUpperCase(Locale.ROOT));\n+            return Architecture.valueOf(OperatingSystem.toUpperCase(archName));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Architecture.java","additions":70,"deletions":12,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -130,4 +130,14 @@\n-        \/\/ Too early to use Locale conversions, manually do uppercase\n-        StringBuilder sb = new StringBuilder(osName);\n-        for (int i = 0; i < sb.length(); i++) {\n-            char ch = sb.charAt(i);\n+        return OperatingSystem.valueOf(toUpperCase(osName));\n+    }\n+\n+    \/**\n+     * {@return Simple conversion of ASCII to upper case; used when too early to use Locale conversions}\n+     *\n+     * @param str a string\n+     * @return the string with lower case ascii converted to upper case\n+     *\/\n+    \/* package-private *\/\n+    static String toUpperCase(String str) {\n+        StringBuilder sb = new StringBuilder(str);\n+        for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n@@ -138,2 +148,1 @@\n-        osName = sb.toString();\n-        return OperatingSystem.valueOf(osName);\n+        return sb.toString();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OperatingSystem.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    static final boolean TARGET_ARCH_IS_PPC64LE = \"@@OPENJDK_TARGET_CPU@@\" == \"ppc64le\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/PlatformProps.java.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import java.nio.ByteOrder;\n@@ -33,0 +34,1 @@\n+import static jdk.internal.util.Architecture.PPC64LE;\n@@ -44,1 +46,0 @@\n-import static org.junit.jupiter.api.Assertions.fail;\n@@ -55,1 +56,1 @@\n-    private static boolean IS_BIG_ENDIAN = Unsafe.getUnsafe().isBigEndian();\n+    private static final boolean IS_BIG_ENDIAN = Unsafe.getUnsafe().isBigEndian();\n@@ -57,1 +58,1 @@\n-    private static boolean IS_64BIT_ADDRESS = Unsafe.getUnsafe().addressSize() == 8;\n+    private static final boolean IS_64BIT_ADDRESS = Unsafe.getUnsafe().addressSize() == 8;\n@@ -74,1 +75,2 @@\n-            case \"ppc64\", \"ppc64le\" -> PPC64;\n+            case \"ppc64\" -> PPC64;\n+            case \"ppc64le\" -> PPC64LE;\n@@ -92,1 +94,3 @@\n-                Arguments.of(PPC64, Architecture.isPPC64())\n+                Arguments.of(PPC64, Architecture.isPPC64()),\n+                Arguments.of(PPC64LE, Architecture.isPPC64LE()),\n+                Arguments.of(OTHER, false)\n@@ -104,0 +108,36 @@\n+    \/**\n+     * Test various Architecture names vs Arch enums.\n+     * @return a stream of arguments for parameterized test\n+     *\/\n+    private static Stream<Arguments> archNames() {\n+        return Stream.of(\n+                Arguments.of(\"x64\", X64, 64, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"X86_64\", X64, 64, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"x86\", X86, 32, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"i386\", X86, 32, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"aarch64\", AARCH64, 64, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"arm\", ARM, 32, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"riscv64\", RISCV64, 64, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"s390\", S390, 64, ByteOrder.BIG_ENDIAN),\n+                Arguments.of(\"s390x\", S390, 64, ByteOrder.BIG_ENDIAN),\n+                Arguments.of(\"ppc64\", PPC64, 64, ByteOrder.BIG_ENDIAN),\n+                Arguments.of(\"ppc64le\", PPC64LE, 64, ByteOrder.LITTLE_ENDIAN)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"archNames\")\n+    public void isArch(String archName, Architecture arch, int addrSize, ByteOrder byteOrder) {\n+        Architecture actual = Architecture.lookupByName(archName);\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName\");\n+\n+        actual = Architecture.lookupByName(archName.toUpperCase(Locale.ROOT));\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName (upper-case)\");\n+\n+        actual = Architecture.lookupByName(archName.toLowerCase(Locale.ROOT));\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName (lower-case)\");\n+\n+        assertEquals(addrSize, actual.addressSize(), \"Wrong address size\");\n+        assertEquals(byteOrder, actual.byteOrder(), \"Wrong byteOrder\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/util\/ArchTest.java","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"}]}