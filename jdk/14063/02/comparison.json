{"files":[{"patch":"@@ -55,3 +55,1 @@\n-ifneq ($(filter $(OPENJDK_TARGET_CPU), ppc64le), )\n-  OPENJDK_TARGET_ARCH_CANONICAL = ppc64\n-else ifneq ($(filter $(OPENJDK_TARGET_CPU), s390x), )\n+ifneq ($(filter $(OPENJDK_TARGET_CPU), s390x), )\n","filename":"make\/modules\/java.base\/gensrc\/GensrcMisc.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+\n+import java.nio.ByteOrder;\n@@ -36,8 +38,13 @@\n-    OTHER,      \/\/ An unknown architecture not specifically named\n-    X64,        \/\/ Represents AMD64 and X86_64\n-    X86,\n-    AARCH64,\n-    ARM,\n-    RISCV64,\n-    S390,\n-    PPC64,\n+    \/*\n+     * An unknown architecture not specifically named.\n+     * The addrSize and ByteOrder values are those of the current architecture.\n+     *\/\n+    OTHER(is64bit() ? 64 : 32, ByteOrder.nativeOrder()),\n+    X64(64, ByteOrder.LITTLE_ENDIAN),  \/\/ Represents AMD64 and X86_64\n+    X86(32, ByteOrder.LITTLE_ENDIAN),\n+    AARCH64(64, ByteOrder.LITTLE_ENDIAN),\n+    ARM(32, ByteOrder.LITTLE_ENDIAN),\n+    RISCV64(64, ByteOrder.LITTLE_ENDIAN),\n+    S390(64, ByteOrder.BIG_ENDIAN),\n+    PPC64(64, ByteOrder.BIG_ENDIAN),\n+    PPC64LE(64, ByteOrder.LITTLE_ENDIAN),\n@@ -46,0 +53,57 @@\n+    private final int addrSize;\n+    private final ByteOrder byteOrder;\n+\n+    \/**\n+     * Construct an Arctecture with number of address bits and byte order.\n+     * @param addrSize number of address bits, typically 64 or 32\n+     * @param byteOrder the byte order, big-endian or little-endian\n+     *\/\n+    Architecture(int addrSize, ByteOrder byteOrder) {\n+        this.addrSize = addrSize;\n+        this.byteOrder = byteOrder;\n+    }\n+\n+    \/**\n+     * {@return the number of address bits, typically 64 or 32}\n+     *\/\n+    public int addressSize() {\n+        return addrSize;\n+    }\n+\n+    \/**\n+     * {@return the byte order, {@link ByteOrder#BIG_ENDIAN} or {@link ByteOrder#LITTLE_ENDIAN}}\n+     *\/\n+    public ByteOrder byteOrder() {\n+        return byteOrder;\n+    }\n+\n+    \/**\n+     * {@return the Architecture by name or an alias for the architecture}\n+     * The names are mapped to upper case before mapping to an Architecture.\n+     * @param archName an Architecture name or alias for the architecture.\n+     * @throws IllegalArgumentException if the name is not an alias or an Architecture name\n+     *\/\n+    public static Architecture lookupByName(String archName) {\n+        archName = archName.toUpperCase(Locale.ROOT); \/\/ normalize to uppercase\n+        return switch (archName) {\n+            case \"X86_64\", \"AMD64\" -> X64;\n+            case \"I386\" -> X86;\n+            case \"S390X\" -> S390;\n+            default -> Architecture.valueOf(archName);\n+        };\n+    }\n+\n+    \/**\n+     * Returns the Architecture of the built architecture.\n+     * Build time names are mapped to respective uppercase enum values.\n+     * Names not recognized are mapped to Architecture.OTHER.\n+     *\/\n+    private static Architecture initArch(String archName) {\n+        try {\n+            return lookupByName(archName);\n+        } catch (IllegalArgumentException ile) {\n+            return Architecture.OTHER;\n+        }\n+    }\n+\n+    \/\/ Initialize the architecture by mapping aliases and names to the enum values.\n@@ -81,2 +145,1 @@\n-     * {@return {@code true} if the current architecture is PPC64}\n-     * Use {@link #isLittleEndian()} to determine big or little endian.\n+     * {@return {@code true} if the current architecture is PPC64, big-endian}\n@@ -89,0 +152,8 @@\n+    \/**\n+     * {@return {@code true} if the current architecture is PPC64, little-endian}\n+     *\/\n+    @ForceInline\n+    public static boolean isPPC64LE() {\n+        return PlatformProps.TARGET_ARCH_IS_PPC64LE;\n+    }\n+\n@@ -127,14 +198,0 @@\n-\n-\n-    \/**\n-     * Returns the Architecture of the built architecture.\n-     * Build time names are mapped to respective uppercase enum values.\n-     * Names not recognized are mapped to Architecture.OTHER.\n-     *\/\n-    private static Architecture initArch(String archName) {\n-        try {\n-            return Architecture.valueOf(archName.toUpperCase(Locale.ROOT));\n-        } catch (IllegalArgumentException ile) {\n-            return Architecture.OTHER;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Architecture.java","additions":81,"deletions":24,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.util.Locale;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OperatingSystem.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    static final boolean TARGET_ARCH_IS_PPC64LE = \"@@OPENJDK_TARGET_CPU@@\" == \"ppc64le\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/PlatformProps.java.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-        archName = archName.replace(\"ppc64le\", \"PPC64\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Platform.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import java.nio.ByteOrder;\n@@ -33,0 +34,1 @@\n+import static jdk.internal.util.Architecture.PPC64LE;\n@@ -44,1 +46,0 @@\n-import static org.junit.jupiter.api.Assertions.fail;\n@@ -55,1 +56,1 @@\n-    private static boolean IS_BIG_ENDIAN = Unsafe.getUnsafe().isBigEndian();\n+    private static final boolean IS_BIG_ENDIAN = Unsafe.getUnsafe().isBigEndian();\n@@ -57,1 +58,1 @@\n-    private static boolean IS_64BIT_ADDRESS = Unsafe.getUnsafe().addressSize() == 8;\n+    private static final boolean IS_64BIT_ADDRESS = Unsafe.getUnsafe().addressSize() == 8;\n@@ -74,1 +75,2 @@\n-            case \"ppc64\", \"ppc64le\" -> PPC64;\n+            case \"ppc64\" -> PPC64;\n+            case \"ppc64le\" -> PPC64LE;\n@@ -92,1 +94,3 @@\n-                Arguments.of(PPC64, Architecture.isPPC64())\n+                Arguments.of(PPC64, Architecture.isPPC64()),\n+                Arguments.of(PPC64LE, Architecture.isPPC64LE()),\n+                Arguments.of(OTHER, false)\n@@ -104,0 +108,36 @@\n+    \/**\n+     * Test various Architecture names vs Arch enums.\n+     * @return a stream of arguments for parameterized test\n+     *\/\n+    private static Stream<Arguments> archNames() {\n+        return Stream.of(\n+                Arguments.of(\"x64\", X64, 64, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"X86_64\", X64, 64, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"x86\", X86, 32, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"i386\", X86, 32, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"aarch64\", AARCH64, 64, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"arm\", ARM, 32, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"riscv64\", RISCV64, 64, ByteOrder.LITTLE_ENDIAN),\n+                Arguments.of(\"s390\", S390, 64, ByteOrder.BIG_ENDIAN),\n+                Arguments.of(\"s390x\", S390, 64, ByteOrder.BIG_ENDIAN),\n+                Arguments.of(\"ppc64\", PPC64, 64, ByteOrder.BIG_ENDIAN),\n+                Arguments.of(\"ppc64le\", PPC64LE, 64, ByteOrder.LITTLE_ENDIAN)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"archNames\")\n+    public void isArch(String archName, Architecture arch, int addrSize, ByteOrder byteOrder) {\n+        Architecture actual = Architecture.lookupByName(archName);\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName\");\n+\n+        actual = Architecture.lookupByName(archName.toUpperCase(Locale.ROOT));\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName (upper-case)\");\n+\n+        actual = Architecture.lookupByName(archName.toLowerCase(Locale.ROOT));\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName (lower-case)\");\n+\n+        assertEquals(addrSize, actual.addressSize(), \"Wrong address size\");\n+        assertEquals(byteOrder, actual.byteOrder(), \"Wrong byteOrder\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/util\/ArchTest.java","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"}]}