{"files":[{"patch":"@@ -55,3 +55,1 @@\n-ifneq ($(filter $(OPENJDK_TARGET_CPU), ppc64le), )\n-  OPENJDK_TARGET_ARCH_CANONICAL = ppc64\n-else ifneq ($(filter $(OPENJDK_TARGET_CPU), s390x), )\n+ifneq ($(filter $(OPENJDK_TARGET_CPU), s390x), )\n","filename":"make\/modules\/java.base\/gensrc\/GensrcMisc.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+\n+import java.nio.ByteOrder;\n@@ -36,11 +38,16 @@\n-    OTHER,      \/\/ An unknown architecture not specifically named\n-    X64,        \/\/ Represents AMD64 and X86_64\n-    X86,\n-    AARCH64,\n-    ARM,\n-    RISCV64,\n-    LOONGARCH64,\n-    S390,\n-    PPC64,\n-    MIPSEL,\n-    MIPS64EL\n+    \/*\n+     * An unknown architecture not specifically named.\n+     * The addrSize and ByteOrder values are those of the current architecture.\n+     *\/\n+    OTHER(is64bit() ? 64 : 32, ByteOrder.nativeOrder()),\n+    X64(64, ByteOrder.LITTLE_ENDIAN),  \/\/ Represents AMD64 and X86_64\n+    X86(32, ByteOrder.LITTLE_ENDIAN),\n+    AARCH64(64, ByteOrder.LITTLE_ENDIAN),\n+    ARM(32, ByteOrder.LITTLE_ENDIAN),\n+    RISCV64(64, ByteOrder.LITTLE_ENDIAN),\n+    LOONGARCH64(64, ByteOrder.LITTLE_ENDIAN),\n+    S390(64, ByteOrder.BIG_ENDIAN),\n+    PPC64(64, ByteOrder.BIG_ENDIAN),\n+    PPC64LE(64, ByteOrder.LITTLE_ENDIAN),\n+    MIPSEL(32, ByteOrder.LITTLE_ENDIAN),\n+    MIPS64EL(64, ByteOrder.LITTLE_ENDIAN)\n@@ -49,0 +56,57 @@\n+    private final int addrSize;\n+    private final ByteOrder byteOrder;\n+\n+    \/**\n+     * Construct an Arctecture with number of address bits and byte order.\n+     * @param addrSize number of address bits, typically 64 or 32\n+     * @param byteOrder the byte order, big-endian or little-endian\n+     *\/\n+    Architecture(int addrSize, ByteOrder byteOrder) {\n+        this.addrSize = addrSize;\n+        this.byteOrder = byteOrder;\n+    }\n+\n+    \/**\n+     * {@return the number of address bits, typically 64 or 32}\n+     *\/\n+    public int addressSize() {\n+        return addrSize;\n+    }\n+\n+    \/**\n+     * {@return the byte order, {@link ByteOrder#BIG_ENDIAN} or {@link ByteOrder#LITTLE_ENDIAN}}\n+     *\/\n+    public ByteOrder byteOrder() {\n+        return byteOrder;\n+    }\n+\n+    \/**\n+     * {@return the Architecture by name or an alias for the architecture}\n+     * The names are mapped to upper case before mapping to an Architecture.\n+     * @param archName an Architecture name or alias for the architecture.\n+     * @throws IllegalArgumentException if the name is not an alias or an Architecture name\n+     *\/\n+    public static Architecture lookupByName(String archName) {\n+        archName = archName.toUpperCase(Locale.ROOT); \/\/ normalize to uppercase\n+        return switch (archName) {\n+            case \"X86_64\", \"AMD64\" -> X64;\n+            case \"I386\" -> X86;\n+            case \"S390X\" -> S390;\n+            default -> Architecture.valueOf(archName);\n+        };\n+    }\n+\n+    \/**\n+     * Returns the Architecture of the built architecture.\n+     * Build time names are mapped to respective uppercase enum values.\n+     * Names not recognized are mapped to Architecture.OTHER.\n+     *\/\n+    private static Architecture initArch(String archName) {\n+        try {\n+            return lookupByName(archName);\n+        } catch (IllegalArgumentException ile) {\n+            return Architecture.OTHER;\n+        }\n+    }\n+\n+    \/\/ Initialize the architecture by mapping aliases and names to the enum values.\n@@ -92,2 +156,1 @@\n-     * {@return {@code true} if the current architecture is PPC64}\n-     * Use {@link #isLittleEndian()} to determine big or little endian.\n+     * {@return {@code true} if the current architecture is PPC64, big-endian}\n@@ -100,0 +163,8 @@\n+    \/**\n+     * {@return {@code true} if the current architecture is PPC64, little-endian}\n+     *\/\n+    @ForceInline\n+    public static boolean isPPC64LE() {\n+        return PlatformProps.TARGET_ARCH_IS_PPC64LE;\n+    }\n+\n@@ -154,14 +225,0 @@\n-\n-\n-    \/**\n-     * Returns the Architecture of the built architecture.\n-     * Build time names are mapped to respective uppercase enum values.\n-     * Names not recognized are mapped to Architecture.OTHER.\n-     *\/\n-    private static Architecture initArch(String archName) {\n-        try {\n-            return Architecture.valueOf(archName.toUpperCase(Locale.ROOT));\n-        } catch (IllegalArgumentException ile) {\n-            return Architecture.OTHER;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Architecture.java","additions":84,"deletions":27,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+    static final boolean TARGET_ARCH_IS_PPC64LE = \"@@OPENJDK_TARGET_CPU@@\" == \"ppc64le\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/PlatformProps.java.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-        archName = archName.replace(\"ppc64le\", \"PPC64\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Platform.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -23,0 +23,2 @@\n+import java.nio.ByteOrder;\n+import java.util.List;\n@@ -29,1 +31,0 @@\n-import static jdk.internal.util.Architecture.OTHER;\n@@ -33,0 +34,1 @@\n+import static jdk.internal.util.Architecture.PPC64LE;\n@@ -47,1 +49,0 @@\n-import static org.junit.jupiter.api.Assertions.fail;\n@@ -51,1 +52,1 @@\n- * @bug 8304915\n+ * @bug 8304915 8308452\n@@ -58,1 +59,34 @@\n-    private static boolean IS_BIG_ENDIAN = Unsafe.getUnsafe().isBigEndian();\n+    private static final boolean IS_BIG_ENDIAN = Unsafe.getUnsafe().isBigEndian();\n+\n+    private static final boolean IS_64BIT_ADDRESS = Unsafe.getUnsafe().addressSize() == 8;\n+\n+    \/**\n+     * Test data for Architecture name vs Arch enums, address bits, endian-ness and boolean isXXX() methods..\n+     * Each Argument contains:\n+     *  - the common os.arch name,\n+     *  - the Architecture Enum,\n+     *  - address bits 32\/64,\n+     *  - the byte-order (little or big),\n+     *  - the result of invoking the architecture specific static method\n+     * @return a stream of arguments for parameterized tests\n+     *\/\n+    private static Stream<Arguments> archParams() {\n+        \/\/ In alphabetical order\n+        return Stream.of(\n+                Arguments.of(\"aarch64\", AARCH64, 64, ByteOrder.LITTLE_ENDIAN, Architecture.isAARCH64()),\n+                Arguments.of(\"amd64\", X64, 64, ByteOrder.LITTLE_ENDIAN, Architecture.isX64()),\n+                Arguments.of(\"arm\", ARM, 32, ByteOrder.LITTLE_ENDIAN, Architecture.isAARCH64()),\n+                Arguments.of(\"i386\", X86, 32, ByteOrder.LITTLE_ENDIAN, Architecture.isX86()),\n+                Arguments.of(\"loongarch64\", LOONGARCH64, 64, ByteOrder.LITTLE_ENDIAN, Architecture.isLOONGARCH64()),\n+                Arguments.of(\"mips64el\", MIPS64EL, 64, ByteOrder.LITTLE_ENDIAN, Architecture.isMIPS64EL()),\n+                Arguments.of(\"mipsel\", MIPSEL, 32, ByteOrder.LITTLE_ENDIAN, Architecture.isMIPSEL()),\n+                Arguments.of(\"ppc64\", PPC64, 64, ByteOrder.BIG_ENDIAN, Architecture.isPPC64()),\n+                Arguments.of(\"ppc64le\", PPC64LE, 64, ByteOrder.LITTLE_ENDIAN, Architecture.isPPC64LE()),\n+                Arguments.of(\"riscv64\", RISCV64, 64, ByteOrder.LITTLE_ENDIAN, Architecture.isRISCV64()),\n+                Arguments.of(\"s390\", S390, 64, ByteOrder.BIG_ENDIAN, Architecture.isS390()),\n+                Arguments.of(\"s390x\", S390, 64, ByteOrder.BIG_ENDIAN, Architecture.isS390()),\n+                Arguments.of(\"x64\", X64, 64, ByteOrder.LITTLE_ENDIAN, Architecture.isX64()),\n+                Arguments.of(\"x86\", X86, 32, ByteOrder.LITTLE_ENDIAN, Architecture.isX86()),\n+                Arguments.of(\"x86_64\", X64, 64, ByteOrder.LITTLE_ENDIAN, Architecture.isX64())\n+        );\n+    }\n@@ -60,1 +94,0 @@\n-    private static boolean IS_64BIT_ADDRESS = Unsafe.getUnsafe().addressSize() == 8;\n@@ -68,1 +101,1 @@\n-        System.out.printf(\"System property os.arch: \\\"%s\\\", Architecture.current(): \\\"%s\\\"%n\",\n+        System.err.printf(\"System property os.arch: \\\"%s\\\", Architecture.current(): \\\"%s\\\"%n\",\n@@ -70,15 +103,0 @@\n-        Architecture arch = switch (osArch) {\n-            case \"x86_64\", \"amd64\" -> X64;\n-            case \"x86\", \"i386\" -> X86;\n-            case \"aarch64\" -> AARCH64;\n-            case \"arm\" -> ARM;\n-            case \"riscv64\" -> RISCV64;\n-            case \"loongarch64\" -> LOONGARCH64;\n-            case \"s390x\", \"s390\" -> S390;\n-            case \"ppc64\", \"ppc64le\" -> PPC64;\n-            case \"mipsel\" -> MIPSEL;\n-            case \"mips64el\" -> MIPS64EL;\n-            default -> OTHER;\n-        };\n-        assertEquals(Architecture.current(), arch, \"mismatch in Architecture.current vs \" + osArch);\n-    }\n@@ -86,17 +104,7 @@\n-    \/**\n-     * Test various Architecture enum values vs boolean isXXX() methods.\n-     * @return a stream of arguments for parameterized test\n-     *\/\n-    private static Stream<Arguments> archParams() {\n-        return Stream.of(\n-                Arguments.of(X64, Architecture.isX64()),\n-                Arguments.of(X86, Architecture.isX86()),\n-                Arguments.of(AARCH64, Architecture.isAARCH64()),\n-                Arguments.of(ARM, Architecture.isARM()),\n-                Arguments.of(RISCV64, Architecture.isRISCV64()),\n-                Arguments.of(LOONGARCH64, Architecture.isLOONGARCH64()),\n-                Arguments.of(S390, Architecture.isS390()),\n-                Arguments.of(MIPSEL, Architecture.isMIPSEL()),\n-                Arguments.of(MIPS64EL, Architecture.isMIPS64EL()),\n-                Arguments.of(PPC64, Architecture.isPPC64())\n-        );\n+        \/\/ Map os.arch system property to expected Architecture\n+        List<Architecture> argList = archParams()\n+                .filter(p -> p.get()[0].equals(osArch))\n+                .map(a -> (Architecture)a.get()[1])\n+                .toList();\n+        assertEquals(1, argList.size(), osArch + \" too few or too many matching system property os.arch cases: \" + argList);\n+        assertEquals(Architecture.current(), argList.get(0), \"mismatch in Architecture.current vs \" + osArch);\n@@ -107,1 +115,13 @@\n-    public void isArch(Architecture arch, boolean isArch) {\n+    public void checkParams(String archName, Architecture arch, int addrSize, ByteOrder byteOrder, boolean isArch) {\n+        Architecture actual = Architecture.lookupByName(archName);\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName\");\n+\n+        actual = Architecture.lookupByName(archName.toUpperCase(Locale.ROOT));\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName (upper-case)\");\n+\n+        actual = Architecture.lookupByName(archName.toLowerCase(Locale.ROOT));\n+        assertEquals(actual, arch, \"Wrong Architecture from lookupByName (lower-case)\");\n+\n+        assertEquals(addrSize, actual.addressSize(), \"Wrong address size\");\n+        assertEquals(byteOrder, actual.byteOrder(), \"Wrong byteOrder\");\n+\n","filename":"test\/jdk\/jdk\/internal\/util\/ArchTest.java","additions":59,"deletions":39,"binary":false,"changes":98,"status":"modified"}]}