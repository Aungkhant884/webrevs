{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -65,0 +66,1 @@\n+    @Stable\n@@ -69,0 +71,1 @@\n+    @Stable\n@@ -97,1 +100,2 @@\n-    private volatile ConstructorAccessor constructorAccessor;\n+    @Stable\n+    private ConstructorAccessor constructorAccessor;\n@@ -494,1 +498,1 @@\n-        ConstructorAccessor ca = constructorAccessor;   \/\/ read volatile\n+        ConstructorAccessor ca = constructorAccessor;   \/\/ read @Stable\n@@ -535,2 +539,2 @@\n-        ConstructorAccessor tmp = null;\n-        if (root != null) tmp = root.getConstructorAccessor();\n+        Constructor<?> root = this.root;\n+        ConstructorAccessor tmp = root == null ? null : root.getConstructorAccessor();\n@@ -559,0 +563,1 @@\n+        Constructor<?> root = this.root;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -68,0 +69,1 @@\n+    @Stable\n@@ -73,0 +75,1 @@\n+    @Stable\n@@ -74,0 +77,1 @@\n+    @Stable\n@@ -82,0 +86,1 @@\n+    @Stable\n@@ -84,0 +89,1 @@\n+    @Stable\n@@ -424,0 +430,3 @@\n+            return getFieldAccessor().get(obj);\n+        } else {\n+            return getOverrideFieldAccessor().get(obj);\n@@ -425,1 +434,0 @@\n-        return getFieldAccessor(obj).get(obj);\n@@ -458,0 +466,3 @@\n+            return getFieldAccessor().getBoolean(obj);\n+        } else {\n+            return getOverrideFieldAccessor().getBoolean(obj);\n@@ -459,1 +470,0 @@\n-        return getFieldAccessor(obj).getBoolean(obj);\n@@ -492,0 +502,3 @@\n+            return getFieldAccessor().getByte(obj);\n+        } else {\n+            return getOverrideFieldAccessor().getByte(obj);\n@@ -493,1 +506,0 @@\n-        return getFieldAccessor(obj).getByte(obj);\n@@ -528,0 +540,3 @@\n+            return getFieldAccessor().getChar(obj);\n+        } else {\n+            return getOverrideFieldAccessor().getChar(obj);\n@@ -529,1 +544,0 @@\n-        return getFieldAccessor(obj).getChar(obj);\n@@ -564,0 +578,3 @@\n+            return getFieldAccessor().getShort(obj);\n+        } else {\n+            return getOverrideFieldAccessor().getShort(obj);\n@@ -565,1 +582,0 @@\n-        return getFieldAccessor(obj).getShort(obj);\n@@ -600,0 +616,3 @@\n+            return getFieldAccessor().getInt(obj);\n+        } else {\n+            return getOverrideFieldAccessor().getInt(obj);\n@@ -601,1 +620,0 @@\n-        return getFieldAccessor(obj).getInt(obj);\n@@ -636,0 +654,3 @@\n+            return getFieldAccessor().getLong(obj);\n+        } else {\n+            return getOverrideFieldAccessor().getLong(obj);\n@@ -637,1 +658,0 @@\n-        return getFieldAccessor(obj).getLong(obj);\n@@ -672,0 +692,3 @@\n+            return getFieldAccessor().getFloat(obj);\n+        } else {\n+            return getOverrideFieldAccessor().getFloat(obj);\n@@ -673,1 +696,0 @@\n-        return getFieldAccessor(obj).getFloat(obj);\n@@ -708,0 +730,3 @@\n+            return getFieldAccessor().getDouble(obj);\n+        } else {\n+            return getOverrideFieldAccessor().getDouble(obj);\n@@ -709,1 +734,0 @@\n-        return getFieldAccessor(obj).getDouble(obj);\n@@ -798,0 +822,3 @@\n+            getFieldAccessor().set(obj, value);\n+        } else {\n+            getOverrideFieldAccessor().set(obj, value);\n@@ -799,1 +826,0 @@\n-        getFieldAccessor(obj).set(obj, value);\n@@ -835,0 +861,3 @@\n+            getFieldAccessor().setBoolean(obj, z);\n+        } else {\n+            getOverrideFieldAccessor().setBoolean(obj, z);\n@@ -836,1 +865,0 @@\n-        getFieldAccessor(obj).setBoolean(obj, z);\n@@ -872,0 +900,3 @@\n+            getFieldAccessor().setByte(obj, b);\n+        } else {\n+            getOverrideFieldAccessor().setByte(obj, b);\n@@ -873,1 +904,0 @@\n-        getFieldAccessor(obj).setByte(obj, b);\n@@ -909,0 +939,3 @@\n+            getFieldAccessor().setChar(obj, c);\n+        } else {\n+            getOverrideFieldAccessor().setChar(obj, c);\n@@ -910,1 +943,0 @@\n-        getFieldAccessor(obj).setChar(obj, c);\n@@ -946,0 +978,3 @@\n+            getFieldAccessor().setShort(obj, s);\n+        } else {\n+            getOverrideFieldAccessor().setShort(obj, s);\n@@ -947,1 +982,0 @@\n-        getFieldAccessor(obj).setShort(obj, s);\n@@ -983,0 +1017,3 @@\n+            getFieldAccessor().setInt(obj, i);\n+        } else {\n+            getOverrideFieldAccessor().setInt(obj, i);\n@@ -984,1 +1021,0 @@\n-        getFieldAccessor(obj).setInt(obj, i);\n@@ -1020,0 +1056,3 @@\n+            getFieldAccessor().setLong(obj, l);\n+        } else {\n+            getOverrideFieldAccessor().setLong(obj, l);\n@@ -1021,1 +1060,0 @@\n-        getFieldAccessor(obj).setLong(obj, l);\n@@ -1057,0 +1095,3 @@\n+            getFieldAccessor().setFloat(obj, f);\n+        } else {\n+            getOverrideFieldAccessor().setFloat(obj, f);\n@@ -1058,1 +1099,0 @@\n-        getFieldAccessor(obj).setFloat(obj, f);\n@@ -1094,0 +1134,3 @@\n+            getFieldAccessor().setDouble(obj, d);\n+        } else {\n+            getOverrideFieldAccessor().setDouble(obj, d);\n@@ -1095,1 +1138,0 @@\n-        getFieldAccessor(obj).setDouble(obj, d);\n@@ -1108,6 +1150,8 @@\n-    private FieldAccessor getFieldAccessor(Object obj)\n-        throws IllegalAccessException\n-    {\n-        boolean ov = override;\n-        FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;\n-        return (a != null) ? a : acquireFieldAccessor(ov);\n+    private FieldAccessor getFieldAccessor() {\n+        FieldAccessor a = fieldAccessor;\n+        return (a != null) ? a : acquireFieldAccessor();\n+    }\n+\n+    private FieldAccessor getOverrideFieldAccessor() {\n+        FieldAccessor a = overrideFieldAccessor;\n+        return (a != null) ? a : acquireOverrideFieldAccessor();\n@@ -1120,1 +1164,1 @@\n-    private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) {\n+    private FieldAccessor acquireFieldAccessor() {\n@@ -1123,2 +1167,2 @@\n-        FieldAccessor tmp = null;\n-        if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck);\n+        Field root = this.root;\n+        FieldAccessor tmp = root == null ? null : root.fieldAccessor;\n@@ -1126,4 +1170,1 @@\n-            if (overrideFinalCheck)\n-                overrideFieldAccessor = tmp;\n-            else\n-                fieldAccessor = tmp;\n+            fieldAccessor = tmp;\n@@ -1132,2 +1173,2 @@\n-            tmp = reflectionFactory.newFieldAccessor(this, overrideFinalCheck);\n-            setFieldAccessor(tmp, overrideFinalCheck);\n+            tmp = reflectionFactory.newFieldAccessor(this, false);\n+            setFieldAccessor(tmp);\n@@ -1135,0 +1176,2 @@\n+        return tmp;\n+    }\n@@ -1136,0 +1179,12 @@\n+    private FieldAccessor acquireOverrideFieldAccessor() {\n+        \/\/ First check to see if one has been created yet, and take it\n+        \/\/ if so\n+        Field root = this.root;\n+        FieldAccessor tmp = root == null ? null : root.overrideFieldAccessor;\n+        if (tmp != null) {\n+            overrideFieldAccessor = tmp;\n+        } else {\n+            \/\/ Otherwise fabricate one and propagate it up to the root\n+            tmp = reflectionFactory.newFieldAccessor(this, true);\n+            setOverrideFieldAccessor(tmp);\n+        }\n@@ -1139,4 +1194,9 @@\n-    \/\/ Returns FieldAccessor for this Field object, not looking up\n-    \/\/ the chain to the root\n-    private FieldAccessor getFieldAccessor(boolean overrideFinalCheck) {\n-        return (overrideFinalCheck)? overrideFieldAccessor : fieldAccessor;\n+    \/\/ Sets the fieldAccessor for this Field object and\n+    \/\/ (recursively) its root\n+    private void setFieldAccessor(FieldAccessor accessor) {\n+        fieldAccessor = accessor;\n+        \/\/ Propagate up\n+        Field root = this.root;\n+        if (root != null) {\n+            root.setFieldAccessor(accessor);\n+        }\n@@ -1145,1 +1205,1 @@\n-    \/\/ Sets the FieldAccessor for this Field object and\n+    \/\/ Sets the overrideFieldAccessor for this Field object and\n@@ -1147,5 +1207,2 @@\n-    private void setFieldAccessor(FieldAccessor accessor, boolean overrideFinalCheck) {\n-        if (overrideFinalCheck)\n-            overrideFieldAccessor = accessor;\n-        else\n-            fieldAccessor = accessor;\n+    private void setOverrideFieldAccessor(FieldAccessor accessor) {\n+        overrideFieldAccessor = accessor;\n@@ -1153,0 +1210,1 @@\n+        Field root = this.root;\n@@ -1154,1 +1212,1 @@\n-            root.setFieldAccessor(accessor, overrideFinalCheck);\n+            root.setOverrideFieldAccessor(accessor);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":102,"deletions":44,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-    private volatile MethodAccessor methodAccessor;\n+    @Stable\n+    private MethodAccessor      methodAccessor;\n@@ -668,2 +669,2 @@\n-        MethodAccessor tmp = null;\n-        if (root != null) tmp = root.getMethodAccessor();\n+        Method root = this.root;\n+        MethodAccessor tmp = root == null ? null : root.getMethodAccessor();\n@@ -692,0 +693,1 @@\n+        Method root = this.root;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -29,0 +31,1 @@\n+import java.util.Objects;\n@@ -34,1 +37,7 @@\n-    private ConstructorAccessorImpl delegate;\n+    \/\/ initial non-null delegate\n+    @Stable\n+    private final ConstructorAccessorImpl initialDelegate;\n+    \/\/ alternative delegate: starts as null;\n+    \/\/ only single change from null -> non-null is guaranteed\n+    @Stable\n+    private ConstructorAccessorImpl altDelegate;\n@@ -37,1 +46,1 @@\n-        setDelegate(delegate);\n+        initialDelegate = Objects.requireNonNull(delegate);\n@@ -45,1 +54,6 @@\n-        return delegate.newInstance(args);\n+        return delegate().newInstance(args);\n+    }\n+\n+    private ConstructorAccessorImpl delegate() {\n+        var d = altDelegate;\n+        return  d != null ? d : initialDelegate;\n@@ -49,1 +63,1 @@\n-        this.delegate = delegate;\n+        altDelegate = Objects.requireNonNull(delegate);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DelegatingConstructorAccessorImpl.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -29,0 +31,1 @@\n+import java.util.Objects;\n@@ -34,1 +37,5 @@\n-    private MethodAccessorImpl delegate;\n+    \/\/ initial non-null delegate\n+    @Stable private final MethodAccessorImpl initialDelegate;\n+    \/\/ alternative delegate: starts as null;\n+    \/\/ only single change from null -> non-null is guaranteed\n+    @Stable private  MethodAccessorImpl altDelegate;\n@@ -37,1 +44,1 @@\n-        setDelegate(delegate);\n+        initialDelegate = Objects.requireNonNull(delegate);\n@@ -40,0 +47,1 @@\n+    @Override\n@@ -43,1 +51,6 @@\n-        return delegate.invoke(obj, args);\n+        return delegate().invoke(obj, args);\n+    }\n+\n+    private MethodAccessorImpl delegate() {\n+        var d = altDelegate;\n+        return  d != null ? d : initialDelegate;\n@@ -47,1 +60,1 @@\n-        this.delegate = delegate;\n+        altDelegate = Objects.requireNonNull(delegate);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DelegatingMethodAccessorImpl.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.reflect.Field;\n+\n@@ -34,0 +38,7 @@\n+    @Stable\n+    protected final Field field;\n+\n+    FieldAccessorImpl(Field field) {\n+        this.field = field;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-\n@@ -42,1 +40,1 @@\n-    private DelegatingConstructorAccessorImpl parent;\n+    private final DelegatingConstructorAccessorImpl parent;\n@@ -48,0 +46,1 @@\n+        this.parent = new DelegatingConstructorAccessorImpl(this);\n@@ -80,2 +79,2 @@\n-    void setParent(DelegatingConstructorAccessorImpl parent) {\n-        this.parent = parent;\n+    DelegatingConstructorAccessorImpl getParent() {\n+        return parent;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/NativeConstructorAccessorImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-\n@@ -42,1 +40,1 @@\n-    private DelegatingMethodAccessorImpl parent;\n+    private final DelegatingMethodAccessorImpl parent;\n@@ -48,0 +46,1 @@\n+        this.parent = new DelegatingMethodAccessorImpl(this);\n@@ -80,2 +79,2 @@\n-    void setParent(DelegatingMethodAccessorImpl parent) {\n-        this.parent = parent;\n+    DelegatingMethodAccessorImpl getParent() {\n+        return parent;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/NativeMethodAccessorImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -213,6 +212,2 @@\n-            NativeMethodAccessorImpl acc =\n-                new NativeMethodAccessorImpl(method);\n-            DelegatingMethodAccessorImpl res =\n-                new DelegatingMethodAccessorImpl(acc);\n-            acc.setParent(res);\n-            return res;\n+            NativeMethodAccessorImpl acc = new NativeMethodAccessorImpl(method);\n+            return acc.getParent();\n@@ -255,6 +250,2 @@\n-            NativeConstructorAccessorImpl acc =\n-                new NativeConstructorAccessorImpl(c);\n-            DelegatingConstructorAccessorImpl res =\n-                new DelegatingConstructorAccessorImpl(acc);\n-            acc.setParent(res);\n-            return res;\n+            NativeConstructorAccessorImpl acc = new NativeConstructorAccessorImpl(c);\n+            return acc.getParent();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,1 +43,1 @@\n-    protected final Field   field;\n+    @Stable\n@@ -47,1 +48,1 @@\n-        this.field = field;\n+        super(field);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeFieldAccessorImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -48,0 +49,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeStaticFieldAccessorImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.reflect;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark measuring cold-start of reflective method invocation.\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 30, warmups = 10)\n+public class ReflectionColdstartBenchmark {\n+\n+    static class Nested {\n+        static Object m00(Object p) {return p;}\n+\n+        static Object m01(Object p) {return p;}\n+\n+        static Object m02(Object p) {return p;}\n+\n+        static Object m03(Object p) {return p;}\n+\n+        static Object m04(Object p) {return p;}\n+\n+        static Object m05(Object p) {return p;}\n+\n+        static Object m06(Object p) {return p;}\n+\n+        static Object m07(Object p) {return p;}\n+\n+        static Object m08(Object p) {return p;}\n+\n+        static Object m09(Object p) {return p;}\n+\n+        static Object m0A(Object p) {return p;}\n+\n+        static Object m0B(Object p) {return p;}\n+\n+        static Object m0C(Object p) {return p;}\n+\n+        static Object m0D(Object p) {return p;}\n+\n+        static Object m0E(Object p) {return p;}\n+\n+        static Object m0F(Object p) {return p;}\n+\n+        static Object m10(Object p) {return p;}\n+\n+        static Object m11(Object p) {return p;}\n+\n+        static Object m12(Object p) {return p;}\n+\n+        static Object m13(Object p) {return p;}\n+\n+        static Object m14(Object p) {return p;}\n+\n+        static Object m15(Object p) {return p;}\n+\n+        static Object m16(Object p) {return p;}\n+\n+        static Object m17(Object p) {return p;}\n+\n+        static Object m18(Object p) {return p;}\n+\n+        static Object m19(Object p) {return p;}\n+\n+        static Object m1A(Object p) {return p;}\n+\n+        static Object m1B(Object p) {return p;}\n+\n+        static Object m1C(Object p) {return p;}\n+\n+        static Object m1D(Object p) {return p;}\n+\n+        static Object m1E(Object p) {return p;}\n+\n+        static Object m1F(Object p) {return p;}\n+    }\n+\n+    private Method[] methods;\n+    private Object arg;\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        methods = Nested.class.getDeclaredMethods();\n+        arg = new Object();\n+    }\n+\n+    @Benchmark\n+    public void invokeMethods(Blackhole bh) throws ReflectiveOperationException {\n+        for (Method m : methods) {\n+            bh.consume(m.invoke(null, arg));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionColdstartBenchmark.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,439 @@\n+\/*\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.reflect;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark measuring field access and method invocation using different conditions:\n+ * <ul>\n+ *     <li>Const - Method\/Field is constant-foldable<\/li>\n+ *     <li>Var - Method\/Field is single-instance but not constant-foldable<\/li>\n+ *     <li>Poly - multiple Method\/Field instances used at single call-site<\/li>\n+ * <\/ul>\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 10, time = 1, batchSize = 10)\n+@Measurement(iterations = 10, time = 1, batchSize = 10)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, warmups = 0)\n+public class ReflectionSpeedBenchmark {\n+\n+    static final Method staticMethodConst;\n+    static final Method instanceMethodConst;\n+    static final Field staticFieldConst;\n+    static final Field instanceFieldConst;\n+    static final Constructor<?> constructorConst;\n+    static final Object[] constructorArgs;\n+\n+    static Method staticMethodVar;\n+    static Method instanceMethodVar;\n+    static Field staticFieldVar;\n+    static Field instanceFieldVar;\n+    static Constructor<?> constructorVar;\n+\n+    static Method[] staticMethodsPoly;\n+    static Method[] instanceMethodsPoly;\n+    static Field[] staticFieldsPoly;\n+    static Field[] instanceFieldsPoly;\n+    static Constructor<?>[] constructorsPoly;\n+    static Object[][] constructorsArgsPoly;\n+\n+    static {\n+        try {\n+            staticMethodConst = staticMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumStatic\", int.class, int.class);\n+            instanceMethodConst = instanceMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumInstance\", int.class, int.class);\n+\n+            staticFieldConst = staticFieldVar = ReflectionSpeedBenchmark.class.getDeclaredField(\"staticField\");\n+            instanceFieldConst = instanceFieldVar = ReflectionSpeedBenchmark.class.getDeclaredField(\"instanceField\");\n+\n+            constructorConst = constructorVar = NestedConstruction.class.getDeclaredConstructor();\n+            constructorArgs = new Object[0];\n+\n+            staticMethodsPoly = NestedStatic.class.getDeclaredMethods();\n+            staticFieldsPoly = NestedStatic.class.getDeclaredFields();\n+            instanceMethodsPoly = NestedInstance.class.getDeclaredMethods();\n+            instanceFieldsPoly = NestedInstance.class.getDeclaredFields();\n+\n+            constructorsPoly = NestedConstruction.class.getDeclaredConstructors();\n+            constructorsArgsPoly = new Object[constructorsPoly.length][];\n+            for (int i = 0; i < constructorsPoly.length; i++) {\n+                constructorsArgsPoly[i] = new Object[constructorsPoly[i].getParameterCount()];\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new NoSuchMethodError(e.getMessage());\n+        } catch (NoSuchFieldException e) {\n+            throw new NoSuchFieldError(e.getMessage());\n+        }\n+    }\n+\n+    public static class NestedStatic {\n+        \/\/ # of fields must be 2^N\n+        public static Object\n+            f00, f01, f02, f03, f04, f05, f06, f07, f08, f09, f0A, f0B, f0C, f0D, f0E, f0F,\n+            f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f1A, f1B, f1C, f1D, f1E, f1F;\n+\n+        \/\/ # of methods must be 2^N\n+        public static Object m00(Object p) {return p;}\n+\n+        public static Object m01(Object p) {return p;}\n+\n+        public static Object m02(Object p) {return p;}\n+\n+        public static Object m03(Object p) {return p;}\n+\n+        public static Object m04(Object p) {return p;}\n+\n+        public static Object m05(Object p) {return p;}\n+\n+        public static Object m06(Object p) {return p;}\n+\n+        public static Object m07(Object p) {return p;}\n+\n+        public static Object m08(Object p) {return p;}\n+\n+        public static Object m09(Object p) {return p;}\n+\n+        public static Object m0A(Object p) {return p;}\n+\n+        public static Object m0B(Object p) {return p;}\n+\n+        public static Object m0C(Object p) {return p;}\n+\n+        public static Object m0D(Object p) {return p;}\n+\n+        public static Object m0E(Object p) {return p;}\n+\n+        public static Object m0F(Object p) {return p;}\n+\n+        public static Object m10(Object p) {return p;}\n+\n+        public static Object m11(Object p) {return p;}\n+\n+        public static Object m12(Object p) {return p;}\n+\n+        public static Object m13(Object p) {return p;}\n+\n+        public static Object m14(Object p) {return p;}\n+\n+        public static Object m15(Object p) {return p;}\n+\n+        public static Object m16(Object p) {return p;}\n+\n+        public static Object m17(Object p) {return p;}\n+\n+        public static Object m18(Object p) {return p;}\n+\n+        public static Object m19(Object p) {return p;}\n+\n+        public static Object m1A(Object p) {return p;}\n+\n+        public static Object m1B(Object p) {return p;}\n+\n+        public static Object m1C(Object p) {return p;}\n+\n+        public static Object m1D(Object p) {return p;}\n+\n+        public static Object m1E(Object p) {return p;}\n+\n+        public static Object m1F(Object p) {return p;}\n+    }\n+\n+    public static class NestedInstance {\n+        \/\/ # of fields must be 2^N\n+        public Object\n+            f00, f01, f02, f03, f04, f05, f06, f07, f08, f09, f0A, f0B, f0C, f0D, f0E, f0F,\n+            f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f1A, f1B, f1C, f1D, f1E, f1F;\n+\n+        \/\/ # of methods must be 2^N\n+        public Object m00(Object p) {return p;}\n+\n+        public Object m01(Object p) {return p;}\n+\n+        public Object m02(Object p) {return p;}\n+\n+        public Object m03(Object p) {return p;}\n+\n+        public Object m04(Object p) {return p;}\n+\n+        public Object m05(Object p) {return p;}\n+\n+        public Object m06(Object p) {return p;}\n+\n+        public Object m07(Object p) {return p;}\n+\n+        public Object m08(Object p) {return p;}\n+\n+        public Object m09(Object p) {return p;}\n+\n+        public Object m0A(Object p) {return p;}\n+\n+        public Object m0B(Object p) {return p;}\n+\n+        public Object m0C(Object p) {return p;}\n+\n+        public Object m0D(Object p) {return p;}\n+\n+        public Object m0E(Object p) {return p;}\n+\n+        public Object m0F(Object p) {return p;}\n+\n+        public Object m10(Object p) {return p;}\n+\n+        public Object m11(Object p) {return p;}\n+\n+        public Object m12(Object p) {return p;}\n+\n+        public Object m13(Object p) {return p;}\n+\n+        public Object m14(Object p) {return p;}\n+\n+        public Object m15(Object p) {return p;}\n+\n+        public Object m16(Object p) {return p;}\n+\n+        public Object m17(Object p) {return p;}\n+\n+        public Object m18(Object p) {return p;}\n+\n+        public Object m19(Object p) {return p;}\n+\n+        public Object m1A(Object p) {return p;}\n+\n+        public Object m1B(Object p) {return p;}\n+\n+        public Object m1C(Object p) {return p;}\n+\n+        public Object m1D(Object p) {return p;}\n+\n+        public Object m1E(Object p) {return p;}\n+\n+        public Object m1F(Object p) {return p;}\n+    }\n+\n+    public static class NestedConstruction {\n+        \/\/ # of constructors must be 2^N\n+        public NestedConstruction() {}\n+\n+        public NestedConstruction(Void p1) {}\n+\n+        public NestedConstruction(Void p1, Void p2) {}\n+\n+        public NestedConstruction(Void p1, Void p2, Void p3) {}\n+\n+        public NestedConstruction(Void p1, Void p2, Void p3, Void p4) {}\n+\n+        public NestedConstruction(Void p1, Void p2, Void p3, Void p4, Void p5) {}\n+\n+        public NestedConstruction(Void p1, Void p2, Void p3, Void p4, Void p5, Void p6) {}\n+\n+        public NestedConstruction(Void p1, Void p2, Void p3, Void p4, Void p5, Void p6, Void p7) {}\n+    }\n+\n+    private int rnd = 0;\n+    private int a, b;\n+    private Object o;\n+    private NestedInstance instance;\n+\n+    private int nextRnd() {\n+        return rnd += 7;\n+    }\n+\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+        a = nextRnd();\n+        b = nextRnd();\n+        o = new Object();\n+        instance = new NestedInstance();\n+    }\n+\n+    public static int sumStatic(int a, int b) {\n+        return a + b;\n+    }\n+\n+    public int sumInstance(int a, int b) {\n+        return a + b;\n+    }\n+\n+    public static int staticField;\n+    public int instanceField;\n+\n+    \/\/ methods\n+\n+    @Benchmark\n+    public int staticMethodConst() {\n+        try {\n+            return (Integer) staticMethodConst.invoke(null, a, b);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int instanceMethodConst() {\n+        try {\n+            return (Integer) instanceMethodConst.invoke(this, a, b);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int staticMethodVar() {\n+        try {\n+            return (Integer) staticMethodVar.invoke(null, a, b);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int instanceMethodVar() {\n+        try {\n+            return (Integer) instanceMethodVar.invoke(this, a, b);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object staticMethodPoly() {\n+        try {\n+            return staticMethodsPoly[nextRnd() & (staticMethodsPoly.length - 1)].invoke(null, o);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object instanceMethodPoly() {\n+        try {\n+            return instanceMethodsPoly[nextRnd() & (instanceMethodsPoly.length - 1)].invoke(instance, o);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    \/\/ fields\n+\n+    @Benchmark\n+    public int staticFieldConst() {\n+        try {\n+            return staticFieldConst.getInt(null);\n+        } catch (IllegalAccessException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int instanceFieldConst() {\n+        try {\n+            return instanceFieldConst.getInt(this);\n+        } catch (IllegalAccessException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int staticFieldVar() {\n+        try {\n+            return staticFieldVar.getInt(null);\n+        } catch (IllegalAccessException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int instanceFieldVar() {\n+        try {\n+            return instanceFieldVar.getInt(this);\n+        } catch (IllegalAccessException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object staticFieldPoly() {\n+        try {\n+            return staticFieldsPoly[nextRnd() & (staticFieldsPoly.length - 1)].get(null);\n+        } catch (IllegalAccessException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object instanceFieldPoly() {\n+        try {\n+            return instanceFieldsPoly[nextRnd() & (instanceFieldsPoly.length - 1)].get(instance);\n+        } catch (IllegalAccessException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    \/\/ constructors\n+\n+    @Benchmark\n+    public Object constructorConst() {\n+        try {\n+            return constructorConst.newInstance(constructorArgs);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object constructorVar() {\n+        try {\n+            return constructorVar.newInstance(constructorArgs);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object constructorPoly() {\n+        try {\n+            int i = nextRnd() & (constructorsPoly.length - 1);\n+            return constructorsPoly[i].newInstance(constructorsArgsPoly[i]);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionSpeedBenchmark.java","additions":439,"deletions":0,"binary":false,"changes":439,"status":"added"}]}