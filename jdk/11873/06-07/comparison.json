{"files":[{"patch":"@@ -24,0 +24,5 @@\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -28,3 +33,5 @@\n- * @summary Verify that JNI NewDirectByteBuffer throws IllegalArgumentException\n- * if the capacity is negative or greater than Integer::MAX_VALUE\n- * @run main\/native NewDirectByteBuffer\n+ * @summary Verify that JNI NewDirectByteBuffer throws\n+ * IllegalArgumentException if the capacity is negative or greater than\n+ * Integer::MAX_VALUE\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 8g)\n+ * @run junit\/othervm\/native NewDirectByteBuffer\n@@ -37,18 +44,0 @@\n-    private static final long[] LEGAL_CAPACITIES = {\n-        0L,\n-        1L,\n-        (long)Integer.MAX_VALUE\/2,\n-        (long)Integer.MAX_VALUE - 1,\n-        (long)Integer.MAX_VALUE\n-    };\n-\n-    private static final long[] ILLEGAL_CAPACITIES = {\n-        Long.MIN_VALUE,\n-        (long)Integer.MIN_VALUE - 1L,\n-        -1L,\n-        (long)Integer.MAX_VALUE + 1L,\n-        3_000_000_000L,\n-        5_000_000_000L,\n-        Long.MAX_VALUE\n-    };\n-\n@@ -56,15 +45,9 @@\n-        if (!buf.isDirect())\n-            throw new RuntimeException(\"Buffer is not direct\");\n-        long bufferCapacity = getDirectByteBufferCapacity(buf);\n-        if (bufferCapacity != capacity)\n-            throw new RuntimeException(\"GetDirectBufferCapacity \"\n-                + bufferCapacity + \" is not \" + capacity);\n-        if (buf.capacity() != capacity)\n-            throw new RuntimeException(\"buf.capacity() \"\n-                + buf.capacity() + \" is not \" + capacity);\n-        if (buf.position() != 0)\n-            throw new RuntimeException(\"buf.position() \"\n-                + buf.position() + \" is nonzero\");\n-        if (buf.limit() != capacity)\n-            throw new RuntimeException(\"buf.limit() \"\n-                + buf.limit() + \" is not \" + capacity);\n+        Assertions.assertTrue(buf.isDirect(), \"Buffer is not direct\");\n+        Assertions.assertEquals(capacity, getDirectByteBufferCapacity(buf),\n+            \"GetDirectBufferCapacity returned unexpected value\");\n+        Assertions.assertEquals(capacity, buf.capacity(),\n+            \"Buffer::capacity returned unexpected value\");\n+        Assertions.assertEquals(0L, buf.position(),\n+            \"Buffer::position returned unexpected value\");\n+        Assertions.assertEquals(capacity, buf.limit(),\n+            \"Buffer::limit returned unexpected value\");\n@@ -73,11 +56,12 @@\n-    public static void main(String[] args) {\n-        System.out.println(\"--- Legal Capacities ---\");\n-        for (long cap : LEGAL_CAPACITIES) {\n-            System.out.println(\"Capacity \" + cap);\n-            try {\n-                ByteBuffer buf = newDirectByteBuffer(cap);\n-                if (buf != null) {\n-                    try {\n-                        checkBuffer(buf, cap);\n-                        System.out.println(\"Verified buffer for capacity \" + cap);\n-                    } finally {\n+    @ParameterizedTest\n+    @ValueSource(longs = {0L, 1L, (long)Integer.MAX_VALUE\/2,\n+        (long)Integer.MAX_VALUE - 1, (long)Integer.MAX_VALUE})\n+    void legalCapacities(long capacity) {\n+        try {\n+            final AtomicReference<ByteBuffer> bufHolder = new AtomicReference();\n+            Assertions.assertDoesNotThrow(() -> {\n+                try {\n+                    bufHolder.set(newDirectByteBuffer(capacity));\n+                } finally {\n+                    ByteBuffer buf = bufHolder.get();\n+                    if (buf != null) {\n@@ -86,2 +70,0 @@\n-                } else {\n-                    throw new RuntimeException(\"Direct buffer is null but no OOME\");\n@@ -89,2 +71,4 @@\n-            } catch (OutOfMemoryError ignored) {\n-                \/\/ Ignore the error so test may continue\n+            });\n+            ByteBuffer buf = bufHolder.get();\n+            if (buf != null) {\n+                checkBuffer(buf, capacity);\n@@ -92,0 +76,2 @@\n+        } catch (OutOfMemoryError ignored) {\n+            \/\/ Ignore the error\n@@ -93,0 +79,1 @@\n+    }\n@@ -94,5 +81,8 @@\n-        System.out.println(\"\\n--- Illegal Capacities ---\");\n-        for (long cap : ILLEGAL_CAPACITIES) {\n-            System.out.println(\"Capacity \" + cap);\n-            try {\n-                ByteBuffer buf = newDirectByteBuffer(cap);\n+    @ParameterizedTest\n+    @ValueSource(longs = {Long.MIN_VALUE, (long)Integer.MIN_VALUE - 1L, -1L,\n+        (long)Integer.MAX_VALUE + 1L, 3_000_000_000L, 5_000_000_000L,\n+        Long.MAX_VALUE})\n+    void illegalCapacities(long capacity) {\n+        try {\n+            Assertions.assertThrows(IllegalArgumentException.class, () -> {\n+                ByteBuffer buf = newDirectByteBuffer(capacity);\n@@ -102,4 +92,3 @@\n-                throw new RuntimeException(\"IAE not thrown for capacity \" + cap);\n-            } catch (IllegalArgumentException expected) {\n-                System.out.println(\"Caught expected IAE for capacity \" + cap);\n-            }\n+            });\n+        } catch (OutOfMemoryError ignored) {\n+            \/\/ Ignore the error\n","filename":"test\/jdk\/java\/nio\/jni\/NewDirectByteBuffer.java","additions":49,"deletions":60,"binary":false,"changes":109,"status":"modified"}]}