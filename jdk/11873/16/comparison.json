{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libNewDirectByteBuffer := $(WIN_LIB_JAVA)\n@@ -84,0 +85,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libNewDirectByteBuffer := -ljava\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2995,1 +2995,1 @@\n-    directByteBufferConstructor = env->GetMethodID(directByteBufferClass, \"<init>\", \"(JI)V\");\n+    directByteBufferConstructor = env->GetMethodID(directByteBufferClass, \"<init>\", \"(JJ)V\");\n@@ -3047,4 +3047,1 @@\n-  \/\/ NOTE that package-private DirectByteBuffer constructor currently\n-  \/\/ takes int capacity\n-  jint  cap  = (jint)  capacity;\n-  jobject ret = env->NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);\n+  jobject ret = env->NewObject(directByteBufferClass, directByteBufferConstructor, addr, capacity);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,0 +181,1 @@\n+    \/\/ The long-valued capacity is restricted to int range.\n@@ -182,2 +183,2 @@\n-    private Direct$Type$Buffer(long addr, int cap) {\n-        super(-1, 0, cap, cap, null);\n+    private Direct$Type$Buffer(long addr, long cap) {\n+        super(-1, 0, checkCapacity(cap), (int)cap, null);\n@@ -189,0 +190,16 @@\n+    \/\/ Throw an IllegalArgumentException if the capacity is not in\n+    \/\/ the range [0, Integer.MAX_VALUE]\n+    \/\/\n+    private static int checkCapacity(long capacity) {\n+        if (capacity < 0) {\n+            throw new IllegalArgumentException\n+                (\"JNI NewDirectByteBuffer passed capacity < 0: (\"\n+                + capacity + \")\");\n+        } else if (capacity > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException\n+                (\"JNI NewDirectByteBuffer passed capacity > Integer.MAX_VALUE: (\"\n+                + capacity + \")\");\n+        }\n+        return (int)capacity;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8299684\n+ * @summary Unit test for the JNI function NewDirectByteBuffer\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 8g)\n+ * @modules java.base\/jdk.internal.misc\n+ * @run junit\/othervm\/native NewDirectByteBuffer\n+ *\/\n+public class NewDirectByteBuffer {\n+    private static final Unsafe UNSAFE;\n+    static {\n+        System.loadLibrary(\"NewDirectByteBuffer\");\n+        UNSAFE = Unsafe.getUnsafe();\n+    }\n+\n+    private static final void checkBuffer(ByteBuffer buf, long capacity) {\n+        \/\/ Verify that the JNI function returns the correct capacity\n+        assertEquals(capacity, getDirectByteBufferCapacity(buf),\n+            \"GetDirectBufferCapacity returned unexpected value\");\n+\n+        \/\/ Verify that the initial state values are correct\n+        assertTrue(buf.isDirect(), \"Buffer is not direct\");\n+        assertFalse(buf.hasArray(), \"Buffer has an array\");\n+        if (capacity > 0) {\n+            assertTrue(buf.hasRemaining(), \"Buffer has no remaining values\");\n+        }\n+        assertFalse(buf.isReadOnly(), \"Buffer s read-only\");\n+        assertEquals(capacity, buf.capacity(),\n+            \"Buffer::capacity returned unexpected value\");\n+        assertEquals(0L, buf.position(),\n+            \"Buffer::position returned unexpected value\");\n+        assertEquals(capacity, buf.limit(),\n+            \"Buffer::limit returned unexpected value\");\n+\n+        \/\/ Verify that the various state mutators work correctly\n+        int halfPos = buf.capacity()\/2;\n+        buf.position(halfPos);\n+        assertEquals(halfPos, buf.position(),\n+            \"Position not set to halfPos\");\n+        assertEquals(buf.capacity() - halfPos, buf.remaining(),\n+            \"Remaining not capacity - halfPos\");\n+\n+        buf.mark();\n+\n+        int twoThirdsPos = 2*(buf.capacity()\/3);\n+        buf.position(twoThirdsPos);\n+        assertEquals(twoThirdsPos, buf.position(),\n+            \"Position not set to twoThirdsPos\");\n+        assertEquals(buf.capacity() - twoThirdsPos, buf.remaining(),\n+            \"Remaining != capacity - twoThirdsPos\");\n+\n+        buf.reset();\n+        assertEquals(halfPos, buf.position(),\n+            \"Buffer not reset to halfPos\");\n+\n+        buf.limit(twoThirdsPos);\n+        assertEquals(twoThirdsPos, buf.limit(),\n+            \"Limit not set to twoThirdsPos\");\n+        assertEquals(twoThirdsPos - halfPos, buf.remaining(),\n+            \"Remaining != twoThirdsPos - halfPos\");\n+\n+        buf.position(twoThirdsPos);\n+        assertFalse(buf.hasRemaining(), \"Buffer has remaining values\");\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(longs = {0L, 1L, (long)Integer.MAX_VALUE\/2,\n+        (long)Integer.MAX_VALUE - 1, (long)Integer.MAX_VALUE})\n+    void legalCapacities(long capacity) {\n+        long addr;\n+        try {\n+            addr = UNSAFE.allocateMemory(capacity);\n+        } catch (OutOfMemoryError ignore) {\n+            System.err.println(\"legalCapacities( \" + capacity\n+                + \") test skipped due to insufficient memory\");\n+            return;\n+        }\n+        try {\n+            ByteBuffer buf = newDirectByteBuffer(addr, capacity);\n+            assertEquals(addr, getDirectBufferAddress(buf),\n+                \"GetDirectBufferAddress does not return supplied address\");\n+            checkBuffer(buf, capacity);\n+        } finally {\n+            UNSAFE.freeMemory(addr);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(longs = {Long.MIN_VALUE, (long)Integer.MIN_VALUE - 1L, -1L,\n+        (long)Integer.MAX_VALUE + 1L, 3_000_000_000L, 5_000_000_000L,\n+        Long.MAX_VALUE})\n+    void illegalCapacities(long capacity) {\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            long addr = UNSAFE.allocateMemory(1);\n+            try {\n+                ByteBuffer buf = newDirectByteBuffer(addr, capacity);\n+            } finally {\n+                UNSAFE.freeMemory(addr);\n+            }\n+        });\n+    }\n+\n+    \/\/ See libNewDirectByteBuffer.c for implementations.\n+    private static native ByteBuffer newDirectByteBuffer(long addr, long capacity);\n+    private static native long getDirectByteBufferCapacity(ByteBuffer buf);\n+    private static native long getDirectBufferAddress(ByteBuffer buf);\n+}\n","filename":"test\/jdk\/java\/nio\/jni\/NewDirectByteBuffer.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdlib.h>\n+#include \"jni.h\"\n+\n+\/\/ private static native ByteBuffer newDirectByteBuffer(long addr, long size)\n+JNIEXPORT jobject JNICALL\n+Java_NewDirectByteBuffer_newDirectByteBuffer\n+    (JNIEnv *env, jclass cls, jlong addr, jlong size)\n+{\n+    \/\/ Create the direct byte buffer, freeing the native memory if an exception\n+    \/\/ is thrown while constructing the buffer\n+    return (*env)->NewDirectByteBuffer(env, (void*)addr, size);\n+}\n+\n+\/\/ private static native long getDirectByteBufferCapacity(ByteBuffer buf)\n+JNIEXPORT jlong JNICALL\n+Java_NewDirectByteBuffer_getDirectByteBufferCapacity\n+    (JNIEnv *env, jclass cls, jobject buf)\n+{\n+    return (*env)->GetDirectBufferCapacity(env, buf);\n+}\n+\n+\/\/ private static native long getDirectBufferAddress(ByteBuffer buf)\n+JNIEXPORT jlong JNICALL\n+Java_NewDirectByteBuffer_getDirectBufferAddress\n+    (JNIEnv *env, jclass cls, jobject buf)\n+{\n+    return (jlong)(*env)->GetDirectBufferAddress(env, buf);\n+}\n","filename":"test\/jdk\/java\/nio\/jni\/libNewDirectByteBuffer.c","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"}]}