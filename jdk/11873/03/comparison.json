{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libNewDirectByteBuffer := -ljava -lc\n@@ -84,0 +85,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libNewDirectByteBuffer := -ljava -lc\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2995,1 +2995,1 @@\n-    directByteBufferConstructor = env->GetMethodID(directByteBufferClass, \"<init>\", \"(JI)V\");\n+    directByteBufferConstructor = env->GetMethodID(directByteBufferClass, \"<init>\", \"(JJ)V\");\n@@ -3047,4 +3047,1 @@\n-  \/\/ NOTE that package-private DirectByteBuffer constructor currently\n-  \/\/ takes int capacity\n-  jint  cap  = (jint)  capacity;\n-  jobject ret = env->NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);\n+  jobject ret = env->NewObject(directByteBufferClass, directByteBufferConstructor, addr, capacity);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,0 +181,1 @@\n+    \/\/ The long-valued capacity is restricted to int range.\n@@ -182,2 +183,2 @@\n-    private Direct$Type$Buffer(long addr, int cap) {\n-        super(-1, 0, cap, cap, null);\n+    private Direct$Type$Buffer(long addr, long cap) {\n+        super(-1, 0, clampCapacity(cap), (int)cap, null);\n@@ -242,0 +243,13 @@\n+    \/\/ Constrain the capacity to int range throwing IAE if not possible\n+    \/\/\n+    private static int clampCapacity(long capacity) {\n+        try {\n+            return Math.toIntExact(capacity);\n+        } catch (ArithmeticException ignore) {\n+            String msg = \"JNI NewDirectByteBuffer passed illegal capacity: \"\n+                + capacity + (capacity < Integer.MIN_VALUE\n+                ? \" < Integer.MIN_VALUE\" : \" > Integer.MAX_VALUE\");\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.nio.ByteBuffer;\n+\n+\/*\n+ * @test\n+ * @bug 8299684\n+ * @summary Verify that JNI NewDirectByteBuffer throws IllegalArgumentException\n+ * if the capacity is negative or greater than Integer::MAX_VALUE\n+ * @run main\/native NewDirectByteBuffer\n+ *\/\n+public class NewDirectByteBuffer {\n+    static {\n+        System.loadLibrary(\"NewDirectByteBuffer\");\n+    }\n+\n+    private static final long[] ILLEGAL_CAPACITIES = {\n+        (long)Integer.MIN_VALUE - 1L,\n+        -1L,\n+        (long)Integer.MAX_VALUE + 1L,\n+        3_000_000_000L,\n+        5_000_000_000L\n+    };\n+\n+    private static final long[] LEGAL_CAPACITIES = {\n+        0L,\n+        1L,\n+        (long)Integer.MAX_VALUE - 1,\n+        (long)Integer.MAX_VALUE\n+    };\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"--- Legal Capacities ---\");\n+        for (long cap : LEGAL_CAPACITIES) {\n+            System.out.println(\"Allocating buffer with capacity \" + cap);\n+            ByteBuffer buf = allocBigBuffer(cap);\n+            long bufferCapacity = getLongCapacity(buf);\n+            System.out.printf(\"buf.capacity(): %d, getLongCapacity(buf): %d%n\",\n+                buf.capacity(), bufferCapacity);\n+            if (bufferCapacity != cap) {\n+                throw new RuntimeException(\"GetDirectBufferCapacity returned \"\n+                    + bufferCapacity + \", not \" + cap + \"as expected\");\n+            }\n+        }\n+\n+        System.out.println(\"\\n--- Illegal Capacities ---\");\n+        for (long cap : ILLEGAL_CAPACITIES) {\n+            try {\n+                ByteBuffer buf = allocBigBuffer(cap);\n+                throw new RuntimeException(\"IAE not thrown for capacity \" + cap);\n+            } catch (IllegalArgumentException expected) {\n+                System.out.println(\"Caught expected IAE for capacity \" + cap);\n+            }\n+        }\n+    }\n+\n+    \/\/ See libNewDirectByteBuffer.c for implementations.\n+    private static native ByteBuffer allocBigBuffer(long size);\n+    private static native long getLongCapacity(ByteBuffer buf);\n+}\n","filename":"test\/jdk\/java\/nio\/jni\/NewDirectByteBuffer.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdlib.h>\n+#include \"jni.h\"\n+\n+\/\/ private static native ByteBuffer allocBigBuffer(long size)\n+JNIEXPORT jobject JNICALL\n+Java_NewDirectByteBuffer_allocBigBuffer(JNIEnv *env, jclass cls, jlong size)\n+{\n+    return (*env)->NewDirectByteBuffer(env, malloc(size), size);\n+}\n+\n+\/\/ private static native long getLongCapacity(ByteBuffer buf)\n+JNIEXPORT jlong JNICALL\n+Java_NewDirectByteBuffer_getLongCapacity(JNIEnv *env, jclass cls, jobject buf)\n+{\n+    return (*env)->GetDirectBufferCapacity(env, buf);\n+}\n","filename":"test\/jdk\/java\/nio\/jni\/libNewDirectByteBuffer.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}