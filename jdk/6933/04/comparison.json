{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -902,0 +902,2 @@\n+  bool should_unroll = true;\n+\n@@ -908,1 +910,1 @@\n-      (future_unroll_cnt - 1) * (100.0 \/ LoopPercentProfileLimit) > cl->profile_trip_cnt() &&\n+      is_residual_iters_large(future_unroll_cnt, cl) &&\n@@ -910,1 +912,11 @@\n-    return false;\n+    if ((cl->slp_max_unroll() == 0) && !is_residual_iters_large(cl->unrolled_count(), cl)) {\n+      \/\/ cl->slp_max_unroll() = 0 means that the previous slp analysis never passed.\n+      \/\/ slp analysis may fail due to the loop IR is too complicated especially during the early stage\n+      \/\/ of loop unrolling analysis. But after several rounds of loop unrolling and other optimizations,\n+      \/\/ it's possible that the loop IR becomes simple enough to pass the slp analysis.\n+      \/\/ So we don't return immediately in hoping that the next slp analysis can succeed.\n+      should_unroll = false;\n+      future_unroll_cnt = cl->unrolled_count();\n+    } else {\n+      return false;\n+    }\n@@ -1006,1 +1018,1 @@\n-      return phase->may_require_nodes(estimate);\n+      return should_unroll && phase->may_require_nodes(estimate);\n@@ -1014,1 +1026,1 @@\n-      return phase->may_require_nodes(estimate);\n+      return should_unroll && phase->may_require_nodes(estimate);\n@@ -1027,1 +1039,1 @@\n-  return phase->may_require_nodes(estimate);\n+  return should_unroll && phase->may_require_nodes(estimate);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -776,0 +776,6 @@\n+\n+  \/\/ Check if the number of residual iterations is large with unroll_cnt.\n+  \/\/ Return true if the residual iterations are more than 10% of the trip count.\n+  bool is_residual_iters_large(int unroll_cnt, CountedLoopNode *cl) const {\n+    return (unroll_cnt - 1) * (100.0 \/ LoopPercentProfileLimit) > cl->profile_trip_cnt();\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8279258\n+ * @summary Auto-vectorization enhancement for two-dimensional array operations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestAutoVectorization\n+ *\/\n+\n+public class TestAutoVectorization {\n+    final private static int NUM = 64;\n+\n+    private static double[][] a = new double[NUM][NUM];\n+    private static double[][] b = new double[NUM][NUM];\n+    private static double[][] c = new double[NUM][NUM];\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR,  \" >0 \" })\n+    @IR(counts = { IRNode.ADD_VD,       \" >0 \" })\n+    @IR(counts = { IRNode.STORE_VECTOR, \" >0 \" })\n+    private static void testDouble(double[][] a , double[][] b, double[][] c) {\n+        for(int i = 0; i < a.length; i++) {\n+            for (int j = 0; j < a[0].length; j++) {\n+                a[i][j] = b[i][j] + c[i][j];\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testDouble\")\n+    private void testDouble_runner() {\n+        testDouble(a, b, c);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAutoVectorization.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -77,0 +77,1 @@\n+    public static final String STORE_VECTOR = START + \"StoreVector\" + MID + END;\n@@ -99,0 +100,1 @@\n+    public static final String LOAD_VECTOR = START + \"LoadVector\" + MID + END;\n@@ -142,0 +144,1 @@\n+    public static final String ADD_VD = START + \"AddVD\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Fork(value=1)\n+public class AutoVectorization {\n+    @Param({\"16\", \"32\", \"64\"})\n+    private int LEN;\n+\n+    private byte[][] a_byte;\n+    private byte[][] b_byte;\n+    private byte[][] c_byte;\n+\n+    private int[][] a_int;\n+    private int[][] b_int;\n+    private int[][] c_int;\n+\n+    private double[][] a_double;\n+    private double[][] b_double;\n+    private double[][] c_double;\n+\n+    @Setup\n+    public void init() {\n+        a_byte = new byte[LEN][LEN];\n+        b_byte = new byte[LEN][LEN];\n+        c_byte = new byte[LEN][LEN];\n+\n+        a_int = new int[LEN][LEN];\n+        b_int = new int[LEN][LEN];\n+        c_int = new int[LEN][LEN];\n+\n+        a_double = new double[LEN][LEN];\n+        b_double = new double[LEN][LEN];\n+        c_double = new double[LEN][LEN];\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private int run_byte(int count, byte[][] a , byte[][] b, byte[][] c) {\n+        for(int i = 0; i < a.length; i++) {\n+            for (int j = 0; j < a[0].length; j++) {\n+                a[i][j] = (byte)(b[i][j] + c[i][j]);\n+            }\n+        }\n+        return a[count][count];\n+    }\n+\n+    @Benchmark\n+    public void test_run_byte(Blackhole bh) {\n+        int r = 0;\n+        for(int i = 0 ; i < 100; i++) {\n+            r += run_byte(i % a_byte.length, a_byte, b_byte, c_byte);\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private int run_int(int count, int[][] a, int[][] b, int[][] c) {\n+        for(int i = 0; i < a.length; i++) {\n+            for (int j = 0; j < a[0].length; j++) {\n+                a[i][j] = b[i][j] + c[i][j];\n+            }\n+        }\n+        return a[count][count];\n+    }\n+\n+    @Benchmark\n+    public void test_run_int(Blackhole bh) {\n+        int r = 0;\n+        for(int i = 0 ; i < 100; i++) {\n+            r += run_int(i % a_int.length, a_int, b_int, c_int);\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private double run_double(int count, double[][] a, double[][] b, double[][] c) {\n+        for(int i = 0; i < a.length; i++) {\n+            for (int j = 0; j < a[0].length; j++) {\n+                a[i][j] = b[i][j] + c[i][j];\n+            }\n+        }\n+        return a[count][count];\n+    }\n+\n+    @Benchmark\n+    public void test_run_double(Blackhole bh) {\n+        double r = 0;\n+        for(int i = 0 ; i < 100; i++) {\n+            r += run_double(i % a_double.length, a_double, b_double, c_double);\n+        }\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/AutoVectorization.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}