{"files":[{"patch":"@@ -910,1 +910,1 @@\n-      (future_unroll_cnt - 1) * (100.0 \/ LoopPercentProfileLimit) > cl->profile_trip_cnt() &&\n+      is_residual_iters_large(future_unroll_cnt, cl) &&\n@@ -913,1 +913,1 @@\n-        (cl->unrolled_count() - 1) * (100.0 \/ LoopPercentProfileLimit) <= cl->profile_trip_cnt()) {\n+        !is_residual_iters_large(cl->unrolled_count(), cl)) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -776,0 +776,6 @@\n+\n+  \/\/ Check if the number of residual iterations is large with unroll_cnt.\n+  \/\/ Return true if the residual iterations are more than 10% of the trip count.\n+  bool is_residual_iters_large(int unroll_cnt, CountedLoopNode *cl) const {\n+    return (unroll_cnt - 1) * (100.0 \/ LoopPercentProfileLimit) > cl->profile_trip_cnt();\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8279258\n+ * @summary Auto-vectorization enhancement for two-dimensional array operations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestAutoVectorization\n+ *\/\n+\n+public class TestAutoVectorization {\n+    final private static int NUM = 64;\n+\n+    private static double[][] a = new double[NUM][NUM];\n+    private static double[][] b = new double[NUM][NUM];\n+    private static double[][] c = new double[NUM][NUM];\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR,  \" >0 \" })\n+    @IR(counts = { IRNode.ADD_VD,       \" >0 \" })\n+    @IR(counts = { IRNode.STORE_VECTOR, \" >0 \" })\n+    private static void testDouble(double[][] a , double[][] b, double[][] c) {\n+        for(int i = 0; i < a.length; i++) {\n+            for (int j = 0; j < a[0].length; j++) {\n+                a[i][j] = b[i][j] + c[i][j];\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testDouble\")\n+    private void testDouble_runner() {\n+        testDouble(a, b, c);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAutoVectorization.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -77,0 +77,1 @@\n+    public static final String STORE_VECTOR = START + \"StoreVector\" + MID + END;\n@@ -99,0 +100,1 @@\n+    public static final String LOAD_VECTOR = START + \"LoadVector\" + MID + END;\n@@ -142,0 +144,1 @@\n+    public static final String ADD_VD = START + \"AddVD\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}