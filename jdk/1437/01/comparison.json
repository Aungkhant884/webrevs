{"files":[{"patch":"@@ -101,1 +101,1 @@\n-  fprintf(fp_hpp, \"#define RM_SIZE %d\\n\",RegisterForm::RegMask_Size());\n+  fprintf(fp_hpp, \"#define RM_SIZE %d\\n\", RegisterForm::RegMask_Size());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,5 +61,7 @@\n-  enum {\n-    _WordBits    = BitsPerWord,\n-    _LogWordBits = LogBitsPerWord,\n-    _RM_SIZE     = LP64_ONLY(align_up(RM_SIZE, 2) >> 1) NOT_LP64(RM_SIZE)\n-  };\n+  \/\/ The RM_SIZE is aligned to 64-bit - assert that this holds\n+  LP64_ONLY(STATIC_ASSERT(is_aligned(RM_SIZE, 2)));\n+\n+  static const unsigned int _WordBitMask = BitsPerWord - 1U;\n+  static const unsigned int _LogWordBits = LogBitsPerWord;\n+  static const unsigned int _RM_SIZE     = LP64_ONLY(RM_SIZE >> 1) NOT_LP64(RM_SIZE);\n+  static const unsigned int _RM_MAX      = _RM_SIZE - 1U;\n@@ -85,1 +87,1 @@\n-  enum { CHUNK_SIZE = RM_SIZE*BitsPerInt };\n+  enum { CHUNK_SIZE = _RM_SIZE * BitsPerWord };\n@@ -124,1 +126,1 @@\n-    _hwm = _RM_SIZE - 1;\n+    _hwm = _RM_MAX;\n@@ -141,1 +143,1 @@\n-  RegMask() : _RM_UP(), _lwm(_RM_SIZE - 1), _hwm(0) {\n+  RegMask() : _RM_UP(), _lwm(_RM_MAX), _hwm(0) {\n@@ -155,1 +157,1 @@\n-    return _RM_UP[r >> _LogWordBits] & (uintptr_t(1) <<(r & (_WordBits - 1U)));\n+    return _RM_UP[r >> _LogWordBits] & (uintptr_t(1) << (r & _WordBitMask));\n@@ -161,1 +163,3 @@\n-  bool is_AllStack() const { return _RM_UP[_RM_SIZE - 1U] >> (_WordBits - 1U); }\n+  bool is_AllStack() const {\n+    return (_RM_UP[_RM_MAX] & (uintptr_t(1) << _WordBitMask)) != 0;\n+  }\n@@ -163,1 +167,3 @@\n-  void set_AllStack() { Insert(OptoReg::Name(CHUNK_SIZE-1)); }\n+  void set_AllStack() {\n+    _RM_UP[_RM_MAX] |= (uintptr_t(1) << _WordBitMask);\n+  }\n@@ -181,1 +187,1 @@\n-        return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(bits));\n+        return OptoReg::Name((i << _LogWordBits) + find_lowest_bit(bits));\n@@ -195,1 +201,1 @@\n-        return OptoReg::Name((i<<_LogWordBits) + find_highest_bit(bits));\n+        return OptoReg::Name((i << _LogWordBits) + find_highest_bit(bits));\n@@ -273,1 +279,1 @@\n-    _lwm = _RM_SIZE - 1;\n+    _lwm = _RM_MAX;\n@@ -275,1 +281,1 @@\n-    memset(_RM_UP, 0, sizeof(uintptr_t)*_RM_SIZE);\n+    memset(_RM_UP, 0, sizeof(uintptr_t) * _RM_SIZE);\n@@ -282,2 +288,2 @@\n-    _hwm = _RM_SIZE - 1;\n-    memset(_RM_UP, 0xFF, sizeof(uintptr_t)*_RM_SIZE);\n+    _hwm = _RM_MAX;\n+    memset(_RM_UP, 0xFF, sizeof(uintptr_t) * _RM_SIZE);\n@@ -297,1 +303,1 @@\n-    _RM_UP[index] |= (uintptr_t(1) << (r & (_WordBits - 1U)));\n+    _RM_UP[index] |= (uintptr_t(1) << (r & _WordBitMask));\n@@ -305,1 +311,1 @@\n-    _RM_UP[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & (_WordBits-1U)));\n+    _RM_UP[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & _WordBitMask));\n@@ -358,1 +364,1 @@\n-    return (int)reg < (int)(CHUNK_SIZE-1);\n+    return (int)reg < (int)(CHUNK_SIZE - 1);\n@@ -363,1 +369,1 @@\n-    return (int)reg < (int)(CHUNK_SIZE-SlotsPerVecZ);\n+    return (int)reg < (int)(CHUNK_SIZE - SlotsPerVecZ);\n@@ -369,1 +375,1 @@\n-  uintptr_t _current_word;\n+  uintptr_t _current_bits;\n@@ -372,1 +378,1 @@\n-  const RegMask&  _rm;\n+  const RegMask& _rm;\n@@ -374,1 +380,1 @@\n-  RegMaskIterator(const RegMask& rm) : _current_word(0), _next_index(rm._lwm), _reg(OptoReg::Special), _rm(rm) {\n+  RegMaskIterator(const RegMask& rm) : _current_bits(0), _next_index(rm._lwm), _reg(OptoReg::Bad), _rm(rm) {\n@@ -386,2 +392,15 @@\n-    if (_current_word != 0) {\n-      unsigned int next_bit = find_lowest_bit(_current_word);\n+\n+    \/\/ This bit shift scheme, borrowed from IndexSetIterator,\n+    \/\/ shifts the _current_bits down by the number of trailing\n+    \/\/ zeros - which leaves the \"current\" bit on position zero,\n+    \/\/ then subtracts by 1 to clear it. This quirk avoids the\n+    \/\/ undefined behavior that could arise if trying to shift\n+    \/\/ away the bit with a single >> (next_bit + 1) shift when\n+    \/\/ next_bit is 31\/63. It also keeps number of shifts and\n+    \/\/ arithmetic ops to a minimum.\n+\n+    \/\/ We have previously found bits at _next_index - 1, and\n+    \/\/ still have some left at the same index.\n+    if (_current_bits != 0) {\n+      unsigned int next_bit = find_lowest_bit(_current_bits);\n+      assert(_reg != OptoReg::Bad, \"can't be in a bad state\");\n@@ -389,2 +408,2 @@\n-      assert(((_current_word >> next_bit) & 0x1) == 1, \"sanity\");\n-      _current_word = (_current_word >> next_bit) - 1;\n+      assert(((_current_bits >> next_bit) & 0x1) == 1, \"lowest bit must be set after shift\");\n+      _current_bits = (_current_bits >> next_bit) - 1;\n@@ -395,0 +414,1 @@\n+    \/\/ Find the next word with bits\n@@ -396,5 +416,8 @@\n-      _current_word = _rm._RM_UP[_next_index++];\n-      if (_current_word != 0) {\n-        unsigned int next_bit = find_lowest_bit(_current_word);\n-        assert(((_current_word >> next_bit) & 0x1) == 1, \"sanity\");\n-        _current_word = (_current_word >> next_bit) - 1;\n+      _current_bits = _rm._RM_UP[_next_index++];\n+      if (_current_bits != 0) {\n+        \/\/ Found a word. Calculate the first register element and\n+        \/\/ prepare _current_bits by shifting it down and clearing\n+        \/\/ the lowest bit\n+        unsigned int next_bit = find_lowest_bit(_current_bits);\n+        assert(((_current_bits >> next_bit) & 0x1) == 1, \"lowest bit must be set after shift\");\n+        _current_bits = (_current_bits >> next_bit) - 1;\n@@ -406,0 +429,1 @@\n+    \/\/ No more bits\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":57,"deletions":33,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/regmask.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Sanity tests for RegMask and RegMaskIterator\n+\n+static void contains_expected_num_of_registers(const RegMask& rm, unsigned int expected) {\n+\n+  ASSERT_TRUE(rm.Size() == expected);\n+  if (expected > 0) {\n+    ASSERT_TRUE(rm.is_NotEmpty());\n+  } else {\n+    ASSERT_TRUE(!rm.is_NotEmpty());\n+    ASSERT_TRUE(!rm.is_AllStack());\n+  }\n+\n+  RegMaskIterator rmi(rm);\n+  unsigned int count = 0;\n+  OptoReg::Name reg = OptoReg::Bad;\n+  while (rmi.has_next()) {\n+    reg = rmi.next();\n+    ASSERT_TRUE(OptoReg::is_valid(reg));\n+    count++;\n+  }\n+  ASSERT_EQ(OptoReg::Bad, rmi.next());\n+  ASSERT_TRUE(count == expected);\n+}\n+\n+TEST_VM(RegMask, empty) {\n+  RegMask rm;\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, iteration) {\n+  RegMask rm;\n+  rm.Insert(30);\n+  rm.Insert(31);\n+  rm.Insert(32);\n+  rm.Insert(33);\n+  rm.Insert(62);\n+  rm.Insert(63);\n+  rm.Insert(64);\n+  rm.Insert(65);\n+\n+  RegMaskIterator rmi(rm);\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(30));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(31));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(32));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(33));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(62));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(63));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(64));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(65));\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, Set_ALL) {\n+  \/\/ Check that Set_All doesn't add bits outside of CHUNK_SIZE\n+  RegMask rm;\n+  rm.Set_All();\n+  ASSERT_TRUE(rm.Size() == RegMask::CHUNK_SIZE);\n+  ASSERT_TRUE(rm.is_NotEmpty());\n+  \/\/ Set_All sets AllStack bit\n+  ASSERT_TRUE(rm.is_AllStack());\n+  contains_expected_num_of_registers(rm, RegMask::CHUNK_SIZE);\n+}\n+\n+TEST_VM(RegMask, Clear) {\n+  \/\/ Check that Clear doesn't leave any stray bits\n+  RegMask rm;\n+  rm.Set_All();\n+  rm.Clear();\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, AND) {\n+  RegMask rm1;\n+  rm1.Insert(OptoReg::Name(1));\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(1)));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR) {\n+  RegMask rm1;\n+  rm1.Insert(OptoReg::Name(1));\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(1)));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, SUBTRACT) {\n+  RegMask rm1;\n+  RegMask rm2;\n+\n+  rm2.Set_All();\n+  for (int i = 17; i < RegMask::CHUNK_SIZE; i++) {\n+    rm1.Insert(i);\n+  }\n+  ASSERT_TRUE(rm1.is_AllStack());\n+  rm2.SUBTRACT(rm1);\n+  contains_expected_num_of_registers(rm1, RegMask::CHUNK_SIZE - 17);\n+  contains_expected_num_of_registers(rm2, 17);\n+}\n+\n+TEST_VM(RegMask, is_bound1) {\n+  RegMask rm;\n+  ASSERT_FALSE(rm.is_bound1());\n+  for (int i = 0; i < RegMask::CHUNK_SIZE - 1; i++) {\n+    rm.Insert(i);\n+    ASSERT_TRUE(rm.is_bound1());\n+    contains_expected_num_of_registers(rm, 1);\n+    rm.Remove(i);\n+  }\n+  \/\/ AllStack bit does not count as a bound register\n+  rm.set_AllStack();\n+  ASSERT_FALSE(rm.is_bound1());\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}