{"files":[{"patch":"@@ -2606,29 +2606,0 @@\n-\/\/ This code originates from JDK's sysAvailable\n-\/\/ from src\/solaris\/hpi\/src\/native_threads\/src\/sys_api_td.c\n-\n-int os::available(int fd, jlong *bytes) {\n-  jlong cur, end;\n-  int mode;\n-  struct stat64 buf64;\n-\n-  if (::fstat64(fd, &buf64) >= 0) {\n-    mode = buf64.st_mode;\n-    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n-      int n;\n-      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n-        *bytes = n;\n-        return 1;\n-      }\n-    }\n-  }\n-  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {\n-    return 0;\n-  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {\n-    return 0;\n-  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {\n-    return 0;\n-  }\n-  *bytes = end - cur;\n-  return 1;\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2311,29 +2311,0 @@\n-\/\/ This code originates from JDK's sysAvailable\n-\/\/ from src\/solaris\/hpi\/src\/native_threads\/src\/sys_api_td.c\n-\n-int os::available(int fd, jlong *bytes) {\n-  jlong cur, end;\n-  int mode;\n-  struct stat buf;\n-\n-  if (::fstat(fd, &buf) >= 0) {\n-    mode = buf.st_mode;\n-    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n-      int n;\n-      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n-        *bytes = n;\n-        return 1;\n-      }\n-    }\n-  }\n-  if ((cur = ::lseek(fd, 0L, SEEK_CUR)) == -1) {\n-    return 0;\n-  } else if ((end = ::lseek(fd, 0L, SEEK_END)) == -1) {\n-    return 0;\n-  } else if (::lseek(fd, cur, SEEK_SET) == -1) {\n-    return 0;\n-  }\n-  *bytes = end - cur;\n-  return 1;\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -4947,29 +4947,0 @@\n-\/\/ This code originates from JDK's sysAvailable\n-\/\/ from src\/solaris\/hpi\/src\/native_threads\/src\/sys_api_td.c\n-\n-int os::available(int fd, jlong *bytes) {\n-  jlong cur, end;\n-  int mode;\n-  struct stat64 buf64;\n-\n-  if (::fstat64(fd, &buf64) >= 0) {\n-    mode = buf64.st_mode;\n-    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n-      int n;\n-      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n-        *bytes = n;\n-        return 1;\n-      }\n-    }\n-  }\n-  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {\n-    return 0;\n-  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {\n-    return 0;\n-  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {\n-    return 0;\n-  }\n-  *bytes = end - cur;\n-  return 1;\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -4995,37 +4995,0 @@\n-static int nonSeekAvailable(int, long *);\n-static int stdinAvailable(int, long *);\n-\n-\/\/ This code is a copy of JDK's sysAvailable\n-\/\/ from src\/windows\/hpi\/src\/sys_api_md.c\n-\n-int os::available(int fd, jlong *bytes) {\n-  jlong cur, end;\n-  struct _stati64 stbuf64;\n-\n-  if (::_fstati64(fd, &stbuf64) >= 0) {\n-    int mode = stbuf64.st_mode;\n-    if (S_ISCHR(mode) || S_ISFIFO(mode)) {\n-      int ret;\n-      long lpbytes;\n-      if (fd == 0) {\n-        ret = stdinAvailable(fd, &lpbytes);\n-      } else {\n-        ret = nonSeekAvailable(fd, &lpbytes);\n-      }\n-      (*bytes) = (jlong)(lpbytes);\n-      return ret;\n-    }\n-    if ((cur = ::_lseeki64(fd, 0L, SEEK_CUR)) == -1) {\n-      return FALSE;\n-    } else if ((end = ::_lseeki64(fd, 0L, SEEK_END)) == -1) {\n-      return FALSE;\n-    } else if (::_lseeki64(fd, cur, SEEK_SET) == -1) {\n-      return FALSE;\n-    }\n-    *bytes = end - cur;\n-    return TRUE;\n-  } else {\n-    return FALSE;\n-  }\n-}\n-\n@@ -5040,94 +5003,0 @@\n-\/\/ This code is a copy of JDK's nonSeekAvailable\n-\/\/ from src\/windows\/hpi\/src\/sys_api_md.c\n-\n-static int nonSeekAvailable(int fd, long *pbytes) {\n-  \/\/ This is used for available on non-seekable devices\n-  \/\/ (like both named and anonymous pipes, such as pipes\n-  \/\/  connected to an exec'd process).\n-  \/\/ Standard Input is a special case.\n-  HANDLE han;\n-\n-  if ((han = (HANDLE) ::_get_osfhandle(fd)) == (HANDLE)(-1)) {\n-    return FALSE;\n-  }\n-\n-  if (! ::PeekNamedPipe(han, NULL, 0, NULL, (LPDWORD)pbytes, NULL)) {\n-    \/\/ PeekNamedPipe fails when at EOF.  In that case we\n-    \/\/ simply make *pbytes = 0 which is consistent with the\n-    \/\/ behavior we get on Solaris when an fd is at EOF.\n-    \/\/ The only alternative is to raise an Exception,\n-    \/\/ which isn't really warranted.\n-    \/\/\n-    if (::GetLastError() != ERROR_BROKEN_PIPE) {\n-      return FALSE;\n-    }\n-    *pbytes = 0;\n-  }\n-  return TRUE;\n-}\n-\n-#define MAX_INPUT_EVENTS 2000\n-\n-\/\/ This code is a copy of JDK's stdinAvailable\n-\/\/ from src\/windows\/hpi\/src\/sys_api_md.c\n-\n-static int stdinAvailable(int fd, long *pbytes) {\n-  HANDLE han;\n-  DWORD numEventsRead = 0;  \/\/ Number of events read from buffer\n-  DWORD numEvents = 0;      \/\/ Number of events in buffer\n-  DWORD i = 0;              \/\/ Loop index\n-  DWORD curLength = 0;      \/\/ Position marker\n-  DWORD actualLength = 0;   \/\/ Number of bytes readable\n-  BOOL error = FALSE;       \/\/ Error holder\n-  INPUT_RECORD *lpBuffer;   \/\/ Pointer to records of input events\n-\n-  if ((han = ::GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) {\n-    return FALSE;\n-  }\n-\n-  \/\/ Construct an array of input records in the console buffer\n-  error = ::GetNumberOfConsoleInputEvents(han, &numEvents);\n-  if (error == 0) {\n-    return nonSeekAvailable(fd, pbytes);\n-  }\n-\n-  \/\/ lpBuffer must fit into 64K or else PeekConsoleInput fails\n-  if (numEvents > MAX_INPUT_EVENTS) {\n-    numEvents = MAX_INPUT_EVENTS;\n-  }\n-\n-  lpBuffer = (INPUT_RECORD *)os::malloc(numEvents * sizeof(INPUT_RECORD), mtInternal);\n-  if (lpBuffer == NULL) {\n-    return FALSE;\n-  }\n-\n-  error = ::PeekConsoleInput(han, lpBuffer, numEvents, &numEventsRead);\n-  if (error == 0) {\n-    os::free(lpBuffer);\n-    return FALSE;\n-  }\n-\n-  \/\/ Examine input records for the number of bytes available\n-  for (i=0; i<numEvents; i++) {\n-    if (lpBuffer[i].EventType == KEY_EVENT) {\n-\n-      KEY_EVENT_RECORD *keyRecord = (KEY_EVENT_RECORD *)\n-                                      &(lpBuffer[i].Event);\n-      if (keyRecord->bKeyDown == TRUE) {\n-        CHAR *keyPressed = (CHAR *) &(keyRecord->uChar);\n-        curLength++;\n-        if (*keyPressed == '\\r') {\n-          actualLength = curLength;\n-        }\n-      }\n-    }\n-  }\n-\n-  if (lpBuffer != NULL) {\n-    os::free(lpBuffer);\n-  }\n-\n-  *pbytes = (long) actualLength;\n-  return TRUE;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":131,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -553,1 +553,0 @@\n-  static int available(int fd, jlong *bytes);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}