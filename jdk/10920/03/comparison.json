{"files":[{"patch":"@@ -389,0 +389,1 @@\n+  if (_chunk == NULL) return false;\n@@ -392,1 +393,0 @@\n-    if (_chunk == NULL) return false;\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  assert(_caller_jvms->same_calls_as(caller_jvms), \"consistent JVMS\");\n+  assert(_caller_jvms == NULL\n+         || _caller_jvms->same_calls_as(caller_jvms), \"consistent JVMS\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -734,2 +734,2 @@\n-  int elide_copy( Node *n, int k, Block *current_block, Node_List &value, Node_List &regnd, bool can_change_regs );\n-  int use_prior_register( Node *copy, uint idx, Node *def, Block *current_block, Node_List &value, Node_List &regnd );\n+  int elide_copy( Node *n, int k, Block *current_block, Node_List *value, Node_List *regnd, bool can_change_regs );\n+  int use_prior_register( Node *copy, uint idx, Node *def, Block *current_block, Node_List *value, Node_List *regnd );\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1527,2 +1527,4 @@\n-    _nodes = NEW_ARENA_ARRAY(a, Node*, max);\n-    clear();\n+    if (a != NULL) {\n+      _nodes = NEW_ARENA_ARRAY(a, Node*, max);\n+      clear();\n+    }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-                                    Node_List& value) {\n+                                    const Node_List &value) {\n@@ -80,1 +80,1 @@\n-int PhaseChaitin::yank( Node *old, Block *current_block, Node_List *value, Node_List *regnd ) {\n+int PhaseChaitin::yank(Node *old, Block *current_block, Node_List *value, Node_List *regnd) {\n@@ -90,3 +90,4 @@\n-  if( regnd && (*regnd)[old_reg]==old ) { \/\/ Instruction is currently available?\n-    value->map(old_reg,NULL);  \/\/ Yank from value\/regnd maps\n-    regnd->map(old_reg,NULL);  \/\/ This register's value is now unknown\n+  assert(value != NULL || regnd == NULL, \"sanity\");\n+  if (value != NULL && regnd != NULL && regnd->at(old_reg) == old) { \/\/ Instruction is currently available?\n+    value->map(old_reg, NULL); \/\/ Yank from value\/regnd maps\n+    regnd->map(old_reg, NULL); \/\/ This register's value is now unknown\n@@ -164,1 +165,1 @@\n-int PhaseChaitin::use_prior_register( Node *n, uint idx, Node *def, Block *current_block, Node_List &value, Node_List &regnd ) {\n+int PhaseChaitin::use_prior_register( Node *n, uint idx, Node *def, Block *current_block, Node_List *value, Node_List *regnd ) {\n@@ -210,1 +211,1 @@\n-  return yank_if_dead(old,current_block,&value,&regnd);\n+  return yank_if_dead(old,current_block,value,regnd);\n@@ -232,1 +233,1 @@\n-int PhaseChaitin::elide_copy( Node *n, int k, Block *current_block, Node_List &value, Node_List &regnd, bool can_change_regs ) {\n+int PhaseChaitin::elide_copy( Node *n, int k, Block *current_block, Node_List *value, Node_List *regnd, bool can_change_regs ) {\n@@ -256,1 +257,1 @@\n-  if( !can_change_regs )\n+  if (!can_change_regs) {\n@@ -258,1 +259,1 @@\n-\n+  }\n@@ -260,2 +261,4 @@\n-  if( &value == NULL ) return blk_adjust;\n-\n+  assert(regnd != NULL || value == NULL, \"sanity\");\n+  if (value == NULL || regnd == NULL) {\n+    return blk_adjust;\n+  }\n@@ -276,4 +279,5 @@\n-  if (register_contains_value(val, val_reg, n_regs, value)) {\n-    blk_adjust += use_prior_register(n,k,regnd[val_reg],current_block,value,regnd);\n-    if( n->in(k) == regnd[val_reg] ) \/\/ Success!  Quit trying\n-      return blk_adjust;\n+  if (register_contains_value(val, val_reg, n_regs, *value)) {\n+    blk_adjust += use_prior_register(n,k,regnd->at(val_reg),current_block,value,regnd);\n+    if (n->in(k) == regnd->at(val_reg)) {\n+      return blk_adjust; \/\/ Success!  Quit trying\n+    }\n@@ -307,1 +311,1 @@\n-    Node *vv = value[reg];\n+    Node *vv = value->at(reg);\n@@ -328,1 +332,1 @@\n-      if (!register_contains_value(vv, reg, n_regs, value)) continue; \/\/ Different value\n+      if (!register_contains_value(vv, reg, n_regs, *value)) continue; \/\/ Different value\n@@ -336,3 +340,3 @@\n-          regnd[reg]->outcnt()==1 ) { \/\/ last use of a spill-load turns into a CISC use\n-        blk_adjust += use_prior_register(n,k,regnd[reg],current_block,value,regnd);\n-        if( n->in(k) == regnd[reg] ) \/\/ Success!  Quit trying\n+          regnd->at(reg)->outcnt()==1 ) { \/\/ last use of a spill-load turns into a CISC use\n+        blk_adjust += use_prior_register(n,k,regnd->at(reg),current_block,value,regnd);\n+        if( n->in(k) == regnd->at(reg) ) \/\/ Success!  Quit trying\n@@ -538,1 +542,1 @@\n-        elide_copy(block->get_node(k), j, block, *blk2value[pb->_pre_order], *blk2regnd[pb->_pre_order], false);\n+        elide_copy(block->get_node(k), j, block, blk2value[pb->_pre_order], blk2regnd[pb->_pre_order], false);\n@@ -694,1 +698,1 @@\n-        j -= elide_copy(n, k, block, value, regnd, two_adr != k);\n+        j -= elide_copy(n, k, block, &value, &regnd, two_adr != k);\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -191,3 +191,5 @@\n-#define CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                 \\\n- {typeName *dummyObj = NULL; type* dummy = &dummyObj->fieldName;                   \\\n-  assert(offset_of(typeName, fieldName) < sizeof(typeName), \"Illegal nonstatic struct entry, field offset too large\"); }\n+#define CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type) {               \\\n+    char space[sizeof (typeName)];                                                 \\\n+    typeName *dummyObj = (typeName *)space; type* dummy = &dummyObj->fieldName;    \\\n+    assert(offset_of(typeName, fieldName) < sizeof(typeName), \"Illegal nonstatic struct entry, field offset too large\"); \\\n+  }\n@@ -196,2 +198,5 @@\n-#define CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)        \\\n- {typedef type dummyvtype; typeName *dummyObj = NULL; volatile dummyvtype* dummy = &dummyObj->fieldName; }\n+#define CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type) {      \\\n+    char space[sizeof (typeName)];                                                 \\\n+    typedef type dummyvtype; typeName *dummyObj = (typeName *)space;               \\\n+    volatile dummyvtype* dummy = &dummyObj->fieldName;                             \\\n+  }\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -142,4 +142,15 @@\n-\/\/ offset directly when base address is NULL. Use 16 to get around the\n-\/\/ warning. The -Wno-invalid-offsetof option could be used to suppress\n-\/\/ this warning, but we instead just avoid the use of offsetof().\n-#define offset_of(klass,field) (size_t)((intx)&(((klass*)16)->field) - 16)\n+\/\/ offset directly when base address is NULL. The -Wno-invalid-offsetof\n+\/\/ option could be used to suppress this warning, but we instead just\n+\/\/ avoid the use of offsetof().\n+\/\/\n+\/\/ FIXME: This macro is complex and rather arcane. Perhaps we should\n+\/\/ use offsetof() instead, with the invalid-offsetof warning\n+\/\/ temporarily disabled.\n+#define offset_of(klass,field)                  \\\n+[]() {                                          \\\n+  char space[sizeof (klass)];                   \\\n+  klass* dummyObj = (klass*)space;              \\\n+  char* c = (char*)(void*)&dummyObj->field;     \\\n+  return (size_t)(c - space);                   \\\n+}()\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}