{"files":[{"patch":"@@ -389,0 +389,1 @@\n+  if (_chunk == NULL) return false;\n@@ -392,1 +393,0 @@\n-    if (_chunk == NULL) return false;\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,1 +390,3 @@\n-  this_key->record_dependency(host);\n+  if (this_key != NULL) {\n+    this_key->record_dependency(host);\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  assert(_caller_jvms->same_calls_as(caller_jvms), \"consistent JVMS\");\n+  assert(_caller_jvms == NULL\n+         || _caller_jvms->same_calls_as(caller_jvms), \"consistent JVMS\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+Node_List Node_List::_empty_list((Arena*)NULL);\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1528,2 +1528,4 @@\n-    _nodes = NEW_ARENA_ARRAY(a, Node*, max);\n-    clear();\n+    if (a != NULL) {\n+      _nodes = NEW_ARENA_ARRAY(a, Node*, max);\n+      clear();\n+    }\n@@ -1552,0 +1554,1 @@\n+  static Node_List _empty_list;  \/\/ static sentinel\n@@ -1579,0 +1582,7 @@\n+\n+  \/\/ If a Node_List *is null, return a reference to an empty sentinel\n+  static Node_List &wrap(Node_List *list) {\n+    if (list != NULL) return *list;\n+    return _empty_list;\n+  }\n+  bool is_null() { return this == &_empty_list; }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-                                    Node_List& value) {\n+                                    const Node_List &value) {\n@@ -90,1 +90,1 @@\n-  if( regnd && (*regnd)[old_reg]==old ) { \/\/ Instruction is currently available?\n+  if( ! regnd->is_null() && (*regnd)[old_reg]==old ) { \/\/ Instruction is currently available?\n@@ -538,1 +538,3 @@\n-        elide_copy(block->get_node(k), j, block, *blk2value[pb->_pre_order], *blk2regnd[pb->_pre_order], false);\n+        elide_copy(block->get_node(k), j, block,\n+                   Node_List::wrap(blk2value[pb->_pre_order]),\n+                   Node_List::wrap(blk2regnd[pb->_pre_order]), false);\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -191,3 +191,5 @@\n-#define CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                 \\\n- {typeName *dummyObj = NULL; type* dummy = &dummyObj->fieldName;                   \\\n-  assert(offset_of(typeName, fieldName) < sizeof(typeName), \"Illegal nonstatic struct entry, field offset too large\"); }\n+#define CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type) {               \\\n+    char space[sizeof (typeName)];                                                 \\\n+    typeName *dummyObj = (typeName *)space; type* dummy = &dummyObj->fieldName;    \\\n+    assert(offset_of(typeName, fieldName) < sizeof(typeName), \"Illegal nonstatic struct entry, field offset too large\"); \\\n+  }\n@@ -196,2 +198,5 @@\n-#define CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)        \\\n- {typedef type dummyvtype; typeName *dummyObj = NULL; volatile dummyvtype* dummy = &dummyObj->fieldName; }\n+#define CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type) {      \\\n+    char space[sizeof (typeName)];                                                 \\\n+    typedef type dummyvtype; typeName *dummyObj = (typeName *)space;               \\\n+    volatile dummyvtype* dummy = &dummyObj->fieldName;                             \\\n+  }\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -142,4 +142,15 @@\n-\/\/ offset directly when base address is NULL. Use 16 to get around the\n-\/\/ warning. The -Wno-invalid-offsetof option could be used to suppress\n-\/\/ this warning, but we instead just avoid the use of offsetof().\n-#define offset_of(klass,field) (size_t)((intx)&(((klass*)16)->field) - 16)\n+\/\/ offset directly when base address is NULL. The -Wno-invalid-offsetof\n+\/\/ option could be used to suppress this warning, but we instead just\n+\/\/ avoid the use of offsetof().\n+\/\/\n+\/\/ FIXME: This macro is complex and rather arcane. Perhaps we should\n+\/\/ use offsetof() instead, with the invalid-offsetof warning\n+\/\/ temporarily disabled.\n+#define offset_of(klass,field)                  \\\n+[]() {                                          \\\n+  char space[sizeof (klass)];                   \\\n+  klass* dummyObj = (klass*)space;              \\\n+  char* c = (char*)(void*)&dummyObj->field;     \\\n+  return (size_t)(c - space);                   \\\n+}()\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}