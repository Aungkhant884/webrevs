{"files":[{"patch":"@@ -791,6 +791,0 @@\n-\n-############################################################################\n-\n-# Loom, fibers branch\n-\n-jdk\/incubator\/concurrent\/ScopedValue\/Stress.java                            0000000 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Stress test ScopedValue with many bindings and rebinings\n- * @enablePreview\n- * @modules jdk.incubator.concurrent\n- * @library \/test\/lib\n- * @key randomness\n- * @run testng ManyBindings\n- *\/\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.ScopedValue.Carrier;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.Random;\n-\n-import jdk.test.lib.RandomFactory;\n-import jdk.test.lib.thread.VThreadRunner;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class ManyBindings {\n-    private static final Random RND = RandomFactory.getRandom();\n-\n-    \/\/ number of scoped values to create\n-    private static final int SCOPED_VALUE_COUNT = 16;\n-\n-    \/\/ recursive depth to test\n-    private static final int MAX_DEPTH = 24;\n-\n-    \/**\n-     * Stress test bindings on platform thread.\n-     *\/\n-    public void testPlatformThread() {\n-        test();\n-    }\n-\n-    \/**\n-     * Stress test bindings on virtual thread.\n-     *\/\n-    public void testVirtualThread() throws Exception {\n-        VThreadRunner.run(() -> test());\n-    }\n-\n-    \/**\n-     * Scoped value and its expected value (or null if not bound).\n-     *\/\n-    record KeyAndValue<T>(ScopedValue<T> key, T value) {\n-        KeyAndValue() {\n-            this(ScopedValue.newInstance(), null);\n-        }\n-    }\n-\n-    \/**\n-     * Stress test bindings on current thread.\n-     *\/\n-    private void test() {\n-        KeyAndValue<Integer>[] array = new KeyAndValue[SCOPED_VALUE_COUNT];\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = new KeyAndValue<>();\n-        }\n-        test(array, 1);\n-    }\n-\n-    \/**\n-     * Test that the scoped values in the array have the expected value, then\n-     * recursively call this method with some of the scoped values bound to a\n-     * new value.\n-     *\n-     * @param array the scoped values and their expected value\n-     * @param depth current recurive depth\n-     *\/\n-    private void test(KeyAndValue<Integer>[] array, int depth) {\n-        if (depth > MAX_DEPTH)\n-            return;\n-\n-        \/\/ check that the scoped values have the expected values\n-        check(array);\n-\n-        \/\/ try to pollute the cache\n-        lotsOfReads(array);\n-\n-        \/\/ create a Carrier to bind\/rebind some of the scoped values\n-        int len = array.length;\n-        Carrier carrier = null;\n-\n-        KeyAndValue<Integer>[] newArray = Arrays.copyOf(array, len);\n-        int n = Math.max(1, RND.nextInt(len \/ 2));\n-        while (n > 0) {\n-            int index = RND.nextInt(len);\n-            ScopedValue<Integer> key = array[index].key;\n-            int newValue = RND.nextInt();\n-            if (carrier == null) {\n-                carrier = ScopedValue.where(key, newValue);\n-            } else {\n-                carrier = carrier.where(key, newValue);\n-            }\n-            newArray[index] = new KeyAndValue<>(key, newValue);\n-            n--;\n-        }\n-\n-        \/\/ invoke recursively\n-        carrier.run(() -> {\n-            test(newArray, depth+1);\n-        });\n-\n-        \/\/ check that the scoped values have the origina values\n-        check(array);\n-    }\n-\n-    \/**\n-     * Check that the given scoped values have the expected value.\n-     *\/\n-    private void check(KeyAndValue<Integer>[] array) {\n-        for (int i = 0; i < array.length; i++) {\n-            ScopedValue<Integer> key = array[i].key;\n-            Integer value = array[i].value;\n-            if (value == null) {\n-                assertFalse(key.isBound());\n-            } else {\n-                assertEquals(key.get(), value);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Do lots of reads of the scoped values, to pollute the SV cache.\n-     *\/\n-    private void lotsOfReads(KeyAndValue<Integer>[] array) {\n-        for (int k = 0; k < 1000; k++) {\n-            int index = RND.nextInt(array.length);\n-            Integer value = array[index].value;\n-            if (value != null) {\n-                ScopedValue<Integer> key = array[index].key;\n-                assertEquals(key.get(), value);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ManyBindings.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,362 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test ScopedValue API\n- * @modules jdk.incubator.concurrent\n- * @run testng ScopeValueAPI\n- *\/\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class ScopeValueAPI {\n-\n-    \/**\n-     * Test that the run method is invoked.\n-     *\/\n-    public void testRun() {\n-        var executed = new AtomicBoolean();\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        ScopedValue.where(name, \"duke\", () -> executed.set(true));\n-        assertTrue(executed.get());\n-    }\n-\n-    \/**\n-     * Test the run method throwing an exception.\n-     *\/\n-    public void testRunThrows() {\n-        class FooException extends RuntimeException { }\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        Runnable op = () -> { throw new FooException(); };\n-        assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Test that the call method is invoked.\n-     *\/\n-    public void testCall() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String result = ScopedValue.where(name, \"duke\", name::get);\n-        assertEquals(result, \"duke\");\n-    }\n-\n-    \/**\n-     * Test the call method throwing an exception.\n-     *\/\n-    public void testCallThrows() {\n-        class FooException extends RuntimeException { }\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        Callable<Void> op = () -> { throw new FooException(); };\n-        assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Test get method.\n-     *\/\n-    public void testGet() throws Exception {\n-        ScopedValue<String> name1 = ScopedValue.newInstance();\n-        ScopedValue<String> name2 = ScopedValue.newInstance();\n-        assertThrows(NoSuchElementException.class, name1::get);\n-        assertThrows(NoSuchElementException.class, name2::get);\n-\n-        \/\/ run\n-        ScopedValue.where(name1, \"duke\", () -> {\n-            assertEquals(name1.get(), \"duke\");\n-            assertThrows(NoSuchElementException.class, name2::get);\n-\n-        });\n-        assertThrows(NoSuchElementException.class, name1::get);\n-        assertThrows(NoSuchElementException.class, name2::get);\n-\n-        \/\/ call\n-        ScopedValue.where(name1, \"duke\", () -> {\n-            assertEquals(name1.get(), \"duke\");\n-            assertThrows(NoSuchElementException.class, name2::get);\n-            return null;\n-        });\n-        assertThrows(NoSuchElementException.class, name1::get);\n-        assertThrows(NoSuchElementException.class, name2::get);\n-    }\n-\n-    \/**\n-     * Test isBound method.\n-     *\/\n-    public void testIsBound() throws Exception {\n-        ScopedValue<String> name1 = ScopedValue.newInstance();\n-        ScopedValue<String> name2 = ScopedValue.newInstance();\n-        assertFalse(name1.isBound());\n-        assertFalse(name2.isBound());\n-\n-        \/\/ run\n-        ScopedValue.where(name1, \"duke\", () -> {\n-            assertTrue(name1.isBound());\n-            assertFalse(name2.isBound());\n-        });\n-        assertFalse(name1.isBound());\n-        assertFalse(name2.isBound());\n-\n-        \/\/ call\n-        ScopedValue.where(name1, \"duke\", () -> {\n-            assertTrue(name1.isBound());\n-            assertFalse(name2.isBound());\n-            return null;\n-        });\n-        assertFalse(name1.isBound());\n-        assertFalse(name2.isBound());\n-    }\n-\n-    \/**\n-     * Test orElse method.\n-     *\/\n-    public void testOrElse() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        assertTrue(name.orElse(null) == null);\n-        assertEquals(name.orElse(\"default\"), \"default\");\n-\n-        \/\/ run\n-        ScopedValue.where(name, \"duke\", () -> {\n-            assertEquals(name.orElse(null), \"duke\");\n-            assertEquals(name.orElse(\"default\"), \"duke\");\n-        });\n-\n-        \/\/ call\n-        var ignore = ScopedValue.where(name, \"duke\", () -> {\n-            assertEquals(name.orElse(null), \"duke\");\n-            assertEquals(name.orElse(\"default\"), \"duke\");\n-            return null;\n-        });\n-    }\n-\n-    \/**\n-     * Test orElseThrow method.\n-     *\/\n-    public void testOrElseThrow() throws Exception {\n-        class FooException extends RuntimeException { }\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        assertThrows(FooException.class, () -> name.orElseThrow(FooException::new));\n-\n-        \/\/ run\n-        ScopedValue.where(name, \"duke\", () -> {\n-            assertEquals(name.orElseThrow(FooException::new), \"duke\");\n-        });\n-\n-        \/\/ call\n-        var ignore = ScopedValue.where(name, \"duke\", () -> {\n-            assertEquals(name.orElseThrow(FooException::new), \"duke\");\n-            return null;\n-        });\n-    }\n-\n-    \/**\n-     * Test two bindings.\n-     *\/\n-    public void testTwoBindings() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        ScopedValue<Integer> age = ScopedValue.newInstance();\n-\n-        \/\/ run\n-        ScopedValue.where(name, \"duke\").where(age, 100).run(() -> {\n-            assertTrue(name.isBound());\n-            assertTrue(age.isBound());\n-            assertEquals(name.get(), \"duke\");\n-            assertEquals((int) age.get(), 100);\n-        });\n-        assertFalse(name.isBound());\n-        assertFalse(age.isBound());\n-\n-        \/\/ call\n-        var ignore = ScopedValue.where(name, \"duke\").where(age, 100).call(() -> {\n-            assertTrue(name.isBound());\n-            assertTrue(age.isBound());\n-            assertEquals(name.get(), \"duke\");\n-            assertEquals((int) age.get(), 100);\n-            return null;\n-        });\n-        assertFalse(name.isBound());\n-        assertFalse(age.isBound());\n-    }\n-\n-    \/**\n-     * Test rebinding.\n-     *\/\n-    public void testRebinding() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-\n-        \/\/ run\n-        ScopedValue.where(name, \"duke\", () -> {\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), \"duke\");\n-\n-            ScopedValue.where(name, \"duchess\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"duchess\".equals(name.get()));\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), \"duke\");\n-        });\n-        assertFalse(name.isBound());\n-\n-        \/\/ call\n-        var ignore1 = ScopedValue.where(name, \"duke\", () -> {\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), \"duke\");\n-\n-            var ignore2 = ScopedValue.where(name, \"duchess\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"duchess\".equals(name.get()));\n-                return null;\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), \"duke\");\n-            return null;\n-        });\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Test rebinding from null vaue to another value.\n-     *\/\n-    public void testRebindingFromNull() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-\n-        \/\/ run\n-        ScopedValue.where(name, null, () -> {\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), null);\n-\n-            ScopedValue.where(name, \"duchess\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"duchess\".equals(name.get()));\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-        });\n-        assertFalse(name.isBound());\n-\n-        \/\/ call\n-        var ignore1 = ScopedValue.where(name, null, () -> {\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), null);\n-\n-            var ignore2 = ScopedValue.where(name, \"duchess\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"duchess\".equals(name.get()));\n-                return null;\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            return null;\n-        });\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Test rebinding to null value.\n-     *\/\n-    public void testRebindingToNull() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-\n-        \/\/ run\n-        ScopedValue.where(name, \"duke\", () -> {\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), \"duke\");\n-\n-            ScopedValue.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), \"duke\");\n-        });\n-        assertFalse(name.isBound());\n-\n-        \/\/ call\n-        var ignore1 = ScopedValue.where(name, \"duke\", () -> {\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), \"duke\");\n-\n-            var ignore2 = ScopedValue.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                return null;\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertEquals(name.get(), \"duke\");\n-            return null;\n-        });\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Test Carrier.get.\n-     *\/\n-    public void testCarrierGet() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        ScopedValue<Integer> age = ScopedValue.newInstance();\n-\n-        \/\/ one scoped value\n-        var carrier1 = ScopedValue.where(name, \"duke\");\n-        assertEquals(carrier1.get(name), \"duke\");\n-        assertThrows(NoSuchElementException.class, () -> carrier1.get(age));\n-\n-        \/\/ two scoped values\n-        var carrier2 = carrier1.where(age, 20);\n-        assertEquals(carrier2.get(name), \"duke\");\n-        assertEquals((int) carrier2.get(age), 20);\n-    }\n-\n-    \/**\n-     * Test NullPointerException.\n-     *\/\n-    public void testNullPointerException() {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\"));\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> { }));\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> null));\n-\n-        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-\n-        var carrier = ScopedValue.where(name, \"duke\");\n-        assertThrows(NullPointerException.class, () -> carrier.where(null, \"value\"));\n-        assertThrows(NullPointerException.class, () -> carrier.get(null));\n-        assertThrows(NullPointerException.class, () -> carrier.run(null));\n-        assertThrows(NullPointerException.class, () -> carrier.call(null));\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ScopeValueAPI.java","additions":0,"deletions":362,"binary":false,"changes":362,"status":"deleted"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Stress test for ScopedValue\n- * @modules jdk.incubator.concurrent\n- * @compile --enable-preview -source ${jdk.version} Stress.java\n- * @run testng\/othervm\/timeout=300 -XX:-TieredCompilation --enable-preview Stress\n- * @run testng\/othervm\/timeout=300 --enable-preview Stress\n- *\/\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.concurrent.ThreadFactory;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class Stress {\n-\n-    ScopedValue<Integer> sl1 = ScopedValue.newInstance();\n-    ScopedValue<Integer> sl2 = ScopedValue.newInstance();\n-\n-    static final ScopedValue<ThreadFactory> factory = ScopedValue.newInstance();\n-    static final ScopedValue.Carrier platformFactoryCarrier = ScopedValue.where(factory, Thread.ofPlatform().factory());\n-    static final ScopedValue.Carrier virtualFactoryCarrier = ScopedValue.where(factory, Thread.ofVirtual().factory());\n-\n-    final ScopedValue<Integer>[] scopeLocals;\n-\n-    Stress() {\n-        scopeLocals = new ScopedValue[500];\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            scopeLocals[i] = ScopedValue.newInstance();\n-        }\n-    }\n-\n-    private class MyBanger implements Runnable {\n-        final ScopedValue.Binder binder;\n-        boolean shouldRunOutOfMemory;\n-        boolean failed = false;\n-\n-        MyBanger(ScopedValue.Binder binder, boolean shouldRunOutOfMemory) {\n-            this.binder = binder;\n-            this.shouldRunOutOfMemory = shouldRunOutOfMemory;\n-        }\n-\n-        volatile int a[][] = new int[10000][];\n-\n-        public void runOutOfMemory(int base, int size) {\n-            for (int i = base; i < a.length; i++) {\n-                try {\n-                    a[i] = new int[size];\n-                } catch (OutOfMemoryError e) {\n-                    size \/= 2;\n-                    if (size == 0) {\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-\n-        public void run() {\n-            int n = sl1.get();\n-            try {\n-                ScopedValue.where(sl1, n + 1).run(this);\n-            } catch (StackOverflowError e) {\n-                if (sl1.get() != n) {\n-                    failed = true;\n-                }\n-            }\n-            if (shouldRunOutOfMemory) {\n-                runOutOfMemory(0, 0x1000_0000);\n-            }\n-\n-            \/\/ Trigger a StructureViolationException\n-            binder.close();\n-        }\n-\n-    }\n-\n-    public void stackOverflow() {\n-        ScopedValue.Binder binder = sl2.bind(99);\n-        try {\n-            var myBanger = new MyBanger(binder, false);\n-            try {\n-                ScopedValue.where(sl1, 0, myBanger);\n-            } catch (RuntimeException e) {\n-                assertFalse(sl1.isBound());\n-            } finally {\n-                binder.close();\n-            }\n-            assertFalse(myBanger.failed);\n-        } finally {\n-            binder.close();\n-        }\n-    }\n-\n-    private int deepBindings(int depth) {\n-        try {\n-            if (depth > 0) {\n-                try (var unused = scopeLocals[depth].bind(depth)) {\n-                    var vx = scopeLocals[depth].get();\n-                    return ScopedValue.where(sl1, sl1.get() + 1)\n-                            .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n-                            .call(() -> scopeLocals[depth].get() + deepBindings(depth - 1) + sl1.get());\n-                }\n-            } else {\n-                return sl2.get();\n-            }\n-        } catch (Exception foo) {\n-            return 0;\n-        }\n-    }\n-\n-    private void deepBindings() {\n-        int result;\n-        try {\n-            result = ScopedValue.where(sl2, 42).where(sl1, 99).call(() ->\n-                    deepBindings(scopeLocals.length - 1));\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-        assertEquals(result, 423693);\n-    }\n-\n-    private int deepBindings2(int depth) throws Exception {\n-        if (depth > 0) {\n-            try (var unused = scopeLocals[depth].bind(depth)) {\n-                try (var structuredTaskScope = new StructuredTaskScope<Integer>(null, factory.get())) {\n-                    var future = structuredTaskScope.fork(\n-                            () -> ScopedValue.where(sl1, sl1.get() + 1)\n-                                    .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n-                                    .call(() -> scopeLocals[depth].get() + deepBindings2(depth - 1) + sl1.get()));\n-                    structuredTaskScope.join();\n-                    return future.get();\n-                }\n-            }\n-        } else {\n-            return sl2.get();\n-        }\n-    }\n-\n-    \/\/ Serious abuse of ScopedValues. Make sure everything still works,\n-    \/\/ even with a ridiculous number of bindings.\n-    @Test\n-    public void manyScopedValues() {\n-        ScopedValue<Object>[] scopeLocals = new ScopedValue[10_000];\n-        ScopedValue.Binder[] binders = new ScopedValue.Binder[scopeLocals.length];\n-\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            scopeLocals[i] = ScopedValue.newInstance();\n-            binders[i] = scopeLocals[i].bind(i);\n-        }\n-        long n = 0;\n-        for (var sl : scopeLocals) {\n-            n += (Integer)sl.get();\n-        }\n-        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n-            binders[i].close();\n-        }\n-        assertEquals(n, 49995000);\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            binders[i] = scopeLocals[i].bind(i);\n-        }\n-        int caught = 0;\n-        \/\/ Trigger StructureViolationExceptions\n-        for (int i = scopeLocals.length - 2; i >= 0; i -= 2) {\n-            try {\n-                binders[i].close();\n-            } catch (StructureViolationException x) {\n-                caught++;\n-            }\n-        }\n-\n-        assertEquals(caught, 5000);\n-\n-        \/\/ They should all be closed now\n-        caught = 0;\n-        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n-            binders[i].close();\n-            try {\n-                binders[i].close();\n-            } catch (StructureViolationException x) {\n-                caught++;\n-            }\n-        }\n-        assertEquals(caught, 0);\n-    }\n-\n-    private void testDeepBindings(ScopedValue.Carrier factoryCarrier) {\n-        int val = 0;\n-        try (var unused = factoryCarrier.where(sl2, 42).where(sl1, 99).bind()) {\n-            val = deepBindings2(scopeLocals.length - 1);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-        assertEquals(val, 423693);\n-    }\n-\n-    \/\/ Make sure that stack overflows are handled correctly.\n-    \/\/ Run for a while to trigger JIT compilation.\n-    @Test\n-    public void stackOverflowTest() {\n-        assertFalse(sl2.isBound());\n-        for (int i = 0; i < 200; i++) {\n-            try {\n-                stackOverflow();\n-            } catch (Throwable t) {\n-                ;\n-            }\n-            assertFalse(sl2.isBound());\n-        }\n-    }\n-\n-    @Test\n-    public void platformFactorydeepBindings() {\n-        testDeepBindings(platformFactoryCarrier);\n-    }\n-\n-    @Test\n-    public void virtualFactorydeepBindings() {\n-        testDeepBindings(virtualFactoryCarrier);\n-    }\n-\n-    void run() {\n-        manyScopedValues();\n-        platformFactorydeepBindings();\n-        stackOverflowTest();\n-        virtualFactorydeepBindings();\n-    }\n-\n-    public static void main(String[] args) {\n-        new Stress().run();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/Stress.java","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -1,202 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Basic tests for StructuredTaskScope with scoped values\n- * @enablePreview\n- * @modules jdk.incubator.concurrent\n- * @run testng WithScopedValue\n- *\/\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class WithScopedValue {\n-\n-    \/**\n-     * Test that fork inherits a scoped value into a child thread.\n-     *\/\n-    public void testForkInheritsScopedValue1() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                Future<String> future = scope.fork(() -> {\n-                    return name.get(); \/\/ child should read \"x\"\n-                });\n-                scope.join();\n-                return future.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"x\");\n-    }\n-\n-    \/**\n-     * Test that fork inherits a scoped value into a grandchild thread.\n-     *\/\n-    public void testForkInheritsScopedValue2() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope1 = new StructuredTaskScope<String>()) {\n-                Future<String> future1 = scope1.fork(() -> {\n-                    try (var scope2 = new StructuredTaskScope<String>()) {\n-                        Future<String> future2 = scope2.fork(() -> {\n-                            return name.get(); \/\/ grandchild should read \"x\"\n-                        });\n-                        scope2.join();\n-                        return future2.resultNow();\n-                    }\n-                });\n-                scope1.join();\n-                return future1.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"x\");\n-    }\n-\n-    \/**\n-     * Test that fork inherits a rebound scoped value into a grandchild thread.\n-     *\/\n-    public void testForkInheritsScopedValue3() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope1 = new StructuredTaskScope<String>()) {\n-                Future<String> future1 = scope1.fork(() -> {\n-                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n-\n-                    \/\/ rebind name to \"y\"\n-                    String grandchildValue = ScopedValue.where(name, \"y\", () -> {\n-                        try (var scope2 = new StructuredTaskScope<String>()) {\n-                            Future<String> future2 = scope2.fork(() -> {\n-                                return name.get(); \/\/ grandchild should read \"y\"\n-                            });\n-                            scope2.join();\n-                            return future2.resultNow();\n-                        }\n-                    });\n-\n-                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n-                    return grandchildValue;\n-                });\n-                scope1.join();\n-                return future1.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"y\");\n-    }\n-\n-    \/**\n-     * Test exiting a dynamic scope with an open task scope.\n-     *\/\n-    public void testStructureViolation1() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        class Box {\n-            StructuredTaskScope<Object> scope;\n-        }\n-        var box = new Box();\n-        try {\n-            try {\n-                ScopedValue.where(name, \"x\", () -> {\n-                    box.scope = new StructuredTaskScope<Object>();\n-                });\n-                fail();\n-            } catch (StructureViolationException expected) { }\n-\n-            \/\/ underlying flock should be closed, fork should return a cancelled task\n-            StructuredTaskScope<Object> scope = box.scope;\n-            AtomicBoolean ran = new AtomicBoolean();\n-            Future<Object> future = scope.fork(() -> {\n-                ran.set(true);\n-                return null;\n-            });\n-            assertTrue(future.isCancelled());\n-            scope.join();\n-            assertFalse(ran.get());\n-\n-        } finally {\n-            StructuredTaskScope<Object> scope = box.scope;\n-            if (scope != null) {\n-                scope.close();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a StructuredTaskScope while executing in a dynamic scope.\n-     *\/\n-    public void testStructureViolation2() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var scope = new StructuredTaskScope<String>()) {\n-            ScopedValue.where(name, \"x\", () -> {\n-                assertThrows(StructureViolationException.class, scope::close);\n-            });\n-        }\n-    }\n-    \n-    \/**\n-     * Test fork when a scoped value is bound after a StructuredTaskScope is created.\n-     *\/\n-    public void testStructureViolation3() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var scope = new StructuredTaskScope<String>()) {\n-            ScopedValue.where(name, \"x\", () -> {\n-                assertThrows(StructureViolationException.class,\n-                        () -> scope.fork(() -> \"foo\"));\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when a scoped value is re-bound after a StructuredTaskScope is created.\n-     *\/\n-    public void testStructureViolation4() throws Exception {\n-        ScopedValue<String> name1 = ScopedValue.newInstance();\n-        ScopedValue<String> name2 = ScopedValue.newInstance();\n-\n-        \/\/ rebind\n-        ScopedValue.where(name1, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name1, \"y\", () -> {\n-                    assertThrows(StructureViolationException.class,\n-                            () -> scope.fork(() -> \"foo\"));\n-                });\n-            }\n-        });\n-\n-        \/\/ new binding\n-        ScopedValue.where(name1, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name2, \"y\", () -> {\n-                    assertThrows(StructureViolationException.class,\n-                            () -> scope.fork(() -> \"foo\"));\n-                });\n-            }\n-        });\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":0,"deletions":202,"binary":false,"changes":202,"status":"deleted"},{"patch":"@@ -1,220 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test ThreadFlock with scoped values\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- * @modules jdk.incubator.concurrent\n- * @run testng WithScopedValue\n- *\/\n-\n-import jdk.internal.misc.ThreadFlock;\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class WithScopedValue {\n-\n-    @DataProvider(name = \"factories\")\n-    public Object[][] factories() {\n-        var defaultThreadFactory = Executors.defaultThreadFactory();\n-        var virtualThreadFactory = Thread.ofVirtual().factory();\n-        return new Object[][]{\n-                { defaultThreadFactory, },\n-                { virtualThreadFactory, },\n-        };\n-    }\n-\n-    \/**\n-     * Test inheritance of a scoped value.\n-     *\/\n-    @Test(dataProvider = \"factories\")\n-    public void testInheritsScopedValue(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"duke\", () -> {\n-            var result = new AtomicReference<String>();\n-            try (var flock = ThreadFlock.open(null)) {\n-                Thread thread = factory.newThread(() -> {\n-                    \/\/ child\n-                    result.set(name.get());\n-                });\n-                flock.start(thread);\n-            }\n-            return result.get();\n-        });\n-        assertEquals(value, \"duke\");\n-    }\n-\n-    \/**\n-     * Test exiting a dynamic scope with open thread flocks.\n-     *\/\n-    public void testStructureViolation1() {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        class Box {\n-            ThreadFlock flock1;\n-            ThreadFlock flock2;\n-        }\n-        var box = new Box();\n-        try {\n-            ScopedValue.where(name, \"x1\", () -> {\n-                box.flock1 = ThreadFlock.open(null);\n-                box.flock2 = ThreadFlock.open(null);\n-            });\n-            fail();\n-        } catch (StructureViolationException expected) { }\n-        assertTrue(box.flock1.isClosed());\n-        assertTrue(box.flock2.isClosed());\n-    }\n-    \n-    \/**\n-     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n-     * flocks. This test closes enclosing flock1.\n-     *\/\n-    public void testStructureViolation2() {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ScopedValue.where(name, \"x1\", () -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ScopedValue.where(name, \"x2\", () -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ScopedValue.where(name, \"x3\", () -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock1.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertTrue(flock1.isClosed());\n-                                assertTrue(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n-     * flocks. This test closes enclosing flock2.\n-     *\/\n-    public void testStructureViolation3() {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ScopedValue.where(name, \"x1\", () -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ScopedValue.where(name, \"x2\", () -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ScopedValue.where(name, \"x3\", () -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock2.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertFalse(flock1.isClosed());\n-                                assertTrue(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n-     * flocks. This test closes enclosing flock3.\n-     *\/\n-    public void testStructureViolation4() {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ScopedValue.where(name, \"x1\", () -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ScopedValue.where(name, \"x2\", () -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ScopedValue.where(name, \"x3\", () -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock3.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertFalse(flock1.isClosed());\n-                                assertFalse(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test start when a scoped value is bound after a thread flock is created.\n-     *\/\n-    @Test(dataProvider = \"factories\")\n-    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var flock = ThreadFlock.open(null)) {\n-            ScopedValue.where(name, \"duke\", () -> {\n-                Thread thread = factory.newThread(() -> { });\n-                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test start when a scoped value is re-bound after a thread flock is created.\n-     *\/\n-    @Test(dataProvider = \"factories\")\n-    public void testStructureViolation6(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        ScopedValue.where(name, \"duke\", () -> {\n-            try (var flock = ThreadFlock.open(null)) {\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    Thread thread = factory.newThread(() -> { });\n-                    expectThrows(StructureViolationException.class, () -> flock.start(thread));\n-                });\n-            }\n-        });\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/WithScopedValue.java","additions":0,"deletions":220,"binary":false,"changes":220,"status":"deleted"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import static org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesData.*;\n-\n-\/**\n- * Tests ScopedValue\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Warmup(iterations=4, time=1)\n-@Measurement(iterations=10, time=1)\n-@Threads(1)\n-@Fork(value = 1,\n-      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesExecutorService\",\n-                        \"-Djmh.executor=CUSTOM\",\n-                        \"-Djmh.blackhole.mode=COMPILER\",\n-                        \"--add-modules=jdk.incubator.concurrent\",\n-                        \"--enable-preview\"})\n-@State(Scope.Thread)\n-@SuppressWarnings(\"preview\")\n-public class ScopedValues {\n-\n-    private static final Integer THE_ANSWER = 42;\n-\n-    \/\/ Test 1: make sure ScopedValue.get() is hoisted out of loops.\n-\n-    @Benchmark\n-    public void thousandAdds_ScopedValue(Blackhole bh) throws Exception {\n-        int result = 0;\n-        for (int i = 0; i < 1_000; i++) {\n-            result += ScopedValuesData.sl1.get();\n-        }\n-        bh.consume(result);\n-    }\n-\n-    @Benchmark\n-    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n-        int result = 0;\n-        for (int i = 0; i < 1_000; i++) {\n-            result += ScopedValuesData.tl1.get();\n-        }\n-        bh.consume(result);\n-    }\n-\n-    \/\/ Test 2: stress the ScopedValue cache.\n-    \/\/ The idea here is to use a bunch of bound values cyclically, which\n-    \/\/ stresses the ScopedValue cache.\n-\n-    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n-        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n-    }\n-\n-    @Benchmark\n-    public int sixValues_ScopedValue() throws Exception {\n-        int result = 0;\n-        for (int i = 0 ; i < 166; i++) {\n-            result = combine(result, sl1.get(), sl2.get(), sl3.get(), sl4.get(), sl5.get(), sl6.get());\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public int sixValues_ThreadLocal() throws Exception {\n-        int result = 0;\n-        for (int i = 0 ; i < 166; i++) {\n-            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n-        }\n-        return result;\n-    }\n-\n-    \/\/ Test 3: The cost of bind, then get\n-    \/\/ This is the worst case for ScopedValues because we have to create\n-    \/\/ a binding, link it in, then search the current bindings. In addition, we\n-    \/\/ create a cache entry for the bound value, then we immediately have to\n-    \/\/ destroy it.\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int CreateBindThenGetThenRemove_ScopedValue() throws Exception {\n-        return ScopedValue.where(sl1, THE_ANSWER).call(sl1::get);\n-    }\n-\n-\n-    \/\/ Create a Carrier ahead of time: might be slightly faster\n-    private static final ScopedValue.Carrier HOLD_42 = ScopedValue.where(sl1, 42);\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetThenRemove_ScopedValue() throws Exception {\n-        return HOLD_42.call(sl1::get);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n-        try {\n-            tl1.set(THE_ANSWER);\n-            return tl1.get();\n-        } finally {\n-            tl1.remove();\n-        }\n-    }\n-\n-    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n-    \/\/ information.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n-        tl1.set(THE_ANSWER);\n-        return tl1.get();\n-    }\n-\n-    \/\/ Test 4: The cost of binding, but not using any result\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public Object bind_ScopedValue() throws Exception {\n-        return HOLD_42.call(this::getClass);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public Object bind_ThreadLocal() throws Exception {\n-        try {\n-            tl1.set(THE_ANSWER);\n-            return this.getClass();\n-        } finally {\n-            tl1.remove();\n-        }\n-    }\n-\n-    \/\/ Simply set a ThreadLocal so that the caller can see it\n-    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n-    \/\/ information.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void setNoRemove_ThreadLocal() throws Exception {\n-        tl1.set(THE_ANSWER);\n-    }\n-\n-    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n-    \/\/ returns a value in a ScopedValue container. The container must already\n-    \/\/ be bound to an AtomicReference for this to work.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void setNoRemove_ScopedValue() throws Exception {\n-        sl_atomicRef.get().setPlain(THE_ANSWER);\n-    }\n-\n-    \/\/ Test 5: A simple counter\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void counter_ScopedValue() {\n-        sl_atomicInt.get().setPlain(\n-                sl_atomicInt.get().getPlain() + 1);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void counter_ThreadLocal() {\n-        \/\/ Very slow:\n-        \/\/ tl1.set(tl1.get() + 1);\n-        var ctr = tl_atomicInt.get();\n-        ctr.setPlain(ctr.getPlain() + 1);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValues.java","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-@SuppressWarnings(\"preview\")\n-public class ScopedValuesData {\n-\n-    static final ScopedValue<Integer> sl1 = ScopedValue.newInstance();\n-    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n-\n-    static final ScopedValue<Integer> sl2 = ScopedValue.newInstance();\n-    static final ScopedValue<Integer> sl3 = ScopedValue.newInstance();\n-    static final ScopedValue<Integer> sl4 = ScopedValue.newInstance();\n-    static final ScopedValue<Integer> sl5 = ScopedValue.newInstance();\n-    static final ScopedValue<Integer> sl6 = ScopedValue.newInstance();\n-    static final ScopedValue<AtomicInteger> sl_atomicInt = ScopedValue.newInstance();\n-\n-    static final ScopedValue<Integer> unbound = ScopedValue.newInstance();\n-\n-    static final ScopedValue<AtomicReference<Integer>> sl_atomicRef = ScopedValue.newInstance();\n-\n-    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n-    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n-\n-    static final ScopedValue.Carrier VALUES = ScopedValue\n-            .where(sl1, 42).where(sl2, 2).where(sl3, 3)\n-            .where(sl4, 4).where(sl5, 5).where(sl6, 6);\n-\n-    public static void run(Runnable action) {\n-        try {\n-            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n-            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n-            tl_atomicInt.set(new AtomicInteger());\n-            VALUES.where(sl_atomicInt, new AtomicInteger())\n-                  .where(sl_atomicRef, new AtomicReference<>())\n-                  .run(action);\n-        } finally {\n-            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n-            tl_atomicInt.remove();\n-        }\n-    }\n-}\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesData.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import java.util.concurrent.*;\n-\n-public class ScopedValuesExecutorService extends ThreadPoolExecutor {\n-    public ScopedValuesExecutorService(int corePoolSize, String prefix) {\n-        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n-              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n-    }\n-}\n-\n-class AThreadFactory implements ThreadFactory {\n-    public Thread newThread(Runnable action) {\n-        return new Thread() {\n-            public void run() {\n-                ScopedValuesData.run(action);\n-            }\n-        };\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesExecutorService.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"}]}