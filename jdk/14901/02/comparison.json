{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.net.DatagramPacket;\n@@ -653,1 +654,1 @@\n-     * Receives a datagram into the given buffer.\n+     * Receives a datagram.\n@@ -655,2 +656,1 @@\n-     * @apiNote This method is for use by the socket adaptor. The buffer is\n-     * assumed to be trusted, meaning it is not accessible to user code.\n+     * @apiNote This method is for use by the socket adaptor.\n@@ -661,1 +661,4 @@\n-    SocketAddress blockingReceive(ByteBuffer dst, long nanos) throws IOException {\n+    void blockingReceive(DatagramPacket p, long nanos) throws IOException {\n+        Objects.requireNonNull(p);\n+        assert nanos >= 0;\n+\n@@ -667,25 +670,0 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            boolean connected = isConnected();\n-            SocketAddress sender;\n-            do {\n-                if (nanos > 0) {\n-                    sender = trustedBlockingReceive(dst, nanos);\n-                } else {\n-                    sender = trustedBlockingReceive(dst);\n-                }\n-                \/\/ check sender when security manager set and not connected\n-                if (sm != null && !connected) {\n-                    InetSocketAddress isa = (InetSocketAddress) sender;\n-                    try {\n-                        sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n-                    } catch (SecurityException e) {\n-                        sender = null;\n-                    }\n-                }\n-            } while (sender == null);\n-            return sender;\n-        } finally {\n-            readLock.unlock();\n-        }\n-    }\n@@ -693,18 +671,6 @@\n-    \/**\n-     * Receives a datagram into given buffer. This method is used to support\n-     * the socket adaptor. The buffer is assumed to be trusted.\n-     * @throws SocketTimeoutException if the timeout elapses\n-     *\/\n-    private SocketAddress trustedBlockingReceive(ByteBuffer dst)\n-        throws IOException\n-    {\n-        assert readLock.isHeldByCurrentThread() && isBlocking();\n-        SocketAddress sender = null;\n-        try {\n-            SocketAddress remote = beginRead(true, false);\n-            configureSocketNonBlockingIfVirtualThread();\n-            boolean connected = (remote != null);\n-            int n = receive(dst, connected);\n-            while (IOStatus.okayToRetry(n) && isOpen()) {\n-                park(Net.POLLIN);\n-                n = receive(dst, connected);\n+            \/\/ underlying socket needs to be non-blocking if timed receive or virtual thread\n+            if (nanos > 0) {\n+                configureSocketNonBlocking();\n+            } else {\n+                configureSocketNonBlockingIfVirtualThread();\n+                nanos = Long.MAX_VALUE;\n@@ -712,3 +678,51 @@\n-            if (n > 0 || (n == 0 && isOpen())) {\n-                \/\/ sender address is in socket address buffer\n-                sender = sourceSocketAddress();\n+\n+            \/\/ p.bufLength is the maximum size of the datagram that can be received\n+            int bufLength;\n+            synchronized (p) {\n+                bufLength = DatagramPackets.getBufLength(p);\n+            }\n+\n+            long startNanos = System.nanoTime();\n+            SocketAddress sender = null;\n+            try {\n+                SocketAddress remote = beginRead(true, false);\n+                boolean connected = (remote != null);\n+                do {\n+                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                    ByteBuffer dst = tryBlockingReceive(connected, bufLength, remainingNanos);\n+\n+                    \/\/ if datagram received then get sender and copy to DatagramPacket\n+                    if (dst != null) {\n+                        try {\n+                            \/\/ sender address is in socket address buffer\n+                            sender = sourceSocketAddress();\n+\n+                            \/\/ check sender when security manager set and not connected\n+                            @SuppressWarnings(\"removal\")\n+                            SecurityManager sm = System.getSecurityManager();\n+                            if (sm != null && !connected) {\n+                                InetSocketAddress isa = (InetSocketAddress) sender;\n+                                try {\n+                                    sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+                                } catch (SecurityException e) {\n+                                    sender = null;\n+                                }\n+                            }\n+\n+                            \/\/ copy bytes to the DatagramPacket, and set length and sender\n+                            if (sender != null) {\n+                                synchronized (p) {\n+                                    \/\/ re-read p.bufLength in case DatagramPacket changed\n+                                    int len = Math.min(dst.limit(), DatagramPackets.getBufLength(p));\n+                                    dst.get(p.getData(), p.getOffset(), len);\n+                                    DatagramPackets.setLength(p, len);\n+                                    p.setSocketAddress(sender);\n+                                }\n+                            }\n+                        } finally {\n+                            Util.offerFirstTemporaryDirectBuffer(dst);\n+                        }\n+                    }\n+                } while (sender == null && isOpen());\n+            } finally {\n+                endRead(true, (sender != null));\n@@ -716,1 +730,0 @@\n-            return sender;\n@@ -718,1 +731,1 @@\n-            endRead(true, (sender != null));\n+            readLock.unlock();\n@@ -723,2 +736,6 @@\n-     * Receives a datagram into given buffer with a timeout. This method is\n-     * used to support the socket adaptor. The buffer is assumed to be trusted.\n+     * Attempt to receive a datagram.\n+     *\n+     * @param connected if the channel's socket is connected\n+     * @param len the maximum size of the datagram to receive\n+     * @param nanos the timeout, should be Long.MAX_VALUE for untimed\n+     * @return a direct buffer containing the datagram or null if channel is closed\n@@ -727,1 +744,1 @@\n-    private SocketAddress trustedBlockingReceive(ByteBuffer dst, long nanos)\n+    private ByteBuffer tryBlockingReceive(boolean connected, int len, long nanos)\n@@ -730,2 +747,3 @@\n-        assert readLock.isHeldByCurrentThread() && isBlocking();\n-        SocketAddress sender = null;\n+        long startNanos = System.nanoTime();\n+        ByteBuffer dst = Util.getTemporaryDirectBuffer(len);\n+        int n = -1;\n@@ -733,15 +751,6 @@\n-            SocketAddress remote = beginRead(true, false);\n-            boolean connected = (remote != null);\n-\n-            \/\/ change socket to non-blocking\n-            lockedConfigureBlocking(false);\n-            try {\n-                long startNanos = System.nanoTime();\n-                int n = receive(dst, connected);\n-                while (n == IOStatus.UNAVAILABLE && isOpen()) {\n-                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n-                    if (remainingNanos <= 0) {\n-                        throw new SocketTimeoutException(\"Receive timed out\");\n-                    }\n-                    park(Net.POLLIN, remainingNanos);\n-                    n = receive(dst, connected);\n+            n = receive(dst, connected);\n+            while (n == IOStatus.UNAVAILABLE && isOpen()) {\n+                \/\/ virtual thread needs to release temporary direct buffer before parking\n+                if (Thread.currentThread().isVirtual()) {\n+                    Util.offerFirstTemporaryDirectBuffer(dst);\n+                    dst = null;\n@@ -749,3 +758,3 @@\n-                if (n > 0 || (n == 0 && isOpen())) {\n-                    \/\/ sender address is in socket address buffer\n-                    sender = sourceSocketAddress();\n+                long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                if (remainingNanos <= 0) {\n+                    throw new SocketTimeoutException(\"Receive timed out\");\n@@ -753,4 +762,6 @@\n-                return sender;\n-            } finally {\n-                \/\/ restore socket to blocking mode (if channel is open)\n-                tryLockedConfigureBlocking(true);\n+                park(Net.POLLIN, remainingNanos);\n+                \/\/ virtual thread needs to re-allocate temporary direct buffer after parking\n+                if (Thread.currentThread().isVirtual()) {\n+                    dst = Util.getTemporaryDirectBuffer(len);\n+                }\n+                n = receive(dst, connected);\n@@ -758,0 +769,1 @@\n+            dst.flip();\n@@ -759,1 +771,5 @@\n-            endRead(true, (sender != null));\n+            \/\/ release buffer if no datagram received\n+            if (dst != null && (n < 0 || (n == 0 && !isOpen()))) {\n+                Util.offerFirstTemporaryDirectBuffer(dst);\n+                dst = null;\n+            }\n@@ -761,0 +777,1 @@\n+        return dst;\n@@ -892,1 +909,1 @@\n-     * Sends a datagram from the bytes in given buffer.\n+     * Sends a datagram.\n@@ -896,0 +913,1 @@\n+     * @throws IllegalArgumentException if not connected and target address not set\n@@ -898,1 +916,3 @@\n-    void blockingSend(ByteBuffer src, SocketAddress target) throws IOException {\n+    void blockingSend(DatagramPacket p) throws IOException {\n+        Objects.requireNonNull(p);\n+\n@@ -904,1 +924,33 @@\n-            send(src, target);\n+\n+            ByteBuffer src = null;\n+            try {\n+                InetSocketAddress target;\n+                synchronized (p) {\n+                    int len = p.getLength();\n+                    src = Util.getTemporaryDirectBuffer(len);\n+\n+                    \/\/ copy bytes to temporary direct buffer\n+                    src.put(p.getData(), p.getOffset(), len);\n+                    src.flip();\n+\n+                    \/\/ target address\n+                    if (p.getAddress() == null) {\n+                        InetSocketAddress remote = remoteAddress();\n+                        if (remote == null) {\n+                            throw new IllegalArgumentException(\"Address not set\");\n+                        }\n+                        \/\/ set address\/port to be compatible with long standing behavior\n+                        p.setAddress(remote.getAddress());\n+                        p.setPort(remote.getPort());\n+                        target = remote;\n+                    } else {\n+                        target = (InetSocketAddress) p.getSocketAddress();\n+                    }\n+                }\n+\n+                \/\/ send the datagram (does not block)\n+                send(src, target);\n+\n+            } finally {\n+                if (src != null) Util.offerFirstTemporaryDirectBuffer(src);\n+            }\n@@ -1201,1 +1253,1 @@\n-     * Ensures that the socket is configured non-blocking when on a virtual thread.\n+     * Ensures that the socket is configured non-blocking.\n@@ -1204,1 +1256,1 @@\n-    private void configureSocketNonBlockingIfVirtualThread() throws IOException {\n+    private void configureSocketNonBlocking() throws IOException {\n@@ -1206,1 +1258,1 @@\n-        if (!forcedNonBlocking && Thread.currentThread().isVirtual()) {\n+        if (!forcedNonBlocking) {\n@@ -1215,0 +1267,10 @@\n+    \/**\n+     * Ensures that the socket is configured non-blocking when on a virtual thread.\n+     * @throws IOException if there is an I\/O error changing the blocking mode\n+     *\/\n+    private void configureSocketNonBlockingIfVirtualThread() throws IOException {\n+        if (Thread.currentThread().isVirtual()) {\n+            configureSocketNonBlocking();\n+        }\n+    }\n+\n@@ -1955,0 +2017,38 @@\n+    \/**\n+     * Defines static methods to get\/set DatagramPacket fields and workaround\n+     * DatagramPacket deficiencies.\n+     *\/\n+    private static class DatagramPackets {\n+        private static final VarHandle LENGTH;\n+        private static final VarHandle BUF_LENGTH;\n+        static {\n+            try {\n+                PrivilegedExceptionAction<MethodHandles.Lookup> pa = () ->\n+                    MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());\n+                @SuppressWarnings(\"removal\")\n+                MethodHandles.Lookup l = AccessController.doPrivileged(pa);\n+                LENGTH = l.findVarHandle(DatagramPacket.class, \"length\", int.class);\n+                BUF_LENGTH = l.findVarHandle(DatagramPacket.class, \"bufLength\", int.class);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+\n+        \/**\n+         * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be\n+         * used at this time because it sets both the length and bufLength fields.\n+         *\/\n+        static void setLength(DatagramPacket p, int value) {\n+            assert Thread.holdsLock(p);\n+            LENGTH.set(p, value);\n+        }\n+\n+        \/**\n+         * Returns the value of the DatagramPacket.bufLength field.\n+         *\/\n+        static int getBufLength(DatagramPacket p) {\n+            assert Thread.holdsLock(p);\n+            return (int) BUF_LENGTH.get(p);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":186,"deletions":86,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -47,1 +46,0 @@\n-import java.nio.ByteBuffer;\n@@ -59,1 +57,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -195,33 +192,6 @@\n-        synchronized (p) {\n-            int len = p.getLength();\n-            ByteBuffer bb = Util.getTemporaryDirectBuffer(len);\n-            try {\n-                \/\/ copy bytes to temporary direct buffer\n-                bb.put(p.getData(), p.getOffset(), len);\n-                bb.flip();\n-\n-                \/\/ target address\n-                InetSocketAddress target;\n-                if (p.getAddress() == null) {\n-                    InetSocketAddress remote = dc.remoteAddress();\n-                    if (remote == null) {\n-                        \/\/ not specified by DatagramSocket\n-                        throw new IllegalArgumentException(\"Address not set\");\n-                    }\n-                    \/\/ set address\/port to maintain compatibility with DatagramSocket\n-                    p.setAddress(remote.getAddress());\n-                    p.setPort(remote.getPort());\n-                    target = remote;\n-                } else {\n-                    target = (InetSocketAddress) p.getSocketAddress();\n-                }\n-\n-                \/\/ send datagram\n-                dc.blockingSend(bb, target);\n-            } catch (AlreadyConnectedException e) {\n-                throw new IllegalArgumentException(\"Connected and packet address differ\");\n-            } catch (ClosedChannelException e) {\n-                throw new SocketException(\"Socket closed\", e);\n-            } finally {\n-                Util.offerFirstTemporaryDirectBuffer(bb);\n-            }\n+        try {\n+            dc.blockingSend(p);\n+        } catch (AlreadyConnectedException e) {\n+            throw new IllegalArgumentException(\"Connected and packet address differ\");\n+        } catch (ClosedChannelException e) {\n+            throw new SocketException(\"Socket closed\", e);\n@@ -233,34 +203,9 @@\n-        synchronized (p) {\n-            \/\/ get temporary direct buffer with a capacity of p.bufLength\n-            int bufLength = DatagramPackets.getBufLength(p);\n-            ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);\n-            try {\n-                SocketAddress sender;\n-                long comp = Blocker.begin();\n-                try {\n-                    sender = dc.blockingReceive(bb, MILLISECONDS.toNanos(timeout));\n-                } finally {\n-                    Blocker.end(comp);\n-                }\n-                bb.flip();\n-\n-                \/\/ copy bytes to the DatagramPacket and set length\n-                int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));\n-                bb.get(p.getData(), p.getOffset(), len);\n-                DatagramPackets.setLength(p, len);\n-\n-                \/\/ sender address\n-                p.setSocketAddress(sender);\n-            } catch (SocketTimeoutException | ClosedByInterruptException e) {\n-                throw e;\n-            } catch (InterruptedIOException e) {\n-                Thread thread = Thread.currentThread();\n-                if (thread.isVirtual() && thread.isInterrupted()) {\n-                    close();\n-                    throw new SocketException(\"Closed by interrupt\");\n-                }\n-                throw e;\n-            } catch (ClosedChannelException e) {\n-                throw new SocketException(\"Socket closed\", e);\n-            } finally {\n-                Util.offerFirstTemporaryDirectBuffer(bb);\n+        try {\n+            dc.blockingReceive(p, MILLISECONDS.toNanos(timeout));\n+        } catch (SocketTimeoutException | ClosedByInterruptException e) {\n+            throw e;\n+        } catch (InterruptedIOException e) {\n+            Thread thread = Thread.currentThread();\n+            if (thread.isVirtual() && thread.isInterrupted()) {\n+                close();\n+                throw new SocketException(\"Closed by interrupt\");\n@@ -268,0 +213,3 @@\n+            throw e;\n+        } catch (ClosedChannelException e) {\n+            throw new SocketException(\"Socket closed\", e);\n@@ -707,38 +655,0 @@\n-    \/**\n-     * Defines static methods to get\/set DatagramPacket fields and workaround\n-     * DatagramPacket deficiencies.\n-     *\/\n-    private static class DatagramPackets {\n-        private static final VarHandle LENGTH;\n-        private static final VarHandle BUF_LENGTH;\n-        static {\n-            try {\n-                PrivilegedExceptionAction<MethodHandles.Lookup> pa = () ->\n-                    MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());\n-                @SuppressWarnings(\"removal\")\n-                MethodHandles.Lookup l = AccessController.doPrivileged(pa);\n-                LENGTH = l.findVarHandle(DatagramPacket.class, \"length\", int.class);\n-                BUF_LENGTH = l.findVarHandle(DatagramPacket.class, \"bufLength\", int.class);\n-            } catch (Exception e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        }\n-\n-        \/**\n-         * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be\n-         * used at this time because it sets both the length and bufLength fields.\n-         *\/\n-        static void setLength(DatagramPacket p, int value) {\n-            assert Thread.holdsLock(p);\n-            LENGTH.set(p, value);\n-        }\n-\n-        \/**\n-         * Returns the value of the DatagramPacket.bufLength field.\n-         *\/\n-        static int getBufLength(DatagramPacket p) {\n-            assert Thread.holdsLock(p);\n-            return (int) BUF_LENGTH.get(p);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramSocketAdaptor.java","additions":19,"deletions":109,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test a timed DatagramSocket.receive with a SecurityManager set\n+ * @run main\/othervm -Djava.security.manager=allow TimeoutWithSM\n+ *\/\n+\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n+import java.security.Permission;\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class TimeoutWithSM {\n+\n+    private static final int TIMEOUT = 10_000;\n+\n+    public static void main(String[] args) throws Exception {\n+        try (var socket = new DatagramSocket(null)) {\n+            InetAddress lb = InetAddress.getLoopbackAddress();\n+            socket.bind(new InetSocketAddress(lb, 0));\n+\n+            \/\/ start sender to send datagrams to us\n+            var done = new AtomicBoolean();\n+            startSender(socket.getLocalSocketAddress(), done);\n+\n+            \/\/ set a SecurityManager that blocks datagrams from sender\n+            System.setSecurityManager(new SecurityManager() {\n+                @Override\n+                public void checkPermission(Permission p) {\n+                }\n+                @Override\n+                public void checkAccept(String host, int port) {\n+                    var isa = new InetSocketAddress(host, port);\n+                    System.out.println(\"checkAccept \" + isa);\n+                    throw new SecurityException();\n+                }\n+            });\n+\n+            \/\/ timed receive, should throw SocketTimeoutException\n+            try {\n+                socket.setSoTimeout(TIMEOUT);\n+                try {\n+                    byte[] bytes = new byte[1024];\n+                    DatagramPacket p = new DatagramPacket(bytes, bytes.length);\n+                    socket.receive(p);\n+                    throw new RuntimeException(\"Packet received, unexpected!!! \"\n+                            + \" sender=\" + p.getSocketAddress() + \", len=\" + p.getLength());\n+                } catch (SocketTimeoutException expected) {\n+                    System.out.println(expected + \", expected!!!\");\n+                }\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Start a thread to send datagrams to the given target address at intervals of\n+     * one second. The sender stops when done is set to true.\n+     *\/\n+    static void startSender(SocketAddress target, AtomicBoolean done) throws Exception {\n+        assert target instanceof InetSocketAddress isa && isa.getAddress().isLoopbackAddress();\n+        var sender = new DatagramSocket(null);\n+        boolean started = false;\n+        try {\n+            InetAddress lb = InetAddress.getLoopbackAddress();\n+            sender.bind(new InetSocketAddress(lb, 0));\n+            Thread.ofPlatform().start(() -> {\n+                try {\n+                    try (sender) {\n+                        byte[] bytes = \"hello\".getBytes(\"UTF-8\");\n+                        DatagramPacket p = new DatagramPacket(bytes, bytes.length);\n+                        p.setSocketAddress(target);\n+                        while (!done.get()) {\n+                            System.out.println(\"Send datagram to \" + target + \" ...\");\n+                            sender.send(p);\n+                            Thread.sleep(Duration.ofSeconds(1));\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            started = true;\n+        } finally {\n+            if (!started) {\n+                sender.close();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/TimeoutWithSM.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}