{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,0 @@\n-import org.xml.sax.SAXNotRecognizedException;\n-import org.xml.sax.SAXNotSupportedException;\n@@ -65,1 +63,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: July 2023\n@@ -472,3 +470,6 @@\n-        try {\n-            final XMLReader reader = JdkXmlUtils.getXMLReader(_overrideDefaultParser,\n-                    _xsltc.isSecureProcessing());\n+        final XMLReader reader = JdkXmlUtils.getXMLReader(\n+                (XMLSecurityManager)_xsltc.getProperty(JdkConstants.SECURITY_MANAGER),\n+                _overrideDefaultParser,\n+                _xsltc.isSecureProcessing(),\n+                _xsltc.getFeature(JdkXmlFeatures.XmlFeature.USE_CATALOG),\n+                (CatalogFeatures)_xsltc.getProperty(JdkXmlFeatures.CATALOG_FEATURES));\n@@ -476,2 +477,2 @@\n-            JdkXmlUtils.setXMLReaderPropertyIfSupport(reader, XMLConstants.ACCESS_EXTERNAL_DTD,\n-                    _xsltc.getProperty(XMLConstants.ACCESS_EXTERNAL_DTD), true);\n+        JdkXmlUtils.setXMLReaderPropertyIfSupport(reader, XMLConstants.ACCESS_EXTERNAL_DTD,\n+                _xsltc.getProperty(XMLConstants.ACCESS_EXTERNAL_DTD), true);\n@@ -479,0 +480,3 @@\n+        \/\/ try setting other JDK-impl properties, ignore if not supported\n+        JdkXmlUtils.setXMLReaderPropertyIfSupport(reader, JdkConstants.CDATA_CHUNK_SIZE,\n+            _xsltc.getProperty(JdkConstants.CDATA_CHUNK_SIZE), false);\n@@ -480,50 +484,1 @@\n-            boolean supportCatalog = true;\n-            boolean useCatalog = _xsltc.getFeature(JdkXmlFeatures.XmlFeature.USE_CATALOG);\n-            try {\n-                reader.setFeature(JdkXmlUtils.USE_CATALOG, useCatalog);\n-            }\n-            catch (SAXNotRecognizedException | SAXNotSupportedException e) {\n-                supportCatalog = false;\n-            }\n-\n-            if (supportCatalog && useCatalog) {\n-                try {\n-                    CatalogFeatures cf = (CatalogFeatures)_xsltc.getProperty(JdkXmlFeatures.CATALOG_FEATURES);\n-                        if (cf != null) {\n-                            for (CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {\n-                                reader.setProperty(f.getPropertyName(), cf.get(f));\n-                            }\n-                        }\n-                } catch (SAXNotRecognizedException e) {\n-                    \/\/shall not happen for internal settings\n-                }\n-            }\n-\n-            String lastProperty = \"\";\n-            try {\n-                XMLSecurityManager securityManager =\n-                        (XMLSecurityManager)_xsltc.getProperty(JdkConstants.SECURITY_MANAGER);\n-                for (XMLSecurityManager.Limit limit : XMLSecurityManager.Limit.values()) {\n-                    if (limit.isSupported(XMLSecurityManager.Processor.PARSER)) {\n-                        lastProperty = limit.apiProperty();\n-                        reader.setProperty(lastProperty, securityManager.getLimitValueAsString(limit));\n-                    }\n-                }\n-                if (securityManager.printEntityCountInfo()) {\n-                    lastProperty = JdkConstants.JDK_DEBUG_LIMIT;\n-                    reader.setProperty(lastProperty, JdkConstants.JDK_YES);\n-                }\n-            } catch (SAXException se) {\n-                XMLSecurityManager.printWarning(reader.getClass().getName(), lastProperty, se);\n-            }\n-\n-            \/\/ try setting other JDK-impl properties, ignore if not supported\n-            JdkXmlUtils.setXMLReaderPropertyIfSupport(reader, JdkConstants.CDATA_CHUNK_SIZE,\n-                _xsltc.getProperty(JdkConstants.CDATA_CHUNK_SIZE), false);\n-\n-            return(parse(reader, input));\n-        }\n-        catch (SAXException e) {\n-            reportError(ERROR, new ErrorMsg(e.getMessage()));\n-        }\n-        return null;\n+        return(parse(reader, input));\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/Parser.java","additions":14,"deletions":59,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+ *\n+ * @LastModified: July 2023\n@@ -67,2 +69,5 @@\n-        XMLReader parent = JdkXmlUtils.getXMLReader(_overrideDefaultParser,\n-                _transformer.isSecureProcessing());\n+        XMLReader parent = JdkXmlUtils.getXMLReader(_transformer._securityManager,\n+                _overrideDefaultParser,\n+                _transformer.isSecureProcessing(),\n+                _transformer._useCatalog,\n+                _transformer._catalogFeatures);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TrAXFilter.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import jdk.xml.internal.JdkConstants;\n-import jdk.xml.internal.XMLSecurityManager;\n@@ -74,0 +72,1 @@\n+import jdk.xml.internal.JdkConstants;\n@@ -81,0 +80,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -91,1 +91,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: July 2023\n@@ -506,1 +506,1 @@\n-            cfBuilder = CatalogFeatures.builder().with(Feature.FILES, _catalogFiles);\n+            cfBuilder = cfBuilder.with(Feature.FILES, _catalogFiles);\n@@ -510,1 +510,1 @@\n-            cfBuilder = CatalogFeatures.builder().with(Feature.DEFER, _catalogDefer);\n+            cfBuilder = cfBuilder.with(Feature.DEFER, _catalogDefer);\n@@ -514,1 +514,1 @@\n-            cfBuilder = CatalogFeatures.builder().with(Feature.PREFER, _catalogPrefer);\n+            cfBuilder = cfBuilder.with(Feature.PREFER, _catalogPrefer);\n@@ -518,1 +518,1 @@\n-            cfBuilder = CatalogFeatures.builder().with(Feature.RESOLVE, _catalogResolve);\n+            cfBuilder = cfBuilder.with(Feature.RESOLVE, _catalogResolve);\n@@ -768,2 +768,5 @@\n-                    reader = JdkXmlUtils.getXMLReader(_overrideDefaultParser,\n-                            !_isNotSecureProcessing);\n+                    reader = JdkXmlUtils.getXMLReader(_xmlSecurityManager,\n+                            _overrideDefaultParser,\n+                            !_isNotSecureProcessing,\n+                            _xmlFeatures.getFeature(JdkXmlFeatures.XmlFeature.USE_CATALOG),\n+                            _catalogFeatures);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TransformerFactoryImpl.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,0 @@\n-import static jdk.xml.internal.JdkConstants.SP_XSLTC_IS_STANDALONE;\n@@ -104,1 +103,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: July 2023\n@@ -222,1 +221,1 @@\n-    private XMLSecurityManager _securityManager;\n+    protected XMLSecurityManager _securityManager;\n@@ -310,1 +309,1 @@\n-            String catalogFiles = _catalogFeatures.get(CatalogFeatures.Feature.DEFER);\n+            String catalogFiles = _catalogFeatures.get(CatalogFeatures.Feature.FILES);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TransformerImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import org.xml.sax.SAXException;\n@@ -54,1 +53,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: July 2023\n@@ -94,2 +93,6 @@\n-                        reader = JdkXmlUtils.getXMLReader(overrideDefaultParser,\n-                                xsltc.isSecureProcessing());\n+                        reader = JdkXmlUtils.getXMLReader(\n+                                (XMLSecurityManager)xsltc.getProperty(JdkConstants.SECURITY_MANAGER),\n+                                overrideDefaultParser,\n+                                xsltc.isSecureProcessing(),\n+                                xsltc.getFeature(JdkXmlFeatures.XmlFeature.USE_CATALOG),\n+                                (CatalogFeatures)xsltc.getProperty(JdkXmlFeatures.CATALOG_FEATURES));\n@@ -110,21 +113,0 @@\n-                    String lastProperty = \"\";\n-                    try {\n-                        XMLSecurityManager securityManager =\n-                                (XMLSecurityManager)xsltc.getProperty(JdkConstants.SECURITY_MANAGER);\n-                        if (securityManager != null) {\n-                            for (XMLSecurityManager.Limit limit : XMLSecurityManager.Limit.values()) {\n-                                if (limit.isSupported(XMLSecurityManager.Processor.PARSER)) {\n-                                    lastProperty = limit.apiProperty();\n-                                    reader.setProperty(lastProperty,\n-                                            securityManager.getLimitValueAsString(limit));\n-                                }\n-                            }\n-                            if (securityManager.printEntityCountInfo()) {\n-                                lastProperty = JdkConstants.JDK_DEBUG_LIMIT;\n-                                reader.setProperty(lastProperty, JdkConstants.JDK_YES);\n-                            }\n-                        }\n-                    } catch (SAXException se) {\n-                        XMLSecurityManager.printWarning(reader.getClass().getName(), lastProperty, se);\n-                    }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/Util.java","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -59,0 +58,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -74,1 +74,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/dom\/DOMConfigurationImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -39,0 +38,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -48,0 +48,2 @@\n+ *\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/PropertyManager.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager.Limit;\n@@ -34,0 +33,1 @@\n+import jdk.xml.internal.XMLSecurityManager.Limit;\n@@ -44,1 +44,1 @@\n- * @LastModified: Aug 2021\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XML11EntityScanner.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -39,0 +38,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -73,1 +73,1 @@\n- * @LastModified: Nov 2022\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XML11NSDocumentScannerImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLLimitAnalyzer;\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -44,0 +42,2 @@\n+import jdk.xml.internal.XMLLimitAnalyzer;\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -66,1 +66,1 @@\n- * @LastModified: Feb 2020\n+ * @LastModified: July 2023\n@@ -391,0 +391,1 @@\n+        fEntityScanner = fEntityManager.getEntityScanner();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLDTDScannerImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager.Limit;\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -59,0 +57,2 @@\n+import jdk.xml.internal.XMLSecurityManager;\n+import jdk.xml.internal.XMLSecurityManager.Limit;\n@@ -77,1 +77,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n@@ -329,0 +329,2 @@\n+    \/\/ DTD Error Code\n+    protected String fDTDErrorCode = null;\n@@ -795,1 +797,1 @@\n-                \/\/ Xerces properties\n+        \/\/ Xerces properties\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLDocumentFragmentScannerImpl.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import javax.xml.stream.XMLInputFactory;\n@@ -48,0 +47,2 @@\n+import jdk.xml.internal.JdkConstants;\n+import jdk.xml.internal.JdkProperty.State;\n@@ -49,0 +50,1 @@\n+import jdk.xml.internal.XMLSecurityManager.Limit;\n@@ -70,1 +72,1 @@\n- * @LastModified: Sep 2017\n+ * @LastModified: July 2023\n@@ -261,2 +263,0 @@\n-\n-\n@@ -268,3 +268,0 @@\n-\n-\n-\n@@ -279,1 +276,3 @@\n-        fSupportDTD = ((Boolean)propertyManager.getProperty(XMLInputFactory.SUPPORT_DTD)).booleanValue();\n+\n+        \/\/ Check the DTD setting\n+        checkDTDSetting();\n@@ -282,1 +281,3 @@\n-        fLoadExternalDTD = !((Boolean)propertyManager.getProperty(Constants.ZEPHYR_PROPERTY_PREFIX + Constants.IGNORE_EXTERNAL_DTD)).booleanValue();\n+        fLoadExternalDTD = !((Boolean)propertyManager.getProperty(\n+                Constants.ZEPHYR_PROPERTY_PREFIX + Constants.IGNORE_EXTERNAL_DTD));\n+\n@@ -323,0 +324,3 @@\n+        \/\/ Check the DTD setting\n+        checkDTDSetting();\n+\n@@ -325,1 +329,0 @@\n-        fDisallowDoctype = componentManager.getFeature(DISALLOW_DOCTYPE_DECL_FEATURE, false);\n@@ -358,0 +361,20 @@\n+    \/**\n+     * Checks the DTD settings. Uses the JDK property {@code jdk.xml.dtd.support}\n+     * in all cases except:\n+     *      if the Xerces property is set\n+     *      if the StAX property is set\n+     *\/\n+    private void checkDTDSetting() {\n+        fDisallowDoctype = fSecurityManager.is(Limit.DTD, JdkConstants.DENY);\n+        fSupportDTD = !fSecurityManager.is(Limit.DTD, JdkConstants.IGNORE);\n+        fDTDErrorCode = \"JDK_DTD_DENY\";\n+\n+        if (fSecurityManager.getState(Limit.XERCES_DISALLOW_DTD) == State.APIPROPERTY\n+                || fSecurityManager.getState(Limit.XERCES_DISALLOW_DTD) == State.LEGACY_APIPROPERTY) {\n+            fDisallowDoctype = fSecurityManager.is(Limit.XERCES_DISALLOW_DTD);\n+            fDTDErrorCode = \"DoctypeNotAllowed\";\n+        } else if (fSecurityManager.getState(Limit.STAX_SUPPORT_DTD) == State.APIPROPERTY\n+                || fSecurityManager.getState(Limit.STAX_SUPPORT_DTD) == State.LEGACY_APIPROPERTY) {\n+            fSupportDTD = fSecurityManager.is(Limit.STAX_SUPPORT_DTD);\n+        }\n+    }\n@@ -898,1 +921,1 @@\n-                            reportFatalError(\"DoctypeNotAllowed\", null);\n+                            reportFatalError(fDTDErrorCode, null);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLDocumentScannerImpl.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLLimitAnalyzer;\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -62,0 +60,1 @@\n+import jdk.xml.internal.JdkProperty;\n@@ -64,0 +63,3 @@\n+import jdk.xml.internal.XMLLimitAnalyzer;\n+import jdk.xml.internal.XMLSecurityManager;\n+import jdk.xml.internal.XMLSecurityManager.Limit;\n@@ -94,1 +96,1 @@\n- * @LastModified: Aug 2021\n+ * @LastModified: July 2023\n@@ -1547,1 +1549,0 @@\n-        fSupportDTD = ((Boolean)propertyManager.getProperty(XMLInputFactory.SUPPORT_DTD));\n@@ -1566,0 +1567,1 @@\n+        checkSupportDTD();\n@@ -1636,1 +1638,1 @@\n-        fSupportDTD = true;\n+        checkSupportDTD();\n@@ -1662,0 +1664,14 @@\n+    \/**\n+     * Checks the supportDTD setting. Use the StAX supportDTD property if it is\n+     * set, otherwise the jdk.xml.dtd.support. Refer to the module-summary for\n+     * more details.\n+     *\/\n+    private void checkSupportDTD() {\n+        \/\/ SupportDTD set the DTD property, so no longer read from propertyManager\n+        fSupportDTD = !fSecurityManager.is(Limit.DTD, JdkConstants.IGNORE);\n+        if (fSecurityManager.getState(Limit.STAX_SUPPORT_DTD) == JdkProperty.State.APIPROPERTY\n+                || fSecurityManager.getState(Limit.STAX_SUPPORT_DTD) == JdkProperty.State.LEGACY_APIPROPERTY) {\n+            fSupportDTD = fSecurityManager.is(Limit.STAX_SUPPORT_DTD);\n+        }\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLEntityManager.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLLimitAnalyzer;\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager.Limit;\n@@ -51,0 +48,3 @@\n+import jdk.xml.internal.XMLLimitAnalyzer;\n+import jdk.xml.internal.XMLSecurityManager;\n+import jdk.xml.internal.XMLSecurityManager.Limit;\n@@ -60,1 +60,1 @@\n- * @LastModified: Mar 2022\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLEntityScanner.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n-\n@@ -40,0 +38,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -58,1 +57,1 @@\n- * @LastModified: Nov 2022\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLNSDocumentScannerImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLLimitAnalyzer;\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -44,0 +42,2 @@\n+import jdk.xml.internal.XMLLimitAnalyzer;\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -70,1 +70,1 @@\n- * @LastModified: Aug 2021\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLScanner.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,3 @@\n+# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#\n+#\n@@ -326,0 +329,5 @@\n+\n+# Implementation Property DTD\n+        JDK_DTD_DENY = JAXP00010008: DOCTYPE is disallowed when the DTD property is set to deny. \\\n+                       Refer to: property jdk.xml.dtd.support in java.xml\/module-summary.\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -79,1 +78,1 @@\n-import jdk.xml.internal.JdkXmlFeatures;\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -106,1 +105,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/xs\/XMLSchemaLoader.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -31,0 +30,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -37,1 +37,1 @@\n- *\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/xs\/models\/CMNodeFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -45,0 +44,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -70,1 +70,1 @@\n- * @LastModified: Apr 2022\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/xs\/traversers\/XSAttributeChecker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -112,0 +111,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -134,1 +134,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n@@ -2286,2 +2286,4 @@\n-                    parser = JdkXmlUtils.getXMLReader(fOverrideDefaultParser,\n-                            fSecurityManager.isSecureProcessing());\n+                    parser = JdkXmlUtils.getXMLReader(fSecurityManager,\n+                            fOverrideDefaultParser, fSecurityManager.isSecureProcessing(),\n+                            fUseCatalog,\n+                            JdkXmlUtils.getCatalogFeatures(fDefer, fCatalogFile, fPrefer, fResolve));\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/xs\/traversers\/XSDHandler.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -35,0 +34,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -42,1 +42,1 @@\n- * @LastModified: Mar 2023\n+ * @LastModified: July 2023\n@@ -82,0 +82,2 @@\n+            \/\/ read system properties for compatibility\n+            fSecurityManager.readSystemProperties();\n@@ -235,0 +237,1 @@\n+            fSecurityManager.setSecureProcessing(fSecureProcess);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/DocumentBuilderFactoryImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -50,0 +49,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -62,1 +62,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n@@ -143,0 +143,6 @@\n+        fSecurityPropertyMgr = new XMLSecurityPropertyManager();\n+        domParser.setProperty(XML_SECURITY_PROPERTY_MANAGER, fSecurityPropertyMgr);\n+\n+        fSecurityManager = dbf.fSecurityManager;\n+        domParser.setProperty(SECURITY_MANAGER, fSecurityManager);\n+\n@@ -176,6 +182,0 @@\n-        fSecurityPropertyMgr = new XMLSecurityPropertyManager();\n-        domParser.setProperty(XML_SECURITY_PROPERTY_MANAGER, fSecurityPropertyMgr);\n-\n-        fSecurityManager = new XMLSecurityManager(secureProcessing);\n-        domParser.setProperty(SECURITY_MANAGER, fSecurityManager);\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/DocumentBuilderImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import com.sun.org.apache.xerces.internal.utils.XMLSecurityPropertyManager;\n@@ -32,0 +33,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -44,0 +46,1 @@\n+ * @LastModified: July 2023\n@@ -68,0 +71,4 @@\n+    \/\/ Security Managers\n+    XMLSecurityManager fSecurityManager = new XMLSecurityManager(true);\n+    XMLSecurityPropertyManager fSecurityPropertyMgr = new XMLSecurityPropertyManager();\n+\n@@ -78,0 +85,2 @@\n+            \/\/ read system properties for compatibility\n+            fSecurityManager.readSystemProperties();\n@@ -125,0 +134,1 @@\n+            fSecurityManager.setSecureProcessing(fSecureProcess);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/SAXParserFactoryImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -48,0 +47,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -66,1 +66,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n@@ -134,2 +134,2 @@\n-        fSecurityManager = new XMLSecurityManager(secureProcessing);\n-        fSecurityPropertyMgr = new XMLSecurityPropertyManager();\n+        fSecurityManager = spf.fSecurityManager;\n+        fSecurityPropertyMgr = spf.fSecurityPropertyMgr;\n@@ -415,7 +415,0 @@\n-                try {\n-                    super.setProperty(SECURITY_MANAGER, fSecurityManager);\n-                } catch (SAXException e) {\n-                    throw new UnsupportedOperationException(\n-                    SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),\n-                    \"property-not-recognized\", new Object [] {SECURITY_MANAGER}), e);\n-                }\n@@ -423,0 +416,8 @@\n+            try {\n+                super.setProperty(SECURITY_MANAGER, fSecurityManager);\n+            } catch (SAXException e) {\n+                throw new UnsupportedOperationException(\n+                SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),\n+                \"property-not-recognized\", new Object [] {SECURITY_MANAGER}), e);\n+            }\n+\n@@ -425,7 +426,7 @@\n-                try {\n-                    super.setProperty(XML_SECURITY_PROPERTY_MANAGER, fSecurityPropertyMgr);\n-                } catch (SAXException e) {\n-                    throw new UnsupportedOperationException(\n-                    SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),\n-                    \"property-not-recognized\", new Object [] {SECURITY_MANAGER}), e);\n-                }\n+            }\n+            try {\n+                super.setProperty(XML_SECURITY_PROPERTY_MANAGER, fSecurityPropertyMgr);\n+            } catch (SAXException e) {\n+                throw new UnsupportedOperationException(\n+                SAXMessageFormatter.formatMessage(fConfiguration.getLocale(),\n+                \"property-not-recognized\", new Object [] {XML_SECURITY_PROPERTY_MANAGER}), e);\n@@ -565,0 +566,5 @@\n+            if (SECURITY_MANAGER.equals(name)) {\n+                fSecurityManager = XMLSecurityManager.convert(value, fSecurityManager);\n+                super.setProperty(name, value);\n+            }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/SAXParserImpl.java","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -43,0 +42,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -72,0 +72,1 @@\n+                            (XMLSecurityManager)fComponentManager.getProperty(Constants.SECURITY_MANAGER),\n@@ -74,14 +75,0 @@\n-                    XMLSecurityManager securityManager =\n-                            (XMLSecurityManager)fComponentManager.getProperty(Constants.SECURITY_MANAGER);\n-                    if (securityManager != null) {\n-                        for (XMLSecurityManager.Limit limit : XMLSecurityManager.Limit.values()) {\n-                            if (securityManager.isSet(limit.ordinal())){\n-                                tf.setAttribute(limit.apiProperty(),\n-                                        securityManager.getLimitValueAsString(limit));\n-                            }\n-                        }\n-                        if (securityManager.printEntityCountInfo()) {\n-                            tf.setAttribute(JdkConstants.JDK_DEBUG_LIMIT, \"yes\");\n-                        }\n-                    }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/validation\/StAXValidatorHelper.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -34,1 +34,0 @@\n-import javax.xml.catalog.CatalogFeatures;\n@@ -38,1 +37,0 @@\n-import javax.xml.transform.TransformerFactory;\n@@ -45,1 +43,0 @@\n-import jdk.xml.internal.JdkXmlFeatures;\n@@ -55,1 +52,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n@@ -144,0 +141,1 @@\n+                            (XMLSecurityManager)fComponentManager.getProperty(Constants.SECURITY_MANAGER),\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/validation\/StreamValidatorHelper.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl;\n@@ -39,1 +38,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -66,1 +64,0 @@\n-import javax.xml.parsers.SAXParserFactory;\n@@ -74,0 +71,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -98,1 +96,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n@@ -679,2 +677,6 @@\n-                    reader = JdkXmlUtils.getXMLReader(fComponentManager.getFeature(JdkConstants.OVERRIDE_PARSER),\n-                            fComponentManager.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING));\n+                    reader = JdkXmlUtils.getXMLReader(\n+                            (XMLSecurityManager)fComponentManager.getProperty(SECURITY_MANAGER),\n+                            fComponentManager.getFeature(JdkConstants.OVERRIDE_PARSER),\n+                            fComponentManager.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING),\n+                            fComponentManager.getFeature(XMLConstants.USE_CATALOG),\n+                            null);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/validation\/ValidatorHandlerImpl.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -59,0 +58,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -73,1 +73,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/validation\/XMLSchemaFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -53,1 +52,1 @@\n-import jdk.xml.internal.JdkXmlUtils;\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -61,1 +60,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/validation\/XMLSchemaValidatorComponentManager.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -53,0 +52,2 @@\n+import jdk.xml.internal.JdkProperty;\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -81,1 +82,1 @@\n- * @LastModified: Sep 2019\n+ * @LastModified: July 2023\n@@ -1672,5 +1673,5 @@\n-            \/\/\n-            \/\/ Default handling\n-            \/\/\n-\n-            fConfiguration.setFeature(featureId, state);\n+            \/\/ Handle security setting\n+            if (!securityManager.setLimit(featureId, JdkProperty.State.APIPROPERTY, state)) {\n+                \/\/fall back to the default configuration\n+                fConfiguration.setFeature(featureId, state);\n+            }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/AbstractSAXParser.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -45,0 +44,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -63,1 +63,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n@@ -453,3 +453,4 @@\n-            \/\/\n-            \/\/ Default handling\n-            \/\/\n+            if (!securityManager.setLimit(featureId, JdkProperty.State.APIPROPERTY, state)) {\n+                \/\/fall back to the default configuration\n+                fConfiguration.setFeature(featureId, state);\n+            }\n@@ -457,1 +458,0 @@\n-            fConfiguration.setFeature(featureId, state);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/DOMParser.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -31,0 +30,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -42,1 +42,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/SAXParser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +27,1 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -47,1 +46,1 @@\n- *\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/SecurityConfiguration.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -32,1 +31,1 @@\n-\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -52,1 +51,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/XMLParser.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.org.apache.xerces.internal.utils;\n-\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager.Limit;\n-import java.util.Formatter;\n-import java.util.HashMap;\n-import java.util.Map;\n-import jdk.xml.internal.JdkConstants;\n-\n-\/**\n- * A helper for analyzing entity expansion limits\n- *\n- * @author Joe Wang Oracle Corp.\n- *\n- *\/\n-public final class XMLLimitAnalyzer {\n-\n-    \/**\n-     * Map old property names with the new ones\n-     *\/\n-    public static enum NameMap {\n-        ENTITY_EXPANSION_LIMIT(JdkConstants.SP_ENTITY_EXPANSION_LIMIT, JdkConstants.ENTITY_EXPANSION_LIMIT),\n-        MAX_OCCUR_NODE_LIMIT(JdkConstants.SP_MAX_OCCUR_LIMIT, JdkConstants.MAX_OCCUR_LIMIT),\n-        ELEMENT_ATTRIBUTE_LIMIT(JdkConstants.SP_ELEMENT_ATTRIBUTE_LIMIT, JdkConstants.ELEMENT_ATTRIBUTE_LIMIT);\n-\n-        final String newName;\n-        final String oldName;\n-\n-        NameMap(String newName, String oldName) {\n-            this.newName = newName;\n-            this.oldName = oldName;\n-        }\n-\n-        String getOldName(String newName) {\n-            if (newName.equals(this.newName)) {\n-                return oldName;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Max value accumulated for each property\n-     *\/\n-    private final int[] values;\n-    \/**\n-     * Names of the entities corresponding to their max values\n-     *\/\n-    private final String[] names;\n-    \/**\n-     * Total value of accumulated entities\n-     *\/\n-    private final int[] totalValue;\n-\n-    \/**\n-     * Maintain values of the top 10 elements in the process of parsing\n-     *\/\n-    private final Map<String, Integer>[] caches;\n-\n-    private String entityStart, entityEnd;\n-    \/**\n-     * Default constructor. Establishes default values for known security\n-     * vulnerabilities.\n-     *\/\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    public XMLLimitAnalyzer() {\n-        values = new int[Limit.values().length];\n-        totalValue = new int[Limit.values().length];\n-        names = new String[Limit.values().length];\n-        caches = new Map[Limit.values().length];\n-    }\n-\n-    \/**\n-     * Add the value to the current max count for the specified property\n-     * To find the max value of all entities, set no limit\n-     *\n-     * @param limit the type of the property\n-     * @param entityName the name of the entity\n-     * @param value the value of the entity\n-     *\/\n-    public void addValue(Limit limit, String entityName, int value) {\n-        addValue(limit.ordinal(), entityName, value);\n-    }\n-\n-    \/**\n-     * Add the value to the current count by the index of the property\n-     * @param index the index of the property\n-     * @param entityName the name of the entity\n-     * @param value the value of the entity\n-     *\/\n-    public void addValue(int index, String entityName, int value) {\n-        if (index == Limit.ENTITY_EXPANSION_LIMIT.ordinal() ||\n-                index == Limit.MAX_OCCUR_NODE_LIMIT.ordinal() ||\n-                index == Limit.ELEMENT_ATTRIBUTE_LIMIT.ordinal() ||\n-                index == Limit.TOTAL_ENTITY_SIZE_LIMIT.ordinal() ||\n-                index == Limit.ENTITY_REPLACEMENT_LIMIT.ordinal()\n-                ) {\n-            totalValue[index] += value;\n-            return;\n-        }\n-        if (index == Limit.MAX_ELEMENT_DEPTH_LIMIT.ordinal() ||\n-                index == Limit.MAX_NAME_LIMIT.ordinal()) {\n-            values[index] = value;\n-            totalValue[index] = value;\n-            return;\n-        }\n-\n-        Map<String, Integer> cache;\n-        if (caches[index] == null) {\n-            cache = new HashMap<>(10);\n-            caches[index] = cache;\n-        } else {\n-            cache = caches[index];\n-        }\n-\n-        int accumulatedValue = value;\n-        if (cache.containsKey(entityName)) {\n-            accumulatedValue += cache.get(entityName);\n-            cache.put(entityName, accumulatedValue);\n-        } else {\n-            cache.put(entityName, value);\n-        }\n-\n-        if (accumulatedValue > values[index]) {\n-            values[index] = accumulatedValue;\n-            names[index] = entityName;\n-        }\n-\n-\n-        if (index == Limit.GENERAL_ENTITY_SIZE_LIMIT.ordinal() ||\n-                index == Limit.PARAMETER_ENTITY_SIZE_LIMIT.ordinal()) {\n-            totalValue[Limit.TOTAL_ENTITY_SIZE_LIMIT.ordinal()] += value;\n-        }\n-    }\n-\n-    \/**\n-     * Return the value of the current max count for the specified property\n-     *\n-     * @param limit the property\n-     * @return the value of the property\n-     *\/\n-    public int getValue(Limit limit) {\n-        return getValue(limit.ordinal());\n-    }\n-\n-    public int getValue(int index) {\n-        if (index == Limit.ENTITY_REPLACEMENT_LIMIT.ordinal()) {\n-            return totalValue[index];\n-        }\n-        return values[index];\n-    }\n-    \/**\n-     * Return the total value accumulated so far\n-     *\n-     * @param limit the property\n-     * @return the accumulated value of the property\n-     *\/\n-    public int getTotalValue(Limit limit) {\n-        return totalValue[limit.ordinal()];\n-    }\n-\n-    public int getTotalValue(int index) {\n-        return totalValue[index];\n-    }\n-    \/**\n-     * Return the current max value (count or length) by the index of a property\n-     * @param index the index of a property\n-     * @return count of a property\n-     *\/\n-    public int getValueByIndex(int index) {\n-        return values[index];\n-    }\n-\n-    public void startEntity(String name) {\n-        entityStart = name;\n-    }\n-\n-    public boolean isTracking(String name) {\n-        if (entityStart == null) {\n-            return false;\n-        }\n-        return entityStart.equals(name);\n-    }\n-    \/**\n-     * Stop tracking the entity\n-     * @param limit the limit property\n-     * @param name the name of an entity\n-     *\/\n-    public void endEntity(Limit limit, String name) {\n-        entityStart = \"\";\n-        Map<String, Integer> cache = caches[limit.ordinal()];\n-        if (cache != null) {\n-            cache.remove(name);\n-        }\n-    }\n-\n-    \/**\n-     * Resets the current value of the specified limit.\n-     * @param limit The limit to be reset.\n-     *\/\n-    public void reset(Limit limit) {\n-        if (limit.ordinal() == Limit.TOTAL_ENTITY_SIZE_LIMIT.ordinal()) {\n-            totalValue[limit.ordinal()] = 0;\n-        } else if (limit.ordinal() == Limit.GENERAL_ENTITY_SIZE_LIMIT.ordinal()) {\n-            names[limit.ordinal()] = null;\n-            values[limit.ordinal()] = 0;\n-            caches[limit.ordinal()] = null;\n-            totalValue[limit.ordinal()] = 0;\n-        }\n-    }\n-\n-    public void debugPrint(XMLSecurityManager securityManager) {\n-        Formatter formatter = new Formatter();\n-        System.out.println(formatter.format(\"%30s %15s %15s %15s %30s\",\n-                \"Property\",\"Limit\",\"Total size\",\"Size\",\"Entity Name\"));\n-\n-        for (Limit limit : Limit.values()) {\n-            formatter = new Formatter();\n-            System.out.println(formatter.format(\"%30s %15d %15d %15d %30s\",\n-                    limit.name(),\n-                    securityManager.getLimit(limit),\n-                    totalValue[limit.ordinal()],\n-                    values[limit.ordinal()],\n-                    names[limit.ordinal()]));\n-        }\n-    }\n-}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/utils\/XMLLimitAnalyzer.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -1,638 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.org.apache.xerces.internal.utils;\n-\n-import com.sun.org.apache.xerces.internal.util.SecurityManager;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import jdk.xml.internal.JdkConstants;\n-import jdk.xml.internal.JdkProperty.State;\n-import jdk.xml.internal.JdkProperty.ImplPropMap;\n-import jdk.xml.internal.SecuritySupport;\n-import org.xml.sax.SAXException;\n-\n-\/**\n- * This class manages standard and implementation-specific limitations.\n- *\n- *\/\n-public final class XMLSecurityManager {\n-\n-    \/**\n-     * Limits managed by the security manager\n-     *\/\n-    @SuppressWarnings(\"deprecation\")\n-    public static enum Limit {\n-\n-        ENTITY_EXPANSION_LIMIT(\"EntityExpansionLimit\",\n-                JdkConstants.JDK_ENTITY_EXPANSION_LIMIT, JdkConstants.SP_ENTITY_EXPANSION_LIMIT, 0, 64000),\n-        MAX_OCCUR_NODE_LIMIT(\"MaxOccurLimit\",\n-                JdkConstants.JDK_MAX_OCCUR_LIMIT, JdkConstants.SP_MAX_OCCUR_LIMIT, 0, 5000),\n-        ELEMENT_ATTRIBUTE_LIMIT(\"ElementAttributeLimit\",\n-                JdkConstants.JDK_ELEMENT_ATTRIBUTE_LIMIT, JdkConstants.SP_ELEMENT_ATTRIBUTE_LIMIT, 0, 10000),\n-        TOTAL_ENTITY_SIZE_LIMIT(\"TotalEntitySizeLimit\",\n-                JdkConstants.JDK_TOTAL_ENTITY_SIZE_LIMIT, JdkConstants.SP_TOTAL_ENTITY_SIZE_LIMIT, 0, 50000000),\n-        GENERAL_ENTITY_SIZE_LIMIT(\"MaxEntitySizeLimit\",\n-                JdkConstants.JDK_GENERAL_ENTITY_SIZE_LIMIT, JdkConstants.SP_GENERAL_ENTITY_SIZE_LIMIT, 0, 0),\n-        PARAMETER_ENTITY_SIZE_LIMIT(\"MaxEntitySizeLimit\",\n-                JdkConstants.JDK_PARAMETER_ENTITY_SIZE_LIMIT, JdkConstants.SP_PARAMETER_ENTITY_SIZE_LIMIT, 0, 1000000),\n-        MAX_ELEMENT_DEPTH_LIMIT(\"MaxElementDepthLimit\",\n-                JdkConstants.JDK_MAX_ELEMENT_DEPTH, JdkConstants.SP_MAX_ELEMENT_DEPTH, 0, 0),\n-        MAX_NAME_LIMIT(\"MaxXMLNameLimit\",\n-                JdkConstants.JDK_XML_NAME_LIMIT, JdkConstants.SP_XML_NAME_LIMIT, 1000, 1000),\n-        ENTITY_REPLACEMENT_LIMIT(\"EntityReplacementLimit\",\n-                JdkConstants.JDK_ENTITY_REPLACEMENT_LIMIT, JdkConstants.SP_ENTITY_REPLACEMENT_LIMIT, 0, 3000000);\n-\n-        final String key;\n-        final String apiProperty;\n-        final String systemProperty;\n-        final int defaultValue;\n-        final int secureValue;\n-\n-        Limit(String key, String apiProperty, String systemProperty, int value, int secureValue) {\n-            this.key = key;\n-            this.apiProperty = apiProperty;\n-            this.systemProperty = systemProperty;\n-            this.defaultValue = value;\n-            this.secureValue = secureValue;\n-        }\n-\n-        \/**\n-         * Checks whether the specified name is a limit. Checks both the\n-         * property and System Property which is now the new property name.\n-         *\n-         * @param name the specified name\n-         * @return true if there is a match, false otherwise\n-         *\/\n-        public boolean is(String name) {\n-            \/\/ current spec: new property name == systemProperty\n-            return (systemProperty != null && systemProperty.equals(name)) ||\n-                   \/\/ current spec: apiProperty is legacy\n-                   (apiProperty.equals(name));\n-        }\n-\n-        \/**\n-         * Returns the state of a property name. By the specification as of JDK 17,\n-         * the \"jdk.xml.\" prefixed System property name is also the current API\n-         * name. The URI-based qName is legacy.\n-         *\n-         * @param name the property name\n-         * @return the state of the property name, null if no match\n-         *\/\n-        public State getState(String name) {\n-            if (systemProperty != null && systemProperty.equals(name)) {\n-                return State.APIPROPERTY;\n-            } else if (apiProperty.equals(name)) {\n-                \/\/the URI-style qName is legacy\n-                return State.LEGACY_APIPROPERTY;\n-            }\n-            return null;\n-        }\n-\n-        public String key() {\n-            return key;\n-        }\n-\n-        public String apiProperty() {\n-            return apiProperty;\n-        }\n-\n-        public String systemProperty() {\n-            return systemProperty;\n-        }\n-\n-        public int defaultValue() {\n-            return defaultValue;\n-        }\n-\n-        int secureValue() {\n-            return secureValue;\n-        }\n-    }\n-\n-    \/**\n-     * Map old property names with the new ones\n-     *\/\n-    public static enum NameMap {\n-\n-        ENTITY_EXPANSION_LIMIT(JdkConstants.SP_ENTITY_EXPANSION_LIMIT, JdkConstants.ENTITY_EXPANSION_LIMIT),\n-        MAX_OCCUR_NODE_LIMIT(JdkConstants.SP_MAX_OCCUR_LIMIT, JdkConstants.MAX_OCCUR_LIMIT),\n-        ELEMENT_ATTRIBUTE_LIMIT(JdkConstants.SP_ELEMENT_ATTRIBUTE_LIMIT, JdkConstants.ELEMENT_ATTRIBUTE_LIMIT);\n-        final String newName;\n-        final String oldName;\n-\n-        NameMap(String newName, String oldName) {\n-            this.newName = newName;\n-            this.oldName = oldName;\n-        }\n-\n-        String getOldName(String newName) {\n-            if (newName.equals(this.newName)) {\n-                return oldName;\n-            }\n-            return null;\n-        }\n-    }\n-    private static final int NO_LIMIT = 0;\n-    \/**\n-     * Values of the properties\n-     *\/\n-    private final int[] values;\n-    \/**\n-     * States of the settings for each property\n-     *\/\n-    private State[] states;\n-    \/**\n-     * Flag indicating if secure processing is set\n-     *\/\n-    boolean secureProcessing;\n-\n-    \/**\n-     * States that determine if properties are set explicitly\n-     *\/\n-    private boolean[] isSet;\n-\n-\n-    \/**\n-     * Index of the special entityCountInfo property\n-     *\/\n-    private final int indexEntityCountInfo = 10000;\n-    private String printEntityCountInfo = \"\";\n-\n-    \/**\n-     * Default constructor. Establishes default values for known security\n-     * vulnerabilities.\n-     *\/\n-    public XMLSecurityManager() {\n-        this(false);\n-    }\n-\n-    \/**\n-     * Instantiate Security Manager in accordance with the status of\n-     * secure processing\n-     * @param secureProcessing\n-     *\/\n-    public XMLSecurityManager(boolean secureProcessing) {\n-        values = new int[Limit.values().length];\n-        states = new State[Limit.values().length];\n-        isSet = new boolean[Limit.values().length];\n-        this.secureProcessing = secureProcessing;\n-        for (Limit limit : Limit.values()) {\n-            if (secureProcessing) {\n-                values[limit.ordinal()] = limit.secureValue;\n-                states[limit.ordinal()] = State.FSP;\n-            } else {\n-                values[limit.ordinal()] = limit.defaultValue();\n-                states[limit.ordinal()] = State.DEFAULT;\n-            }\n-        }\n-        \/\/read system properties or jaxp.properties\n-        readSystemProperties();\n-    }\n-\n-    \/**\n-     * Setting FEATURE_SECURE_PROCESSING explicitly\n-     *\/\n-    public void setSecureProcessing(boolean secure) {\n-        secureProcessing = secure;\n-        for (Limit limit : Limit.values()) {\n-            if (secure) {\n-                setLimit(limit.ordinal(), State.FSP, limit.secureValue());\n-            } else {\n-                setLimit(limit.ordinal(), State.FSP, limit.defaultValue());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Return the state of secure processing\n-     * @return the state of secure processing\n-     *\/\n-    public boolean isSecureProcessing() {\n-        return secureProcessing;\n-    }\n-\n-    \/**\n-     * Finds a limit's new name with the given property name.\n-     * @param propertyName the property name specified\n-     * @return the limit's new name if found, null otherwise\n-     *\/\n-    public String find(String propertyName) {\n-        for (Limit limit : Limit.values()) {\n-            if (limit.is(propertyName)) {\n-                \/\/ current spec: new property name == systemProperty\n-                return limit.systemProperty();\n-            }\n-        }\n-        \/\/ENTITYCOUNT's new name is qName\n-        if (ImplPropMap.ENTITYCOUNT.is(propertyName)) {\n-            return ImplPropMap.ENTITYCOUNT.qName();\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Set limit by property name and state\n-     * @param propertyName property name\n-     * @param state the state of the property\n-     * @param value the value of the property\n-     * @return true if the property is managed by the security manager; false\n-     *              if otherwise.\n-     *\/\n-    public boolean setLimit(String propertyName, State state, Object value) {\n-        int index = getIndex(propertyName);\n-        if (index > -1) {\n-            State pState = state;\n-            if (index != indexEntityCountInfo && state == State.APIPROPERTY) {\n-                pState = (Limit.values()[index]).getState(propertyName);\n-            }\n-            setLimit(index, pState, value);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Set the value for a specific limit.\n-     *\n-     * @param limit the limit\n-     * @param state the state of the property\n-     * @param value the value of the property\n-     *\/\n-    public void setLimit(Limit limit, State state, int value) {\n-        setLimit(limit.ordinal(), state, value);\n-    }\n-\n-    \/**\n-     * Set the value of a property by its index\n-     *\n-     * @param index the index of the property\n-     * @param state the state of the property\n-     * @param value the value of the property\n-     *\/\n-    public void setLimit(int index, State state, Object value) {\n-        if (index == indexEntityCountInfo) {\n-            printEntityCountInfo = (String)value;\n-        } else {\n-            int temp;\n-            if (value instanceof Integer) {\n-                temp = (Integer)value;\n-            } else {\n-                temp = Integer.parseInt((String) value);\n-                if (temp < 0) {\n-                    temp = 0;\n-                }\n-            }\n-            setLimit(index, state, temp);\n-        }\n-    }\n-\n-    \/**\n-     * Set the value of a property by its index\n-     *\n-     * @param index the index of the property\n-     * @param state the state of the property\n-     * @param value the value of the property\n-     *\/\n-    public void setLimit(int index, State state, int value) {\n-        if (index == indexEntityCountInfo) {\n-            \/\/if it's explicitly set, it's treated as yes no matter the value\n-            printEntityCountInfo = JdkConstants.JDK_YES;\n-        } else {\n-            \/\/only update if it shall override\n-            if (state.compareTo(states[index]) >= 0) {\n-                values[index] = value;\n-                states[index] = state;\n-                isSet[index] = true;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Return the value of the specified property\n-     *\n-     * @param propertyName the property name\n-     * @return the value of the property as a string. If a property is managed\n-     * by this manager, its value shall not be null.\n-     *\/\n-    public String getLimitAsString(String propertyName) {\n-        int index = getIndex(propertyName);\n-        if (index > -1) {\n-            return getLimitValueByIndex(index);\n-        }\n-\n-        return null;\n-    }\n-    \/**\n-     * Return the value of the specified property\n-     *\n-     * @param limit the property\n-     * @return the value of the property\n-     *\/\n-    public int getLimit(Limit limit) {\n-        return values[limit.ordinal()];\n-    }\n-\n-    \/**\n-     * Return the value of a property by its ordinal\n-     *\n-     * @param limit the property\n-     * @return value of a property\n-     *\/\n-    public String getLimitValueAsString(Limit limit) {\n-        return Integer.toString(values[limit.ordinal()]);\n-    }\n-\n-    \/**\n-     * Return the value of a property by its ordinal\n-     *\n-     * @param index the index of a property\n-     * @return limit of a property as a string\n-     *\/\n-    public String getLimitValueByIndex(int index) {\n-        if (index == indexEntityCountInfo) {\n-            return printEntityCountInfo;\n-        }\n-\n-        return Integer.toString(values[index]);\n-    }\n-\n-    \/**\n-     * Return the state of the limit property\n-     *\n-     * @param limit the limit\n-     * @return the state of the limit property\n-     *\/\n-    public State getState(Limit limit) {\n-        return states[limit.ordinal()];\n-    }\n-\n-    \/**\n-     * Return the state of the limit property\n-     *\n-     * @param limit the limit\n-     * @return the state of the limit property\n-     *\/\n-    public String getStateLiteral(Limit limit) {\n-        return states[limit.ordinal()].literal();\n-    }\n-\n-    \/**\n-     * Get the index by property name\n-     *\n-     * @param propertyName property name\n-     * @return the index of the property if found; return -1 if not\n-     *\/\n-    public int getIndex(String propertyName) {\n-        for (Limit limit : Limit.values()) {\n-            \/\/ see JDK-8265248, accept both the URL and jdk.xml as prefix\n-            if (limit.is(propertyName)) {\n-                \/\/internally, ordinal is used as index\n-                return limit.ordinal();\n-            }\n-        }\n-        \/\/special property to return entity count info\n-        if (ImplPropMap.ENTITYCOUNT.is(propertyName)) {\n-            return indexEntityCountInfo;\n-        }\n-        return -1;\n-    }\n-\n-    \/**\n-     * Check if there's no limit defined by the Security Manager\n-     * @param limit\n-     * @return\n-     *\/\n-    public boolean isNoLimit(int limit) {\n-        return limit==NO_LIMIT;\n-    }\n-    \/**\n-     * Check if the size (length or count) of the specified limit property is\n-     * over the limit\n-     *\n-     * @param limit the type of the limit property\n-     * @param entityName the name of the entity\n-     * @param size the size (count or length) of the entity\n-     * @return true if the size is over the limit, false otherwise\n-     *\/\n-    public boolean isOverLimit(Limit limit, String entityName, int size,\n-            XMLLimitAnalyzer limitAnalyzer) {\n-        return isOverLimit(limit.ordinal(), entityName, size, limitAnalyzer);\n-    }\n-\n-    \/**\n-     * Check if the value (length or count) of the specified limit property is\n-     * over the limit\n-     *\n-     * @param index the index of the limit property\n-     * @param entityName the name of the entity\n-     * @param size the size (count or length) of the entity\n-     * @return true if the size is over the limit, false otherwise\n-     *\/\n-    public boolean isOverLimit(int index, String entityName, int size,\n-            XMLLimitAnalyzer limitAnalyzer) {\n-        if (values[index] == NO_LIMIT) {\n-            return false;\n-        }\n-        if (size > values[index]) {\n-            limitAnalyzer.addValue(index, entityName, size);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Check against cumulated value\n-     *\n-     * @param limit the type of the limit property\n-     * @param size the size (count or length) of the entity\n-     * @return true if the size is over the limit, false otherwise\n-     *\/\n-    public boolean isOverLimit(Limit limit, XMLLimitAnalyzer limitAnalyzer) {\n-        return isOverLimit(limit.ordinal(), limitAnalyzer);\n-    }\n-\n-    public boolean isOverLimit(int index, XMLLimitAnalyzer limitAnalyzer) {\n-        if (values[index] == NO_LIMIT) {\n-            return false;\n-        }\n-\n-        if (index == Limit.ELEMENT_ATTRIBUTE_LIMIT.ordinal() ||\n-                index == Limit.ENTITY_EXPANSION_LIMIT.ordinal() ||\n-                index == Limit.TOTAL_ENTITY_SIZE_LIMIT.ordinal() ||\n-                index == Limit.ENTITY_REPLACEMENT_LIMIT.ordinal() ||\n-                index == Limit.MAX_ELEMENT_DEPTH_LIMIT.ordinal() ||\n-                index == Limit.MAX_NAME_LIMIT.ordinal()\n-                ) {\n-            return (limitAnalyzer.getTotalValue(index) > values[index]);\n-        } else {\n-            return (limitAnalyzer.getValue(index) > values[index]);\n-        }\n-    }\n-\n-    public void debugPrint(XMLLimitAnalyzer limitAnalyzer) {\n-        if (printEntityCountInfo.equals(JdkConstants.JDK_YES)) {\n-            limitAnalyzer.debugPrint(this);\n-        }\n-    }\n-\n-\n-    \/**\n-     * Indicate if a property is set explicitly\n-     * @param index\n-     * @return\n-     *\/\n-    public boolean isSet(int index) {\n-        return isSet[index];\n-    }\n-\n-    public boolean printEntityCountInfo() {\n-        return printEntityCountInfo.equals(JdkConstants.JDK_YES);\n-    }\n-\n-    \/**\n-     * Read system properties, or the configuration file\n-     *\/\n-    private void readSystemProperties() {\n-        for (Limit limit : Limit.values()) {\n-            \/\/ attempts to read both the current and old system propery\n-            if (!getSystemProperty(limit, limit.systemProperty())\n-                    && (!getOldSystemProperty(limit))) {\n-                \/\/if system property is not found, try the config file\n-                getPropertyConfig(limit, limit.systemProperty());\n-            }\n-        }\n-    }\n-\n-    \/\/ Array list to store printed warnings for each SAX parser used\n-    private static final CopyOnWriteArrayList<String> printedWarnings = new CopyOnWriteArrayList<>();\n-\n-    \/**\n-     * Prints out warnings if a parser does not support the specified feature\/property.\n-     *\n-     * @param parserClassName the name of the parser class\n-     * @param propertyName the property name\n-     * @param exception the exception thrown by the parser\n-     *\/\n-    public static void printWarning(String parserClassName, String propertyName, SAXException exception) {\n-        String key = parserClassName+\":\"+propertyName;\n-        if (printedWarnings.addIfAbsent(key)) {\n-            System.err.println( \"Warning: \"+parserClassName+\": \"+exception.getMessage());\n-        }\n-    }\n-\n-    \/**\n-     * Reads a system property, sets value and state if found.\n-     *\n-     * @param limit the limit property\n-     * @param sysPropertyName the name of system property\n-     *\/\n-    private boolean getSystemProperty(Limit limit, String sysPropertyName) {\n-        try {\n-            String value = SecuritySupport.getSystemProperty(sysPropertyName);\n-            if (value != null && !value.equals(\"\")) {\n-                values[limit.ordinal()] = Integer.parseInt(value);\n-                states[limit.ordinal()] = State.SYSTEMPROPERTY;\n-                return true;\n-            }\n-        } catch (NumberFormatException e) {\n-            \/\/invalid setting\n-            throw new NumberFormatException(\"Invalid setting for system property: \" + limit.systemProperty());\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Reads the legacy system property.\n-     * @param limit a limit object\n-     * @return true if found, false otherwise\n-     *\/\n-    private boolean getOldSystemProperty(Limit limit) {\n-        boolean found = false;\n-        for (NameMap nameMap : NameMap.values()) {\n-            String oldName = nameMap.getOldName(limit.systemProperty());\n-            if (oldName != null) {\n-                if (getSystemProperty(limit, oldName)) {\n-                    found = true;\n-                    break;\n-                }\n-            }\n-        }\n-        return found;\n-    }\n-\n-    \/**\n-     * Reads a property from a configuration file, if any.\n-     *\n-     * @param limit the limit property\n-     * @param sysPropertyName the name of system property\n-     * @return\n-     *\/\n-    private boolean getPropertyConfig(Limit limit, String sysPropertyName) {\n-        try {\n-            String value = SecuritySupport.readConfig(sysPropertyName);\n-            if (value != null && !value.equals(\"\")) {\n-                values[limit.ordinal()] = Integer.parseInt(value);\n-                states[limit.ordinal()] = State.JAXPDOTPROPERTIES;\n-                return true;\n-            }\n-        } catch (NumberFormatException e) {\n-            \/\/invalid setting\n-            throw new NumberFormatException(\"Invalid setting for system property: \" + limit.systemProperty());\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Convert a value set through setProperty to XMLSecurityManager.\n-     * If the value is an instance of XMLSecurityManager, use it to override the default;\n-     * If the value is an old SecurityManager, convert to the new XMLSecurityManager.\n-     *\n-     * @param value user specified security manager\n-     * @param securityManager an instance of XMLSecurityManager\n-     * @return an instance of the new security manager XMLSecurityManager\n-     *\/\n-    public static XMLSecurityManager convert(Object value, XMLSecurityManager securityManager) {\n-        if (value == null) {\n-            if (securityManager == null) {\n-                securityManager = new XMLSecurityManager(true);\n-            }\n-            return securityManager;\n-        }\n-        if (value instanceof XMLSecurityManager) {\n-            return (XMLSecurityManager)value;\n-        } else {\n-            if (securityManager == null) {\n-                securityManager = new XMLSecurityManager(true);\n-            }\n-            if (value instanceof SecurityManager) {\n-                SecurityManager origSM = (SecurityManager)value;\n-                securityManager.setLimit(Limit.MAX_OCCUR_NODE_LIMIT, State.APIPROPERTY, origSM.getMaxOccurNodeLimit());\n-                securityManager.setLimit(Limit.ENTITY_EXPANSION_LIMIT, State.APIPROPERTY, origSM.getEntityExpansionLimit());\n-                securityManager.setLimit(Limit.ELEMENT_ATTRIBUTE_LIMIT, State.APIPROPERTY, origSM.getElementAttrLimit());\n-            }\n-            return securityManager;\n-        }\n-    }\n-}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/utils\/XMLSecurityManager.java","additions":0,"deletions":638,"binary":false,"changes":638,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;\n@@ -83,0 +82,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -131,1 +131,1 @@\n- * @LastModified: July 2022\n+ * @LastModified: July 2023\n@@ -1734,0 +1734,5 @@\n+                fChildConfig.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), fCatalogFile);\n+                fChildConfig.setProperty(CatalogFeatures.Feature.DEFER.getPropertyName(), fDefer);\n+                fChildConfig.setProperty(CatalogFeatures.Feature.PREFER.getPropertyName(), fPrefer);\n+                fChildConfig.setProperty(CatalogFeatures.Feature.RESOLVE.getPropertyName(), fResolve);\n+                fChildConfig.setFeature(XMLConstants.USE_CATALOG, fUseCatalog);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/xinclude\/XIncludeHandler.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +23,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLLimitAnalyzer;\n-import java.io.IOException;\n@@ -27,0 +24,2 @@\n+import java.io.IOException;\n+import jdk.xml.internal.XMLLimitAnalyzer;\n@@ -42,0 +41,1 @@\n+ * @LastModified: July 2023\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/xni\/parser\/XMLDTDScanner.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @LastModified: Jan 2023\n+ * @LastModified: July 2023\n@@ -126,0 +126,2 @@\n+            JdkXmlUtils.setReaderProperty(reader, _xmlSecurityManager, _useCatalog,\n+                    _catalogFeatures);\n@@ -127,1 +129,2 @@\n-            reader = JdkXmlUtils.getXMLReader(m_overrideDefaultParser, _secureProcessing);\n+            reader = JdkXmlUtils.getXMLReader(_xmlSecurityManager, m_overrideDefaultParser,\n+                    _secureProcessing, _useCatalog, _catalogFeatures);\n@@ -144,36 +147,0 @@\n-        String lastProperty = \"\";\n-        try {\n-            if (_xmlSecurityManager != null) {\n-                for (XMLSecurityManager.Limit limit : XMLSecurityManager.Limit.values()) {\n-                    if (limit.isSupported(XMLSecurityManager.Processor.PARSER)) {\n-                        lastProperty = limit.apiProperty();\n-                        reader.setProperty(lastProperty,\n-                                _xmlSecurityManager.getLimitValueAsString(limit));\n-                    }\n-                }\n-                if (_xmlSecurityManager.printEntityCountInfo()) {\n-                    lastProperty = JdkConstants.JDK_DEBUG_LIMIT;\n-                    reader.setProperty(lastProperty, JdkConstants.JDK_YES);\n-                }\n-            }\n-        } catch (SAXException se) {\n-            XMLSecurityManager.printWarning(reader.getClass().getName(), lastProperty, se);\n-        }\n-\n-        boolean supportCatalog = true;\n-        try {\n-            reader.setFeature(JdkXmlUtils.USE_CATALOG, _useCatalog);\n-        }\n-        catch (SAXNotRecognizedException | SAXNotSupportedException e) {\n-            supportCatalog = false;\n-        }\n-\n-        if (supportCatalog && _useCatalog && _catalogFeatures != null) {\n-            try {\n-                for (CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {\n-                    reader.setProperty(f.getPropertyName(), _catalogFeatures.get(f));\n-                }\n-            } catch (SAXNotRecognizedException e) {\n-                \/\/shall not happen for internal settings\n-            }\n-        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/utils\/XMLReaderManager.java","additions":5,"deletions":38,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -290,1 +290,11 @@\n-    public static final String CONFIG_FILE = \"java.xml.config.file\";\n+    public static final String CONFIG_FILE_PROPNAME = \"java.xml.config.file\";\n+\n+    \/**\n+     * System Property for the DTD property\n+     *\/\n+    public static final String DTD_PROPNAME = \"jdk.xml.dtd.support\";\n+\n+    \/\/ DTD property values\n+    public static final int ALLOW = 0;\n+    public static final int IGNORE = 1;\n+    public static final int DENY = 2;\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkConstants.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,3 @@\n+    public static final boolean IS_WINDOWS = SecuritySupport.getSystemProperty(\"os.name\").contains(\"Windows\");\n+    public static final String JAVA_HOME = SecuritySupport.getSystemProperty(\"java.home\");\n+\n@@ -64,1 +67,3 @@\n-\n+    \/** Property identifier: security manager. *\/\n+    private static final String SECURITY_MANAGER =\n+        Constants.XERCES_PROPERTY_PREFIX + Constants.SECURITY_MANAGER_PROPERTY;\n@@ -76,1 +81,4 @@\n-\n+    \/\/values for the Resolve property\n+    public static final String RESOLVE_STRICT = \"strict\";\n+    public static final String RESOLVE_CONTINUE = \"continue\";\n+    public static final String RESOLVE_IGNORE = \"ignore\";\n@@ -165,1 +173,1 @@\n-            builder = builder.with(CatalogFeatures.Feature.FILES, file);\n+            builder = builder.with(Feature.FILES, file);\n@@ -168,1 +176,1 @@\n-            builder = builder.with(CatalogFeatures.Feature.PREFER, prefer);\n+            builder = builder.with(Feature.PREFER, prefer);\n@@ -171,1 +179,1 @@\n-            builder = builder.with(CatalogFeatures.Feature.DEFER, defer);\n+            builder = builder.with(Feature.DEFER, defer);\n@@ -174,1 +182,1 @@\n-            builder = builder.with(CatalogFeatures.Feature.RESOLVE, resolve);\n+            builder = builder.with(Feature.RESOLVE, resolve);\n@@ -180,0 +188,9 @@\n+    \/**\n+     * Checks whether the RESOLVE feature in the CatalogFeatures is continue.\n+     * @param cf the specified CatalogFeatures\n+     * @return true if the RESOLVE feature is\n+     *\/\n+    public static boolean isResolveContinue(CatalogFeatures cf) {\n+        return (cf == null || cf.get(Feature.RESOLVE).equals(RESOLVE_CONTINUE));\n+    }\n+\n@@ -240,0 +257,5 @@\n+     * Note: parameter useXMLReaderFactory was removed. The method instead checks\n+     * the SAX_DRIVER property for whether the XMLReader should be created using\n+     * XMLReaderFactory for compatibility.  (see JDK-6490921).\n+     *\n+     * @param sm the XMLSecurityManager\n@@ -244,3 +266,2 @@\n-     * @param useXMLReaderFactory a flag indicating when the XMLReader should be\n-     * created using XMLReaderFactory. True is a compatibility mode that honors\n-     * the property org.xml.sax.driver (see JDK-6490921).\n+     * @param useCatalog a flag indicating whether Catalog is enabled\n+     * @param catalogFeatures the CatalogFeatures\n@@ -249,2 +270,3 @@\n-    public static XMLReader getXMLReader(boolean overrideDefaultParser,\n-            boolean secureProcessing) {\n+    public static XMLReader getXMLReader(XMLSecurityManager sm,\n+            boolean overrideDefaultParser, boolean secureProcessing,\n+            boolean useCatalog, CatalogFeatures catalogFeatures) {\n@@ -275,5 +297,3 @@\n-            return reader;\n-        }\n-\n-        \/\/ use the system-default\n-        saxFactory = defaultSAXFactory;\n+        } else {\n+            \/\/ use the system-default\n+            saxFactory = defaultSAXFactory;\n@@ -281,1 +301,1 @@\n-        try {\n+            try {\n@@ -283,2 +303,3 @@\n-        } catch (ParserConfigurationException | SAXException ex) {\n-            \/\/ shall not happen with the system-default reader\n+            } catch (ParserConfigurationException | SAXException ex) {\n+                \/\/ shall not happen with the system-default reader\n+            }\n@@ -286,0 +307,3 @@\n+\n+        setReaderProperty(reader, sm, useCatalog, catalogFeatures);\n+\n@@ -289,0 +313,41 @@\n+    \/**\n+     * Sets properties on the reader, including XMLSecurityManager and Catalog\n+     * features.\n+     *\n+     * @param reader the XMLReader\n+     * @param sm the XMLSecurityManager\n+     * @param useCatalog the USE_CATALOG property\n+     * @param catalogFeatures the Catalog features\n+     *\/\n+    public static void setReaderProperty(XMLReader reader, XMLSecurityManager sm,\n+            boolean useCatalog, CatalogFeatures catalogFeatures) {\n+        if (reader != null) {\n+            try {\n+                reader.setProperty(SECURITY_MANAGER, sm);\n+            } catch (SAXException ex) {\n+                \/\/ internal setting, shouldn't happen\n+            }\n+\n+            boolean supportCatalog = true;\n+            try {\n+                reader.setFeature(JdkXmlUtils.USE_CATALOG, useCatalog);\n+            }\n+            catch (SAXException e) {\n+                supportCatalog = false;\n+            }\n+\n+            if (catalogFeatures != null) {\n+                CatalogFeatures cf = catalogFeatures;\n+                if (supportCatalog && useCatalog) {\n+                    try {\n+                        for (CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {\n+                            reader.setProperty(f.getPropertyName(), cf.get(f));\n+                        }\n+                    } catch (SAXException e) {\n+                        \/\/shall not happen for internal settings\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -356,1 +421,9 @@\n-    public static SAXTransformerFactory getSAXTransformFactory(boolean overrideDefaultParser) {\n+    \/**\n+     * Returns an instance of SAXTransformerFactory with the current XMLSecurityManager\n+     * and the setting of the OVERRIDE_PARSER property.\n+     * @param sm the XMLSecurityManager\n+     * @param overrideDefaultParser the setting of the OVERRIDE_PARSER property\n+     * @return an instance of SAXTransformerFactory\n+     *\/\n+    public static SAXTransformerFactory getSAXTransformFactory(XMLSecurityManager sm,\n+            boolean overrideDefaultParser) {\n@@ -360,0 +433,11 @@\n+        if (sm != null) {\n+            for (XMLSecurityManager.Limit limit : XMLSecurityManager.Limit.values()) {\n+                if (sm.isSet(limit)){\n+                    tf.setAttribute(limit.apiProperty(), sm.getLimitValueAsString(limit));\n+                }\n+            }\n+            if (sm.printEntityCountInfo()) {\n+                tf.setAttribute(JdkConstants.JDK_DEBUG_LIMIT, \"yes\");\n+            }\n+        }\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkXmlUtils.java","additions":105,"deletions":21,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-                    String configFile = SecuritySupport.getSystemProperty(JdkConstants.CONFIG_FILE);\n+                    String configFile = SecuritySupport.getSystemProperty(JdkConstants.CONFIG_FILE_PROPNAME);\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/SecuritySupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n@@ -30,0 +34,2 @@\n+import java.util.stream.Collectors;\n+import javax.xml.stream.XMLInputFactory;\n@@ -40,0 +46,33 @@\n+    public static final String DTD_KEY = JdkConstants.DTD_PROPNAME;\n+\n+    \/\/ Xerces Feature\n+    public static final String DISALLOW_DTD = \"http:\/\/apache.org\/xml\/features\/disallow-doctype-decl\";\n+    public static final String LOAD_EXTERNAL_DTD = \"http:\/\/apache.org\/xml\/features\/nonvalidating\/load-external-dtd\";\n+\n+    \/\/ StAX feature\n+    public static final String ZEPHYR_PROPERTY_PREFIX = \"http:\/\/java.sun.com\/xml\/stream\/properties\/\" ;\n+    public static final String IGNORE_EXTERNAL_DTD = ZEPHYR_PROPERTY_PREFIX + \"ignore-external-dtd\";\n+\n+    \/\/ Valid values for the DTD property\n+    public static final String DTD_ALLOW = \"allow\";\n+    public static final String DTD_IGNORE = \"ignore\";\n+    public static final String DTD_DENY = \"deny\";\n+    static final Map<String, Integer> DTD_MAP;\n+    \/\/ Source Level JDK 8\n+    static {\n+        Map<String, Integer> map = new HashMap<>();\n+        map.put(DTD_ALLOW, 0);\n+        map.put(DTD_IGNORE, 1);\n+        map.put(DTD_DENY, 2);\n+        DTD_MAP = Collections.unmodifiableMap(map);\n+    }\n+\n+    \/\/ Value converter for properties of type Boolean\n+    private static final BooleanMapper BOOLMAPPER = new BooleanMapper();\n+\n+    \/\/ Value converter for properties of type Integer\n+    private static final IntegerMapper INTMAPPER = new IntegerMapper();\n+\n+    \/\/ DTD value map\n+    private static final StringMapper DTDMAPPER = new StringMapper(DTD_MAP);\n+\n@@ -46,1 +85,1 @@\n-            JdkConstants.SP_ENTITY_EXPANSION_LIMIT, 0, 64000, Processor.PARSER),\n+            JdkConstants.SP_ENTITY_EXPANSION_LIMIT, JdkConstants.ENTITY_EXPANSION_LIMIT, 0, 64000, Processor.PARSER, INTMAPPER),\n@@ -48,1 +87,1 @@\n-            JdkConstants.SP_MAX_OCCUR_LIMIT, 0, 5000, Processor.PARSER),\n+            JdkConstants.SP_MAX_OCCUR_LIMIT, JdkConstants.MAX_OCCUR_LIMIT, 0, 5000, Processor.PARSER, INTMAPPER),\n@@ -50,1 +89,1 @@\n-            JdkConstants.SP_ELEMENT_ATTRIBUTE_LIMIT, 0, 10000, Processor.PARSER),\n+            JdkConstants.SP_ELEMENT_ATTRIBUTE_LIMIT, JdkConstants.ELEMENT_ATTRIBUTE_LIMIT, 0, 10000, Processor.PARSER, INTMAPPER),\n@@ -52,1 +91,1 @@\n-            JdkConstants.SP_TOTAL_ENTITY_SIZE_LIMIT, 0, 50000000, Processor.PARSER),\n+            JdkConstants.SP_TOTAL_ENTITY_SIZE_LIMIT, null, 0, 50000000, Processor.PARSER, INTMAPPER),\n@@ -54,1 +93,1 @@\n-            JdkConstants.SP_GENERAL_ENTITY_SIZE_LIMIT, 0, 0, Processor.PARSER),\n+            JdkConstants.SP_GENERAL_ENTITY_SIZE_LIMIT, null, 0, 0, Processor.PARSER, INTMAPPER),\n@@ -56,1 +95,1 @@\n-            JdkConstants.SP_PARAMETER_ENTITY_SIZE_LIMIT, 0, 1000000, Processor.PARSER),\n+            JdkConstants.SP_PARAMETER_ENTITY_SIZE_LIMIT, null, 0, 1000000, Processor.PARSER, INTMAPPER),\n@@ -58,1 +97,1 @@\n-            JdkConstants.SP_MAX_ELEMENT_DEPTH, 0, 0, Processor.PARSER),\n+            JdkConstants.SP_MAX_ELEMENT_DEPTH, null, 0, 0, Processor.PARSER, INTMAPPER),\n@@ -60,1 +99,1 @@\n-            JdkConstants.SP_XML_NAME_LIMIT, 1000, 1000, Processor.PARSER),\n+            JdkConstants.SP_XML_NAME_LIMIT, null, 1000, 1000, Processor.PARSER, INTMAPPER),\n@@ -62,1 +101,1 @@\n-            JdkConstants.SP_ENTITY_REPLACEMENT_LIMIT, 0, 3000000, Processor.PARSER),\n+            JdkConstants.SP_ENTITY_REPLACEMENT_LIMIT, null, 0, 3000000, Processor.PARSER, INTMAPPER),\n@@ -64,1 +103,1 @@\n-            JdkConstants.XPATH_GROUP_LIMIT, 10, 10, Processor.XPATH),\n+            JdkConstants.XPATH_GROUP_LIMIT, null, 10, 10, Processor.XPATH, INTMAPPER),\n@@ -66,1 +105,1 @@\n-            JdkConstants.XPATH_OP_LIMIT, 100, 100, Processor.XPATH),\n+            JdkConstants.XPATH_OP_LIMIT, null, 100, 100, Processor.XPATH, INTMAPPER),\n@@ -68,1 +107,5 @@\n-            JdkConstants.XPATH_TOTALOP_LIMIT, 10000, 10000, Processor.XPATH)\n+            JdkConstants.XPATH_TOTALOP_LIMIT, null, 10000, 10000, Processor.XPATH, INTMAPPER),\n+        DTD(\"DTDProperty\", JdkConstants.DTD_PROPNAME, JdkConstants.DTD_PROPNAME, null,\n+                JdkConstants.ALLOW, JdkConstants.ALLOW, Processor.PARSER, DTDMAPPER),\n+        XERCES_DISALLOW_DTD(\"disallowDTD\", DISALLOW_DTD, null, null, 0, 0, Processor.PARSER, BOOLMAPPER),\n+        STAX_SUPPORT_DTD(\"supportDTD\", XMLInputFactory.SUPPORT_DTD, null, null, 1, 1, Processor.PARSER, BOOLMAPPER),\n@@ -74,0 +117,1 @@\n+        final String spOld;\n@@ -77,0 +121,1 @@\n+        final ValueMapper mapper;\n@@ -78,2 +123,2 @@\n-        Limit(String key, String apiProperty, String systemProperty, int value,\n-                int secureValue, Processor processor) {\n+        Limit(String key, String apiProperty, String systemProperty, String spOld, int value,\n+                int secureValue, Processor processor, ValueMapper mapper) {\n@@ -83,0 +128,1 @@\n+            this.spOld = spOld;\n@@ -86,0 +132,1 @@\n+            this.mapper = mapper;\n@@ -132,0 +179,5 @@\n+        \/\/ returns legacy System Property\n+        public String spOld() {\n+            return spOld;\n+        }\n+\n@@ -143,12 +195,0 @@\n-    }\n-\n-    \/**\n-     * Map old property names with the new ones\n-     *\/\n-    public static enum NameMap {\n-\n-        ENTITY_EXPANSION_LIMIT(JdkConstants.SP_ENTITY_EXPANSION_LIMIT, JdkConstants.ENTITY_EXPANSION_LIMIT),\n-        MAX_OCCUR_NODE_LIMIT(JdkConstants.SP_MAX_OCCUR_LIMIT, JdkConstants.MAX_OCCUR_LIMIT),\n-        ELEMENT_ATTRIBUTE_LIMIT(JdkConstants.SP_ELEMENT_ATTRIBUTE_LIMIT, JdkConstants.ELEMENT_ATTRIBUTE_LIMIT);\n-        final String newName;\n-        final String oldName;\n@@ -156,10 +196,2 @@\n-        NameMap(String newName, String oldName) {\n-            this.newName = newName;\n-            this.oldName = oldName;\n-        }\n-\n-        String getOldName(String newName) {\n-            if (newName.equals(this.newName)) {\n-                return oldName;\n-            }\n-            return null;\n+        public ValueMapper mapper() {\n+            return mapper;\n@@ -173,0 +205,1 @@\n+        ANY,\n@@ -233,1 +266,2 @@\n-        \/\/read system properties or jaxp.properties\n+\n+        \/\/read system properties or the config file (jaxp.properties by default)\n@@ -287,2 +321,8 @@\n-        int index = getIndex(propertyName);\n-        if (index > -1) {\n+        \/\/ special property to return entity count info\n+        if (ImplPropMap.ENTITYCOUNT.is(propertyName)) {\n+            printEntityCountInfo = (String)value;\n+            return true;\n+        }\n+\n+        Limit limit = getEnumValue(propertyName);\n+        if (limit != null) {\n@@ -290,2 +330,3 @@\n-            if (index != indexEntityCountInfo && state == State.APIPROPERTY) {\n-                pState = (Limit.values()[index]).getState(propertyName);\n+            if (state == State.APIPROPERTY) {\n+                \/\/ ordinal is the index of the value array\n+                pState = (Limit.values()[limit.ordinal()]).getState(propertyName);\n@@ -293,1 +334,1 @@\n-            setLimit(index, pState, value);\n+            setLimit(limit, pState, value);\n@@ -311,1 +352,1 @@\n-     * Set the value of a property by its index\n+     * Sets the value of a property by its enum name\n@@ -313,1 +354,1 @@\n-     * @param index the index of the property\n+     * @param limit the limit\n@@ -317,14 +358,4 @@\n-    public void setLimit(int index, State state, Object value) {\n-        if (index == indexEntityCountInfo) {\n-            printEntityCountInfo = (String)value;\n-        } else {\n-            int temp;\n-            if (value instanceof Integer) {\n-                temp = (Integer)value;\n-            } else {\n-                temp = Integer.parseInt((String) value);\n-                if (temp < 0) {\n-                    temp = 0;\n-                }\n-            }\n-            setLimit(index, state, temp);\n+    public void setLimit(Limit limit, State state, Object value) {\n+        int intValue = limit.mapper().toInt(value);\n+        if (intValue < 0) {\n+            intValue = 0;\n@@ -332,0 +363,2 @@\n+\n+        setLimit(limit.ordinal(), state, intValue);\n@@ -387,1 +420,1 @@\n-        return Integer.toString(values[limit.ordinal()]);\n+        return limit.mapper().toString(values[limit.ordinal()]);\n@@ -401,1 +434,2 @@\n-        return Integer.toString(values[index]);\n+        Limit limit = Limit.values()[index];\n+        return limit.mapper().toString(values[index]);\n@@ -424,0 +458,16 @@\n+    \/**\n+     * Returns the enum value by its property name.\n+     *\n+     * @param propertyName property name\n+     * @return the enum value if found; null otherwise\n+     *\/\n+    public Limit getEnumValue(String propertyName) {\n+        for (Limit limit : Limit.values()) {\n+            if (limit.is(propertyName)) {\n+                return limit;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n@@ -526,2 +576,26 @@\n-     * @param index\n-     * @return\n+     * @param limit the limit\n+     * @return true if the limit is set, false otherwise\n+     *\/\n+    public boolean isSet(Limit limit) {\n+        return isSet[limit.ordinal()];\n+    }\n+\n+    \/**\n+     * Checks whether the specified {@link Limit} is set and the value is\n+     * as specified.\n+     *\n+     * @param limit the {@link Limit}\n+     * @param value the value\n+     * @return true if the {@code Limit} is set and the values match\n+     *\/\n+    public boolean is(Limit limit, int value) {\n+        return getLimit(limit) == value;\n+    }\n+\n+    \/**\n+     * Checks whether the specified {@link Limit} is set and the value is\n+     * 1 (true for a property of boolean type).\n+     *\n+     * @param limit the {@link Limit}\n+     *\n+     * @return true if the {@code Limit} is set and the value is 1\n@@ -529,2 +603,2 @@\n-    public boolean isSet(int index) {\n-        return isSet[index];\n+    public boolean is(Limit limit) {\n+        return getLimit(limit) == 1;\n@@ -540,1 +614,1 @@\n-    private void readSystemProperties() {\n+    public void readSystemProperties() {\n@@ -542,5 +616,10 @@\n-            \/\/ attempts to read both the current and old system propery\n-            if (!getSystemProperty(limit, limit.systemProperty())\n-                    && (!getOldSystemProperty(limit))) {\n-                \/\/if system property is not found, try the config file\n-                getPropertyConfig(limit, limit.systemProperty());\n+            if (State.SYSTEMPROPERTY.compareTo(states[limit.ordinal()]) >= 0 &&\n+                    limit.systemProperty() != null) {\n+                \/\/ attempts to read both the current and old system propery\n+                if (!getSystemProperty(limit, limit.systemProperty())\n+                        && (!getSystemProperty(limit, limit.spOld()))) {\n+                    \/\/if system property is not found, try the config file\n+                    if (State.JAXPDOTPROPERTIES.compareTo(states[limit.ordinal()]) >= 0) {\n+                        getPropertyConfig(limit, limit.systemProperty());\n+                    }\n+                }\n@@ -575,0 +654,2 @@\n+        if (sysPropertyName == null) return false;\n+\n@@ -578,2 +659,1 @@\n-                values[limit.ordinal()] = Integer.parseInt(value);\n-                states[limit.ordinal()] = State.SYSTEMPROPERTY;\n+                setLimit(limit, State.SYSTEMPROPERTY, value);\n@@ -589,19 +669,0 @@\n-    \/**\n-     * Reads the legacy system property.\n-     * @param limit a limit object\n-     * @return true if found, false otherwise\n-     *\/\n-    private boolean getOldSystemProperty(Limit limit) {\n-        boolean found = false;\n-        for (NameMap nameMap : NameMap.values()) {\n-            String oldName = nameMap.getOldName(limit.systemProperty());\n-            if (oldName != null) {\n-                if (getSystemProperty(limit, oldName)) {\n-                    found = true;\n-                    break;\n-                }\n-            }\n-        }\n-        return found;\n-    }\n-\n@@ -619,2 +680,1 @@\n-                values[limit.ordinal()] = Integer.parseInt(value);\n-                states[limit.ordinal()] = State.JAXPDOTPROPERTIES;\n+                setLimit(limit, State.JAXPDOTPROPERTIES, value);\n@@ -661,0 +721,157 @@\n+\n+    \/**\n+     * Represents a mapper for properties of type String. The input is expected\n+     * to be a String or Object. If there is a map, the mappings are between the\n+     * keys and values within the map.\n+     *\/\n+    public static class StringMapper extends ValueMapper {\n+        private final Map<String, Integer> map;\n+        private final Map<Integer, String> reverseMap;\n+\n+        public StringMapper(Map<String, Integer> map) {\n+            this.map = map;\n+            if (map != null) {\n+                reverseMap = map.entrySet().stream()\n+                    .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n+            } else {\n+                reverseMap = null;\n+            }\n+        }\n+\n+        \/**\n+         * Finds the mapping int value with the specified property value. This\n+         * method will try to convert the provided value to an integer if no\n+         * mapping is found.\n+         * @param value the property value\n+         * @return the mapping int value if found, null otherwise\n+         *\/\n+        @Override\n+        public int toInt(Object value) {\n+            Objects.requireNonNull(value);\n+            Integer iVal;\n+            if (map != null) {\n+                iVal = map.get(((String)value).toLowerCase());\n+                iVal = (iVal == null) ? 0 : iVal;\n+            } else {\n+                try {\n+                    iVal = (int)Double.parseDouble((String)value);\n+                } catch (NumberFormatException e) {\n+                    \/\/ Note: this is the currently expected behavior. It may be\n+                    \/\/ appropriate for the setter to catch it.\n+                    throw new NumberFormatException(\"Invalid setting \" + value\n+                            + \" for a property of Integer type.\");\n+                }\n+            }\n+            return iVal;\n+        }\n+\n+        @Override\n+        public String toObject(int value) {\n+            if (reverseMap != null) {\n+                return reverseMap.get(value);\n+            }\n+            return Integer.toString(value);\n+        }\n+\n+        @Override\n+        public String toString(int value) {\n+            return toObject(value);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a mapper for properties of type Integer. The input is expected\n+     * to be either an Integer or String.\n+     *\/\n+    public static class IntegerMapper extends ValueMapper {\n+        @Override\n+        public int toInt(Object value) {\n+            Objects.requireNonNull(value);\n+\n+            Integer iVal;\n+            if (value instanceof Integer) {\n+                iVal = (Integer)value;\n+            } else {\n+                try {\n+                    iVal = Integer.parseInt((String)value);\n+                } catch (NumberFormatException e) {\n+                    \/\/ Note: this is the currently expected behavior. It may be\n+                    \/\/ appropriate for the setter to catch it.\n+                    throw new NumberFormatException(\"Invalid setting \" + value\n+                            + \" for a property of Integer type.\");\n+                }\n+            }\n+\n+            return iVal;\n+        }\n+\n+        @Override\n+        public Integer toObject(int value) {\n+            return value;\n+        }\n+\n+        @Override\n+        public String toString(int value) {\n+            return Integer.toString(value);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a mapper for properties of type Boolean. The input is expected\n+     * to be either a Boolean or String.\n+     *\/\n+    public static class BooleanMapper extends ValueMapper {\n+        @Override\n+        public int toInt(Object value) {\n+            Objects.requireNonNull(value);\n+\n+            Boolean bVal;\n+            if (value instanceof Boolean) {\n+                bVal = (Boolean)value;\n+            } else {\n+                bVal = ((String)value).equalsIgnoreCase(\"true\");\n+            }\n+\n+            return bVal ? 1 : 0;\n+        }\n+\n+        @Override\n+        public Boolean toObject(int value) {\n+            return value != 0;\n+        }\n+\n+        @Override\n+        public String toString(int value) {\n+            return Boolean.toString(value != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a mapper of property values between int and other types, such as\n+     * Boolean, String, and Object.\n+     *\/\n+    public static abstract class ValueMapper {\n+        \/\/ converts to an int value from that of the specified type\n+        public abstract int toInt(Object value);\n+        \/\/ converts the int value back to the original type\n+        public abstract Object toObject(int value);\n+        \/\/ converts the int value of a property to a String representation\n+        public abstract String toString(int value);\n+\n+    }\n+\n+    \/**\n+     * Represents a mapper of property values between int and other types, such as\n+     * Boolean, String, and Object.\n+     *\n+     * @param <T> the value type to be mapped with an int value\n+     *\/\n+    public abstract class ValueMapper1<T> {\n+        \/\/ converts to an int value from that of the specified type\n+        public abstract int toInt(T value);\n+        \/\/ converts the int value back to the original type\n+        public abstract T toObject(int value);\n+        \/\/ converts the int value of a property to a String representation\n+        public abstract String toString(int value);\n+\n+    }\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/XMLSecurityManager.java","additions":310,"deletions":93,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -755,1 +755,1 @@\n- * <td style=\"text-align:center\" rowspan=\"3\">yes<\/td>\n+ * <td style=\"text-align:center\" rowspan=\"4\">yes<\/td>\n@@ -811,0 +811,34 @@\n+ * <tr>\n+ * <td id=\"DTD\">{@systemProperty jdk.xml.dtd.support}<a href=\"#Note7\">[7]<\/a><\/td>\n+ * <td>Instructs the parser to handle DTDs in accordance with the setting of this property.\n+ * The options are:\n+ * <ul>\n+ * <li><p>\n+ * {@code allow} -- indicates that the parser shall continue processing DTDs;\n+ * <\/li>\n+ * <li><p>\n+ * {@code ignore} -- indicates that the parser shall skip DTDs;\n+ * <\/li>\n+ * <li><p>\n+ * {@code deny} -- indicates that the parser shall reject DTDs as an error.\n+ * The parser shall report the error in accordance with its relevant specification.\n+ * <\/li>\n+ * <\/ul>\n+ * <\/td>\n+ * <td style=\"text-align:center\">String<\/td>\n+ * <td>\n+ * {@code allow, ignore, and deny}. Values are case-insensitive.\n+ * <\/td>\n+ * <td style=\"text-align:center\">allow<\/td>\n+ * <td style=\"text-align:center\">No<\/td>\n+ * <td style=\"text-align:center\">Yes<\/td>\n+ * <td style=\"text-align:center\">\n+ *     <a href=\"#DOM\">DOM<\/a><br>\n+ *     <a href=\"#SAX\">SAX<\/a><br>\n+ *     <a href=\"#StAX\">StAX<\/a><br>\n+ *     <a href=\"#Validation\">Validation<\/a><br>\n+ *     <a href=\"#Transform\">Transform<\/a>\n+ * <\/td>\n+ * <td style=\"text-align:center\"><a href=\"#Processor\">Method 1<\/a><\/td>\n+ * <td style=\"text-align:center\">22<\/td>\n+ * <\/tr>\n@@ -841,0 +875,13 @@\n+ * <p id=\"Note7\">\n+ * <b>[7]<\/b> The {@code jdk.xml.dtd.support} property complements the two existing\n+ * DTD-related properties, {@code disallow-doctype-decl}(fully qualified name:\n+ * {@code http:\/\/apache.org\/xml\/features\/disallow-doctype-decl}) and supportDTD\n+ * ({@code javax.xml.stream.supportDTD}), by providing a uniformed support for the\n+ * processors listed and a system property that can be used in the\n+ * <a href=\"#Conf_CF\">JAXP Configuration File<\/a>. When {@code disallow-doctype-decl} is\n+ * set on the DOM or SAX factory, or supportDTD on StAX factory, the {@code jdk.xml.dtd.support}\n+ * property will have no effect.\n+ * <p>\n+ * These three properties control whether DTDs as a whole shall be processed. When\n+ * they are set to deny or ignore, other properties that regulate a part or an\n+ * aspect of DTD shall have no effect.\n","filename":"src\/java.xml\/share\/classes\/module-info.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager.Limit;\n@@ -37,0 +36,5 @@\n+import jdk.xml.internal.XMLSecurityManager.BooleanMapper;\n+import jdk.xml.internal.XMLSecurityManager.IntegerMapper;\n+import jdk.xml.internal.XMLSecurityManager.Limit;\n+import jdk.xml.internal.XMLSecurityManager.StringMapper;\n+import jdk.xml.internal.XMLSecurityManager.ValueMapper;\n@@ -93,0 +97,12 @@\n+            Object value1 = null, value2 = null;\n+            ValueMapper mapper = limit.mapper();\n+            if (mapper instanceof StringMapper) {\n+                value1 = mapper.toObject(0);\n+                value2 = mapper.toObject(1);\n+            } else if (mapper instanceof BooleanMapper) {\n+                value1 = true;\n+                value2 = false;\n+            } else if (mapper instanceof IntegerMapper) {\n+                value1 = 100;\n+                value2 = 200;\n+            }\n@@ -94,1 +110,2 @@\n-                testProperties(p, limit.apiProperty(), 100, limit.systemProperty(), 200, true);\n+                testProperties(p, limit.apiProperty(), value1, limit.systemProperty(), value2,\n+                    (limit.systemProperty() != null && !limit.apiProperty().equals(limit.systemProperty())));\n@@ -179,1 +196,0 @@\n-\n@@ -268,1 +284,8 @@\n-            ret2 = Integer.parseInt((String)ret2);\n+            if (differ) {\n+                ret2 = Integer.parseInt((String)ret2);\n+            }\n+        } else if ((value1 instanceof Boolean) && ret1 instanceof String) {\n+            ret1 = Boolean.parseBoolean((String)ret1);\n+            if (differ) {\n+                ret2 = Boolean.parseBoolean((String)ret2);\n+            }\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/ImplPropertyTest.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+\n+# ---- For DTD test ----\n+#\n+# Disallow DTD\n+jdk.xml.dtd.support=deny\n+#\n+# Implementation specific limits:\n+jdk.xml.entityExpansionLimit=1000\n+\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/files\/dtd2.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+package common.dtd;\n+\n+\/**\n+ * @test @bug 8306632\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.dtd.DOMTest 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.dtd.DOMTest 1 \/\/ verifies overriding with config file\n+ * @run driver common.dtd.DOMTest 2 \/\/ verifies overriding with system property\n+ * @run driver common.dtd.DOMTest 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.dtd.DOMTest 4 \/\/ verifies DTD=ignore\n+ * @run driver common.dtd.DOMTest 5 \/\/ verifies disallow-doctype-decl=false\n+ * @run driver common.dtd.DOMTest 6 \/\/ verifies disallow-doctype-decl=true\n+ * @summary verifies DOM's support of the property jdk.xml.dtd.support.\n+ *\/\n+public class DOMTest extends DTDTestBase {\n+    public static void main(String args[]) throws Exception {\n+        new DOMTest().run(args[0]);\n+    }\n+\n+    public void run(String index) throws Exception {\n+        paramMap(Processor.DOM, null, index);\n+        super.testDOM(filename, fsp, state, config, sysProp, apiProp, expectError, error);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/dtd\/DOMTest.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+package common.dtd;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.validation.SchemaFactory;\n+import common.util.TestBase;\n+\n+\/**\n+ * @bug 8306632\n+ * @summary tests the DTD property jdk.xml.dtd.support.\n+ * The DTD property controls how DTDs are processed.\n+ *\/\n+public class DTDTestBase extends TestBase {\n+    static final String SRC_DIR;\n+    static {\n+        String srcDir = System.getProperty(\"test.src\", \".\");\n+        if (IS_WINDOWS) {\n+            srcDir = srcDir.replace('\\\\', '\/');\n+        }\n+        SRC_DIR = srcDir;\n+        TEST_SOURCE_DIR = srcDir + \"\/..\/xmlfiles\/\";\n+    }\n+\n+    public void testDOM(String filename, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp,\n+        boolean expectError, String error) throws Exception {\n+\n+        DocumentBuilderFactory dbf = getDBF(fsp, state, config, sysProp, apiProp);\n+        process(filename, dbf, expectError, error);\n+    }\n+\n+    public void testSAX(String filename, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp,\n+        boolean expectError, String error) throws Exception {\n+\n+        SAXParser parser = getSAXParser(fsp, state, config, sysProp, apiProp);\n+        process(filename, parser, expectError, error);\n+    }\n+\n+    public void testStAX(String filename, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp,\n+        boolean expectError, String error) throws Exception {\n+\n+        XMLInputFactory xif = getXMLInputFactory(state, config, sysProp, apiProp);\n+        process(filename, xif, expectError, error);\n+    }\n+\n+    public void testSchema1(String filename, String xsd, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp,\n+        boolean expectError, String error) throws Exception {\n+\n+        SchemaFactory sf = getSchemaFactory(fsp, state, config, sysProp, apiProp);\n+        process(filename, sf, expectError, error);\n+    }\n+\n+    public void testSchema2(String filename, String xsd, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp,\n+        boolean expectError, String error) throws Exception {\n+        testSchema1(filename, xsd, fsp, state, config, sysProp, apiProp, expectError,  error);\n+    }\n+\n+    public void testValidation(String filename, String xsd, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp,\n+        boolean expectError, String error) throws Exception {\n+\n+        SchemaFactory sf = getSchemaFactory(fsp, state, config, sysProp, apiProp);\n+        validate(filename, sf, expectError, error);\n+    }\n+\n+    public void testStylesheet(String filename, String xsl, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp,\n+        boolean expectError, String error) throws Exception {\n+\n+        TransformerFactory tf = getTransformerFactory(fsp, state, config, sysProp, apiProp);\n+        process(filename, tf, expectError, error);\n+    }\n+\n+    public void testTransform(String filename, String xsl, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp,\n+        boolean expectError, String error) throws Exception {\n+\n+        TransformerFactory tf = getTransformerFactory(fsp, state, config, sysProp, apiProp);\n+        transform(filename, xsl, tf, expectError, error);\n+    }\n+\n+    \/*\n+     * DataProvider for testing configuring properties for parsers.\n+     *\n+     * Fields:\n+     *     file, FSP, state of setting, config file, system property, api property,\n+     *     Custom Catalog, error expected, error code or expected result\n+     *\/\n+    public Object[][] getConfigs(Processor processor) {\n+        \/\/ file with an external DTD that's not in JdkCatalog\n+        String fileDTDNotInC = \"properties1.xml\";\n+\n+        \/\/ error code when DTD=deny; The cause for DOM\n+        String errCode = \"JAXP00010008\";\n+\n+        \/\/ Xerces error message when DTD is disallowed\n+        String errXerces = \"disallow-doctype-decl\";\n+\n+        \/\/ error (not from catalog) is expect when CATALOG=continue\n+        boolean isErrExpected = true;\n+        String expected1 = \"invalid.site.com\";\n+\n+        \/\/ expected when DTD is ignored\n+        String expected = \"\";\n+\n+        switch (processor) {\n+            case SAX:\n+                \/\/errCode = \"JAXP00090001\";\n+                break;\n+            case STAX:\n+                errCode = \"JAXP00010008\";\n+                \/\/ StAX is non-validating parser\n+                isErrExpected = false;\n+                expected = \".*[\\\\w\\\\s]+(value1)[\\\\w\\\\s]+.*\";\n+                expected1 = expected;\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        return new Object[][]{\n+            \/\/ Case 1: external reference pointing to an invalid site\n+            \/**\n+             * Case 1-1: DTD=allow by default; no Config file;\n+             * Expect: error as the parser processes DTD and tries to access the invalid site\n+             * Error: JAXP00010008 java.net.UnknownHostException: invalid.site.com\n+             *\/\n+            {fileDTDNotInC, null, null, null, null, null, isErrExpected, expected},\n+\n+            \/**\n+             * Case 1-2: DTD=deny in config file\n+             * Expect: Exception since DTD is denied\n+             *\/\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE, Properties.CONFIG_FILE_DTD2, null, null, true, errCode},\n+\n+            \/**\n+             * Case 1-3: DTD=allow with the System Property\n+             * Expect: error as Case 1-1\n+             *\/\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, null, isErrExpected, expected1},\n+\n+            \/**\n+             * Case 1-4: DTD=deny with the API property\n+             * Expect: Exception as Case 1-2\n+             *\/\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, new Properties[]{Properties.DTD2}, true, errCode},\n+\n+            \/**\n+             * Case 1-5: DTD=ignore with the API property\n+             * Expect: no error, DTD is ignored\n+             *\/\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, new Properties[]{Properties.DTD1}, false, expected},\n+\n+            \/\/ Case 2: repeat Case 1-3 (allow), 1-4 (deny) with the Xerces property on the factory\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, new Properties[]{Properties.XERCES_ALLOW_DTD}, isErrExpected, expected1},\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, new Properties[]{Properties.XERCES_DISALLOW_DTD}, true, errXerces},\n+\n+            \/\/ Case 3: repeat Case 1-3 (allow), 1-5 (ignore) with the StAX property on the factory\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, new Properties[]{Properties.SUPPORT_DTD}, isErrExpected, expected1},\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, new Properties[]{Properties.SUPPORT_DTD_FALSE}, false, expected},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing configuring properties for validation or transform.\n+     *\n+     * Fields:\n+     *     xml file, xsd or xsl file, FSP, state of setting, config file, system property,\n+     *     api property, Custom Catalog, error expected, error code or expected result\n+     *\/\n+    public Object[][] getConfig(String m) {\n+        \/\/ SchemaTest1: Schema Import\n+        String xmlFile = \"XSDImport_company.xsd\";\n+        String xsdOrXsl = null;\n+        String expected = \"\";\n+        boolean errOnIgnore = false;\n+        String ignoreExpected = \"\";\n+        String errCode = \"JAXP00010008\";\n+\n+        switch (m) {\n+            case \"SchemaTest2\":\n+                \/\/ Schema Include\n+                xmlFile = \"XSDInclude_company.xsd\";\n+                break;\n+            case \"Validation\":\n+                \/\/ Schema Location\n+                xmlFile = \"val_test.xml\";\n+                errOnIgnore = true;\n+                ignoreExpected = \"x1\";\n+                break;\n+            case \"Stylesheet\":\n+                xmlFile = \"XSLDTD.xsl\";\n+                break;\n+            case \"Transform\":\n+                xmlFile = \"XSLPI.xml\";\n+                xsdOrXsl = \"<?xml version='1.0'?>\"\n+                + \"<!DOCTYPE top SYSTEM 'test.dtd'\"\n+                + \"[\"\n+                + \"<!ENTITY % pe \\\"x\\\">\"\n+                + \"<!ENTITY   x1 \\\"AAAAA\\\">\"\n+                + \"<!ENTITY   x2 \\\"bbb\\\">\"\n+                +\"]>\"\n+                + \"<?xml-stylesheet href=\\\"\"\n+                + TEST_SOURCE_DIR\n+                + \"\/XSLPI_target.xsl\\\" type=\\\"text\/xml\\\"?>\"\n+                + \"<xsl:stylesheet \"\n+                + \"    xmlns:xsl='http:\/\/www.w3.org\/1999\/XSL\/Transform' \"\n+                + \"    version='1.0'>\"\n+                + \"<\/xsl:stylesheet> \";\n+                errCode = \"JAXP00010008\";\n+                break;\n+            default:\n+                break;\n+        }\n+        return new Object[][]{\n+            \/\/ Case 1: external reference pointing to an invalid site\n+            \/**\n+             * Case 1-1: default setting, DTD=allow\n+             * Expect: pass without error\n+             *\/\n+            {xmlFile, xsdOrXsl, null, null, null, null, null, false, expected},\n+\n+            \/**\n+             * Case 1-2: DTD=deny in config file\n+             * Expect: Exception since DTD is denied\n+             *\/\n+            {xmlFile, xsdOrXsl, null, PropertyState.CONFIG_FILE, Properties.CONFIG_FILE_DTD2, null, null, true, errCode},\n+\n+            \/**\n+             * Case 1-3: DTD=allow with the System Property\n+             * Expect: error as Case 1-1\n+             *\/\n+            {xmlFile, xsdOrXsl, null, PropertyState.CONFIG_FILE_SYSTEM, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, null, false, expected},\n+\n+            \/**\n+             * Case 1-4: DTD=deny with the API property\n+             * Expect: Exception as Case 1-2\n+             *\/\n+            {xmlFile, xsdOrXsl, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, new Properties[]{Properties.DTD2}, true, errCode},\n+\n+            \/**\n+             * Case 1-5: DTD=ignore with the API property\n+             * Expect: no error, DTD is ignored\n+             *\/\n+            {xmlFile, xsdOrXsl, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_DTD2, new Properties[]{Properties.DTD0}, new Properties[]{Properties.DTD1}, errOnIgnore, ignoreExpected},\n+\n+        };\n+    }\n+\n+    \/\/ Returns absolute path\n+    static String getPath(String file) {\n+        String temp = TEST_SOURCE_DIR + file;\n+        if (IS_WINDOWS) {\n+            temp = \"\/\" + temp;\n+        }\n+        return temp;\n+    }\n+\n+    \/\/ parameters in the same order as the test method\n+    String filename; String xsd; String xsl; Properties fsp; PropertyState state;\n+    Properties config; Properties[] sysProp; Properties[] apiProp;\n+    boolean expectError; String error;\n+\n+    \/\/ Maps the DataProvider array to individual parameters\n+    public void paramMap(Processor processor, String method, String index) {\n+        int i = 0;\n+        Object[][] params;\n+        if (processor == Processor.VALIDATOR ||\n+                processor == Processor.TRANSFORMER) {\n+            params = getConfig(method);\n+            i = 1;\n+        } else {\n+            params = getConfigs(processor);\n+        }\n+        Object[] param = params[Integer.parseInt(index)];\n+        filename = (String)param[0];\n+        if (processor == Processor.VALIDATOR) {\n+            xsd = (String)param[i];\n+        } else if (processor == Processor.TRANSFORMER) {\n+            xsl = (String)param[i];\n+        }\n+        fsp = (Properties)param[i + 1];\n+        state = (PropertyState)param[i + 2];\n+        config = (Properties)param[i + 3];\n+        sysProp = (Properties[])param[i + 4];\n+        apiProp = (Properties[])param[i + 5];\n+        expectError = (boolean)param[i + 6];\n+        error = (String)param[i + 7];\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/dtd\/DTDTestBase.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+package common.dtd;\n+\n+import common.util.TestBase;\n+\n+\/**\n+ * @test @bug 8306632\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.dtd.SAXTest 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.dtd.SAXTest 1 \/\/ verifies overriding with config file\n+ * @run driver common.dtd.SAXTest 2 \/\/ verifies overriding with system property\n+ * @run driver common.dtd.SAXTest 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.dtd.SAXTest 4 \/\/ verifies DTD=ignore\n+ * @run driver common.dtd.SAXTest 5 \/\/ verifies disallow-doctype-decl=false\n+ * @run driver common.dtd.SAXTest 6 \/\/ verifies disallow-doctype-decl=true\n+ * @summary verifies SAX's support of the property jdk.xml.dtd.support.\n+ *\/\n+public class SAXTest extends DTDTestBase {\n+    public static void main(String args[]) throws Exception {\n+        new SAXTest().run(args[0]);\n+    }\n+\n+    public void run(String index) throws Exception {\n+        paramMap(TestBase.Processor.SAX, null, index);\n+        super.testSAX(filename, fsp, state, config, sysProp, apiProp, expectError, error);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/dtd\/SAXTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+package common.dtd;\n+\n+\/**\n+ * @test @bug 8306632\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.dtd.SchemaTest SchemaTest1 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.dtd.SchemaTest SchemaTest1 1 \/\/ verifies overriding with config file\n+ * @run driver common.dtd.SchemaTest SchemaTest1 2 \/\/ verifies overriding with system property\n+ * @run driver common.dtd.SchemaTest SchemaTest1 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.dtd.SchemaTest SchemaTest1 4 \/\/ verifies DTD=ignore\n+ * @run driver common.dtd.SchemaTest SchemaTest2 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.dtd.SchemaTest SchemaTest2 1 \/\/ verifies overriding with config file\n+ * @run driver common.dtd.SchemaTest SchemaTest2 2 \/\/ verifies overriding with system property\n+ * @run driver common.dtd.SchemaTest SchemaTest2 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.dtd.SchemaTest SchemaTest2 4 \/\/ verifies DTD=ignore\n+ * @run driver common.dtd.SchemaTest Validation 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.dtd.SchemaTest Validation 1 \/\/ verifies overriding with config file\n+ * @run driver common.dtd.SchemaTest Validation 2 \/\/ verifies overriding with system property\n+ * @run driver common.dtd.SchemaTest Validation 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.dtd.SchemaTest Validation 4 \/\/ verifies DTD=ignore\n+ * @summary verifies Schema and Validation's support of the property jdk.xml.dtd.support.\n+ *\/\n+public class SchemaTest extends DTDTestBase {\n+\n+    public static void main(String args[]) throws Exception {\n+        new SchemaTest().run(args[0], args[1]);\n+    }\n+\n+    public void run(String method, String index) throws Exception {\n+        paramMap(Processor.VALIDATOR, method, index);\n+        switch (method) {\n+            case \"SchemaTest1\":\n+                super.testSchema1(filename, xsd, fsp, state, config, sysProp, apiProp, expectError, error);\n+                break;\n+            case \"SchemaTest2\":\n+                super.testSchema2(filename, xsd, fsp, state, config, sysProp, apiProp, expectError, error);\n+                break;\n+            case \"Validation\":\n+                super.testValidation(filename, xsd, fsp, state, config, sysProp, apiProp, expectError, error);\n+                break;\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/dtd\/SchemaTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+package common.dtd;\n+\n+import common.util.TestBase;\n+\n+\/**\n+ * @test @bug 8306632\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.dtd.StAXTest 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.dtd.StAXTest 1 \/\/ verifies overriding with config file\n+ * @run driver common.dtd.StAXTest 2 \/\/ verifies overriding with system property\n+ * @run driver common.dtd.StAXTest 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.dtd.StAXTest 4 \/\/ verifies DTD=ignore\n+ * @run driver common.dtd.StAXTest 5 \/\/ verifies disallow-doctype-decl=false\n+ * @run driver common.dtd.StAXTest 6 \/\/ verifies disallow-doctype-decl=true\n+ * @run driver common.dtd.StAXTest 7 \/\/ verifies supportDTD=true\n+ * @run driver common.dtd.StAXTest 8 \/\/ verifies supportDTD=false\n+ * @summary verifies StAX's support of the property jdk.xml.dtd.support.\n+ *\/\n+public class StAXTest extends DTDTestBase {\n+\n+    public static void main(String args[]) throws Exception {\n+        new StAXTest().run(args[0]);\n+    }\n+\n+    public void run(String index) throws Exception {\n+        paramMap(TestBase.Processor.STAX, null, index);\n+        super.testStAX(filename, fsp, state, config, sysProp, apiProp, expectError, error);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/dtd\/StAXTest.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+package common.dtd;\n+\n+import common.util.TestBase;\n+\n+\/**\n+ * @test @bug 8306632\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.dtd.TransformTest Stylesheet 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.dtd.TransformTest Stylesheet 1 \/\/ verifies overriding with config file\n+ * @run driver common.dtd.TransformTest Stylesheet 2 \/\/ verifies overriding with system property\n+ * @run driver common.dtd.TransformTest Stylesheet 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.dtd.TransformTest Stylesheet 4 \/\/ verifies DTD=ignore\n+ * @run driver common.dtd.TransformTest Transform 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.dtd.TransformTest Transform 1 \/\/ verifies overriding with config file\n+ * @run driver common.dtd.TransformTest Transform 2 \/\/ verifies overriding with system property\n+ * @run driver common.dtd.TransformTest Transform 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.dtd.TransformTest Transform 4 \/\/ verifies DTD=ignore\n+ * @summary verifies Transform's support of the property jdk.xml.dtd.support.\n+ *\/\n+public class TransformTest extends DTDTestBase {\n+\n+    public static void main(String args[]) throws Exception {\n+        new TransformTest().run(args[0], args[1]);\n+    }\n+\n+    public void run(String method, String index) throws Exception {\n+        paramMap(TestBase.Processor.TRANSFORMER, method, index);\n+        switch (method) {\n+            case \"Stylesheet\":\n+                super.testStylesheet(filename, xsl, fsp, state, config, sysProp, apiProp, expectError, error);\n+                break;\n+            case \"Transform\":\n+                super.testTransform(filename, xsl, fsp, state, config, sysProp, apiProp, expectError, error);\n+                break;\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/dtd\/TransformTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,635 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.regex.Pattern;\n+import javax.xml.XMLConstants;\n+import javax.xml.catalog.CatalogFeatures;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLResolver;\n+import javax.xml.stream.XMLStreamConstants;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.sax.SAXSource;\n+import javax.xml.transform.stax.StAXSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+import javax.xml.validation.Validator;\n+import org.w3c.dom.Document;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+\/**\n+ * Test base for common\/dtd\n+ *\/\n+public class TestBase {\n+    static final boolean DEBUG = true;\n+    public static final String ORACLE_JAXP_PROPERTY_PREFIX =\n+        \"http:\/\/www.oracle.com\/xml\/jaxp\/properties\/\";\n+    public static final String JDK_ENTITY_COUNT_INFO =\n+            ORACLE_JAXP_PROPERTY_PREFIX + \"getEntityCountInfo\";\n+    public static final String CATALOG_FILE = CatalogFeatures.Feature.FILES.getPropertyName();\n+    public static final boolean IS_WINDOWS = System.getProperty(\"os.name\").contains(\"Windows\");\n+    public static String SRC_DIR = System.getProperty(\"test.src\", \".\");\n+    public static String TEST_SOURCE_DIR;\n+\n+\n+    \/\/ configuration file system property\n+    private static final String CONFIG_FILE = \"java.xml.config.file\";\n+\n+    \/\/ Xerces Property\n+    public static final String DISALLOW_DTD = \"http:\/\/apache.org\/xml\/features\/disallow-doctype-decl\";\n+    public static final String LOAD_EXTERNAL_DTD = \"http:\/\/apache.org\/xml\/features\/nonvalidating\/load-external-dtd\";\n+\n+    \/\/ Zephyr Properties\n+    public static final String ZEPHYR_PROPERTY_PREFIX = \"http:\/\/java.sun.com\/xml\/stream\/properties\/\" ;\n+    public static final String IGNORE_EXTERNAL_DTD = ZEPHYR_PROPERTY_PREFIX + \"ignore-external-dtd\";\n+\n+    \/\/ Impl Specific Properties\n+    public static final String SP_DTD = \"jdk.xml.dtd.support\";\n+    public static final String OVERRIDE_PARSER = \"jdk.xml.overrideDefaultParser\";\n+\n+    \/\/ DTD\/CATALOG constants\n+    public static final String RESOLVE_CONTINUE = \"continue\";\n+    public static final String RESOLVE_IGNORE = \"ignore\";\n+    public static final String RESOLVE_STRICT = \"strict\";\n+\n+    public static final String DTD_ALLOW = \"allow\";\n+    public static final String DTD_IGNORE = \"ignore\";\n+    public static final String DTD_DENY = \"deny\";\n+\n+    \/\/ JAXP Configuration File(JCF) location\n+    \/\/ DTD = deny\n+    public static final String JCF_DTD2 = \"..\/config\/files\/dtd2.properties\";\n+\n+\n+    String xmlExternalEntity, xmlExternalEntityId;\n+    String xmlGE_Expansion, xmlGE_ExpansionId;\n+\n+    public static enum Processor { DOM, SAX, STAX, VALIDATOR, TRANSFORMER };\n+    static enum SourceType { STREAM, SAX, STAX, DOM };\n+\n+    public static enum Properties {\n+        CONFIG_FILE_DTD2(null, CONFIG_FILE, Type.FEATURE, getPath(JCF_DTD2)),\n+        FSP(XMLConstants.FEATURE_SECURE_PROCESSING, null, Type.FEATURE, \"true\"),\n+        FSP_FALSE(XMLConstants.FEATURE_SECURE_PROCESSING, null, Type.FEATURE, \"false\"),\n+\n+        \/\/ properties\n+        DTD0(SP_DTD, \"ditto\", Type.PROPERTY, DTD_ALLOW),\n+        DTD1(SP_DTD, \"ditto\", Type.PROPERTY, DTD_IGNORE),\n+        DTD2(SP_DTD, \"ditto\", Type.PROPERTY, DTD_DENY),\n+\n+        \/\/ StAX properties\n+        SUPPORT_DTD(XMLInputFactory.SUPPORT_DTD, null, Type.FEATURE, \"true\"),\n+        SUPPORT_DTD_FALSE(XMLInputFactory.SUPPORT_DTD, null, Type.FEATURE, \"false\"),\n+        SUPPORT_EXTERNAL_ENTITIES(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, null, Type.FEATURE, \"true\"),\n+        SUPPORT_EXTERNAL_ENTITIES_FALSE(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, null, Type.FEATURE, \"false\"),\n+        REPLACE_ENTITY_REF(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, null, Type.FEATURE, \"true\"),\n+        REPLACE_ENTITY_REF_FALSE(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, null, Type.FEATURE, \"false\"),\n+        ZEPHY_IGNORE_EXTERNAL_DTD(IGNORE_EXTERNAL_DTD, null, Type.FEATURE, \"true\"),\n+        ZEPHY_IGNORE_EXTERNAL_DTD_FALSE(IGNORE_EXTERNAL_DTD, null, Type.FEATURE, \"false\"),\n+\n+        \/\/ Xerces properties\n+        XERCES_DISALLOW_DTD(DISALLOW_DTD, null, Type.FEATURE, \"true\"),\n+        XERCES_ALLOW_DTD(DISALLOW_DTD, null, Type.FEATURE, \"false\"),\n+        XERCES_LOAD_EXTERNAL_DTD(LOAD_EXTERNAL_DTD, null, Type.FEATURE, \"true\"),\n+        XERCES_LOAD_EXTERNAL_DTD_FALSE(LOAD_EXTERNAL_DTD, null, Type.FEATURE, \"false\"),\n+\n+        ;\n+\n+        final String apiName, spName;\n+        final Type type;\n+        final String value;\n+\n+        String file, resolve;\n+        Properties(String apiName, String spName, Type t, String value) {\n+            this.apiName = apiName;\n+            \/\/ if spName not specified, it's the same as the API name\n+            if (\"ditto\".equals(spName)) {\n+                this.spName = apiName;\n+            } else {\n+                this.spName = spName;\n+            }\n+            this.type = t;\n+            this.value = value;\n+        }\n+\n+        public Type type() {\n+            return type;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+    }\n+\n+    public static enum Type {\n+        CONFIGFILE,\n+        FEATURE,\n+        PROPERTY,\n+        LIMIT,\n+    }\n+\n+    \/\/ the state of property setting\n+    public static enum PropertyState {\n+        \/\/ set through the factories\n+        API,\n+        \/\/ set through the System Property\n+        SYSTEM,\n+        \/\/ set in the Config file\n+        CONFIG_FILE,\n+        \/\/ set with both the Config file and System Property, the later shall prevail\n+        CONFIG_FILE_SYSTEM,\n+        \/\/ set: Config file, System Property and API, the later shall prevail\n+        CONFIG_FILE_SYSTEM_API,\n+    }\n+\n+    protected void process(String filename, DocumentBuilderFactory dbf, boolean expectError,\n+            String error) throws Exception {\n+        \/\/dbf.setAttribute(CatalogFeatures.Feature.RESOLVE.getPropertyName(), \"continue\");\n+        DocumentBuilder builder = dbf.newDocumentBuilder();\n+        File file = new File(getPath(filename));\n+        try {\n+            Document document = builder.parse(file);\n+            Assert.assertTrue(!expectError);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            processError(expectError, error, e);\n+        }\n+    }\n+\n+    protected void process(String filename, SAXParser parser, boolean expectError,\n+            String error) throws Exception {\n+\n+        File file = new File(getPath(filename));\n+        try {\n+            parser.parse(file, new DefaultHandler());\n+            Assert.assertTrue(!expectError);\n+        } catch (Exception e) {\n+            \/\/e.printStackTrace();\n+            processError(expectError, error, e);\n+        }\n+    }\n+\n+    protected void process(String filename, XMLInputFactory xif, boolean expectError,\n+            String expected) throws Exception {\n+\n+        String xml = getPath(filename);\n+        try {\n+            InputStream entityxml = new FileInputStream(xml);\n+            XMLStreamReader streamReader = xif.createXMLStreamReader(xml, entityxml);\n+            String text = getText(streamReader, XMLStreamConstants.CHARACTERS);\n+            System.out.println(\"Text: [\" + text.trim() + \"]\");\n+            Assert.assertTrue(Pattern.matches(expected, text.trim()));\n+            Assert.assertTrue(!expectError);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            processError(expectError, expected, e);\n+        }\n+    }\n+\n+    protected void process(String filename, SchemaFactory sf, boolean expectError,\n+            String expected) throws Exception {\n+\n+        String xsd = getPath(filename);\n+        try {\n+            Schema schema = sf.newSchema(new StreamSource(new File(xsd)));\n+            Assert.assertTrue(!expectError);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            processError(expectError, expected, e);\n+        }\n+    }\n+\n+    protected void process(String filename, TransformerFactory tf, boolean expectError,\n+            String expected) throws Exception {\n+        String xsl = getPath(filename);\n+        try {\n+            SAXSource xslSource = new SAXSource(new InputSource(xsl));\n+            xslSource.setSystemId(xsl);\n+            Transformer transformer = tf.newTransformer(xslSource);\n+            Assert.assertTrue(!expectError);\n+        } catch (Exception e) {\n+            \/\/e.printStackTrace();\n+            processError(expectError, expected, e);\n+        }\n+    }\n+\n+    protected void transform(String xmlFile, String xsl, TransformerFactory tf,\n+            boolean expectError, String expected) throws Exception {\n+        String xmlSysId = getPath(xmlFile);\n+        try {\n+            SAXSource xslSource = new SAXSource(new InputSource(new StringReader(xsl)));\n+            \/\/SAXSource xslSource = new SAXSource(new InputSource(xslSysId));\n+            xslSource.setSystemId(xmlSysId);\n+            Transformer transformer = tf.newTransformer(xslSource);\n+            StringWriter sw = new StringWriter();\n+            transformer.transform(getSource(SourceType.STREAM, xmlSysId), new StreamResult(sw));\n+            Assert.assertTrue(!expectError);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            processError(expectError, expected, e);\n+        }\n+    }\n+\n+    protected void validate(String filename, SchemaFactory sf, boolean expectError,\n+            String expected) throws Exception {\n+        String xml = getPath(filename);\n+        try {\n+            Schema schema = sf.newSchema();\n+            Validator validator = schema.newValidator();\n+            validator.validate(new StreamSource(new File(xml)));\n+            Assert.assertTrue(!expectError);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            processError(expectError, expected, e);\n+        }\n+    }\n+\n+    protected void processError(boolean expectError, String error, Exception e)\n+            throws Exception {\n+        \/\/e.printStackTrace();\n+        String str = e.getMessage();\n+\/\/        System.out.println(\"Exp Msg: \" + str);\n+        \/\/e.printStackTrace();\n+        if (!expectError) {\n+            Assert.assertTrue(false, \"Expected pass, but Exception is thrown \" +\n+                    str);\n+        } else {\n+            Assert.assertTrue((str != null) && str.contains(error));\n+        }\n+    }\n+\n+    \/**\n+     * Returns a DocumentBuilderFactory with settings as specified.\n+     *\n+     * @param fsp FSP setting\n+     * @param state the setting method\n+     * @param config the configuration file setting\n+     * @param sysProp properties to be set through the System Property API\n+     * @param apiProp the properties to be set via the factory\n+     * @return a DocumentBuilderFactory\n+     *\/\n+    protected DocumentBuilderFactory getDBF(Properties fsp, PropertyState state,\n+            Properties config, Properties[] sysProp, Properties[] apiProp) {\n+        setSystemProperty(config, state, sysProp);\n+\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newDefaultNSInstance();\n+        dbf.setXIncludeAware(true);\n+        if (fsp != null) {\n+            try {\n+                dbf.setFeature(fsp.apiName, Boolean.parseBoolean(fsp.value));\n+            } catch (ParserConfigurationException ex) {\n+                \/\/ shouldn't happen\n+                \/\/ex.printStackTrace();\n+                Assert.fail(\"Test error: setting \" + fsp.apiName + \" to \" + fsp.value);\n+            }\n+        }\n+        if (state == PropertyState.API || state == PropertyState.CONFIG_FILE_SYSTEM_API) {\n+            for (Properties property : apiProp) {\n+                if (property.type == Type.FEATURE) {\n+                    try {\n+                        dbf.setFeature(property.apiName, Boolean.parseBoolean(property.value));\n+                    } catch (ParserConfigurationException ex) {\n+                        Assert.fail(\"Test error: setting \" + fsp.apiName + \" to \" + fsp.value);\n+                    }\n+                } else {\n+                    dbf.setAttribute(property.apiName, property.value);\n+                }\n+            }\n+        }\n+\n+        clearSystemProperty(state, sysProp);\n+\n+        return dbf;\n+    }\n+\n+    \/**\n+     * Returns an instance of SAXParser with a catalog if one is provided.\n+     *\n+     * @param fsp Feature Secure Processing\n+     * @param state the state of property settings\n+     * @param config the config file\n+     * @param sysProp the system properties\n+     * @param apiProp the properties to be set via the factory\n+     * @return an instance of SAXParser\n+     * @throws ParserConfigurationException\n+     * @throws Exception\n+     *\/\n+    public SAXParser getSAXParser(Properties fsp, PropertyState state, Properties config,\n+            Properties[] sysProp, Properties[] apiProp) throws Exception {\n+        setSystemProperty(config, state, sysProp);\n+\n+        SAXParserFactory spf = SAXParserFactory.newDefaultNSInstance();\n+        spf.setXIncludeAware(true);\n+        if (fsp != null) {\n+            try {\n+                spf.setFeature(fsp.apiName, Boolean.parseBoolean(fsp.value));\n+            } catch (ParserConfigurationException ex) {\n+                Assert.fail(\"Test error: setting \" + fsp.apiName + \" to \" + fsp.value);\n+            }\n+        }\n+\n+        if (state == PropertyState.API || state == PropertyState.CONFIG_FILE_SYSTEM_API) {\n+            for (Properties property : apiProp) {\n+                if (property.type == Type.FEATURE) {\n+                    try {\n+                        spf.setFeature(property.apiName, Boolean.parseBoolean(property.value));\n+                    } catch (ParserConfigurationException ex) {\n+                        Assert.fail(\"Test error: setting \" + fsp.apiName + \" to \" + fsp.value);\n+                    }\n+                }\n+            }\n+        }\n+        SAXParser parser = spf.newSAXParser();\n+        if (state == PropertyState.API || state == PropertyState.CONFIG_FILE_SYSTEM_API) {\n+            for (Properties property : apiProp) {\n+                if (property.type != Type.FEATURE) {\n+                    parser.setProperty(property.apiName, property.value);\n+                }\n+            }\n+        }\n+\n+        clearSystemProperty(state, sysProp);\n+        return parser;\n+    }\n+\n+    protected XMLInputFactory getXMLInputFactory(PropertyState state,\n+            Properties config, Properties[] sysProp, Properties[] apiProp) {\n+        setSystemProperty(config, state, sysProp);\n+        XMLInputFactory factory = XMLInputFactory.newInstance();\n+\n+        if (state == PropertyState.API || state == PropertyState.CONFIG_FILE_SYSTEM_API) {\n+            for (Properties property : apiProp) {\n+                factory.setProperty(property.apiName, property.value);\n+            }\n+        }\n+\n+        clearSystemProperty(state, sysProp);\n+\n+        return factory;\n+    }\n+\n+    protected SchemaFactory getSchemaFactory(Properties fsp, PropertyState state,\n+            Properties config, Properties[] sysProp, Properties[] apiProp)\n+            throws Exception {\n+        setSystemProperty(config, state, sysProp);\n+        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+\n+        if (fsp != null) {\n+            factory.setFeature(fsp.apiName, Boolean.parseBoolean(fsp.value));\n+        }\n+\n+        if (state == PropertyState.API || state == PropertyState.CONFIG_FILE_SYSTEM_API) {\n+            for (Properties property : apiProp) {\n+                if (property.type == Type.FEATURE) {\n+                    factory.setFeature(property.apiName, Boolean.parseBoolean(property.value));\n+                } else {\n+                    factory.setProperty(property.apiName, property.value);\n+                }\n+            }\n+        }\n+\n+        clearSystemProperty(state, sysProp);\n+\n+        return factory;\n+    }\n+\n+    protected TransformerFactory getTransformerFactory(Properties fsp, PropertyState state,\n+            Properties config, Properties[] sysProp, Properties[] apiProp)\n+            throws Exception {\n+        setSystemProperty(config, state, sysProp);\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        \/\/tf.setAttribute(JDK_ENTITY_COUNT_INFO, \"yes\");\n+        if (fsp != null) {\n+            tf.setFeature(fsp.apiName, Boolean.parseBoolean(fsp.value));\n+        }\n+        if (state == PropertyState.API || state == PropertyState.CONFIG_FILE_SYSTEM_API) {\n+            for (Properties property : apiProp) {\n+                if (property.type == Type.FEATURE) {\n+                    tf.setFeature(property.apiName, Boolean.parseBoolean(property.value));\n+                } else {\n+                    tf.setAttribute(property.apiName, property.value);\n+                }\n+            }\n+        }\n+\n+        clearSystemProperty(state, sysProp);\n+\n+        return tf;\n+    }\n+\n+    XMLStreamReader getStreamReader(boolean setUseCatalog, boolean useCatalog,\n+            String catalog, String xml, XMLResolver resolver)\n+            throws FileNotFoundException, XMLStreamException {\n+        XMLInputFactory factory = XMLInputFactory.newInstance();\n+        if (catalog != null) {\n+            factory.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+        }\n+\n+        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n+        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n+\n+        if (resolver != null) {\n+            factory.setProperty(XMLInputFactory.RESOLVER, resolver);\n+        }\n+\n+        if (setUseCatalog) {\n+            factory.setProperty(XMLConstants.USE_CATALOG, useCatalog);\n+        }\n+\n+        InputStream entityxml = new FileInputStream(xml);\n+        XMLStreamReader streamReader = factory.createXMLStreamReader(xml, entityxml);\n+        return streamReader;\n+    }\n+\n+\n+    \/**\n+     * Returns the accumulated text of an event type.\n+     *\n+     * @param streamReader the XMLStreamReader\n+     * @param type the type of event requested\n+     * @return the text of the accumulated text for the request type\n+     * @throws XMLStreamException\n+     *\/\n+    String getText(XMLStreamReader streamReader, int type) throws XMLStreamException {\n+        StringBuilder text = new StringBuilder();\n+        StringBuilder entityRef = new StringBuilder();\n+\n+        while(streamReader.hasNext()){\n+            int eventType = streamReader.next();\n+            switch (eventType) {\n+                case XMLStreamConstants.START_ELEMENT:\n+                    break;\n+                case XMLStreamConstants.CHARACTERS:\n+                    text.append(streamReader.getText());\n+                    break;\n+                case XMLStreamConstants.ENTITY_REFERENCE:\n+                    entityRef.append(streamReader.getText());\n+                    break;\n+            }\n+        }\n+        if (type == XMLStreamConstants.CHARACTERS) {\n+            return text.toString();\n+        } else {\n+            return entityRef.toString();\n+        }\n+    }\n+\n+    \/**\n+     * Build a Source for _xmlFile depending on the value of sourceType.\n+     * @return\n+     * @throws FileNotFoundException\n+     * @throws XMLStreamException\n+     *\/\n+    private Source getSource(SourceType sourceType, String xmlFile)\n+            throws FileNotFoundException, XMLStreamException {\n+        if (sourceType == null) {\n+            throw new Error(\"Test Bug: Please check that sourceType is set\");\n+        }\n+        switch(sourceType) {\n+            case SAX: return new SAXSource(new InputSource(xmlFile));\n+            case STAX: return new StAXSource(XMLInputFactory.newFactory()\n+                    .createXMLEventReader(xmlFile, new FileInputStream(xmlFile)));\n+            case DOM: return new DOMSource(null,xmlFile);\n+            default: return new StreamSource(xmlFile);\n+        }\n+    }\n+\n+    \/**\n+     * Sets the System Property via the System Property API and\/or the Config file.\n+     *\n+     * @param config the configuration file setting\n+     * @param state the setting method\n+     * @param sysProp properties to be set through the System Property API\n+     *\/\n+    protected void setSystemProperty(Properties config, PropertyState state, Properties[] sysProp) {\n+        \/\/ no System Property\n+        if (state == null) return;\n+        if (sysProp != null) {\n+            for (Properties property : sysProp) {\n+                setSystemProperty1(config, state, property);\n+            }\n+        } else {\n+            setSystemProperty1(config, state, null);\n+        }\n+    }\n+\n+    protected void setSystemProperty1(Properties config, PropertyState state, Properties property) {\n+        switch (state) {\n+            case SYSTEM:\n+                System.setProperty(property.spName, property.value);\n+                break;\n+            case CONFIG_FILE:\n+                System.setProperty(CONFIG_FILE, config.value);\n+                break;\n+            case CONFIG_FILE_SYSTEM:\n+            case CONFIG_FILE_SYSTEM_API:\n+                System.setProperty(CONFIG_FILE, config.value);\n+                if (property != null) {\n+                    System.setProperty(property.spName, property.value);\n+                }\n+                break;\n+        }\n+    }\n+\n+    \/**\n+     * Clears the System Properties.\n+     *\n+     * @param state the state of setting, refer to {@link PropertyState}.\n+     * @param sysProp the system properties\n+     *\/\n+    protected void clearSystemProperty(PropertyState state, Properties[] sysProp) {\n+        if (state == null) return;\n+        if (sysProp != null) {\n+            for (Properties property : sysProp) {\n+                clearSystemProperty1(state, property);\n+            }\n+        } else {\n+            clearSystemProperty1(state, null);\n+        }\n+    }\n+    protected void clearSystemProperty1(PropertyState m, Properties property) {\n+        if (m == null) return;\n+        switch (m) {\n+            case SYSTEM:\n+                System.clearProperty(property.spName);\n+                break;\n+            case CONFIG_FILE:\n+                System.clearProperty(CONFIG_FILE);\n+                break;\n+            case CONFIG_FILE_SYSTEM:\n+            case CONFIG_FILE_SYSTEM_API:\n+                System.clearProperty(CONFIG_FILE);\n+                if (property != null) {\n+                    System.clearProperty(property.spName);\n+                }\n+                break;\n+        }\n+    }\n+\n+    static String getPath(String file) {\n+        String temp = TEST_SOURCE_DIR + file;\n+        if (IS_WINDOWS) {\n+            temp = \"\/\" + temp;\n+        }\n+        return temp;\n+    }\n+\n+    static class Assert {\n+        public static void assertTrue(boolean condition) {\n+            assertTrue(condition, null);\n+        }\n+\n+        public static void assertTrue(boolean condition, String message) {\n+            if (!condition) {\n+                if (message != null) {\n+                    throw new RuntimeException(\"Expected true but was false. \" + message);\n+                } else {\n+                    throw new RuntimeException(\"Expected true but was false. \");\n+                }\n+            }\n+        }\n+\n+        public static void fail(String message) {\n+            throw new RuntimeException(\"Test failed. \" + message);\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/util\/TestBase.java","additions":635,"deletions":0,"binary":false,"changes":635,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+<?xml version=\"1.1\"?>\n+<!DOCTYPE top SYSTEM 'test.dtd'\n+[\n+    <!ENTITY % pe \"x\">\n+    <!ENTITY   x \"AAAAA\">\n+    <!ENTITY   x1 \"BBB\">\n+        ]>\n+<xsd:schema xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+            targetNamespace=\"http:\/\/www.company.org\"\n+            xmlns=\"http:\/\/www.company.org\"\n+            elementFormDefault=\"unqualified\"\n+            xmlns:per=\"http:\/\/www.person.org\"\n+            xmlns:pro=\"http:\/\/www.product.org\">\n+    <xsd:import namespace=\"http:\/\/www.person.org\"\n+                schemaLocation=\"XSDImport_person.xsd\"\/>\n+    <xsd:import namespace=\"http:\/\/www.product.org\"\n+                schemaLocation=\"XSDImport_product.xsd\"\/>\n+    <xsd:element name=\"Company\">\n+        <xsd:complexType>\n+            <xsd:sequence>\n+                <xsd:element name=\"Person\" type=\"per:PersonType\" \n+                             maxOccurs=\"unbounded\"\/>\n+                <xsd:element name=\"Product\" type=\"pro:ProductType\" \n+                             maxOccurs=\"unbounded\"\/>\n+            <\/xsd:sequence>\n+        <\/xsd:complexType>\n+    <\/xsd:element>\n+<\/xsd:schema>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSDImport_company.xsd","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+<?xml version=\"1.1\"?>\n+<xsd:schema xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+            targetNamespace=\"http:\/\/www.person.org\"\n+            xmlns=\"http:\/\/www.person.org\"\n+            elementFormDefault=\"unqualified\">\n+    <xsd:complexType name=\"PersonType\">\n+        <xsd:sequence>\n+           <xsd:element name=\"Name\" type=\"xsd:string\"\/>\n+           <xsd:element name=\"SSN\" type=\"xsd:string\"\/>\n+        <\/xsd:sequence>\n+    <\/xsd:complexType>\n+<\/xsd:schema>\n\\ No newline at end of file\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSDImport_person.xsd","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+<?xml version=\"1.1\"?>\n+<xsd:schema xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+            targetNamespace=\"http:\/\/www.product.org\"\n+            xmlns=\"http:\/\/www.product.org\"\n+            elementFormDefault=\"unqualified\">\n+    <xsd:complexType name=\"ProductType\">\n+        <xsd:sequence>\n+           <xsd:element name=\"Type\" type=\"xsd:string\"\/>\n+        <\/xsd:sequence>\n+    <\/xsd:complexType>\n+<\/xsd:schema>\n\\ No newline at end of file\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSDImport_product.xsd","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+<?xml version=\"1.1\"?>\n+<!DOCTYPE top SYSTEM 'test.dtd'\n+[\n+    <!ENTITY % pe \"x\">\n+    <!ENTITY   x \"AAAAA\">\n+    <!ENTITY   x1 \"BBB\">\n+        ]>\n+<xsd:schema xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+            targetNamespace=\"http:\/\/www.company.org\"\n+            xmlns=\"http:\/\/www.company.org\"\n+            elementFormDefault=\"qualified\">\n+    <xsd:include schemaLocation=\"XSDInclude_person.xsd\"\/>\n+    <xsd:include schemaLocation=\"XSDInclude_product.xsd\"\/>\n+    <xsd:element name=\"Company\">\n+        <xsd:complexType>\n+            <xsd:sequence>\n+                <xsd:element name=\"Person\" type=\"PersonType\"\n+                             maxOccurs=\"unbounded\"\/>\n+                <xsd:element name=\"Product\" type=\"ProductType\"\n+                             maxOccurs=\"unbounded\"\/>\n+            <\/xsd:sequence>\n+        <\/xsd:complexType>\n+    <\/xsd:element>\n+<\/xsd:schema>\n\\ No newline at end of file\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSDInclude_company.xsd","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSDInclude_person.xsd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/XSDInclude_person.xsd","status":"copied"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSDInclude_product.xsd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/XSDInclude_product.xsd","status":"copied"},{"patch":"@@ -0,0 +1,108 @@\n+<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n+<!-- Portions (C) International Organization for Standardization 1986\n+     Permission to copy in any form is granted for use with\n+     conforming SGML systems and applications as defined in\n+     ISO 8879, provided this notice is included in all copies.\n+-->\n+<!-- Character entity set. Typical invocation:\n+     <!ENTITY % HTMLlat1 PUBLIC\n+       \"-\/\/W3C\/\/ENTITIES Latin 1\/\/EN\/\/HTML\">\n+     %HTMLlat1;\n+-->\n+\n+<!ENTITY nbsp   \"&#160;\" >\n+<!ENTITY iexcl  \"&#161;\" >\n+<!ENTITY cent   \"&#162;\" >\n+<!ENTITY pound  \"&#163;\" >\n+<!ENTITY curren \"&#164;\" >\n+<!ENTITY yen    \"&#165;\" >\n+<!ENTITY brvbar \"&#166;\" >\n+<!ENTITY sect   \"&#167;\" >\n+<!ENTITY uml    \"&#168;\" >\n+<!ENTITY copy   \"&#169;\" >\n+<!ENTITY ordf   \"&#170;\" >\n+<!ENTITY laquo  \"&#171;\" >\n+<!ENTITY not    \"&#172;\" >\n+<!ENTITY shy    \"&#173;\" >\n+<!ENTITY reg    \"&#174;\" >\n+<!ENTITY macr   \"&#175;\" >\n+<!ENTITY deg    \"&#176;\" >\n+<!ENTITY plusmn \"&#177;\" >\n+<!ENTITY sup2   \"&#178;\" >\n+<!ENTITY sup3   \"&#179;\" >\n+<!ENTITY acute  \"&#180;\" >\n+<!ENTITY micro  \"&#181;\" >\n+<!ENTITY para   \"&#182;\" >\n+<!ENTITY middot \"&#183;\" >\n+<!ENTITY cedil  \"&#184;\" >\n+<!ENTITY sup1   \"&#185;\" >\n+<!ENTITY ordm   \"&#186;\" >\n+<!ENTITY raquo  \"&#187;\" >\n+<!ENTITY frac14 \"&#188;\" >\n+<!ENTITY frac12 \"&#189;\" >\n+<!ENTITY frac34 \"&#190;\" >\n+<!ENTITY iquest \"&#191;\" >\n+<!ENTITY Agrave \"&#192;\" >\n+<!ENTITY Aacute \"&#193;\" >\n+<!ENTITY Acirc  \"&#194;\" >\n+<!ENTITY Atilde \"&#195;\" >\n+<!ENTITY Auml   \"&#196;\" >\n+<!ENTITY Aring  \"&#197;\" >\n+<!ENTITY AElig  \"&#198;\" >\n+<!ENTITY Ccedil \"&#199;\" >\n+<!ENTITY Egrave \"&#200;\" >\n+<!ENTITY Eacute \"&#201;\" >\n+<!ENTITY Ecirc  \"&#202;\" >\n+<!ENTITY Euml   \"&#203;\" >\n+<!ENTITY Igrave \"&#204;\" >\n+<!ENTITY Iacute \"&#205;\" >\n+<!ENTITY Icirc  \"&#206;\" >\n+<!ENTITY Iuml   \"&#207;\" >\n+<!ENTITY ETH    \"&#208;\" >\n+<!ENTITY Ntilde \"&#209;\" >\n+<!ENTITY Ograve \"&#210;\" >\n+<!ENTITY Oacute \"&#211;\" >\n+<!ENTITY Ocirc  \"&#212;\" >\n+<!ENTITY Otilde \"&#213;\" >\n+<!ENTITY Ouml   \"&#214;\" >\n+<!ENTITY times  \"&#215;\" >\n+<!ENTITY Oslash \"&#216;\" >\n+<!ENTITY Ugrave \"&#217;\" >\n+<!ENTITY Uacute \"&#218;\" >\n+<!ENTITY Ucirc  \"&#219;\" >\n+<!ENTITY Uuml   \"&#220;\" >\n+<!ENTITY Yacute \"&#221;\" >\n+<!ENTITY THORN  \"&#222;\" >\n+<!ENTITY szlig  \"&#223;\" >\n+<!ENTITY agrave \"&#224;\" >\n+<!ENTITY aacute \"&#225;\" >\n+<!ENTITY acirc  \"&#226;\" >\n+<!ENTITY atilde \"&#227;\" >\n+<!ENTITY auml   \"&#228;\" >\n+<!ENTITY aring  \"&#229;\" >\n+<!ENTITY aelig  \"&#230;\" >\n+<!ENTITY ccedil \"&#231;\" >\n+<!ENTITY egrave \"&#232;\" >\n+<!ENTITY eacute \"&#233;\" >\n+<!ENTITY ecirc  \"&#234;\" >\n+<!ENTITY euml   \"&#235;\" >\n+<!ENTITY igrave \"&#236;\" >\n+<!ENTITY iacute \"&#237;\" >\n+<!ENTITY icirc  \"&#238;\" >\n+<!ENTITY iuml   \"&#239;\" >\n+<!ENTITY eth    \"&#240;\" >\n+<!ENTITY ntilde \"&#241;\" >\n+<!ENTITY ograve \"&#242;\" >\n+<!ENTITY oacute \"&#243;\" >\n+<!ENTITY ocirc  \"&#244;\" >\n+<!ENTITY otilde \"&#245;\" >\n+<!ENTITY ouml   \"&#246;\" >\n+<!ENTITY divide \"&#247;\" >\n+<!ENTITY oslash \"&#248;\" >\n+<!ENTITY ugrave \"&#249;\" >\n+<!ENTITY uacute \"&#250;\" >\n+<!ENTITY ucirc  \"&#251;\" >\n+<!ENTITY uuml   \"&#252;\" >\n+<!ENTITY yacute \"&#253;\" >\n+<!ENTITY thorn  \"&#254;\" >\n+<!ENTITY yuml   \"&#255;\" >\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSLDTD.dtd","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+<?xml version=\"1.1\"?>\n+<!DOCTYPE top SYSTEM 'test.dtd'\n+[\n+    <!ENTITY % pe \"x\">\n+    <!ENTITY   x \"AAAAA\">\n+    <!ENTITY   x1 \"BBB\">\n+        ]>\n+<doc><\/doc>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSLDTD.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+<?xml version=\"1.1\" encoding=\"ISO-8859-1\" standalone=\"no\"?>\n+<!DOCTYPE HTMLlat1 SYSTEM \"XSLDTD.dtd\">\n+<xsl:stylesheet xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" version=\"1.0\">\n+\n+  <!-- FileName: copy20 -->\n+  <!-- Document: http:\/\/www.w3.org\/TR\/xslt -->\n+  <!-- DocVersion: 19991116 -->\n+  <!-- Section: 11.3 -->\n+  <!-- Creator: David Marston -->\n+  <!-- Purpose: Test copy-of a string constant containing character entity -->\n+\n+<xsl:output method=\"xml\" encoding=\"UTF-8\"\/>\n+<!-- With this output encoding, should get two bytes (xC3,xA6) for the &aelig -->\n+\n+<xsl:template match=\"\/\">\n+  <out>\n+    <xsl:copy-of select=\"'abcd&aelig;fgh'\"\/>\n+  <\/out>\n+<\/xsl:template>\n+\n+<\/xsl:stylesheet>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSLDTD.xsl","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n+<!DOCTYPE doc SYSTEM 'test.dtd'\n+[\n+    <!ENTITY % pe \"x\">\n+    <!ENTITY   x \"AAAAA\">\n+    <!ENTITY   x1 \"BBB\">\n+        ]>\n+<doc\/>\n\\ No newline at end of file\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSLPI.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+<?xml version='1.1'?>\r\n+<?xml-stylesheet href=\"XSLPI_target.xsl\" type=\"text\/xml\"?>\r\n+<xsl:stylesheet \r\n+    xmlns:xsl='http:\/\/www.w3.org\/1999\/XSL\/Transform' \r\n+    version='1.0'>\r\n+<\/xsl:stylesheet>\n\\ No newline at end of file\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSLPI.xsl","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+<?xml version=\"1.1\" encoding=\"UTF-8\"?>\r\n+<xsl:stylesheet xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" version=\"1.0\">\r\n+\r\n+  <xsl:template match=\"footer\">\r\n+   <dv id=\"footer\"><xsl:apply-templates\/><\/dv>\r\n+  <\/xsl:template>\r\n+\r\n+\r\n+<\/xsl:stylesheet>\n\\ No newline at end of file\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSLPI_target.xsl","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!DOCTYPE properties SYSTEM \"http:\/\/java.sun.com\/dtd\/properties.dtd\">\n+<properties>\n+    <comment>java.util.Properties<\/comment>\n+    <entry key=\"property1\">value1<\/entry>\n+    <entry key=\"property2\">value2<\/entry>\n+    <entry key=\"property3\">value3<\/entry>\n+<\/properties>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/properties.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!DOCTYPE properties SYSTEM \"http:\/\/invalid.site.com\/dtd\/properties1.dtd\"\n+[\n+    <!ENTITY % pe \"x\">\n+    <!ENTITY   x \"AAAAA\">\n+    <!ENTITY   x1 \"BBB\">\n+        ]>\n+<properties>\n+    <comment>java.util.Properties<\/comment>\n+    <entry key=\"property1\">value1<\/entry>\n+    <entry key=\"property2\">value2<\/entry>\n+    <entry key=\"property3\">value3<\/entry>\n+<\/properties>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/properties1.xml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+\r\n+<!ENTITY % bltin \"&#42;\">\r\n+<!ENTITY % pe \"x\">\r\n+\r\n+<!ELEMENT top (#PCDATA)>\r\n+\r\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/test.dtd","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+<?xml version=\"1.1\"?>\n+<!DOCTYPE top SYSTEM 'test.dtd'\n+[\n+    <!ENTITY % pe \"x\">\n+    <!ENTITY   x \"AAAAA\">\n+    <!ENTITY   x1 \"BBB\">\n+        ]>\n+<test:root xmlns:test=\"test\"\n+            xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+            xsi:schemaLocation=\"test val_test.xsd\"\n+            xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\">\n+   <child xsi:type=\"xsd:string\">&x1;<\/child>\n+<\/test:root>\n\\ No newline at end of file\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/val_test.xml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+<?xml version=\"1.1\"?>\n+<xsd:schema xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+             targetNamespace=\"test\">\n+     <xsd:element name=\"root\">\n+         <xsd:complexType>\n+             <xsd:sequence>\n+                 <xsd:element name=\"child\" type=\"xsd:anyType\"\/>\n+             <\/xsd:sequence>\n+         <\/xsd:complexType>\n+\n+         <xsd:key name=\"key1\">\n+             <xsd:selector xpath=\".\"\/>\n+             <xsd:field xpath=\"child\"\/>\n+         <\/xsd:key>\n+     <\/xsd:element>\n+<\/xsd:schema>\n\\ No newline at end of file\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/val_test.xsd","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"}]}