{"files":[{"patch":"@@ -825,2 +825,2 @@\n-  if (cause != NULL) {\n-    cause_sym = cause == NULL ? NULL : cause->klass()->name();\n+  if (cause != NULL && cause != pending_exception) {\n+    cause_sym = cause->klass()->name();\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.internal.org.objectweb.asm.*;\n-\n-public class AsmClasses implements Opcodes {\n-\n-    \/\/ class B extends A {}\n-    public static byte[] dumpB() throws Exception {\n-\n-        ClassWriter classWriter = new ClassWriter(0);\n-        FieldVisitor fieldVisitor;\n-        RecordComponentVisitor recordComponentVisitor;\n-        MethodVisitor methodVisitor;\n-        AnnotationVisitor annotationVisitor0;\n-\n-        classWriter.visit(61, ACC_PUBLIC | ACC_SUPER, \"B\", null, \"A\", null);\n-\n-        classWriter.visitSource(\"B.java\", null);\n-        methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        methodVisitor.visitCode();\n-        Label label0 = new Label();\n-        methodVisitor.visitLabel(label0);\n-        methodVisitor.visitLineNumber(24, label0);\n-        methodVisitor.visitVarInsn(ALOAD, 0);\n-        methodVisitor.visitMethodInsn(INVOKESPECIAL, \"A\", \"<init>\", \"()V\", false);\n-        methodVisitor.visitInsn(RETURN);\n-        methodVisitor.visitMaxs(1, 1);\n-        methodVisitor.visitEnd();\n-        classWriter.visitEnd();\n-\n-        return classWriter.toByteArray();\n-    }\n-\n-    \/\/ public class A extends C {\n-    \/\/     public A(boolean okSuper) {\n-    \/\/        System.out.println(\"A extends C\");\n-    \/\/        if (okSuper) {\n-    \/\/            throw new RuntimeException(\"Should not call this\");\n-    \/\/        }\n-    \/\/     }\n-    \/\/ }\n-    public static byte[] dumpA() throws Exception {\n-\n-        ClassWriter classWriter = new ClassWriter(0);\n-        FieldVisitor fieldVisitor;\n-        RecordComponentVisitor recordComponentVisitor;\n-        MethodVisitor methodVisitor;\n-        AnnotationVisitor annotationVisitor0;\n-\n-        classWriter.visit(61, ACC_PUBLIC | ACC_SUPER, \"A\", null, \"C\", null);\n-\n-        classWriter.visitSource(\"A.java\", null);\n-\n-        {\n-        methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"(Z)V\", null, null);\n-        methodVisitor.visitCode();\n-        Label label0 = new Label();\n-        methodVisitor.visitLabel(label0);\n-        methodVisitor.visitLineNumber(25, label0);\n-        methodVisitor.visitVarInsn(ALOAD, 0);\n-        methodVisitor.visitMethodInsn(INVOKESPECIAL, \"C\", \"<init>\", \"()V\", false);\n-        Label label1 = new Label();\n-        methodVisitor.visitLabel(label1);\n-        methodVisitor.visitLineNumber(26, label1);\n-        methodVisitor.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-        methodVisitor.visitLdcInsn(\"A extends C\");\n-        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false);\n-        Label label2 = new Label();\n-        methodVisitor.visitLabel(label2);\n-        methodVisitor.visitLineNumber(27, label2);\n-        methodVisitor.visitVarInsn(ILOAD, 1);\n-        Label label3 = new Label();\n-        methodVisitor.visitJumpInsn(IFEQ, label3);\n-        Label label4 = new Label();\n-        methodVisitor.visitLabel(label4);\n-        methodVisitor.visitLineNumber(28, label4);\n-        methodVisitor.visitTypeInsn(NEW, \"java\/lang\/RuntimeException\");\n-        methodVisitor.visitInsn(DUP);\n-        methodVisitor.visitLdcInsn(\"Should not call this\");\n-        methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/RuntimeException\", \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        methodVisitor.visitInsn(ATHROW);\n-        methodVisitor.visitLabel(label3);\n-        methodVisitor.visitLineNumber(30, label3);\n-        methodVisitor.visitFrame(Opcodes.F_FULL, 2, new Object[] {\"A\", Opcodes.INTEGER}, 0, new Object[] {});\n-        methodVisitor.visitInsn(RETURN);\n-        methodVisitor.visitMaxs(3, 2);\n-        methodVisitor.visitEnd();\n-        }\n-        classWriter.visitEnd();\n-\n-        return classWriter.toByteArray();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/AsmClasses.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-class ClassLoadingThread extends Thread {\n-\n-    private ClassLoader ldr = null;\n-    private Object thread_sync = null;\n-    private boolean okSuper = false;\n-\n-    \/** Debug messages printing *\/\n-    private static void println(String s) {\n-        System.out.println(Thread.currentThread().getName() + \": \" + s);\n-        System.out.flush();\n-    }\n-\n-    public ClassLoadingThread(ClassLoader loader, Object sync, boolean super_is_ok) {\n-        ldr = loader;\n-        thread_sync = sync;\n-        okSuper = super_is_ok;\n-    }\n-\n-    private boolean success = true;\n-    public boolean report_success() { return success; }\n-\n-    public void run() {\n-        try {\n-            println(\"Starting...\");\n-            \/\/ Initiate class loading using specified type\n-            Class<?> a = Class.forName(\"ClassInLoader\", true, ldr);\n-            Object obj = a.getConstructor(boolean.class).newInstance(okSuper);\n-\n-        } catch (Throwable e) {\n-            println(\"Exception is caught: \" + e);\n-            e.printStackTrace();\n-            success = false;\n-        } finally {\n-            println(\"Finished\");\n-            synchronized (thread_sync) {\n-                thread_sync.notify();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ClassLoadingThread.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,168 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-\n-class MyLoader extends ClassLoader {\n-    static {\n-        registerAsParallelCapable();\n-    }\n-\n-    public Class loadClass(String name) throws ClassNotFoundException {\n-        synchronized(getClassLoadingLock(name)) {\n-            Class<?> c = findLoadedClass(name);\n-            if (c != null) return c;\n-\n-            byte[] b = loadClassData(name);\n-            if (b != null) {\n-                return defineClass(name, b, 0, b.length);\n-            } else {\n-                return super.loadClass(name);\n-            }\n-        }\n-    }\n-\n-    private static boolean waitForSuper = false;\n-    private static boolean concurrent = false;\n-    private static boolean okSuper = false;\n-    private static boolean first = true;\n-    private Object sync = new Object();\n-    private Object thread_sync = new Object();\n-\n-    private void makeThreadWait() {\n-         first = false;  \/\/ second thread gets a different A\n-         if (waitForSuper) {\n-            \/\/ Wake up the first thread here.\n-            synchronized (thread_sync) {\n-                thread_sync.notify();\n-            }\n-        }\n-        if (isRegisteredAsParallelCapable()) {\n-            synchronized(sync) {\n-                try {\n-                    System.out.println(\"t1 waits parallelCapable loader\");\n-                    sync.wait(100);  \/\/ Give up lock after request to load B\n-                } catch (InterruptedException e) {}\n-             }\n-         } else {\n-             try {\n-                System.out.println(\"t1 waits non-parallelCapable loader\");\n-                wait(100);  \/\/ Give up lock after request to load B\n-              } catch (InterruptedException e) {}\n-         }\n-    }\n-\n-    private byte[] loadClassData(String name) {\n-        \/\/ load the class data from the connection\n-        if (name.equals(\"A\")) {\n-            if (first) {\n-                System.out.println(\"loading A extends B\");\n-                return getClassData(\"A\");\n-            } else {\n-                System.out.println(\"loading A extends C\");\n-                byte[] data;\n-                try {\n-                    data = AsmClasses.dumpA();\n-                } catch (Exception e) {\n-                    data = null;\n-                }\n-                return data;\n-            }\n-        } else if (name.equals(\"B\")) {\n-            byte[] data;\n-            if (okSuper) {\n-                data = getClassData(\"B\");\n-            } else {\n-                try {\n-                    data = AsmClasses.dumpB();\n-                } catch (Exception e) {\n-                    data = null;\n-                    e.printStackTrace();\n-                }\n-            }\n-            if (first) makeThreadWait();\n-            return data;\n-        } else if (name.equals(\"C\")) {\n-            byte[] data = getClassData(\"C\");\n-            makeThreadWait();\n-            return data;\n-        } else {\n-            return getClassData(name);\n-        }\n-    }\n-\n-    byte[] getClassData(String name) {\n-        try {\n-           String TempName = name;\n-           String currentDir = System.getProperty(\"test.classes\");\n-           String filename = currentDir + File.separator + TempName + \".class\";\n-\n-           FileInputStream fis = new FileInputStream(filename);\n-           byte[] b = new byte[5000];\n-           int cnt = fis.read(b, 0, 5000);\n-           byte[] c = new byte[cnt];\n-           for (int i=0; i<cnt; i++) c[i] = b[i];\n-             return c;\n-        } catch (IOException e) {\n-           return null;\n-        }\n-    }\n-\n-    ClassLoadingThread[] threads = new ClassLoadingThread[2];\n-    private boolean success = true;\n-\n-    public boolean report_success() {\n-        for (int i = 0; i < 2; i++) {\n-          try {\n-            threads[i].join();\n-            if (!threads[i].report_success()) success = false;\n-          } catch (InterruptedException e) {}\n-        }\n-        return success;\n-    }\n-\n-    void startLoading() {\n-\n-        for (int i = 0; i < 2; i++) {\n-            threads[i] = new ClassLoadingThread(this, thread_sync, okSuper);\n-            threads[i].setName(\"Loading Thread #\" + (i + 1));\n-            threads[i].start();\n-            System.out.println(\"Thread \" + (i + 1) + \" was started...\");\n-            \/\/ wait to start the second thread if not concurrent\n-            if (!concurrent && i == 0) {\n-                synchronized(thread_sync) {\n-                    try {\n-                        System.out.println(\"t2 waits\");\n-                        thread_sync.wait();\n-                    } catch (InterruptedException e) {}\n-                }\n-            }\n-        }\n-    }\n-\n-    MyLoader(boolean load_in_parallel, boolean wait_for_super, boolean load_different_super) {\n-       concurrent = load_in_parallel;\n-       waitForSuper = wait_for_super;\n-       okSuper = load_different_super;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoader.java","additions":0,"deletions":168,"binary":false,"changes":168,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test MyLoaderTest\n- * @bug 8262046\n- * @summary Call handle_parallel_super_load, loading parallel threads that throw CCE\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile -XDignore.symbol.file AsmClasses.java\n- * @compile classfiles\/ClassInLoader.java classfiles\/A.java classfiles\/B.java classfiles\/C.java\n- * @run main\/othervm MyLoaderTest\n- * @run main\/othervm MyLoaderTest -waitForSuper\n- * @run main\/othervm MyLoaderTest -parallelCapable\n- * @run main\/othervm MyLoaderTest -waitForSuper -parallelCapable\n- * @run main\/othervm MyLoaderTest -okSuper\n- * @run main\/othervm MyLoaderTest -waitForSuper -okSuper\n- * @run main\/othervm MyLoaderTest -waitForSuper -parallelCapable -okSuper\n- * @run main\/othervm MyLoaderTest -concurrent\n- * @run main\/othervm MyLoaderTest -concurrent -parallelCapable\n- *\/\n-\n-public class MyLoaderTest {\n-    public static void main(java.lang.String[] args) throws Exception {\n-        boolean concurrent = false;\n-        boolean waitForSuper = false;\n-        boolean okSuper = false;\n-        boolean parallelCapable = false;\n-        boolean success = true;\n-        for (int i = 0; i < args.length; i++) {\n-            try {\n-                \/\/ Don't print debug info\n-                if (args[i].equals(\"-concurrent\")) {\n-                    concurrent = true;\n-                } else if (args[i].equals(\"-okSuper\")) {\n-                    okSuper = true;\n-                } else if (args[i].equals(\"-parallelCapable\")) {\n-                    parallelCapable = true;\n-                } else if (args[i].equals(\"-waitForSuper\")) {\n-                    waitForSuper = true;\n-                } else {\n-                    System.out.println(\"Unrecognized \" + args[i]);\n-                }\n-            } catch (NumberFormatException e) {\n-                System.err.println(\"Invalid parameter: \" + args[i - 1] + \" \" + args[i]);\n-            }\n-        }\n-        if (parallelCapable) {\n-            MyLoader ldr = new MyLoader(concurrent, waitForSuper, okSuper);\n-            ldr.startLoading();\n-            success = ldr.report_success();\n-        } else {\n-            MyNonParallelLoader ldr = new MyNonParallelLoader(concurrent, waitForSuper, okSuper);\n-            ldr.startLoading();\n-            success = ldr.report_success();\n-        }\n-        if (success) {\n-            System.out.println(\"PASSED\");\n-        } else {\n-            throw new RuntimeException(\"FAILED\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoaderTest.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-class MyNonParallelLoader extends MyLoader {\n-    \/\/ This loader isn't parallel capable because it's not registered in the static\n-    \/\/ initializer as such.  parallelCapable is not an inheritable attribute.\n-    MyNonParallelLoader(boolean load_in_parallel, boolean wait_for_super, boolean load_different_super2) {\n-       super(load_in_parallel, wait_for_super, load_different_super2);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyNonParallelLoader.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262046\n+ * @summary JVMS 5.4.3 If an attempt by the Java Virtual Machine to resolve a symbolic reference fails\n+ *          because an error is thrown that is an instance of LinkageError (or a subclass), then subsequent\n+ *          attempts to resolve the reference always fail with the same error that was thrown as a result of\n+ *          the initial resolution attempt.\n+ * @run main\/othervm SaveResolutionErrorTest\n+ *\/\n+\n+public class SaveResolutionErrorTest {\n+    static byte classfile_for_Tester[];\n+    static byte classfile_for_Loadee[];\n+\n+    public static void main(java.lang.String[] args) throws Exception {\n+        ClassLoader appLoader = SaveResolutionErrorTest.class.getClassLoader();\n+        classfile_for_Tester = appLoader.getResourceAsStream(\"SaveResolutionErrorTest$Tester.class\").readAllBytes();\n+        classfile_for_Loadee = appLoader.getResourceAsStream(\"SaveResolutionErrorTest$Loadee.class\").readAllBytes();\n+\n+        long started = System.currentTimeMillis();\n+        for (int i = 0; i < 1000; i++) {\n+            System.out.println(\"Test: \" + i);\n+            MyLoader loader = new MyLoader(appLoader);\n+            loader.doTest();\n+\n+            if (System.currentTimeMillis() - started > 100000) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Succeed\");\n+    }\n+\n+    public static class Tester extends Thread {\n+        static int errorCount = 0;\n+        synchronized static void incrError() {\n+            ++ errorCount;\n+        }\n+\n+        public volatile static boolean go = false;\n+\n+        public static void doit() throws Exception {\n+            System.out.println(Tester.class.getClassLoader());\n+\n+            Thread t1 = new Tester();\n+            Thread t2 = new Tester();\n+\n+            t1.start();\n+            t2.start();\n+\n+            go = true;\n+\n+            t1.join();\n+            t2.join();\n+\n+\n+            System.out.println(\"errorCount = \" + errorCount);\n+\n+            if (errorCount != 0 && errorCount != 2) {\n+                throw new RuntimeException(\"errorCount should be 0 or 2 but is \" + errorCount);\n+            }\n+        }\n+\n+        static int foobar;\n+        static boolean debug = false;\n+\n+        public void run() {\n+            while (!go) { Thread.onSpinWait(); }\n+\n+            try {\n+                \/\/ The first thread who tries to resolve the CP entry for the \"Loadee\" class\n+                \/\/ should (most likely) result in a resolution error. This error, if it has\n+                \/\/ happened, must also be reported by the second thread.\n+                \/\/\n+                \/\/ In some rare conditions, the resolution may succeed. In this case, both\n+                \/\/ threads must succeed. The reasons is:\n+                \/\/\n+                \/\/     The first thread who tries to resolve the CP entry gets a bad class, but\n+                \/\/     when it tries to update the CP entry, the second thread has already succeeded in\n+                \/\/     loading the class and has set the entry's tag to JVM_CONSTANT_Class.\n+\n+                foobar += Loadee.value;\n+            } catch (Throwable t) {\n+                Throwable cause = t.getCause();\n+                if (cause != null) {\n+                    String s = cause.toString();\n+                    if (s.equals(t.toString())) { \/\/ wrong cause\n+                        t.printStackTrace();\n+                        throw new RuntimeException(\"wrong cause\");\n+                    }\n+                }\n+                if (debug) {\n+                    System.out.println(t);\n+                } else {\n+                    synchronized (Tester.class) {\n+                        \/\/ Enable this block to see the stack trace\n+                        System.out.println(\"------\");\n+                        t.printStackTrace();\n+                        System.out.println(\"\");\n+                    }\n+                }\n+                incrError();\n+            }\n+        }\n+    }\n+\n+    public static class Loadee {\n+        static int value = 1234;\n+    }\n+\n+    static class MyLoader extends ClassLoader {\n+        static int count;\n+        static byte[] badclass = {1, 2, 3, 4, 5, 6, 7, 8};\n+\n+        static {\n+            registerAsParallelCapable();\n+        }\n+\n+        ClassLoader parent;\n+\n+        MyLoader(ClassLoader parent) {\n+            this.parent = parent;\n+        }\n+\n+        synchronized boolean hack() {\n+            ++ count;\n+            if ((count % 2) == 1) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        public Class loadClass(String name) throws ClassNotFoundException {\n+            if (name.equals(\"SaveResolutionErrorTest$Loadee\")) {\n+                if (hack()) {\n+                    return defineClass(name, badclass, 0, badclass.length);\n+                } else {\n+                    return defineClass(name, classfile_for_Loadee, 0, classfile_for_Loadee.length);\n+                }\n+            }\n+            if (name.equals(\"SaveResolutionErrorTest$Tester\")) {\n+                return defineClass(name, classfile_for_Tester, 0, classfile_for_Tester.length);\n+            }\n+            return parent.loadClass(name);\n+        }\n+\n+        void doTest() throws Exception {\n+            Class c = Class.forName(\"SaveResolutionErrorTest$Tester\", \/*init=*\/true, this);\n+            java.lang.reflect.Method m = c.getMethod(\"doit\");\n+            m.invoke(null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SaveResolutionErrorTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class A extends B {\n-    public A(boolean okSuper) {\n-       System.out.println(\"A extends B\");\n-       if (!okSuper) {\n-           throw new RuntimeException(\"Should throw CCE here\");\n-       }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/classfiles\/A.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class B { public B() { System.out.println(\"B\"); } }\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/classfiles\/B.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class C { public C() { System.out.println(\"C\"); } }\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/classfiles\/C.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Create a class to load inside the loader instance, that will load\n-\/\/ A through a constant pool reference.\n-\/\/ Through 2 different constant pool references\n-class CP1 {\n-  void foo(boolean okSuper) throws Exception {\n-      System.out.println(\"CP1.foo()\");\n-      try {\n-          Class<?> a = A.class;\n-          Object obj = a.getConstructor(boolean.class).newInstance(okSuper);\n-          if (!okSuper) {\n-              throw new RuntimeException(\"Should throw CCE here\");\n-          }\n-      } catch (Throwable e) {\n-          System.out.println(\"Exception is caught: \" + e);\n-          if (okSuper || !(e instanceof java.lang.ClassCircularityError)) {\n-              throw new RuntimeException(\"Unexpected exception\");\n-          }\n-      }\n-  }\n-}\n-\n-\/\/ This class has a constant pool reference to A also but will load\n-\/\/ the second version of the class if CCE is thrown while loading the\n-\/\/ first version of the class.  Otherwise if okSuper, will load A extends B\n-\/\/ Due to timing, thread 1 might still be loading class A with CCE so this\n-\/\/ could get CCE also.\n-class CP2 {\n-  void foo(boolean okSuper) throws Exception {\n-      System.out.println(\"CP2.foo()\");\n-      try {\n-          Class<?> a = A.class;\n-          Object obj = a.getConstructor(boolean.class).newInstance(okSuper);\n-      } catch (Throwable e) {\n-          System.out.println(\"Exception is caught: \" + e);\n-      }\n-  }\n-}\n-\n-public class ClassInLoader {\n-  public ClassInLoader(boolean okSuper) throws Exception {\n-    System.out.println(\"ClassInLoader\");\n-    CP1 c1 = new CP1();\n-    c1.foo(okSuper);\n-    CP2 c2 = new CP2();\n-    c2.foo(okSuper);\n-  }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/classfiles\/ClassInLoader.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"}]}