{"files":[{"patch":"@@ -661,0 +661,2 @@\n+  } else if (tag.is_unresolved_klass_in_error()) {\n+    return ciConstant();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,0 +236,5 @@\n+  bool is_unresolved_klass_in_error() const {\n+    constantTag tag = get_constant_pool_tag(get_klass_index());\n+    return tag.is_unresolved_klass_in_error();\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -724,11 +724,10 @@\n-  BasicType basic_type = con.basic_type();\n-  if (basic_type == T_ILLEGAL) {\n-    \/\/ OutOfMemoryError in the CI while loading constant\n-    push_null();\n-    outer()->record_failure(\"ldc did not link\");\n-    return;\n-  }\n-  if (is_reference_type(basic_type)) {\n-    ciObject* obj = con.as_object();\n-    if (obj->is_null_object()) {\n-      push_null();\n+  if (con.is_valid()) {\n+    BasicType basic_type = con.basic_type();\n+    if (is_reference_type(basic_type)) {\n+      ciObject* obj = con.as_object();\n+      if (obj->is_null_object()) {\n+        push_null();\n+      } else {\n+        assert(obj->is_instance() || obj->is_array(), \"must be java_mirror of klass\");\n+        push_object(obj->klass());\n+      }\n@@ -736,2 +735,1 @@\n-      assert(obj->is_instance() || obj->is_array(), \"must be java_mirror of klass\");\n-      push_object(obj->klass());\n+      push_translate(ciType::make(basic_type));\n@@ -740,1 +738,8 @@\n-    push_translate(ciType::make(basic_type));\n+    if (str->is_unresolved_klass_in_error()) {\n+      trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                        Deoptimization::Action_none));\n+    } else {\n+      \/\/ OutOfMemoryError in the CI while loading constant\n+      push_null();\n+      outer()->record_failure(\"ldc did not link\");\n+    }\n@@ -2171,0 +2176,2 @@\n+      return str.is_unresolved_klass_in_error();\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1961,0 +1961,1 @@\n+int java_lang_Throwable::_cause_offset;\n@@ -1968,0 +1969,1 @@\n+  macro(_cause_offset,         k, \"cause\",         throwable_signature,               false); \\\n@@ -2008,0 +2010,3 @@\n+oop java_lang_Throwable::cause(oop throwable) {\n+  return throwable->obj_field(_cause_offset);\n+}\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -502,0 +502,1 @@\n+  static int _cause_offset;\n@@ -519,0 +520,1 @@\n+  static oop cause(oop throwable);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/ add new entry to the table\n+\/\/ create new error entry\n@@ -39,1 +39,2 @@\n-                                     Symbol* error, Symbol* message)\n+                                     Symbol* error, Symbol* message,\n+                                     Symbol* cause, Symbol* cause_msg)\n@@ -44,1 +45,8 @@\n-  ResolutionErrorEntry* entry = new_entry(hash, pool(), cp_index, error, message);\n+  ResolutionErrorEntry* entry = (ResolutionErrorEntry*)Hashtable<ConstantPool*, mtClass>::new_entry(hash, pool());\n+  entry->set_cp_index(cp_index);\n+  entry->set_error(error);\n+  entry->set_message(message);\n+  entry->set_nest_host_error(NULL);\n+  entry->set_cause(cause);\n+  entry->set_cause_msg(cause_msg);\n+\n@@ -48,1 +56,1 @@\n-\/\/ add new entry to the table\n+\/\/ create new nest host error entry\n@@ -56,1 +64,8 @@\n-  ResolutionErrorEntry* entry = new_entry(hash, pool(), cp_index, message);\n+  ResolutionErrorEntry* entry = (ResolutionErrorEntry*)Hashtable<ConstantPool*, mtClass>::new_entry(hash, pool());\n+  entry->set_cp_index(cp_index);\n+  entry->set_nest_host_error(message);\n+  entry->set_error(NULL);\n+  entry->set_message(NULL);\n+  entry->set_cause(NULL);\n+  entry->set_cause_msg(NULL);\n+\n@@ -90,2 +105,5 @@\n-void ResolutionErrorEntry::set_nest_host_error(const char* message) {\n-  _nest_host_error = message;\n+void ResolutionErrorEntry::set_cause(Symbol* c) {\n+  _cause = c;\n+  if (_cause != NULL) {\n+    _cause->increment_refcount();\n+  }\n@@ -94,12 +112,5 @@\n-\/\/ create new error entry\n-ResolutionErrorEntry* ResolutionErrorTable::new_entry(int hash, ConstantPool* pool,\n-                                                      int cp_index, Symbol* error,\n-                                                      Symbol* message)\n-{\n-  ResolutionErrorEntry* entry = (ResolutionErrorEntry*)Hashtable<ConstantPool*, mtClass>::new_entry(hash, pool);\n-  entry->set_cp_index(cp_index);\n-  entry->set_error(error);\n-  entry->set_message(message);\n-  entry->set_nest_host_error(NULL);\n-\n-  return entry;\n+void ResolutionErrorEntry::set_cause_msg(Symbol* c) {\n+  _cause_msg = c;\n+  if (_cause_msg != NULL) {\n+    _cause_msg->increment_refcount();\n+  }\n@@ -108,11 +119,2 @@\n-\/\/ create new nest host error entry\n-ResolutionErrorEntry* ResolutionErrorTable::new_entry(int hash, ConstantPool* pool,\n-                                                      int cp_index, const char* message)\n-{\n-  ResolutionErrorEntry* entry = (ResolutionErrorEntry*)Hashtable<ConstantPool*, mtClass>::new_entry(hash, pool);\n-  entry->set_cp_index(cp_index);\n-  entry->set_nest_host_error(message);\n-  entry->set_error(NULL);\n-  entry->set_message(NULL);\n-\n-  return entry;\n+void ResolutionErrorEntry::set_nest_host_error(const char* message) {\n+  _nest_host_error = message;\n@@ -129,0 +131,6 @@\n+  if (entry->cause() != NULL) {\n+    entry->cause()->decrement_refcount();\n+  }\n+  if (entry->cause_msg() != NULL) {\n+    entry->cause_msg()->decrement_refcount();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":38,"deletions":30,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,3 @@\n+private:\n+  void free_entry(ResolutionErrorEntry *entry);\n+\n@@ -47,6 +50,0 @@\n-  ResolutionErrorEntry* new_entry(int hash, ConstantPool* pool, int cp_index,\n-                                  Symbol* error, Symbol* message);\n-  ResolutionErrorEntry* new_entry(int hash, ConstantPool* pool, int cp_index,\n-                                  const char* message);\n-  void free_entry(ResolutionErrorEntry *entry);\n-\n@@ -67,1 +64,2 @@\n-                 const constantPoolHandle& pool, int which, Symbol* error, Symbol* message);\n+                 const constantPoolHandle& pool, int which, Symbol* error, Symbol* message,\n+                 Symbol* cause, Symbol* cause_msg);\n@@ -102,0 +100,2 @@\n+  Symbol*           _cause;\n+  Symbol*           _cause_msg;\n@@ -116,0 +116,6 @@\n+  Symbol*            cause() const              { return _cause; }\n+  void               set_cause(Symbol* c);\n+\n+  Symbol*            cause_msg() const          { return _cause_msg; }\n+  void               set_cause_msg(Symbol* c);\n+\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1986,1 +1986,2 @@\n-                                            Symbol* error, Symbol* message) {\n+                                            Symbol* error, Symbol* message,\n+                                            Symbol* cause, Symbol* cause_msg) {\n@@ -1991,1 +1992,4 @@\n-    resolution_errors()->add_entry(index, hash, pool, which, error, message);\n+    ResolutionErrorEntry* entry = resolution_errors()->find_entry(index, hash, pool, which);\n+    if (entry == NULL) {\n+      resolution_errors()->add_entry(index, hash, pool, which, error, message, cause, cause_msg);\n+    }\n@@ -2002,1 +2006,1 @@\n-                                                Symbol** message) {\n+                                                Symbol** message, Symbol** cause, Symbol** cause_msg) {\n@@ -2010,0 +2014,2 @@\n+      *cause = entry->cause();\n+      *cause_msg = entry->cause_msg();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-                                   Symbol* message);\n+                                   Symbol* message, Symbol* cause = NULL, Symbol* cause_msg = NULL);\n@@ -283,1 +283,1 @@\n-                                       Symbol** message);\n+                                       Symbol** message, Symbol** cause, Symbol** cause_msg);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -538,0 +538,1 @@\n+  template(throwable_signature,                       \"Ljava\/lang\/Throwable;\")                    \\\n@@ -540,1 +541,0 @@\n-  template(throwable_throwable_signature,             \"(Ljava\/lang\/Throwable;)Ljava\/lang\/Throwable;\")             \\\n@@ -545,0 +545,1 @@\n+  template(throwable_throwable_signature,             \"(Ljava\/lang\/Throwable;)Ljava\/lang\/Throwable;\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-                                   bool save_resolution_error, TRAPS) {\n+                                   TRAPS) {\n@@ -497,3 +497,7 @@\n-  Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n-  if (klass != NULL) {\n-    return klass;\n+  \/\/ The tag must be JVM_CONSTANT_Class in order to read the correct value from\n+  \/\/ the unresolved_klasses() array.\n+  if (this_cp->tag_at(which).is_klass()) {\n+    Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    if (klass != NULL) {\n+      return klass;\n+    }\n@@ -538,11 +542,7 @@\n-    if (save_resolution_error) {\n-      save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);\n-      \/\/ If CHECK_NULL above doesn't return the exception, that means that\n-      \/\/ some other thread has beaten us and has resolved the class.\n-      \/\/ To preserve old behavior, we return the resolved class.\n-      klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n-      assert(klass != NULL, \"must be resolved if exception was cleared\");\n-      return klass;\n-    } else {\n-      return NULL;  \/\/ return the pending exception\n-    }\n+    save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);\n+    \/\/ If CHECK_NULL above doesn't return the exception, that means that\n+    \/\/ some other thread has beaten us and has resolved the class.\n+    \/\/ To preserve old behavior, we return the resolved class.\n+    Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    assert(klass != NULL, \"must be resolved if exception was cleared\");\n+    return klass;\n@@ -555,0 +555,1 @@\n+\n@@ -560,1 +561,13 @@\n-  this_cp->release_tag_at_put(which, JVM_CONSTANT_Class);\n+  \/\/ We also need to CAS to not overwrite an error from a racing thread.\n+\n+  jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(which),\n+                                  (jbyte)JVM_CONSTANT_UnresolvedClass,\n+                                  (jbyte)JVM_CONSTANT_Class);\n+\n+  \/\/ We need to recheck exceptions from racing thread and return the same.\n+  if (old_tag == JVM_CONSTANT_UnresolvedClassInError) {\n+    \/\/ Remove klass.\n+    this_cp->resolved_klasses()->at_put(resolved_klass_index, NULL);\n+    throw_resolution_error(this_cp, which, CHECK_NULL);\n+  }\n+\n@@ -575,2 +588,3 @@\n-  Klass* k = this_cp->resolved_klasses()->at(resolved_klass_index);\n-  if (k != NULL) {\n+  if (this_cp->tag_at(which).is_klass()) {\n+    Klass* k = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    assert(k != NULL, \"should be resolved\");\n@@ -578,0 +592,2 @@\n+  } else if (this_cp->tag_at(which).is_unresolved_klass_in_error()) {\n+    return NULL;\n@@ -770,1 +786,1 @@\n-Symbol* ConstantPool::exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n+static Symbol* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n@@ -802,0 +818,19 @@\n+static void add_resolution_error(const constantPoolHandle& this_cp, int which,\n+                                 constantTag tag, oop pending_exception) {\n+\n+  Symbol* error = pending_exception->klass()->name();\n+  oop cause = java_lang_Throwable::cause(pending_exception);\n+\n+  \/\/ Also dig out the exception cause, if present.\n+  Symbol* cause_sym = NULL;\n+  Symbol* cause_msg = NULL;\n+  if (cause != NULL && cause != pending_exception) {\n+    cause_sym = cause->klass()->name();\n+    cause_msg = java_lang_Throwable::detail_message(cause);\n+  }\n+\n+  Symbol* message = exception_message(this_cp, which, tag, pending_exception);\n+  SystemDictionary::add_resolution_error(this_cp, which, error, message, cause_sym, cause_msg);\n+}\n+\n+\n@@ -803,0 +838,1 @@\n+  ResourceMark rm(THREAD);\n@@ -804,1 +840,3 @@\n-  Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &message);\n+  Symbol* cause = NULL;\n+  Symbol* cause_msg = NULL;\n+  Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &message, &cause, &cause_msg);\n@@ -806,0 +844,2 @@\n+  const char* cause_str = cause_msg != NULL ? cause_msg->as_C_string() : NULL;\n+\n@@ -808,2 +848,7 @@\n-    ResourceMark rm;\n-    THROW_MSG(error, message->as_C_string());\n+    char* msg = message->as_C_string();\n+    if (cause != NULL) {\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n+      THROW_MSG_CAUSE(error, msg, h_cause);\n+    } else {\n+      THROW_MSG(error, msg);\n+    }\n@@ -811,1 +856,6 @@\n-    THROW(error);\n+    if (cause != NULL) {\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n+      THROW_CAUSE(error, h_cause);\n+    } else {\n+      THROW(error);\n+    }\n@@ -819,1 +869,0 @@\n-  Symbol* error = PENDING_EXCEPTION->klass()->name();\n@@ -830,2 +879,1 @@\n-    Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);\n-    SystemDictionary::add_resolution_error(this_cp, which, error, message);\n+    add_resolution_error(this_cp, which, tag, PENDING_EXCEPTION);\n@@ -950,1 +998,1 @@\n-      Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);\n+      Klass* resolved = klass_at_impl(this_cp, index, CHECK_NULL);\n@@ -1039,1 +1087,1 @@\n-      Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);\n+      Klass* callee = klass_at_impl(this_cp, callee_index, CHECK_NULL);\n@@ -2339,7 +2387,1 @@\n-\n-        Klass* klass = resolved_klasses()->at(resolved_klass_index);\n-        if (klass != NULL) {\n-          klass->print_value_on(st);\n-        } else {\n-          symbol_at(name_index)->print_value_on(st);\n-        }\n+        symbol_at(name_index)->print_value_on(st);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":77,"deletions":35,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -421,7 +421,1 @@\n-    return klass_at_impl(h_this, which, true, THREAD);\n-  }\n-\n-  \/\/ Version of klass_at that doesn't save the resolution error, called during deopt\n-  Klass* klass_at_ignore_error(int which, TRAPS) {\n-    constantPoolHandle h_this(THREAD, this);\n-    return klass_at_impl(h_this, which, false, THREAD);\n+    return klass_at_impl(h_this, which, THREAD);\n@@ -889,2 +883,1 @@\n-  static Klass* klass_at_impl(const constantPoolHandle& this_cp, int which,\n-                              bool save_resolution_error, TRAPS);\n+  static Klass* klass_at_impl(const constantPoolHandle& this_cp, int which, TRAPS);\n@@ -906,1 +899,0 @@\n-  static Symbol* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1823,1 +1823,1 @@\n-    Klass* tk = constant_pool->klass_at_ignore_error(index, THREAD);\n+    Klass* tk = constant_pool->klass_at(index, THREAD);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262046\n+ * @summary JVMS 5.4.3 If an attempt by the Java Virtual Machine to resolve a symbolic reference fails\n+ *          because an error is thrown that is an instance of LinkageError (or a subclass), then subsequent\n+ *          attempts to resolve the reference always fail with the same error that was thrown as a result of\n+ *          the initial resolution attempt.\n+ * @run main\/othervm SaveResolutionErrorTest\n+ *\/\n+\n+public class SaveResolutionErrorTest {\n+    static byte classfile_for_Tester[];\n+    static byte classfile_for_Loadee[];\n+\n+    public static void main(java.lang.String[] args) throws Exception {\n+        ClassLoader appLoader = SaveResolutionErrorTest.class.getClassLoader();\n+        classfile_for_Tester = appLoader.getResourceAsStream(\"SaveResolutionErrorTest$Tester.class\").readAllBytes();\n+        classfile_for_Loadee = appLoader.getResourceAsStream(\"SaveResolutionErrorTest$Loadee.class\").readAllBytes();\n+\n+        long started = System.currentTimeMillis();\n+        for (int i = 0; i < 1000; i++) {\n+            System.out.println(\"Test: \" + i);\n+            MyLoader loader = new MyLoader(appLoader);\n+            loader.doTest();\n+\n+            if (System.currentTimeMillis() - started > 100000) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Succeed\");\n+    }\n+\n+    public static class Tester extends Thread {\n+        static int errorCount = 0;\n+        synchronized static void incrError() {\n+            ++ errorCount;\n+        }\n+\n+        public volatile static boolean go = false;\n+\n+        public static void doit() throws Exception {\n+            System.out.println(Tester.class.getClassLoader());\n+\n+            Thread t1 = new Tester();\n+            Thread t2 = new Tester();\n+\n+            t1.start();\n+            t2.start();\n+\n+            go = true;\n+\n+            t1.join();\n+            t2.join();\n+\n+\n+            System.out.println(\"errorCount = \" + errorCount);\n+\n+            if (errorCount != 0 && errorCount != 2) {\n+                throw new RuntimeException(\"errorCount should be 0 or 2 but is \" + errorCount);\n+            }\n+        }\n+\n+        static int foobar;\n+        static boolean debug = false;\n+\n+        public void run() {\n+            while (!go) { Thread.onSpinWait(); }\n+\n+            try {\n+                \/\/ The first thread who tries to resolve the CP entry for the \"Loadee\" class\n+                \/\/ should (most likely) result in a resolution error. This error, if it has\n+                \/\/ happened, must also be reported by the second thread.\n+                \/\/\n+                \/\/ In some rare conditions, the resolution may succeed. In this case, both\n+                \/\/ threads must succeed. The reasons is:\n+                \/\/\n+                \/\/     The first thread who tries to resolve the CP entry gets a bad class, but\n+                \/\/     when it tries to update the CP entry, the second thread has already succeeded in\n+                \/\/     loading the class and has set the entry's tag to JVM_CONSTANT_Class.\n+\n+                foobar += Loadee.value;\n+            } catch (Throwable t) {\n+                Throwable cause = t.getCause();\n+                if (cause != null) {\n+                    String s = cause.toString();\n+                    if (s.equals(t.toString())) { \/\/ wrong cause\n+                        t.printStackTrace();\n+                        throw new RuntimeException(\"wrong cause\");\n+                    }\n+                }\n+                if (debug) {\n+                    System.out.println(t);\n+                } else {\n+                    synchronized (Tester.class) {\n+                        \/\/ Enable this block to see the stack trace\n+                        System.out.println(\"------\");\n+                        t.printStackTrace();\n+                        System.out.println(\"\");\n+                    }\n+                }\n+                incrError();\n+            }\n+        }\n+    }\n+\n+    public static class Loadee {\n+        static int value = 1234;\n+    }\n+\n+    static class MyLoader extends ClassLoader {\n+        static int count;\n+        static byte[] badclass = {1, 2, 3, 4, 5, 6, 7, 8};\n+\n+        static {\n+            registerAsParallelCapable();\n+        }\n+\n+        ClassLoader parent;\n+\n+        MyLoader(ClassLoader parent) {\n+            this.parent = parent;\n+        }\n+\n+        synchronized boolean hack() {\n+            ++ count;\n+            if ((count % 2) == 1) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        public Class loadClass(String name) throws ClassNotFoundException {\n+            if (name.equals(\"SaveResolutionErrorTest$Loadee\")) {\n+                if (hack()) {\n+                    return defineClass(name, badclass, 0, badclass.length);\n+                } else {\n+                    return defineClass(name, classfile_for_Loadee, 0, classfile_for_Loadee.length);\n+                }\n+            }\n+            if (name.equals(\"SaveResolutionErrorTest$Tester\")) {\n+                return defineClass(name, classfile_for_Tester, 0, classfile_for_Tester.length);\n+            }\n+            return parent.loadClass(name);\n+        }\n+\n+        void doTest() throws Exception {\n+            Class c = Class.forName(\"SaveResolutionErrorTest$Tester\", \/*init=*\/true, this);\n+            java.lang.reflect.Method m = c.getMethod(\"doit\");\n+            m.invoke(null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SaveResolutionErrorTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}