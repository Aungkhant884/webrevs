{"files":[{"patch":"@@ -112,0 +112,2 @@\n+  AdapterHandlerLibrary::initialize();\n+\n@@ -2393,4 +2395,2 @@\n-      for (int byte = 0; byte < _basic_types_per_int; byte++) {\n-        int bt = ((sig_index < total_args_passed)\n-                  ? adapter_encoding(sig_bt[sig_index++])\n-                  : 0);\n+      for (int byte = 0; sig_index < total_args_passed && byte < _basic_types_per_int; byte++) {\n+        int bt = adapter_encoding(sig_bt[sig_index++]);\n@@ -2438,1 +2438,41 @@\n-      st.print(\"%08x\", value(i));\n+      st.print(\"%x\", value(i));\n+    }\n+    return st.as_string();\n+  }\n+\n+#ifndef PRODUCT\n+  \/\/ Reconstitutes the basic type arguments from the fingerprint,\n+  \/\/ producing strings like LIJDF\n+  const char* as_basic_args_string() {\n+    stringStream st;\n+    bool long_prev = false;\n+    for (int i = 0; i < length(); i++) {\n+      unsigned val = (unsigned)value(i);\n+      \/\/ args are packed so that first\/lower arguments are in the highest\n+      \/\/ bits of each int value, so iterate from highest to the lowest\n+      for (int j = 32 - _basic_type_bits; j >= 0; j -= _basic_type_bits) {\n+        unsigned v = (val >> j) & _basic_type_mask;\n+        if (v == 0) {\n+          assert(i == length() - 1, \"Only expect zeroes in the last word\");\n+          continue;\n+        }\n+        if (long_prev) {\n+          long_prev = false;\n+          if (v == T_VOID) {\n+            st.print(\"J\");\n+          } else {\n+            st.print(\"L\");\n+          }\n+        }\n+        switch (v) {\n+          case T_INT:    st.print(\"I\");    break;\n+          case T_LONG:   long_prev = true; break;\n+          case T_FLOAT:  st.print(\"F\");    break;\n+          case T_DOUBLE: st.print(\"D\");    break;\n+          case T_VOID:   break;\n+          default: ShouldNotReachHere();\n+        }\n+      }\n+    }\n+    if (long_prev) {\n+      st.print(\"L\");\n@@ -2442,0 +2482,1 @@\n+#endif \/\/ !product\n@@ -2603,0 +2644,5 @@\n+AdapterHandlerEntry* AdapterHandlerLibrary::_no_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_int_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_int_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_obj_arg_handler = NULL;\n@@ -2607,3 +2653,0 @@\n-  \/\/ Should be called only when AdapterHandlerLibrary_lock is active.\n-  if (_buffer == NULL) \/\/ Initialize lazily\n-      _buffer = BufferBlob::create(\"adapters\", AdapterHandlerLibrary_size);\n@@ -2617,0 +2660,14 @@\n+static void post_adapter_creation(const AdapterBlob* new_adapter, const AdapterHandlerEntry* entry) {\n+  char blob_id[256];\n+  jio_snprintf(blob_id,\n+                sizeof(blob_id),\n+                \"%s(%s)\",\n+                new_adapter->name(),\n+                entry->fingerprint()->as_string());\n+  Forte::register_stub(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n+\n+  if (JvmtiExport::should_post_dynamic_code_generated()) {\n+    JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n+  }\n+}\n+\n@@ -2618,12 +2675,54 @@\n-  if (_adapters != NULL) return;\n-  _adapters = new AdapterHandlerTable();\n-\n-  \/\/ Create a special handler for abstract methods.  Abstract methods\n-  \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n-  \/\/ throw AbstractMethodError just in case.\n-  \/\/ Pass wrong_method_abstract for the c2i transitions to return\n-  \/\/ AbstractMethodError for invalid invocations.\n-  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-  _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),\n-                                                              StubRoutines::throw_AbstractMethodError_entry(),\n-                                                              wrong_method_abstract, wrong_method_abstract);\n+\n+  ResourceMark rm;\n+  AdapterBlob* no_arg_blob = NULL;\n+\n+  AdapterBlob* int_arg_blob = NULL;\n+  BasicType    int_args[] = { T_INT };\n+\n+  AdapterBlob* obj_arg_blob = NULL;\n+  BasicType    obj_args[] = { T_OBJECT };\n+\n+  AdapterBlob* obj_int_arg_blob = NULL;\n+  BasicType    obj_int_args[] = { T_OBJECT, T_INT };\n+\n+  AdapterBlob* obj_obj_arg_blob = NULL;\n+  BasicType    obj_obj_args[] = { T_OBJECT, T_OBJECT };\n+\n+  {\n+    MutexLocker mu(AdapterHandlerLibrary_lock);\n+    assert(_adapters == NULL, \"Initializing more than once\");\n+\n+    _adapters = new AdapterHandlerTable();\n+\n+    \/\/ Create a special handler for abstract methods.  Abstract methods\n+    \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n+    \/\/ throw AbstractMethodError just in case.\n+    \/\/ Pass wrong_method_abstract for the c2i transitions to return\n+    \/\/ AbstractMethodError for invalid invocations.\n+    address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),\n+                                                                StubRoutines::throw_AbstractMethodError_entry(),\n+                                                                wrong_method_abstract, wrong_method_abstract);\n+\n+    _buffer = BufferBlob::create(\"adapters\", AdapterHandlerLibrary_size);\n+\n+    _no_arg_handler = create_adapter(no_arg_blob, 0, NULL, true);\n+    _obj_arg_handler = create_adapter(obj_arg_blob, 1, obj_args, true);\n+    _int_arg_handler = create_adapter(int_arg_blob, 1, int_args, true);\n+    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, 2, obj_int_args, true);\n+    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, 2, obj_obj_args, true);\n+\n+    assert(no_arg_blob != NULL &&\n+          obj_arg_blob != NULL &&\n+          int_arg_blob != NULL &&\n+          obj_int_arg_blob != NULL &&\n+          obj_obj_arg_blob != NULL, \"Initial adapters must be properly created\");\n+  }\n+\n+\n+  \/\/ Outside of the lock\n+  post_adapter_creation(no_arg_blob, _no_arg_handler);\n+  post_adapter_creation(obj_arg_blob, _obj_arg_handler);\n+  post_adapter_creation(int_arg_blob, _int_arg_handler);\n+  post_adapter_creation(obj_int_arg_blob, _obj_int_arg_handler);\n+  post_adapter_creation(obj_obj_arg_blob, _obj_obj_arg_handler);\n@@ -2640,0 +2739,81 @@\n+AdapterHandlerEntry* AdapterHandlerLibrary::get_simple_adapter(const methodHandle& method) {\n+  if (method->is_abstract()) {\n+    return _abstract_method_handler;\n+  }\n+  int total_args_passed = method->size_of_parameters(); \/\/ All args on stack\n+  if (total_args_passed == 0) {\n+    return _no_arg_handler;\n+  } else if (total_args_passed == 1) {\n+    if (!method->is_static()) {\n+      return _obj_arg_handler;\n+    }\n+    switch (method->signature()->char_at(1)) {\n+      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_ARRAY:\n+        return _obj_arg_handler;\n+      case JVM_SIGNATURE_INT:\n+      case JVM_SIGNATURE_BOOLEAN:\n+      case JVM_SIGNATURE_CHAR:\n+      case JVM_SIGNATURE_BYTE:\n+      case JVM_SIGNATURE_SHORT:\n+        return _int_arg_handler;\n+    }\n+  } else if (total_args_passed == 2 &&\n+             !method->is_static()) {\n+    switch (method->signature()->char_at(1)) {\n+      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_ARRAY:\n+        return _obj_obj_arg_handler;\n+      case JVM_SIGNATURE_INT:\n+      case JVM_SIGNATURE_BOOLEAN:\n+      case JVM_SIGNATURE_CHAR:\n+      case JVM_SIGNATURE_BYTE:\n+      case JVM_SIGNATURE_SHORT:\n+        return _obj_int_arg_handler;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+class AdapterSignatureIterator : public SignatureIterator {\n+ private:\n+  BasicType stack_sig_bt[16];\n+  BasicType* sig_bt;\n+  int index;\n+\n+ public:\n+  AdapterSignatureIterator(Symbol* signature,\n+                           fingerprint_t fingerprint,\n+                           bool is_static,\n+                           int total_args_passed) :\n+    SignatureIterator(signature, fingerprint),\n+    index(0)\n+  {\n+    sig_bt = (total_args_passed <= 16) ? stack_sig_bt : NEW_RESOURCE_ARRAY(BasicType, total_args_passed);\n+    if (!is_static) { \/\/ Pass in receiver first\n+      sig_bt[index++] = T_OBJECT;\n+    }\n+    do_parameters_on(this);\n+  }\n+\n+  BasicType* basic_types() {\n+    return sig_bt;\n+  }\n+\n+#ifdef ASSERT\n+  int slots() {\n+    return index;\n+  }\n+#endif\n+\n+ private:\n+\n+  friend class SignatureIterator;  \/\/ so do_parameters_on can call do_type\n+  void do_type(BasicType type) {\n+    sig_bt[index++] = type;\n+    if (type == T_LONG || type == T_DOUBLE) {\n+      sig_bt[index++] = T_VOID; \/\/ Longs & doubles take 2 Java slots\n+    }\n+  }\n+};\n+\n@@ -2645,0 +2825,1 @@\n+  assert(_adapters != NULL, \"Uninitialized\");\n@@ -2646,1 +2827,5 @@\n-  ResourceMark rm;\n+  \/\/ Fast-path for trivial adapters\n+  AdapterHandlerEntry* entry = get_simple_adapter(method);\n+  if (entry != NULL) {\n+    return entry;\n+  }\n@@ -2648,1 +2833,1 @@\n-  NOT_PRODUCT(int insts_size);\n+  ResourceMark rm;\n@@ -2650,10 +2835,0 @@\n-  AdapterHandlerEntry* entry = NULL;\n-  AdapterFingerPrint* fingerprint = NULL;\n-  {\n-    MutexLocker mu(AdapterHandlerLibrary_lock);\n-    \/\/ make sure data structure is initialized\n-    initialize();\n-\n-    if (method->is_abstract()) {\n-      return _abstract_method_handler;\n-    }\n@@ -2661,2 +2836,2 @@\n-    \/\/ Fill in the signature array, for the calling-convention call.\n-    int total_args_passed = method->size_of_parameters(); \/\/ All args on stack\n+  \/\/ Fill in the signature array, for the calling-convention call.\n+  int total_args_passed = method->size_of_parameters(); \/\/ All args on stack\n@@ -2664,2 +2839,4 @@\n-    BasicType stack_sig_bt[16];\n-    BasicType* sig_bt = (total_args_passed <= 16) ? stack_sig_bt : NEW_RESOURCE_ARRAY(BasicType, total_args_passed);\n+  AdapterSignatureIterator si(method->signature(), method->constMethod()->fingerprint(), method->is_static(), total_args_passed);\n+  BasicType* sig_bt = si.basic_types();\n+  {\n+    MutexLocker mu(AdapterHandlerLibrary_lock);\n@@ -2667,9 +2844,1 @@\n-    int i = 0;\n-    if (!method->is_static())  \/\/ Pass in receiver first\n-      sig_bt[i++] = T_OBJECT;\n-    for (SignatureStream ss(method->signature()); !ss.at_return_type(); ss.next()) {\n-      sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n-      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n-        sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n-    }\n-    assert(i == total_args_passed, \"\");\n+    assert(si.slots() == total_args_passed, \"\");\n@@ -2680,0 +2849,1 @@\n+    if (entry != NULL) {\n@@ -2681,6 +2851,8 @@\n-    AdapterHandlerEntry* shared_entry = NULL;\n-    \/\/ Start adapter sharing verification only after the VM is booted.\n-    if (VerifyAdapterSharing && (entry != NULL)) {\n-      shared_entry = entry;\n-      entry = NULL;\n-    }\n+      if (VerifyAdapterSharing) {\n+        AdapterBlob* comparison_blob = NULL;\n+        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, total_args_passed, sig_bt, false);\n+        assert(comparison_blob == NULL, \"no blob should be created when creating an adapter for comparison\");\n+        assert(comparison_entry->compare_code(entry), \"code must match\");\n+        \/\/ Release the one just created and return the original\n+        _adapters->free_entry(comparison_entry);\n+      }\n@@ -2688,2 +2860,0 @@\n-\n-    if (entry != NULL) {\n@@ -2693,30 +2863,42 @@\n-    VMRegPair stack_regs[16];\n-    VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n-\n-    \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n-    int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n-\n-    \/\/ Make a C heap allocated version of the fingerprint to store in the adapter\n-    fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);\n-\n-    \/\/ StubRoutines::code2() is initialized after this function can be called. As a result,\n-    \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated\n-    \/\/ prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C\n-    \/\/ stub that ensure that an I2C stub is called from an interpreter frame.\n-    bool contains_all_checks = StubRoutines::code2() != NULL;\n-\n-    \/\/ Create I2C & C2I handlers\n-    BufferBlob* buf = buffer_blob(); \/\/ the temporary code buffer in CodeCache\n-    if (buf != NULL) {\n-      CodeBuffer buffer(buf);\n-      short buffer_locs[20];\n-      buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n-                                             sizeof(buffer_locs)\/sizeof(relocInfo));\n-\n-      MacroAssembler _masm(&buffer);\n-      entry = SharedRuntime::generate_i2c2i_adapters(&_masm,\n-                                                     total_args_passed,\n-                                                     comp_args_on_stack,\n-                                                     sig_bt,\n-                                                     regs,\n-                                                     fingerprint);\n+    entry = create_adapter(new_adapter, total_args_passed, sig_bt, \/* allocate_code_blob *\/ true);\n+  }\n+\n+  \/\/ Outside of the lock\n+  if (new_adapter != NULL) {\n+    post_adapter_creation(new_adapter, entry);\n+  }\n+  return entry;\n+}\n+\n+AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& new_adapter,\n+                                                           int total_args_passed,\n+                                                           BasicType* sig_bt,\n+                                                           bool allocate_code_blob) {\n+\n+  \/\/ StubRoutines::code2() is initialized after this function can be called. As a result,\n+  \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated\n+  \/\/ prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C\n+  \/\/ stub that ensure that an I2C stub is called from an interpreter frame.\n+  bool contains_all_checks = StubRoutines::code2() != NULL;\n+\n+  VMRegPair stack_regs[16];\n+  VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n+\n+  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n+  int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n+  BufferBlob* buf = buffer_blob(); \/\/ the temporary code buffer in CodeCache\n+  CodeBuffer buffer(buf);\n+  short buffer_locs[20];\n+  buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n+                                          sizeof(buffer_locs)\/sizeof(relocInfo));\n+\n+  \/\/ Make a C heap allocated version of the fingerprint to store in the adapter\n+  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);\n+  MacroAssembler _masm(&buffer);\n+  AdapterHandlerEntry* entry = SharedRuntime::generate_i2c2i_adapters(&_masm,\n+                                                total_args_passed,\n+                                                comp_args_on_stack,\n+                                                sig_bt,\n+                                                regs,\n+                                                fingerprint);\n+\n@@ -2724,10 +2906,6 @@\n-      if (VerifyAdapterSharing) {\n-        if (shared_entry != NULL) {\n-          assert(shared_entry->compare_code(buf->code_begin(), buffer.insts_size()), \"code must match\");\n-          \/\/ Release the one just created and return the original\n-          _adapters->free_entry(entry);\n-          return shared_entry;\n-        } else  {\n-          entry->save_code(buf->code_begin(), buffer.insts_size());\n-        }\n-      }\n+  if (VerifyAdapterSharing) {\n+    entry->save_code(buf->code_begin(), buffer.insts_size());\n+    if (!allocate_code_blob) {\n+      return entry;\n+    }\n+  }\n@@ -2736,10 +2914,9 @@\n-      new_adapter = AdapterBlob::create(&buffer);\n-      NOT_PRODUCT(insts_size = buffer.insts_size());\n-    }\n-    if (new_adapter == NULL) {\n-      \/\/ CodeCache is full, disable compilation\n-      \/\/ Ought to log this but compile log is only per compile thread\n-      \/\/ and we're some non descript Java thread.\n-      return NULL; \/\/ Out of CodeCache space\n-    }\n-    entry->relocate(new_adapter->content_begin());\n+  new_adapter = AdapterBlob::create(&buffer);\n+  NOT_PRODUCT(int insts_size = buffer.insts_size());\n+  if (new_adapter == NULL) {\n+    \/\/ CodeCache is full, disable compilation\n+    \/\/ Ought to log this but compile log is only per compile thread\n+    \/\/ and we're some non descript Java thread.\n+    return NULL;\n+  }\n+  entry->relocate(new_adapter->content_begin());\n@@ -2747,14 +2924,13 @@\n-    \/\/ debugging suppport\n-    if (PrintAdapterHandlers || PrintStubCode) {\n-      ttyLocker ttyl;\n-      entry->print_adapter_on(tty);\n-      tty->print_cr(\"i2c argument handler #%d for: %s %s %s (%d bytes generated)\",\n-                    _adapters->number_of_entries(), (method->is_static() ? \"static\" : \"receiver\"),\n-                    method->signature()->as_C_string(), fingerprint->as_string(), insts_size);\n-      tty->print_cr(\"c2i argument handler starts at %p\", entry->get_c2i_entry());\n-      if (Verbose || PrintStubCode) {\n-        address first_pc = entry->base_address();\n-        if (first_pc != NULL) {\n-          Disassembler::decode(first_pc, first_pc + insts_size);\n-          tty->cr();\n-        }\n+  \/\/ debugging suppport\n+  if (PrintAdapterHandlers || PrintStubCode) {\n+    ttyLocker ttyl;\n+    entry->print_adapter_on(tty);\n+    tty->print_cr(\"i2c argument handler #%d for: %s %s (%d bytes generated)\",\n+                  _adapters->number_of_entries(), fingerprint->as_basic_args_string(),\n+                  fingerprint->as_string(), insts_size);\n+    tty->print_cr(\"c2i argument handler starts at %p\", entry->get_c2i_entry());\n+    if (Verbose || PrintStubCode) {\n+      address first_pc = entry->base_address();\n+      if (first_pc != NULL) {\n+        Disassembler::decode(first_pc, first_pc + insts_size);\n+        tty->cr();\n@@ -2763,6 +2939,0 @@\n-#endif\n-    \/\/ Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)\n-    \/\/ The checks are inserted only if -XX:+VerifyAdapterCalls is specified.\n-    if (contains_all_checks || !VerifyAdapterCalls) {\n-      _adapters->add(entry);\n-    }\n@@ -2770,14 +2940,6 @@\n-  \/\/ Outside of the lock\n-  if (new_adapter != NULL) {\n-    char blob_id[256];\n-    jio_snprintf(blob_id,\n-                 sizeof(blob_id),\n-                 \"%s(%s)@\" PTR_FORMAT,\n-                 new_adapter->name(),\n-                 fingerprint->as_string(),\n-                 new_adapter->content_begin());\n-    Forte::register_stub(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n-\n-    if (JvmtiExport::should_post_dynamic_code_generated()) {\n-      JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n-    }\n+#endif\n+\n+  \/\/ Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)\n+  \/\/ The checks are inserted only if -XX:+VerifyAdapterCalls is specified.\n+  if (contains_all_checks || !VerifyAdapterCalls) {\n+    _adapters->add(entry);\n@@ -2832,2 +2994,4 @@\n-bool AdapterHandlerEntry::compare_code(unsigned char* buffer, int length) {\n-  if (length != _saved_code_length) {\n+bool AdapterHandlerEntry::compare_code(AdapterHandlerEntry* other) {\n+  assert(_saved_code != NULL && other->_saved_code != NULL, \"code not saved\");\n+\n+  if (other->_saved_code_length != _saved_code_length) {\n@@ -2837,1 +3001,1 @@\n-  return (memcmp(buffer, _saved_code, length) == 0) ? true : false;\n+  return memcmp(other->_saved_code, _saved_code, _saved_code_length) == 0;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":304,"deletions":140,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -623,0 +623,1 @@\n+  friend class AdapterHandlerLibrary;\n@@ -645,1 +646,0 @@\n-    _saved_code = NULL;\n@@ -673,1 +673,1 @@\n-  bool compare_code(unsigned char* code, int length);\n+  bool compare_code(AdapterHandlerEntry* other);\n@@ -681,0 +681,1 @@\n+  friend class SharedRuntime;\n@@ -685,0 +686,6 @@\n+  static AdapterHandlerEntry* _no_arg_handler;\n+  static AdapterHandlerEntry* _int_arg_handler;\n+  static AdapterHandlerEntry* _obj_arg_handler;\n+  static AdapterHandlerEntry* _obj_int_arg_handler;\n+  static AdapterHandlerEntry* _obj_obj_arg_handler;\n+\n@@ -687,1 +694,5 @@\n-\n+  static AdapterHandlerEntry* create_adapter(AdapterBlob*& new_adapter,\n+                                             int total_args_passed,\n+                                             BasicType* sig_bt,\n+                                             bool allocate_code_blob);\n+  static AdapterHandlerEntry* get_simple_adapter(const methodHandle& method);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"}]}