{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import javax.crypto.BadPaddingException;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPadding.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -196,1 +195,0 @@\n-            throw new SignatureException(\"Could not sign data\");\n@@ -200,0 +198,1 @@\n+        throw new SignatureException(\"Could not sign data\");\n@@ -218,0 +217,2 @@\n+            byte[] decrypted = RSACore.rsa(sigBytes, publicKey);\n+\n@@ -221,10 +222,5 @@\n-            byte[] decrypted = RSACore.rsa(sigBytes, publicKey);\n-\n-            boolean status = MessageDigest.isEqual(padded, decrypted);\n-            if (!status) {\n-                \/\/ fall back to the decode approach for max compatibility\n-                byte[] unpadded = padding.unpad(decrypted);\n-                if (unpadded != null) {\n-                    status = MessageDigest.isEqual(digest,\n-                            RSAUtil.decodeSignature(digestOID, unpadded));\n-                }\n+            if (!MessageDigest.isEqual(padded, decrypted)) {\n+                byte[] encoded2 = RSAUtil.encodeSignatureOmitNull\n+                        (digestOID, digest);\n+                byte[] padded2 = padding.pad(encoded2);\n+                return MessageDigest.isEqual(padded2, decrypted);\n@@ -232,1 +228,1 @@\n-            return status;\n+            return true;\n@@ -235,2 +231,0 @@\n-        } catch (IOException e) {\n-            throw new SignatureException(\"Signature encoding error\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSASignature.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,0 +182,14 @@\n+    \/**\n+     * Encode the digest with NULL parameter value omitted, return the\n+     * to-be-signed data.\n+     *\/\n+    public static byte[] encodeSignatureOmitNull(ObjectIdentifier oid,\n+            byte[] digest) {\n+        DerOutputStream out = new DerOutputStream();\n+        new AlgorithmId(oid, true).encode(out);\n+        out.putOctetString(digest);\n+        DerValue result =\n+            new DerValue(DerValue.tag_Sequence, out.toByteArray());\n+        return result.toByteArray();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAUtil.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -81,0 +81,4 @@\n+    \/\/ this flag will override the oid-specific NULL handling\n+    \/\/ when set to true, NULL params will be omitted from the encoding\n+    private transient boolean omitNull = false;\n+\n@@ -98,0 +102,13 @@\n+    \/**\n+     * Constructs a parameterless algorithm ID with flag controlling\n+     * whether NULL params is omitted.\n+     *\n+     * @param oid the identifier for the algorithm\n+     * @param omitNull the flag controlling whether NULL is encoded for\n+     *     NULL params\n+     *\/\n+    public AlgorithmId(ObjectIdentifier oid, boolean omitNull) {\n+        algid = oid;\n+        this.omitNull = omitNull;\n+    }\n+\n@@ -169,1 +186,1 @@\n-            if (algid.equals(RSAEncryption_oid)\n+            if (!omitNull && (algid.equals(RSAEncryption_oid)\n@@ -195,1 +212,1 @@\n-                    || algid.equals(SHA3_512withRSA_oid)) {\n+                    || algid.equals(SHA3_512withRSA_oid))) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"}]}