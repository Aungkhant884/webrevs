{"files":[{"patch":"@@ -38,0 +38,1 @@\n+EXCLUDES += jdk\/classfile\/components\/snippet-files\n","filename":"make\/modules\/java.base\/Java.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.classfile.attribute.CodeAttribute;\n@@ -266,1 +267,1 @@\n-     * Adds a method, with only a {@Code attribute}.\n+     * Adds a method, with only a {@link CodeAttribute}.\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/ClassBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,6 +65,6 @@\n- *\n- * <p>Class transformation sample where code transformation is stateful:\n- * <p>{@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"codeRelabeling\"}\n- *\n- * <p>Complex class instrumentation sample chaining multiple transformations:\n- * <p>{@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"classInstrumentation\"}\n+ * <p>\n+ * Class transformation sample where code transformation is stateful:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"codeRelabeling\"}\n+ * <p>\n+ * Complex class instrumentation sample chaining multiple transformations:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"classInstrumentation\"}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/ClassfileTransform.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,12 +66,65 @@\n-     * A flags word, indicating the kind of range.  Multiple flag bits\n-     * may be set.  Valid flags include {@link jdk.classfile.Classfile#CRT_STATEMENT},\n-     * {@link jdk.classfile.Classfile#CRT_BLOCK},\n-     * {@link jdk.classfile.Classfile#CRT_ASSIGNMENT},\n-     * {@link jdk.classfile.Classfile#CRT_FLOW_CONTROLLER},\n-     * {@link jdk.classfile.Classfile#CRT_FLOW_TARGET},\n-     * {@link jdk.classfile.Classfile#CRT_INVOKE},\n-     * {@link jdk.classfile.Classfile#CRT_CREATE},\n-     * {@link jdk.classfile.Classfile#CRT_BRANCH_TRUE},\n-     * {@link jdk.classfile.Classfile#CRT_BRANCH_FALSE}.\n-     *\n-     * @@@ Need reference for interpretation of flags.\n+     * The value of the flags item describes the kind of range. Multiple flags\n+     * may be set within flags.\n+     * <ul>\n+     * <li>{@link jdk.classfile.Classfile#CRT_STATEMENT} Range is a Statement\n+     * (except ExpressionStatement), StatementExpression (14.8), as well as each\n+     * VariableDeclaratorId = VariableInitializer of\n+     * LocalVariableDeclarationStatement (14.4) or FieldDeclaration (8.3) in the\n+     * grammar.\n+     * <li>{@link jdk.classfile.Classfile#CRT_BLOCK} Range is a Block in the\n+     * grammar.\n+     * <li>{@link jdk.classfile.Classfile#CRT_ASSIGNMENT} Range is an assignment\n+     * expression - Expression1 AssignmentOperator Expression1 in the grammar as\n+     * well as increment and decrement expressions (both prefix and postfix).\n+     * <li>{@link jdk.classfile.Classfile#CRT_FLOW_CONTROLLER} An expression\n+     * whose value will effect control flow. Flowcon in the following:\n+     * <pre>\n+     * if ( Flowcon ) Statement [else Statement]\n+     * for ( ForInitOpt ; [Flowcon] ; ForUpdateOpt ) Statement\n+     * while ( Flowcon ) Statement\n+     * do Statement while ( Flowcon ) ;\n+     * switch ( Flowcon ) { SwitchBlockStatementGroups }\n+     * Flowcon || Expression3\n+     * Flowcon &amp;&amp; Expression3\n+     * Flowcon ? Expression : Expression1\n+     * <\/pre>\n+     * <li>{@link jdk.classfile.Classfile#CRT_FLOW_TARGET} Statement or\n+     * expression effected by a CRT_FLOW_CONTROLLER. Flowtarg in the following:\n+     * <pre>\n+     * if ( Flowcon ) Flowtarg [else Flowtarg]\n+     * for ( ForInitOpt ; [Flowcon] ; ForUpdateOpt ) Flowtarg\n+     * while ( Flowcon ) Flowtarg\n+     * do Flowtarg while ( Flowcon ) ;\n+     * Flowcon || Flowtarg\n+     * Flowcon &amp;&amp; Flowtarg\n+     * Flowcon ? Flowtarg : Flowtarg\n+     * <\/pre>\n+     * <li>{@link jdk.classfile.Classfile#CRT_INVOKE} Method invocation. For\n+     * example: Identifier Arguments.\n+     * <li>{@link jdk.classfile.Classfile#CRT_CREATE} New object creation. For\n+     * example: new Creator.\n+     * <li>{@link jdk.classfile.Classfile#CRT_BRANCH_TRUE} A condition encoded\n+     * in the branch instruction immediately contained in the code range for\n+     * this item is not inverted towards the corresponding branch condition in\n+     * the source code. I.e. actual jump occurs if and only if the the source\n+     * code branch condition evaluates to true. Entries of this type are\n+     * produced only for conditions that are listed in the description of\n+     * CRT_FLOW_CONTROLLER flag. The source range for the entry contains flow\n+     * controlling expression. start_pc field for an entry of this type must\n+     * point to a branch instruction: if_acmp&lt;cond&gt;, if_icmp&lt;cond&gt;,\n+     * if&lt;cond&gt;, ifnonull, ifnull or goto. CRT_BRANCH_TRUE and\n+     * CRT_BRANCH_FALSE are special kinds of entries that can be used to\n+     * determine what branch of a condition was chosen during the runtime.\n+     * <li>{@link jdk.classfile.Classfile#CRT_BRANCH_FALSE} A condition encoded\n+     * in the branch instruction immediately contained in the code range for\n+     * this item is inverted towards the corresponding branch condition in the\n+     * source code. I.e. actual jump occurs if and only if the the source code\n+     * branch condition evaluates to false. Entries of this type are produced\n+     * only for conditions that are listed in the description of\n+     * CRT_FLOW_CONTROLLER flag. The source range for the entry contains flow\n+     * controlling expression. start_pc field for an entry of this type must\n+     * point to a branch instruction: if_acmp&lt;cond&gt;, if_icmp&lt;cond&gt;,\n+     * if&lt;cond&gt;, ifnonull, ifnull or goto.\n+     * <\/ul>\n+     * <p>\n+     * All bits of the flags item not assigned above are reserved for future use. They should be set to zero in generated class files and should be ignored by Java virtual machine implementations.\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/attribute\/CharacterRangeInfo.java","additions":65,"deletions":12,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -35,3 +35,22 @@\n- * Models the {@code CharacterRangeTable} attribute (@@@ need spec reference),\n- * which appears on {@code Code} attributes.  It is used by debuggers to\n- * determine the correspondence between the code array and the source file.\n+ * The CharacterRangeTable attribute is an optional variable-length attribute in\n+ * the attributes table of a {@code Code} attribute. It may be used by debuggers\n+ * to determine which part of the Java virtual machine code array corresponds to\n+ * a given position in the source file or to determine what section of source\n+ * code corresponds to a given index into the code array. The\n+ * CharacterRangeTable attribute consists of an array of character range entries.\n+ * Each character range entry within the table associates a range of indices in\n+ * the code array with a range of character indices in the source file. If the\n+ * source file is viewed as an array of characters, a character index is the\n+ * corresponding index into this array. Note that character indices are not the\n+ * same as byte indices as multi-byte characters may be present in the source\n+ * file. Each character range entry includes a flag which indicates what kind of\n+ * range is described: statement, assignment, method call, etc. Both code index\n+ * ranges and character ranges may nest within other ranges, but they may not\n+ * partially overlap. Thus, a given code index may correspond to several\n+ * character range entries and in turn several character ranges, but there will\n+ * be a smallest character range, and for each kind of range in which it is\n+ * enclosed there will be a smallest character range. Similarly, a given\n+ * character index may correspond to several character range entries and in turn\n+ * several code index ranges, but there will be a smallest code index range, and\n+ * for each kind of range in which it is enclosed there will be a smallest code\n+ * index range. The character range entries may appear in any order.\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/attribute\/CharacterRangeTableAttribute.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+         * <\/ul>\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/components\/ClassPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"printClass\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"printClass\"}\n@@ -47,2 +46,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"customPrint\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"customPrint\"}\n@@ -51,2 +49,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"printNodesInTest\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"printNodesInTest\"}\n@@ -68,2 +65,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"singleClassRemap\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"singleClassRemap\"}\n@@ -72,2 +68,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"allPackageRemap\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"allPackageRemap\"}\n@@ -82,2 +77,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"codeLocalsShifting\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"codeLocalsShifting\"}\n@@ -96,2 +90,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"codeRelabeling\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"codeRelabeling\"}\n@@ -102,1 +95,1 @@\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"classInstrumentation\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"classInstrumentation\"}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/components\/package-info.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+\n+import java.lang.reflect.AccessFlag;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import jdk.classfile.ClassModel;\n+import jdk.classfile.ClassTransform;\n+import jdk.classfile.CodeModel;\n+import jdk.classfile.CodeTransform;\n+import jdk.classfile.FieldModel;\n+import jdk.classfile.MethodModel;\n+import jdk.classfile.TypeKind;\n+import jdk.classfile.instruction.InvokeInstruction;\n+\n+import jdk.classfile.MethodTransform;\n+import jdk.classfile.components.ClassPrinter;\n+import jdk.classfile.components.ClassRemapper;\n+import jdk.classfile.components.CodeLocalsShifter;\n+import jdk.classfile.components.CodeRelabeler;\n+import jdk.classfile.instruction.ReturnInstruction;\n+import jdk.classfile.instruction.StoreInstruction;\n+\n+class PackageSnippets {\n+\n+    void printClass(ClassModel classModel) {\n+        \/\/ @start region=\"printClass\"\n+        ClassPrinter.toJson(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        \/\/ @end\n+    }\n+\n+    \/\/ @start region=\"customPrint\"\n+    void customPrint(ClassModel classModel) {\n+        print(ClassPrinter.toTree(classModel, ClassPrinter.Verbosity.TRACE_ALL));\n+    }\n+\n+    void print(ClassPrinter.Node node) {\n+        switch (node) {\n+            case ClassPrinter.MapNode mn -> {\n+                \/\/ print map header\n+                mn.values().forEach(this::print);\n+            }\n+            case ClassPrinter.ListNode ln -> {\n+                \/\/ print list header\n+                ln.forEach(this::print);\n+            }\n+            case ClassPrinter.LeafNode n -> {\n+                \/\/ print leaf node\n+            }\n+        }\n+    }\n+    \/\/ @end\n+\n+    \/\/ @start region=\"printNodesInTest\"\n+    @Test\n+    void printNodesInTest(ClassModel classModel) {\n+        var classNode = ClassPrinter.toTree(classModel, ClassPrinter.Verbosity.TRACE_ALL);\n+        assertContains(classNode, \"method name\", \"myFooMethod\");\n+        assertContains(classNode, \"field name\", \"myBarField\");\n+        assertContains(classNode, \"inner class\", \"MyInnerFooClass\");\n+    }\n+\n+    void assertContains(ClassPrinter.Node node, ConstantDesc key, ConstantDesc value) {\n+        if (!node.walk().anyMatch(n -> n instanceof ClassPrinter.LeafNode ln\n+                               && ln.name().equals(key)\n+                               && ln.value().equals(value))) {\n+            node.toYaml(System.out::print);\n+            throw new AssertionError(\"expected %s: %s\".formatted(key, value));\n+        }\n+    }\n+    \/\/ @end\n+    @interface Test{}\n+\n+    void singleClassRemap(ClassModel... allMyClasses) {\n+        \/\/ @start region=\"singleClassRemap\"\n+        var classRemapper = ClassRemapper.of(\n+                Map.of(ClassDesc.of(\"Foo\"), ClassDesc.of(\"Bar\")));\n+\n+        for (var classModel : allMyClasses) {\n+            byte[] newBytes = classRemapper.remapClass(classModel);\n+\n+        }\n+        \/\/ @end\n+    }\n+\n+    void allPackageRemap(ClassModel... allMyClasses) {\n+        \/\/ @start region=\"allPackageRemap\"\n+        var classRemapper = ClassRemapper.of(cd ->\n+                ClassDesc.ofDescriptor(cd.descriptorString().replace(\"Lcom\/oldpackage\/\", \"Lcom\/newpackage\/\")));\n+\n+        for (var classModel : allMyClasses) {\n+            byte[] newBytes = classRemapper.remapClass(classModel);\n+\n+        }\n+        \/\/ @end\n+    }\n+\n+    void codeLocalsShifting(ClassModel classModel) {\n+        \/\/ @start region=\"codeLocalsShifting\"\n+        byte[] newBytes = classModel.transform((classBuilder, classElement) -> {\n+                if (classElement instanceof MethodModel method)\n+                    classBuilder.transformMethod(method,\n+                            MethodTransform.transformingCode(\n+                                    CodeLocalsShifter.of(method.flags(), method.methodTypeSymbol())));\n+                else\n+                    classBuilder.accept(classElement);\n+            });\n+        \/\/ @end\n+    }\n+\n+    void codeRelabeling(ClassModel classModel) {\n+        \/\/ @start region=\"codeRelabeling\"\n+        byte[] newBytes = classModel.transform(\n+                ClassTransform.transformingMethodBodies(\n+                        CodeTransform.ofStateful(CodeRelabeler::of)));\n+        \/\/ @end\n+    }\n+\n+    \/\/ @start region=\"classInstrumentation\"\n+    byte[] classInstrumentation(ClassModel target, ClassModel instrumentor, Predicate<MethodModel> instrumentedMethodsFilter) {\n+        var instrumentorCodeMap = instrumentor.methods().stream()\n+                                              .filter(instrumentedMethodsFilter)\n+                                              .collect(Collectors.toMap(mm -> mm.methodName().stringValue() + mm.methodType().stringValue(), mm -> mm.code().orElse(null)));\n+        var targetFieldNames = target.fields().stream().map(f -> f.fieldName().stringValue()).collect(Collectors.toSet());\n+        var targetMethods = target.methods().stream().map(m -> m.methodName().stringValue() + m.methodType().stringValue()).collect(Collectors.toSet());\n+        var instrumentorClassRemapper = ClassRemapper.of(Map.of(instrumentor.thisClass().asSymbol(), target.thisClass().asSymbol()));\n+        return target.transform(\n+                ClassTransform.transformingMethods(\n+                        instrumentedMethodsFilter,\n+                        (mb, me) -> {\n+                            if (me instanceof CodeModel targetCodeModel) {\n+                                var mm = targetCodeModel.parent().get();\n+                                \/\/instrumented methods code is taken from instrumentor\n+                                mb.transformCode(instrumentorCodeMap.get(mm.methodName().stringValue() + mm.methodType().stringValue()),\n+                                        \/\/all references to the instrumentor class are remapped to target class\n+                                        instrumentorClassRemapper.asCodeTransform()\n+                                        .andThen((codeBuilder, instrumentorCodeElement) -> {\n+                                            \/\/all invocations of target methods from instrumentor are inlined\n+                                            if (instrumentorCodeElement instanceof InvokeInstruction inv\n+                                                && target.thisClass().asInternalName().equals(inv.owner().asInternalName())\n+                                                && mm.methodName().stringValue().equals(inv.name().stringValue())\n+                                                && mm.methodType().stringValue().equals(inv.type().stringValue())) {\n+\n+                                                \/\/store stacked method parameters into locals\n+                                                var storeStack = new LinkedList<StoreInstruction>();\n+                                                int slot = 0;\n+                                                if (!mm.flags().has(AccessFlag.STATIC))\n+                                                    storeStack.add(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                for (var pt : mm.methodTypeSymbol().parameterList()) {\n+                                                    var tk = TypeKind.fromDescriptor(pt.descriptorString());\n+                                                    storeStack.addFirst(StoreInstruction.of(tk, slot));\n+                                                    slot += tk.slotSize();\n+                                                }\n+                                                storeStack.forEach(codeBuilder::with);\n+\n+                                                \/\/inlined target locals must be shifted based on the actual instrumentor locals\n+                                                codeBuilder.block(inlinedBlockBuilder -> inlinedBlockBuilder\n+                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n+                                                        .andThen(CodeRelabeler.of())\n+                                                        .andThen((innerBuilder, shiftedTargetCode) -> {\n+                                                            \/\/returns must be replaced with jump to the end of the inlined method\n+                                                            if (shiftedTargetCode instanceof ReturnInstruction)\n+                                                                innerBuilder.goto_(inlinedBlockBuilder.breakLabel());\n+                                                            else\n+                                                                innerBuilder.with(shiftedTargetCode);\n+                                                        })));\n+                                            } else\n+                                                codeBuilder.with(instrumentorCodeElement);\n+                                        }));\n+                            } else\n+                                mb.with(me);\n+                        })\n+                .andThen(ClassTransform.endHandler(clb ->\n+                    \/\/remaining instrumentor fields and methods are injected at the end\n+                    clb.transform(instrumentor,\n+                            ClassTransform.dropping(cle ->\n+                                    !(cle instanceof FieldModel fm\n+                                            && !targetFieldNames.contains(fm.fieldName().stringValue()))\n+                                    && !(cle instanceof MethodModel mm\n+                                            && !\"<init>\".equals(mm.methodName().stringValue())\n+                                            && !targetMethods.contains(mm.methodName().stringValue() + mm.methodType().stringValue())))\n+                            \/\/and instrumentor class references remapped to target class\n+                            .andThen(instrumentorClassRemapper)))));\n+    }\n+    \/\/ @end\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -49,1 +49,0 @@\n-     * @return\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/constantpool\/PoolEntry.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-     *           which must be of kind {@link Kind#ARRAY_LOAD}\n+     *           which must be of kind {@link Opcode.Kind#ARRAY_LOAD}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/ArrayLoadInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-     *           which must be of kind {@link Kind#ARRAY_STORE}\n+     *           which must be of kind {@link Opcode.Kind#ARRAY_STORE}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/ArrayStoreInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-     *           which must be of kind {@link Kind#BRANCH}\n+     *           which must be of kind {@link Opcode.Kind#BRANCH}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/BranchInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,2 @@\n-     * may be set.  Valid flags include {@link jdk.classfile.Classfile#CRT_STATEMENT},\n+     * may be set.  Valid flags include\n+     * {@link jdk.classfile.Classfile#CRT_STATEMENT},\n@@ -82,1 +83,1 @@\n-     * @@@ Need reference for interpretation of flags.\n+     * @see jdk.classfile.attribute.CharacterRangeInfo#flags()\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/CharacterRange.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-     *           which must be of kind {@link Kind#CONSTANT}\n+     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n@@ -131,1 +131,1 @@\n-     *           which must be of kind {@link Kind#CONSTANT}\n+     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n@@ -145,1 +145,1 @@\n-     *           which must be of kind {@link Kind#CONSTANT}\n+     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/ConstantInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-     *           which must be of kind {@link Kind#CONVERT}\n+     *           which must be of kind {@link Opcode.Kind#CONVERT}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/ConvertInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-     *           which must be of kind {@link Kind#FIELD_ACCESS}\n+     *           which must be of kind {@link Opcode.Kind#FIELD_ACCESS}\n@@ -98,1 +98,1 @@\n-     *           which must be of kind {@link Kind#FIELD_ACCESS}\n+     *           which must be of kind {@link Opcode.Kind#FIELD_ACCESS}\n@@ -114,1 +114,1 @@\n-     *           which must be of kind {@link Kind#FIELD_ACCESS}\n+     *           which must be of kind {@link Opcode.Kind#FIELD_ACCESS}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/FieldInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.classfile.Opcode;\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/IncrementInstruction.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-     *           which must be of kind {@link Kind#INVOKE}\n+     *           which must be of kind {@link Opcode.Kind#INVOKE}\n@@ -113,1 +113,1 @@\n-     *           which must be of kind {@link Kind#INVOKE}\n+     *           which must be of kind {@link Opcode.Kind#INVOKE}\n@@ -131,1 +131,1 @@\n-     *           which must be of kind {@link Kind#INVOKE}\n+     *           which must be of kind {@link Opcode.Kind#INVOKE}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/InvokeInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-     *           which must be of kind {@link Kind#LOAD}\n+     *           which must be of kind {@link Opcode.Kind#LOAD}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/LoadInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-     *           which must be of kind {@link Kind#MONITOR}\n+     *           which must be of kind {@link Opcode.Kind#MONITOR}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/MonitorInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-     *           which must be of kind {@link Kind#OPERATOR}\n+     *           which must be of kind {@link Opcode.Kind#OPERATOR}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/OperatorInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-     *           which must be of kind {@link Kind#RETURN}\n+     *           which must be of kind {@link Opcode.Kind#RETURN}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/ReturnInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-     *           which must be of kind {@link Kind#STACK}\n+     *           which must be of kind {@link Opcode.Kind#STACK}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/StackInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-     *           which must be of kind {@link Kind#STORE}\n+     *           which must be of kind {@link Opcode.Kind#STORE}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/StoreInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-     *           which must be of kind {@link Kind#TYPE_CHECK}\n+     *           which must be of kind {@link Opcode.Kind#TYPE_CHECK}\n@@ -64,1 +64,1 @@\n-     *           which must be of kind {@link Kind#TYPE_CHECK}\n+     *           which must be of kind {@link Opcode.Kind#TYPE_CHECK}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/instruction\/TypeCheckInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * <h1>Classfile parsing, generation, and transformation<\/h1>\n+ * <h2>Classfile parsing, generation, and transformation<\/h2>\n@@ -54,2 +54,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"enumerateFieldsMethods1\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"enumerateFieldsMethods1\"}\n@@ -72,2 +71,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"enumerateFieldsMethods2\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"enumerateFieldsMethods2\"}\n@@ -82,2 +80,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"gatherDependencies1\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"gatherDependencies1\"}\n@@ -87,2 +84,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"gatherDependencies2\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"gatherDependencies2\"}\n@@ -171,1 +167,1 @@\n- * <p>\n+ *\n@@ -178,1 +174,0 @@\n- * <p>\n@@ -210,2 +205,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"helloWorld\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"helloWorld\"}\n@@ -256,2 +250,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"stripDebugMethods1\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"stripDebugMethods1\"}\n@@ -275,2 +268,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"stripDebugMethods2\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"stripDebugMethods2\"}\n@@ -285,2 +277,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"fooToBarTransform\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"fooToBarTransform\"}\n@@ -293,1 +284,0 @@\n- * <p>\n@@ -300,1 +290,0 @@\n- * <p>\n@@ -306,1 +295,0 @@\n- * <p>\n@@ -313,2 +301,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"fooToBarUnrolled\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"fooToBarUnrolled\"}\n@@ -321,2 +308,1 @@\n- * <p>\n- * {@snippet lang=\"java\" class=\"jdk.classfile.snippet-files.PackageSnippets\" region=\"instrumentCallsTransform\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"instrumentCallsTransform\"}\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/package-info.java","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-import jdk.classfile.MethodTransform;\n-import jdk.classfile.components.ClassPrinter;\n@@ -235,85 +233,0 @@\n-    void printClass(ClassModel classModel) {\n-        \/\/ @start region=\"printClass\"\n-        ClassPrinter.toJson(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n-        \/\/ @end\n-    }\n-\n-    \/\/ @start region=\"customPrint\"\n-    void customPrint(ClassModel classModel) {\n-        print(ClassPrinter.toTree(classModel, ClassPrinter.Verbosity.TRACE_ALL));\n-    }\n-\n-    void print(ClassPrinter.Node node) {\n-        switch (node) {\n-            case ClassPrinter.MapNode mn -> {\n-                \/\/ print map header\n-                mn.values().forEach(this::print);\n-            }\n-            case ClassPrinter.ListNode ln -> {\n-                \/\/ print list header\n-                ln.forEach(this::print);\n-            }\n-            case ClassPrinter.LeafNode n -> {\n-                \/\/ print leaf node\n-            }\n-        }\n-    }\n-    \/\/ @end\n-\n-    \/\/ @start region=\"printNodesInTest\"\n-    @Test\n-    void printNodesInTest(ClassModel classModel) {\n-        var classNode = ClassPrinter.toTree(classModel, ClassPrinter.Verbosity.TRACE_ALL);\n-        assertContains(classNode, \"method name\", \"myFooMethod\");\n-        assertContains(classNode, \"field name\", \"myBarField\");\n-        assertContains(classNode, \"inner class\", \"MyInnerFooClass\");\n-    }\n-\n-    void assertContains(ClassPrinter.Node node, ConstantDesc key, ConstantDesc value) {\n-        if (!node.walk().anyMatch(n -> n instanceof ClassPrinter.LeafNode ln\n-                               && ln.name().equals(key)\n-                               && ln.value().equals(value))) {\n-            node.toYaml(System.out::print);\n-            throw new AssertionError(\"expected %s: %s\".formatted(key, value));\n-        }\n-    }\n-    \/\/ @end\n-    @interface Test{}\n-\n-    void singleClassRemap(ClassModel... allMyClasses) {\n-        \/\/ @start region=\"singleClassRemap\"\n-        var classRemapper = ClassRemapper.of(\n-                Map.of(ClassDesc.of(\"Foo\"), ClassDesc.of(\"Bar\")));\n-\n-        for (var classModel : allMyClasses) {\n-            byte[] newBytes = classRemapper.remapClass(classModel);\n-\n-        }\n-        \/\/ @end\n-    }\n-\n-    void allPackageRemap(ClassModel... allMyClasses) {\n-        \/\/ @start region=\"allPackageRemap\"\n-        var classRemapper = ClassRemapper.of(cd ->\n-                ClassDesc.ofDescriptor(cd.descriptorString().replace(\"Lcom\/oldpackage\/\", \"Lcom\/newpackage\/\")));\n-\n-        for (var classModel : allMyClasses) {\n-            byte[] newBytes = classRemapper.remapClass(classModel);\n-\n-        }\n-        \/\/ @end\n-    }\n-\n-    void codeLocalsShifting(ClassModel classModel) {\n-        \/\/ @start region=\"codeLocalsShifting\"\n-        byte[] newBytes = classModel.transform((classBuilder, classElement) -> {\n-                if (classElement instanceof MethodModel method)\n-                    classBuilder.transformMethod(method,\n-                            MethodTransform.transformingCode(\n-                                    CodeLocalsShifter.of(method.flags(), method.methodTypeSymbol())));\n-                else\n-                    classBuilder.accept(classElement);\n-            });\n-        \/\/ @end\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/classfile\/snippet-files\/PackageSnippets.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"modified"}]}