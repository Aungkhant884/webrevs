{"files":[{"patch":"@@ -2403,0 +2403,8 @@\n+    case Op_VectorMaskCmp:\n+    \/\/ We don't have VectorReinterpret with bit_size less than 64 support for\n+    \/\/ now, even for byte type. To be refined with fully VectorCast support.\n+    case Op_VectorReinterpret:\n+      if (vlen < 2 || bit_size < 64) {\n+        return false;\n+      }\n+      break;\n@@ -2416,3 +2424,15 @@\n-     case Op_VectorMaskCmp:\n-       if (vlen < 2 || bit_size < 64) {\n-         return false;\n+    \/\/ Some types of VectorCast are not implemented for now.\n+    case Op_VectorCastI2X:\n+      if (bt == T_BYTE) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastS2X:\n+      if (vlen < 4 || bit_size < 64) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastF2X:\n+    case Op_VectorCastD2X:\n+      if (bt == T_INT || bt == T_SHORT || bt == T_BYTE || bt == T_LONG) {\n+        return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3862,0 +3862,3 @@\n+  if (masklen < 64) {\n+    andq(tmp, (((jlong)1 << masklen) - 1));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -772,0 +772,9 @@\n+      _features &= ~CPU_AVX512DQ;\n+      _features &= ~CPU_AVX512_VNNI;\n+      _features &= ~CPU_AVX512_VAES;\n+      _features &= ~CPU_AVX512_VPOPCNTDQ;\n+      _features &= ~CPU_AVX512_VPCLMULQDQ;\n+      _features &= ~CPU_AVX512_VBMI;\n+      _features &= ~CPU_AVX512_VBMI2;\n+      _features &= ~CPU_CLWB;\n+      _features &= ~CPU_FLUSHOPT;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -778,1 +778,1 @@\n-  static bool is_knights_family() { return ((cpu_family() == 0x06) && ((extended_cpu_model() == 0x57) || (extended_cpu_model() == 0x85))); } \/\/ Xeon Phi 3200\/5200\/7200 and Future Xeon Phi\n+  static bool is_knights_family() { return UseKNLSetting || ((cpu_family() == 0x06) && ((extended_cpu_model() == 0x57) || (extended_cpu_model() == 0x85))); } \/\/ Xeon Phi 3200\/5200\/7200 and Future Xeon Phi\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-  if (get_block_for_node(ctrl) == not_null_block) {\n+  if (ctrl != NULL && get_block_for_node(ctrl) == not_null_block) {\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -2840,0 +2841,28 @@\n+static typeArrayOop lock_gc_or_pin_string_value(JavaThread* thread, oop str) {\n+  if (Universe::heap()->supports_object_pinning()) {\n+    \/\/ Forbid deduplication before obtaining the value array, to prevent\n+    \/\/ deduplication from replacing the value array while setting up or in\n+    \/\/ the critical section.  That would lead to the release operation\n+    \/\/ unpinning the wrong object.\n+    if (StringDedup::is_enabled()) {\n+      NoSafepointVerifier nsv;\n+      StringDedup::forbid_deduplication(str);\n+    }\n+    typeArrayOop s_value = java_lang_String::value(str);\n+    return (typeArrayOop) Universe::heap()->pin_object(thread, s_value);\n+  } else {\n+    Handle h(thread, str);      \/\/ Handlize across potential safepoint.\n+    GCLocker::lock_critical(thread);\n+    return java_lang_String::value(h());\n+  }\n+}\n+\n+static void unlock_gc_or_unpin_string_value(JavaThread* thread, oop str) {\n+  if (Universe::heap()->supports_object_pinning()) {\n+    typeArrayOop s_value = java_lang_String::value(str);\n+    Universe::heap()->unpin_object(thread, s_value);\n+  } else {\n+    GCLocker::unlock_critical(thread);\n+  }\n+}\n+\n@@ -2842,6 +2871,1 @@\n-  oop s = lock_gc_or_pin_object(thread, string);\n-  typeArrayOop s_value = java_lang_String::value(s);\n-  bool is_latin1 = java_lang_String::is_latin1(s);\n-  if (isCopy != NULL) {\n-    *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;\n-  }\n+  oop s = JNIHandles::resolve_non_null(string);\n@@ -2849,1 +2873,2 @@\n-  if (!is_latin1) {\n+  if (!java_lang_String::is_latin1(s)) {\n+    typeArrayOop s_value = lock_gc_or_pin_string_value(thread, s);\n@@ -2851,0 +2876,1 @@\n+    if (isCopy != NULL) *isCopy = JNI_FALSE;\n@@ -2853,0 +2879,1 @@\n+    typeArrayOop s_value = java_lang_String::value(s);\n@@ -2862,0 +2889,1 @@\n+    if (isCopy != NULL) *isCopy = JNI_TRUE;\n@@ -2870,1 +2898,0 @@\n-  \/\/ The str and chars arguments are ignored for UTF16 strings\n@@ -2877,0 +2904,3 @@\n+  } else {\n+    \/\/ For non-latin1 string, drop the associated gc-locker\/pin.\n+    unlock_gc_or_unpin_string_value(thread, s);\n@@ -2878,1 +2908,0 @@\n-  unlock_gc_or_unpin_object(thread, str);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":38,"deletions":9,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+compiler\/vectorapi\/VectorCastShape128Test.java 8269952 generic-x64\n+compiler\/vectorapi\/VectorCastShape64Test.java 8269952 generic-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}