{"files":[{"patch":"@@ -31,0 +31,5 @@\n+size_t G1CardTable::min_card_size(size_t region_size) {\n+  int region_size_log = exact_log2_long((jlong)region_size);\n+  return 1 << (region_size_log - LogOfMaxCardsPerRegion);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n@@ -78,0 +79,1 @@\n+  static const size_t LogOfMaxCardsPerRegion = BitsPerByte * sizeof(G1CardSetArray::EntryDataType);\n@@ -88,0 +90,1 @@\n+  static size_t min_card_size(size_t region_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1664,1 +1664,1 @@\n-  guarantee(heap_rs.base() >= (char*)G1CardTable::card_size, \"Java heap must not start within the first card.\");\n+  guarantee(heap_rs.base() >= (char*)(uintptr_t)(G1CardTable::card_size), \"Java heap must not start within the first card.\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  CardTable::initialize_card_size(1 << (region_size_log - 16));\n+  CardTable::initialize_card_size(G1CardTable::min_card_size(region_size));\n@@ -103,2 +103,0 @@\n-  assert(LogCardsPerRegion <= 16, \"Total cards per region should be less than or equal to 2^16\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  assert((int)block_size <= 1024, \"block_size must be less than or equal to 1024\");\n+  assert(block_size <= MaxBlockSize, \"block_size must be less than or equal to \" UINT32_FORMAT, MaxBlockSize);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,4 @@\n+  \/\/ This maximum is derived from that we need an extra bit for possible\n+  \/\/ offsets in the byte for backskip values (this is a hard limit)\n+  static const uint MaxBlockSize = 1024;\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -100,0 +101,1 @@\n+    assert(BOTConstants::N_bytes == CardTable::card_size, \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/parallel\/objectStartArray.hpp\"\n@@ -30,0 +29,2 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/parallel\/objectStartArray.hpp\"\n@@ -38,3 +39,3 @@\n-uintx CardTable::card_shift = 0;\n-uintx CardTable::card_size = 0;\n-uintx CardTable::card_size_in_words = 0;\n+uint CardTable::card_shift = 0;\n+uint CardTable::card_size = 0;\n+uint CardTable::card_size_in_words = 0;\n@@ -42,1 +43,1 @@\n-void CardTable::initialize_card_size(uintx min_card_size) {\n+void CardTable::initialize_card_size(uint min_card_size) {\n@@ -46,5 +47,2 @@\n-  \/\/ GCCardSizeInBytes is rounded off to the nearest power of 2, and clamped\n-  \/\/ between min and max card sizes\n-  card_size = GCCardSizeInBytes;\n-  card_size = round_up_power_of_2(card_size);\n-  card_size = clamp(card_size, MAX2(min_card_size,card_size_min), card_size_max);\n+  \/\/ Card size is the max. of minimum permissible value and GCCardSizeInBytes\n+  card_size = MAX2(min_card_size, GCCardSizeInBytes);\n@@ -52,1 +50,0 @@\n-  card_size = 1 << card_shift;\n@@ -58,0 +55,1 @@\n+#if INCLUDE_PARALLELGC\n@@ -60,0 +58,1 @@\n+#endif\n@@ -65,1 +64,1 @@\n-  log_info(gc, barrier)(\"CardTable entry size: \" UINTX_FORMAT,  card_size);\n+  log_info_p(gc, init)(\"CardTable entry size: \" UINT32_FORMAT,  card_size);\n@@ -69,1 +68,1 @@\n-  initialize_card_size(card_size_min);\n+  initialize_card_size(CardSizeMin);\n@@ -96,1 +95,0 @@\n-  assert(card_size >= card_size_min && card_size <= card_size_max, \"card_size must be between min and max\");\n@@ -468,1 +466,1 @@\n-  return card_size_max * os::vm_page_size();\n+  return CardSizeMax * os::vm_page_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -232,3 +232,3 @@\n-  static uintx card_shift;\n-  static uintx card_size;\n-  static uintx card_size_in_words;\n+  static uint card_shift;\n+  static uint card_size;\n+  static uint card_size_in_words;\n@@ -237,2 +237,2 @@\n-  static const uintx card_size_min = 128;\n-  static const uintx card_size_max = 1024;\n+  static const uint CardSizeMin = 512;\n+  static const uint CardSizeMax = 1024;\n@@ -245,1 +245,1 @@\n-  static void initialize_card_size(uintx min_card_size);\n+  static void initialize_card_size(uint min_card_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -697,1 +697,1 @@\n-  product(uintx, GCCardSizeInBytes, 512,                                    \\\n+  product(uint, GCCardSizeInBytes, 512,                                     \\\n@@ -699,1 +699,2 @@\n-          range(128, 1024)                                                  \\\n+          range(512, 1024)                                                  \\\n+          constraint(GCCardSizeInBytesConstraintFunc, AfterErgo)            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -427,0 +427,14 @@\n+JVMFlag::Error GCCardSizeInBytesConstraintFunc(uint value, bool verbose) {\n+  if(!(UseG1GC || UseParallelGC || UseSerialGC))\n+    return JVMFlag::SUCCESS;\n+  if (!is_power_of_2(value)) {\n+    JVMFlag::printError(verbose,\n+                        \"GCCardSizeInBytes (\" UINT32_FORMAT \") must be \"\n+                        \"a power of 2\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  } else {\n+    return JVMFlag::SUCCESS;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n- f(size_t, MaxMetaspaceSizeConstraintFunc)\n+ f(size_t, MaxMetaspaceSizeConstraintFunc)                     \\\n+ f(uint, GCCardSizeInBytesConstraintFunc)\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}