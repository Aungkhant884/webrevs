{"files":[{"patch":"@@ -1663,1 +1663,1 @@\n-  guarantee(heap_rs.base() >= (char*)G1CardTable::card_size, \"Java heap must not start within the first card.\");\n+  guarantee(heap_rs.base() >= (char*)(uintptr_t)(G1CardTable::card_size), \"Java heap must not start within the first card.\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,3 @@\n+  \/\/ Initialize card size\n+  CardTable::initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,10 @@\n+uint ObjectStartArray::block_shift = 0;\n+uint ObjectStartArray::block_size = 0;\n+uint ObjectStartArray::block_size_in_words = 0;\n+\n+void ObjectStartArray::initialize_block_size(uint card_shift) {\n+  block_shift = card_shift;\n+  block_size = 1 << block_shift;\n+  block_size_in_words = block_size \/ sizeof(HeapWord);\n+}\n+\n@@ -38,1 +48,1 @@\n-  assert((int)block_size <= 512, \"block_size must be less than or equal to 512\");\n+  assert(block_size <= _max_block_size, \"block_size must be less than or equal to \" UINT32_FORMAT, _max_block_size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,5 +55,11 @@\n-  enum BlockSizeConstants {\n-    block_shift                  = 9,\n-    block_size                   = 1 << block_shift,\n-    block_size_in_words          = block_size \/ sizeof(HeapWord)\n-  };\n+  static uint block_shift;\n+  static uint block_size;\n+  static uint block_size_in_words;\n+\n+  \/\/ Maximum size an offset table entry can cover. This maximum is derived from that\n+  \/\/ we need an extra bit for possible offsets in the byte for backskip values, leaving 2^7 possible offsets.\n+  \/\/ Mininum object alignment is 8 bytes (2^3), so we can at most represent 2^10 offsets within a BOT value.\n+  static const uint _max_block_size = 1024;\n+\n+  \/\/ Initialize block size based on card size\n+  static void initialize_block_size(uint card_shift);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,12 @@\n+uint BOTConstants::LogN = 0;\n+uint BOTConstants::LogN_words = 0;\n+uint BOTConstants::N_bytes = 0;\n+uint BOTConstants::N_words = 0;\n+\n+void BOTConstants::initialize_bot_size(uint card_shift) {\n+  LogN =  card_shift;\n+  LogN_words = LogN - LogHeapWordSize;\n+  N_bytes = 1 << LogN;\n+  N_words = 1 << LogN_words;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -52,4 +53,5 @@\n-  static const uint LogN = 9;\n-  static const uint LogN_words = LogN - LogHeapWordSize;\n-  static const uint N_bytes = 1 << LogN;\n-  static const uint N_words = 1 << LogN_words;\n+  static uint LogN;\n+  static uint LogN_words;\n+  static uint N_bytes;\n+  static uint N_words;\n+\n@@ -62,0 +64,3 @@\n+  \/\/ Initialize bot size based on card size\n+  static void initialize_bot_size(uint card_shift);\n+\n@@ -96,0 +101,1 @@\n+    assert(BOTConstants::N_bytes == CardTable::card_size, \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/parallel\/objectStartArray.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -36,0 +39,24 @@\n+uint CardTable::card_shift = 0;\n+uint CardTable::card_size = 0;\n+uint CardTable::card_size_in_words = 0;\n+\n+void CardTable::initialize_card_size() {\n+  assert(UseG1GC || UseParallelGC || UseSerialGC,\n+         \"Initialize card size should only be called by card based collectors.\");\n+\n+  \/\/ Card size is the max. of minimum permissible value and GCCardSizeInBytes\n+  card_size = GCCardSizeInBytes;\n+  card_shift = log2i_exact(card_size);\n+  card_size_in_words = card_size \/ sizeof(HeapWord);\n+\n+  \/\/ Set blockOffsetTable size based on card table entry size\n+  BOTConstants::initialize_bot_size(card_shift);\n+\n+#if INCLUDE_PARALLELGC\n+  \/\/ Set ObjectStartArray block size based on card table entry size\n+  ObjectStartArray::initialize_block_size(card_shift);\n+#endif\n+\n+  log_info_p(gc, init)(\"CardTable entry size: \" UINT32_FORMAT,  card_size);\n+}\n+\n@@ -59,2 +86,0 @@\n-\n-  assert(card_size <= 512, \"card_size must be less than 512\"); \/\/ why?\n@@ -431,1 +456,2 @@\n-  return card_size * os::vm_page_size();\n+  \/\/ CardTable max alignment is computed with _card_size_max\n+  return _card_size_max * os::vm_page_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -231,6 +231,7 @@\n-  \/\/ Constants\n-  enum SomePublicConstants {\n-    card_shift                  = 9,\n-    card_size                   = 1 << card_shift,\n-    card_size_in_words          = card_size \/ sizeof(HeapWord)\n-  };\n+  \/\/ CardTable entry size\n+  static uint card_shift;\n+  static uint card_size;\n+  static uint card_size_in_words;\n+\n+  \/\/ max permissible card size\n+  static const uint _card_size_max = 1024;\n@@ -242,0 +243,3 @@\n+  \/\/ Initialize card size\n+  static void initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -695,3 +695,7 @@\n-          range(0, max_juint)\n-\n-\/\/ end of GC_FLAGS\n+          range(0, max_juint)                                               \\\n+                                                                            \\\n+  product(uint, GCCardSizeInBytes, 512,                                     \\\n+          \"Card table entry size (in bytes) for card based collectors\")     \\\n+          range(128, 1024)                                                  \\\n+          constraint(GCCardSizeInBytesConstraintFunc, AfterErgo)            \\\n+  \/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -64,0 +65,2 @@\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -427,0 +427,14 @@\n+JVMFlag::Error GCCardSizeInBytesConstraintFunc(uint value, bool verbose) {\n+  if(!(UseG1GC || UseParallelGC || UseSerialGC))\n+    return JVMFlag::SUCCESS;\n+  if (!is_power_of_2(value)) {\n+    JVMFlag::printError(verbose,\n+                        \"GCCardSizeInBytes (\" UINT32_FORMAT \") must be \"\n+                        \"a power of 2\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  } else {\n+    return JVMFlag::SUCCESS;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n- f(size_t, MaxMetaspaceSizeConstraintFunc)\n+ f(size_t, MaxMetaspaceSizeConstraintFunc)                     \\\n+ f(uint, GCCardSizeInBytesConstraintFunc)\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}